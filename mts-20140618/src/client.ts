// This file is auto-generated, don't edit it
/**
 *
 */
import Util, * as $Util from '@alicloud/tea-util';
import OpenApi, * as $OpenApi from '@alicloud/openapi-client';
import EndpointUtil from '@alicloud/endpoint-util';
import * as $tea from '@alicloud/tea-typescript';

export class ActivateMediaWorkflowRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  mediaWorkflowId?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      mediaWorkflowId: 'MediaWorkflowId',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      mediaWorkflowId: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ActivateMediaWorkflowResponseBody extends $tea.Model {
  requestId?: string;
  mediaWorkflow?: ActivateMediaWorkflowResponseBodyMediaWorkflow;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      mediaWorkflow: 'MediaWorkflow',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      mediaWorkflow: ActivateMediaWorkflowResponseBodyMediaWorkflow,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ActivateMediaWorkflowResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ActivateMediaWorkflowResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ActivateMediaWorkflowResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddAsrPipelineRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  name?: string;
  priority?: number;
  notifyConfig?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      name: 'Name',
      priority: 'Priority',
      notifyConfig: 'NotifyConfig',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      name: 'string',
      priority: 'number',
      notifyConfig: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddAsrPipelineResponseBody extends $tea.Model {
  requestId?: string;
  pipeline?: AddAsrPipelineResponseBodyPipeline;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      pipeline: 'Pipeline',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      pipeline: AddAsrPipelineResponseBodyPipeline,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddAsrPipelineResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: AddAsrPipelineResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: AddAsrPipelineResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddCategoryRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  cateName?: string;
  parentId?: number;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      cateName: 'CateName',
      parentId: 'ParentId',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      cateName: 'string',
      parentId: 'number',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddCategoryResponseBody extends $tea.Model {
  category?: AddCategoryResponseBodyCategory;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      category: 'Category',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: AddCategoryResponseBodyCategory,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddCategoryResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: AddCategoryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: AddCategoryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddCensorPipelineRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  name?: string;
  priority?: number;
  notifyConfig?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      name: 'Name',
      priority: 'Priority',
      notifyConfig: 'NotifyConfig',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      name: 'string',
      priority: 'number',
      notifyConfig: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddCensorPipelineResponseBody extends $tea.Model {
  requestId?: string;
  pipeline?: AddCensorPipelineResponseBodyPipeline;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      pipeline: 'Pipeline',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      pipeline: AddCensorPipelineResponseBodyPipeline,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddCensorPipelineResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: AddCensorPipelineResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: AddCensorPipelineResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddCoverPipelineRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  name?: string;
  priority?: string;
  notifyConfig?: string;
  role?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      name: 'Name',
      priority: 'Priority',
      notifyConfig: 'NotifyConfig',
      role: 'Role',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      name: 'string',
      priority: 'string',
      notifyConfig: 'string',
      role: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddCoverPipelineResponseBody extends $tea.Model {
  requestId?: string;
  pipeline?: AddCoverPipelineResponseBodyPipeline;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      pipeline: 'Pipeline',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      pipeline: AddCoverPipelineResponseBodyPipeline,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddCoverPipelineResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: AddCoverPipelineResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: AddCoverPipelineResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddMCTemplateRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  name?: string;
  porn?: string;
  terrorism?: string;
  politics?: string;
  ad?: string;
  qrcode?: string;
  live?: string;
  logo?: string;
  abuse?: string;
  contraband?: string;
  spam?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      name: 'Name',
      porn: 'Porn',
      terrorism: 'Terrorism',
      politics: 'Politics',
      ad: 'Ad',
      qrcode: 'Qrcode',
      live: 'Live',
      logo: 'Logo',
      abuse: 'Abuse',
      contraband: 'Contraband',
      spam: 'spam',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      name: 'string',
      porn: 'string',
      terrorism: 'string',
      politics: 'string',
      ad: 'string',
      qrcode: 'string',
      live: 'string',
      logo: 'string',
      abuse: 'string',
      contraband: 'string',
      spam: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddMCTemplateResponseBody extends $tea.Model {
  requestId?: string;
  template?: AddMCTemplateResponseBodyTemplate;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      template: 'Template',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      template: AddMCTemplateResponseBodyTemplate,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddMCTemplateResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: AddMCTemplateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: AddMCTemplateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddMediaRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  fileURL?: string;
  title?: string;
  description?: string;
  coverURL?: string;
  tags?: string;
  mediaWorkflowId?: string;
  mediaWorkflowUserData?: string;
  inputUnbind?: boolean;
  cateId?: number;
  overrideParams?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      fileURL: 'FileURL',
      title: 'Title',
      description: 'Description',
      coverURL: 'CoverURL',
      tags: 'Tags',
      mediaWorkflowId: 'MediaWorkflowId',
      mediaWorkflowUserData: 'MediaWorkflowUserData',
      inputUnbind: 'InputUnbind',
      cateId: 'CateId',
      overrideParams: 'OverrideParams',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      fileURL: 'string',
      title: 'string',
      description: 'string',
      coverURL: 'string',
      tags: 'string',
      mediaWorkflowId: 'string',
      mediaWorkflowUserData: 'string',
      inputUnbind: 'boolean',
      cateId: 'number',
      overrideParams: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddMediaResponseBody extends $tea.Model {
  requestId?: string;
  media?: AddMediaResponseBodyMedia;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      media: 'Media',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      media: AddMediaResponseBodyMedia,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddMediaResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: AddMediaResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: AddMediaResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddMediaTagRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  mediaId?: string;
  tag?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      mediaId: 'MediaId',
      tag: 'Tag',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      mediaId: 'string',
      tag: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddMediaTagResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddMediaTagResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: AddMediaTagResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: AddMediaTagResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddMediaWorkflowRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  name?: string;
  topology?: string;
  triggerMode?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      name: 'Name',
      topology: 'Topology',
      triggerMode: 'TriggerMode',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      name: 'string',
      topology: 'string',
      triggerMode: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddMediaWorkflowResponseBody extends $tea.Model {
  requestId?: string;
  mediaWorkflow?: AddMediaWorkflowResponseBodyMediaWorkflow;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      mediaWorkflow: 'MediaWorkflow',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      mediaWorkflow: AddMediaWorkflowResponseBodyMediaWorkflow,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddMediaWorkflowResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: AddMediaWorkflowResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: AddMediaWorkflowResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddPipelineRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  name?: string;
  speed?: string;
  speedLevel?: number;
  notifyConfig?: string;
  role?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      name: 'Name',
      speed: 'Speed',
      speedLevel: 'SpeedLevel',
      notifyConfig: 'NotifyConfig',
      role: 'Role',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      name: 'string',
      speed: 'string',
      speedLevel: 'number',
      notifyConfig: 'string',
      role: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddPipelineResponseBody extends $tea.Model {
  requestId?: string;
  pipeline?: AddPipelineResponseBodyPipeline;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      pipeline: 'Pipeline',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      pipeline: AddPipelineResponseBodyPipeline,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddPipelineResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: AddPipelineResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: AddPipelineResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddPornPipelineRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  name?: string;
  priority?: number;
  notifyConfig?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      name: 'Name',
      priority: 'Priority',
      notifyConfig: 'NotifyConfig',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      name: 'string',
      priority: 'number',
      notifyConfig: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddPornPipelineResponseBody extends $tea.Model {
  requestId?: string;
  pipeline?: AddPornPipelineResponseBodyPipeline;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      pipeline: 'Pipeline',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      pipeline: AddPornPipelineResponseBodyPipeline,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddPornPipelineResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: AddPornPipelineResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: AddPornPipelineResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddSmarttagTemplateRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  templateName?: string;
  industry?: string;
  scene?: string;
  analyseTypes?: string;
  faceCategoryIds?: string;
  isDefault?: boolean;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      templateName: 'TemplateName',
      industry: 'Industry',
      scene: 'Scene',
      analyseTypes: 'AnalyseTypes',
      faceCategoryIds: 'FaceCategoryIds',
      isDefault: 'IsDefault',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      templateName: 'string',
      industry: 'string',
      scene: 'string',
      analyseTypes: 'string',
      faceCategoryIds: 'string',
      isDefault: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddSmarttagTemplateResponseBody extends $tea.Model {
  requestId?: string;
  templateId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      templateId: 'TemplateId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      templateId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddSmarttagTemplateResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: AddSmarttagTemplateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: AddSmarttagTemplateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddTemplateRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  name?: string;
  container?: string;
  video?: string;
  audio?: string;
  transConfig?: string;
  muxConfig?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      name: 'Name',
      container: 'Container',
      video: 'Video',
      audio: 'Audio',
      transConfig: 'TransConfig',
      muxConfig: 'MuxConfig',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      name: 'string',
      container: 'string',
      video: 'string',
      audio: 'string',
      transConfig: 'string',
      muxConfig: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddTemplateResponseBody extends $tea.Model {
  requestId?: string;
  template?: AddTemplateResponseBodyTemplate;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      template: 'Template',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      template: AddTemplateResponseBodyTemplate,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddTemplateResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: AddTemplateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: AddTemplateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddTerrorismPipelineRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  name?: string;
  priority?: number;
  notifyConfig?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      name: 'Name',
      priority: 'Priority',
      notifyConfig: 'NotifyConfig',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      name: 'string',
      priority: 'number',
      notifyConfig: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddTerrorismPipelineResponseBody extends $tea.Model {
  requestId?: string;
  pipeline?: AddTerrorismPipelineResponseBodyPipeline;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      pipeline: 'Pipeline',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      pipeline: AddTerrorismPipelineResponseBodyPipeline,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddTerrorismPipelineResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: AddTerrorismPipelineResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: AddTerrorismPipelineResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddWaterMarkTemplateRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  name?: string;
  config?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      name: 'Name',
      config: 'Config',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      name: 'string',
      config: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddWaterMarkTemplateResponseBody extends $tea.Model {
  waterMarkTemplate?: AddWaterMarkTemplateResponseBodyWaterMarkTemplate;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      waterMarkTemplate: 'WaterMarkTemplate',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      waterMarkTemplate: AddWaterMarkTemplateResponseBodyWaterMarkTemplate,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddWaterMarkTemplateResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: AddWaterMarkTemplateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: AddWaterMarkTemplateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BindInputBucketRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  bucket?: string;
  roleArn?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      bucket: 'Bucket',
      roleArn: 'RoleArn',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      bucket: 'string',
      roleArn: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BindInputBucketResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BindInputBucketResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: BindInputBucketResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: BindInputBucketResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BindOutputBucketRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  bucket?: string;
  roleArn?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      bucket: 'Bucket',
      roleArn: 'RoleArn',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      bucket: 'string',
      roleArn: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BindOutputBucketResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BindOutputBucketResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: BindOutputBucketResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: BindOutputBucketResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelJobRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  jobId?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      jobId: 'JobId',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      jobId: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelJobResponseBody extends $tea.Model {
  requestId?: string;
  jobId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      jobId: 'JobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      jobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CancelJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CancelJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CategoryTreeRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CategoryTreeResponseBody extends $tea.Model {
  requestId?: string;
  categoryTree?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      categoryTree: 'CategoryTree',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      categoryTree: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CategoryTreeResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CategoryTreeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CategoryTreeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CheckResourceRequest extends $tea.Model {
  interrupt?: boolean;
  invoker?: string;
  pk?: string;
  bid?: string;
  hid?: number;
  country?: string;
  taskIdentifier?: string;
  taskExtraData?: string;
  gmtWakeup?: string;
  success?: boolean;
  message?: string;
  level?: number;
  url?: string;
  prompt?: string;
  static names(): { [key: string]: string } {
    return {
      interrupt: 'Interrupt',
      invoker: 'Invoker',
      pk: 'Pk',
      bid: 'Bid',
      hid: 'Hid',
      country: 'Country',
      taskIdentifier: 'TaskIdentifier',
      taskExtraData: 'TaskExtraData',
      gmtWakeup: 'GmtWakeup',
      success: 'Success',
      message: 'Message',
      level: 'Level',
      url: 'Url',
      prompt: 'Prompt',
    };
  }

  static types(): { [key: string]: any } {
    return {
      interrupt: 'boolean',
      invoker: 'string',
      pk: 'string',
      bid: 'string',
      hid: 'number',
      country: 'string',
      taskIdentifier: 'string',
      taskExtraData: 'string',
      gmtWakeup: 'string',
      success: 'boolean',
      message: 'string',
      level: 'number',
      url: 'string',
      prompt: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CheckResourceResponseBody extends $tea.Model {
  gmtWakeup?: string;
  hid?: number;
  message?: string;
  taskIdentifier?: string;
  success?: boolean;
  url?: string;
  interrupt?: boolean;
  invoker?: string;
  taskExtraData?: string;
  country?: string;
  prompt?: string;
  level?: number;
  pk?: string;
  bid?: string;
  static names(): { [key: string]: string } {
    return {
      gmtWakeup: 'GmtWakeup',
      hid: 'Hid',
      message: 'Message',
      taskIdentifier: 'TaskIdentifier',
      success: 'Success',
      url: 'Url',
      interrupt: 'Interrupt',
      invoker: 'Invoker',
      taskExtraData: 'TaskExtraData',
      country: 'Country',
      prompt: 'Prompt',
      level: 'Level',
      pk: 'Pk',
      bid: 'Bid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gmtWakeup: 'string',
      hid: 'number',
      message: 'string',
      taskIdentifier: 'string',
      success: 'boolean',
      url: 'string',
      interrupt: 'boolean',
      invoker: 'string',
      taskExtraData: 'string',
      country: 'string',
      prompt: 'string',
      level: 'number',
      pk: 'string',
      bid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CheckResourceResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CheckResourceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CheckResourceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFpShotDBRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  name?: string;
  modelId?: number;
  config?: string;
  description?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      name: 'Name',
      modelId: 'ModelId',
      config: 'Config',
      description: 'Description',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      name: 'string',
      modelId: 'number',
      config: 'string',
      description: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFpShotDBResponseBody extends $tea.Model {
  requestId?: string;
  fpShotDB?: CreateFpShotDBResponseBodyFpShotDB;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      fpShotDB: 'FpShotDB',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      fpShotDB: CreateFpShotDBResponseBodyFpShotDB,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFpShotDBResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateFpShotDBResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateFpShotDBResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMcuTemplateRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  template?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      template: 'Template',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      template: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMcuTemplateResponseBody extends $tea.Model {
  requestId?: string;
  templateId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      templateId: 'TemplateId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      templateId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMcuTemplateResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateMcuTemplateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateMcuTemplateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSessionRequest extends $tea.Model {
  ownerId?: string;
  resourceOwnerId?: string;
  resourceOwnerAccount?: string;
  ownerAccount?: string;
  endUserId?: string;
  sessionTime?: number;
  mediaId?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerId: 'ResourceOwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      ownerAccount: 'OwnerAccount',
      endUserId: 'EndUserId',
      sessionTime: 'SessionTime',
      mediaId: 'MediaId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'string',
      resourceOwnerId: 'string',
      resourceOwnerAccount: 'string',
      ownerAccount: 'string',
      endUserId: 'string',
      sessionTime: 'number',
      mediaId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSessionResponseBody extends $tea.Model {
  ticket?: string;
  requestId?: string;
  sessionId?: string;
  static names(): { [key: string]: string } {
    return {
      ticket: 'Ticket',
      requestId: 'RequestId',
      sessionId: 'SessionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ticket: 'string',
      requestId: 'string',
      sessionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSessionResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateSessionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateSessionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeactivateMediaWorkflowRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  mediaWorkflowId?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      mediaWorkflowId: 'MediaWorkflowId',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      mediaWorkflowId: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeactivateMediaWorkflowResponseBody extends $tea.Model {
  requestId?: string;
  mediaWorkflow?: DeactivateMediaWorkflowResponseBodyMediaWorkflow;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      mediaWorkflow: 'MediaWorkflow',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      mediaWorkflow: DeactivateMediaWorkflowResponseBodyMediaWorkflow,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeactivateMediaWorkflowResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeactivateMediaWorkflowResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeactivateMediaWorkflowResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DecryptKeyRequest extends $tea.Model {
  ownerId?: string;
  resourceOwnerId?: string;
  resourceOwnerAccount?: string;
  ownerAccount?: string;
  ciphertextBlob?: string;
  rand?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerId: 'ResourceOwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      ownerAccount: 'OwnerAccount',
      ciphertextBlob: 'CiphertextBlob',
      rand: 'Rand',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'string',
      resourceOwnerId: 'string',
      resourceOwnerAccount: 'string',
      ownerAccount: 'string',
      ciphertextBlob: 'string',
      rand: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DecryptKeyResponseBody extends $tea.Model {
  rand?: string;
  requestId?: string;
  plaintext?: string;
  static names(): { [key: string]: string } {
    return {
      rand: 'Rand',
      requestId: 'RequestId',
      plaintext: 'Plaintext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      rand: 'string',
      requestId: 'string',
      plaintext: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DecryptKeyResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DecryptKeyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DecryptKeyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCategoryRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  cateId?: number;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      cateId: 'CateId',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      cateId: 'number',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCategoryResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCategoryResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteCategoryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteCategoryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMCTemplateRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  templateId?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      templateId: 'TemplateId',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      templateId: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMCTemplateResponseBody extends $tea.Model {
  requestId?: string;
  templateId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      templateId: 'TemplateId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      templateId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMCTemplateResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteMCTemplateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteMCTemplateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMcuJobRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  jobIds?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      jobIds: 'JobIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      jobIds: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMcuJobResponseBody extends $tea.Model {
  nonExistJobIds?: DeleteMcuJobResponseBodyNonExistJobIds;
  requestId?: string;
  deletedJobIds?: DeleteMcuJobResponseBodyDeletedJobIds;
  static names(): { [key: string]: string } {
    return {
      nonExistJobIds: 'NonExistJobIds',
      requestId: 'RequestId',
      deletedJobIds: 'DeletedJobIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nonExistJobIds: DeleteMcuJobResponseBodyNonExistJobIds,
      requestId: 'string',
      deletedJobIds: DeleteMcuJobResponseBodyDeletedJobIds,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMcuJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteMcuJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteMcuJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMcuTemplateRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  templateId?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      templateId: 'TemplateId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      templateId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMcuTemplateResponseBody extends $tea.Model {
  requestId?: string;
  templateId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      templateId: 'TemplateId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      templateId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMcuTemplateResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteMcuTemplateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteMcuTemplateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMediaRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  mediaIds?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      mediaIds: 'MediaIds',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      mediaIds: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMediaResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMediaResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteMediaResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteMediaResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMediaTagRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  mediaId?: string;
  tag?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      mediaId: 'MediaId',
      tag: 'Tag',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      mediaId: 'string',
      tag: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMediaTagResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMediaTagResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteMediaTagResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteMediaTagResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMediaWorkflowRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  mediaWorkflowId?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      mediaWorkflowId: 'MediaWorkflowId',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      mediaWorkflowId: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMediaWorkflowResponseBody extends $tea.Model {
  requestId?: string;
  mediaWorkflow?: DeleteMediaWorkflowResponseBodyMediaWorkflow;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      mediaWorkflow: 'MediaWorkflow',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      mediaWorkflow: DeleteMediaWorkflowResponseBodyMediaWorkflow,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMediaWorkflowResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteMediaWorkflowResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteMediaWorkflowResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeletePipelineRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  pipelineId?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      pipelineId: 'PipelineId',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      pipelineId: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeletePipelineResponseBody extends $tea.Model {
  requestId?: string;
  pipelineId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      pipelineId: 'PipelineId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      pipelineId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeletePipelineResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeletePipelineResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeletePipelineResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSmarttagTemplateRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  templateId?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      templateId: 'TemplateId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      templateId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSmarttagTemplateResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSmarttagTemplateResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteSmarttagTemplateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteSmarttagTemplateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTemplateRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  templateId?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      templateId: 'TemplateId',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      templateId: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTemplateResponseBody extends $tea.Model {
  requestId?: string;
  templateId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      templateId: 'TemplateId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      templateId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTemplateResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteTemplateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteTemplateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWaterMarkTemplateRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  waterMarkTemplateId?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      waterMarkTemplateId: 'WaterMarkTemplateId',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      waterMarkTemplateId: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWaterMarkTemplateResponseBody extends $tea.Model {
  requestId?: string;
  waterMarkTemplateId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      waterMarkTemplateId: 'WaterMarkTemplateId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      waterMarkTemplateId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWaterMarkTemplateResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteWaterMarkTemplateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteWaterMarkTemplateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMtsUserResourcePackageRequest extends $tea.Model {
  securityToken?: string;
  ownerId?: number;
  showLog?: string;
  static names(): { [key: string]: string } {
    return {
      securityToken: 'SecurityToken',
      ownerId: 'OwnerId',
      showLog: 'ShowLog',
    };
  }

  static types(): { [key: string]: any } {
    return {
      securityToken: 'string',
      ownerId: 'number',
      showLog: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMtsUserResourcePackageResponseBody extends $tea.Model {
  requestId?: string;
  resourcePackageInfos?: DescribeMtsUserResourcePackageResponseBodyResourcePackageInfos;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      resourcePackageInfos: 'ResourcePackageInfos',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      resourcePackageInfos: DescribeMtsUserResourcePackageResponseBodyResourcePackageInfos,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMtsUserResourcePackageResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeMtsUserResourcePackageResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeMtsUserResourcePackageResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetLicenseRequest extends $tea.Model {
  ownerId?: string;
  resourceOwnerId?: string;
  resourceOwnerAccount?: string;
  ownerAccount?: string;
  licenseUrl?: string;
  data?: string;
  mediaId?: string;
  header?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerId: 'ResourceOwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      ownerAccount: 'OwnerAccount',
      licenseUrl: 'LicenseUrl',
      data: 'Data',
      mediaId: 'MediaId',
      header: 'Header',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'string',
      resourceOwnerId: 'string',
      resourceOwnerAccount: 'string',
      ownerAccount: 'string',
      licenseUrl: 'string',
      data: 'string',
      mediaId: 'string',
      header: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetLicenseResponseBody extends $tea.Model {
  requestId?: string;
  license?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      license: 'License',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      license: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetLicenseResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: GetLicenseResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: GetLicenseResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPackageRequest extends $tea.Model {
  ownerId?: string;
  resourceOwnerId?: string;
  resourceOwnerAccount?: string;
  ownerAccount?: string;
  data?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerId: 'ResourceOwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      ownerAccount: 'OwnerAccount',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'string',
      resourceOwnerId: 'string',
      resourceOwnerAccount: 'string',
      ownerAccount: 'string',
      data: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPackageResponseBody extends $tea.Model {
  certPackage?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      certPackage: 'CertPackage',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      certPackage: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPackageResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: GetPackageResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: GetPackageResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAllCategoryRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAllCategoryResponseBody extends $tea.Model {
  categoryList?: ListAllCategoryResponseBodyCategoryList;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      categoryList: 'CategoryList',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      categoryList: ListAllCategoryResponseBodyCategoryList,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAllCategoryResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListAllCategoryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListAllCategoryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAllMediaBucketRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  nextPageToken?: string;
  maximumPageSize?: number;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      nextPageToken: 'NextPageToken',
      maximumPageSize: 'MaximumPageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      nextPageToken: 'string',
      maximumPageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAllMediaBucketResponseBody extends $tea.Model {
  requestId?: string;
  nextPageToken?: string;
  mediaBucketList?: ListAllMediaBucketResponseBodyMediaBucketList;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      nextPageToken: 'NextPageToken',
      mediaBucketList: 'MediaBucketList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      nextPageToken: 'string',
      mediaBucketList: ListAllMediaBucketResponseBodyMediaBucketList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAllMediaBucketResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListAllMediaBucketResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListAllMediaBucketResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAsrPipelineRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  pageSize?: number;
  pageNumber?: number;
  state?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      pageSize: 'PageSize',
      pageNumber: 'PageNumber',
      state: 'State',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      pageSize: 'number',
      pageNumber: 'number',
      state: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAsrPipelineResponseBody extends $tea.Model {
  totalCount?: number;
  pageSize?: number;
  requestId?: string;
  pageNumber?: number;
  pipelineList?: ListAsrPipelineResponseBodyPipelineList;
  static names(): { [key: string]: string } {
    return {
      totalCount: 'TotalCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      pageNumber: 'PageNumber',
      pipelineList: 'PipelineList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      pageNumber: 'number',
      pipelineList: ListAsrPipelineResponseBodyPipelineList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAsrPipelineResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListAsrPipelineResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListAsrPipelineResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCensorPipelineRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  pageSize?: number;
  pageNumber?: number;
  state?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      pageSize: 'PageSize',
      pageNumber: 'PageNumber',
      state: 'State',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      pageSize: 'number',
      pageNumber: 'number',
      state: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCensorPipelineResponseBody extends $tea.Model {
  totalCount?: number;
  pageSize?: number;
  requestId?: string;
  pageNumber?: number;
  pipelineList?: ListCensorPipelineResponseBodyPipelineList;
  static names(): { [key: string]: string } {
    return {
      totalCount: 'TotalCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      pageNumber: 'PageNumber',
      pipelineList: 'PipelineList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      pageNumber: 'number',
      pipelineList: ListCensorPipelineResponseBodyPipelineList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCensorPipelineResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListCensorPipelineResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListCensorPipelineResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCoverPipelineRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  pageSize?: number;
  pageNumber?: number;
  state?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      pageSize: 'PageSize',
      pageNumber: 'PageNumber',
      state: 'State',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      pageSize: 'number',
      pageNumber: 'number',
      state: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCoverPipelineResponseBody extends $tea.Model {
  totalCount?: number;
  pageSize?: number;
  requestId?: string;
  pageNumber?: number;
  pipelineList?: ListCoverPipelineResponseBodyPipelineList;
  static names(): { [key: string]: string } {
    return {
      totalCount: 'TotalCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      pageNumber: 'PageNumber',
      pipelineList: 'PipelineList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      pageNumber: 'number',
      pipelineList: ListCoverPipelineResponseBodyPipelineList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCoverPipelineResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListCoverPipelineResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListCoverPipelineResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCustomPersonsRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  categoryId?: string;
  personId?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      categoryId: 'CategoryId',
      personId: 'PersonId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      categoryId: 'string',
      personId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCustomPersonsResponseBody extends $tea.Model {
  requestId?: string;
  categories?: ListCustomPersonsResponseBodyCategories;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      categories: 'Categories',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      categories: ListCustomPersonsResponseBodyCategories,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCustomPersonsResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListCustomPersonsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListCustomPersonsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFpShotDBRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  fpDBIds?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      fpDBIds: 'FpDBIds',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      fpDBIds: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFpShotDBResponseBody extends $tea.Model {
  fpShotDBList?: ListFpShotDBResponseBodyFpShotDBList;
  requestId?: string;
  nonExistIds?: ListFpShotDBResponseBodyNonExistIds;
  static names(): { [key: string]: string } {
    return {
      fpShotDBList: 'FpShotDBList',
      requestId: 'RequestId',
      nonExistIds: 'NonExistIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fpShotDBList: ListFpShotDBResponseBodyFpShotDBList,
      requestId: 'string',
      nonExistIds: ListFpShotDBResponseBodyNonExistIds,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFpShotDBResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListFpShotDBResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListFpShotDBResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFpShotFilesRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  nextPageToken?: string;
  pageSize?: number;
  fpDBId?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      nextPageToken: 'NextPageToken',
      pageSize: 'PageSize',
      fpDBId: 'FpDBId',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      nextPageToken: 'string',
      pageSize: 'number',
      fpDBId: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFpShotFilesResponseBody extends $tea.Model {
  requestId?: string;
  nextPageToken?: string;
  fpShotFileList?: ListFpShotFilesResponseBodyFpShotFileList;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      nextPageToken: 'NextPageToken',
      fpShotFileList: 'FpShotFileList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      nextPageToken: 'string',
      fpShotFileList: ListFpShotFilesResponseBodyFpShotFileList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFpShotFilesResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListFpShotFilesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListFpShotFilesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFpShotNotaryRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  nextPageToken?: string;
  maximumPageSize?: number;
  startOfCreatedTimeRange?: string;
  endOfCreatedTimeRange?: string;
  fpDBId?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      nextPageToken: 'NextPageToken',
      maximumPageSize: 'MaximumPageSize',
      startOfCreatedTimeRange: 'StartOfCreatedTimeRange',
      endOfCreatedTimeRange: 'EndOfCreatedTimeRange',
      fpDBId: 'FpDBId',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      nextPageToken: 'string',
      maximumPageSize: 'number',
      startOfCreatedTimeRange: 'string',
      endOfCreatedTimeRange: 'string',
      fpDBId: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFpShotNotaryResponseBody extends $tea.Model {
  requestId?: string;
  fpShotNotaryList?: ListFpShotNotaryResponseBodyFpShotNotaryList;
  nextPageToken?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      fpShotNotaryList: 'FpShotNotaryList',
      nextPageToken: 'NextPageToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      fpShotNotaryList: ListFpShotNotaryResponseBodyFpShotNotaryList,
      nextPageToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFpShotNotaryResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListFpShotNotaryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListFpShotNotaryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  nextPageToken?: string;
  maximumPageSize?: number;
  state?: string;
  startOfJobCreatedTimeRange?: string;
  endOfJobCreatedTimeRange?: string;
  pipelineId?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      nextPageToken: 'NextPageToken',
      maximumPageSize: 'MaximumPageSize',
      state: 'State',
      startOfJobCreatedTimeRange: 'StartOfJobCreatedTimeRange',
      endOfJobCreatedTimeRange: 'EndOfJobCreatedTimeRange',
      pipelineId: 'PipelineId',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      nextPageToken: 'string',
      maximumPageSize: 'number',
      state: 'string',
      startOfJobCreatedTimeRange: 'string',
      endOfJobCreatedTimeRange: 'string',
      pipelineId: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobResponseBody extends $tea.Model {
  requestId?: string;
  nextPageToken?: string;
  jobList?: ListJobResponseBodyJobList;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      nextPageToken: 'NextPageToken',
      jobList: 'JobList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      nextPageToken: 'string',
      jobList: ListJobResponseBodyJobList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMediaRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  nextPageToken?: string;
  maximumPageSize?: number;
  from?: string;
  to?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      nextPageToken: 'NextPageToken',
      maximumPageSize: 'MaximumPageSize',
      from: 'From',
      to: 'To',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      nextPageToken: 'string',
      maximumPageSize: 'number',
      from: 'string',
      to: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMediaResponseBody extends $tea.Model {
  mediaList?: ListMediaResponseBodyMediaList;
  requestId?: string;
  nextPageToken?: string;
  static names(): { [key: string]: string } {
    return {
      mediaList: 'MediaList',
      requestId: 'RequestId',
      nextPageToken: 'NextPageToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      mediaList: ListMediaResponseBodyMediaList,
      requestId: 'string',
      nextPageToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMediaResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListMediaResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListMediaResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMediaWorkflowExecutionsRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  mediaWorkflowId?: string;
  mediaWorkflowName?: string;
  inputFileURL?: string;
  nextPageToken?: string;
  maximumPageSize?: number;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      mediaWorkflowId: 'MediaWorkflowId',
      mediaWorkflowName: 'MediaWorkflowName',
      inputFileURL: 'InputFileURL',
      nextPageToken: 'NextPageToken',
      maximumPageSize: 'MaximumPageSize',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      mediaWorkflowId: 'string',
      mediaWorkflowName: 'string',
      inputFileURL: 'string',
      nextPageToken: 'string',
      maximumPageSize: 'number',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMediaWorkflowExecutionsResponseBody extends $tea.Model {
  mediaWorkflowExecutionList?: ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionList;
  requestId?: string;
  nextPageToken?: string;
  static names(): { [key: string]: string } {
    return {
      mediaWorkflowExecutionList: 'MediaWorkflowExecutionList',
      requestId: 'RequestId',
      nextPageToken: 'NextPageToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      mediaWorkflowExecutionList: ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionList,
      requestId: 'string',
      nextPageToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMediaWorkflowExecutionsResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListMediaWorkflowExecutionsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListMediaWorkflowExecutionsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPornPipelineRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  pageSize?: number;
  pageNumber?: number;
  state?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      pageSize: 'PageSize',
      pageNumber: 'PageNumber',
      state: 'State',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      pageSize: 'number',
      pageNumber: 'number',
      state: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPornPipelineResponseBody extends $tea.Model {
  totalCount?: number;
  pageSize?: number;
  requestId?: string;
  pageNumber?: number;
  pipelineList?: ListPornPipelineResponseBodyPipelineList;
  static names(): { [key: string]: string } {
    return {
      totalCount: 'TotalCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      pageNumber: 'PageNumber',
      pipelineList: 'PipelineList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      pageNumber: 'number',
      pipelineList: ListPornPipelineResponseBodyPipelineList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPornPipelineResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListPornPipelineResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListPornPipelineResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTerrorismPipelineRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  pageSize?: number;
  pageNumber?: number;
  state?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      pageSize: 'PageSize',
      pageNumber: 'PageNumber',
      state: 'State',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      pageSize: 'number',
      pageNumber: 'number',
      state: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTerrorismPipelineResponseBody extends $tea.Model {
  totalCount?: number;
  pageSize?: number;
  requestId?: string;
  pageNumber?: number;
  pipelineList?: ListTerrorismPipelineResponseBodyPipelineList;
  static names(): { [key: string]: string } {
    return {
      totalCount: 'TotalCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      pageNumber: 'PageNumber',
      pipelineList: 'PipelineList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      pageNumber: 'number',
      pipelineList: ListTerrorismPipelineResponseBodyPipelineList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTerrorismPipelineResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListTerrorismPipelineResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListTerrorismPipelineResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class LogicalDeleteResourceRequest extends $tea.Model {
  interrupt?: boolean;
  invoker?: string;
  pk?: string;
  bid?: string;
  hid?: number;
  country?: string;
  taskIdentifier?: string;
  taskExtraData?: string;
  gmtWakeup?: string;
  success?: boolean;
  message?: string;
  static names(): { [key: string]: string } {
    return {
      interrupt: 'Interrupt',
      invoker: 'Invoker',
      pk: 'Pk',
      bid: 'Bid',
      hid: 'Hid',
      country: 'Country',
      taskIdentifier: 'TaskIdentifier',
      taskExtraData: 'TaskExtraData',
      gmtWakeup: 'GmtWakeup',
      success: 'Success',
      message: 'Message',
    };
  }

  static types(): { [key: string]: any } {
    return {
      interrupt: 'boolean',
      invoker: 'string',
      pk: 'string',
      bid: 'string',
      hid: 'number',
      country: 'string',
      taskIdentifier: 'string',
      taskExtraData: 'string',
      gmtWakeup: 'string',
      success: 'boolean',
      message: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class LogicalDeleteResourceResponseBody extends $tea.Model {
  gmtWakeup?: string;
  hid?: number;
  invoker?: string;
  message?: string;
  taskIdentifier?: string;
  taskExtraData?: string;
  country?: string;
  pk?: string;
  bid?: string;
  success?: boolean;
  interrupt?: boolean;
  static names(): { [key: string]: string } {
    return {
      gmtWakeup: 'GmtWakeup',
      hid: 'Hid',
      invoker: 'Invoker',
      message: 'Message',
      taskIdentifier: 'TaskIdentifier',
      taskExtraData: 'TaskExtraData',
      country: 'Country',
      pk: 'Pk',
      bid: 'Bid',
      success: 'Success',
      interrupt: 'Interrupt',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gmtWakeup: 'string',
      hid: 'number',
      invoker: 'string',
      message: 'string',
      taskIdentifier: 'string',
      taskExtraData: 'string',
      country: 'string',
      pk: 'string',
      bid: 'string',
      success: 'boolean',
      interrupt: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class LogicalDeleteResourceResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: LogicalDeleteResourceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: LogicalDeleteResourceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PhysicalDeleteResourceRequest extends $tea.Model {
  interrupt?: boolean;
  invoker?: string;
  pk?: string;
  bid?: string;
  hid?: number;
  country?: string;
  taskIdentifier?: string;
  taskExtraData?: string;
  gmtWakeup?: string;
  success?: boolean;
  message?: string;
  static names(): { [key: string]: string } {
    return {
      interrupt: 'Interrupt',
      invoker: 'Invoker',
      pk: 'Pk',
      bid: 'Bid',
      hid: 'Hid',
      country: 'Country',
      taskIdentifier: 'TaskIdentifier',
      taskExtraData: 'TaskExtraData',
      gmtWakeup: 'GmtWakeup',
      success: 'Success',
      message: 'Message',
    };
  }

  static types(): { [key: string]: any } {
    return {
      interrupt: 'boolean',
      invoker: 'string',
      pk: 'string',
      bid: 'string',
      hid: 'number',
      country: 'string',
      taskIdentifier: 'string',
      taskExtraData: 'string',
      gmtWakeup: 'string',
      success: 'boolean',
      message: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PhysicalDeleteResourceResponseBody extends $tea.Model {
  gmtWakeup?: string;
  hid?: number;
  invoker?: string;
  message?: string;
  taskIdentifier?: string;
  taskExtraData?: string;
  country?: string;
  pk?: string;
  bid?: string;
  success?: boolean;
  interrupt?: boolean;
  static names(): { [key: string]: string } {
    return {
      gmtWakeup: 'GmtWakeup',
      hid: 'Hid',
      invoker: 'Invoker',
      message: 'Message',
      taskIdentifier: 'TaskIdentifier',
      taskExtraData: 'TaskExtraData',
      country: 'Country',
      pk: 'Pk',
      bid: 'Bid',
      success: 'Success',
      interrupt: 'Interrupt',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gmtWakeup: 'string',
      hid: 'number',
      invoker: 'string',
      message: 'string',
      taskIdentifier: 'string',
      taskExtraData: 'string',
      country: 'string',
      pk: 'string',
      bid: 'string',
      success: 'boolean',
      interrupt: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PhysicalDeleteResourceResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: PhysicalDeleteResourceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: PhysicalDeleteResourceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PlayerAuthRequest extends $tea.Model {
  ownerId?: string;
  resourceOwnerId?: string;
  resourceOwnerAccount?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerId: 'ResourceOwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'string',
      resourceOwnerId: 'string',
      resourceOwnerAccount: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PlayerAuthResponseBody extends $tea.Model {
  requestId?: string;
  logURL?: string;
  switchList?: PlayerAuthResponseBodySwitchList;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      logURL: 'LogURL',
      switchList: 'SwitchList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      logURL: 'string',
      switchList: PlayerAuthResponseBodySwitchList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PlayerAuthResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: PlayerAuthResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: PlayerAuthResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PlayInfoRequest extends $tea.Model {
  ownerId?: string;
  resourceOwnerId?: string;
  resourceOwnerAccount?: string;
  ownerAccount?: string;
  mediaId?: string;
  formats?: string;
  authInfo?: string;
  authTimeout?: number;
  rand?: string;
  playDomain?: string;
  hlsUriToken?: string;
  terminal?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerId: 'ResourceOwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      ownerAccount: 'OwnerAccount',
      mediaId: 'MediaId',
      formats: 'Formats',
      authInfo: 'AuthInfo',
      authTimeout: 'AuthTimeout',
      rand: 'Rand',
      playDomain: 'PlayDomain',
      hlsUriToken: 'HlsUriToken',
      terminal: 'Terminal',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'string',
      resourceOwnerId: 'string',
      resourceOwnerAccount: 'string',
      ownerAccount: 'string',
      mediaId: 'string',
      formats: 'string',
      authInfo: 'string',
      authTimeout: 'number',
      rand: 'string',
      playDomain: 'string',
      hlsUriToken: 'string',
      terminal: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PlayInfoResponseBody extends $tea.Model {
  requestId?: string;
  notFoundCDNDomain?: PlayInfoResponseBodyNotFoundCDNDomain;
  playInfoList?: PlayInfoResponseBodyPlayInfoList;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      notFoundCDNDomain: 'NotFoundCDNDomain',
      playInfoList: 'PlayInfoList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      notFoundCDNDomain: PlayInfoResponseBodyNotFoundCDNDomain,
      playInfoList: PlayInfoResponseBodyPlayInfoList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PlayInfoResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: PlayInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: PlayInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAnalysisJobListRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  analysisJobIds?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      analysisJobIds: 'AnalysisJobIds',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      analysisJobIds: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAnalysisJobListResponseBody extends $tea.Model {
  requestId?: string;
  analysisJobList?: QueryAnalysisJobListResponseBodyAnalysisJobList;
  nonExistAnalysisJobIds?: QueryAnalysisJobListResponseBodyNonExistAnalysisJobIds;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      analysisJobList: 'AnalysisJobList',
      nonExistAnalysisJobIds: 'NonExistAnalysisJobIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      analysisJobList: QueryAnalysisJobListResponseBodyAnalysisJobList,
      nonExistAnalysisJobIds: QueryAnalysisJobListResponseBodyNonExistAnalysisJobIds,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAnalysisJobListResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryAnalysisJobListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryAnalysisJobListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAnnotationJobListRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  annotationJobIds?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      annotationJobIds: 'AnnotationJobIds',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      annotationJobIds: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAnnotationJobListResponseBody extends $tea.Model {
  annotationJobList?: QueryAnnotationJobListResponseBodyAnnotationJobList;
  requestId?: string;
  nonExistIds?: QueryAnnotationJobListResponseBodyNonExistIds;
  static names(): { [key: string]: string } {
    return {
      annotationJobList: 'AnnotationJobList',
      requestId: 'RequestId',
      nonExistIds: 'NonExistIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      annotationJobList: QueryAnnotationJobListResponseBodyAnnotationJobList,
      requestId: 'string',
      nonExistIds: QueryAnnotationJobListResponseBodyNonExistIds,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAnnotationJobListResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryAnnotationJobListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryAnnotationJobListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAsrJobListRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  jobIds?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      jobIds: 'JobIds',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      jobIds: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAsrJobListResponseBody extends $tea.Model {
  requestId?: string;
  jobList?: QueryAsrJobListResponseBodyJobList;
  nonExistIds?: QueryAsrJobListResponseBodyNonExistIds;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      jobList: 'JobList',
      nonExistIds: 'NonExistIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      jobList: QueryAsrJobListResponseBodyJobList,
      nonExistIds: QueryAsrJobListResponseBodyNonExistIds,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAsrJobListResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryAsrJobListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryAsrJobListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAsrPipelineListRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  pipelineIds?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      pipelineIds: 'PipelineIds',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      pipelineIds: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAsrPipelineListResponseBody extends $tea.Model {
  requestId?: string;
  pipelineList?: QueryAsrPipelineListResponseBodyPipelineList;
  nonExistIds?: QueryAsrPipelineListResponseBodyNonExistIds;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      pipelineList: 'PipelineList',
      nonExistIds: 'NonExistIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      pipelineList: QueryAsrPipelineListResponseBodyPipelineList,
      nonExistIds: QueryAsrPipelineListResponseBodyNonExistIds,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAsrPipelineListResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryAsrPipelineListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryAsrPipelineListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAuthConfigRequest extends $tea.Model {
  ownerId?: string;
  resourceOwnerId?: string;
  resourceOwnerAccount?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerId: 'ResourceOwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'string',
      resourceOwnerId: 'string',
      resourceOwnerAccount: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAuthConfigResponseBody extends $tea.Model {
  key2?: string;
  key1?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      key2: 'Key2',
      key1: 'Key1',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key2: 'string',
      key1: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAuthConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryAuthConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryAuthConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCensorJobListRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  jobIds?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      jobIds: 'JobIds',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      jobIds: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCensorJobListResponseBody extends $tea.Model {
  requestId?: string;
  censorJobList?: QueryCensorJobListResponseBodyCensorJobList;
  nonExistIds?: QueryCensorJobListResponseBodyNonExistIds;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      censorJobList: 'CensorJobList',
      nonExistIds: 'NonExistIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      censorJobList: QueryCensorJobListResponseBodyCensorJobList,
      nonExistIds: QueryCensorJobListResponseBodyNonExistIds,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCensorJobListResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryCensorJobListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryCensorJobListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCensorPipelineListRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  pipelineIds?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      pipelineIds: 'PipelineIds',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      pipelineIds: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCensorPipelineListResponseBody extends $tea.Model {
  requestId?: string;
  pipelineList?: QueryCensorPipelineListResponseBodyPipelineList;
  nonExistIds?: QueryCensorPipelineListResponseBodyNonExistIds;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      pipelineList: 'PipelineList',
      nonExistIds: 'NonExistIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      pipelineList: QueryCensorPipelineListResponseBodyPipelineList,
      nonExistIds: QueryCensorPipelineListResponseBodyNonExistIds,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCensorPipelineListResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryCensorPipelineListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryCensorPipelineListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryComplexJobListRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  jobIds?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      jobIds: 'JobIds',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      jobIds: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryComplexJobListResponseBody extends $tea.Model {
  nonExistJobIds?: QueryComplexJobListResponseBodyNonExistJobIds;
  requestId?: string;
  jobList?: QueryComplexJobListResponseBodyJobList;
  static names(): { [key: string]: string } {
    return {
      nonExistJobIds: 'NonExistJobIds',
      requestId: 'RequestId',
      jobList: 'JobList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nonExistJobIds: QueryComplexJobListResponseBodyNonExistJobIds,
      requestId: 'string',
      jobList: QueryComplexJobListResponseBodyJobList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryComplexJobListResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryComplexJobListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryComplexJobListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCoverJobListRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  coverJobIds?: string;
  nextPageToken?: string;
  maximumPageSize?: number;
  state?: string;
  startOfJobCreatedTimeRange?: string;
  endOfJobCreatedTimeRange?: string;
  pipelineId?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      coverJobIds: 'CoverJobIds',
      nextPageToken: 'NextPageToken',
      maximumPageSize: 'MaximumPageSize',
      state: 'State',
      startOfJobCreatedTimeRange: 'StartOfJobCreatedTimeRange',
      endOfJobCreatedTimeRange: 'EndOfJobCreatedTimeRange',
      pipelineId: 'PipelineId',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      coverJobIds: 'string',
      nextPageToken: 'string',
      maximumPageSize: 'number',
      state: 'string',
      startOfJobCreatedTimeRange: 'string',
      endOfJobCreatedTimeRange: 'string',
      pipelineId: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCoverJobListResponseBody extends $tea.Model {
  coverJobList?: QueryCoverJobListResponseBodyCoverJobList;
  requestId?: string;
  nextPageToken?: string;
  nonExistIds?: QueryCoverJobListResponseBodyNonExistIds;
  static names(): { [key: string]: string } {
    return {
      coverJobList: 'CoverJobList',
      requestId: 'RequestId',
      nextPageToken: 'NextPageToken',
      nonExistIds: 'NonExistIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      coverJobList: QueryCoverJobListResponseBodyCoverJobList,
      requestId: 'string',
      nextPageToken: 'string',
      nonExistIds: QueryCoverJobListResponseBodyNonExistIds,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCoverJobListResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryCoverJobListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryCoverJobListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCoverPipelineListRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  pipelineIds?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      pipelineIds: 'PipelineIds',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      pipelineIds: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCoverPipelineListResponseBody extends $tea.Model {
  requestId?: string;
  pipelineList?: QueryCoverPipelineListResponseBodyPipelineList;
  nonExistIds?: QueryCoverPipelineListResponseBodyNonExistIds;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      pipelineList: 'PipelineList',
      nonExistIds: 'NonExistIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      pipelineList: QueryCoverPipelineListResponseBodyPipelineList,
      nonExistIds: QueryCoverPipelineListResponseBodyNonExistIds,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCoverPipelineListResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryCoverPipelineListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryCoverPipelineListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEditingJobListRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  jobIds?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      jobIds: 'JobIds',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      jobIds: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEditingJobListResponseBody extends $tea.Model {
  nonExistJobIds?: QueryEditingJobListResponseBodyNonExistJobIds;
  requestId?: string;
  jobList?: QueryEditingJobListResponseBodyJobList;
  static names(): { [key: string]: string } {
    return {
      nonExistJobIds: 'NonExistJobIds',
      requestId: 'RequestId',
      jobList: 'JobList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nonExistJobIds: QueryEditingJobListResponseBodyNonExistJobIds,
      requestId: 'string',
      jobList: QueryEditingJobListResponseBodyJobList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEditingJobListResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryEditingJobListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryEditingJobListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryFacerecogJobListRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  facerecogJobIds?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      facerecogJobIds: 'FacerecogJobIds',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      facerecogJobIds: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryFacerecogJobListResponseBody extends $tea.Model {
  requestId?: string;
  nonExistIds?: QueryFacerecogJobListResponseBodyNonExistIds;
  facerecogJobList?: QueryFacerecogJobListResponseBodyFacerecogJobList;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      nonExistIds: 'NonExistIds',
      facerecogJobList: 'FacerecogJobList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      nonExistIds: QueryFacerecogJobListResponseBodyNonExistIds,
      facerecogJobList: QueryFacerecogJobListResponseBodyFacerecogJobList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryFacerecogJobListResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryFacerecogJobListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryFacerecogJobListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryFpCompareJobListRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  jobIds?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      jobIds: 'JobIds',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      jobIds: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryFpCompareJobListResponseBody extends $tea.Model {
  fpCompareJobList?: QueryFpCompareJobListResponseBodyFpCompareJobList;
  requestId?: string;
  nonExistIds?: QueryFpCompareJobListResponseBodyNonExistIds;
  static names(): { [key: string]: string } {
    return {
      fpCompareJobList: 'FpCompareJobList',
      requestId: 'RequestId',
      nonExistIds: 'NonExistIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fpCompareJobList: QueryFpCompareJobListResponseBodyFpCompareJobList,
      requestId: 'string',
      nonExistIds: QueryFpCompareJobListResponseBodyNonExistIds,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryFpCompareJobListResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryFpCompareJobListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryFpCompareJobListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryFpDBDeleteJobListRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  jobIds?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      jobIds: 'JobIds',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      jobIds: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryFpDBDeleteJobListResponseBody extends $tea.Model {
  requestId?: string;
  fpDBDeleteJobList?: QueryFpDBDeleteJobListResponseBodyFpDBDeleteJobList;
  nonExistIds?: QueryFpDBDeleteJobListResponseBodyNonExistIds;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      fpDBDeleteJobList: 'FpDBDeleteJobList',
      nonExistIds: 'NonExistIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      fpDBDeleteJobList: QueryFpDBDeleteJobListResponseBodyFpDBDeleteJobList,
      nonExistIds: QueryFpDBDeleteJobListResponseBodyNonExistIds,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryFpDBDeleteJobListResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryFpDBDeleteJobListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryFpDBDeleteJobListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryFpFileDeleteJobListRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  jobIds?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      jobIds: 'JobIds',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      jobIds: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryFpFileDeleteJobListResponseBody extends $tea.Model {
  requestId?: string;
  fpFileDeleteJobList?: QueryFpFileDeleteJobListResponseBodyFpFileDeleteJobList;
  nonExistIds?: QueryFpFileDeleteJobListResponseBodyNonExistIds;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      fpFileDeleteJobList: 'FpFileDeleteJobList',
      nonExistIds: 'NonExistIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      fpFileDeleteJobList: QueryFpFileDeleteJobListResponseBodyFpFileDeleteJobList,
      nonExistIds: QueryFpFileDeleteJobListResponseBodyNonExistIds,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryFpFileDeleteJobListResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryFpFileDeleteJobListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryFpFileDeleteJobListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryFpImportResultRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  startTime?: number;
  endTime?: number;
  pageSize?: number;
  pageIndex?: number;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      startTime: 'StartTime',
      endTime: 'EndTime',
      pageSize: 'PageSize',
      pageIndex: 'PageIndex',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      startTime: 'number',
      endTime: 'number',
      pageSize: 'number',
      pageIndex: 'number',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryFpImportResultResponseBody extends $tea.Model {
  pageInfo?: QueryFpImportResultResponseBodyPageInfo;
  fpResultLogInfoList?: QueryFpImportResultResponseBodyFpResultLogInfoList;
  requestId?: string;
  logCount?: number;
  static names(): { [key: string]: string } {
    return {
      pageInfo: 'PageInfo',
      fpResultLogInfoList: 'FpResultLogInfoList',
      requestId: 'RequestId',
      logCount: 'LogCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageInfo: QueryFpImportResultResponseBodyPageInfo,
      fpResultLogInfoList: QueryFpImportResultResponseBodyFpResultLogInfoList,
      requestId: 'string',
      logCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryFpImportResultResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryFpImportResultResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryFpImportResultResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryFpShotJobListRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  jobIds?: string;
  nextPageToken?: string;
  maximumPageSize?: number;
  state?: string;
  startOfJobCreatedTimeRange?: string;
  endOfJobCreatedTimeRange?: string;
  primaryKeyList?: string;
  pipelineId?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      jobIds: 'JobIds',
      nextPageToken: 'NextPageToken',
      maximumPageSize: 'MaximumPageSize',
      state: 'State',
      startOfJobCreatedTimeRange: 'StartOfJobCreatedTimeRange',
      endOfJobCreatedTimeRange: 'EndOfJobCreatedTimeRange',
      primaryKeyList: 'PrimaryKeyList',
      pipelineId: 'PipelineId',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      jobIds: 'string',
      nextPageToken: 'string',
      maximumPageSize: 'number',
      state: 'string',
      startOfJobCreatedTimeRange: 'string',
      endOfJobCreatedTimeRange: 'string',
      primaryKeyList: 'string',
      pipelineId: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryFpShotJobListResponseBody extends $tea.Model {
  requestId?: string;
  nextPageToken?: string;
  nonExistPrimaryKeys?: QueryFpShotJobListResponseBodyNonExistPrimaryKeys;
  fpShotJobList?: QueryFpShotJobListResponseBodyFpShotJobList;
  nonExistIds?: QueryFpShotJobListResponseBodyNonExistIds;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      nextPageToken: 'NextPageToken',
      nonExistPrimaryKeys: 'NonExistPrimaryKeys',
      fpShotJobList: 'FpShotJobList',
      nonExistIds: 'NonExistIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      nextPageToken: 'string',
      nonExistPrimaryKeys: QueryFpShotJobListResponseBodyNonExistPrimaryKeys,
      fpShotJobList: QueryFpShotJobListResponseBodyFpShotJobList,
      nonExistIds: QueryFpShotJobListResponseBodyNonExistIds,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryFpShotJobListResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryFpShotJobListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryFpShotJobListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryImageSearchJobListRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  jobIds?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      jobIds: 'JobIds',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      jobIds: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryImageSearchJobListResponseBody extends $tea.Model {
  imageSearchJobList?: QueryImageSearchJobListResponseBodyImageSearchJobList;
  requestId?: string;
  nonExistIds?: QueryImageSearchJobListResponseBodyNonExistIds;
  static names(): { [key: string]: string } {
    return {
      imageSearchJobList: 'ImageSearchJobList',
      requestId: 'RequestId',
      nonExistIds: 'NonExistIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      imageSearchJobList: QueryImageSearchJobListResponseBodyImageSearchJobList,
      requestId: 'string',
      nonExistIds: QueryImageSearchJobListResponseBodyNonExistIds,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryImageSearchJobListResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryImageSearchJobListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryImageSearchJobListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryInnerJobRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  jobId?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      jobId: 'JobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      jobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryInnerJobResponseBody extends $tea.Model {
  status?: string;
  suggestion?: string;
  requestId?: string;
  video?: QueryInnerJobResponseBodyVideo;
  image?: QueryInnerJobResponseBodyImage;
  static names(): { [key: string]: string } {
    return {
      status: 'Status',
      suggestion: 'Suggestion',
      requestId: 'RequestId',
      video: 'Video',
      image: 'Image',
    };
  }

  static types(): { [key: string]: any } {
    return {
      status: 'string',
      suggestion: 'string',
      requestId: 'string',
      video: QueryInnerJobResponseBodyVideo,
      image: QueryInnerJobResponseBodyImage,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryInnerJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryInnerJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryInnerJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryIProductionJobRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  jobId?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      jobId: 'JobId',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      jobId: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryIProductionJobResponseBody extends $tea.Model {
  functionName?: string;
  input?: string;
  requestId?: string;
  userData?: string;
  state?: string;
  output?: string;
  pipelineId?: string;
  jobParams?: string;
  jobId?: string;
  result?: string;
  static names(): { [key: string]: string } {
    return {
      functionName: 'FunctionName',
      input: 'Input',
      requestId: 'RequestId',
      userData: 'UserData',
      state: 'State',
      output: 'Output',
      pipelineId: 'PipelineId',
      jobParams: 'JobParams',
      jobId: 'JobId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      functionName: 'string',
      input: 'string',
      requestId: 'string',
      userData: 'string',
      state: 'string',
      output: 'string',
      pipelineId: 'string',
      jobParams: 'string',
      jobId: 'string',
      result: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryIProductionJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryIProductionJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryIProductionJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryIProductionJobListRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  IProductionJobIds?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      IProductionJobIds: 'IProductionJobIds',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      IProductionJobIds: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryIProductionJobListResponseBody extends $tea.Model {
  requestId?: string;
  jobs?: QueryIProductionJobListResponseBodyJobs;
  nextPageToken?: string;
  nonExistIds?: QueryIProductionJobListResponseBodyNonExistIds;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      jobs: 'Jobs',
      nextPageToken: 'NextPageToken',
      nonExistIds: 'NonExistIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      jobs: QueryIProductionJobListResponseBodyJobs,
      nextPageToken: 'string',
      nonExistIds: QueryIProductionJobListResponseBodyNonExistIds,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryIProductionJobListResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryIProductionJobListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryIProductionJobListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobListRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  jobIds?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      jobIds: 'JobIds',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      jobIds: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobListResponseBody extends $tea.Model {
  nonExistJobIds?: QueryJobListResponseBodyNonExistJobIds;
  requestId?: string;
  jobList?: QueryJobListResponseBodyJobList;
  static names(): { [key: string]: string } {
    return {
      nonExistJobIds: 'NonExistJobIds',
      requestId: 'RequestId',
      jobList: 'JobList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nonExistJobIds: QueryJobListResponseBodyNonExistJobIds,
      requestId: 'string',
      jobList: QueryJobListResponseBodyJobList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobListResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryJobListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryJobListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  jobIds?: string;
  nextPageToken?: string;
  maximumPageSize?: number;
  state?: string;
  startOfJobCreatedTimeRange?: string;
  endOfJobCreatedTimeRange?: string;
  pipelineId?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      jobIds: 'JobIds',
      nextPageToken: 'NextPageToken',
      maximumPageSize: 'MaximumPageSize',
      state: 'State',
      startOfJobCreatedTimeRange: 'StartOfJobCreatedTimeRange',
      endOfJobCreatedTimeRange: 'EndOfJobCreatedTimeRange',
      pipelineId: 'PipelineId',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      jobIds: 'string',
      nextPageToken: 'string',
      maximumPageSize: 'number',
      state: 'string',
      startOfJobCreatedTimeRange: 'string',
      endOfJobCreatedTimeRange: 'string',
      pipelineId: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBody extends $tea.Model {
  requestId?: string;
  nextPageToken?: string;
  jobList?: QueryMCJobListResponseBodyJobList;
  nonExistIds?: QueryMCJobListResponseBodyNonExistIds;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      nextPageToken: 'NextPageToken',
      jobList: 'JobList',
      nonExistIds: 'NonExistIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      nextPageToken: 'string',
      jobList: QueryMCJobListResponseBodyJobList,
      nonExistIds: QueryMCJobListResponseBodyNonExistIds,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryMCJobListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryMCJobListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCTemplateListRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  templateIds?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      templateIds: 'TemplateIds',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      templateIds: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCTemplateListResponseBody extends $tea.Model {
  nonExistTids?: QueryMCTemplateListResponseBodyNonExistTids;
  templateList?: QueryMCTemplateListResponseBodyTemplateList;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      nonExistTids: 'NonExistTids',
      templateList: 'TemplateList',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nonExistTids: QueryMCTemplateListResponseBodyNonExistTids,
      templateList: QueryMCTemplateListResponseBodyTemplateList,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCTemplateListResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryMCTemplateListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryMCTemplateListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMcuJobRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  jobIds?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      jobIds: 'JobIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      jobIds: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMcuJobResponseBody extends $tea.Model {
  nonExistJobIds?: QueryMcuJobResponseBodyNonExistJobIds;
  requestId?: string;
  jobResult?: QueryMcuJobResponseBodyJobResult;
  static names(): { [key: string]: string } {
    return {
      nonExistJobIds: 'NonExistJobIds',
      requestId: 'RequestId',
      jobResult: 'JobResult',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nonExistJobIds: QueryMcuJobResponseBodyNonExistJobIds,
      requestId: 'string',
      jobResult: QueryMcuJobResponseBodyJobResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMcuJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryMcuJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryMcuJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMcuTemplateRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  templateId?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      templateId: 'TemplateId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      templateId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMcuTemplateResponseBody extends $tea.Model {
  requestId?: string;
  templates?: QueryMcuTemplateResponseBodyTemplates;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      templates: 'Templates',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      templates: QueryMcuTemplateResponseBodyTemplates,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMcuTemplateResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryMcuTemplateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryMcuTemplateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaCensorJobDetailRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  jobId?: string;
  ownerAccount?: string;
  nextPageToken?: string;
  maximumPageSize?: number;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      jobId: 'JobId',
      ownerAccount: 'OwnerAccount',
      nextPageToken: 'NextPageToken',
      maximumPageSize: 'MaximumPageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      jobId: 'string',
      ownerAccount: 'string',
      nextPageToken: 'string',
      maximumPageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaCensorJobDetailResponseBody extends $tea.Model {
  requestId?: string;
  mediaCensorJobDetail?: QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetail;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      mediaCensorJobDetail: 'MediaCensorJobDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      mediaCensorJobDetail: QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetail,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaCensorJobDetailResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryMediaCensorJobDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryMediaCensorJobDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaCensorJobListRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  jobId?: string;
  ownerAccount?: string;
  nextPageToken?: string;
  maximumPageSize?: number;
  state?: string;
  startOfJobCreatedTimeRange?: string;
  endOfJobCreatedTimeRange?: string;
  pipelineId?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      jobId: 'JobId',
      ownerAccount: 'OwnerAccount',
      nextPageToken: 'NextPageToken',
      maximumPageSize: 'MaximumPageSize',
      state: 'State',
      startOfJobCreatedTimeRange: 'StartOfJobCreatedTimeRange',
      endOfJobCreatedTimeRange: 'EndOfJobCreatedTimeRange',
      pipelineId: 'PipelineId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      jobId: 'string',
      ownerAccount: 'string',
      nextPageToken: 'string',
      maximumPageSize: 'number',
      state: 'string',
      startOfJobCreatedTimeRange: 'string',
      endOfJobCreatedTimeRange: 'string',
      pipelineId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaCensorJobListResponseBody extends $tea.Model {
  mediaCensorJobList?: QueryMediaCensorJobListResponseBodyMediaCensorJobList;
  requestId?: string;
  nextPageToken?: string;
  nonExistIds?: QueryMediaCensorJobListResponseBodyNonExistIds;
  static names(): { [key: string]: string } {
    return {
      mediaCensorJobList: 'MediaCensorJobList',
      requestId: 'RequestId',
      nextPageToken: 'NextPageToken',
      nonExistIds: 'NonExistIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      mediaCensorJobList: QueryMediaCensorJobListResponseBodyMediaCensorJobList,
      requestId: 'string',
      nextPageToken: 'string',
      nonExistIds: QueryMediaCensorJobListResponseBodyNonExistIds,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaCensorJobListResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryMediaCensorJobListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryMediaCensorJobListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaDetailJobListRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  jobIds?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      jobIds: 'JobIds',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      jobIds: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaDetailJobListResponseBody extends $tea.Model {
  requestId?: string;
  jobList?: QueryMediaDetailJobListResponseBodyJobList;
  nonExistIds?: QueryMediaDetailJobListResponseBodyNonExistIds;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      jobList: 'JobList',
      nonExistIds: 'NonExistIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      jobList: QueryMediaDetailJobListResponseBodyJobList,
      nonExistIds: QueryMediaDetailJobListResponseBodyNonExistIds,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaDetailJobListResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryMediaDetailJobListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryMediaDetailJobListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaFpDeleteJobListRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  jobIds?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      jobIds: 'JobIds',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      jobIds: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaFpDeleteJobListResponseBody extends $tea.Model {
  requestId?: string;
  nonExistIds?: QueryMediaFpDeleteJobListResponseBodyNonExistIds;
  mediaFpDeleteJobList?: QueryMediaFpDeleteJobListResponseBodyMediaFpDeleteJobList;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      nonExistIds: 'NonExistIds',
      mediaFpDeleteJobList: 'MediaFpDeleteJobList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      nonExistIds: QueryMediaFpDeleteJobListResponseBodyNonExistIds,
      mediaFpDeleteJobList: QueryMediaFpDeleteJobListResponseBodyMediaFpDeleteJobList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaFpDeleteJobListResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryMediaFpDeleteJobListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryMediaFpDeleteJobListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaInfoJobListRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  mediaInfoJobIds?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      mediaInfoJobIds: 'MediaInfoJobIds',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      mediaInfoJobIds: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaInfoJobListResponseBody extends $tea.Model {
  nonExistMediaInfoJobIds?: QueryMediaInfoJobListResponseBodyNonExistMediaInfoJobIds;
  requestId?: string;
  mediaInfoJobList?: QueryMediaInfoJobListResponseBodyMediaInfoJobList;
  static names(): { [key: string]: string } {
    return {
      nonExistMediaInfoJobIds: 'NonExistMediaInfoJobIds',
      requestId: 'RequestId',
      mediaInfoJobList: 'MediaInfoJobList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nonExistMediaInfoJobIds: QueryMediaInfoJobListResponseBodyNonExistMediaInfoJobIds,
      requestId: 'string',
      mediaInfoJobList: QueryMediaInfoJobListResponseBodyMediaInfoJobList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaInfoJobListResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryMediaInfoJobListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryMediaInfoJobListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaListRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  mediaIds?: string;
  includePlayList?: boolean;
  includeSnapshotList?: boolean;
  includeMediaInfo?: boolean;
  includeSummaryList?: boolean;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      mediaIds: 'MediaIds',
      includePlayList: 'IncludePlayList',
      includeSnapshotList: 'IncludeSnapshotList',
      includeMediaInfo: 'IncludeMediaInfo',
      includeSummaryList: 'IncludeSummaryList',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      mediaIds: 'string',
      includePlayList: 'boolean',
      includeSnapshotList: 'boolean',
      includeMediaInfo: 'boolean',
      includeSummaryList: 'boolean',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaListResponseBody extends $tea.Model {
  nonExistMediaIds?: QueryMediaListResponseBodyNonExistMediaIds;
  mediaList?: QueryMediaListResponseBodyMediaList;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      nonExistMediaIds: 'NonExistMediaIds',
      mediaList: 'MediaList',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nonExistMediaIds: QueryMediaListResponseBodyNonExistMediaIds,
      mediaList: QueryMediaListResponseBodyMediaList,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaListResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryMediaListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryMediaListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaListByURLRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  fileURLs?: string;
  includePlayList?: boolean;
  includeSnapshotList?: boolean;
  includeMediaInfo?: boolean;
  includeSummaryList?: boolean;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      fileURLs: 'FileURLs',
      includePlayList: 'IncludePlayList',
      includeSnapshotList: 'IncludeSnapshotList',
      includeMediaInfo: 'IncludeMediaInfo',
      includeSummaryList: 'IncludeSummaryList',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      fileURLs: 'string',
      includePlayList: 'boolean',
      includeSnapshotList: 'boolean',
      includeMediaInfo: 'boolean',
      includeSummaryList: 'boolean',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaListByURLResponseBody extends $tea.Model {
  mediaList?: QueryMediaListByURLResponseBodyMediaList;
  nonExistFileURLs?: QueryMediaListByURLResponseBodyNonExistFileURLs;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      mediaList: 'MediaList',
      nonExistFileURLs: 'NonExistFileURLs',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      mediaList: QueryMediaListByURLResponseBodyMediaList,
      nonExistFileURLs: QueryMediaListByURLResponseBodyNonExistFileURLs,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaListByURLResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryMediaListByURLResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryMediaListByURLResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaWorkflowExecutionListRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  runIds?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      runIds: 'RunIds',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      runIds: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaWorkflowExecutionListResponseBody extends $tea.Model {
  nonExistRunIds?: QueryMediaWorkflowExecutionListResponseBodyNonExistRunIds;
  mediaWorkflowExecutionList?: QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionList;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      nonExistRunIds: 'NonExistRunIds',
      mediaWorkflowExecutionList: 'MediaWorkflowExecutionList',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nonExistRunIds: QueryMediaWorkflowExecutionListResponseBodyNonExistRunIds,
      mediaWorkflowExecutionList: QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionList,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaWorkflowExecutionListResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryMediaWorkflowExecutionListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryMediaWorkflowExecutionListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaWorkflowListRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  mediaWorkflowIds?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      mediaWorkflowIds: 'MediaWorkflowIds',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      mediaWorkflowIds: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaWorkflowListResponseBody extends $tea.Model {
  nonExistMediaWorkflowIds?: QueryMediaWorkflowListResponseBodyNonExistMediaWorkflowIds;
  mediaWorkflowList?: QueryMediaWorkflowListResponseBodyMediaWorkflowList;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      nonExistMediaWorkflowIds: 'NonExistMediaWorkflowIds',
      mediaWorkflowList: 'MediaWorkflowList',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nonExistMediaWorkflowIds: QueryMediaWorkflowListResponseBodyNonExistMediaWorkflowIds,
      mediaWorkflowList: QueryMediaWorkflowListResponseBodyMediaWorkflowList,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaWorkflowListResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryMediaWorkflowListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryMediaWorkflowListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryPipelineListRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  pipelineIds?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      pipelineIds: 'PipelineIds',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      pipelineIds: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryPipelineListResponseBody extends $tea.Model {
  requestId?: string;
  pipelineList?: QueryPipelineListResponseBodyPipelineList;
  nonExistPids?: QueryPipelineListResponseBodyNonExistPids;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      pipelineList: 'PipelineList',
      nonExistPids: 'NonExistPids',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      pipelineList: QueryPipelineListResponseBodyPipelineList,
      nonExistPids: QueryPipelineListResponseBodyNonExistPids,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryPipelineListResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryPipelineListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryPipelineListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryPornJobListRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  jobIds?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      jobIds: 'JobIds',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      jobIds: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryPornJobListResponseBody extends $tea.Model {
  requestId?: string;
  pornJobList?: QueryPornJobListResponseBodyPornJobList;
  nonExistIds?: QueryPornJobListResponseBodyNonExistIds;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      pornJobList: 'PornJobList',
      nonExistIds: 'NonExistIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      pornJobList: QueryPornJobListResponseBodyPornJobList,
      nonExistIds: QueryPornJobListResponseBodyNonExistIds,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryPornJobListResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryPornJobListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryPornJobListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryPornPipelineListRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  pipelineIds?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      pipelineIds: 'PipelineIds',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      pipelineIds: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryPornPipelineListResponseBody extends $tea.Model {
  requestId?: string;
  pipelineList?: QueryPornPipelineListResponseBodyPipelineList;
  nonExistIds?: QueryPornPipelineListResponseBodyNonExistIds;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      pipelineList: 'PipelineList',
      nonExistIds: 'NonExistIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      pipelineList: QueryPornPipelineListResponseBodyPipelineList,
      nonExistIds: QueryPornPipelineListResponseBodyNonExistIds,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryPornPipelineListResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryPornPipelineListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryPornPipelineListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySmarttagJobRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  jobId?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      jobId: 'JobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      jobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySmarttagJobResponseBody extends $tea.Model {
  jobStatus?: string;
  requestId?: string;
  userData?: string;
  results?: QuerySmarttagJobResponseBodyResults;
  static names(): { [key: string]: string } {
    return {
      jobStatus: 'JobStatus',
      requestId: 'RequestId',
      userData: 'UserData',
      results: 'Results',
    };
  }

  static types(): { [key: string]: any } {
    return {
      jobStatus: 'string',
      requestId: 'string',
      userData: 'string',
      results: QuerySmarttagJobResponseBodyResults,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySmarttagJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QuerySmarttagJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QuerySmarttagJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySmarttagTemplateListRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  templateId?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      templateId: 'TemplateId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      templateId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySmarttagTemplateListResponseBody extends $tea.Model {
  requestId?: string;
  templates?: QuerySmarttagTemplateListResponseBodyTemplates;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      templates: 'Templates',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      templates: QuerySmarttagTemplateListResponseBodyTemplates,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySmarttagTemplateListResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QuerySmarttagTemplateListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QuerySmarttagTemplateListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySnapshotJobListRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  snapshotJobIds?: string;
  nextPageToken?: string;
  maximumPageSize?: number;
  state?: string;
  startOfJobCreatedTimeRange?: string;
  endOfJobCreatedTimeRange?: string;
  pipelineId?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      snapshotJobIds: 'SnapshotJobIds',
      nextPageToken: 'NextPageToken',
      maximumPageSize: 'MaximumPageSize',
      state: 'State',
      startOfJobCreatedTimeRange: 'StartOfJobCreatedTimeRange',
      endOfJobCreatedTimeRange: 'EndOfJobCreatedTimeRange',
      pipelineId: 'PipelineId',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      snapshotJobIds: 'string',
      nextPageToken: 'string',
      maximumPageSize: 'number',
      state: 'string',
      startOfJobCreatedTimeRange: 'string',
      endOfJobCreatedTimeRange: 'string',
      pipelineId: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySnapshotJobListResponseBody extends $tea.Model {
  snapshotJobList?: QuerySnapshotJobListResponseBodySnapshotJobList;
  requestId?: string;
  nonExistSnapshotJobIds?: QuerySnapshotJobListResponseBodyNonExistSnapshotJobIds;
  nextPageToken?: string;
  static names(): { [key: string]: string } {
    return {
      snapshotJobList: 'SnapshotJobList',
      requestId: 'RequestId',
      nonExistSnapshotJobIds: 'NonExistSnapshotJobIds',
      nextPageToken: 'NextPageToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      snapshotJobList: QuerySnapshotJobListResponseBodySnapshotJobList,
      requestId: 'string',
      nonExistSnapshotJobIds: QuerySnapshotJobListResponseBodyNonExistSnapshotJobIds,
      nextPageToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySnapshotJobListResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QuerySnapshotJobListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QuerySnapshotJobListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySubtitleJobListRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  jobIds?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      jobIds: 'JobIds',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      jobIds: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySubtitleJobListResponseBody extends $tea.Model {
  nonExistJobIds?: QuerySubtitleJobListResponseBodyNonExistJobIds;
  requestId?: string;
  jobList?: QuerySubtitleJobListResponseBodyJobList;
  static names(): { [key: string]: string } {
    return {
      nonExistJobIds: 'NonExistJobIds',
      requestId: 'RequestId',
      jobList: 'JobList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nonExistJobIds: QuerySubtitleJobListResponseBodyNonExistJobIds,
      requestId: 'string',
      jobList: QuerySubtitleJobListResponseBodyJobList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySubtitleJobListResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QuerySubtitleJobListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QuerySubtitleJobListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTagJobListRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  tagJobIds?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      tagJobIds: 'TagJobIds',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      tagJobIds: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTagJobListResponseBody extends $tea.Model {
  tagJobList?: QueryTagJobListResponseBodyTagJobList;
  requestId?: string;
  nonExistIds?: QueryTagJobListResponseBodyNonExistIds;
  static names(): { [key: string]: string } {
    return {
      tagJobList: 'TagJobList',
      requestId: 'RequestId',
      nonExistIds: 'NonExistIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagJobList: QueryTagJobListResponseBodyTagJobList,
      requestId: 'string',
      nonExistIds: QueryTagJobListResponseBodyNonExistIds,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTagJobListResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryTagJobListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryTagJobListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTemplateListRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  templateIds?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      templateIds: 'TemplateIds',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      templateIds: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTemplateListResponseBody extends $tea.Model {
  nonExistTids?: QueryTemplateListResponseBodyNonExistTids;
  templateList?: QueryTemplateListResponseBodyTemplateList;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      nonExistTids: 'NonExistTids',
      templateList: 'TemplateList',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nonExistTids: QueryTemplateListResponseBodyNonExistTids,
      templateList: QueryTemplateListResponseBodyTemplateList,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTemplateListResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryTemplateListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryTemplateListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTerrorismJobListRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  jobIds?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      jobIds: 'JobIds',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      jobIds: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTerrorismJobListResponseBody extends $tea.Model {
  requestId?: string;
  terrorismJobList?: QueryTerrorismJobListResponseBodyTerrorismJobList;
  nonExistIds?: QueryTerrorismJobListResponseBodyNonExistIds;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      terrorismJobList: 'TerrorismJobList',
      nonExistIds: 'NonExistIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      terrorismJobList: QueryTerrorismJobListResponseBodyTerrorismJobList,
      nonExistIds: QueryTerrorismJobListResponseBodyNonExistIds,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTerrorismJobListResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryTerrorismJobListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryTerrorismJobListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTerrorismPipelineListRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  pipelineIds?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      pipelineIds: 'PipelineIds',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      pipelineIds: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTerrorismPipelineListResponseBody extends $tea.Model {
  requestId?: string;
  pipelineList?: QueryTerrorismPipelineListResponseBodyPipelineList;
  nonExistIds?: QueryTerrorismPipelineListResponseBodyNonExistIds;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      pipelineList: 'PipelineList',
      nonExistIds: 'NonExistIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      pipelineList: QueryTerrorismPipelineListResponseBodyPipelineList,
      nonExistIds: QueryTerrorismPipelineListResponseBodyNonExistIds,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTerrorismPipelineListResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryTerrorismPipelineListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryTerrorismPipelineListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryVideoGifJobListRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  jobIds?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      jobIds: 'JobIds',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      jobIds: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryVideoGifJobListResponseBody extends $tea.Model {
  requestId?: string;
  jobList?: QueryVideoGifJobListResponseBodyJobList;
  nonExistIds?: QueryVideoGifJobListResponseBodyNonExistIds;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      jobList: 'JobList',
      nonExistIds: 'NonExistIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      jobList: QueryVideoGifJobListResponseBodyJobList,
      nonExistIds: QueryVideoGifJobListResponseBodyNonExistIds,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryVideoGifJobListResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryVideoGifJobListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryVideoGifJobListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryVideoPoseJobListRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  jobIds?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      jobIds: 'JobIds',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      jobIds: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryVideoPoseJobListResponseBody extends $tea.Model {
  nonExistJobIds?: QueryVideoPoseJobListResponseBodyNonExistJobIds;
  requestId?: string;
  jobList?: QueryVideoPoseJobListResponseBodyJobList;
  static names(): { [key: string]: string } {
    return {
      nonExistJobIds: 'NonExistJobIds',
      requestId: 'RequestId',
      jobList: 'JobList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nonExistJobIds: QueryVideoPoseJobListResponseBodyNonExistJobIds,
      requestId: 'string',
      jobList: QueryVideoPoseJobListResponseBodyJobList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryVideoPoseJobListResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryVideoPoseJobListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryVideoPoseJobListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryVideoQualityJobRequest extends $tea.Model {
  userId?: number;
  jobId?: string;
  static names(): { [key: string]: string } {
    return {
      userId: 'UserId',
      jobId: 'JobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      userId: 'number',
      jobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryVideoQualityJobResponseBody extends $tea.Model {
  message?: string;
  requestId?: string;
  job?: QueryVideoQualityJobResponseBodyJob;
  code?: string;
  static names(): { [key: string]: string } {
    return {
      message: 'Message',
      requestId: 'RequestId',
      job: 'Job',
      code: 'Code',
    };
  }

  static types(): { [key: string]: any } {
    return {
      message: 'string',
      requestId: 'string',
      job: QueryVideoQualityJobResponseBodyJob,
      code: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryVideoQualityJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryVideoQualityJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryVideoQualityJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryVideoSplitJobListRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  jobIds?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      jobIds: 'JobIds',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      jobIds: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryVideoSplitJobListResponseBody extends $tea.Model {
  requestId?: string;
  jobList?: QueryVideoSplitJobListResponseBodyJobList;
  nonExistIds?: QueryVideoSplitJobListResponseBodyNonExistIds;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      jobList: 'JobList',
      nonExistIds: 'NonExistIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      jobList: QueryVideoSplitJobListResponseBodyJobList,
      nonExistIds: QueryVideoSplitJobListResponseBodyNonExistIds,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryVideoSplitJobListResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryVideoSplitJobListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryVideoSplitJobListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryVideoSummaryJobListRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  jobIds?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      jobIds: 'JobIds',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      jobIds: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryVideoSummaryJobListResponseBody extends $tea.Model {
  requestId?: string;
  jobList?: QueryVideoSummaryJobListResponseBodyJobList;
  nonExistIds?: QueryVideoSummaryJobListResponseBodyNonExistIds;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      jobList: 'JobList',
      nonExistIds: 'NonExistIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      jobList: QueryVideoSummaryJobListResponseBodyJobList,
      nonExistIds: QueryVideoSummaryJobListResponseBodyNonExistIds,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryVideoSummaryJobListResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryVideoSummaryJobListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryVideoSummaryJobListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryWaterMarkTemplateListRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  waterMarkTemplateIds?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      waterMarkTemplateIds: 'WaterMarkTemplateIds',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      waterMarkTemplateIds: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryWaterMarkTemplateListResponseBody extends $tea.Model {
  requestId?: string;
  nonExistWids?: QueryWaterMarkTemplateListResponseBodyNonExistWids;
  waterMarkTemplateList?: QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateList;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      nonExistWids: 'NonExistWids',
      waterMarkTemplateList: 'WaterMarkTemplateList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      nonExistWids: QueryWaterMarkTemplateListResponseBodyNonExistWids,
      waterMarkTemplateList: QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryWaterMarkTemplateListResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryWaterMarkTemplateListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryWaterMarkTemplateListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RefreshCdnDomainConfigsCacheRequest extends $tea.Model {
  ownerId?: string;
  resourceOwnerId?: string;
  resourceOwnerAccount?: string;
  ownerAccount?: string;
  domains?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerId: 'ResourceOwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      ownerAccount: 'OwnerAccount',
      domains: 'Domains',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'string',
      resourceOwnerId: 'string',
      resourceOwnerAccount: 'string',
      ownerAccount: 'string',
      domains: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RefreshCdnDomainConfigsCacheResponseBody extends $tea.Model {
  sucessDomains?: RefreshCdnDomainConfigsCacheResponseBodySucessDomains;
  failedDomains?: RefreshCdnDomainConfigsCacheResponseBodyFailedDomains;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      sucessDomains: 'SucessDomains',
      failedDomains: 'FailedDomains',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      sucessDomains: RefreshCdnDomainConfigsCacheResponseBodySucessDomains,
      failedDomains: RefreshCdnDomainConfigsCacheResponseBodyFailedDomains,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RefreshCdnDomainConfigsCacheResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: RefreshCdnDomainConfigsCacheResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: RefreshCdnDomainConfigsCacheResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RegisterCustomFaceRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  categoryId?: string;
  personId?: string;
  imageUrl?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      categoryId: 'CategoryId',
      personId: 'PersonId',
      imageUrl: 'ImageUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      categoryId: 'string',
      personId: 'string',
      imageUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RegisterCustomFaceResponseBody extends $tea.Model {
  faceId?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      faceId: 'FaceId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      faceId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RegisterCustomFaceResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: RegisterCustomFaceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: RegisterCustomFaceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RegisterMediaDetailPersonRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  category?: string;
  personName?: string;
  images?: string;
  personLib?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      category: 'Category',
      personName: 'PersonName',
      images: 'Images',
      personLib: 'PersonLib',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      category: 'string',
      personName: 'string',
      images: 'string',
      personLib: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RegisterMediaDetailPersonResponseBody extends $tea.Model {
  requestId?: string;
  registeredPersonages?: RegisterMediaDetailPersonResponseBodyRegisteredPersonages;
  failedImages?: RegisterMediaDetailPersonResponseBodyFailedImages;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      registeredPersonages: 'RegisteredPersonages',
      failedImages: 'FailedImages',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      registeredPersonages: RegisterMediaDetailPersonResponseBodyRegisteredPersonages,
      failedImages: RegisterMediaDetailPersonResponseBodyFailedImages,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RegisterMediaDetailPersonResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: RegisterMediaDetailPersonResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: RegisterMediaDetailPersonResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RegisterMediaDetailScenarioRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  jobId?: string;
  scenario?: string;
  description?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      jobId: 'JobId',
      scenario: 'Scenario',
      description: 'Description',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      jobId: 'string',
      scenario: 'string',
      description: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RegisterMediaDetailScenarioResponseBody extends $tea.Model {
  scenarioId?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      scenarioId: 'ScenarioId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      scenarioId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RegisterMediaDetailScenarioResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: RegisterMediaDetailScenarioResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: RegisterMediaDetailScenarioResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReportAnnotationJobResultRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  jobId?: string;
  annotation?: string;
  details?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      jobId: 'JobId',
      annotation: 'Annotation',
      details: 'Details',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      jobId: 'string',
      annotation: 'string',
      details: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReportAnnotationJobResultResponseBody extends $tea.Model {
  requestId?: string;
  jobId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      jobId: 'JobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      jobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReportAnnotationJobResultResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ReportAnnotationJobResultResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ReportAnnotationJobResultResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReportCensorJobResultRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  jobId?: string;
  label?: string;
  detail?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      jobId: 'JobId',
      label: 'Label',
      detail: 'Detail',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      jobId: 'string',
      label: 'string',
      detail: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReportCensorJobResultResponseBody extends $tea.Model {
  requestId?: string;
  jobId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      jobId: 'JobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      jobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReportCensorJobResultResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ReportCensorJobResultResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ReportCensorJobResultResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReportCoverJobResultRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  jobId?: string;
  result?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      jobId: 'JobId',
      result: 'Result',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      jobId: 'string',
      result: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReportCoverJobResultResponseBody extends $tea.Model {
  requestId?: string;
  jobId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      jobId: 'JobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      jobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReportCoverJobResultResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ReportCoverJobResultResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ReportCoverJobResultResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReportFacerecogJobResultRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  jobId?: string;
  facerecog?: string;
  details?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      jobId: 'JobId',
      facerecog: 'Facerecog',
      details: 'Details',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      jobId: 'string',
      facerecog: 'string',
      details: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReportFacerecogJobResultResponseBody extends $tea.Model {
  requestId?: string;
  jobId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      jobId: 'JobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      jobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReportFacerecogJobResultResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ReportFacerecogJobResultResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ReportFacerecogJobResultResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReportFpShotJobResultRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  jobId?: string;
  result?: string;
  details?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      jobId: 'JobId',
      result: 'Result',
      details: 'Details',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      jobId: 'string',
      result: 'string',
      details: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReportFpShotJobResultResponseBody extends $tea.Model {
  requestId?: string;
  jobId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      jobId: 'JobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      jobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReportFpShotJobResultResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ReportFpShotJobResultResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ReportFpShotJobResultResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReportMediaDetailJobResultRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  jobId?: string;
  tag?: string;
  results?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      jobId: 'JobId',
      tag: 'Tag',
      results: 'Results',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      jobId: 'string',
      tag: 'string',
      results: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReportMediaDetailJobResultResponseBody extends $tea.Model {
  requestId?: string;
  jobId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      jobId: 'JobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      jobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReportMediaDetailJobResultResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ReportMediaDetailJobResultResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ReportMediaDetailJobResultResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReportPornJobResultRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  jobId?: string;
  label?: string;
  detail?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      jobId: 'JobId',
      label: 'Label',
      detail: 'Detail',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      jobId: 'string',
      label: 'string',
      detail: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReportPornJobResultResponseBody extends $tea.Model {
  requestId?: string;
  jobId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      jobId: 'JobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      jobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReportPornJobResultResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ReportPornJobResultResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ReportPornJobResultResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReportTagJobResultRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  jobId?: string;
  tag?: string;
  result?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      jobId: 'JobId',
      tag: 'Tag',
      result: 'Result',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      jobId: 'string',
      tag: 'string',
      result: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReportTagJobResultResponseBody extends $tea.Model {
  requestId?: string;
  jobId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      jobId: 'JobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      jobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReportTagJobResultResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ReportTagJobResultResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ReportTagJobResultResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReportTerrorismJobResultRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  jobId?: string;
  label?: string;
  detail?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      jobId: 'JobId',
      label: 'Label',
      detail: 'Detail',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      jobId: 'string',
      label: 'string',
      detail: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReportTerrorismJobResultResponseBody extends $tea.Model {
  requestId?: string;
  jobId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      jobId: 'JobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      jobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReportTerrorismJobResultResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ReportTerrorismJobResultResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ReportTerrorismJobResultResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReportVideoSplitJobResultRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  jobId?: string;
  result?: string;
  details?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      jobId: 'JobId',
      result: 'Result',
      details: 'Details',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      jobId: 'string',
      result: 'string',
      details: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReportVideoSplitJobResultResponseBody extends $tea.Model {
  requestId?: string;
  jobId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      jobId: 'JobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      jobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReportVideoSplitJobResultResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ReportVideoSplitJobResultResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ReportVideoSplitJobResultResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchMediaRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  from?: string;
  to?: string;
  keyWord?: string;
  title?: string;
  description?: string;
  tag?: string;
  cateId?: string;
  sortBy?: string;
  pageSize?: number;
  pageNumber?: number;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      from: 'From',
      to: 'To',
      keyWord: 'KeyWord',
      title: 'Title',
      description: 'Description',
      tag: 'Tag',
      cateId: 'CateId',
      sortBy: 'SortBy',
      pageSize: 'PageSize',
      pageNumber: 'PageNumber',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      from: 'string',
      to: 'string',
      keyWord: 'string',
      title: 'string',
      description: 'string',
      tag: 'string',
      cateId: 'string',
      sortBy: 'string',
      pageSize: 'number',
      pageNumber: 'number',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchMediaResponseBody extends $tea.Model {
  mediaList?: SearchMediaResponseBodyMediaList;
  totalNum?: number;
  pageSize?: number;
  requestId?: string;
  pageNumber?: number;
  static names(): { [key: string]: string } {
    return {
      mediaList: 'MediaList',
      totalNum: 'TotalNum',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      pageNumber: 'PageNumber',
    };
  }

  static types(): { [key: string]: any } {
    return {
      mediaList: SearchMediaResponseBodyMediaList,
      totalNum: 'number',
      pageSize: 'number',
      requestId: 'string',
      pageNumber: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchMediaResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: SearchMediaResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: SearchMediaResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchMediaWorkflowRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  pageSize?: number;
  pageNumber?: number;
  stateList?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      pageSize: 'PageSize',
      pageNumber: 'PageNumber',
      stateList: 'StateList',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      pageSize: 'number',
      pageNumber: 'number',
      stateList: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchMediaWorkflowResponseBody extends $tea.Model {
  totalCount?: number;
  mediaWorkflowList?: SearchMediaWorkflowResponseBodyMediaWorkflowList;
  pageSize?: number;
  requestId?: string;
  pageNumber?: number;
  static names(): { [key: string]: string } {
    return {
      totalCount: 'TotalCount',
      mediaWorkflowList: 'MediaWorkflowList',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      pageNumber: 'PageNumber',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalCount: 'number',
      mediaWorkflowList: SearchMediaWorkflowResponseBodyMediaWorkflowList,
      pageSize: 'number',
      requestId: 'string',
      pageNumber: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchMediaWorkflowResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: SearchMediaWorkflowResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: SearchMediaWorkflowResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchPipelineRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  pageSize?: number;
  pageNumber?: number;
  state?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      pageSize: 'PageSize',
      pageNumber: 'PageNumber',
      state: 'State',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      pageSize: 'number',
      pageNumber: 'number',
      state: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchPipelineResponseBody extends $tea.Model {
  totalCount?: number;
  pageSize?: number;
  requestId?: string;
  pageNumber?: number;
  pipelineList?: SearchPipelineResponseBodyPipelineList;
  static names(): { [key: string]: string } {
    return {
      totalCount: 'TotalCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      pageNumber: 'PageNumber',
      pipelineList: 'PipelineList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      pageNumber: 'number',
      pipelineList: SearchPipelineResponseBodyPipelineList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchPipelineResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: SearchPipelineResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: SearchPipelineResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchTemplateRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  pageSize?: number;
  pageNumber?: number;
  state?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      pageSize: 'PageSize',
      pageNumber: 'PageNumber',
      state: 'State',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      pageSize: 'number',
      pageNumber: 'number',
      state: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchTemplateResponseBody extends $tea.Model {
  totalCount?: number;
  templateList?: SearchTemplateResponseBodyTemplateList;
  pageSize?: number;
  requestId?: string;
  pageNumber?: number;
  static names(): { [key: string]: string } {
    return {
      totalCount: 'TotalCount',
      templateList: 'TemplateList',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      pageNumber: 'PageNumber',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalCount: 'number',
      templateList: SearchTemplateResponseBodyTemplateList,
      pageSize: 'number',
      requestId: 'string',
      pageNumber: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchTemplateResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: SearchTemplateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: SearchTemplateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchWaterMarkTemplateRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  pageSize?: number;
  pageNumber?: number;
  state?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      pageSize: 'PageSize',
      pageNumber: 'PageNumber',
      state: 'State',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      pageSize: 'number',
      pageNumber: 'number',
      state: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchWaterMarkTemplateResponseBody extends $tea.Model {
  totalCount?: number;
  pageSize?: number;
  requestId?: string;
  pageNumber?: number;
  waterMarkTemplateList?: SearchWaterMarkTemplateResponseBodyWaterMarkTemplateList;
  static names(): { [key: string]: string } {
    return {
      totalCount: 'TotalCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      pageNumber: 'PageNumber',
      waterMarkTemplateList: 'WaterMarkTemplateList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      pageNumber: 'number',
      waterMarkTemplateList: SearchWaterMarkTemplateResponseBodyWaterMarkTemplateList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchWaterMarkTemplateResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: SearchWaterMarkTemplateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: SearchWaterMarkTemplateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetAuthConfigRequest extends $tea.Model {
  ownerId?: string;
  resourceOwnerId?: string;
  resourceOwnerAccount?: string;
  ownerAccount?: string;
  key1?: string;
  key2?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerId: 'ResourceOwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      ownerAccount: 'OwnerAccount',
      key1: 'Key1',
      key2: 'Key2',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'string',
      resourceOwnerId: 'string',
      resourceOwnerAccount: 'string',
      ownerAccount: 'string',
      key1: 'string',
      key2: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetAuthConfigResponseBody extends $tea.Model {
  key2?: string;
  key1?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      key2: 'Key2',
      key1: 'Key1',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key2: 'string',
      key1: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetAuthConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: SetAuthConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: SetAuthConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopIProductionJobRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  jobId?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      jobId: 'JobId',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      jobId: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopIProductionJobResponseBody extends $tea.Model {
  requestId?: string;
  jobId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      jobId: 'JobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      jobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopIProductionJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: StopIProductionJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: StopIProductionJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitAnalysisJobRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  input?: string;
  analysisConfig?: string;
  userData?: string;
  pipelineId?: string;
  priority?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      input: 'Input',
      analysisConfig: 'AnalysisConfig',
      userData: 'UserData',
      pipelineId: 'PipelineId',
      priority: 'Priority',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      input: 'string',
      analysisConfig: 'string',
      userData: 'string',
      pipelineId: 'string',
      priority: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitAnalysisJobResponseBody extends $tea.Model {
  requestId?: string;
  analysisJob?: SubmitAnalysisJobResponseBodyAnalysisJob;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      analysisJob: 'AnalysisJob',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      analysisJob: SubmitAnalysisJobResponseBodyAnalysisJob,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitAnalysisJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: SubmitAnalysisJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: SubmitAnalysisJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitAnnotationJobRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  input?: string;
  annotationConfig?: string;
  userData?: string;
  pipelineId?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      input: 'Input',
      annotationConfig: 'AnnotationConfig',
      userData: 'UserData',
      pipelineId: 'PipelineId',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      input: 'string',
      annotationConfig: 'string',
      userData: 'string',
      pipelineId: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitAnnotationJobResponseBody extends $tea.Model {
  requestId?: string;
  jobId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      jobId: 'JobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      jobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitAnnotationJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: SubmitAnnotationJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: SubmitAnnotationJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitAsrJobRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  input?: string;
  pipelineId?: string;
  asrConfig?: string;
  userData?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      input: 'Input',
      pipelineId: 'PipelineId',
      asrConfig: 'AsrConfig',
      userData: 'UserData',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      input: 'string',
      pipelineId: 'string',
      asrConfig: 'string',
      userData: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitAsrJobResponseBody extends $tea.Model {
  requestId?: string;
  jobId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      jobId: 'JobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      jobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitAsrJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: SubmitAsrJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: SubmitAsrJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitBeautifyJobsRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  beautifyConfig?: string;
  userData?: string;
  pipelineId?: string;
  async?: boolean;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      beautifyConfig: 'BeautifyConfig',
      userData: 'UserData',
      pipelineId: 'PipelineId',
      async: 'Async',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      beautifyConfig: 'string',
      userData: 'string',
      pipelineId: 'string',
      async: 'boolean',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitBeautifyJobsResponseBody extends $tea.Model {
  requestId?: string;
  jobList?: SubmitBeautifyJobsResponseBodyJobList;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      jobList: 'JobList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      jobList: SubmitBeautifyJobsResponseBodyJobList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitBeautifyJobsResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: SubmitBeautifyJobsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: SubmitBeautifyJobsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitComplexJobRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  inputs?: string;
  complexConfigs?: string;
  transcodeOutput?: string;
  outputBucket?: string;
  outputLocation?: string;
  pipelineId?: string;
  userData?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      inputs: 'Inputs',
      complexConfigs: 'ComplexConfigs',
      transcodeOutput: 'TranscodeOutput',
      outputBucket: 'OutputBucket',
      outputLocation: 'OutputLocation',
      pipelineId: 'PipelineId',
      userData: 'UserData',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      inputs: 'string',
      complexConfigs: 'string',
      transcodeOutput: 'string',
      outputBucket: 'string',
      outputLocation: 'string',
      pipelineId: 'string',
      userData: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitComplexJobResponseBody extends $tea.Model {
  requestId?: string;
  complexJob?: SubmitComplexJobResponseBodyComplexJob;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      complexJob: 'ComplexJob',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      complexJob: SubmitComplexJobResponseBodyComplexJob,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitComplexJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: SubmitComplexJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: SubmitComplexJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitCoverJobRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  input?: string;
  coverConfig?: string;
  userData?: string;
  pipelineId?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      input: 'Input',
      coverConfig: 'CoverConfig',
      userData: 'UserData',
      pipelineId: 'PipelineId',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      input: 'string',
      coverConfig: 'string',
      userData: 'string',
      pipelineId: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitCoverJobResponseBody extends $tea.Model {
  requestId?: string;
  jobId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      jobId: 'JobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      jobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitCoverJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: SubmitCoverJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: SubmitCoverJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitEditingJobsRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  editingInputs?: string;
  editingJobOutputs?: string;
  outputBucket?: string;
  outputLocation?: string;
  pipelineId?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      editingInputs: 'EditingInputs',
      editingJobOutputs: 'EditingJobOutputs',
      outputBucket: 'OutputBucket',
      outputLocation: 'OutputLocation',
      pipelineId: 'PipelineId',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      editingInputs: 'string',
      editingJobOutputs: 'string',
      outputBucket: 'string',
      outputLocation: 'string',
      pipelineId: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitEditingJobsResponseBody extends $tea.Model {
  jobResultList?: SubmitEditingJobsResponseBodyJobResultList;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      jobResultList: 'JobResultList',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      jobResultList: SubmitEditingJobsResponseBodyJobResultList,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitEditingJobsResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: SubmitEditingJobsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: SubmitEditingJobsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitFacerecogJobRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  input?: string;
  facerecogConfig?: string;
  userData?: string;
  pipelineId?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      input: 'Input',
      facerecogConfig: 'FacerecogConfig',
      userData: 'UserData',
      pipelineId: 'PipelineId',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      input: 'string',
      facerecogConfig: 'string',
      userData: 'string',
      pipelineId: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitFacerecogJobResponseBody extends $tea.Model {
  requestId?: string;
  jobId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      jobId: 'JobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      jobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitFacerecogJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: SubmitFacerecogJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: SubmitFacerecogJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitFpCompareJobRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  masterMedia?: string;
  queryMedia?: string;
  pipelineId?: string;
  fpDBId?: string;
  matchedFrameStorage?: string;
  userData?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      masterMedia: 'MasterMedia',
      queryMedia: 'QueryMedia',
      pipelineId: 'PipelineId',
      fpDBId: 'FpDBId',
      matchedFrameStorage: 'MatchedFrameStorage',
      userData: 'UserData',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      masterMedia: 'string',
      queryMedia: 'string',
      pipelineId: 'string',
      fpDBId: 'string',
      matchedFrameStorage: 'string',
      userData: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitFpCompareJobResponseBody extends $tea.Model {
  requestId?: string;
  jobId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      jobId: 'JobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      jobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitFpCompareJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: SubmitFpCompareJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: SubmitFpCompareJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitFpDBDeleteJobRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  pipelineId?: string;
  fpDBId?: string;
  userData?: string;
  delType?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      pipelineId: 'PipelineId',
      fpDBId: 'FpDBId',
      userData: 'UserData',
      delType: 'DelType',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      pipelineId: 'string',
      fpDBId: 'string',
      userData: 'string',
      delType: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitFpDBDeleteJobResponseBody extends $tea.Model {
  requestId?: string;
  jobId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      jobId: 'JobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      jobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitFpDBDeleteJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: SubmitFpDBDeleteJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: SubmitFpDBDeleteJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitFpFileDeleteJobRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  pipelineId?: string;
  fpDBId?: string;
  userData?: string;
  fileIds?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      pipelineId: 'PipelineId',
      fpDBId: 'FpDBId',
      userData: 'UserData',
      fileIds: 'FileIds',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      pipelineId: 'string',
      fpDBId: 'string',
      userData: 'string',
      fileIds: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitFpFileDeleteJobResponseBody extends $tea.Model {
  requestId?: string;
  jobId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      jobId: 'JobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      jobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitFpFileDeleteJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: SubmitFpFileDeleteJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: SubmitFpFileDeleteJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitFpShotJobRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  input?: string;
  pipelineId?: string;
  fpShotConfig?: string;
  userData?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      input: 'Input',
      pipelineId: 'PipelineId',
      fpShotConfig: 'FpShotConfig',
      userData: 'UserData',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      input: 'string',
      pipelineId: 'string',
      fpShotConfig: 'string',
      userData: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitFpShotJobResponseBody extends $tea.Model {
  requestId?: string;
  jobId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      jobId: 'JobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      jobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitFpShotJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: SubmitFpShotJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: SubmitFpShotJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitImageQualityJobRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  input?: string;
  pipelineId?: string;
  userData?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      input: 'Input',
      pipelineId: 'PipelineId',
      userData: 'UserData',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      input: 'string',
      pipelineId: 'string',
      userData: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitImageQualityJobResponseBody extends $tea.Model {
  requestId?: string;
  imageQualityJob?: SubmitImageQualityJobResponseBodyImageQualityJob;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      imageQualityJob: 'ImageQualityJob',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      imageQualityJob: SubmitImageQualityJobResponseBodyImageQualityJob,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitImageQualityJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: SubmitImageQualityJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: SubmitImageQualityJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitImageSearchJobRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  inputVideo?: string;
  inputImage?: string;
  pipelineId?: string;
  fpDBId?: string;
  config?: string;
  userData?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      inputVideo: 'InputVideo',
      inputImage: 'InputImage',
      pipelineId: 'PipelineId',
      fpDBId: 'FpDBId',
      config: 'Config',
      userData: 'UserData',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      inputVideo: 'string',
      inputImage: 'string',
      pipelineId: 'string',
      fpDBId: 'string',
      config: 'string',
      userData: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitImageSearchJobResponseBody extends $tea.Model {
  requestId?: string;
  jobId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      jobId: 'JobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      jobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitImageSearchJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: SubmitImageSearchJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: SubmitImageSearchJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitInnerJobRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  pipelineId?: string;
  video?: string;
  images?: string;
  uid?: number;
  config?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      pipelineId: 'PipelineId',
      video: 'Video',
      images: 'Images',
      uid: 'Uid',
      config: 'Config',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      pipelineId: 'string',
      video: 'string',
      images: 'string',
      uid: 'number',
      config: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitInnerJobResponseBody extends $tea.Model {
  requestId?: string;
  jobId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      jobId: 'JobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      jobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitInnerJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: SubmitInnerJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: SubmitInnerJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitIProductionJobRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  functionName?: string;
  modelId?: string;
  jobParams?: string;
  scheduleParams?: string;
  notifyUrl?: string;
  userData?: string;
  pipelineId?: string;
  ownerAccount?: string;
  input?: string;
  output?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      functionName: 'FunctionName',
      modelId: 'ModelId',
      jobParams: 'JobParams',
      scheduleParams: 'ScheduleParams',
      notifyUrl: 'NotifyUrl',
      userData: 'UserData',
      pipelineId: 'PipelineId',
      ownerAccount: 'OwnerAccount',
      input: 'Input',
      output: 'Output',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      functionName: 'string',
      modelId: 'string',
      jobParams: 'string',
      scheduleParams: 'string',
      notifyUrl: 'string',
      userData: 'string',
      pipelineId: 'string',
      ownerAccount: 'string',
      input: 'string',
      output: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitIProductionJobResponseBody extends $tea.Model {
  requestId?: string;
  jobId?: string;
  result?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      jobId: 'JobId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      jobId: 'string',
      result: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitIProductionJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: SubmitIProductionJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: SubmitIProductionJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitJobsRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  input?: string;
  outputs?: string;
  outputBucket?: string;
  outputLocation?: string;
  pipelineId?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      input: 'Input',
      outputs: 'Outputs',
      outputBucket: 'OutputBucket',
      outputLocation: 'OutputLocation',
      pipelineId: 'PipelineId',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      input: 'string',
      outputs: 'string',
      outputBucket: 'string',
      outputLocation: 'string',
      pipelineId: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitJobsResponseBody extends $tea.Model {
  jobResultList?: SubmitJobsResponseBodyJobResultList;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      jobResultList: 'JobResultList',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      jobResultList: SubmitJobsResponseBodyJobResultList,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitJobsResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: SubmitJobsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: SubmitJobsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitMCJobRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  video?: string;
  images?: string;
  texts?: string;
  pipelineId?: string;
  censorConfig?: string;
  userData?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      video: 'Video',
      images: 'Images',
      texts: 'Texts',
      pipelineId: 'PipelineId',
      censorConfig: 'CensorConfig',
      userData: 'UserData',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      video: 'string',
      images: 'string',
      texts: 'string',
      pipelineId: 'string',
      censorConfig: 'string',
      userData: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitMCJobResponseBody extends $tea.Model {
  requestId?: string;
  jobId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      jobId: 'JobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      jobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitMCJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: SubmitMCJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: SubmitMCJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitMcuJobRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  input?: string;
  pipelineId?: string;
  templateId?: string;
  template?: string;
  userData?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      input: 'Input',
      pipelineId: 'PipelineId',
      templateId: 'TemplateId',
      template: 'Template',
      userData: 'UserData',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      input: 'string',
      pipelineId: 'string',
      templateId: 'string',
      template: 'string',
      userData: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitMcuJobResponseBody extends $tea.Model {
  requestId?: string;
  jobId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      jobId: 'JobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      jobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitMcuJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: SubmitMcuJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: SubmitMcuJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitMediaCensorJobRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  input?: string;
  coverImages?: string;
  title?: string;
  description?: string;
  barrages?: string;
  pipelineId?: string;
  videoCensorConfig?: string;
  userData?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      input: 'Input',
      coverImages: 'CoverImages',
      title: 'Title',
      description: 'Description',
      barrages: 'Barrages',
      pipelineId: 'PipelineId',
      videoCensorConfig: 'VideoCensorConfig',
      userData: 'UserData',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      input: 'string',
      coverImages: 'string',
      title: 'string',
      description: 'string',
      barrages: 'string',
      pipelineId: 'string',
      videoCensorConfig: 'string',
      userData: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitMediaCensorJobResponseBody extends $tea.Model {
  requestId?: string;
  jobId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      jobId: 'JobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      jobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitMediaCensorJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: SubmitMediaCensorJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: SubmitMediaCensorJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitMediaDetailJobRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  input?: string;
  pipelineId?: string;
  mediaDetailConfig?: string;
  userData?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      input: 'Input',
      pipelineId: 'PipelineId',
      mediaDetailConfig: 'MediaDetailConfig',
      userData: 'UserData',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      input: 'string',
      pipelineId: 'string',
      mediaDetailConfig: 'string',
      userData: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitMediaDetailJobResponseBody extends $tea.Model {
  requestId?: string;
  jobId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      jobId: 'JobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      jobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitMediaDetailJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: SubmitMediaDetailJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: SubmitMediaDetailJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitMediaFpDeleteJobRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  pipelineId?: string;
  primaryKey?: string;
  fpDBId?: string;
  userData?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      pipelineId: 'PipelineId',
      primaryKey: 'PrimaryKey',
      fpDBId: 'FpDBId',
      userData: 'UserData',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      pipelineId: 'string',
      primaryKey: 'string',
      fpDBId: 'string',
      userData: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitMediaFpDeleteJobResponseBody extends $tea.Model {
  requestId?: string;
  jobId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      jobId: 'JobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      jobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitMediaFpDeleteJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: SubmitMediaFpDeleteJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: SubmitMediaFpDeleteJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitMediaInfoJobRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  input?: string;
  userData?: string;
  pipelineId?: string;
  async?: boolean;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      input: 'Input',
      userData: 'UserData',
      pipelineId: 'PipelineId',
      async: 'Async',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      input: 'string',
      userData: 'string',
      pipelineId: 'string',
      async: 'boolean',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitMediaInfoJobResponseBody extends $tea.Model {
  mediaInfoJob?: SubmitMediaInfoJobResponseBodyMediaInfoJob;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      mediaInfoJob: 'MediaInfoJob',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      mediaInfoJob: SubmitMediaInfoJobResponseBodyMediaInfoJob,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitMediaInfoJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: SubmitMediaInfoJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: SubmitMediaInfoJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitPornJobRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  input?: string;
  pipelineId?: string;
  pornConfig?: string;
  userData?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      input: 'Input',
      pipelineId: 'PipelineId',
      pornConfig: 'PornConfig',
      userData: 'UserData',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      input: 'string',
      pipelineId: 'string',
      pornConfig: 'string',
      userData: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitPornJobResponseBody extends $tea.Model {
  requestId?: string;
  jobId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      jobId: 'JobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      jobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitPornJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: SubmitPornJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: SubmitPornJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitSmarttagJobRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  pipelineId?: string;
  title?: string;
  content?: string;
  contentType?: string;
  contentAddr?: string;
  params?: string;
  notifyUrl?: string;
  userData?: string;
  input?: string;
  templateId?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      pipelineId: 'PipelineId',
      title: 'Title',
      content: 'Content',
      contentType: 'ContentType',
      contentAddr: 'ContentAddr',
      params: 'Params',
      notifyUrl: 'NotifyUrl',
      userData: 'UserData',
      input: 'Input',
      templateId: 'TemplateId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      pipelineId: 'string',
      title: 'string',
      content: 'string',
      contentType: 'string',
      contentAddr: 'string',
      params: 'string',
      notifyUrl: 'string',
      userData: 'string',
      input: 'string',
      templateId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitSmarttagJobResponseBody extends $tea.Model {
  requestId?: string;
  jobId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      jobId: 'JobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      jobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitSmarttagJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: SubmitSmarttagJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: SubmitSmarttagJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitSnapshotJobRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  input?: string;
  snapshotConfig?: string;
  userData?: string;
  pipelineId?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      input: 'Input',
      snapshotConfig: 'SnapshotConfig',
      userData: 'UserData',
      pipelineId: 'PipelineId',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      input: 'string',
      snapshotConfig: 'string',
      userData: 'string',
      pipelineId: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitSnapshotJobResponseBody extends $tea.Model {
  requestId?: string;
  snapshotJob?: SubmitSnapshotJobResponseBodySnapshotJob;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      snapshotJob: 'SnapshotJob',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      snapshotJob: SubmitSnapshotJobResponseBodySnapshotJob,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitSnapshotJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: SubmitSnapshotJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: SubmitSnapshotJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitSubtitleJobRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  inputConfig?: string;
  outputConfig?: string;
  pipelineId?: string;
  userData?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      inputConfig: 'InputConfig',
      outputConfig: 'OutputConfig',
      pipelineId: 'PipelineId',
      userData: 'UserData',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      inputConfig: 'string',
      outputConfig: 'string',
      pipelineId: 'string',
      userData: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitSubtitleJobResponseBody extends $tea.Model {
  requestId?: string;
  subtitleJob?: SubmitSubtitleJobResponseBodySubtitleJob;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      subtitleJob: 'SubtitleJob',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      subtitleJob: SubmitSubtitleJobResponseBodySubtitleJob,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitSubtitleJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: SubmitSubtitleJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: SubmitSubtitleJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitTagJobRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  input?: string;
  tagConfig?: string;
  userData?: string;
  pipelineId?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      input: 'Input',
      tagConfig: 'TagConfig',
      userData: 'UserData',
      pipelineId: 'PipelineId',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      input: 'string',
      tagConfig: 'string',
      userData: 'string',
      pipelineId: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitTagJobResponseBody extends $tea.Model {
  requestId?: string;
  jobId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      jobId: 'JobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      jobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitTagJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: SubmitTagJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: SubmitTagJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitTerrorismJobRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  input?: string;
  pipelineId?: string;
  terrorismConfig?: string;
  userData?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      input: 'Input',
      pipelineId: 'PipelineId',
      terrorismConfig: 'TerrorismConfig',
      userData: 'UserData',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      input: 'string',
      pipelineId: 'string',
      terrorismConfig: 'string',
      userData: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitTerrorismJobResponseBody extends $tea.Model {
  requestId?: string;
  jobId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      jobId: 'JobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      jobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitTerrorismJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: SubmitTerrorismJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: SubmitTerrorismJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitVideoGifJobRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  input?: string;
  pipelineId?: string;
  videoGifConfig?: string;
  userData?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      input: 'Input',
      pipelineId: 'PipelineId',
      videoGifConfig: 'VideoGifConfig',
      userData: 'UserData',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      input: 'string',
      pipelineId: 'string',
      videoGifConfig: 'string',
      userData: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitVideoGifJobResponseBody extends $tea.Model {
  requestId?: string;
  jobId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      jobId: 'JobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      jobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitVideoGifJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: SubmitVideoGifJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: SubmitVideoGifJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitVideoPoseJobRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  input?: string;
  outputConfig?: string;
  pipelineId?: string;
  userData?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      input: 'Input',
      outputConfig: 'OutputConfig',
      pipelineId: 'PipelineId',
      userData: 'UserData',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      input: 'string',
      outputConfig: 'string',
      pipelineId: 'string',
      userData: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitVideoPoseJobResponseBody extends $tea.Model {
  requestId?: string;
  videoPoseJob?: SubmitVideoPoseJobResponseBodyVideoPoseJob;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      videoPoseJob: 'VideoPoseJob',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      videoPoseJob: SubmitVideoPoseJobResponseBodyVideoPoseJob,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitVideoPoseJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: SubmitVideoPoseJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: SubmitVideoPoseJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitVideoQualityJobRequest extends $tea.Model {
  userId?: number;
  pipelineId?: string;
  sourceType?: string;
  modelId?: string;
  input?: string;
  output?: string;
  jobParams?: string;
  scheduleParams?: string;
  userData?: string;
  notifyUrl?: string;
  static names(): { [key: string]: string } {
    return {
      userId: 'UserId',
      pipelineId: 'PipelineId',
      sourceType: 'SourceType',
      modelId: 'ModelId',
      input: 'Input',
      output: 'Output',
      jobParams: 'JobParams',
      scheduleParams: 'ScheduleParams',
      userData: 'UserData',
      notifyUrl: 'NotifyUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      userId: 'number',
      pipelineId: 'string',
      sourceType: 'string',
      modelId: 'string',
      input: 'string',
      output: 'string',
      jobParams: 'string',
      scheduleParams: 'string',
      userData: 'string',
      notifyUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitVideoQualityJobResponseBody extends $tea.Model {
  message?: string;
  requestId?: string;
  code?: string;
  jobId?: string;
  static names(): { [key: string]: string } {
    return {
      message: 'Message',
      requestId: 'RequestId',
      code: 'Code',
      jobId: 'JobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      message: 'string',
      requestId: 'string',
      code: 'string',
      jobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitVideoQualityJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: SubmitVideoQualityJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: SubmitVideoQualityJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitVideoSplitJobRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  input?: string;
  pipelineId?: string;
  videoSplitConfig?: string;
  userData?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      input: 'Input',
      pipelineId: 'PipelineId',
      videoSplitConfig: 'VideoSplitConfig',
      userData: 'UserData',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      input: 'string',
      pipelineId: 'string',
      videoSplitConfig: 'string',
      userData: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitVideoSplitJobResponseBody extends $tea.Model {
  requestId?: string;
  jobId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      jobId: 'JobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      jobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitVideoSplitJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: SubmitVideoSplitJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: SubmitVideoSplitJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitVideoSummaryJobRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  input?: string;
  pipelineId?: string;
  videoSummaryConfig?: string;
  userData?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      input: 'Input',
      pipelineId: 'PipelineId',
      videoSummaryConfig: 'VideoSummaryConfig',
      userData: 'UserData',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      input: 'string',
      pipelineId: 'string',
      videoSummaryConfig: 'string',
      userData: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitVideoSummaryJobResponseBody extends $tea.Model {
  requestId?: string;
  jobId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      jobId: 'JobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      jobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitVideoSummaryJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: SubmitVideoSummaryJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: SubmitVideoSummaryJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TagCustomPersonRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  categoryId?: string;
  categoryName?: string;
  categoryDescription?: string;
  personId?: string;
  personName?: string;
  personDescription?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      categoryId: 'CategoryId',
      categoryName: 'CategoryName',
      categoryDescription: 'CategoryDescription',
      personId: 'PersonId',
      personName: 'PersonName',
      personDescription: 'PersonDescription',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      categoryId: 'string',
      categoryName: 'string',
      categoryDescription: 'string',
      personId: 'string',
      personName: 'string',
      personDescription: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TagCustomPersonResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TagCustomPersonResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: TagCustomPersonResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: TagCustomPersonResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnbindInputBucketRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  bucket?: string;
  roleArn?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      bucket: 'Bucket',
      roleArn: 'RoleArn',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      bucket: 'string',
      roleArn: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnbindInputBucketResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnbindInputBucketResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: UnbindInputBucketResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: UnbindInputBucketResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnbindOutputBucketRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  bucket?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      bucket: 'Bucket',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      bucket: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnbindOutputBucketResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnbindOutputBucketResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: UnbindOutputBucketResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: UnbindOutputBucketResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnregisterCustomFaceRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  categoryId?: string;
  personId?: string;
  faceId?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      categoryId: 'CategoryId',
      personId: 'PersonId',
      faceId: 'FaceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      categoryId: 'string',
      personId: 'string',
      faceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnregisterCustomFaceResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnregisterCustomFaceResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: UnregisterCustomFaceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: UnregisterCustomFaceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateAsrPipelineRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  pipelineId?: string;
  name?: string;
  state?: string;
  priority?: number;
  notifyConfig?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      pipelineId: 'PipelineId',
      name: 'Name',
      state: 'State',
      priority: 'Priority',
      notifyConfig: 'NotifyConfig',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      pipelineId: 'string',
      name: 'string',
      state: 'string',
      priority: 'number',
      notifyConfig: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateAsrPipelineResponseBody extends $tea.Model {
  requestId?: string;
  pipeline?: UpdateAsrPipelineResponseBodyPipeline;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      pipeline: 'Pipeline',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      pipeline: UpdateAsrPipelineResponseBodyPipeline,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateAsrPipelineResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: UpdateAsrPipelineResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: UpdateAsrPipelineResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCategoryNameRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  cateId?: string;
  cateName?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      cateId: 'CateId',
      cateName: 'CateName',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      cateId: 'string',
      cateName: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCategoryNameResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCategoryNameResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: UpdateCategoryNameResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: UpdateCategoryNameResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCensorPipelineRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  pipelineId?: string;
  name?: string;
  state?: string;
  priority?: number;
  notifyConfig?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      pipelineId: 'PipelineId',
      name: 'Name',
      state: 'State',
      priority: 'Priority',
      notifyConfig: 'NotifyConfig',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      pipelineId: 'string',
      name: 'string',
      state: 'string',
      priority: 'number',
      notifyConfig: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCensorPipelineResponseBody extends $tea.Model {
  requestId?: string;
  pipeline?: UpdateCensorPipelineResponseBodyPipeline;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      pipeline: 'Pipeline',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      pipeline: UpdateCensorPipelineResponseBodyPipeline,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCensorPipelineResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: UpdateCensorPipelineResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: UpdateCensorPipelineResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCoverPipelineRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  pipelineId?: string;
  name?: string;
  state?: string;
  priority?: number;
  notifyConfig?: string;
  role?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      pipelineId: 'PipelineId',
      name: 'Name',
      state: 'State',
      priority: 'Priority',
      notifyConfig: 'NotifyConfig',
      role: 'Role',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      pipelineId: 'string',
      name: 'string',
      state: 'string',
      priority: 'number',
      notifyConfig: 'string',
      role: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCoverPipelineResponseBody extends $tea.Model {
  requestId?: string;
  pipeline?: UpdateCoverPipelineResponseBodyPipeline;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      pipeline: 'Pipeline',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      pipeline: UpdateCoverPipelineResponseBodyPipeline,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCoverPipelineResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: UpdateCoverPipelineResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: UpdateCoverPipelineResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMCTemplateRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  templateId?: string;
  name?: string;
  porn?: string;
  terrorism?: string;
  politics?: string;
  ad?: string;
  qrcode?: string;
  live?: string;
  logo?: string;
  abuse?: string;
  contraband?: string;
  spam?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      templateId: 'TemplateId',
      name: 'Name',
      porn: 'Porn',
      terrorism: 'Terrorism',
      politics: 'Politics',
      ad: 'Ad',
      qrcode: 'Qrcode',
      live: 'Live',
      logo: 'Logo',
      abuse: 'Abuse',
      contraband: 'Contraband',
      spam: 'spam',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      templateId: 'string',
      name: 'string',
      porn: 'string',
      terrorism: 'string',
      politics: 'string',
      ad: 'string',
      qrcode: 'string',
      live: 'string',
      logo: 'string',
      abuse: 'string',
      contraband: 'string',
      spam: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMCTemplateResponseBody extends $tea.Model {
  requestId?: string;
  template?: UpdateMCTemplateResponseBodyTemplate;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      template: 'Template',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      template: UpdateMCTemplateResponseBodyTemplate,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMCTemplateResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: UpdateMCTemplateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: UpdateMCTemplateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMcuTemplateRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  templateId?: string;
  template?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      templateId: 'TemplateId',
      template: 'Template',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      templateId: 'string',
      template: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMcuTemplateResponseBody extends $tea.Model {
  requestId?: string;
  templateId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      templateId: 'TemplateId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      templateId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMcuTemplateResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: UpdateMcuTemplateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: UpdateMcuTemplateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMediaRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  mediaId?: string;
  title?: string;
  description?: string;
  coverURL?: string;
  cateId?: number;
  tags?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      mediaId: 'MediaId',
      title: 'Title',
      description: 'Description',
      coverURL: 'CoverURL',
      cateId: 'CateId',
      tags: 'Tags',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      mediaId: 'string',
      title: 'string',
      description: 'string',
      coverURL: 'string',
      cateId: 'number',
      tags: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMediaResponseBody extends $tea.Model {
  requestId?: string;
  media?: UpdateMediaResponseBodyMedia;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      media: 'Media',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      media: UpdateMediaResponseBodyMedia,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMediaResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: UpdateMediaResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: UpdateMediaResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMediaCategoryRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  mediaId?: string;
  cateId?: number;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      mediaId: 'MediaId',
      cateId: 'CateId',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      mediaId: 'string',
      cateId: 'number',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMediaCategoryResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMediaCategoryResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: UpdateMediaCategoryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: UpdateMediaCategoryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMediaCoverRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  mediaId?: string;
  coverURL?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      mediaId: 'MediaId',
      coverURL: 'CoverURL',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      mediaId: 'string',
      coverURL: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMediaCoverResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMediaCoverResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: UpdateMediaCoverResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: UpdateMediaCoverResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMediaPublishStateRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  mediaId?: string;
  publish?: boolean;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      mediaId: 'MediaId',
      publish: 'Publish',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      mediaId: 'string',
      publish: 'boolean',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMediaPublishStateResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMediaPublishStateResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: UpdateMediaPublishStateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: UpdateMediaPublishStateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMediaWorkflowRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  mediaWorkflowId?: string;
  topology?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      mediaWorkflowId: 'MediaWorkflowId',
      topology: 'Topology',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      mediaWorkflowId: 'string',
      topology: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMediaWorkflowResponseBody extends $tea.Model {
  requestId?: string;
  mediaWorkflow?: UpdateMediaWorkflowResponseBodyMediaWorkflow;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      mediaWorkflow: 'MediaWorkflow',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      mediaWorkflow: UpdateMediaWorkflowResponseBodyMediaWorkflow,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMediaWorkflowResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: UpdateMediaWorkflowResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: UpdateMediaWorkflowResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMediaWorkflowTriggerModeRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  mediaWorkflowId?: string;
  triggerMode?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      mediaWorkflowId: 'MediaWorkflowId',
      triggerMode: 'TriggerMode',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      mediaWorkflowId: 'string',
      triggerMode: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMediaWorkflowTriggerModeResponseBody extends $tea.Model {
  requestId?: string;
  mediaWorkflow?: UpdateMediaWorkflowTriggerModeResponseBodyMediaWorkflow;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      mediaWorkflow: 'MediaWorkflow',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      mediaWorkflow: UpdateMediaWorkflowTriggerModeResponseBodyMediaWorkflow,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMediaWorkflowTriggerModeResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: UpdateMediaWorkflowTriggerModeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: UpdateMediaWorkflowTriggerModeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePipelineRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  pipelineId?: string;
  name?: string;
  state?: string;
  notifyConfig?: string;
  role?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      pipelineId: 'PipelineId',
      name: 'Name',
      state: 'State',
      notifyConfig: 'NotifyConfig',
      role: 'Role',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      pipelineId: 'string',
      name: 'string',
      state: 'string',
      notifyConfig: 'string',
      role: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePipelineResponseBody extends $tea.Model {
  requestId?: string;
  pipeline?: UpdatePipelineResponseBodyPipeline;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      pipeline: 'Pipeline',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      pipeline: UpdatePipelineResponseBodyPipeline,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePipelineResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: UpdatePipelineResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: UpdatePipelineResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePornPipelineRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  pipelineId?: string;
  name?: string;
  state?: string;
  priority?: number;
  notifyConfig?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      pipelineId: 'PipelineId',
      name: 'Name',
      state: 'State',
      priority: 'Priority',
      notifyConfig: 'NotifyConfig',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      pipelineId: 'string',
      name: 'string',
      state: 'string',
      priority: 'number',
      notifyConfig: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePornPipelineResponseBody extends $tea.Model {
  requestId?: string;
  pipeline?: UpdatePornPipelineResponseBodyPipeline;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      pipeline: 'Pipeline',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      pipeline: UpdatePornPipelineResponseBodyPipeline,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePornPipelineResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: UpdatePornPipelineResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: UpdatePornPipelineResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSmarttagTemplateRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  templateId?: string;
  templateName?: string;
  industry?: string;
  scene?: string;
  analyseTypes?: string;
  faceCategoryIds?: string;
  isDefault?: boolean;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      templateId: 'TemplateId',
      templateName: 'TemplateName',
      industry: 'Industry',
      scene: 'Scene',
      analyseTypes: 'AnalyseTypes',
      faceCategoryIds: 'FaceCategoryIds',
      isDefault: 'IsDefault',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      templateId: 'string',
      templateName: 'string',
      industry: 'string',
      scene: 'string',
      analyseTypes: 'string',
      faceCategoryIds: 'string',
      isDefault: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSmarttagTemplateResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSmarttagTemplateResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: UpdateSmarttagTemplateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: UpdateSmarttagTemplateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTemplateRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  templateId?: string;
  name?: string;
  container?: string;
  video?: string;
  audio?: string;
  muxConfig?: string;
  transConfig?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      templateId: 'TemplateId',
      name: 'Name',
      container: 'Container',
      video: 'Video',
      audio: 'Audio',
      muxConfig: 'MuxConfig',
      transConfig: 'TransConfig',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      templateId: 'string',
      name: 'string',
      container: 'string',
      video: 'string',
      audio: 'string',
      muxConfig: 'string',
      transConfig: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTemplateResponseBody extends $tea.Model {
  requestId?: string;
  template?: UpdateTemplateResponseBodyTemplate;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      template: 'Template',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      template: UpdateTemplateResponseBodyTemplate,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTemplateResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: UpdateTemplateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: UpdateTemplateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTerrorismPipelineRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  pipelineId?: string;
  name?: string;
  state?: string;
  priority?: number;
  notifyConfig?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      pipelineId: 'PipelineId',
      name: 'Name',
      state: 'State',
      priority: 'Priority',
      notifyConfig: 'NotifyConfig',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      pipelineId: 'string',
      name: 'string',
      state: 'string',
      priority: 'number',
      notifyConfig: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTerrorismPipelineResponseBody extends $tea.Model {
  requestId?: string;
  pipeline?: UpdateTerrorismPipelineResponseBodyPipeline;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      pipeline: 'Pipeline',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      pipeline: UpdateTerrorismPipelineResponseBodyPipeline,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTerrorismPipelineResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: UpdateTerrorismPipelineResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: UpdateTerrorismPipelineResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWaterMarkTemplateRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  waterMarkTemplateId?: string;
  name?: string;
  config?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      waterMarkTemplateId: 'WaterMarkTemplateId',
      name: 'Name',
      config: 'Config',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      waterMarkTemplateId: 'string',
      name: 'string',
      config: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWaterMarkTemplateResponseBody extends $tea.Model {
  waterMarkTemplate?: UpdateWaterMarkTemplateResponseBodyWaterMarkTemplate;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      waterMarkTemplate: 'WaterMarkTemplate',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      waterMarkTemplate: UpdateWaterMarkTemplateResponseBodyWaterMarkTemplate,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWaterMarkTemplateResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: UpdateWaterMarkTemplateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: UpdateWaterMarkTemplateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ActivateMediaWorkflowResponseBodyMediaWorkflow extends $tea.Model {
  creationTime?: string;
  mediaWorkflowId?: string;
  state?: string;
  name?: string;
  topology?: string;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      mediaWorkflowId: 'MediaWorkflowId',
      state: 'State',
      name: 'Name',
      topology: 'Topology',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      mediaWorkflowId: 'string',
      state: 'string',
      name: 'string',
      topology: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddAsrPipelineResponseBodyPipelineNotifyConfig extends $tea.Model {
  topic?: string;
  queue?: string;
  static names(): { [key: string]: string } {
    return {
      topic: 'Topic',
      queue: 'Queue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      topic: 'string',
      queue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddAsrPipelineResponseBodyPipeline extends $tea.Model {
  state?: string;
  notifyConfig?: AddAsrPipelineResponseBodyPipelineNotifyConfig;
  priority?: number;
  name?: string;
  id?: string;
  static names(): { [key: string]: string } {
    return {
      state: 'State',
      notifyConfig: 'NotifyConfig',
      priority: 'Priority',
      name: 'Name',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      state: 'string',
      notifyConfig: AddAsrPipelineResponseBodyPipelineNotifyConfig,
      priority: 'number',
      name: 'string',
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddCategoryResponseBodyCategory extends $tea.Model {
  cateName?: string;
  parentId?: string;
  cateId?: string;
  level?: string;
  static names(): { [key: string]: string } {
    return {
      cateName: 'CateName',
      parentId: 'ParentId',
      cateId: 'CateId',
      level: 'Level',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cateName: 'string',
      parentId: 'string',
      cateId: 'string',
      level: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddCensorPipelineResponseBodyPipelineNotifyConfig extends $tea.Model {
  topic?: string;
  queue?: string;
  static names(): { [key: string]: string } {
    return {
      topic: 'Topic',
      queue: 'Queue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      topic: 'string',
      queue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddCensorPipelineResponseBodyPipeline extends $tea.Model {
  state?: string;
  notifyConfig?: AddCensorPipelineResponseBodyPipelineNotifyConfig;
  priority?: number;
  name?: string;
  id?: string;
  static names(): { [key: string]: string } {
    return {
      state: 'State',
      notifyConfig: 'NotifyConfig',
      priority: 'Priority',
      name: 'Name',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      state: 'string',
      notifyConfig: AddCensorPipelineResponseBodyPipelineNotifyConfig,
      priority: 'number',
      name: 'string',
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddCoverPipelineResponseBodyPipelineNotifyConfig extends $tea.Model {
  topic?: string;
  queue?: string;
  static names(): { [key: string]: string } {
    return {
      topic: 'Topic',
      queue: 'Queue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      topic: 'string',
      queue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddCoverPipelineResponseBodyPipeline extends $tea.Model {
  state?: string;
  notifyConfig?: AddCoverPipelineResponseBodyPipelineNotifyConfig;
  priority?: string;
  role?: string;
  name?: string;
  id?: string;
  static names(): { [key: string]: string } {
    return {
      state: 'State',
      notifyConfig: 'NotifyConfig',
      priority: 'Priority',
      role: 'Role',
      name: 'Name',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      state: 'string',
      notifyConfig: AddCoverPipelineResponseBodyPipelineNotifyConfig,
      priority: 'string',
      role: 'string',
      name: 'string',
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddMCTemplateResponseBodyTemplate extends $tea.Model {
  logo?: string;
  abuse?: string;
  terrorism?: string;
  politics?: string;
  qrcode?: string;
  spam?: string;
  live?: string;
  contraband?: string;
  ad?: string;
  porn?: string;
  name?: string;
  templateId?: string;
  static names(): { [key: string]: string } {
    return {
      logo: 'Logo',
      abuse: 'Abuse',
      terrorism: 'Terrorism',
      politics: 'Politics',
      qrcode: 'Qrcode',
      spam: 'Spam',
      live: 'Live',
      contraband: 'Contraband',
      ad: 'Ad',
      porn: 'Porn',
      name: 'Name',
      templateId: 'TemplateId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      logo: 'string',
      abuse: 'string',
      terrorism: 'string',
      politics: 'string',
      qrcode: 'string',
      spam: 'string',
      live: 'string',
      contraband: 'string',
      ad: 'string',
      porn: 'string',
      name: 'string',
      templateId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddMediaResponseBodyMediaTags extends $tea.Model {
  tag?: string[];
  static names(): { [key: string]: string } {
    return {
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tag: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddMediaResponseBodyMediaFile extends $tea.Model {
  state?: string;
  URL?: string;
  static names(): { [key: string]: string } {
    return {
      state: 'State',
      URL: 'URL',
    };
  }

  static types(): { [key: string]: any } {
    return {
      state: 'string',
      URL: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddMediaResponseBodyMediaRunIdList extends $tea.Model {
  runId?: string[];
  static names(): { [key: string]: string } {
    return {
      runId: 'RunId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      runId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddMediaResponseBodyMedia extends $tea.Model {
  creationTime?: string;
  cateId?: number;
  height?: string;
  censorState?: string;
  tags?: AddMediaResponseBodyMediaTags;
  bitrate?: string;
  mediaId?: string;
  file?: AddMediaResponseBodyMediaFile;
  publishState?: string;
  description?: string;
  width?: string;
  size?: string;
  coverURL?: string;
  runIdList?: AddMediaResponseBodyMediaRunIdList;
  duration?: string;
  fps?: string;
  title?: string;
  format?: string;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      cateId: 'CateId',
      height: 'Height',
      censorState: 'CensorState',
      tags: 'Tags',
      bitrate: 'Bitrate',
      mediaId: 'MediaId',
      file: 'File',
      publishState: 'PublishState',
      description: 'Description',
      width: 'Width',
      size: 'Size',
      coverURL: 'CoverURL',
      runIdList: 'RunIdList',
      duration: 'Duration',
      fps: 'Fps',
      title: 'Title',
      format: 'Format',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      cateId: 'number',
      height: 'string',
      censorState: 'string',
      tags: AddMediaResponseBodyMediaTags,
      bitrate: 'string',
      mediaId: 'string',
      file: AddMediaResponseBodyMediaFile,
      publishState: 'string',
      description: 'string',
      width: 'string',
      size: 'string',
      coverURL: 'string',
      runIdList: AddMediaResponseBodyMediaRunIdList,
      duration: 'string',
      fps: 'string',
      title: 'string',
      format: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddMediaWorkflowResponseBodyMediaWorkflow extends $tea.Model {
  creationTime?: string;
  mediaWorkflowId?: string;
  state?: string;
  triggerMode?: string;
  name?: string;
  topology?: string;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      mediaWorkflowId: 'MediaWorkflowId',
      state: 'State',
      triggerMode: 'TriggerMode',
      name: 'Name',
      topology: 'Topology',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      mediaWorkflowId: 'string',
      state: 'string',
      triggerMode: 'string',
      name: 'string',
      topology: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddPipelineResponseBodyPipelineNotifyConfig extends $tea.Model {
  mqTopic?: string;
  queueName?: string;
  mqTag?: string;
  topic?: string;
  static names(): { [key: string]: string } {
    return {
      mqTopic: 'MqTopic',
      queueName: 'QueueName',
      mqTag: 'MqTag',
      topic: 'Topic',
    };
  }

  static types(): { [key: string]: any } {
    return {
      mqTopic: 'string',
      queueName: 'string',
      mqTag: 'string',
      topic: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddPipelineResponseBodyPipeline extends $tea.Model {
  speed?: string;
  state?: string;
  speedLevel?: number;
  notifyConfig?: AddPipelineResponseBodyPipelineNotifyConfig;
  role?: string;
  name?: string;
  id?: string;
  quotaAllocate?: number;
  static names(): { [key: string]: string } {
    return {
      speed: 'Speed',
      state: 'State',
      speedLevel: 'SpeedLevel',
      notifyConfig: 'NotifyConfig',
      role: 'Role',
      name: 'Name',
      id: 'Id',
      quotaAllocate: 'QuotaAllocate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      speed: 'string',
      state: 'string',
      speedLevel: 'number',
      notifyConfig: AddPipelineResponseBodyPipelineNotifyConfig,
      role: 'string',
      name: 'string',
      id: 'string',
      quotaAllocate: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddPornPipelineResponseBodyPipelineNotifyConfig extends $tea.Model {
  topic?: string;
  queue?: string;
  static names(): { [key: string]: string } {
    return {
      topic: 'Topic',
      queue: 'Queue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      topic: 'string',
      queue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddPornPipelineResponseBodyPipeline extends $tea.Model {
  state?: string;
  notifyConfig?: AddPornPipelineResponseBodyPipelineNotifyConfig;
  priority?: number;
  name?: string;
  id?: string;
  static names(): { [key: string]: string } {
    return {
      state: 'State',
      notifyConfig: 'NotifyConfig',
      priority: 'Priority',
      name: 'Name',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      state: 'string',
      notifyConfig: AddPornPipelineResponseBodyPipelineNotifyConfig,
      priority: 'number',
      name: 'string',
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddTemplateResponseBodyTemplateVideoBitrateBnd extends $tea.Model {
  max?: string;
  min?: string;
  static names(): { [key: string]: string } {
    return {
      max: 'Max',
      min: 'Min',
    };
  }

  static types(): { [key: string]: any } {
    return {
      max: 'string',
      min: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddTemplateResponseBodyTemplateVideo extends $tea.Model {
  bufsize?: string;
  longShortMode?: string;
  degrain?: string;
  bitrateBnd?: AddTemplateResponseBodyTemplateVideoBitrateBnd;
  pixFmt?: string;
  pad?: string;
  codec?: string;
  height?: string;
  qscale?: string;
  crop?: string;
  bitrate?: string;
  maxrate?: string;
  maxFps?: string;
  profile?: string;
  crf?: string;
  remove?: string;
  gop?: string;
  width?: string;
  fps?: string;
  preset?: string;
  scanMode?: string;
  resoPriority?: string;
  static names(): { [key: string]: string } {
    return {
      bufsize: 'Bufsize',
      longShortMode: 'LongShortMode',
      degrain: 'Degrain',
      bitrateBnd: 'BitrateBnd',
      pixFmt: 'PixFmt',
      pad: 'Pad',
      codec: 'Codec',
      height: 'Height',
      qscale: 'Qscale',
      crop: 'Crop',
      bitrate: 'Bitrate',
      maxrate: 'Maxrate',
      maxFps: 'MaxFps',
      profile: 'Profile',
      crf: 'Crf',
      remove: 'Remove',
      gop: 'Gop',
      width: 'Width',
      fps: 'Fps',
      preset: 'Preset',
      scanMode: 'ScanMode',
      resoPriority: 'ResoPriority',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bufsize: 'string',
      longShortMode: 'string',
      degrain: 'string',
      bitrateBnd: AddTemplateResponseBodyTemplateVideoBitrateBnd,
      pixFmt: 'string',
      pad: 'string',
      codec: 'string',
      height: 'string',
      qscale: 'string',
      crop: 'string',
      bitrate: 'string',
      maxrate: 'string',
      maxFps: 'string',
      profile: 'string',
      crf: 'string',
      remove: 'string',
      gop: 'string',
      width: 'string',
      fps: 'string',
      preset: 'string',
      scanMode: 'string',
      resoPriority: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddTemplateResponseBodyTemplateTransConfig extends $tea.Model {
  isCheckAudioBitrate?: string;
  transMode?: string;
  isCheckReso?: string;
  isCheckVideoBitrateFail?: string;
  adjDarMethod?: string;
  isCheckVideoBitrate?: string;
  isCheckResoFail?: string;
  isCheckAudioBitrateFail?: string;
  static names(): { [key: string]: string } {
    return {
      isCheckAudioBitrate: 'IsCheckAudioBitrate',
      transMode: 'TransMode',
      isCheckReso: 'IsCheckReso',
      isCheckVideoBitrateFail: 'IsCheckVideoBitrateFail',
      adjDarMethod: 'AdjDarMethod',
      isCheckVideoBitrate: 'IsCheckVideoBitrate',
      isCheckResoFail: 'IsCheckResoFail',
      isCheckAudioBitrateFail: 'IsCheckAudioBitrateFail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isCheckAudioBitrate: 'string',
      transMode: 'string',
      isCheckReso: 'string',
      isCheckVideoBitrateFail: 'string',
      adjDarMethod: 'string',
      isCheckVideoBitrate: 'string',
      isCheckResoFail: 'string',
      isCheckAudioBitrateFail: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddTemplateResponseBodyTemplateMuxConfigWebp extends $tea.Model {
  loop?: string;
  static names(): { [key: string]: string } {
    return {
      loop: 'Loop',
    };
  }

  static types(): { [key: string]: any } {
    return {
      loop: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddTemplateResponseBodyTemplateMuxConfigGif extends $tea.Model {
  finalDelay?: string;
  ditherMode?: string;
  loop?: string;
  isCustomPalette?: string;
  static names(): { [key: string]: string } {
    return {
      finalDelay: 'FinalDelay',
      ditherMode: 'DitherMode',
      loop: 'Loop',
      isCustomPalette: 'IsCustomPalette',
    };
  }

  static types(): { [key: string]: any } {
    return {
      finalDelay: 'string',
      ditherMode: 'string',
      loop: 'string',
      isCustomPalette: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddTemplateResponseBodyTemplateMuxConfigSegment extends $tea.Model {
  duration?: string;
  static names(): { [key: string]: string } {
    return {
      duration: 'Duration',
    };
  }

  static types(): { [key: string]: any } {
    return {
      duration: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddTemplateResponseBodyTemplateMuxConfig extends $tea.Model {
  webp?: AddTemplateResponseBodyTemplateMuxConfigWebp;
  gif?: AddTemplateResponseBodyTemplateMuxConfigGif;
  segment?: AddTemplateResponseBodyTemplateMuxConfigSegment;
  static names(): { [key: string]: string } {
    return {
      webp: 'Webp',
      gif: 'Gif',
      segment: 'Segment',
    };
  }

  static types(): { [key: string]: any } {
    return {
      webp: AddTemplateResponseBodyTemplateMuxConfigWebp,
      gif: AddTemplateResponseBodyTemplateMuxConfigGif,
      segment: AddTemplateResponseBodyTemplateMuxConfigSegment,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddTemplateResponseBodyTemplateAudioVolume extends $tea.Model {
  method?: string;
  level?: string;
  static names(): { [key: string]: string } {
    return {
      method: 'Method',
      level: 'Level',
    };
  }

  static types(): { [key: string]: any } {
    return {
      method: 'string',
      level: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddTemplateResponseBodyTemplateAudio extends $tea.Model {
  profile?: string;
  remove?: string;
  codec?: string;
  samplerate?: string;
  qscale?: string;
  channels?: string;
  volume?: AddTemplateResponseBodyTemplateAudioVolume;
  bitrate?: string;
  static names(): { [key: string]: string } {
    return {
      profile: 'Profile',
      remove: 'Remove',
      codec: 'Codec',
      samplerate: 'Samplerate',
      qscale: 'Qscale',
      channels: 'Channels',
      volume: 'Volume',
      bitrate: 'Bitrate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      profile: 'string',
      remove: 'string',
      codec: 'string',
      samplerate: 'string',
      qscale: 'string',
      channels: 'string',
      volume: AddTemplateResponseBodyTemplateAudioVolume,
      bitrate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddTemplateResponseBodyTemplateContainer extends $tea.Model {
  format?: string;
  static names(): { [key: string]: string } {
    return {
      format: 'Format',
    };
  }

  static types(): { [key: string]: any } {
    return {
      format: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddTemplateResponseBodyTemplate extends $tea.Model {
  video?: AddTemplateResponseBodyTemplateVideo;
  transConfig?: AddTemplateResponseBodyTemplateTransConfig;
  state?: string;
  muxConfig?: AddTemplateResponseBodyTemplateMuxConfig;
  name?: string;
  audio?: AddTemplateResponseBodyTemplateAudio;
  id?: string;
  container?: AddTemplateResponseBodyTemplateContainer;
  static names(): { [key: string]: string } {
    return {
      video: 'Video',
      transConfig: 'TransConfig',
      state: 'State',
      muxConfig: 'MuxConfig',
      name: 'Name',
      audio: 'Audio',
      id: 'Id',
      container: 'Container',
    };
  }

  static types(): { [key: string]: any } {
    return {
      video: AddTemplateResponseBodyTemplateVideo,
      transConfig: AddTemplateResponseBodyTemplateTransConfig,
      state: 'string',
      muxConfig: AddTemplateResponseBodyTemplateMuxConfig,
      name: 'string',
      audio: AddTemplateResponseBodyTemplateAudio,
      id: 'string',
      container: AddTemplateResponseBodyTemplateContainer,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddTerrorismPipelineResponseBodyPipelineNotifyConfig extends $tea.Model {
  topic?: string;
  queue?: string;
  static names(): { [key: string]: string } {
    return {
      topic: 'Topic',
      queue: 'Queue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      topic: 'string',
      queue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddTerrorismPipelineResponseBodyPipeline extends $tea.Model {
  state?: string;
  notifyConfig?: AddTerrorismPipelineResponseBodyPipelineNotifyConfig;
  priority?: number;
  name?: string;
  id?: string;
  static names(): { [key: string]: string } {
    return {
      state: 'State',
      notifyConfig: 'NotifyConfig',
      priority: 'Priority',
      name: 'Name',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      state: 'string',
      notifyConfig: AddTerrorismPipelineResponseBodyPipelineNotifyConfig,
      priority: 'number',
      name: 'string',
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddWaterMarkTemplateResponseBodyWaterMarkTemplateRatioRefer extends $tea.Model {
  dx?: string;
  width?: string;
  height?: string;
  dy?: string;
  static names(): { [key: string]: string } {
    return {
      dx: 'Dx',
      width: 'Width',
      height: 'Height',
      dy: 'Dy',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dx: 'string',
      width: 'string',
      height: 'string',
      dy: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddWaterMarkTemplateResponseBodyWaterMarkTemplateTimeline extends $tea.Model {
  start?: string;
  duration?: string;
  static names(): { [key: string]: string } {
    return {
      start: 'Start',
      duration: 'Duration',
    };
  }

  static types(): { [key: string]: any } {
    return {
      start: 'string',
      duration: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddWaterMarkTemplateResponseBodyWaterMarkTemplate extends $tea.Model {
  type?: string;
  ratioRefer?: AddWaterMarkTemplateResponseBodyWaterMarkTemplateRatioRefer;
  referPos?: string;
  state?: string;
  dx?: string;
  width?: string;
  height?: string;
  timeline?: AddWaterMarkTemplateResponseBodyWaterMarkTemplateTimeline;
  name?: string;
  dy?: string;
  id?: string;
  static names(): { [key: string]: string } {
    return {
      type: 'Type',
      ratioRefer: 'RatioRefer',
      referPos: 'ReferPos',
      state: 'State',
      dx: 'Dx',
      width: 'Width',
      height: 'Height',
      timeline: 'Timeline',
      name: 'Name',
      dy: 'Dy',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      type: 'string',
      ratioRefer: AddWaterMarkTemplateResponseBodyWaterMarkTemplateRatioRefer,
      referPos: 'string',
      state: 'string',
      dx: 'string',
      width: 'string',
      height: 'string',
      timeline: AddWaterMarkTemplateResponseBodyWaterMarkTemplateTimeline,
      name: 'string',
      dy: 'string',
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFpShotDBResponseBodyFpShotDB extends $tea.Model {
  description?: string;
  state?: string;
  name?: string;
  fpDBId?: string;
  modelId?: number;
  config?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      state: 'State',
      name: 'Name',
      fpDBId: 'FpDBId',
      modelId: 'ModelId',
      config: 'Config',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      state: 'string',
      name: 'string',
      fpDBId: 'string',
      modelId: 'number',
      config: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeactivateMediaWorkflowResponseBodyMediaWorkflow extends $tea.Model {
  creationTime?: string;
  mediaWorkflowId?: string;
  state?: string;
  name?: string;
  topology?: string;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      mediaWorkflowId: 'MediaWorkflowId',
      state: 'State',
      name: 'Name',
      topology: 'Topology',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      mediaWorkflowId: 'string',
      state: 'string',
      name: 'string',
      topology: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMcuJobResponseBodyNonExistJobIds extends $tea.Model {
  string?: string[];
  static names(): { [key: string]: string } {
    return {
      string: 'String',
    };
  }

  static types(): { [key: string]: any } {
    return {
      string: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMcuJobResponseBodyDeletedJobIds extends $tea.Model {
  string?: string[];
  static names(): { [key: string]: string } {
    return {
      string: 'String',
    };
  }

  static types(): { [key: string]: any } {
    return {
      string: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMediaWorkflowResponseBodyMediaWorkflow extends $tea.Model {
  creationTime?: string;
  mediaWorkflowId?: string;
  state?: string;
  name?: string;
  topology?: string;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      mediaWorkflowId: 'MediaWorkflowId',
      state: 'State',
      name: 'Name',
      topology: 'Topology',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      mediaWorkflowId: 'string',
      state: 'string',
      name: 'string',
      topology: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMtsUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo extends $tea.Model {
  displayName?: string;
  status?: string;
  commodityCode?: string;
  currCapacity?: string;
  initCapacity?: string;
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      displayName: 'DisplayName',
      status: 'Status',
      commodityCode: 'CommodityCode',
      currCapacity: 'CurrCapacity',
      initCapacity: 'InitCapacity',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      displayName: 'string',
      status: 'string',
      commodityCode: 'string',
      currCapacity: 'string',
      initCapacity: 'string',
      instanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMtsUserResourcePackageResponseBodyResourcePackageInfos extends $tea.Model {
  resourcePackageInfo?: DescribeMtsUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo[];
  static names(): { [key: string]: string } {
    return {
      resourcePackageInfo: 'ResourcePackageInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resourcePackageInfo: { 'type': 'array', 'itemType': DescribeMtsUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAllCategoryResponseBodyCategoryListCategory extends $tea.Model {
  cateName?: string;
  parentId?: string;
  cateId?: string;
  level?: string;
  static names(): { [key: string]: string } {
    return {
      cateName: 'CateName',
      parentId: 'ParentId',
      cateId: 'CateId',
      level: 'Level',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cateName: 'string',
      parentId: 'string',
      cateId: 'string',
      level: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAllCategoryResponseBodyCategoryList extends $tea.Model {
  category?: ListAllCategoryResponseBodyCategoryListCategory[];
  static names(): { [key: string]: string } {
    return {
      category: 'Category',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: { 'type': 'array', 'itemType': ListAllCategoryResponseBodyCategoryListCategory },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAllMediaBucketResponseBodyMediaBucketListMediaBucket extends $tea.Model {
  type?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      type: 'Type',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      type: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAllMediaBucketResponseBodyMediaBucketList extends $tea.Model {
  mediaBucket?: ListAllMediaBucketResponseBodyMediaBucketListMediaBucket[];
  static names(): { [key: string]: string } {
    return {
      mediaBucket: 'MediaBucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      mediaBucket: { 'type': 'array', 'itemType': ListAllMediaBucketResponseBodyMediaBucketListMediaBucket },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAsrPipelineResponseBodyPipelineListPipelineNotifyConfig extends $tea.Model {
  queueName?: string;
  topic?: string;
  static names(): { [key: string]: string } {
    return {
      queueName: 'QueueName',
      topic: 'Topic',
    };
  }

  static types(): { [key: string]: any } {
    return {
      queueName: 'string',
      topic: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAsrPipelineResponseBodyPipelineListPipeline extends $tea.Model {
  state?: string;
  notifyConfig?: ListAsrPipelineResponseBodyPipelineListPipelineNotifyConfig;
  priority?: string;
  name?: string;
  id?: string;
  static names(): { [key: string]: string } {
    return {
      state: 'State',
      notifyConfig: 'NotifyConfig',
      priority: 'Priority',
      name: 'Name',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      state: 'string',
      notifyConfig: ListAsrPipelineResponseBodyPipelineListPipelineNotifyConfig,
      priority: 'string',
      name: 'string',
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAsrPipelineResponseBodyPipelineList extends $tea.Model {
  pipeline?: ListAsrPipelineResponseBodyPipelineListPipeline[];
  static names(): { [key: string]: string } {
    return {
      pipeline: 'Pipeline',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pipeline: { 'type': 'array', 'itemType': ListAsrPipelineResponseBodyPipelineListPipeline },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCensorPipelineResponseBodyPipelineListPipelineNotifyConfig extends $tea.Model {
  topic?: string;
  queue?: string;
  static names(): { [key: string]: string } {
    return {
      topic: 'Topic',
      queue: 'Queue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      topic: 'string',
      queue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCensorPipelineResponseBodyPipelineListPipeline extends $tea.Model {
  state?: string;
  notifyConfig?: ListCensorPipelineResponseBodyPipelineListPipelineNotifyConfig;
  priority?: string;
  name?: string;
  id?: string;
  static names(): { [key: string]: string } {
    return {
      state: 'State',
      notifyConfig: 'NotifyConfig',
      priority: 'Priority',
      name: 'Name',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      state: 'string',
      notifyConfig: ListCensorPipelineResponseBodyPipelineListPipelineNotifyConfig,
      priority: 'string',
      name: 'string',
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCensorPipelineResponseBodyPipelineList extends $tea.Model {
  pipeline?: ListCensorPipelineResponseBodyPipelineListPipeline[];
  static names(): { [key: string]: string } {
    return {
      pipeline: 'Pipeline',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pipeline: { 'type': 'array', 'itemType': ListCensorPipelineResponseBodyPipelineListPipeline },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCoverPipelineResponseBodyPipelineListPipeline extends $tea.Model {
  state?: string;
  quotaNum?: number;
  userId?: number;
  notifyConfig?: string;
  extendConfig?: string;
  priority?: string;
  role?: string;
  name?: string;
  pipelineId?: string;
  quotaUsed?: number;
  static names(): { [key: string]: string } {
    return {
      state: 'State',
      quotaNum: 'quotaNum',
      userId: 'UserId',
      notifyConfig: 'NotifyConfig',
      extendConfig: 'ExtendConfig',
      priority: 'Priority',
      role: 'Role',
      name: 'Name',
      pipelineId: 'PipelineId',
      quotaUsed: 'quotaUsed',
    };
  }

  static types(): { [key: string]: any } {
    return {
      state: 'string',
      quotaNum: 'number',
      userId: 'number',
      notifyConfig: 'string',
      extendConfig: 'string',
      priority: 'string',
      role: 'string',
      name: 'string',
      pipelineId: 'string',
      quotaUsed: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCoverPipelineResponseBodyPipelineList extends $tea.Model {
  pipeline?: ListCoverPipelineResponseBodyPipelineListPipeline[];
  static names(): { [key: string]: string } {
    return {
      pipeline: 'Pipeline',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pipeline: { 'type': 'array', 'itemType': ListCoverPipelineResponseBodyPipelineListPipeline },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCustomPersonsResponseBodyCategoriesCategoryPersonsPersonFacesFace extends $tea.Model {
  imageUrl?: string;
  faceId?: string;
  static names(): { [key: string]: string } {
    return {
      imageUrl: 'ImageUrl',
      faceId: 'FaceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      imageUrl: 'string',
      faceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCustomPersonsResponseBodyCategoriesCategoryPersonsPersonFaces extends $tea.Model {
  face?: ListCustomPersonsResponseBodyCategoriesCategoryPersonsPersonFacesFace[];
  static names(): { [key: string]: string } {
    return {
      face: 'Face',
    };
  }

  static types(): { [key: string]: any } {
    return {
      face: { 'type': 'array', 'itemType': ListCustomPersonsResponseBodyCategoriesCategoryPersonsPersonFacesFace },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCustomPersonsResponseBodyCategoriesCategoryPersonsPerson extends $tea.Model {
  personName?: string;
  personDescription?: string;
  faces?: ListCustomPersonsResponseBodyCategoriesCategoryPersonsPersonFaces;
  personId?: string;
  static names(): { [key: string]: string } {
    return {
      personName: 'PersonName',
      personDescription: 'PersonDescription',
      faces: 'Faces',
      personId: 'PersonId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      personName: 'string',
      personDescription: 'string',
      faces: ListCustomPersonsResponseBodyCategoriesCategoryPersonsPersonFaces,
      personId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCustomPersonsResponseBodyCategoriesCategoryPersons extends $tea.Model {
  person?: ListCustomPersonsResponseBodyCategoriesCategoryPersonsPerson[];
  static names(): { [key: string]: string } {
    return {
      person: 'Person',
    };
  }

  static types(): { [key: string]: any } {
    return {
      person: { 'type': 'array', 'itemType': ListCustomPersonsResponseBodyCategoriesCategoryPersonsPerson },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCustomPersonsResponseBodyCategoriesCategory extends $tea.Model {
  persons?: ListCustomPersonsResponseBodyCategoriesCategoryPersons;
  categoryId?: string;
  categoryName?: string;
  categoryDescription?: string;
  static names(): { [key: string]: string } {
    return {
      persons: 'Persons',
      categoryId: 'CategoryId',
      categoryName: 'CategoryName',
      categoryDescription: 'CategoryDescription',
    };
  }

  static types(): { [key: string]: any } {
    return {
      persons: ListCustomPersonsResponseBodyCategoriesCategoryPersons,
      categoryId: 'string',
      categoryName: 'string',
      categoryDescription: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCustomPersonsResponseBodyCategories extends $tea.Model {
  category?: ListCustomPersonsResponseBodyCategoriesCategory[];
  static names(): { [key: string]: string } {
    return {
      category: 'Category',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: { 'type': 'array', 'itemType': ListCustomPersonsResponseBodyCategoriesCategory },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFpShotDBResponseBodyFpShotDBListFpShotDB extends $tea.Model {
  status?: string;
  description?: string;
  name?: string;
  modelId?: number;
  fpDBId?: string;
  static names(): { [key: string]: string } {
    return {
      status: 'Status',
      description: 'Description',
      name: 'Name',
      modelId: 'ModelId',
      fpDBId: 'FpDBId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      status: 'string',
      description: 'string',
      name: 'string',
      modelId: 'number',
      fpDBId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFpShotDBResponseBodyFpShotDBList extends $tea.Model {
  fpShotDB?: ListFpShotDBResponseBodyFpShotDBListFpShotDB[];
  static names(): { [key: string]: string } {
    return {
      fpShotDB: 'FpShotDB',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fpShotDB: { 'type': 'array', 'itemType': ListFpShotDBResponseBodyFpShotDBListFpShotDB },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFpShotDBResponseBodyNonExistIds extends $tea.Model {
  string?: string[];
  static names(): { [key: string]: string } {
    return {
      string: 'String',
    };
  }

  static types(): { [key: string]: any } {
    return {
      string: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFpShotFilesResponseBodyFpShotFileListFpShotFileInputFile extends $tea.Model {
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFpShotFilesResponseBodyFpShotFileListFpShotFile extends $tea.Model {
  primaryKey?: string;
  inputFile?: ListFpShotFilesResponseBodyFpShotFileListFpShotFileInputFile;
  fileId?: string;
  static names(): { [key: string]: string } {
    return {
      primaryKey: 'PrimaryKey',
      inputFile: 'InputFile',
      fileId: 'FileId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      primaryKey: 'string',
      inputFile: ListFpShotFilesResponseBodyFpShotFileListFpShotFileInputFile,
      fileId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFpShotFilesResponseBodyFpShotFileList extends $tea.Model {
  fpShotFile?: ListFpShotFilesResponseBodyFpShotFileListFpShotFile[];
  static names(): { [key: string]: string } {
    return {
      fpShotFile: 'FpShotFile',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fpShotFile: { 'type': 'array', 'itemType': ListFpShotFilesResponseBodyFpShotFileListFpShotFile },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFpShotNotaryResponseBodyFpShotNotaryListFpShotNotary extends $tea.Model {
  creationTime?: string;
  finishTime?: string;
  jobId?: string;
  txHash?: string;
  transactionId?: string;
  fpDBId?: string;
  detail?: string;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      finishTime: 'FinishTime',
      jobId: 'JobId',
      txHash: 'TxHash',
      transactionId: 'TransactionId',
      fpDBId: 'FpDBId',
      detail: 'Detail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      finishTime: 'string',
      jobId: 'string',
      txHash: 'string',
      transactionId: 'string',
      fpDBId: 'string',
      detail: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFpShotNotaryResponseBodyFpShotNotaryList extends $tea.Model {
  fpShotNotary?: ListFpShotNotaryResponseBodyFpShotNotaryListFpShotNotary[];
  static names(): { [key: string]: string } {
    return {
      fpShotNotary: 'FpShotNotary',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fpShotNotary: { 'type': 'array', 'itemType': ListFpShotNotaryResponseBodyFpShotNotaryListFpShotNotary },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobResponseBodyJobListJobOutputVideoBitrateBnd extends $tea.Model {
  max?: string;
  min?: string;
  static names(): { [key: string]: string } {
    return {
      max: 'Max',
      min: 'Min',
    };
  }

  static types(): { [key: string]: any } {
    return {
      max: 'string',
      min: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobResponseBodyJobListJobOutputVideo extends $tea.Model {
  bufsize?: string;
  degrain?: string;
  bitrateBnd?: ListJobResponseBodyJobListJobOutputVideoBitrateBnd;
  pixFmt?: string;
  pad?: string;
  codec?: string;
  height?: string;
  qscale?: string;
  crop?: string;
  bitrate?: string;
  maxrate?: string;
  maxFps?: string;
  profile?: string;
  crf?: string;
  gop?: string;
  width?: string;
  fps?: string;
  preset?: string;
  scanMode?: string;
  resoPriority?: string;
  static names(): { [key: string]: string } {
    return {
      bufsize: 'Bufsize',
      degrain: 'Degrain',
      bitrateBnd: 'BitrateBnd',
      pixFmt: 'PixFmt',
      pad: 'Pad',
      codec: 'Codec',
      height: 'Height',
      qscale: 'Qscale',
      crop: 'Crop',
      bitrate: 'Bitrate',
      maxrate: 'Maxrate',
      maxFps: 'MaxFps',
      profile: 'Profile',
      crf: 'Crf',
      gop: 'Gop',
      width: 'Width',
      fps: 'Fps',
      preset: 'Preset',
      scanMode: 'ScanMode',
      resoPriority: 'ResoPriority',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bufsize: 'string',
      degrain: 'string',
      bitrateBnd: ListJobResponseBodyJobListJobOutputVideoBitrateBnd,
      pixFmt: 'string',
      pad: 'string',
      codec: 'string',
      height: 'string',
      qscale: 'string',
      crop: 'string',
      bitrate: 'string',
      maxrate: 'string',
      maxFps: 'string',
      profile: 'string',
      crf: 'string',
      gop: 'string',
      width: 'string',
      fps: 'string',
      preset: 'string',
      scanMode: 'string',
      resoPriority: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobResponseBodyJobListJobOutputTransConfig extends $tea.Model {
  isCheckAudioBitrate?: string;
  transMode?: string;
  isCheckReso?: string;
  isCheckVideoBitrateFail?: string;
  adjDarMethod?: string;
  isCheckVideoBitrate?: string;
  isCheckResoFail?: string;
  isCheckAudioBitrateFail?: string;
  static names(): { [key: string]: string } {
    return {
      isCheckAudioBitrate: 'IsCheckAudioBitrate',
      transMode: 'TransMode',
      isCheckReso: 'IsCheckReso',
      isCheckVideoBitrateFail: 'IsCheckVideoBitrateFail',
      adjDarMethod: 'AdjDarMethod',
      isCheckVideoBitrate: 'IsCheckVideoBitrate',
      isCheckResoFail: 'IsCheckResoFail',
      isCheckAudioBitrateFail: 'IsCheckAudioBitrateFail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isCheckAudioBitrate: 'string',
      transMode: 'string',
      isCheckReso: 'string',
      isCheckVideoBitrateFail: 'string',
      adjDarMethod: 'string',
      isCheckVideoBitrate: 'string',
      isCheckResoFail: 'string',
      isCheckAudioBitrateFail: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobResponseBodyJobListJobOutputEncryption extends $tea.Model {
  type?: string;
  key?: string;
  keyType?: string;
  id?: string;
  keyUri?: string;
  skipCnt?: string;
  static names(): { [key: string]: string } {
    return {
      type: 'Type',
      key: 'Key',
      keyType: 'KeyType',
      id: 'Id',
      keyUri: 'KeyUri',
      skipCnt: 'SkipCnt',
    };
  }

  static types(): { [key: string]: any } {
    return {
      type: 'string',
      key: 'string',
      keyType: 'string',
      id: 'string',
      keyUri: 'string',
      skipCnt: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobResponseBodyJobListJobOutputWaterMarkListWaterMarkInputFile extends $tea.Model {
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobResponseBodyJobListJobOutputWaterMarkListWaterMark extends $tea.Model {
  type?: string;
  referPos?: string;
  dx?: string;
  width?: string;
  height?: string;
  inputFile?: ListJobResponseBodyJobListJobOutputWaterMarkListWaterMarkInputFile;
  waterMarkTemplateId?: string;
  dy?: string;
  static names(): { [key: string]: string } {
    return {
      type: 'Type',
      referPos: 'ReferPos',
      dx: 'Dx',
      width: 'Width',
      height: 'Height',
      inputFile: 'InputFile',
      waterMarkTemplateId: 'WaterMarkTemplateId',
      dy: 'Dy',
    };
  }

  static types(): { [key: string]: any } {
    return {
      type: 'string',
      referPos: 'string',
      dx: 'string',
      width: 'string',
      height: 'string',
      inputFile: ListJobResponseBodyJobListJobOutputWaterMarkListWaterMarkInputFile,
      waterMarkTemplateId: 'string',
      dy: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobResponseBodyJobListJobOutputWaterMarkList extends $tea.Model {
  waterMark?: ListJobResponseBodyJobListJobOutputWaterMarkListWaterMark[];
  static names(): { [key: string]: string } {
    return {
      waterMark: 'WaterMark',
    };
  }

  static types(): { [key: string]: any } {
    return {
      waterMark: { 'type': 'array', 'itemType': ListJobResponseBodyJobListJobOutputWaterMarkListWaterMark },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobResponseBodyJobListJobOutputM3U8NonStandardSupportTS extends $tea.Model {
  sizeSupport?: boolean;
  md5Support?: boolean;
  static names(): { [key: string]: string } {
    return {
      sizeSupport: 'SizeSupport',
      md5Support: 'Md5Support',
    };
  }

  static types(): { [key: string]: any } {
    return {
      sizeSupport: 'boolean',
      md5Support: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobResponseBodyJobListJobOutputM3U8NonStandardSupport extends $tea.Model {
  TS?: ListJobResponseBodyJobListJobOutputM3U8NonStandardSupportTS;
  static names(): { [key: string]: string } {
    return {
      TS: 'TS',
    };
  }

  static types(): { [key: string]: any } {
    return {
      TS: ListJobResponseBodyJobListJobOutputM3U8NonStandardSupportTS,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobResponseBodyJobListJobOutputAudioVolume extends $tea.Model {
  method?: string;
  level?: string;
  static names(): { [key: string]: string } {
    return {
      method: 'Method',
      level: 'Level',
    };
  }

  static types(): { [key: string]: any } {
    return {
      method: 'string',
      level: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobResponseBodyJobListJobOutputAudio extends $tea.Model {
  profile?: string;
  codec?: string;
  samplerate?: string;
  qscale?: string;
  channels?: string;
  volume?: ListJobResponseBodyJobListJobOutputAudioVolume;
  bitrate?: string;
  static names(): { [key: string]: string } {
    return {
      profile: 'Profile',
      codec: 'Codec',
      samplerate: 'Samplerate',
      qscale: 'Qscale',
      channels: 'Channels',
      volume: 'Volume',
      bitrate: 'Bitrate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      profile: 'string',
      codec: 'string',
      samplerate: 'string',
      qscale: 'string',
      channels: 'string',
      volume: ListJobResponseBodyJobListJobOutputAudioVolume,
      bitrate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobResponseBodyJobListJobOutputMergeListMerge extends $tea.Model {
  start?: string;
  roleArn?: string;
  mergeURL?: string;
  duration?: string;
  static names(): { [key: string]: string } {
    return {
      start: 'Start',
      roleArn: 'RoleArn',
      mergeURL: 'MergeURL',
      duration: 'Duration',
    };
  }

  static types(): { [key: string]: any } {
    return {
      start: 'string',
      roleArn: 'string',
      mergeURL: 'string',
      duration: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobResponseBodyJobListJobOutputMergeList extends $tea.Model {
  merge?: ListJobResponseBodyJobListJobOutputMergeListMerge[];
  static names(): { [key: string]: string } {
    return {
      merge: 'Merge',
    };
  }

  static types(): { [key: string]: any } {
    return {
      merge: { 'type': 'array', 'itemType': ListJobResponseBodyJobListJobOutputMergeListMerge },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobResponseBodyJobListJobOutputSuperReso extends $tea.Model {
  isHalfSample?: string;
  static names(): { [key: string]: string } {
    return {
      isHalfSample: 'IsHalfSample',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isHalfSample: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobResponseBodyJobListJobOutputOutSubtitleListOutSubtitleOutSubtitleFile extends $tea.Model {
  roleArn?: string;
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      roleArn: 'RoleArn',
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      roleArn: 'string',
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobResponseBodyJobListJobOutputOutSubtitleListOutSubtitle extends $tea.Model {
  map?: string;
  outSubtitleFile?: ListJobResponseBodyJobListJobOutputOutSubtitleListOutSubtitleOutSubtitleFile;
  success?: boolean;
  message?: string;
  static names(): { [key: string]: string } {
    return {
      map: 'Map',
      outSubtitleFile: 'OutSubtitleFile',
      success: 'Success',
      message: 'Message',
    };
  }

  static types(): { [key: string]: any } {
    return {
      map: 'string',
      outSubtitleFile: ListJobResponseBodyJobListJobOutputOutSubtitleListOutSubtitleOutSubtitleFile,
      success: 'boolean',
      message: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobResponseBodyJobListJobOutputOutSubtitleList extends $tea.Model {
  outSubtitle?: ListJobResponseBodyJobListJobOutputOutSubtitleListOutSubtitle[];
  static names(): { [key: string]: string } {
    return {
      outSubtitle: 'OutSubtitle',
    };
  }

  static types(): { [key: string]: any } {
    return {
      outSubtitle: { 'type': 'array', 'itemType': ListJobResponseBodyJobListJobOutputOutSubtitleListOutSubtitle },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobResponseBodyJobListJobOutputOutputFile extends $tea.Model {
  roleArn?: string;
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      roleArn: 'RoleArn',
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      roleArn: 'string',
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobResponseBodyJobListJobOutputContainer extends $tea.Model {
  format?: string;
  static names(): { [key: string]: string } {
    return {
      format: 'Format',
    };
  }

  static types(): { [key: string]: any } {
    return {
      format: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobResponseBodyJobListJobOutputClipTimeSpan extends $tea.Model {
  seek?: string;
  duration?: string;
  static names(): { [key: string]: string } {
    return {
      seek: 'Seek',
      duration: 'Duration',
    };
  }

  static types(): { [key: string]: any } {
    return {
      seek: 'string',
      duration: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobResponseBodyJobListJobOutputClip extends $tea.Model {
  timeSpan?: ListJobResponseBodyJobListJobOutputClipTimeSpan;
  static names(): { [key: string]: string } {
    return {
      timeSpan: 'TimeSpan',
    };
  }

  static types(): { [key: string]: any } {
    return {
      timeSpan: ListJobResponseBodyJobListJobOutputClipTimeSpan,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobResponseBodyJobListJobOutputOpeningListOpening extends $tea.Model {
  openUrl?: string;
  start?: string;
  width?: string;
  height?: string;
  static names(): { [key: string]: string } {
    return {
      openUrl: 'openUrl',
      start: 'Start',
      width: 'Width',
      height: 'Height',
    };
  }

  static types(): { [key: string]: any } {
    return {
      openUrl: 'string',
      start: 'string',
      width: 'string',
      height: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobResponseBodyJobListJobOutputOpeningList extends $tea.Model {
  opening?: ListJobResponseBodyJobListJobOutputOpeningListOpening[];
  static names(): { [key: string]: string } {
    return {
      opening: 'Opening',
    };
  }

  static types(): { [key: string]: any } {
    return {
      opening: { 'type': 'array', 'itemType': ListJobResponseBodyJobListJobOutputOpeningListOpening },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobResponseBodyJobListJobOutputMuxConfigWebp extends $tea.Model {
  loop?: string;
  static names(): { [key: string]: string } {
    return {
      loop: 'Loop',
    };
  }

  static types(): { [key: string]: any } {
    return {
      loop: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobResponseBodyJobListJobOutputMuxConfigGif extends $tea.Model {
  finalDelay?: string;
  ditherMode?: string;
  loop?: string;
  isCustomPalette?: string;
  static names(): { [key: string]: string } {
    return {
      finalDelay: 'FinalDelay',
      ditherMode: 'DitherMode',
      loop: 'Loop',
      isCustomPalette: 'IsCustomPalette',
    };
  }

  static types(): { [key: string]: any } {
    return {
      finalDelay: 'string',
      ditherMode: 'string',
      loop: 'string',
      isCustomPalette: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobResponseBodyJobListJobOutputMuxConfigSegment extends $tea.Model {
  duration?: string;
  static names(): { [key: string]: string } {
    return {
      duration: 'Duration',
    };
  }

  static types(): { [key: string]: any } {
    return {
      duration: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobResponseBodyJobListJobOutputMuxConfig extends $tea.Model {
  webp?: ListJobResponseBodyJobListJobOutputMuxConfigWebp;
  gif?: ListJobResponseBodyJobListJobOutputMuxConfigGif;
  segment?: ListJobResponseBodyJobListJobOutputMuxConfigSegment;
  static names(): { [key: string]: string } {
    return {
      webp: 'Webp',
      gif: 'Gif',
      segment: 'Segment',
    };
  }

  static types(): { [key: string]: any } {
    return {
      webp: ListJobResponseBodyJobListJobOutputMuxConfigWebp,
      gif: ListJobResponseBodyJobListJobOutputMuxConfigGif,
      segment: ListJobResponseBodyJobListJobOutputMuxConfigSegment,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobResponseBodyJobListJobOutputTailSlateListTailSlate extends $tea.Model {
  start?: string;
  bgColor?: string;
  isMergeAudio?: boolean;
  width?: string;
  height?: string;
  blendDuration?: string;
  tailUrl?: string;
  static names(): { [key: string]: string } {
    return {
      start: 'Start',
      bgColor: 'BgColor',
      isMergeAudio: 'IsMergeAudio',
      width: 'Width',
      height: 'Height',
      blendDuration: 'BlendDuration',
      tailUrl: 'TailUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      start: 'string',
      bgColor: 'string',
      isMergeAudio: 'boolean',
      width: 'string',
      height: 'string',
      blendDuration: 'string',
      tailUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobResponseBodyJobListJobOutputTailSlateList extends $tea.Model {
  tailSlate?: ListJobResponseBodyJobListJobOutputTailSlateListTailSlate[];
  static names(): { [key: string]: string } {
    return {
      tailSlate: 'TailSlate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tailSlate: { 'type': 'array', 'itemType': ListJobResponseBodyJobListJobOutputTailSlateListTailSlate },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput extends $tea.Model {
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitle extends $tea.Model {
  charEnc?: string;
  fontName?: string;
  input?: ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput;
  static names(): { [key: string]: string } {
    return {
      charEnc: 'CharEnc',
      fontName: 'FontName',
      input: 'Input',
    };
  }

  static types(): { [key: string]: any } {
    return {
      charEnc: 'string',
      fontName: 'string',
      input: ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleList extends $tea.Model {
  extSubtitle?: ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitle[];
  static names(): { [key: string]: string } {
    return {
      extSubtitle: 'ExtSubtitle',
    };
  }

  static types(): { [key: string]: any } {
    return {
      extSubtitle: { 'type': 'array', 'itemType': ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitle },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobResponseBodyJobListJobOutputSubtitleConfigSubtitleListSubtitle extends $tea.Model {
  map?: string;
  static names(): { [key: string]: string } {
    return {
      map: 'Map',
    };
  }

  static types(): { [key: string]: any } {
    return {
      map: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobResponseBodyJobListJobOutputSubtitleConfigSubtitleList extends $tea.Model {
  subtitle?: ListJobResponseBodyJobListJobOutputSubtitleConfigSubtitleListSubtitle[];
  static names(): { [key: string]: string } {
    return {
      subtitle: 'Subtitle',
    };
  }

  static types(): { [key: string]: any } {
    return {
      subtitle: { 'type': 'array', 'itemType': ListJobResponseBodyJobListJobOutputSubtitleConfigSubtitleListSubtitle },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobResponseBodyJobListJobOutputSubtitleConfig extends $tea.Model {
  extSubtitleList?: ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleList;
  subtitleList?: ListJobResponseBodyJobListJobOutputSubtitleConfigSubtitleList;
  static names(): { [key: string]: string } {
    return {
      extSubtitleList: 'ExtSubtitleList',
      subtitleList: 'SubtitleList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      extSubtitleList: ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleList,
      subtitleList: ListJobResponseBodyJobListJobOutputSubtitleConfigSubtitleList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost extends $tea.Model {
  preloadTime?: string;
  avgBitrate?: string;
  costBandwidth?: string;
  static names(): { [key: string]: string } {
    return {
      preloadTime: 'PreloadTime',
      avgBitrate: 'AvgBitrate',
      costBandwidth: 'CostBandwidth',
    };
  }

  static types(): { [key: string]: any } {
    return {
      preloadTime: 'string',
      avgBitrate: 'string',
      costBandwidth: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStream extends $tea.Model {
  index?: string;
  timebase?: string;
  avgFPS?: string;
  pixFmt?: string;
  sar?: string;
  lang?: string;
  codecLongName?: string;
  height?: string;
  numFrames?: string;
  bitrate?: string;
  codecTagString?: string;
  hasBFrames?: string;
  profile?: string;
  startTime?: string;
  networkCost?: ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost;
  dar?: string;
  codecName?: string;
  width?: string;
  duration?: string;
  fps?: string;
  codecTag?: string;
  codecTimeBase?: string;
  level?: string;
  static names(): { [key: string]: string } {
    return {
      index: 'Index',
      timebase: 'Timebase',
      avgFPS: 'AvgFPS',
      pixFmt: 'PixFmt',
      sar: 'Sar',
      lang: 'Lang',
      codecLongName: 'CodecLongName',
      height: 'Height',
      numFrames: 'NumFrames',
      bitrate: 'Bitrate',
      codecTagString: 'CodecTagString',
      hasBFrames: 'HasBFrames',
      profile: 'Profile',
      startTime: 'StartTime',
      networkCost: 'NetworkCost',
      dar: 'Dar',
      codecName: 'CodecName',
      width: 'Width',
      duration: 'Duration',
      fps: 'Fps',
      codecTag: 'CodecTag',
      codecTimeBase: 'CodecTimeBase',
      level: 'Level',
    };
  }

  static types(): { [key: string]: any } {
    return {
      index: 'string',
      timebase: 'string',
      avgFPS: 'string',
      pixFmt: 'string',
      sar: 'string',
      lang: 'string',
      codecLongName: 'string',
      height: 'string',
      numFrames: 'string',
      bitrate: 'string',
      codecTagString: 'string',
      hasBFrames: 'string',
      profile: 'string',
      startTime: 'string',
      networkCost: ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost,
      dar: 'string',
      codecName: 'string',
      width: 'string',
      duration: 'string',
      fps: 'string',
      codecTag: 'string',
      codecTimeBase: 'string',
      level: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamList extends $tea.Model {
  videoStream?: ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStream[];
  static names(): { [key: string]: string } {
    return {
      videoStream: 'VideoStream',
    };
  }

  static types(): { [key: string]: any } {
    return {
      videoStream: { 'type': 'array', 'itemType': ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStream },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobResponseBodyJobListJobOutputPropertiesStreamsAudioStreamListAudioStream extends $tea.Model {
  timebase?: string;
  index?: string;
  sampleFmt?: string;
  channelLayout?: string;
  lang?: string;
  samplerate?: string;
  codecLongName?: string;
  channels?: string;
  numFrames?: string;
  bitrate?: string;
  codecTagString?: string;
  startTime?: string;
  codecName?: string;
  duration?: string;
  codecTag?: string;
  codecTimeBase?: string;
  static names(): { [key: string]: string } {
    return {
      timebase: 'Timebase',
      index: 'Index',
      sampleFmt: 'SampleFmt',
      channelLayout: 'ChannelLayout',
      lang: 'Lang',
      samplerate: 'Samplerate',
      codecLongName: 'CodecLongName',
      channels: 'Channels',
      numFrames: 'NumFrames',
      bitrate: 'Bitrate',
      codecTagString: 'CodecTagString',
      startTime: 'StartTime',
      codecName: 'CodecName',
      duration: 'Duration',
      codecTag: 'CodecTag',
      codecTimeBase: 'CodecTimeBase',
    };
  }

  static types(): { [key: string]: any } {
    return {
      timebase: 'string',
      index: 'string',
      sampleFmt: 'string',
      channelLayout: 'string',
      lang: 'string',
      samplerate: 'string',
      codecLongName: 'string',
      channels: 'string',
      numFrames: 'string',
      bitrate: 'string',
      codecTagString: 'string',
      startTime: 'string',
      codecName: 'string',
      duration: 'string',
      codecTag: 'string',
      codecTimeBase: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobResponseBodyJobListJobOutputPropertiesStreamsAudioStreamList extends $tea.Model {
  audioStream?: ListJobResponseBodyJobListJobOutputPropertiesStreamsAudioStreamListAudioStream[];
  static names(): { [key: string]: string } {
    return {
      audioStream: 'AudioStream',
    };
  }

  static types(): { [key: string]: any } {
    return {
      audioStream: { 'type': 'array', 'itemType': ListJobResponseBodyJobListJobOutputPropertiesStreamsAudioStreamListAudioStream },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream extends $tea.Model {
  index?: string;
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      index: 'Index',
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      index: 'string',
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamList extends $tea.Model {
  subtitleStream?: ListJobResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream[];
  static names(): { [key: string]: string } {
    return {
      subtitleStream: 'SubtitleStream',
    };
  }

  static types(): { [key: string]: any } {
    return {
      subtitleStream: { 'type': 'array', 'itemType': ListJobResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobResponseBodyJobListJobOutputPropertiesStreams extends $tea.Model {
  videoStreamList?: ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamList;
  audioStreamList?: ListJobResponseBodyJobListJobOutputPropertiesStreamsAudioStreamList;
  subtitleStreamList?: ListJobResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamList;
  static names(): { [key: string]: string } {
    return {
      videoStreamList: 'VideoStreamList',
      audioStreamList: 'AudioStreamList',
      subtitleStreamList: 'SubtitleStreamList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      videoStreamList: ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamList,
      audioStreamList: ListJobResponseBodyJobListJobOutputPropertiesStreamsAudioStreamList,
      subtitleStreamList: ListJobResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobResponseBodyJobListJobOutputPropertiesFormat extends $tea.Model {
  startTime?: string;
  numPrograms?: string;
  size?: string;
  numStreams?: string;
  formatLongName?: string;
  duration?: string;
  bitrate?: string;
  formatName?: string;
  static names(): { [key: string]: string } {
    return {
      startTime: 'StartTime',
      numPrograms: 'NumPrograms',
      size: 'Size',
      numStreams: 'NumStreams',
      formatLongName: 'FormatLongName',
      duration: 'Duration',
      bitrate: 'Bitrate',
      formatName: 'FormatName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      startTime: 'string',
      numPrograms: 'string',
      size: 'string',
      numStreams: 'string',
      formatLongName: 'string',
      duration: 'string',
      bitrate: 'string',
      formatName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobResponseBodyJobListJobOutputProperties extends $tea.Model {
  width?: string;
  height?: string;
  duration?: string;
  fps?: string;
  bitrate?: string;
  fileFormat?: string;
  streams?: ListJobResponseBodyJobListJobOutputPropertiesStreams;
  format?: ListJobResponseBodyJobListJobOutputPropertiesFormat;
  fileSize?: string;
  static names(): { [key: string]: string } {
    return {
      width: 'Width',
      height: 'Height',
      duration: 'Duration',
      fps: 'Fps',
      bitrate: 'Bitrate',
      fileFormat: 'FileFormat',
      streams: 'Streams',
      format: 'Format',
      fileSize: 'FileSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      width: 'string',
      height: 'string',
      duration: 'string',
      fps: 'string',
      bitrate: 'string',
      fileFormat: 'string',
      streams: ListJobResponseBodyJobListJobOutputPropertiesStreams,
      format: ListJobResponseBodyJobListJobOutputPropertiesFormat,
      fileSize: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobResponseBodyJobListJobOutput extends $tea.Model {
  video?: ListJobResponseBodyJobListJobOutputVideo;
  transConfig?: ListJobResponseBodyJobListJobOutputTransConfig;
  encryption?: ListJobResponseBodyJobListJobOutputEncryption;
  waterMarkList?: ListJobResponseBodyJobListJobOutputWaterMarkList;
  waterMarkConfigUrl?: string;
  deWatermark?: string;
  m3U8NonStandardSupport?: ListJobResponseBodyJobListJobOutputM3U8NonStandardSupport;
  priority?: string;
  audio?: ListJobResponseBodyJobListJobOutputAudio;
  audioStreamMap?: string;
  mergeList?: ListJobResponseBodyJobListJobOutputMergeList;
  superReso?: ListJobResponseBodyJobListJobOutputSuperReso;
  userData?: string;
  outSubtitleList?: ListJobResponseBodyJobListJobOutputOutSubtitleList;
  videoStreamMap?: string;
  outputFile?: ListJobResponseBodyJobListJobOutputOutputFile;
  rotate?: string;
  container?: ListJobResponseBodyJobListJobOutputContainer;
  clip?: ListJobResponseBodyJobListJobOutputClip;
  mergeConfigUrl?: string;
  openingList?: ListJobResponseBodyJobListJobOutputOpeningList;
  muxConfig?: ListJobResponseBodyJobListJobOutputMuxConfig;
  tailSlateList?: ListJobResponseBodyJobListJobOutputTailSlateList;
  templateId?: string;
  subtitleConfig?: ListJobResponseBodyJobListJobOutputSubtitleConfig;
  properties?: ListJobResponseBodyJobListJobOutputProperties;
  static names(): { [key: string]: string } {
    return {
      video: 'Video',
      transConfig: 'TransConfig',
      encryption: 'Encryption',
      waterMarkList: 'WaterMarkList',
      waterMarkConfigUrl: 'WaterMarkConfigUrl',
      deWatermark: 'DeWatermark',
      m3U8NonStandardSupport: 'M3U8NonStandardSupport',
      priority: 'Priority',
      audio: 'Audio',
      audioStreamMap: 'AudioStreamMap',
      mergeList: 'MergeList',
      superReso: 'SuperReso',
      userData: 'UserData',
      outSubtitleList: 'OutSubtitleList',
      videoStreamMap: 'VideoStreamMap',
      outputFile: 'OutputFile',
      rotate: 'Rotate',
      container: 'Container',
      clip: 'Clip',
      mergeConfigUrl: 'MergeConfigUrl',
      openingList: 'OpeningList',
      muxConfig: 'MuxConfig',
      tailSlateList: 'TailSlateList',
      templateId: 'TemplateId',
      subtitleConfig: 'SubtitleConfig',
      properties: 'Properties',
    };
  }

  static types(): { [key: string]: any } {
    return {
      video: ListJobResponseBodyJobListJobOutputVideo,
      transConfig: ListJobResponseBodyJobListJobOutputTransConfig,
      encryption: ListJobResponseBodyJobListJobOutputEncryption,
      waterMarkList: ListJobResponseBodyJobListJobOutputWaterMarkList,
      waterMarkConfigUrl: 'string',
      deWatermark: 'string',
      m3U8NonStandardSupport: ListJobResponseBodyJobListJobOutputM3U8NonStandardSupport,
      priority: 'string',
      audio: ListJobResponseBodyJobListJobOutputAudio,
      audioStreamMap: 'string',
      mergeList: ListJobResponseBodyJobListJobOutputMergeList,
      superReso: ListJobResponseBodyJobListJobOutputSuperReso,
      userData: 'string',
      outSubtitleList: ListJobResponseBodyJobListJobOutputOutSubtitleList,
      videoStreamMap: 'string',
      outputFile: ListJobResponseBodyJobListJobOutputOutputFile,
      rotate: 'string',
      container: ListJobResponseBodyJobListJobOutputContainer,
      clip: ListJobResponseBodyJobListJobOutputClip,
      mergeConfigUrl: 'string',
      openingList: ListJobResponseBodyJobListJobOutputOpeningList,
      muxConfig: ListJobResponseBodyJobListJobOutputMuxConfig,
      tailSlateList: ListJobResponseBodyJobListJobOutputTailSlateList,
      templateId: 'string',
      subtitleConfig: ListJobResponseBodyJobListJobOutputSubtitleConfig,
      properties: ListJobResponseBodyJobListJobOutputProperties,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobResponseBodyJobListJobInput extends $tea.Model {
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobResponseBodyJobListJobMNSMessageResult extends $tea.Model {
  messageId?: string;
  errorMessage?: string;
  errorCode?: string;
  static names(): { [key: string]: string } {
    return {
      messageId: 'MessageId',
      errorMessage: 'ErrorMessage',
      errorCode: 'ErrorCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      messageId: 'string',
      errorMessage: 'string',
      errorCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobResponseBodyJobListJob extends $tea.Model {
  creationTime?: string;
  percent?: number;
  finishTime?: string;
  state?: string;
  jobId?: string;
  code?: string;
  message?: string;
  output?: ListJobResponseBodyJobListJobOutput;
  pipelineId?: string;
  input?: ListJobResponseBodyJobListJobInput;
  MNSMessageResult?: ListJobResponseBodyJobListJobMNSMessageResult;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      percent: 'Percent',
      finishTime: 'FinishTime',
      state: 'State',
      jobId: 'JobId',
      code: 'Code',
      message: 'Message',
      output: 'Output',
      pipelineId: 'PipelineId',
      input: 'Input',
      MNSMessageResult: 'MNSMessageResult',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      percent: 'number',
      finishTime: 'string',
      state: 'string',
      jobId: 'string',
      code: 'string',
      message: 'string',
      output: ListJobResponseBodyJobListJobOutput,
      pipelineId: 'string',
      input: ListJobResponseBodyJobListJobInput,
      MNSMessageResult: ListJobResponseBodyJobListJobMNSMessageResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobResponseBodyJobList extends $tea.Model {
  job?: ListJobResponseBodyJobListJob[];
  static names(): { [key: string]: string } {
    return {
      job: 'Job',
    };
  }

  static types(): { [key: string]: any } {
    return {
      job: { 'type': 'array', 'itemType': ListJobResponseBodyJobListJob },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMediaResponseBodyMediaListMediaTags extends $tea.Model {
  tag?: string[];
  static names(): { [key: string]: string } {
    return {
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tag: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMediaResponseBodyMediaListMediaFile extends $tea.Model {
  state?: string;
  URL?: string;
  static names(): { [key: string]: string } {
    return {
      state: 'State',
      URL: 'URL',
    };
  }

  static types(): { [key: string]: any } {
    return {
      state: 'string',
      URL: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMediaResponseBodyMediaListMediaRunIdList extends $tea.Model {
  runId?: string[];
  static names(): { [key: string]: string } {
    return {
      runId: 'RunId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      runId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMediaResponseBodyMediaListMedia extends $tea.Model {
  creationTime?: string;
  cateId?: number;
  height?: string;
  censorState?: string;
  tags?: ListMediaResponseBodyMediaListMediaTags;
  bitrate?: string;
  mediaId?: string;
  file?: ListMediaResponseBodyMediaListMediaFile;
  publishState?: string;
  description?: string;
  width?: string;
  size?: string;
  coverURL?: string;
  runIdList?: ListMediaResponseBodyMediaListMediaRunIdList;
  duration?: string;
  fps?: string;
  title?: string;
  format?: string;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      cateId: 'CateId',
      height: 'Height',
      censorState: 'CensorState',
      tags: 'Tags',
      bitrate: 'Bitrate',
      mediaId: 'MediaId',
      file: 'File',
      publishState: 'PublishState',
      description: 'Description',
      width: 'Width',
      size: 'Size',
      coverURL: 'CoverURL',
      runIdList: 'RunIdList',
      duration: 'Duration',
      fps: 'Fps',
      title: 'Title',
      format: 'Format',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      cateId: 'number',
      height: 'string',
      censorState: 'string',
      tags: ListMediaResponseBodyMediaListMediaTags,
      bitrate: 'string',
      mediaId: 'string',
      file: ListMediaResponseBodyMediaListMediaFile,
      publishState: 'string',
      description: 'string',
      width: 'string',
      size: 'string',
      coverURL: 'string',
      runIdList: ListMediaResponseBodyMediaListMediaRunIdList,
      duration: 'string',
      fps: 'string',
      title: 'string',
      format: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMediaResponseBodyMediaList extends $tea.Model {
  media?: ListMediaResponseBodyMediaListMedia[];
  static names(): { [key: string]: string } {
    return {
      media: 'Media',
    };
  }

  static types(): { [key: string]: any } {
    return {
      media: { 'type': 'array', 'itemType': ListMediaResponseBodyMediaListMedia },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivityMNSMessageResult extends $tea.Model {
  messageId?: string;
  errorMessage?: string;
  errorCode?: string;
  static names(): { [key: string]: string } {
    return {
      messageId: 'MessageId',
      errorMessage: 'ErrorMessage',
      errorCode: 'ErrorCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      messageId: 'string',
      errorMessage: 'string',
      errorCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivity extends $tea.Model {
  endTime?: string;
  type?: string;
  startTime?: string;
  state?: string;
  jobId?: string;
  code?: string;
  message?: string;
  name?: string;
  MNSMessageResult?: ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivityMNSMessageResult;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      type: 'Type',
      startTime: 'StartTime',
      state: 'State',
      jobId: 'JobId',
      code: 'Code',
      message: 'Message',
      name: 'Name',
      MNSMessageResult: 'MNSMessageResult',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      type: 'string',
      startTime: 'string',
      state: 'string',
      jobId: 'string',
      code: 'string',
      message: 'string',
      name: 'string',
      MNSMessageResult: ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivityMNSMessageResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityList extends $tea.Model {
  activity?: ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivity[];
  static names(): { [key: string]: string } {
    return {
      activity: 'Activity',
    };
  }

  static types(): { [key: string]: any } {
    return {
      activity: { 'type': 'array', 'itemType': ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivity },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInputInputFile extends $tea.Model {
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInput extends $tea.Model {
  userData?: string;
  inputFile?: ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInputInputFile;
  static names(): { [key: string]: string } {
    return {
      userData: 'UserData',
      inputFile: 'InputFile',
    };
  }

  static types(): { [key: string]: any } {
    return {
      userData: 'string',
      inputFile: ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInputInputFile,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecution extends $tea.Model {
  creationTime?: string;
  mediaWorkflowId?: string;
  state?: string;
  activityList?: ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityList;
  name?: string;
  input?: ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInput;
  mediaId?: string;
  runId?: string;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      mediaWorkflowId: 'MediaWorkflowId',
      state: 'State',
      activityList: 'ActivityList',
      name: 'Name',
      input: 'Input',
      mediaId: 'MediaId',
      runId: 'RunId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      mediaWorkflowId: 'string',
      state: 'string',
      activityList: ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityList,
      name: 'string',
      input: ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInput,
      mediaId: 'string',
      runId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionList extends $tea.Model {
  mediaWorkflowExecution?: ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecution[];
  static names(): { [key: string]: string } {
    return {
      mediaWorkflowExecution: 'MediaWorkflowExecution',
    };
  }

  static types(): { [key: string]: any } {
    return {
      mediaWorkflowExecution: { 'type': 'array', 'itemType': ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecution },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPornPipelineResponseBodyPipelineListPipelineNotifyConfig extends $tea.Model {
  topic?: string;
  queue?: string;
  static names(): { [key: string]: string } {
    return {
      topic: 'Topic',
      queue: 'Queue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      topic: 'string',
      queue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPornPipelineResponseBodyPipelineListPipeline extends $tea.Model {
  state?: string;
  notifyConfig?: ListPornPipelineResponseBodyPipelineListPipelineNotifyConfig;
  priority?: string;
  name?: string;
  id?: string;
  static names(): { [key: string]: string } {
    return {
      state: 'State',
      notifyConfig: 'NotifyConfig',
      priority: 'Priority',
      name: 'Name',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      state: 'string',
      notifyConfig: ListPornPipelineResponseBodyPipelineListPipelineNotifyConfig,
      priority: 'string',
      name: 'string',
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPornPipelineResponseBodyPipelineList extends $tea.Model {
  pipeline?: ListPornPipelineResponseBodyPipelineListPipeline[];
  static names(): { [key: string]: string } {
    return {
      pipeline: 'Pipeline',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pipeline: { 'type': 'array', 'itemType': ListPornPipelineResponseBodyPipelineListPipeline },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTerrorismPipelineResponseBodyPipelineListPipelineNotifyConfig extends $tea.Model {
  topic?: string;
  queue?: string;
  static names(): { [key: string]: string } {
    return {
      topic: 'Topic',
      queue: 'Queue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      topic: 'string',
      queue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTerrorismPipelineResponseBodyPipelineListPipeline extends $tea.Model {
  state?: string;
  notifyConfig?: ListTerrorismPipelineResponseBodyPipelineListPipelineNotifyConfig;
  priority?: string;
  name?: string;
  id?: string;
  static names(): { [key: string]: string } {
    return {
      state: 'State',
      notifyConfig: 'NotifyConfig',
      priority: 'Priority',
      name: 'Name',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      state: 'string',
      notifyConfig: ListTerrorismPipelineResponseBodyPipelineListPipelineNotifyConfig,
      priority: 'string',
      name: 'string',
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTerrorismPipelineResponseBodyPipelineList extends $tea.Model {
  pipeline?: ListTerrorismPipelineResponseBodyPipelineListPipeline[];
  static names(): { [key: string]: string } {
    return {
      pipeline: 'Pipeline',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pipeline: { 'type': 'array', 'itemType': ListTerrorismPipelineResponseBodyPipelineListPipeline },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PlayerAuthResponseBodySwitchListSwitch extends $tea.Model {
  functionId?: string;
  functionName?: string;
  state?: string;
  switchId?: string;
  static names(): { [key: string]: string } {
    return {
      functionId: 'FunctionId',
      functionName: 'FunctionName',
      state: 'State',
      switchId: 'SwitchId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      functionId: 'string',
      functionName: 'string',
      state: 'string',
      switchId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PlayerAuthResponseBodySwitchList extends $tea.Model {
  switch?: PlayerAuthResponseBodySwitchListSwitch[];
  static names(): { [key: string]: string } {
    return {
      switch: 'Switch',
    };
  }

  static types(): { [key: string]: any } {
    return {
      switch: { 'type': 'array', 'itemType': PlayerAuthResponseBodySwitchListSwitch },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PlayInfoResponseBodyNotFoundCDNDomain extends $tea.Model {
  string?: string[];
  static names(): { [key: string]: string } {
    return {
      string: 'String',
    };
  }

  static types(): { [key: string]: any } {
    return {
      string: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PlayInfoResponseBodyPlayInfoListPlayInfo extends $tea.Model {
  downloadType?: string;
  width?: string;
  definition?: string;
  rand?: string;
  url?: string;
  complexity?: string;
  encryption?: string;
  fps?: string;
  encryptionType?: string;
  height?: string;
  activityName?: string;
  size?: string;
  bitrate?: string;
  plaintext?: string;
  duration?: string;
  format?: string;
  static names(): { [key: string]: string } {
    return {
      downloadType: 'downloadType',
      width: 'width',
      definition: 'definition',
      rand: 'rand',
      url: 'Url',
      complexity: 'complexity',
      encryption: 'encryption',
      fps: 'fps',
      encryptionType: 'encryptionType',
      height: 'height',
      activityName: 'activityName',
      size: 'size',
      bitrate: 'bitrate',
      plaintext: 'plaintext',
      duration: 'duration',
      format: 'format',
    };
  }

  static types(): { [key: string]: any } {
    return {
      downloadType: 'string',
      width: 'string',
      definition: 'string',
      rand: 'string',
      url: 'string',
      complexity: 'string',
      encryption: 'string',
      fps: 'string',
      encryptionType: 'string',
      height: 'string',
      activityName: 'string',
      size: 'string',
      bitrate: 'string',
      plaintext: 'string',
      duration: 'string',
      format: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PlayInfoResponseBodyPlayInfoList extends $tea.Model {
  playInfo?: PlayInfoResponseBodyPlayInfoListPlayInfo[];
  static names(): { [key: string]: string } {
    return {
      playInfo: 'PlayInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      playInfo: { 'type': 'array', 'itemType': PlayInfoResponseBodyPlayInfoListPlayInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigQualityControl extends $tea.Model {
  methodStreaming?: string;
  rateQuality?: string;
  static names(): { [key: string]: string } {
    return {
      methodStreaming: 'MethodStreaming',
      rateQuality: 'RateQuality',
    };
  }

  static types(): { [key: string]: any } {
    return {
      methodStreaming: 'string',
      rateQuality: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigPropertiesControlCrop extends $tea.Model {
  top?: string;
  width?: string;
  height?: string;
  left?: string;
  mode?: string;
  static names(): { [key: string]: string } {
    return {
      top: 'Top',
      width: 'Width',
      height: 'Height',
      left: 'Left',
      mode: 'Mode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      top: 'string',
      width: 'string',
      height: 'string',
      left: 'string',
      mode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigPropertiesControl extends $tea.Model {
  deinterlace?: string;
  crop?: QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigPropertiesControlCrop;
  static names(): { [key: string]: string } {
    return {
      deinterlace: 'Deinterlace',
      crop: 'Crop',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deinterlace: 'string',
      crop: QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigPropertiesControlCrop,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfig extends $tea.Model {
  qualityControl?: QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigQualityControl;
  propertiesControl?: QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigPropertiesControl;
  static names(): { [key: string]: string } {
    return {
      qualityControl: 'QualityControl',
      propertiesControl: 'PropertiesControl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      qualityControl: QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigQualityControl,
      propertiesControl: QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigPropertiesControl,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobMNSMessageResult extends $tea.Model {
  messageId?: string;
  errorMessage?: string;
  errorCode?: string;
  static names(): { [key: string]: string } {
    return {
      messageId: 'MessageId',
      errorMessage: 'ErrorMessage',
      errorCode: 'ErrorCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      messageId: 'string',
      errorMessage: 'string',
      errorCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateVideoBitrateBnd extends $tea.Model {
  max?: string;
  min?: string;
  static names(): { [key: string]: string } {
    return {
      max: 'Max',
      min: 'Min',
    };
  }

  static types(): { [key: string]: any } {
    return {
      max: 'string',
      min: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateVideo extends $tea.Model {
  bufsize?: string;
  degrain?: string;
  bitrateBnd?: QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateVideoBitrateBnd;
  pixFmt?: string;
  codec?: string;
  height?: string;
  qscale?: string;
  bitrate?: string;
  maxrate?: string;
  profile?: string;
  crf?: string;
  gop?: string;
  width?: string;
  fps?: string;
  preset?: string;
  scanMode?: string;
  static names(): { [key: string]: string } {
    return {
      bufsize: 'Bufsize',
      degrain: 'Degrain',
      bitrateBnd: 'BitrateBnd',
      pixFmt: 'PixFmt',
      codec: 'Codec',
      height: 'Height',
      qscale: 'Qscale',
      bitrate: 'Bitrate',
      maxrate: 'Maxrate',
      profile: 'Profile',
      crf: 'Crf',
      gop: 'Gop',
      width: 'Width',
      fps: 'Fps',
      preset: 'Preset',
      scanMode: 'ScanMode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bufsize: 'string',
      degrain: 'string',
      bitrateBnd: QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateVideoBitrateBnd,
      pixFmt: 'string',
      codec: 'string',
      height: 'string',
      qscale: 'string',
      bitrate: 'string',
      maxrate: 'string',
      profile: 'string',
      crf: 'string',
      gop: 'string',
      width: 'string',
      fps: 'string',
      preset: 'string',
      scanMode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateTransConfig extends $tea.Model {
  transMode?: string;
  static names(): { [key: string]: string } {
    return {
      transMode: 'TransMode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      transMode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfigGif extends $tea.Model {
  finalDelay?: string;
  loop?: string;
  static names(): { [key: string]: string } {
    return {
      finalDelay: 'FinalDelay',
      loop: 'Loop',
    };
  }

  static types(): { [key: string]: any } {
    return {
      finalDelay: 'string',
      loop: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfigSegment extends $tea.Model {
  duration?: string;
  static names(): { [key: string]: string } {
    return {
      duration: 'Duration',
    };
  }

  static types(): { [key: string]: any } {
    return {
      duration: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfig extends $tea.Model {
  gif?: QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfigGif;
  segment?: QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfigSegment;
  static names(): { [key: string]: string } {
    return {
      gif: 'Gif',
      segment: 'Segment',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gif: QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfigGif,
      segment: QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfigSegment,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateAudio extends $tea.Model {
  profile?: string;
  codec?: string;
  samplerate?: string;
  qscale?: string;
  channels?: string;
  bitrate?: string;
  static names(): { [key: string]: string } {
    return {
      profile: 'Profile',
      codec: 'Codec',
      samplerate: 'Samplerate',
      qscale: 'Qscale',
      channels: 'Channels',
      bitrate: 'Bitrate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      profile: 'string',
      codec: 'string',
      samplerate: 'string',
      qscale: 'string',
      channels: 'string',
      bitrate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateContainer extends $tea.Model {
  format?: string;
  static names(): { [key: string]: string } {
    return {
      format: 'Format',
    };
  }

  static types(): { [key: string]: any } {
    return {
      format: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplate extends $tea.Model {
  video?: QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateVideo;
  transConfig?: QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateTransConfig;
  state?: string;
  muxConfig?: QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfig;
  name?: string;
  audio?: QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateAudio;
  id?: string;
  container?: QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateContainer;
  static names(): { [key: string]: string } {
    return {
      video: 'Video',
      transConfig: 'TransConfig',
      state: 'State',
      muxConfig: 'MuxConfig',
      name: 'Name',
      audio: 'Audio',
      id: 'Id',
      container: 'Container',
    };
  }

  static types(): { [key: string]: any } {
    return {
      video: QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateVideo,
      transConfig: QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateTransConfig,
      state: 'string',
      muxConfig: QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfig,
      name: 'string',
      audio: QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateAudio,
      id: 'string',
      container: QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateContainer,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateList extends $tea.Model {
  template?: QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplate[];
  static names(): { [key: string]: string } {
    return {
      template: 'Template',
    };
  }

  static types(): { [key: string]: any } {
    return {
      template: { 'type': 'array', 'itemType': QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplate },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobInputFile extends $tea.Model {
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJob extends $tea.Model {
  creationTime?: string;
  percent?: number;
  state?: string;
  analysisConfig?: QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfig;
  message?: string;
  priority?: string;
  MNSMessageResult?: QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobMNSMessageResult;
  templateList?: QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateList;
  userData?: string;
  code?: string;
  inputFile?: QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobInputFile;
  pipelineId?: string;
  id?: string;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      percent: 'Percent',
      state: 'State',
      analysisConfig: 'AnalysisConfig',
      message: 'Message',
      priority: 'Priority',
      MNSMessageResult: 'MNSMessageResult',
      templateList: 'TemplateList',
      userData: 'UserData',
      code: 'Code',
      inputFile: 'InputFile',
      pipelineId: 'PipelineId',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      percent: 'number',
      state: 'string',
      analysisConfig: QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfig,
      message: 'string',
      priority: 'string',
      MNSMessageResult: QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobMNSMessageResult,
      templateList: QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateList,
      userData: 'string',
      code: 'string',
      inputFile: QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobInputFile,
      pipelineId: 'string',
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAnalysisJobListResponseBodyAnalysisJobList extends $tea.Model {
  analysisJob?: QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJob[];
  static names(): { [key: string]: string } {
    return {
      analysisJob: 'AnalysisJob',
    };
  }

  static types(): { [key: string]: any } {
    return {
      analysisJob: { 'type': 'array', 'itemType': QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJob },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAnalysisJobListResponseBodyNonExistAnalysisJobIds extends $tea.Model {
  string?: string[];
  static names(): { [key: string]: string } {
    return {
      string: 'String',
    };
  }

  static types(): { [key: string]: any } {
    return {
      string: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAnnotationJobListResponseBodyAnnotationJobListAnnotationJobInput extends $tea.Model {
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAnnotationJobListResponseBodyAnnotationJobListAnnotationJobVideoAnnotationResultAnnotationsAnnotation extends $tea.Model {
  score?: string;
  label?: string;
  static names(): { [key: string]: string } {
    return {
      score: 'Score',
      label: 'Label',
    };
  }

  static types(): { [key: string]: any } {
    return {
      score: 'string',
      label: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAnnotationJobListResponseBodyAnnotationJobListAnnotationJobVideoAnnotationResultAnnotations extends $tea.Model {
  annotation?: QueryAnnotationJobListResponseBodyAnnotationJobListAnnotationJobVideoAnnotationResultAnnotationsAnnotation[];
  static names(): { [key: string]: string } {
    return {
      annotation: 'Annotation',
    };
  }

  static types(): { [key: string]: any } {
    return {
      annotation: { 'type': 'array', 'itemType': QueryAnnotationJobListResponseBodyAnnotationJobListAnnotationJobVideoAnnotationResultAnnotationsAnnotation },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAnnotationJobListResponseBodyAnnotationJobListAnnotationJobVideoAnnotationResult extends $tea.Model {
  annotations?: QueryAnnotationJobListResponseBodyAnnotationJobListAnnotationJobVideoAnnotationResultAnnotations;
  details?: string;
  static names(): { [key: string]: string } {
    return {
      annotations: 'Annotations',
      details: 'Details',
    };
  }

  static types(): { [key: string]: any } {
    return {
      annotations: QueryAnnotationJobListResponseBodyAnnotationJobListAnnotationJobVideoAnnotationResultAnnotations,
      details: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAnnotationJobListResponseBodyAnnotationJobListAnnotationJob extends $tea.Model {
  creationTime?: string;
  state?: string;
  userData?: string;
  code?: string;
  message?: string;
  pipelineId?: string;
  input?: QueryAnnotationJobListResponseBodyAnnotationJobListAnnotationJobInput;
  id?: string;
  videoAnnotationResult?: QueryAnnotationJobListResponseBodyAnnotationJobListAnnotationJobVideoAnnotationResult;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      state: 'State',
      userData: 'UserData',
      code: 'Code',
      message: 'Message',
      pipelineId: 'PipelineId',
      input: 'Input',
      id: 'Id',
      videoAnnotationResult: 'VideoAnnotationResult',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      state: 'string',
      userData: 'string',
      code: 'string',
      message: 'string',
      pipelineId: 'string',
      input: QueryAnnotationJobListResponseBodyAnnotationJobListAnnotationJobInput,
      id: 'string',
      videoAnnotationResult: QueryAnnotationJobListResponseBodyAnnotationJobListAnnotationJobVideoAnnotationResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAnnotationJobListResponseBodyAnnotationJobList extends $tea.Model {
  annotationJob?: QueryAnnotationJobListResponseBodyAnnotationJobListAnnotationJob[];
  static names(): { [key: string]: string } {
    return {
      annotationJob: 'AnnotationJob',
    };
  }

  static types(): { [key: string]: any } {
    return {
      annotationJob: { 'type': 'array', 'itemType': QueryAnnotationJobListResponseBodyAnnotationJobListAnnotationJob },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAnnotationJobListResponseBodyNonExistIds extends $tea.Model {
  string?: string[];
  static names(): { [key: string]: string } {
    return {
      string: 'String',
    };
  }

  static types(): { [key: string]: any } {
    return {
      string: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAsrJobListResponseBodyJobListJobAsrConfig extends $tea.Model {
  scene?: string;
  static names(): { [key: string]: string } {
    return {
      scene: 'Scene',
    };
  }

  static types(): { [key: string]: any } {
    return {
      scene: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAsrJobListResponseBodyJobListJobInput extends $tea.Model {
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAsrJobListResponseBodyJobListJobAsrResultAsrTextListAsrText extends $tea.Model {
  endTime?: string;
  startTime?: number;
  channelId?: string;
  text?: string;
  speechRate?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      startTime: 'StartTime',
      channelId: 'ChannelId',
      text: 'Text',
      speechRate: 'SpeechRate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      startTime: 'number',
      channelId: 'string',
      text: 'string',
      speechRate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAsrJobListResponseBodyJobListJobAsrResultAsrTextList extends $tea.Model {
  asrText?: QueryAsrJobListResponseBodyJobListJobAsrResultAsrTextListAsrText[];
  static names(): { [key: string]: string } {
    return {
      asrText: 'AsrText',
    };
  }

  static types(): { [key: string]: any } {
    return {
      asrText: { 'type': 'array', 'itemType': QueryAsrJobListResponseBodyJobListJobAsrResultAsrTextListAsrText },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAsrJobListResponseBodyJobListJobAsrResult extends $tea.Model {
  duration?: string;
  asrTextList?: QueryAsrJobListResponseBodyJobListJobAsrResultAsrTextList;
  static names(): { [key: string]: string } {
    return {
      duration: 'Duration',
      asrTextList: 'AsrTextList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      duration: 'string',
      asrTextList: QueryAsrJobListResponseBodyJobListJobAsrResultAsrTextList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAsrJobListResponseBodyJobListJob extends $tea.Model {
  creationTime?: string;
  state?: string;
  userData?: string;
  code?: string;
  message?: string;
  asrConfig?: QueryAsrJobListResponseBodyJobListJobAsrConfig;
  pipelineId?: string;
  input?: QueryAsrJobListResponseBodyJobListJobInput;
  id?: string;
  asrResult?: QueryAsrJobListResponseBodyJobListJobAsrResult;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      state: 'State',
      userData: 'UserData',
      code: 'Code',
      message: 'Message',
      asrConfig: 'AsrConfig',
      pipelineId: 'PipelineId',
      input: 'Input',
      id: 'Id',
      asrResult: 'AsrResult',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      state: 'string',
      userData: 'string',
      code: 'string',
      message: 'string',
      asrConfig: QueryAsrJobListResponseBodyJobListJobAsrConfig,
      pipelineId: 'string',
      input: QueryAsrJobListResponseBodyJobListJobInput,
      id: 'string',
      asrResult: QueryAsrJobListResponseBodyJobListJobAsrResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAsrJobListResponseBodyJobList extends $tea.Model {
  job?: QueryAsrJobListResponseBodyJobListJob[];
  static names(): { [key: string]: string } {
    return {
      job: 'Job',
    };
  }

  static types(): { [key: string]: any } {
    return {
      job: { 'type': 'array', 'itemType': QueryAsrJobListResponseBodyJobListJob },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAsrJobListResponseBodyNonExistIds extends $tea.Model {
  string?: string[];
  static names(): { [key: string]: string } {
    return {
      string: 'String',
    };
  }

  static types(): { [key: string]: any } {
    return {
      string: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAsrPipelineListResponseBodyPipelineListPipelineNotifyConfig extends $tea.Model {
  queueName?: string;
  topic?: string;
  static names(): { [key: string]: string } {
    return {
      queueName: 'QueueName',
      topic: 'Topic',
    };
  }

  static types(): { [key: string]: any } {
    return {
      queueName: 'string',
      topic: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAsrPipelineListResponseBodyPipelineListPipeline extends $tea.Model {
  state?: string;
  notifyConfig?: QueryAsrPipelineListResponseBodyPipelineListPipelineNotifyConfig;
  priority?: string;
  name?: string;
  id?: string;
  static names(): { [key: string]: string } {
    return {
      state: 'State',
      notifyConfig: 'NotifyConfig',
      priority: 'Priority',
      name: 'Name',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      state: 'string',
      notifyConfig: QueryAsrPipelineListResponseBodyPipelineListPipelineNotifyConfig,
      priority: 'string',
      name: 'string',
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAsrPipelineListResponseBodyPipelineList extends $tea.Model {
  pipeline?: QueryAsrPipelineListResponseBodyPipelineListPipeline[];
  static names(): { [key: string]: string } {
    return {
      pipeline: 'Pipeline',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pipeline: { 'type': 'array', 'itemType': QueryAsrPipelineListResponseBodyPipelineListPipeline },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAsrPipelineListResponseBodyNonExistIds extends $tea.Model {
  string?: string[];
  static names(): { [key: string]: string } {
    return {
      string: 'String',
    };
  }

  static types(): { [key: string]: any } {
    return {
      string: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCensorJobListResponseBodyCensorJobListCensorJobCensorTerrorismResultTerrorismTopListTop extends $tea.Model {
  index?: string;
  score?: string;
  timestamp?: string;
  object?: string;
  label?: string;
  static names(): { [key: string]: string } {
    return {
      index: 'Index',
      score: 'Score',
      timestamp: 'Timestamp',
      object: 'Object',
      label: 'Label',
    };
  }

  static types(): { [key: string]: any } {
    return {
      index: 'string',
      score: 'string',
      timestamp: 'string',
      object: 'string',
      label: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCensorJobListResponseBodyCensorJobListCensorJobCensorTerrorismResultTerrorismTopList extends $tea.Model {
  top?: QueryCensorJobListResponseBodyCensorJobListCensorJobCensorTerrorismResultTerrorismTopListTop[];
  static names(): { [key: string]: string } {
    return {
      top: 'Top',
    };
  }

  static types(): { [key: string]: any } {
    return {
      top: { 'type': 'array', 'itemType': QueryCensorJobListResponseBodyCensorJobListCensorJobCensorTerrorismResultTerrorismTopListTop },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCensorJobListResponseBodyCensorJobListCensorJobCensorTerrorismResultTerrorismCounterListCounter extends $tea.Model {
  label?: string;
  count?: number;
  static names(): { [key: string]: string } {
    return {
      label: 'Label',
      count: 'Count',
    };
  }

  static types(): { [key: string]: any } {
    return {
      label: 'string',
      count: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCensorJobListResponseBodyCensorJobListCensorJobCensorTerrorismResultTerrorismCounterList extends $tea.Model {
  counter?: QueryCensorJobListResponseBodyCensorJobListCensorJobCensorTerrorismResultTerrorismCounterListCounter[];
  static names(): { [key: string]: string } {
    return {
      counter: 'Counter',
    };
  }

  static types(): { [key: string]: any } {
    return {
      counter: { 'type': 'array', 'itemType': QueryCensorJobListResponseBodyCensorJobListCensorJobCensorTerrorismResultTerrorismCounterListCounter },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCensorJobListResponseBodyCensorJobListCensorJobCensorTerrorismResult extends $tea.Model {
  terrorismTopList?: QueryCensorJobListResponseBodyCensorJobListCensorJobCensorTerrorismResultTerrorismTopList;
  suggestion?: string;
  averageScore?: string;
  terrorismCounterList?: QueryCensorJobListResponseBodyCensorJobListCensorJobCensorTerrorismResultTerrorismCounterList;
  label?: string;
  maxScore?: string;
  static names(): { [key: string]: string } {
    return {
      terrorismTopList: 'TerrorismTopList',
      suggestion: 'Suggestion',
      averageScore: 'AverageScore',
      terrorismCounterList: 'TerrorismCounterList',
      label: 'Label',
      maxScore: 'MaxScore',
    };
  }

  static types(): { [key: string]: any } {
    return {
      terrorismTopList: QueryCensorJobListResponseBodyCensorJobListCensorJobCensorTerrorismResultTerrorismTopList,
      suggestion: 'string',
      averageScore: 'string',
      terrorismCounterList: QueryCensorJobListResponseBodyCensorJobListCensorJobCensorTerrorismResultTerrorismCounterList,
      label: 'string',
      maxScore: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCensorJobListResponseBodyCensorJobListCensorJobImageCensorResultsImageCensorResult extends $tea.Model {
  imageBucket?: string;
  result?: string;
  imageLocation?: string;
  imageObject?: string;
  static names(): { [key: string]: string } {
    return {
      imageBucket: 'ImageBucket',
      result: 'Result',
      imageLocation: 'ImageLocation',
      imageObject: 'ImageObject',
    };
  }

  static types(): { [key: string]: any } {
    return {
      imageBucket: 'string',
      result: 'string',
      imageLocation: 'string',
      imageObject: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCensorJobListResponseBodyCensorJobListCensorJobImageCensorResults extends $tea.Model {
  imageCensorResult?: QueryCensorJobListResponseBodyCensorJobListCensorJobImageCensorResultsImageCensorResult[];
  static names(): { [key: string]: string } {
    return {
      imageCensorResult: 'ImageCensorResult',
    };
  }

  static types(): { [key: string]: any } {
    return {
      imageCensorResult: { 'type': 'array', 'itemType': QueryCensorJobListResponseBodyCensorJobListCensorJobImageCensorResultsImageCensorResult },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCensorJobListResponseBodyCensorJobListCensorJobInput extends $tea.Model {
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCensorJobListResponseBodyCensorJobListCensorJobCensorConfigOutputFile extends $tea.Model {
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCensorJobListResponseBodyCensorJobListCensorJobCensorConfig extends $tea.Model {
  interval?: string;
  saveType?: string;
  outputFile?: QueryCensorJobListResponseBodyCensorJobListCensorJobCensorConfigOutputFile;
  scenes?: string;
  bizType?: string;
  static names(): { [key: string]: string } {
    return {
      interval: 'Interval',
      saveType: 'SaveType',
      outputFile: 'OutputFile',
      scenes: 'Scenes',
      bizType: 'BizType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      interval: 'string',
      saveType: 'string',
      outputFile: QueryCensorJobListResponseBodyCensorJobListCensorJobCensorConfigOutputFile,
      scenes: 'string',
      bizType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCensorJobListResponseBodyCensorJobListCensorJobCensorPornResultPornCounterListCounter extends $tea.Model {
  label?: string;
  count?: number;
  static names(): { [key: string]: string } {
    return {
      label: 'Label',
      count: 'Count',
    };
  }

  static types(): { [key: string]: any } {
    return {
      label: 'string',
      count: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCensorJobListResponseBodyCensorJobListCensorJobCensorPornResultPornCounterList extends $tea.Model {
  counter?: QueryCensorJobListResponseBodyCensorJobListCensorJobCensorPornResultPornCounterListCounter[];
  static names(): { [key: string]: string } {
    return {
      counter: 'Counter',
    };
  }

  static types(): { [key: string]: any } {
    return {
      counter: { 'type': 'array', 'itemType': QueryCensorJobListResponseBodyCensorJobListCensorJobCensorPornResultPornCounterListCounter },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCensorJobListResponseBodyCensorJobListCensorJobCensorPornResultPornTopListTop extends $tea.Model {
  index?: string;
  score?: string;
  timestamp?: string;
  object?: string;
  label?: string;
  static names(): { [key: string]: string } {
    return {
      index: 'Index',
      score: 'Score',
      timestamp: 'Timestamp',
      object: 'Object',
      label: 'Label',
    };
  }

  static types(): { [key: string]: any } {
    return {
      index: 'string',
      score: 'string',
      timestamp: 'string',
      object: 'string',
      label: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCensorJobListResponseBodyCensorJobListCensorJobCensorPornResultPornTopList extends $tea.Model {
  top?: QueryCensorJobListResponseBodyCensorJobListCensorJobCensorPornResultPornTopListTop[];
  static names(): { [key: string]: string } {
    return {
      top: 'Top',
    };
  }

  static types(): { [key: string]: any } {
    return {
      top: { 'type': 'array', 'itemType': QueryCensorJobListResponseBodyCensorJobListCensorJobCensorPornResultPornTopListTop },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCensorJobListResponseBodyCensorJobListCensorJobCensorPornResult extends $tea.Model {
  pornCounterList?: QueryCensorJobListResponseBodyCensorJobListCensorJobCensorPornResultPornCounterList;
  suggestion?: string;
  averageScore?: string;
  pornTopList?: QueryCensorJobListResponseBodyCensorJobListCensorJobCensorPornResultPornTopList;
  label?: string;
  maxScore?: string;
  static names(): { [key: string]: string } {
    return {
      pornCounterList: 'PornCounterList',
      suggestion: 'Suggestion',
      averageScore: 'AverageScore',
      pornTopList: 'PornTopList',
      label: 'Label',
      maxScore: 'MaxScore',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pornCounterList: QueryCensorJobListResponseBodyCensorJobListCensorJobCensorPornResultPornCounterList,
      suggestion: 'string',
      averageScore: 'string',
      pornTopList: QueryCensorJobListResponseBodyCensorJobListCensorJobCensorPornResultPornTopList,
      label: 'string',
      maxScore: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCensorJobListResponseBodyCensorJobListCensorJob extends $tea.Model {
  creationTime?: string;
  state?: string;
  censorTerrorismResult?: QueryCensorJobListResponseBodyCensorJobListCensorJobCensorTerrorismResult;
  imageCensorResults?: QueryCensorJobListResponseBodyCensorJobListCensorJobImageCensorResults;
  titleCensorResult?: string;
  message?: string;
  input?: QueryCensorJobListResponseBodyCensorJobListCensorJobInput;
  barrageCensorResult?: string;
  descCensorResult?: string;
  resultSaveObject?: string;
  censorConfig?: QueryCensorJobListResponseBodyCensorJobListCensorJobCensorConfig;
  userData?: string;
  code?: string;
  censorPornResult?: QueryCensorJobListResponseBodyCensorJobListCensorJobCensorPornResult;
  pipelineId?: string;
  id?: string;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      state: 'State',
      censorTerrorismResult: 'CensorTerrorismResult',
      imageCensorResults: 'ImageCensorResults',
      titleCensorResult: 'TitleCensorResult',
      message: 'Message',
      input: 'Input',
      barrageCensorResult: 'BarrageCensorResult',
      descCensorResult: 'DescCensorResult',
      resultSaveObject: 'ResultSaveObject',
      censorConfig: 'CensorConfig',
      userData: 'UserData',
      code: 'Code',
      censorPornResult: 'CensorPornResult',
      pipelineId: 'PipelineId',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      state: 'string',
      censorTerrorismResult: QueryCensorJobListResponseBodyCensorJobListCensorJobCensorTerrorismResult,
      imageCensorResults: QueryCensorJobListResponseBodyCensorJobListCensorJobImageCensorResults,
      titleCensorResult: 'string',
      message: 'string',
      input: QueryCensorJobListResponseBodyCensorJobListCensorJobInput,
      barrageCensorResult: 'string',
      descCensorResult: 'string',
      resultSaveObject: 'string',
      censorConfig: QueryCensorJobListResponseBodyCensorJobListCensorJobCensorConfig,
      userData: 'string',
      code: 'string',
      censorPornResult: QueryCensorJobListResponseBodyCensorJobListCensorJobCensorPornResult,
      pipelineId: 'string',
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCensorJobListResponseBodyCensorJobList extends $tea.Model {
  censorJob?: QueryCensorJobListResponseBodyCensorJobListCensorJob[];
  static names(): { [key: string]: string } {
    return {
      censorJob: 'CensorJob',
    };
  }

  static types(): { [key: string]: any } {
    return {
      censorJob: { 'type': 'array', 'itemType': QueryCensorJobListResponseBodyCensorJobListCensorJob },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCensorJobListResponseBodyNonExistIds extends $tea.Model {
  string?: string[];
  static names(): { [key: string]: string } {
    return {
      string: 'String',
    };
  }

  static types(): { [key: string]: any } {
    return {
      string: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCensorPipelineListResponseBodyPipelineListPipelineNotifyConfig extends $tea.Model {
  topic?: string;
  queue?: string;
  static names(): { [key: string]: string } {
    return {
      topic: 'Topic',
      queue: 'Queue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      topic: 'string',
      queue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCensorPipelineListResponseBodyPipelineListPipeline extends $tea.Model {
  state?: string;
  notifyConfig?: QueryCensorPipelineListResponseBodyPipelineListPipelineNotifyConfig;
  priority?: string;
  name?: string;
  id?: string;
  static names(): { [key: string]: string } {
    return {
      state: 'State',
      notifyConfig: 'NotifyConfig',
      priority: 'Priority',
      name: 'Name',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      state: 'string',
      notifyConfig: QueryCensorPipelineListResponseBodyPipelineListPipelineNotifyConfig,
      priority: 'string',
      name: 'string',
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCensorPipelineListResponseBodyPipelineList extends $tea.Model {
  pipeline?: QueryCensorPipelineListResponseBodyPipelineListPipeline[];
  static names(): { [key: string]: string } {
    return {
      pipeline: 'Pipeline',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pipeline: { 'type': 'array', 'itemType': QueryCensorPipelineListResponseBodyPipelineListPipeline },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCensorPipelineListResponseBodyNonExistIds extends $tea.Model {
  string?: string[];
  static names(): { [key: string]: string } {
    return {
      string: 'String',
    };
  }

  static types(): { [key: string]: any } {
    return {
      string: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryComplexJobListResponseBodyNonExistJobIds extends $tea.Model {
  string?: string[];
  static names(): { [key: string]: string } {
    return {
      string: 'String',
    };
  }

  static types(): { [key: string]: any } {
    return {
      string: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryComplexJobListResponseBodyJobListJobTranscodeOutputVideoBitrateBnd extends $tea.Model {
  max?: string;
  min?: string;
  static names(): { [key: string]: string } {
    return {
      max: 'Max',
      min: 'Min',
    };
  }

  static types(): { [key: string]: any } {
    return {
      max: 'string',
      min: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryComplexJobListResponseBodyJobListJobTranscodeOutputVideo extends $tea.Model {
  bufsize?: string;
  degrain?: string;
  bitrateBnd?: QueryComplexJobListResponseBodyJobListJobTranscodeOutputVideoBitrateBnd;
  pixFmt?: string;
  pad?: string;
  codec?: string;
  height?: string;
  qscale?: string;
  crop?: string;
  bitrate?: string;
  maxrate?: string;
  maxFps?: string;
  profile?: string;
  crf?: string;
  gop?: string;
  width?: string;
  fps?: string;
  preset?: string;
  scanMode?: string;
  static names(): { [key: string]: string } {
    return {
      bufsize: 'Bufsize',
      degrain: 'Degrain',
      bitrateBnd: 'BitrateBnd',
      pixFmt: 'PixFmt',
      pad: 'Pad',
      codec: 'Codec',
      height: 'Height',
      qscale: 'Qscale',
      crop: 'Crop',
      bitrate: 'Bitrate',
      maxrate: 'Maxrate',
      maxFps: 'MaxFps',
      profile: 'Profile',
      crf: 'Crf',
      gop: 'Gop',
      width: 'Width',
      fps: 'Fps',
      preset: 'Preset',
      scanMode: 'ScanMode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bufsize: 'string',
      degrain: 'string',
      bitrateBnd: QueryComplexJobListResponseBodyJobListJobTranscodeOutputVideoBitrateBnd,
      pixFmt: 'string',
      pad: 'string',
      codec: 'string',
      height: 'string',
      qscale: 'string',
      crop: 'string',
      bitrate: 'string',
      maxrate: 'string',
      maxFps: 'string',
      profile: 'string',
      crf: 'string',
      gop: 'string',
      width: 'string',
      fps: 'string',
      preset: 'string',
      scanMode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryComplexJobListResponseBodyJobListJobTranscodeOutputTransConfig extends $tea.Model {
  isCheckAudioBitrate?: string;
  isCheckReso?: string;
  transMode?: string;
  isCheckVideoBitrateFail?: string;
  adjDarMethod?: string;
  duration?: string;
  isCheckVideoBitrate?: string;
  isCheckResoFail?: string;
  isCheckAudioBitrateFail?: string;
  static names(): { [key: string]: string } {
    return {
      isCheckAudioBitrate: 'IsCheckAudioBitrate',
      isCheckReso: 'IsCheckReso',
      transMode: 'TransMode',
      isCheckVideoBitrateFail: 'IsCheckVideoBitrateFail',
      adjDarMethod: 'AdjDarMethod',
      duration: 'Duration',
      isCheckVideoBitrate: 'IsCheckVideoBitrate',
      isCheckResoFail: 'IsCheckResoFail',
      isCheckAudioBitrateFail: 'IsCheckAudioBitrateFail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isCheckAudioBitrate: 'string',
      isCheckReso: 'string',
      transMode: 'string',
      isCheckVideoBitrateFail: 'string',
      adjDarMethod: 'string',
      duration: 'string',
      isCheckVideoBitrate: 'string',
      isCheckResoFail: 'string',
      isCheckAudioBitrateFail: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryComplexJobListResponseBodyJobListJobTranscodeOutputEncryption extends $tea.Model {
  type?: string;
  key?: string;
  keyType?: string;
  id?: string;
  keyUri?: string;
  skipCnt?: string;
  static names(): { [key: string]: string } {
    return {
      type: 'Type',
      key: 'Key',
      keyType: 'KeyType',
      id: 'Id',
      keyUri: 'KeyUri',
      skipCnt: 'SkipCnt',
    };
  }

  static types(): { [key: string]: any } {
    return {
      type: 'string',
      key: 'string',
      keyType: 'string',
      id: 'string',
      keyUri: 'string',
      skipCnt: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryComplexJobListResponseBodyJobListJobTranscodeOutputWaterMarkListWaterMarkInputFile extends $tea.Model {
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryComplexJobListResponseBodyJobListJobTranscodeOutputWaterMarkListWaterMark extends $tea.Model {
  type?: string;
  referPos?: string;
  dx?: string;
  width?: string;
  height?: string;
  inputFile?: QueryComplexJobListResponseBodyJobListJobTranscodeOutputWaterMarkListWaterMarkInputFile;
  waterMarkTemplateId?: string;
  dy?: string;
  static names(): { [key: string]: string } {
    return {
      type: 'Type',
      referPos: 'ReferPos',
      dx: 'Dx',
      width: 'Width',
      height: 'Height',
      inputFile: 'InputFile',
      waterMarkTemplateId: 'WaterMarkTemplateId',
      dy: 'Dy',
    };
  }

  static types(): { [key: string]: any } {
    return {
      type: 'string',
      referPos: 'string',
      dx: 'string',
      width: 'string',
      height: 'string',
      inputFile: QueryComplexJobListResponseBodyJobListJobTranscodeOutputWaterMarkListWaterMarkInputFile,
      waterMarkTemplateId: 'string',
      dy: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryComplexJobListResponseBodyJobListJobTranscodeOutputWaterMarkList extends $tea.Model {
  waterMark?: QueryComplexJobListResponseBodyJobListJobTranscodeOutputWaterMarkListWaterMark[];
  static names(): { [key: string]: string } {
    return {
      waterMark: 'WaterMark',
    };
  }

  static types(): { [key: string]: any } {
    return {
      waterMark: { 'type': 'array', 'itemType': QueryComplexJobListResponseBodyJobListJobTranscodeOutputWaterMarkListWaterMark },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryComplexJobListResponseBodyJobListJobTranscodeOutputM3U8NonStandardSupportTS extends $tea.Model {
  sizeSupport?: boolean;
  md5Support?: boolean;
  static names(): { [key: string]: string } {
    return {
      sizeSupport: 'SizeSupport',
      md5Support: 'Md5Support',
    };
  }

  static types(): { [key: string]: any } {
    return {
      sizeSupport: 'boolean',
      md5Support: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryComplexJobListResponseBodyJobListJobTranscodeOutputM3U8NonStandardSupport extends $tea.Model {
  TS?: QueryComplexJobListResponseBodyJobListJobTranscodeOutputM3U8NonStandardSupportTS;
  static names(): { [key: string]: string } {
    return {
      TS: 'TS',
    };
  }

  static types(): { [key: string]: any } {
    return {
      TS: QueryComplexJobListResponseBodyJobListJobTranscodeOutputM3U8NonStandardSupportTS,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryComplexJobListResponseBodyJobListJobTranscodeOutputAudioVolume extends $tea.Model {
  method?: string;
  level?: string;
  static names(): { [key: string]: string } {
    return {
      method: 'Method',
      level: 'Level',
    };
  }

  static types(): { [key: string]: any } {
    return {
      method: 'string',
      level: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryComplexJobListResponseBodyJobListJobTranscodeOutputAudio extends $tea.Model {
  profile?: string;
  codec?: string;
  samplerate?: string;
  qscale?: string;
  channels?: string;
  volume?: QueryComplexJobListResponseBodyJobListJobTranscodeOutputAudioVolume;
  bitrate?: string;
  static names(): { [key: string]: string } {
    return {
      profile: 'Profile',
      codec: 'Codec',
      samplerate: 'Samplerate',
      qscale: 'Qscale',
      channels: 'Channels',
      volume: 'Volume',
      bitrate: 'Bitrate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      profile: 'string',
      codec: 'string',
      samplerate: 'string',
      qscale: 'string',
      channels: 'string',
      volume: QueryComplexJobListResponseBodyJobListJobTranscodeOutputAudioVolume,
      bitrate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryComplexJobListResponseBodyJobListJobTranscodeOutputMergeListMerge extends $tea.Model {
  start?: string;
  roleArn?: string;
  mergeURL?: string;
  duration?: string;
  static names(): { [key: string]: string } {
    return {
      start: 'Start',
      roleArn: 'RoleArn',
      mergeURL: 'MergeURL',
      duration: 'Duration',
    };
  }

  static types(): { [key: string]: any } {
    return {
      start: 'string',
      roleArn: 'string',
      mergeURL: 'string',
      duration: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryComplexJobListResponseBodyJobListJobTranscodeOutputMergeList extends $tea.Model {
  merge?: QueryComplexJobListResponseBodyJobListJobTranscodeOutputMergeListMerge[];
  static names(): { [key: string]: string } {
    return {
      merge: 'Merge',
    };
  }

  static types(): { [key: string]: any } {
    return {
      merge: { 'type': 'array', 'itemType': QueryComplexJobListResponseBodyJobListJobTranscodeOutputMergeListMerge },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryComplexJobListResponseBodyJobListJobTranscodeOutputSuperReso extends $tea.Model {
  isHalfSample?: string;
  static names(): { [key: string]: string } {
    return {
      isHalfSample: 'IsHalfSample',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isHalfSample: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryComplexJobListResponseBodyJobListJobTranscodeOutputDigiWaterMarkInputFile extends $tea.Model {
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryComplexJobListResponseBodyJobListJobTranscodeOutputDigiWaterMark extends $tea.Model {
  type?: string;
  alpha?: string;
  inputFile?: QueryComplexJobListResponseBodyJobListJobTranscodeOutputDigiWaterMarkInputFile;
  static names(): { [key: string]: string } {
    return {
      type: 'Type',
      alpha: 'Alpha',
      inputFile: 'InputFile',
    };
  }

  static types(): { [key: string]: any } {
    return {
      type: 'string',
      alpha: 'string',
      inputFile: QueryComplexJobListResponseBodyJobListJobTranscodeOutputDigiWaterMarkInputFile,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryComplexJobListResponseBodyJobListJobTranscodeOutputOutputFile extends $tea.Model {
  roleArn?: string;
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      roleArn: 'RoleArn',
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      roleArn: 'string',
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryComplexJobListResponseBodyJobListJobTranscodeOutputContainer extends $tea.Model {
  format?: string;
  static names(): { [key: string]: string } {
    return {
      format: 'Format',
    };
  }

  static types(): { [key: string]: any } {
    return {
      format: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryComplexJobListResponseBodyJobListJobTranscodeOutputClipTimeSpan extends $tea.Model {
  seek?: string;
  duration?: string;
  static names(): { [key: string]: string } {
    return {
      seek: 'Seek',
      duration: 'Duration',
    };
  }

  static types(): { [key: string]: any } {
    return {
      seek: 'string',
      duration: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryComplexJobListResponseBodyJobListJobTranscodeOutputClip extends $tea.Model {
  timeSpan?: QueryComplexJobListResponseBodyJobListJobTranscodeOutputClipTimeSpan;
  static names(): { [key: string]: string } {
    return {
      timeSpan: 'TimeSpan',
    };
  }

  static types(): { [key: string]: any } {
    return {
      timeSpan: QueryComplexJobListResponseBodyJobListJobTranscodeOutputClipTimeSpan,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryComplexJobListResponseBodyJobListJobTranscodeOutputMuxConfigGif extends $tea.Model {
  finalDelay?: string;
  ditherMode?: string;
  loop?: string;
  isCustomPalette?: string;
  static names(): { [key: string]: string } {
    return {
      finalDelay: 'FinalDelay',
      ditherMode: 'DitherMode',
      loop: 'Loop',
      isCustomPalette: 'IsCustomPalette',
    };
  }

  static types(): { [key: string]: any } {
    return {
      finalDelay: 'string',
      ditherMode: 'string',
      loop: 'string',
      isCustomPalette: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryComplexJobListResponseBodyJobListJobTranscodeOutputMuxConfigSegment extends $tea.Model {
  duration?: string;
  static names(): { [key: string]: string } {
    return {
      duration: 'Duration',
    };
  }

  static types(): { [key: string]: any } {
    return {
      duration: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryComplexJobListResponseBodyJobListJobTranscodeOutputMuxConfig extends $tea.Model {
  gif?: QueryComplexJobListResponseBodyJobListJobTranscodeOutputMuxConfigGif;
  segment?: QueryComplexJobListResponseBodyJobListJobTranscodeOutputMuxConfigSegment;
  static names(): { [key: string]: string } {
    return {
      gif: 'Gif',
      segment: 'Segment',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gif: QueryComplexJobListResponseBodyJobListJobTranscodeOutputMuxConfigGif,
      segment: QueryComplexJobListResponseBodyJobListJobTranscodeOutputMuxConfigSegment,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryComplexJobListResponseBodyJobListJobTranscodeOutputSubtitleConfigExtSubtitleListExtSubtitleInput extends $tea.Model {
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryComplexJobListResponseBodyJobListJobTranscodeOutputSubtitleConfigExtSubtitleListExtSubtitle extends $tea.Model {
  charEnc?: string;
  fontName?: string;
  input?: QueryComplexJobListResponseBodyJobListJobTranscodeOutputSubtitleConfigExtSubtitleListExtSubtitleInput;
  static names(): { [key: string]: string } {
    return {
      charEnc: 'CharEnc',
      fontName: 'FontName',
      input: 'Input',
    };
  }

  static types(): { [key: string]: any } {
    return {
      charEnc: 'string',
      fontName: 'string',
      input: QueryComplexJobListResponseBodyJobListJobTranscodeOutputSubtitleConfigExtSubtitleListExtSubtitleInput,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryComplexJobListResponseBodyJobListJobTranscodeOutputSubtitleConfigExtSubtitleList extends $tea.Model {
  extSubtitle?: QueryComplexJobListResponseBodyJobListJobTranscodeOutputSubtitleConfigExtSubtitleListExtSubtitle[];
  static names(): { [key: string]: string } {
    return {
      extSubtitle: 'ExtSubtitle',
    };
  }

  static types(): { [key: string]: any } {
    return {
      extSubtitle: { 'type': 'array', 'itemType': QueryComplexJobListResponseBodyJobListJobTranscodeOutputSubtitleConfigExtSubtitleListExtSubtitle },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryComplexJobListResponseBodyJobListJobTranscodeOutputSubtitleConfigSubtitleListSubtitle extends $tea.Model {
  map?: string;
  static names(): { [key: string]: string } {
    return {
      map: 'Map',
    };
  }

  static types(): { [key: string]: any } {
    return {
      map: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryComplexJobListResponseBodyJobListJobTranscodeOutputSubtitleConfigSubtitleList extends $tea.Model {
  subtitle?: QueryComplexJobListResponseBodyJobListJobTranscodeOutputSubtitleConfigSubtitleListSubtitle[];
  static names(): { [key: string]: string } {
    return {
      subtitle: 'Subtitle',
    };
  }

  static types(): { [key: string]: any } {
    return {
      subtitle: { 'type': 'array', 'itemType': QueryComplexJobListResponseBodyJobListJobTranscodeOutputSubtitleConfigSubtitleListSubtitle },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryComplexJobListResponseBodyJobListJobTranscodeOutputSubtitleConfig extends $tea.Model {
  extSubtitleList?: QueryComplexJobListResponseBodyJobListJobTranscodeOutputSubtitleConfigExtSubtitleList;
  subtitleList?: QueryComplexJobListResponseBodyJobListJobTranscodeOutputSubtitleConfigSubtitleList;
  static names(): { [key: string]: string } {
    return {
      extSubtitleList: 'ExtSubtitleList',
      subtitleList: 'SubtitleList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      extSubtitleList: QueryComplexJobListResponseBodyJobListJobTranscodeOutputSubtitleConfigExtSubtitleList,
      subtitleList: QueryComplexJobListResponseBodyJobListJobTranscodeOutputSubtitleConfigSubtitleList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost extends $tea.Model {
  preloadTime?: string;
  avgBitrate?: string;
  costBandwidth?: string;
  static names(): { [key: string]: string } {
    return {
      preloadTime: 'PreloadTime',
      avgBitrate: 'AvgBitrate',
      costBandwidth: 'CostBandwidth',
    };
  }

  static types(): { [key: string]: any } {
    return {
      preloadTime: 'string',
      avgBitrate: 'string',
      costBandwidth: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreamsVideoStreamListVideoStream extends $tea.Model {
  index?: string;
  timebase?: string;
  avgFPS?: string;
  pixFmt?: string;
  sar?: string;
  lang?: string;
  codecLongName?: string;
  height?: string;
  numFrames?: string;
  bitrate?: string;
  codecTagString?: string;
  hasBFrames?: string;
  profile?: string;
  startTime?: string;
  networkCost?: QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost;
  dar?: string;
  codecName?: string;
  width?: string;
  duration?: string;
  fps?: string;
  codecTag?: string;
  codecTimeBase?: string;
  level?: string;
  static names(): { [key: string]: string } {
    return {
      index: 'Index',
      timebase: 'Timebase',
      avgFPS: 'AvgFPS',
      pixFmt: 'PixFmt',
      sar: 'Sar',
      lang: 'Lang',
      codecLongName: 'CodecLongName',
      height: 'Height',
      numFrames: 'NumFrames',
      bitrate: 'Bitrate',
      codecTagString: 'CodecTagString',
      hasBFrames: 'HasBFrames',
      profile: 'Profile',
      startTime: 'StartTime',
      networkCost: 'NetworkCost',
      dar: 'Dar',
      codecName: 'CodecName',
      width: 'Width',
      duration: 'Duration',
      fps: 'Fps',
      codecTag: 'CodecTag',
      codecTimeBase: 'CodecTimeBase',
      level: 'Level',
    };
  }

  static types(): { [key: string]: any } {
    return {
      index: 'string',
      timebase: 'string',
      avgFPS: 'string',
      pixFmt: 'string',
      sar: 'string',
      lang: 'string',
      codecLongName: 'string',
      height: 'string',
      numFrames: 'string',
      bitrate: 'string',
      codecTagString: 'string',
      hasBFrames: 'string',
      profile: 'string',
      startTime: 'string',
      networkCost: QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost,
      dar: 'string',
      codecName: 'string',
      width: 'string',
      duration: 'string',
      fps: 'string',
      codecTag: 'string',
      codecTimeBase: 'string',
      level: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreamsVideoStreamList extends $tea.Model {
  videoStream?: QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreamsVideoStreamListVideoStream[];
  static names(): { [key: string]: string } {
    return {
      videoStream: 'VideoStream',
    };
  }

  static types(): { [key: string]: any } {
    return {
      videoStream: { 'type': 'array', 'itemType': QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreamsVideoStreamListVideoStream },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreamsAudioStreamListAudioStream extends $tea.Model {
  timebase?: string;
  index?: string;
  sampleFmt?: string;
  channelLayout?: string;
  lang?: string;
  samplerate?: string;
  codecLongName?: string;
  channels?: string;
  numFrames?: string;
  bitrate?: string;
  codecTagString?: string;
  startTime?: string;
  codecName?: string;
  duration?: string;
  codecTag?: string;
  codecTimeBase?: string;
  static names(): { [key: string]: string } {
    return {
      timebase: 'Timebase',
      index: 'Index',
      sampleFmt: 'SampleFmt',
      channelLayout: 'ChannelLayout',
      lang: 'Lang',
      samplerate: 'Samplerate',
      codecLongName: 'CodecLongName',
      channels: 'Channels',
      numFrames: 'NumFrames',
      bitrate: 'Bitrate',
      codecTagString: 'CodecTagString',
      startTime: 'StartTime',
      codecName: 'CodecName',
      duration: 'Duration',
      codecTag: 'CodecTag',
      codecTimeBase: 'CodecTimeBase',
    };
  }

  static types(): { [key: string]: any } {
    return {
      timebase: 'string',
      index: 'string',
      sampleFmt: 'string',
      channelLayout: 'string',
      lang: 'string',
      samplerate: 'string',
      codecLongName: 'string',
      channels: 'string',
      numFrames: 'string',
      bitrate: 'string',
      codecTagString: 'string',
      startTime: 'string',
      codecName: 'string',
      duration: 'string',
      codecTag: 'string',
      codecTimeBase: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreamsAudioStreamList extends $tea.Model {
  audioStream?: QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreamsAudioStreamListAudioStream[];
  static names(): { [key: string]: string } {
    return {
      audioStream: 'AudioStream',
    };
  }

  static types(): { [key: string]: any } {
    return {
      audioStream: { 'type': 'array', 'itemType': QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreamsAudioStreamListAudioStream },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreamsSubtitleStreamListSubtitleStream extends $tea.Model {
  index?: string;
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      index: 'Index',
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      index: 'string',
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreamsSubtitleStreamList extends $tea.Model {
  subtitleStream?: QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreamsSubtitleStreamListSubtitleStream[];
  static names(): { [key: string]: string } {
    return {
      subtitleStream: 'SubtitleStream',
    };
  }

  static types(): { [key: string]: any } {
    return {
      subtitleStream: { 'type': 'array', 'itemType': QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreamsSubtitleStreamListSubtitleStream },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreams extends $tea.Model {
  videoStreamList?: QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreamsVideoStreamList;
  audioStreamList?: QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreamsAudioStreamList;
  subtitleStreamList?: QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreamsSubtitleStreamList;
  static names(): { [key: string]: string } {
    return {
      videoStreamList: 'VideoStreamList',
      audioStreamList: 'AudioStreamList',
      subtitleStreamList: 'SubtitleStreamList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      videoStreamList: QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreamsVideoStreamList,
      audioStreamList: QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreamsAudioStreamList,
      subtitleStreamList: QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreamsSubtitleStreamList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesFormat extends $tea.Model {
  startTime?: string;
  numPrograms?: string;
  size?: string;
  numStreams?: string;
  formatLongName?: string;
  duration?: string;
  bitrate?: string;
  formatName?: string;
  static names(): { [key: string]: string } {
    return {
      startTime: 'StartTime',
      numPrograms: 'NumPrograms',
      size: 'Size',
      numStreams: 'NumStreams',
      formatLongName: 'FormatLongName',
      duration: 'Duration',
      bitrate: 'Bitrate',
      formatName: 'FormatName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      startTime: 'string',
      numPrograms: 'string',
      size: 'string',
      numStreams: 'string',
      formatLongName: 'string',
      duration: 'string',
      bitrate: 'string',
      formatName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryComplexJobListResponseBodyJobListJobTranscodeOutputProperties extends $tea.Model {
  width?: string;
  height?: string;
  duration?: string;
  fps?: string;
  bitrate?: string;
  fileFormat?: string;
  streams?: QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreams;
  format?: QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesFormat;
  fileSize?: string;
  static names(): { [key: string]: string } {
    return {
      width: 'Width',
      height: 'Height',
      duration: 'Duration',
      fps: 'Fps',
      bitrate: 'Bitrate',
      fileFormat: 'FileFormat',
      streams: 'Streams',
      format: 'Format',
      fileSize: 'FileSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      width: 'string',
      height: 'string',
      duration: 'string',
      fps: 'string',
      bitrate: 'string',
      fileFormat: 'string',
      streams: QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesStreams,
      format: QueryComplexJobListResponseBodyJobListJobTranscodeOutputPropertiesFormat,
      fileSize: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryComplexJobListResponseBodyJobListJobTranscodeOutput extends $tea.Model {
  video?: QueryComplexJobListResponseBodyJobListJobTranscodeOutputVideo;
  transConfig?: QueryComplexJobListResponseBodyJobListJobTranscodeOutputTransConfig;
  encryption?: QueryComplexJobListResponseBodyJobListJobTranscodeOutputEncryption;
  waterMarkList?: QueryComplexJobListResponseBodyJobListJobTranscodeOutputWaterMarkList;
  deWatermark?: string;
  waterMarkConfigUrl?: string;
  m3U8NonStandardSupport?: QueryComplexJobListResponseBodyJobListJobTranscodeOutputM3U8NonStandardSupport;
  priority?: string;
  audio?: QueryComplexJobListResponseBodyJobListJobTranscodeOutputAudio;
  audioStreamMap?: string;
  mergeList?: QueryComplexJobListResponseBodyJobListJobTranscodeOutputMergeList;
  superReso?: QueryComplexJobListResponseBodyJobListJobTranscodeOutputSuperReso;
  userData?: string;
  digiWaterMark?: QueryComplexJobListResponseBodyJobListJobTranscodeOutputDigiWaterMark;
  videoStreamMap?: string;
  outputFile?: QueryComplexJobListResponseBodyJobListJobTranscodeOutputOutputFile;
  rotate?: string;
  container?: QueryComplexJobListResponseBodyJobListJobTranscodeOutputContainer;
  clip?: QueryComplexJobListResponseBodyJobListJobTranscodeOutputClip;
  mergeConfigUrl?: string;
  muxConfig?: QueryComplexJobListResponseBodyJobListJobTranscodeOutputMuxConfig;
  templateId?: string;
  subtitleConfig?: QueryComplexJobListResponseBodyJobListJobTranscodeOutputSubtitleConfig;
  properties?: QueryComplexJobListResponseBodyJobListJobTranscodeOutputProperties;
  static names(): { [key: string]: string } {
    return {
      video: 'Video',
      transConfig: 'TransConfig',
      encryption: 'Encryption',
      waterMarkList: 'WaterMarkList',
      deWatermark: 'DeWatermark',
      waterMarkConfigUrl: 'WaterMarkConfigUrl',
      m3U8NonStandardSupport: 'M3U8NonStandardSupport',
      priority: 'Priority',
      audio: 'Audio',
      audioStreamMap: 'AudioStreamMap',
      mergeList: 'MergeList',
      superReso: 'SuperReso',
      userData: 'UserData',
      digiWaterMark: 'DigiWaterMark',
      videoStreamMap: 'VideoStreamMap',
      outputFile: 'OutputFile',
      rotate: 'Rotate',
      container: 'Container',
      clip: 'Clip',
      mergeConfigUrl: 'MergeConfigUrl',
      muxConfig: 'MuxConfig',
      templateId: 'TemplateId',
      subtitleConfig: 'SubtitleConfig',
      properties: 'Properties',
    };
  }

  static types(): { [key: string]: any } {
    return {
      video: QueryComplexJobListResponseBodyJobListJobTranscodeOutputVideo,
      transConfig: QueryComplexJobListResponseBodyJobListJobTranscodeOutputTransConfig,
      encryption: QueryComplexJobListResponseBodyJobListJobTranscodeOutputEncryption,
      waterMarkList: QueryComplexJobListResponseBodyJobListJobTranscodeOutputWaterMarkList,
      deWatermark: 'string',
      waterMarkConfigUrl: 'string',
      m3U8NonStandardSupport: QueryComplexJobListResponseBodyJobListJobTranscodeOutputM3U8NonStandardSupport,
      priority: 'string',
      audio: QueryComplexJobListResponseBodyJobListJobTranscodeOutputAudio,
      audioStreamMap: 'string',
      mergeList: QueryComplexJobListResponseBodyJobListJobTranscodeOutputMergeList,
      superReso: QueryComplexJobListResponseBodyJobListJobTranscodeOutputSuperReso,
      userData: 'string',
      digiWaterMark: QueryComplexJobListResponseBodyJobListJobTranscodeOutputDigiWaterMark,
      videoStreamMap: 'string',
      outputFile: QueryComplexJobListResponseBodyJobListJobTranscodeOutputOutputFile,
      rotate: 'string',
      container: QueryComplexJobListResponseBodyJobListJobTranscodeOutputContainer,
      clip: QueryComplexJobListResponseBodyJobListJobTranscodeOutputClip,
      mergeConfigUrl: 'string',
      muxConfig: QueryComplexJobListResponseBodyJobListJobTranscodeOutputMuxConfig,
      templateId: 'string',
      subtitleConfig: QueryComplexJobListResponseBodyJobListJobTranscodeOutputSubtitleConfig,
      properties: QueryComplexJobListResponseBodyJobListJobTranscodeOutputProperties,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryComplexJobListResponseBodyJobListJobMNSMessageResult extends $tea.Model {
  messageId?: string;
  errorMessage?: string;
  errorCode?: string;
  static names(): { [key: string]: string } {
    return {
      messageId: 'MessageId',
      errorMessage: 'ErrorMessage',
      errorCode: 'ErrorCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      messageId: 'string',
      errorMessage: 'string',
      errorCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClipsClipClipsConfigClipsConfigVideo extends $tea.Model {
  t?: string;
  l?: string;
  static names(): { [key: string]: string } {
    return {
      t: 'T',
      l: 'L',
    };
  }

  static types(): { [key: string]: any } {
    return {
      t: 'string',
      l: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClipsClipClipsConfig extends $tea.Model {
  clipsConfigVideo?: QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClipsClipClipsConfigClipsConfigVideo;
  static names(): { [key: string]: string } {
    return {
      clipsConfigVideo: 'ClipsConfigVideo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clipsConfigVideo: QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClipsClipClipsConfigClipsConfigVideo,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClipsClip extends $tea.Model {
  clipsConfig?: QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClipsClipClipsConfig;
  out?: string;
  in?: string;
  clipID?: string;
  static names(): { [key: string]: string } {
    return {
      clipsConfig: 'ClipsConfig',
      out: 'Out',
      in: 'In',
      clipID: 'clipID',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clipsConfig: QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClipsClipClipsConfig,
      out: 'string',
      in: 'string',
      clipID: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClips extends $tea.Model {
  clip?: QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClipsClip[];
  static names(): { [key: string]: string } {
    return {
      clip: 'Clip',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clip: { 'type': 'array', 'itemType': QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClipsClip },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrack extends $tea.Model {
  type?: string;
  order?: string;
  id?: string;
  clips?: QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClips;
  static names(): { [key: string]: string } {
    return {
      type: 'Type',
      order: 'Order',
      id: 'Id',
      clips: 'Clips',
    };
  }

  static types(): { [key: string]: any } {
    return {
      type: 'string',
      order: 'string',
      id: 'string',
      clips: QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClips,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackList extends $tea.Model {
  track?: QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrack[];
  static names(): { [key: string]: string } {
    return {
      track: 'Track',
    };
  }

  static types(): { [key: string]: any } {
    return {
      track: { 'type': 'array', 'itemType': QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrack },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTimelineConfigTimelineConfigAudio extends $tea.Model {
  channelLayout?: string;
  samplerate?: string;
  channels?: string;
  static names(): { [key: string]: string } {
    return {
      channelLayout: 'ChannelLayout',
      samplerate: 'Samplerate',
      channels: 'Channels',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelLayout: 'string',
      samplerate: 'string',
      channels: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTimelineConfigTimelineConfigVideo extends $tea.Model {
  bgColor?: string;
  width?: string;
  renderRatio?: string;
  isGpuData?: string;
  height?: string;
  isOneTrackData?: string;
  fps?: string;
  reclosePrec?: string;
  static names(): { [key: string]: string } {
    return {
      bgColor: 'BgColor',
      width: 'Width',
      renderRatio: 'RenderRatio',
      isGpuData: 'IsGpuData',
      height: 'Height',
      isOneTrackData: 'IsOneTrackData',
      fps: 'Fps',
      reclosePrec: 'ReclosePrec',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bgColor: 'string',
      width: 'string',
      renderRatio: 'string',
      isGpuData: 'string',
      height: 'string',
      isOneTrackData: 'string',
      fps: 'string',
      reclosePrec: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTimelineConfig extends $tea.Model {
  timelineConfigAudio?: QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTimelineConfigTimelineConfigAudio;
  timelineConfigVideo?: QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTimelineConfigTimelineConfigVideo;
  static names(): { [key: string]: string } {
    return {
      timelineConfigAudio: 'TimelineConfigAudio',
      timelineConfigVideo: 'TimelineConfigVideo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      timelineConfigAudio: QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTimelineConfigTimelineConfigAudio,
      timelineConfigVideo: QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTimelineConfigTimelineConfigVideo,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimeline extends $tea.Model {
  trackList?: QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackList;
  timelineConfig?: QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTimelineConfig;
  static names(): { [key: string]: string } {
    return {
      trackList: 'TrackList',
      timelineConfig: 'TimelineConfig',
    };
  }

  static types(): { [key: string]: any } {
    return {
      trackList: QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackList,
      timelineConfig: QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTimelineConfig,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingClipListClipEffectsEffect extends $tea.Model {
  effect?: string;
  effectConfig?: string;
  static names(): { [key: string]: string } {
    return {
      effect: 'Effect',
      effectConfig: 'EffectConfig',
    };
  }

  static types(): { [key: string]: any } {
    return {
      effect: 'string',
      effectConfig: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingClipListClipEffects extends $tea.Model {
  effect?: QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingClipListClipEffectsEffect[];
  static names(): { [key: string]: string } {
    return {
      effect: 'Effect',
    };
  }

  static types(): { [key: string]: any } {
    return {
      effect: { 'type': 'array', 'itemType': QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingClipListClipEffectsEffect },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingClipListClip extends $tea.Model {
  type?: string;
  sourceID?: string;
  effects?: QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingClipListClipEffects;
  sourceType?: string;
  sourceStrmMap?: string;
  out?: string;
  in?: string;
  id?: string;
  static names(): { [key: string]: string } {
    return {
      type: 'Type',
      sourceID: 'SourceID',
      effects: 'Effects',
      sourceType: 'SourceType',
      sourceStrmMap: 'SourceStrmMap',
      out: 'Out',
      in: 'In',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      type: 'string',
      sourceID: 'string',
      effects: QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingClipListClipEffects,
      sourceType: 'string',
      sourceStrmMap: 'string',
      out: 'string',
      in: 'string',
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingClipList extends $tea.Model {
  clip?: QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingClipListClip[];
  static names(): { [key: string]: string } {
    return {
      clip: 'Clip',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clip: { 'type': 'array', 'itemType': QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingClipListClip },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditing extends $tea.Model {
  timeline?: QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimeline;
  clipList?: QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingClipList;
  static names(): { [key: string]: string } {
    return {
      timeline: 'Timeline',
      clipList: 'ClipList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      timeline: QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingTimeline,
      clipList: QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditingClipList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigs extends $tea.Model {
  editing?: QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditing;
  static names(): { [key: string]: string } {
    return {
      editing: 'Editing',
    };
  }

  static types(): { [key: string]: any } {
    return {
      editing: QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigsEditing,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryComplexJobListResponseBodyJobListJobComplexEditingConfigs extends $tea.Model {
  complexEditingConfigs?: QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigs[];
  static names(): { [key: string]: string } {
    return {
      complexEditingConfigs: 'ComplexEditingConfigs',
    };
  }

  static types(): { [key: string]: any } {
    return {
      complexEditingConfigs: { 'type': 'array', 'itemType': QueryComplexJobListResponseBodyJobListJobComplexEditingConfigsComplexEditingConfigs },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryComplexJobListResponseBodyJobListJobInputsInputsEditingInputsEditingInputInputFile extends $tea.Model {
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryComplexJobListResponseBodyJobListJobInputsInputsEditingInputsEditingInputInputConfig extends $tea.Model {
  isNormalSar?: string;
  deinterlaceMethod?: string;
  static names(): { [key: string]: string } {
    return {
      isNormalSar: 'IsNormalSar',
      deinterlaceMethod: 'DeinterlaceMethod',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isNormalSar: 'string',
      deinterlaceMethod: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryComplexJobListResponseBodyJobListJobInputsInputsEditingInputsEditingInput extends $tea.Model {
  inputFile?: QueryComplexJobListResponseBodyJobListJobInputsInputsEditingInputsEditingInputInputFile;
  inputConfig?: QueryComplexJobListResponseBodyJobListJobInputsInputsEditingInputsEditingInputInputConfig;
  id?: string;
  static names(): { [key: string]: string } {
    return {
      inputFile: 'InputFile',
      inputConfig: 'InputConfig',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      inputFile: QueryComplexJobListResponseBodyJobListJobInputsInputsEditingInputsEditingInputInputFile,
      inputConfig: QueryComplexJobListResponseBodyJobListJobInputsInputsEditingInputsEditingInputInputConfig,
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryComplexJobListResponseBodyJobListJobInputsInputsEditingInputs extends $tea.Model {
  editingInput?: QueryComplexJobListResponseBodyJobListJobInputsInputsEditingInputsEditingInput[];
  static names(): { [key: string]: string } {
    return {
      editingInput: 'EditingInput',
    };
  }

  static types(): { [key: string]: any } {
    return {
      editingInput: { 'type': 'array', 'itemType': QueryComplexJobListResponseBodyJobListJobInputsInputsEditingInputsEditingInput },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryComplexJobListResponseBodyJobListJobInputsInputs extends $tea.Model {
  editingInputs?: QueryComplexJobListResponseBodyJobListJobInputsInputsEditingInputs;
  static names(): { [key: string]: string } {
    return {
      editingInputs: 'EditingInputs',
    };
  }

  static types(): { [key: string]: any } {
    return {
      editingInputs: QueryComplexJobListResponseBodyJobListJobInputsInputsEditingInputs,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryComplexJobListResponseBodyJobListJobInputs extends $tea.Model {
  inputs?: QueryComplexJobListResponseBodyJobListJobInputsInputs[];
  static names(): { [key: string]: string } {
    return {
      inputs: 'Inputs',
    };
  }

  static types(): { [key: string]: any } {
    return {
      inputs: { 'type': 'array', 'itemType': QueryComplexJobListResponseBodyJobListJobInputsInputs },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryComplexJobListResponseBodyJobListJob extends $tea.Model {
  creationTime?: string;
  percent?: number;
  finishTime?: string;
  state?: string;
  transcodeOutput?: QueryComplexJobListResponseBodyJobListJobTranscodeOutput;
  message?: string;
  MNSMessageResult?: QueryComplexJobListResponseBodyJobListJobMNSMessageResult;
  complexEditingConfigs?: QueryComplexJobListResponseBodyJobListJobComplexEditingConfigs;
  inputs?: QueryComplexJobListResponseBodyJobListJobInputs;
  jobId?: string;
  code?: string;
  pipelineId?: string;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      percent: 'Percent',
      finishTime: 'FinishTime',
      state: 'State',
      transcodeOutput: 'transcodeOutput',
      message: 'Message',
      MNSMessageResult: 'MNSMessageResult',
      complexEditingConfigs: 'ComplexEditingConfigs',
      inputs: 'Inputs',
      jobId: 'JobId',
      code: 'Code',
      pipelineId: 'PipelineId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      percent: 'number',
      finishTime: 'string',
      state: 'string',
      transcodeOutput: QueryComplexJobListResponseBodyJobListJobTranscodeOutput,
      message: 'string',
      MNSMessageResult: QueryComplexJobListResponseBodyJobListJobMNSMessageResult,
      complexEditingConfigs: QueryComplexJobListResponseBodyJobListJobComplexEditingConfigs,
      inputs: QueryComplexJobListResponseBodyJobListJobInputs,
      jobId: 'string',
      code: 'string',
      pipelineId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryComplexJobListResponseBodyJobList extends $tea.Model {
  job?: QueryComplexJobListResponseBodyJobListJob[];
  static names(): { [key: string]: string } {
    return {
      job: 'Job',
    };
  }

  static types(): { [key: string]: any } {
    return {
      job: { 'type': 'array', 'itemType': QueryComplexJobListResponseBodyJobListJob },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCoverJobListResponseBodyCoverJobListCoverJobCoverImageListCoverImage extends $tea.Model {
  time?: string;
  score?: string;
  url?: string;
  static names(): { [key: string]: string } {
    return {
      time: 'Time',
      score: 'Score',
      url: 'Url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      time: 'string',
      score: 'string',
      url: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCoverJobListResponseBodyCoverJobListCoverJobCoverImageList extends $tea.Model {
  coverImage?: QueryCoverJobListResponseBodyCoverJobListCoverJobCoverImageListCoverImage[];
  static names(): { [key: string]: string } {
    return {
      coverImage: 'CoverImage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      coverImage: { 'type': 'array', 'itemType': QueryCoverJobListResponseBodyCoverJobListCoverJobCoverImageListCoverImage },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCoverJobListResponseBodyCoverJobListCoverJobInput extends $tea.Model {
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCoverJobListResponseBodyCoverJobListCoverJobCoverConfigOutputFile extends $tea.Model {
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCoverJobListResponseBodyCoverJobListCoverJobCoverConfig extends $tea.Model {
  outputFile?: QueryCoverJobListResponseBodyCoverJobListCoverJobCoverConfigOutputFile;
  static names(): { [key: string]: string } {
    return {
      outputFile: 'OutputFile',
    };
  }

  static types(): { [key: string]: any } {
    return {
      outputFile: QueryCoverJobListResponseBodyCoverJobListCoverJobCoverConfigOutputFile,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCoverJobListResponseBodyCoverJobListCoverJob extends $tea.Model {
  creationTime?: string;
  state?: string;
  coverImageList?: QueryCoverJobListResponseBodyCoverJobListCoverJobCoverImageList;
  userData?: string;
  code?: string;
  message?: string;
  pipelineId?: string;
  input?: QueryCoverJobListResponseBodyCoverJobListCoverJobInput;
  id?: string;
  coverConfig?: QueryCoverJobListResponseBodyCoverJobListCoverJobCoverConfig;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      state: 'State',
      coverImageList: 'CoverImageList',
      userData: 'UserData',
      code: 'Code',
      message: 'Message',
      pipelineId: 'PipelineId',
      input: 'Input',
      id: 'Id',
      coverConfig: 'CoverConfig',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      state: 'string',
      coverImageList: QueryCoverJobListResponseBodyCoverJobListCoverJobCoverImageList,
      userData: 'string',
      code: 'string',
      message: 'string',
      pipelineId: 'string',
      input: QueryCoverJobListResponseBodyCoverJobListCoverJobInput,
      id: 'string',
      coverConfig: QueryCoverJobListResponseBodyCoverJobListCoverJobCoverConfig,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCoverJobListResponseBodyCoverJobList extends $tea.Model {
  coverJob?: QueryCoverJobListResponseBodyCoverJobListCoverJob[];
  static names(): { [key: string]: string } {
    return {
      coverJob: 'CoverJob',
    };
  }

  static types(): { [key: string]: any } {
    return {
      coverJob: { 'type': 'array', 'itemType': QueryCoverJobListResponseBodyCoverJobListCoverJob },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCoverJobListResponseBodyNonExistIds extends $tea.Model {
  string?: string[];
  static names(): { [key: string]: string } {
    return {
      string: 'String',
    };
  }

  static types(): { [key: string]: any } {
    return {
      string: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCoverPipelineListResponseBodyPipelineListPipelineNotifyConfig extends $tea.Model {
  topic?: string;
  queue?: string;
  static names(): { [key: string]: string } {
    return {
      topic: 'Topic',
      queue: 'Queue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      topic: 'string',
      queue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCoverPipelineListResponseBodyPipelineListPipeline extends $tea.Model {
  state?: string;
  notifyConfig?: QueryCoverPipelineListResponseBodyPipelineListPipelineNotifyConfig;
  priority?: string;
  role?: string;
  name?: string;
  id?: string;
  static names(): { [key: string]: string } {
    return {
      state: 'State',
      notifyConfig: 'NotifyConfig',
      priority: 'Priority',
      role: 'Role',
      name: 'Name',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      state: 'string',
      notifyConfig: QueryCoverPipelineListResponseBodyPipelineListPipelineNotifyConfig,
      priority: 'string',
      role: 'string',
      name: 'string',
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCoverPipelineListResponseBodyPipelineList extends $tea.Model {
  pipeline?: QueryCoverPipelineListResponseBodyPipelineListPipeline[];
  static names(): { [key: string]: string } {
    return {
      pipeline: 'Pipeline',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pipeline: { 'type': 'array', 'itemType': QueryCoverPipelineListResponseBodyPipelineListPipeline },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCoverPipelineListResponseBodyNonExistIds extends $tea.Model {
  string?: string[];
  static names(): { [key: string]: string } {
    return {
      string: 'String',
    };
  }

  static types(): { [key: string]: any } {
    return {
      string: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEditingJobListResponseBodyNonExistJobIds extends $tea.Model {
  string?: string[];
  static names(): { [key: string]: string } {
    return {
      string: 'String',
    };
  }

  static types(): { [key: string]: any } {
    return {
      string: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEditingJobListResponseBodyJobListJobEditingInputsEditingInputInputFile extends $tea.Model {
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEditingJobListResponseBodyJobListJobEditingInputsEditingInputInputConfig extends $tea.Model {
  isNormalSar?: string;
  deinterlaceMethod?: string;
  static names(): { [key: string]: string } {
    return {
      isNormalSar: 'IsNormalSar',
      deinterlaceMethod: 'DeinterlaceMethod',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isNormalSar: 'string',
      deinterlaceMethod: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEditingJobListResponseBodyJobListJobEditingInputsEditingInput extends $tea.Model {
  inputFile?: QueryEditingJobListResponseBodyJobListJobEditingInputsEditingInputInputFile;
  inputConfig?: QueryEditingJobListResponseBodyJobListJobEditingInputsEditingInputInputConfig;
  id?: string;
  static names(): { [key: string]: string } {
    return {
      inputFile: 'InputFile',
      inputConfig: 'InputConfig',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      inputFile: QueryEditingJobListResponseBodyJobListJobEditingInputsEditingInputInputFile,
      inputConfig: QueryEditingJobListResponseBodyJobListJobEditingInputsEditingInputInputConfig,
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEditingJobListResponseBodyJobListJobEditingInputs extends $tea.Model {
  editingInput?: QueryEditingJobListResponseBodyJobListJobEditingInputsEditingInput[];
  static names(): { [key: string]: string } {
    return {
      editingInput: 'EditingInput',
    };
  }

  static types(): { [key: string]: any } {
    return {
      editingInput: { 'type': 'array', 'itemType': QueryEditingJobListResponseBodyJobListJobEditingInputsEditingInput },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEditingJobListResponseBodyJobListJobEditingConfigVideoBitrateBnd extends $tea.Model {
  max?: string;
  min?: string;
  static names(): { [key: string]: string } {
    return {
      max: 'Max',
      min: 'Min',
    };
  }

  static types(): { [key: string]: any } {
    return {
      max: 'string',
      min: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEditingJobListResponseBodyJobListJobEditingConfigVideo extends $tea.Model {
  bufsize?: string;
  degrain?: string;
  bitrateBnd?: QueryEditingJobListResponseBodyJobListJobEditingConfigVideoBitrateBnd;
  pixFmt?: string;
  pad?: string;
  codec?: string;
  height?: string;
  qscale?: string;
  crop?: string;
  bitrate?: string;
  maxrate?: string;
  maxFps?: string;
  profile?: string;
  crf?: string;
  gop?: string;
  width?: string;
  fps?: string;
  preset?: string;
  scanMode?: string;
  static names(): { [key: string]: string } {
    return {
      bufsize: 'Bufsize',
      degrain: 'Degrain',
      bitrateBnd: 'BitrateBnd',
      pixFmt: 'PixFmt',
      pad: 'Pad',
      codec: 'Codec',
      height: 'Height',
      qscale: 'Qscale',
      crop: 'Crop',
      bitrate: 'Bitrate',
      maxrate: 'Maxrate',
      maxFps: 'MaxFps',
      profile: 'Profile',
      crf: 'Crf',
      gop: 'Gop',
      width: 'Width',
      fps: 'Fps',
      preset: 'Preset',
      scanMode: 'ScanMode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bufsize: 'string',
      degrain: 'string',
      bitrateBnd: QueryEditingJobListResponseBodyJobListJobEditingConfigVideoBitrateBnd,
      pixFmt: 'string',
      pad: 'string',
      codec: 'string',
      height: 'string',
      qscale: 'string',
      crop: 'string',
      bitrate: 'string',
      maxrate: 'string',
      maxFps: 'string',
      profile: 'string',
      crf: 'string',
      gop: 'string',
      width: 'string',
      fps: 'string',
      preset: 'string',
      scanMode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEditingJobListResponseBodyJobListJobEditingConfigTransConfig extends $tea.Model {
  isCheckAudioBitrate?: string;
  isCheckReso?: string;
  transMode?: string;
  isCheckVideoBitrateFail?: string;
  adjDarMethod?: string;
  duration?: string;
  isCheckVideoBitrate?: string;
  isCheckResoFail?: string;
  isCheckAudioBitrateFail?: string;
  static names(): { [key: string]: string } {
    return {
      isCheckAudioBitrate: 'IsCheckAudioBitrate',
      isCheckReso: 'IsCheckReso',
      transMode: 'TransMode',
      isCheckVideoBitrateFail: 'IsCheckVideoBitrateFail',
      adjDarMethod: 'AdjDarMethod',
      duration: 'Duration',
      isCheckVideoBitrate: 'IsCheckVideoBitrate',
      isCheckResoFail: 'IsCheckResoFail',
      isCheckAudioBitrateFail: 'IsCheckAudioBitrateFail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isCheckAudioBitrate: 'string',
      isCheckReso: 'string',
      transMode: 'string',
      isCheckVideoBitrateFail: 'string',
      adjDarMethod: 'string',
      duration: 'string',
      isCheckVideoBitrate: 'string',
      isCheckResoFail: 'string',
      isCheckAudioBitrateFail: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEditingJobListResponseBodyJobListJobEditingConfigEncryption extends $tea.Model {
  type?: string;
  key?: string;
  keyType?: string;
  id?: string;
  keyUri?: string;
  skipCnt?: string;
  static names(): { [key: string]: string } {
    return {
      type: 'Type',
      key: 'Key',
      keyType: 'KeyType',
      id: 'Id',
      keyUri: 'KeyUri',
      skipCnt: 'SkipCnt',
    };
  }

  static types(): { [key: string]: any } {
    return {
      type: 'string',
      key: 'string',
      keyType: 'string',
      id: 'string',
      keyUri: 'string',
      skipCnt: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEditingJobListResponseBodyJobListJobEditingConfigWaterMarkListWaterMarkInputFile extends $tea.Model {
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEditingJobListResponseBodyJobListJobEditingConfigWaterMarkListWaterMark extends $tea.Model {
  type?: string;
  referPos?: string;
  dx?: string;
  width?: string;
  height?: string;
  inputFile?: QueryEditingJobListResponseBodyJobListJobEditingConfigWaterMarkListWaterMarkInputFile;
  waterMarkTemplateId?: string;
  dy?: string;
  static names(): { [key: string]: string } {
    return {
      type: 'Type',
      referPos: 'ReferPos',
      dx: 'Dx',
      width: 'Width',
      height: 'Height',
      inputFile: 'InputFile',
      waterMarkTemplateId: 'WaterMarkTemplateId',
      dy: 'Dy',
    };
  }

  static types(): { [key: string]: any } {
    return {
      type: 'string',
      referPos: 'string',
      dx: 'string',
      width: 'string',
      height: 'string',
      inputFile: QueryEditingJobListResponseBodyJobListJobEditingConfigWaterMarkListWaterMarkInputFile,
      waterMarkTemplateId: 'string',
      dy: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEditingJobListResponseBodyJobListJobEditingConfigWaterMarkList extends $tea.Model {
  waterMark?: QueryEditingJobListResponseBodyJobListJobEditingConfigWaterMarkListWaterMark[];
  static names(): { [key: string]: string } {
    return {
      waterMark: 'WaterMark',
    };
  }

  static types(): { [key: string]: any } {
    return {
      waterMark: { 'type': 'array', 'itemType': QueryEditingJobListResponseBodyJobListJobEditingConfigWaterMarkListWaterMark },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEditingJobListResponseBodyJobListJobEditingConfigM3U8NonStandardSupportTS extends $tea.Model {
  sizeSupport?: boolean;
  md5Support?: boolean;
  static names(): { [key: string]: string } {
    return {
      sizeSupport: 'SizeSupport',
      md5Support: 'Md5Support',
    };
  }

  static types(): { [key: string]: any } {
    return {
      sizeSupport: 'boolean',
      md5Support: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEditingJobListResponseBodyJobListJobEditingConfigM3U8NonStandardSupport extends $tea.Model {
  TS?: QueryEditingJobListResponseBodyJobListJobEditingConfigM3U8NonStandardSupportTS;
  static names(): { [key: string]: string } {
    return {
      TS: 'TS',
    };
  }

  static types(): { [key: string]: any } {
    return {
      TS: QueryEditingJobListResponseBodyJobListJobEditingConfigM3U8NonStandardSupportTS,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEditingJobListResponseBodyJobListJobEditingConfigAudioVolume extends $tea.Model {
  method?: string;
  level?: string;
  static names(): { [key: string]: string } {
    return {
      method: 'Method',
      level: 'Level',
    };
  }

  static types(): { [key: string]: any } {
    return {
      method: 'string',
      level: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEditingJobListResponseBodyJobListJobEditingConfigAudio extends $tea.Model {
  profile?: string;
  codec?: string;
  samplerate?: string;
  qscale?: string;
  channels?: string;
  volume?: QueryEditingJobListResponseBodyJobListJobEditingConfigAudioVolume;
  bitrate?: string;
  static names(): { [key: string]: string } {
    return {
      profile: 'Profile',
      codec: 'Codec',
      samplerate: 'Samplerate',
      qscale: 'Qscale',
      channels: 'Channels',
      volume: 'Volume',
      bitrate: 'Bitrate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      profile: 'string',
      codec: 'string',
      samplerate: 'string',
      qscale: 'string',
      channels: 'string',
      volume: QueryEditingJobListResponseBodyJobListJobEditingConfigAudioVolume,
      bitrate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEditingJobListResponseBodyJobListJobEditingConfigMergeListMerge extends $tea.Model {
  start?: string;
  roleArn?: string;
  mergeURL?: string;
  duration?: string;
  static names(): { [key: string]: string } {
    return {
      start: 'Start',
      roleArn: 'RoleArn',
      mergeURL: 'MergeURL',
      duration: 'Duration',
    };
  }

  static types(): { [key: string]: any } {
    return {
      start: 'string',
      roleArn: 'string',
      mergeURL: 'string',
      duration: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEditingJobListResponseBodyJobListJobEditingConfigMergeList extends $tea.Model {
  merge?: QueryEditingJobListResponseBodyJobListJobEditingConfigMergeListMerge[];
  static names(): { [key: string]: string } {
    return {
      merge: 'Merge',
    };
  }

  static types(): { [key: string]: any } {
    return {
      merge: { 'type': 'array', 'itemType': QueryEditingJobListResponseBodyJobListJobEditingConfigMergeListMerge },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEditingJobListResponseBodyJobListJobEditingConfigSuperReso extends $tea.Model {
  isHalfSample?: string;
  static names(): { [key: string]: string } {
    return {
      isHalfSample: 'IsHalfSample',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isHalfSample: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEditingJobListResponseBodyJobListJobEditingConfigDigiWaterMarkInputFile extends $tea.Model {
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEditingJobListResponseBodyJobListJobEditingConfigDigiWaterMark extends $tea.Model {
  type?: string;
  alpha?: string;
  inputFile?: QueryEditingJobListResponseBodyJobListJobEditingConfigDigiWaterMarkInputFile;
  static names(): { [key: string]: string } {
    return {
      type: 'Type',
      alpha: 'Alpha',
      inputFile: 'InputFile',
    };
  }

  static types(): { [key: string]: any } {
    return {
      type: 'string',
      alpha: 'string',
      inputFile: QueryEditingJobListResponseBodyJobListJobEditingConfigDigiWaterMarkInputFile,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEditingJobListResponseBodyJobListJobEditingConfigOutputFile extends $tea.Model {
  roleArn?: string;
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      roleArn: 'RoleArn',
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      roleArn: 'string',
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfigClipsConfigVideo extends $tea.Model {
  t?: string;
  l?: string;
  static names(): { [key: string]: string } {
    return {
      t: 'T',
      l: 'L',
    };
  }

  static types(): { [key: string]: any } {
    return {
      t: 'string',
      l: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfig extends $tea.Model {
  clipsConfigVideo?: QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfigClipsConfigVideo;
  static names(): { [key: string]: string } {
    return {
      clipsConfigVideo: 'ClipsConfigVideo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clipsConfigVideo: QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfigClipsConfigVideo,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClipsClip extends $tea.Model {
  clipsConfig?: QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfig;
  out?: string;
  in?: string;
  clipID?: string;
  static names(): { [key: string]: string } {
    return {
      clipsConfig: 'ClipsConfig',
      out: 'Out',
      in: 'In',
      clipID: 'clipID',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clipsConfig: QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfig,
      out: 'string',
      in: 'string',
      clipID: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClips extends $tea.Model {
  clip?: QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClipsClip[];
  static names(): { [key: string]: string } {
    return {
      clip: 'Clip',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clip: { 'type': 'array', 'itemType': QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClipsClip },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrack extends $tea.Model {
  type?: string;
  order?: string;
  id?: string;
  clips?: QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClips;
  static names(): { [key: string]: string } {
    return {
      type: 'Type',
      order: 'Order',
      id: 'Id',
      clips: 'Clips',
    };
  }

  static types(): { [key: string]: any } {
    return {
      type: 'string',
      order: 'string',
      id: 'string',
      clips: QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClips,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackList extends $tea.Model {
  track?: QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrack[];
  static names(): { [key: string]: string } {
    return {
      track: 'Track',
    };
  }

  static types(): { [key: string]: any } {
    return {
      track: { 'type': 'array', 'itemType': QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrack },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTimelineConfigTimelineConfigAudio extends $tea.Model {
  channelLayout?: string;
  samplerate?: string;
  channels?: string;
  static names(): { [key: string]: string } {
    return {
      channelLayout: 'ChannelLayout',
      samplerate: 'Samplerate',
      channels: 'Channels',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelLayout: 'string',
      samplerate: 'string',
      channels: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTimelineConfigTimelineConfigVideo extends $tea.Model {
  bgColor?: string;
  width?: string;
  renderRatio?: string;
  isGpuData?: string;
  height?: string;
  isOneTrackData?: string;
  fps?: string;
  reclosePrec?: string;
  static names(): { [key: string]: string } {
    return {
      bgColor: 'BgColor',
      width: 'Width',
      renderRatio: 'RenderRatio',
      isGpuData: 'IsGpuData',
      height: 'Height',
      isOneTrackData: 'IsOneTrackData',
      fps: 'Fps',
      reclosePrec: 'ReclosePrec',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bgColor: 'string',
      width: 'string',
      renderRatio: 'string',
      isGpuData: 'string',
      height: 'string',
      isOneTrackData: 'string',
      fps: 'string',
      reclosePrec: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTimelineConfig extends $tea.Model {
  timelineConfigAudio?: QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTimelineConfigTimelineConfigAudio;
  timelineConfigVideo?: QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTimelineConfigTimelineConfigVideo;
  static names(): { [key: string]: string } {
    return {
      timelineConfigAudio: 'TimelineConfigAudio',
      timelineConfigVideo: 'TimelineConfigVideo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      timelineConfigAudio: QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTimelineConfigTimelineConfigAudio,
      timelineConfigVideo: QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTimelineConfigTimelineConfigVideo,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimeline extends $tea.Model {
  trackList?: QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackList;
  timelineConfig?: QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTimelineConfig;
  static names(): { [key: string]: string } {
    return {
      trackList: 'TrackList',
      timelineConfig: 'TimelineConfig',
    };
  }

  static types(): { [key: string]: any } {
    return {
      trackList: QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackList,
      timelineConfig: QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTimelineConfig,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipListClipEffectsEffect extends $tea.Model {
  effect?: string;
  effectConfig?: string;
  static names(): { [key: string]: string } {
    return {
      effect: 'Effect',
      effectConfig: 'EffectConfig',
    };
  }

  static types(): { [key: string]: any } {
    return {
      effect: 'string',
      effectConfig: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipListClipEffects extends $tea.Model {
  effect?: QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipListClipEffectsEffect[];
  static names(): { [key: string]: string } {
    return {
      effect: 'Effect',
    };
  }

  static types(): { [key: string]: any } {
    return {
      effect: { 'type': 'array', 'itemType': QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipListClipEffectsEffect },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipListClip extends $tea.Model {
  type?: string;
  sourceID?: string;
  effects?: QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipListClipEffects;
  sourceType?: string;
  sourceStrmMap?: string;
  out?: string;
  in?: string;
  id?: string;
  static names(): { [key: string]: string } {
    return {
      type: 'Type',
      sourceID: 'SourceID',
      effects: 'Effects',
      sourceType: 'SourceType',
      sourceStrmMap: 'SourceStrmMap',
      out: 'Out',
      in: 'In',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      type: 'string',
      sourceID: 'string',
      effects: QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipListClipEffects,
      sourceType: 'string',
      sourceStrmMap: 'string',
      out: 'string',
      in: 'string',
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipList extends $tea.Model {
  clip?: QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipListClip[];
  static names(): { [key: string]: string } {
    return {
      clip: 'Clip',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clip: { 'type': 'array', 'itemType': QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipListClip },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEditingJobListResponseBodyJobListJobEditingConfigEditing extends $tea.Model {
  timeline?: QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimeline;
  clipList?: QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipList;
  static names(): { [key: string]: string } {
    return {
      timeline: 'Timeline',
      clipList: 'ClipList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      timeline: QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimeline,
      clipList: QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEditingJobListResponseBodyJobListJobEditingConfigContainer extends $tea.Model {
  format?: string;
  static names(): { [key: string]: string } {
    return {
      format: 'Format',
    };
  }

  static types(): { [key: string]: any } {
    return {
      format: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEditingJobListResponseBodyJobListJobEditingConfigClipTimeSpan extends $tea.Model {
  seek?: string;
  duration?: string;
  static names(): { [key: string]: string } {
    return {
      seek: 'Seek',
      duration: 'Duration',
    };
  }

  static types(): { [key: string]: any } {
    return {
      seek: 'string',
      duration: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEditingJobListResponseBodyJobListJobEditingConfigClip extends $tea.Model {
  timeSpan?: QueryEditingJobListResponseBodyJobListJobEditingConfigClipTimeSpan;
  static names(): { [key: string]: string } {
    return {
      timeSpan: 'TimeSpan',
    };
  }

  static types(): { [key: string]: any } {
    return {
      timeSpan: QueryEditingJobListResponseBodyJobListJobEditingConfigClipTimeSpan,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEditingJobListResponseBodyJobListJobEditingConfigMuxConfigGif extends $tea.Model {
  finalDelay?: string;
  ditherMode?: string;
  loop?: string;
  isCustomPalette?: string;
  static names(): { [key: string]: string } {
    return {
      finalDelay: 'FinalDelay',
      ditherMode: 'DitherMode',
      loop: 'Loop',
      isCustomPalette: 'IsCustomPalette',
    };
  }

  static types(): { [key: string]: any } {
    return {
      finalDelay: 'string',
      ditherMode: 'string',
      loop: 'string',
      isCustomPalette: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEditingJobListResponseBodyJobListJobEditingConfigMuxConfigSegment extends $tea.Model {
  duration?: string;
  static names(): { [key: string]: string } {
    return {
      duration: 'Duration',
    };
  }

  static types(): { [key: string]: any } {
    return {
      duration: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEditingJobListResponseBodyJobListJobEditingConfigMuxConfig extends $tea.Model {
  gif?: QueryEditingJobListResponseBodyJobListJobEditingConfigMuxConfigGif;
  segment?: QueryEditingJobListResponseBodyJobListJobEditingConfigMuxConfigSegment;
  static names(): { [key: string]: string } {
    return {
      gif: 'Gif',
      segment: 'Segment',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gif: QueryEditingJobListResponseBodyJobListJobEditingConfigMuxConfigGif,
      segment: QueryEditingJobListResponseBodyJobListJobEditingConfigMuxConfigSegment,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitleInput extends $tea.Model {
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitle extends $tea.Model {
  charEnc?: string;
  fontName?: string;
  input?: QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitleInput;
  static names(): { [key: string]: string } {
    return {
      charEnc: 'CharEnc',
      fontName: 'FontName',
      input: 'Input',
    };
  }

  static types(): { [key: string]: any } {
    return {
      charEnc: 'string',
      fontName: 'string',
      input: QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitleInput,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigExtSubtitleList extends $tea.Model {
  extSubtitle?: QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitle[];
  static names(): { [key: string]: string } {
    return {
      extSubtitle: 'ExtSubtitle',
    };
  }

  static types(): { [key: string]: any } {
    return {
      extSubtitle: { 'type': 'array', 'itemType': QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitle },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigSubtitleListSubtitle extends $tea.Model {
  map?: string;
  static names(): { [key: string]: string } {
    return {
      map: 'Map',
    };
  }

  static types(): { [key: string]: any } {
    return {
      map: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigSubtitleList extends $tea.Model {
  subtitle?: QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigSubtitleListSubtitle[];
  static names(): { [key: string]: string } {
    return {
      subtitle: 'Subtitle',
    };
  }

  static types(): { [key: string]: any } {
    return {
      subtitle: { 'type': 'array', 'itemType': QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigSubtitleListSubtitle },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfig extends $tea.Model {
  extSubtitleList?: QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigExtSubtitleList;
  subtitleList?: QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigSubtitleList;
  static names(): { [key: string]: string } {
    return {
      extSubtitleList: 'ExtSubtitleList',
      subtitleList: 'SubtitleList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      extSubtitleList: QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigExtSubtitleList,
      subtitleList: QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigSubtitleList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsVideoStreamListVideoStreamNetworkCost extends $tea.Model {
  preloadTime?: string;
  avgBitrate?: string;
  costBandwidth?: string;
  static names(): { [key: string]: string } {
    return {
      preloadTime: 'PreloadTime',
      avgBitrate: 'AvgBitrate',
      costBandwidth: 'CostBandwidth',
    };
  }

  static types(): { [key: string]: any } {
    return {
      preloadTime: 'string',
      avgBitrate: 'string',
      costBandwidth: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsVideoStreamListVideoStream extends $tea.Model {
  index?: string;
  timebase?: string;
  avgFPS?: string;
  pixFmt?: string;
  sar?: string;
  lang?: string;
  codecLongName?: string;
  height?: string;
  numFrames?: string;
  bitrate?: string;
  codecTagString?: string;
  hasBFrames?: string;
  profile?: string;
  startTime?: string;
  networkCost?: QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsVideoStreamListVideoStreamNetworkCost;
  dar?: string;
  codecName?: string;
  width?: string;
  duration?: string;
  fps?: string;
  codecTag?: string;
  codecTimeBase?: string;
  level?: string;
  static names(): { [key: string]: string } {
    return {
      index: 'Index',
      timebase: 'Timebase',
      avgFPS: 'AvgFPS',
      pixFmt: 'PixFmt',
      sar: 'Sar',
      lang: 'Lang',
      codecLongName: 'CodecLongName',
      height: 'Height',
      numFrames: 'NumFrames',
      bitrate: 'Bitrate',
      codecTagString: 'CodecTagString',
      hasBFrames: 'HasBFrames',
      profile: 'Profile',
      startTime: 'StartTime',
      networkCost: 'NetworkCost',
      dar: 'Dar',
      codecName: 'CodecName',
      width: 'Width',
      duration: 'Duration',
      fps: 'Fps',
      codecTag: 'CodecTag',
      codecTimeBase: 'CodecTimeBase',
      level: 'Level',
    };
  }

  static types(): { [key: string]: any } {
    return {
      index: 'string',
      timebase: 'string',
      avgFPS: 'string',
      pixFmt: 'string',
      sar: 'string',
      lang: 'string',
      codecLongName: 'string',
      height: 'string',
      numFrames: 'string',
      bitrate: 'string',
      codecTagString: 'string',
      hasBFrames: 'string',
      profile: 'string',
      startTime: 'string',
      networkCost: QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsVideoStreamListVideoStreamNetworkCost,
      dar: 'string',
      codecName: 'string',
      width: 'string',
      duration: 'string',
      fps: 'string',
      codecTag: 'string',
      codecTimeBase: 'string',
      level: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsVideoStreamList extends $tea.Model {
  videoStream?: QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsVideoStreamListVideoStream[];
  static names(): { [key: string]: string } {
    return {
      videoStream: 'VideoStream',
    };
  }

  static types(): { [key: string]: any } {
    return {
      videoStream: { 'type': 'array', 'itemType': QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsVideoStreamListVideoStream },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsAudioStreamListAudioStream extends $tea.Model {
  timebase?: string;
  index?: string;
  sampleFmt?: string;
  channelLayout?: string;
  lang?: string;
  samplerate?: string;
  codecLongName?: string;
  channels?: string;
  numFrames?: string;
  bitrate?: string;
  codecTagString?: string;
  startTime?: string;
  codecName?: string;
  duration?: string;
  codecTag?: string;
  codecTimeBase?: string;
  static names(): { [key: string]: string } {
    return {
      timebase: 'Timebase',
      index: 'Index',
      sampleFmt: 'SampleFmt',
      channelLayout: 'ChannelLayout',
      lang: 'Lang',
      samplerate: 'Samplerate',
      codecLongName: 'CodecLongName',
      channels: 'Channels',
      numFrames: 'NumFrames',
      bitrate: 'Bitrate',
      codecTagString: 'CodecTagString',
      startTime: 'StartTime',
      codecName: 'CodecName',
      duration: 'Duration',
      codecTag: 'CodecTag',
      codecTimeBase: 'CodecTimeBase',
    };
  }

  static types(): { [key: string]: any } {
    return {
      timebase: 'string',
      index: 'string',
      sampleFmt: 'string',
      channelLayout: 'string',
      lang: 'string',
      samplerate: 'string',
      codecLongName: 'string',
      channels: 'string',
      numFrames: 'string',
      bitrate: 'string',
      codecTagString: 'string',
      startTime: 'string',
      codecName: 'string',
      duration: 'string',
      codecTag: 'string',
      codecTimeBase: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsAudioStreamList extends $tea.Model {
  audioStream?: QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsAudioStreamListAudioStream[];
  static names(): { [key: string]: string } {
    return {
      audioStream: 'AudioStream',
    };
  }

  static types(): { [key: string]: any } {
    return {
      audioStream: { 'type': 'array', 'itemType': QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsAudioStreamListAudioStream },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsSubtitleStreamListSubtitleStream extends $tea.Model {
  index?: string;
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      index: 'Index',
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      index: 'string',
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsSubtitleStreamList extends $tea.Model {
  subtitleStream?: QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsSubtitleStreamListSubtitleStream[];
  static names(): { [key: string]: string } {
    return {
      subtitleStream: 'SubtitleStream',
    };
  }

  static types(): { [key: string]: any } {
    return {
      subtitleStream: { 'type': 'array', 'itemType': QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsSubtitleStreamListSubtitleStream },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreams extends $tea.Model {
  videoStreamList?: QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsVideoStreamList;
  audioStreamList?: QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsAudioStreamList;
  subtitleStreamList?: QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsSubtitleStreamList;
  static names(): { [key: string]: string } {
    return {
      videoStreamList: 'VideoStreamList',
      audioStreamList: 'AudioStreamList',
      subtitleStreamList: 'SubtitleStreamList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      videoStreamList: QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsVideoStreamList,
      audioStreamList: QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsAudioStreamList,
      subtitleStreamList: QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsSubtitleStreamList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesFormat extends $tea.Model {
  startTime?: string;
  numPrograms?: string;
  size?: string;
  numStreams?: string;
  formatLongName?: string;
  duration?: string;
  bitrate?: string;
  formatName?: string;
  static names(): { [key: string]: string } {
    return {
      startTime: 'StartTime',
      numPrograms: 'NumPrograms',
      size: 'Size',
      numStreams: 'NumStreams',
      formatLongName: 'FormatLongName',
      duration: 'Duration',
      bitrate: 'Bitrate',
      formatName: 'FormatName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      startTime: 'string',
      numPrograms: 'string',
      size: 'string',
      numStreams: 'string',
      formatLongName: 'string',
      duration: 'string',
      bitrate: 'string',
      formatName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEditingJobListResponseBodyJobListJobEditingConfigProperties extends $tea.Model {
  width?: string;
  height?: string;
  duration?: string;
  fps?: string;
  bitrate?: string;
  fileFormat?: string;
  streams?: QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreams;
  format?: QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesFormat;
  fileSize?: string;
  static names(): { [key: string]: string } {
    return {
      width: 'Width',
      height: 'Height',
      duration: 'Duration',
      fps: 'Fps',
      bitrate: 'Bitrate',
      fileFormat: 'FileFormat',
      streams: 'Streams',
      format: 'Format',
      fileSize: 'FileSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      width: 'string',
      height: 'string',
      duration: 'string',
      fps: 'string',
      bitrate: 'string',
      fileFormat: 'string',
      streams: QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreams,
      format: QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesFormat,
      fileSize: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEditingJobListResponseBodyJobListJobEditingConfig extends $tea.Model {
  video?: QueryEditingJobListResponseBodyJobListJobEditingConfigVideo;
  transConfig?: QueryEditingJobListResponseBodyJobListJobEditingConfigTransConfig;
  encryption?: QueryEditingJobListResponseBodyJobListJobEditingConfigEncryption;
  waterMarkList?: QueryEditingJobListResponseBodyJobListJobEditingConfigWaterMarkList;
  deWatermark?: string;
  waterMarkConfigUrl?: string;
  m3U8NonStandardSupport?: QueryEditingJobListResponseBodyJobListJobEditingConfigM3U8NonStandardSupport;
  priority?: string;
  audio?: QueryEditingJobListResponseBodyJobListJobEditingConfigAudio;
  audioStreamMap?: string;
  mergeList?: QueryEditingJobListResponseBodyJobListJobEditingConfigMergeList;
  superReso?: QueryEditingJobListResponseBodyJobListJobEditingConfigSuperReso;
  userData?: string;
  digiWaterMark?: QueryEditingJobListResponseBodyJobListJobEditingConfigDigiWaterMark;
  videoStreamMap?: string;
  outputFile?: QueryEditingJobListResponseBodyJobListJobEditingConfigOutputFile;
  rotate?: string;
  editing?: QueryEditingJobListResponseBodyJobListJobEditingConfigEditing;
  container?: QueryEditingJobListResponseBodyJobListJobEditingConfigContainer;
  clip?: QueryEditingJobListResponseBodyJobListJobEditingConfigClip;
  mergeConfigUrl?: string;
  muxConfig?: QueryEditingJobListResponseBodyJobListJobEditingConfigMuxConfig;
  templateId?: string;
  subtitleConfig?: QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfig;
  properties?: QueryEditingJobListResponseBodyJobListJobEditingConfigProperties;
  static names(): { [key: string]: string } {
    return {
      video: 'Video',
      transConfig: 'TransConfig',
      encryption: 'Encryption',
      waterMarkList: 'WaterMarkList',
      deWatermark: 'DeWatermark',
      waterMarkConfigUrl: 'WaterMarkConfigUrl',
      m3U8NonStandardSupport: 'M3U8NonStandardSupport',
      priority: 'Priority',
      audio: 'Audio',
      audioStreamMap: 'AudioStreamMap',
      mergeList: 'MergeList',
      superReso: 'SuperReso',
      userData: 'UserData',
      digiWaterMark: 'DigiWaterMark',
      videoStreamMap: 'VideoStreamMap',
      outputFile: 'OutputFile',
      rotate: 'Rotate',
      editing: 'Editing',
      container: 'Container',
      clip: 'Clip',
      mergeConfigUrl: 'MergeConfigUrl',
      muxConfig: 'MuxConfig',
      templateId: 'TemplateId',
      subtitleConfig: 'SubtitleConfig',
      properties: 'Properties',
    };
  }

  static types(): { [key: string]: any } {
    return {
      video: QueryEditingJobListResponseBodyJobListJobEditingConfigVideo,
      transConfig: QueryEditingJobListResponseBodyJobListJobEditingConfigTransConfig,
      encryption: QueryEditingJobListResponseBodyJobListJobEditingConfigEncryption,
      waterMarkList: QueryEditingJobListResponseBodyJobListJobEditingConfigWaterMarkList,
      deWatermark: 'string',
      waterMarkConfigUrl: 'string',
      m3U8NonStandardSupport: QueryEditingJobListResponseBodyJobListJobEditingConfigM3U8NonStandardSupport,
      priority: 'string',
      audio: QueryEditingJobListResponseBodyJobListJobEditingConfigAudio,
      audioStreamMap: 'string',
      mergeList: QueryEditingJobListResponseBodyJobListJobEditingConfigMergeList,
      superReso: QueryEditingJobListResponseBodyJobListJobEditingConfigSuperReso,
      userData: 'string',
      digiWaterMark: QueryEditingJobListResponseBodyJobListJobEditingConfigDigiWaterMark,
      videoStreamMap: 'string',
      outputFile: QueryEditingJobListResponseBodyJobListJobEditingConfigOutputFile,
      rotate: 'string',
      editing: QueryEditingJobListResponseBodyJobListJobEditingConfigEditing,
      container: QueryEditingJobListResponseBodyJobListJobEditingConfigContainer,
      clip: QueryEditingJobListResponseBodyJobListJobEditingConfigClip,
      mergeConfigUrl: 'string',
      muxConfig: QueryEditingJobListResponseBodyJobListJobEditingConfigMuxConfig,
      templateId: 'string',
      subtitleConfig: QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfig,
      properties: QueryEditingJobListResponseBodyJobListJobEditingConfigProperties,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEditingJobListResponseBodyJobListJobMNSMessageResult extends $tea.Model {
  messageId?: string;
  errorMessage?: string;
  errorCode?: string;
  static names(): { [key: string]: string } {
    return {
      messageId: 'MessageId',
      errorMessage: 'ErrorMessage',
      errorCode: 'ErrorCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      messageId: 'string',
      errorMessage: 'string',
      errorCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEditingJobListResponseBodyJobListJob extends $tea.Model {
  creationTime?: string;
  percent?: number;
  finishTime?: string;
  state?: string;
  jobId?: string;
  code?: string;
  message?: string;
  editingInputs?: QueryEditingJobListResponseBodyJobListJobEditingInputs;
  pipelineId?: string;
  editingConfig?: QueryEditingJobListResponseBodyJobListJobEditingConfig;
  MNSMessageResult?: QueryEditingJobListResponseBodyJobListJobMNSMessageResult;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      percent: 'Percent',
      finishTime: 'FinishTime',
      state: 'State',
      jobId: 'JobId',
      code: 'Code',
      message: 'Message',
      editingInputs: 'EditingInputs',
      pipelineId: 'PipelineId',
      editingConfig: 'EditingConfig',
      MNSMessageResult: 'MNSMessageResult',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      percent: 'number',
      finishTime: 'string',
      state: 'string',
      jobId: 'string',
      code: 'string',
      message: 'string',
      editingInputs: QueryEditingJobListResponseBodyJobListJobEditingInputs,
      pipelineId: 'string',
      editingConfig: QueryEditingJobListResponseBodyJobListJobEditingConfig,
      MNSMessageResult: QueryEditingJobListResponseBodyJobListJobMNSMessageResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEditingJobListResponseBodyJobList extends $tea.Model {
  job?: QueryEditingJobListResponseBodyJobListJob[];
  static names(): { [key: string]: string } {
    return {
      job: 'Job',
    };
  }

  static types(): { [key: string]: any } {
    return {
      job: { 'type': 'array', 'itemType': QueryEditingJobListResponseBodyJobListJob },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryFacerecogJobListResponseBodyNonExistIds extends $tea.Model {
  string?: string[];
  static names(): { [key: string]: string } {
    return {
      string: 'String',
    };
  }

  static types(): { [key: string]: any } {
    return {
      string: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryFacerecogJobListResponseBodyFacerecogJobListFacerecogJobVideoFacerecogResultFacerecogsFacerecogFacesFace extends $tea.Model {
  score?: string;
  name?: string;
  target?: string;
  static names(): { [key: string]: string } {
    return {
      score: 'Score',
      name: 'Name',
      target: 'Target',
    };
  }

  static types(): { [key: string]: any } {
    return {
      score: 'string',
      name: 'string',
      target: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryFacerecogJobListResponseBodyFacerecogJobListFacerecogJobVideoFacerecogResultFacerecogsFacerecogFaces extends $tea.Model {
  face?: QueryFacerecogJobListResponseBodyFacerecogJobListFacerecogJobVideoFacerecogResultFacerecogsFacerecogFacesFace[];
  static names(): { [key: string]: string } {
    return {
      face: 'Face',
    };
  }

  static types(): { [key: string]: any } {
    return {
      face: { 'type': 'array', 'itemType': QueryFacerecogJobListResponseBodyFacerecogJobListFacerecogJobVideoFacerecogResultFacerecogsFacerecogFacesFace },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryFacerecogJobListResponseBodyFacerecogJobListFacerecogJobVideoFacerecogResultFacerecogsFacerecog extends $tea.Model {
  time?: string;
  faces?: QueryFacerecogJobListResponseBodyFacerecogJobListFacerecogJobVideoFacerecogResultFacerecogsFacerecogFaces;
  static names(): { [key: string]: string } {
    return {
      time: 'Time',
      faces: 'Faces',
    };
  }

  static types(): { [key: string]: any } {
    return {
      time: 'string',
      faces: QueryFacerecogJobListResponseBodyFacerecogJobListFacerecogJobVideoFacerecogResultFacerecogsFacerecogFaces,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryFacerecogJobListResponseBodyFacerecogJobListFacerecogJobVideoFacerecogResultFacerecogs extends $tea.Model {
  facerecog?: QueryFacerecogJobListResponseBodyFacerecogJobListFacerecogJobVideoFacerecogResultFacerecogsFacerecog[];
  static names(): { [key: string]: string } {
    return {
      facerecog: 'Facerecog',
    };
  }

  static types(): { [key: string]: any } {
    return {
      facerecog: { 'type': 'array', 'itemType': QueryFacerecogJobListResponseBodyFacerecogJobListFacerecogJobVideoFacerecogResultFacerecogsFacerecog },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryFacerecogJobListResponseBodyFacerecogJobListFacerecogJobVideoFacerecogResult extends $tea.Model {
  facerecogs?: QueryFacerecogJobListResponseBodyFacerecogJobListFacerecogJobVideoFacerecogResultFacerecogs;
  static names(): { [key: string]: string } {
    return {
      facerecogs: 'Facerecogs',
    };
  }

  static types(): { [key: string]: any } {
    return {
      facerecogs: QueryFacerecogJobListResponseBodyFacerecogJobListFacerecogJobVideoFacerecogResultFacerecogs,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryFacerecogJobListResponseBodyFacerecogJobListFacerecogJobInput extends $tea.Model {
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryFacerecogJobListResponseBodyFacerecogJobListFacerecogJob extends $tea.Model {
  creationTime?: string;
  videoFacerecogResult?: QueryFacerecogJobListResponseBodyFacerecogJobListFacerecogJobVideoFacerecogResult;
  state?: string;
  userData?: string;
  code?: string;
  message?: string;
  pipelineId?: string;
  input?: QueryFacerecogJobListResponseBodyFacerecogJobListFacerecogJobInput;
  id?: string;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      videoFacerecogResult: 'VideoFacerecogResult',
      state: 'State',
      userData: 'UserData',
      code: 'Code',
      message: 'Message',
      pipelineId: 'PipelineId',
      input: 'Input',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      videoFacerecogResult: QueryFacerecogJobListResponseBodyFacerecogJobListFacerecogJobVideoFacerecogResult,
      state: 'string',
      userData: 'string',
      code: 'string',
      message: 'string',
      pipelineId: 'string',
      input: QueryFacerecogJobListResponseBodyFacerecogJobListFacerecogJobInput,
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryFacerecogJobListResponseBodyFacerecogJobList extends $tea.Model {
  facerecogJob?: QueryFacerecogJobListResponseBodyFacerecogJobListFacerecogJob[];
  static names(): { [key: string]: string } {
    return {
      facerecogJob: 'FacerecogJob',
    };
  }

  static types(): { [key: string]: any } {
    return {
      facerecogJob: { 'type': 'array', 'itemType': QueryFacerecogJobListResponseBodyFacerecogJobListFacerecogJob },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobMasterFile extends $tea.Model {
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobQueryFile extends $tea.Model {
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobMatchFrameStorageMasterMediaFrames extends $tea.Model {
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobMatchFrameStorageMatchedFramesDescFile extends $tea.Model {
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobMatchFrameStorageQueryMediaFrames extends $tea.Model {
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobMatchFrameStorage extends $tea.Model {
  masterMediaFrames?: QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobMatchFrameStorageMasterMediaFrames;
  matchedFramesDescFile?: QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobMatchFrameStorageMatchedFramesDescFile;
  queryMediaFrames?: QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobMatchFrameStorageQueryMediaFrames;
  static names(): { [key: string]: string } {
    return {
      masterMediaFrames: 'MasterMediaFrames',
      matchedFramesDescFile: 'MatchedFramesDescFile',
      queryMediaFrames: 'QueryMediaFrames',
    };
  }

  static types(): { [key: string]: any } {
    return {
      masterMediaFrames: QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobMatchFrameStorageMasterMediaFrames,
      matchedFramesDescFile: QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobMatchFrameStorageMatchedFramesDescFile,
      queryMediaFrames: QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobMatchFrameStorageQueryMediaFrames,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobFpCompareResultMediaMatchSegmentsMediaMatchSegment extends $tea.Model {
  queryStartTime?: string;
  queryEndFrame?: string;
  score?: string;
  totalMatchFrameNum?: string;
  masterEndTime?: string;
  masterStartTime?: string;
  queryStartFrame?: string;
  masterEndFrame?: string;
  masterStartFrame?: string;
  queryEndTime?: string;
  static names(): { [key: string]: string } {
    return {
      queryStartTime: 'QueryStartTime',
      queryEndFrame: 'QueryEndFrame',
      score: 'Score',
      totalMatchFrameNum: 'TotalMatchFrameNum',
      masterEndTime: 'MasterEndTime',
      masterStartTime: 'MasterStartTime',
      queryStartFrame: 'QueryStartFrame',
      masterEndFrame: 'MasterEndFrame',
      masterStartFrame: 'MasterStartFrame',
      queryEndTime: 'QueryEndTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      queryStartTime: 'string',
      queryEndFrame: 'string',
      score: 'string',
      totalMatchFrameNum: 'string',
      masterEndTime: 'string',
      masterStartTime: 'string',
      queryStartFrame: 'string',
      masterEndFrame: 'string',
      masterStartFrame: 'string',
      queryEndTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobFpCompareResultMediaMatchSegments extends $tea.Model {
  mediaMatchSegment?: QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobFpCompareResultMediaMatchSegmentsMediaMatchSegment[];
  static names(): { [key: string]: string } {
    return {
      mediaMatchSegment: 'MediaMatchSegment',
    };
  }

  static types(): { [key: string]: any } {
    return {
      mediaMatchSegment: { 'type': 'array', 'itemType': QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobFpCompareResultMediaMatchSegmentsMediaMatchSegment },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobFpCompareResultQueryMediaInfo extends $tea.Model {
  audioSampleRate?: string;
  audioBitRate?: string;
  fpNum?: string;
  width?: string;
  height?: string;
  totalVideoFrame?: string;
  fps?: string;
  duration?: string;
  audioChannels?: string;
  static names(): { [key: string]: string } {
    return {
      audioSampleRate: 'AudioSampleRate',
      audioBitRate: 'AudioBitRate',
      fpNum: 'FpNum',
      width: 'Width',
      height: 'Height',
      totalVideoFrame: 'TotalVideoFrame',
      fps: 'Fps',
      duration: 'Duration',
      audioChannels: 'AudioChannels',
    };
  }

  static types(): { [key: string]: any } {
    return {
      audioSampleRate: 'string',
      audioBitRate: 'string',
      fpNum: 'string',
      width: 'string',
      height: 'string',
      totalVideoFrame: 'string',
      fps: 'string',
      duration: 'string',
      audioChannels: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobFpCompareResultMasterMediaInfo extends $tea.Model {
  audioSampleRate?: string;
  audioBitRate?: string;
  fpNum?: string;
  width?: string;
  height?: string;
  totalVideoFrame?: string;
  fps?: string;
  duration?: string;
  audioChannels?: string;
  static names(): { [key: string]: string } {
    return {
      audioSampleRate: 'AudioSampleRate',
      audioBitRate: 'AudioBitRate',
      fpNum: 'FpNum',
      width: 'Width',
      height: 'Height',
      totalVideoFrame: 'TotalVideoFrame',
      fps: 'Fps',
      duration: 'Duration',
      audioChannels: 'AudioChannels',
    };
  }

  static types(): { [key: string]: any } {
    return {
      audioSampleRate: 'string',
      audioBitRate: 'string',
      fpNum: 'string',
      width: 'string',
      height: 'string',
      totalVideoFrame: 'string',
      fps: 'string',
      duration: 'string',
      audioChannels: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobFpCompareResult extends $tea.Model {
  mediaMatchSegments?: QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobFpCompareResultMediaMatchSegments;
  queryMediaInfo?: QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobFpCompareResultQueryMediaInfo;
  masterMediaInfo?: QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobFpCompareResultMasterMediaInfo;
  static names(): { [key: string]: string } {
    return {
      mediaMatchSegments: 'MediaMatchSegments',
      queryMediaInfo: 'QueryMediaInfo',
      masterMediaInfo: 'MasterMediaInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      mediaMatchSegments: QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobFpCompareResultMediaMatchSegments,
      queryMediaInfo: QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobFpCompareResultQueryMediaInfo,
      masterMediaInfo: QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobFpCompareResultMasterMediaInfo,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJob extends $tea.Model {
  masterFile?: QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobMasterFile;
  creationTime?: string;
  finishTime?: string;
  state?: string;
  message?: string;
  queryFile?: QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobQueryFile;
  fpDBId?: string;
  userData?: string;
  code?: string;
  matchFrameStorage?: QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobMatchFrameStorage;
  pipelineId?: string;
  id?: string;
  fpCompareResult?: QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobFpCompareResult;
  static names(): { [key: string]: string } {
    return {
      masterFile: 'MasterFile',
      creationTime: 'CreationTime',
      finishTime: 'FinishTime',
      state: 'State',
      message: 'Message',
      queryFile: 'QueryFile',
      fpDBId: 'FpDBId',
      userData: 'UserData',
      code: 'Code',
      matchFrameStorage: 'MatchFrameStorage',
      pipelineId: 'PipelineId',
      id: 'Id',
      fpCompareResult: 'FpCompareResult',
    };
  }

  static types(): { [key: string]: any } {
    return {
      masterFile: QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobMasterFile,
      creationTime: 'string',
      finishTime: 'string',
      state: 'string',
      message: 'string',
      queryFile: QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobQueryFile,
      fpDBId: 'string',
      userData: 'string',
      code: 'string',
      matchFrameStorage: QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobMatchFrameStorage,
      pipelineId: 'string',
      id: 'string',
      fpCompareResult: QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJobFpCompareResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryFpCompareJobListResponseBodyFpCompareJobList extends $tea.Model {
  fpCompareJob?: QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJob[];
  static names(): { [key: string]: string } {
    return {
      fpCompareJob: 'FpCompareJob',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fpCompareJob: { 'type': 'array', 'itemType': QueryFpCompareJobListResponseBodyFpCompareJobListFpCompareJob },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryFpCompareJobListResponseBodyNonExistIds extends $tea.Model {
  string?: string[];
  static names(): { [key: string]: string } {
    return {
      string: 'String',
    };
  }

  static types(): { [key: string]: any } {
    return {
      string: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryFpDBDeleteJobListResponseBodyFpDBDeleteJobListFpDBDeleteJob extends $tea.Model {
  creationTime?: string;
  status?: string;
  finishTime?: string;
  delType?: string;
  userData?: string;
  code?: string;
  message?: string;
  pipelineId?: string;
  fpDBId?: string;
  id?: string;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      status: 'Status',
      finishTime: 'FinishTime',
      delType: 'DelType',
      userData: 'UserData',
      code: 'Code',
      message: 'Message',
      pipelineId: 'PipelineId',
      fpDBId: 'FpDBId',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      status: 'string',
      finishTime: 'string',
      delType: 'string',
      userData: 'string',
      code: 'string',
      message: 'string',
      pipelineId: 'string',
      fpDBId: 'string',
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryFpDBDeleteJobListResponseBodyFpDBDeleteJobList extends $tea.Model {
  fpDBDeleteJob?: QueryFpDBDeleteJobListResponseBodyFpDBDeleteJobListFpDBDeleteJob[];
  static names(): { [key: string]: string } {
    return {
      fpDBDeleteJob: 'FpDBDeleteJob',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fpDBDeleteJob: { 'type': 'array', 'itemType': QueryFpDBDeleteJobListResponseBodyFpDBDeleteJobListFpDBDeleteJob },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryFpDBDeleteJobListResponseBodyNonExistIds extends $tea.Model {
  string?: string[];
  static names(): { [key: string]: string } {
    return {
      string: 'String',
    };
  }

  static types(): { [key: string]: any } {
    return {
      string: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryFpFileDeleteJobListResponseBodyFpFileDeleteJobListFpFileDeleteJob extends $tea.Model {
  creationTime?: string;
  status?: string;
  finishTime?: string;
  userData?: string;
  code?: string;
  message?: string;
  pipelineId?: string;
  fpDBId?: string;
  id?: string;
  fileIds?: string;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      status: 'Status',
      finishTime: 'FinishTime',
      userData: 'UserData',
      code: 'Code',
      message: 'Message',
      pipelineId: 'PipelineId',
      fpDBId: 'FpDBId',
      id: 'Id',
      fileIds: 'FileIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      status: 'string',
      finishTime: 'string',
      userData: 'string',
      code: 'string',
      message: 'string',
      pipelineId: 'string',
      fpDBId: 'string',
      id: 'string',
      fileIds: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryFpFileDeleteJobListResponseBodyFpFileDeleteJobList extends $tea.Model {
  fpFileDeleteJob?: QueryFpFileDeleteJobListResponseBodyFpFileDeleteJobListFpFileDeleteJob[];
  static names(): { [key: string]: string } {
    return {
      fpFileDeleteJob: 'FpFileDeleteJob',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fpFileDeleteJob: { 'type': 'array', 'itemType': QueryFpFileDeleteJobListResponseBodyFpFileDeleteJobListFpFileDeleteJob },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryFpFileDeleteJobListResponseBodyNonExistIds extends $tea.Model {
  string?: string[];
  static names(): { [key: string]: string } {
    return {
      string: 'String',
    };
  }

  static types(): { [key: string]: any } {
    return {
      string: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryFpImportResultResponseBodyPageInfo extends $tea.Model {
  pageIndex?: number;
  pageSize?: number;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      pageIndex: 'PageIndex',
      pageSize: 'PageSize',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageIndex: 'number',
      pageSize: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryFpImportResultResponseBodyFpResultLogInfoListFpResultLogInfo extends $tea.Model {
  logStartTime?: number;
  logPath?: string;
  createTime?: number;
  logSize?: number;
  logName?: string;
  logEndTime?: number;
  static names(): { [key: string]: string } {
    return {
      logStartTime: 'LogStartTime',
      logPath: 'LogPath',
      createTime: 'CreateTime',
      logSize: 'LogSize',
      logName: 'LogName',
      logEndTime: 'LogEndTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      logStartTime: 'number',
      logPath: 'string',
      createTime: 'number',
      logSize: 'number',
      logName: 'string',
      logEndTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryFpImportResultResponseBodyFpResultLogInfoList extends $tea.Model {
  fpResultLogInfo?: QueryFpImportResultResponseBodyFpResultLogInfoListFpResultLogInfo[];
  static names(): { [key: string]: string } {
    return {
      fpResultLogInfo: 'FpResultLogInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fpResultLogInfo: { 'type': 'array', 'itemType': QueryFpImportResultResponseBodyFpResultLogInfoListFpResultLogInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryFpShotJobListResponseBodyNonExistPrimaryKeys extends $tea.Model {
  string?: string[];
  static names(): { [key: string]: string } {
    return {
      string: 'String',
    };
  }

  static types(): { [key: string]: any } {
    return {
      string: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlicesFpShotSliceDuplication extends $tea.Model {
  start?: string;
  duration?: string;
  static names(): { [key: string]: string } {
    return {
      start: 'Start',
      duration: 'Duration',
    };
  }

  static types(): { [key: string]: any } {
    return {
      start: 'string',
      duration: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlicesFpShotSliceInput extends $tea.Model {
  start?: string;
  duration?: string;
  static names(): { [key: string]: string } {
    return {
      start: 'Start',
      duration: 'Duration',
    };
  }

  static types(): { [key: string]: any } {
    return {
      start: 'string',
      duration: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlicesFpShotSlice extends $tea.Model {
  duplication?: QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlicesFpShotSliceDuplication;
  similarity?: string;
  input?: QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlicesFpShotSliceInput;
  static names(): { [key: string]: string } {
    return {
      duplication: 'Duplication',
      similarity: 'Similarity',
      input: 'Input',
    };
  }

  static types(): { [key: string]: any } {
    return {
      duplication: QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlicesFpShotSliceDuplication,
      similarity: 'string',
      input: QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlicesFpShotSliceInput,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlices extends $tea.Model {
  fpShotSlice?: QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlicesFpShotSlice[];
  static names(): { [key: string]: string } {
    return {
      fpShotSlice: 'FpShotSlice',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fpShotSlice: { 'type': 'array', 'itemType': QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlicesFpShotSlice },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShot extends $tea.Model {
  primaryKey?: string;
  fpShotSlices?: QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlices;
  similarity?: string;
  static names(): { [key: string]: string } {
    return {
      primaryKey: 'PrimaryKey',
      fpShotSlices: 'FpShotSlices',
      similarity: 'Similarity',
    };
  }

  static types(): { [key: string]: any } {
    return {
      primaryKey: 'string',
      fpShotSlices: QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShotFpShotSlices,
      similarity: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShots extends $tea.Model {
  fpShot?: QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShot[];
  static names(): { [key: string]: string } {
    return {
      fpShot: 'FpShot',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fpShot: { 'type': 'array', 'itemType': QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShotsFpShot },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlicesFpShotSliceDuplication extends $tea.Model {
  start?: string;
  duration?: string;
  static names(): { [key: string]: string } {
    return {
      start: 'Start',
      duration: 'Duration',
    };
  }

  static types(): { [key: string]: any } {
    return {
      start: 'string',
      duration: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlicesFpShotSliceInput extends $tea.Model {
  start?: string;
  duration?: string;
  static names(): { [key: string]: string } {
    return {
      start: 'Start',
      duration: 'Duration',
    };
  }

  static types(): { [key: string]: any } {
    return {
      start: 'string',
      duration: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlicesFpShotSlice extends $tea.Model {
  duplication?: QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlicesFpShotSliceDuplication;
  similarity?: string;
  input?: QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlicesFpShotSliceInput;
  static names(): { [key: string]: string } {
    return {
      duplication: 'Duplication',
      similarity: 'Similarity',
      input: 'Input',
    };
  }

  static types(): { [key: string]: any } {
    return {
      duplication: QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlicesFpShotSliceDuplication,
      similarity: 'string',
      input: QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlicesFpShotSliceInput,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlices extends $tea.Model {
  fpShotSlice?: QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlicesFpShotSlice[];
  static names(): { [key: string]: string } {
    return {
      fpShotSlice: 'FpShotSlice',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fpShotSlice: { 'type': 'array', 'itemType': QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlicesFpShotSlice },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShot extends $tea.Model {
  primaryKey?: string;
  fpShotSlices?: QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlices;
  similarity?: string;
  static names(): { [key: string]: string } {
    return {
      primaryKey: 'PrimaryKey',
      fpShotSlices: 'FpShotSlices',
      similarity: 'Similarity',
    };
  }

  static types(): { [key: string]: any } {
    return {
      primaryKey: 'string',
      fpShotSlices: QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShotFpShotSlices,
      similarity: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShots extends $tea.Model {
  fpShot?: QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShot[];
  static names(): { [key: string]: string } {
    return {
      fpShot: 'FpShot',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fpShot: { 'type': 'array', 'itemType': QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShotsFpShot },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResult extends $tea.Model {
  audioFpShots?: QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShots;
  fpShots?: QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShots;
  static names(): { [key: string]: string } {
    return {
      audioFpShots: 'AudioFpShots',
      fpShots: 'FpShots',
    };
  }

  static types(): { [key: string]: any } {
    return {
      audioFpShots: QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultAudioFpShots,
      fpShots: QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResultFpShots,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotConfig extends $tea.Model {
  primaryKey?: string;
  saveType?: string;
  notary?: string;
  fpDBId?: string;
  static names(): { [key: string]: string } {
    return {
      primaryKey: 'PrimaryKey',
      saveType: 'SaveType',
      notary: 'Notary',
      fpDBId: 'FpDBId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      primaryKey: 'string',
      saveType: 'string',
      notary: 'string',
      fpDBId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryFpShotJobListResponseBodyFpShotJobListFpShotJobInputFile extends $tea.Model {
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryFpShotJobListResponseBodyFpShotJobListFpShotJob extends $tea.Model {
  fpShotResult?: QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResult;
  creationTime?: string;
  finishTime?: string;
  state?: string;
  message?: string;
  txHash?: string;
  transactionId?: string;
  fpShotConfig?: QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotConfig;
  fileId?: string;
  userData?: string;
  code?: string;
  inputFile?: QueryFpShotJobListResponseBodyFpShotJobListFpShotJobInputFile;
  pipelineId?: string;
  id?: string;
  static names(): { [key: string]: string } {
    return {
      fpShotResult: 'FpShotResult',
      creationTime: 'CreationTime',
      finishTime: 'FinishTime',
      state: 'State',
      message: 'Message',
      txHash: 'TxHash',
      transactionId: 'TransactionId',
      fpShotConfig: 'FpShotConfig',
      fileId: 'FileId',
      userData: 'UserData',
      code: 'Code',
      inputFile: 'InputFile',
      pipelineId: 'PipelineId',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fpShotResult: QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotResult,
      creationTime: 'string',
      finishTime: 'string',
      state: 'string',
      message: 'string',
      txHash: 'string',
      transactionId: 'string',
      fpShotConfig: QueryFpShotJobListResponseBodyFpShotJobListFpShotJobFpShotConfig,
      fileId: 'string',
      userData: 'string',
      code: 'string',
      inputFile: QueryFpShotJobListResponseBodyFpShotJobListFpShotJobInputFile,
      pipelineId: 'string',
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryFpShotJobListResponseBodyFpShotJobList extends $tea.Model {
  fpShotJob?: QueryFpShotJobListResponseBodyFpShotJobListFpShotJob[];
  static names(): { [key: string]: string } {
    return {
      fpShotJob: 'FpShotJob',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fpShotJob: { 'type': 'array', 'itemType': QueryFpShotJobListResponseBodyFpShotJobListFpShotJob },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryFpShotJobListResponseBodyNonExistIds extends $tea.Model {
  string?: string[];
  static names(): { [key: string]: string } {
    return {
      string: 'String',
    };
  }

  static types(): { [key: string]: any } {
    return {
      string: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryImageSearchJobListResponseBodyImageSearchJobListImageSearchJobResultImageSearchShotsImageSearchShots extends $tea.Model {
  matchedFrame?: string;
  matchedTimestamp?: string;
  similarity?: string;
  static names(): { [key: string]: string } {
    return {
      matchedFrame: 'MatchedFrame',
      matchedTimestamp: 'MatchedTimestamp',
      similarity: 'Similarity',
    };
  }

  static types(): { [key: string]: any } {
    return {
      matchedFrame: 'string',
      matchedTimestamp: 'string',
      similarity: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryImageSearchJobListResponseBodyImageSearchJobListImageSearchJobResultImageSearchShots extends $tea.Model {
  imageSearchShots?: QueryImageSearchJobListResponseBodyImageSearchJobListImageSearchJobResultImageSearchShotsImageSearchShots[];
  static names(): { [key: string]: string } {
    return {
      imageSearchShots: 'ImageSearchShots',
    };
  }

  static types(): { [key: string]: any } {
    return {
      imageSearchShots: { 'type': 'array', 'itemType': QueryImageSearchJobListResponseBodyImageSearchJobListImageSearchJobResultImageSearchShotsImageSearchShots },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryImageSearchJobListResponseBodyImageSearchJobListImageSearchJobResult extends $tea.Model {
  imageSearchShots?: QueryImageSearchJobListResponseBodyImageSearchJobListImageSearchJobResultImageSearchShots;
  static names(): { [key: string]: string } {
    return {
      imageSearchShots: 'ImageSearchShots',
    };
  }

  static types(): { [key: string]: any } {
    return {
      imageSearchShots: QueryImageSearchJobListResponseBodyImageSearchJobListImageSearchJobResultImageSearchShots,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryImageSearchJobListResponseBodyImageSearchJobListImageSearchJobInputImage extends $tea.Model {
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryImageSearchJobListResponseBodyImageSearchJobListImageSearchJobInputVideo extends $tea.Model {
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryImageSearchJobListResponseBodyImageSearchJobListImageSearchJob extends $tea.Model {
  creationTime?: string;
  finishTime?: string;
  result?: QueryImageSearchJobListResponseBodyImageSearchJobListImageSearchJobResult;
  state?: string;
  userData?: string;
  code?: string;
  message?: string;
  pipelineId?: string;
  inputImage?: QueryImageSearchJobListResponseBodyImageSearchJobListImageSearchJobInputImage;
  id?: string;
  inputVideo?: QueryImageSearchJobListResponseBodyImageSearchJobListImageSearchJobInputVideo;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      finishTime: 'FinishTime',
      result: 'Result',
      state: 'State',
      userData: 'UserData',
      code: 'Code',
      message: 'Message',
      pipelineId: 'PipelineId',
      inputImage: 'inputImage',
      id: 'Id',
      inputVideo: 'InputVideo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      finishTime: 'string',
      result: QueryImageSearchJobListResponseBodyImageSearchJobListImageSearchJobResult,
      state: 'string',
      userData: 'string',
      code: 'string',
      message: 'string',
      pipelineId: 'string',
      inputImage: QueryImageSearchJobListResponseBodyImageSearchJobListImageSearchJobInputImage,
      id: 'string',
      inputVideo: QueryImageSearchJobListResponseBodyImageSearchJobListImageSearchJobInputVideo,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryImageSearchJobListResponseBodyImageSearchJobList extends $tea.Model {
  imageSearchJob?: QueryImageSearchJobListResponseBodyImageSearchJobListImageSearchJob[];
  static names(): { [key: string]: string } {
    return {
      imageSearchJob: 'ImageSearchJob',
    };
  }

  static types(): { [key: string]: any } {
    return {
      imageSearchJob: { 'type': 'array', 'itemType': QueryImageSearchJobListResponseBodyImageSearchJobListImageSearchJob },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryImageSearchJobListResponseBodyNonExistIds extends $tea.Model {
  string?: string[];
  static names(): { [key: string]: string } {
    return {
      string: 'String',
    };
  }

  static types(): { [key: string]: any } {
    return {
      string: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryInnerJobResponseBodyVideo extends $tea.Model {
  index?: number;
  result?: number;
  code?: string;
  static names(): { [key: string]: string } {
    return {
      index: 'Index',
      result: 'Result',
      code: 'Code',
    };
  }

  static types(): { [key: string]: any } {
    return {
      index: 'number',
      result: 'number',
      code: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryInnerJobResponseBodyImageResult extends $tea.Model {
  index?: number;
  result?: number;
  code?: string;
  static names(): { [key: string]: string } {
    return {
      index: 'Index',
      result: 'Result',
      code: 'Code',
    };
  }

  static types(): { [key: string]: any } {
    return {
      index: 'number',
      result: 'number',
      code: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryInnerJobResponseBodyImage extends $tea.Model {
  result?: QueryInnerJobResponseBodyImageResult[];
  static names(): { [key: string]: string } {
    return {
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      result: { 'type': 'array', 'itemType': QueryInnerJobResponseBodyImageResult },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryIProductionJobListResponseBodyJobs extends $tea.Model {
  string?: string[];
  static names(): { [key: string]: string } {
    return {
      string: 'String',
    };
  }

  static types(): { [key: string]: any } {
    return {
      string: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryIProductionJobListResponseBodyNonExistIds extends $tea.Model {
  string?: string[];
  static names(): { [key: string]: string } {
    return {
      string: 'String',
    };
  }

  static types(): { [key: string]: any } {
    return {
      string: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobListResponseBodyNonExistJobIds extends $tea.Model {
  string?: string[];
  static names(): { [key: string]: string } {
    return {
      string: 'String',
    };
  }

  static types(): { [key: string]: any } {
    return {
      string: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobListResponseBodyJobListJobOutputVideoBitrateBnd extends $tea.Model {
  max?: string;
  min?: string;
  static names(): { [key: string]: string } {
    return {
      max: 'Max',
      min: 'Min',
    };
  }

  static types(): { [key: string]: any } {
    return {
      max: 'string',
      min: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobListResponseBodyJobListJobOutputVideo extends $tea.Model {
  bufsize?: string;
  degrain?: string;
  bitrateBnd?: QueryJobListResponseBodyJobListJobOutputVideoBitrateBnd;
  pixFmt?: string;
  pad?: string;
  codec?: string;
  height?: string;
  qscale?: string;
  crop?: string;
  bitrate?: string;
  maxrate?: string;
  maxFps?: string;
  profile?: string;
  crf?: string;
  gop?: string;
  width?: string;
  fps?: string;
  preset?: string;
  scanMode?: string;
  resoPriority?: string;
  static names(): { [key: string]: string } {
    return {
      bufsize: 'Bufsize',
      degrain: 'Degrain',
      bitrateBnd: 'BitrateBnd',
      pixFmt: 'PixFmt',
      pad: 'Pad',
      codec: 'Codec',
      height: 'Height',
      qscale: 'Qscale',
      crop: 'Crop',
      bitrate: 'Bitrate',
      maxrate: 'Maxrate',
      maxFps: 'MaxFps',
      profile: 'Profile',
      crf: 'Crf',
      gop: 'Gop',
      width: 'Width',
      fps: 'Fps',
      preset: 'Preset',
      scanMode: 'ScanMode',
      resoPriority: 'ResoPriority',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bufsize: 'string',
      degrain: 'string',
      bitrateBnd: QueryJobListResponseBodyJobListJobOutputVideoBitrateBnd,
      pixFmt: 'string',
      pad: 'string',
      codec: 'string',
      height: 'string',
      qscale: 'string',
      crop: 'string',
      bitrate: 'string',
      maxrate: 'string',
      maxFps: 'string',
      profile: 'string',
      crf: 'string',
      gop: 'string',
      width: 'string',
      fps: 'string',
      preset: 'string',
      scanMode: 'string',
      resoPriority: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobListResponseBodyJobListJobOutputTransConfig extends $tea.Model {
  isCheckAudioBitrate?: string;
  transMode?: string;
  isCheckReso?: string;
  isCheckVideoBitrateFail?: string;
  adjDarMethod?: string;
  isCheckVideoBitrate?: string;
  isCheckResoFail?: string;
  isCheckAudioBitrateFail?: string;
  static names(): { [key: string]: string } {
    return {
      isCheckAudioBitrate: 'IsCheckAudioBitrate',
      transMode: 'TransMode',
      isCheckReso: 'IsCheckReso',
      isCheckVideoBitrateFail: 'IsCheckVideoBitrateFail',
      adjDarMethod: 'AdjDarMethod',
      isCheckVideoBitrate: 'IsCheckVideoBitrate',
      isCheckResoFail: 'IsCheckResoFail',
      isCheckAudioBitrateFail: 'IsCheckAudioBitrateFail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isCheckAudioBitrate: 'string',
      transMode: 'string',
      isCheckReso: 'string',
      isCheckVideoBitrateFail: 'string',
      adjDarMethod: 'string',
      isCheckVideoBitrate: 'string',
      isCheckResoFail: 'string',
      isCheckAudioBitrateFail: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobListResponseBodyJobListJobOutputEncryption extends $tea.Model {
  type?: string;
  key?: string;
  keyType?: string;
  id?: string;
  keyUri?: string;
  skipCnt?: string;
  static names(): { [key: string]: string } {
    return {
      type: 'Type',
      key: 'Key',
      keyType: 'KeyType',
      id: 'Id',
      keyUri: 'KeyUri',
      skipCnt: 'SkipCnt',
    };
  }

  static types(): { [key: string]: any } {
    return {
      type: 'string',
      key: 'string',
      keyType: 'string',
      id: 'string',
      keyUri: 'string',
      skipCnt: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobListResponseBodyJobListJobOutputWaterMarkListWaterMarkInputFile extends $tea.Model {
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobListResponseBodyJobListJobOutputWaterMarkListWaterMark extends $tea.Model {
  type?: string;
  referPos?: string;
  dx?: string;
  width?: string;
  height?: string;
  inputFile?: QueryJobListResponseBodyJobListJobOutputWaterMarkListWaterMarkInputFile;
  waterMarkTemplateId?: string;
  dy?: string;
  static names(): { [key: string]: string } {
    return {
      type: 'Type',
      referPos: 'ReferPos',
      dx: 'Dx',
      width: 'Width',
      height: 'Height',
      inputFile: 'InputFile',
      waterMarkTemplateId: 'WaterMarkTemplateId',
      dy: 'Dy',
    };
  }

  static types(): { [key: string]: any } {
    return {
      type: 'string',
      referPos: 'string',
      dx: 'string',
      width: 'string',
      height: 'string',
      inputFile: QueryJobListResponseBodyJobListJobOutputWaterMarkListWaterMarkInputFile,
      waterMarkTemplateId: 'string',
      dy: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobListResponseBodyJobListJobOutputWaterMarkList extends $tea.Model {
  waterMark?: QueryJobListResponseBodyJobListJobOutputWaterMarkListWaterMark[];
  static names(): { [key: string]: string } {
    return {
      waterMark: 'WaterMark',
    };
  }

  static types(): { [key: string]: any } {
    return {
      waterMark: { 'type': 'array', 'itemType': QueryJobListResponseBodyJobListJobOutputWaterMarkListWaterMark },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobListResponseBodyJobListJobOutputM3U8NonStandardSupportTS extends $tea.Model {
  sizeSupport?: boolean;
  md5Support?: boolean;
  static names(): { [key: string]: string } {
    return {
      sizeSupport: 'SizeSupport',
      md5Support: 'Md5Support',
    };
  }

  static types(): { [key: string]: any } {
    return {
      sizeSupport: 'boolean',
      md5Support: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobListResponseBodyJobListJobOutputM3U8NonStandardSupport extends $tea.Model {
  TS?: QueryJobListResponseBodyJobListJobOutputM3U8NonStandardSupportTS;
  static names(): { [key: string]: string } {
    return {
      TS: 'TS',
    };
  }

  static types(): { [key: string]: any } {
    return {
      TS: QueryJobListResponseBodyJobListJobOutputM3U8NonStandardSupportTS,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobListResponseBodyJobListJobOutputAudioVolume extends $tea.Model {
  method?: string;
  level?: string;
  static names(): { [key: string]: string } {
    return {
      method: 'Method',
      level: 'Level',
    };
  }

  static types(): { [key: string]: any } {
    return {
      method: 'string',
      level: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobListResponseBodyJobListJobOutputAudio extends $tea.Model {
  profile?: string;
  codec?: string;
  samplerate?: string;
  qscale?: string;
  channels?: string;
  volume?: QueryJobListResponseBodyJobListJobOutputAudioVolume;
  bitrate?: string;
  static names(): { [key: string]: string } {
    return {
      profile: 'Profile',
      codec: 'Codec',
      samplerate: 'Samplerate',
      qscale: 'Qscale',
      channels: 'Channels',
      volume: 'Volume',
      bitrate: 'Bitrate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      profile: 'string',
      codec: 'string',
      samplerate: 'string',
      qscale: 'string',
      channels: 'string',
      volume: QueryJobListResponseBodyJobListJobOutputAudioVolume,
      bitrate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobListResponseBodyJobListJobOutputMergeListMerge extends $tea.Model {
  start?: string;
  roleArn?: string;
  mergeURL?: string;
  duration?: string;
  static names(): { [key: string]: string } {
    return {
      start: 'Start',
      roleArn: 'RoleArn',
      mergeURL: 'MergeURL',
      duration: 'Duration',
    };
  }

  static types(): { [key: string]: any } {
    return {
      start: 'string',
      roleArn: 'string',
      mergeURL: 'string',
      duration: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobListResponseBodyJobListJobOutputMergeList extends $tea.Model {
  merge?: QueryJobListResponseBodyJobListJobOutputMergeListMerge[];
  static names(): { [key: string]: string } {
    return {
      merge: 'Merge',
    };
  }

  static types(): { [key: string]: any } {
    return {
      merge: { 'type': 'array', 'itemType': QueryJobListResponseBodyJobListJobOutputMergeListMerge },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobListResponseBodyJobListJobOutputSuperReso extends $tea.Model {
  isHalfSample?: string;
  static names(): { [key: string]: string } {
    return {
      isHalfSample: 'IsHalfSample',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isHalfSample: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobListResponseBodyJobListJobOutputOutSubtitleListOutSubtitleOutSubtitleFile extends $tea.Model {
  roleArn?: string;
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      roleArn: 'RoleArn',
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      roleArn: 'string',
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobListResponseBodyJobListJobOutputOutSubtitleListOutSubtitle extends $tea.Model {
  map?: string;
  outSubtitleFile?: QueryJobListResponseBodyJobListJobOutputOutSubtitleListOutSubtitleOutSubtitleFile;
  success?: boolean;
  message?: string;
  static names(): { [key: string]: string } {
    return {
      map: 'Map',
      outSubtitleFile: 'OutSubtitleFile',
      success: 'Success',
      message: 'Message',
    };
  }

  static types(): { [key: string]: any } {
    return {
      map: 'string',
      outSubtitleFile: QueryJobListResponseBodyJobListJobOutputOutSubtitleListOutSubtitleOutSubtitleFile,
      success: 'boolean',
      message: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobListResponseBodyJobListJobOutputOutSubtitleList extends $tea.Model {
  outSubtitle?: QueryJobListResponseBodyJobListJobOutputOutSubtitleListOutSubtitle[];
  static names(): { [key: string]: string } {
    return {
      outSubtitle: 'OutSubtitle',
    };
  }

  static types(): { [key: string]: any } {
    return {
      outSubtitle: { 'type': 'array', 'itemType': QueryJobListResponseBodyJobListJobOutputOutSubtitleListOutSubtitle },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobListResponseBodyJobListJobOutputOutputFile extends $tea.Model {
  roleArn?: string;
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      roleArn: 'RoleArn',
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      roleArn: 'string',
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobListResponseBodyJobListJobOutputContainer extends $tea.Model {
  format?: string;
  static names(): { [key: string]: string } {
    return {
      format: 'Format',
    };
  }

  static types(): { [key: string]: any } {
    return {
      format: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobListResponseBodyJobListJobOutputClipTimeSpan extends $tea.Model {
  seek?: string;
  duration?: string;
  static names(): { [key: string]: string } {
    return {
      seek: 'Seek',
      duration: 'Duration',
    };
  }

  static types(): { [key: string]: any } {
    return {
      seek: 'string',
      duration: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobListResponseBodyJobListJobOutputClip extends $tea.Model {
  timeSpan?: QueryJobListResponseBodyJobListJobOutputClipTimeSpan;
  static names(): { [key: string]: string } {
    return {
      timeSpan: 'TimeSpan',
    };
  }

  static types(): { [key: string]: any } {
    return {
      timeSpan: QueryJobListResponseBodyJobListJobOutputClipTimeSpan,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobListResponseBodyJobListJobOutputOpeningListOpening extends $tea.Model {
  openUrl?: string;
  start?: string;
  width?: string;
  height?: string;
  static names(): { [key: string]: string } {
    return {
      openUrl: 'openUrl',
      start: 'Start',
      width: 'Width',
      height: 'Height',
    };
  }

  static types(): { [key: string]: any } {
    return {
      openUrl: 'string',
      start: 'string',
      width: 'string',
      height: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobListResponseBodyJobListJobOutputOpeningList extends $tea.Model {
  opening?: QueryJobListResponseBodyJobListJobOutputOpeningListOpening[];
  static names(): { [key: string]: string } {
    return {
      opening: 'Opening',
    };
  }

  static types(): { [key: string]: any } {
    return {
      opening: { 'type': 'array', 'itemType': QueryJobListResponseBodyJobListJobOutputOpeningListOpening },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobListResponseBodyJobListJobOutputMuxConfigWebp extends $tea.Model {
  loop?: string;
  static names(): { [key: string]: string } {
    return {
      loop: 'Loop',
    };
  }

  static types(): { [key: string]: any } {
    return {
      loop: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobListResponseBodyJobListJobOutputMuxConfigGif extends $tea.Model {
  finalDelay?: string;
  ditherMode?: string;
  loop?: string;
  isCustomPalette?: string;
  static names(): { [key: string]: string } {
    return {
      finalDelay: 'FinalDelay',
      ditherMode: 'DitherMode',
      loop: 'Loop',
      isCustomPalette: 'IsCustomPalette',
    };
  }

  static types(): { [key: string]: any } {
    return {
      finalDelay: 'string',
      ditherMode: 'string',
      loop: 'string',
      isCustomPalette: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobListResponseBodyJobListJobOutputMuxConfigSegment extends $tea.Model {
  duration?: string;
  static names(): { [key: string]: string } {
    return {
      duration: 'Duration',
    };
  }

  static types(): { [key: string]: any } {
    return {
      duration: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobListResponseBodyJobListJobOutputMuxConfig extends $tea.Model {
  webp?: QueryJobListResponseBodyJobListJobOutputMuxConfigWebp;
  gif?: QueryJobListResponseBodyJobListJobOutputMuxConfigGif;
  segment?: QueryJobListResponseBodyJobListJobOutputMuxConfigSegment;
  static names(): { [key: string]: string } {
    return {
      webp: 'Webp',
      gif: 'Gif',
      segment: 'Segment',
    };
  }

  static types(): { [key: string]: any } {
    return {
      webp: QueryJobListResponseBodyJobListJobOutputMuxConfigWebp,
      gif: QueryJobListResponseBodyJobListJobOutputMuxConfigGif,
      segment: QueryJobListResponseBodyJobListJobOutputMuxConfigSegment,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobListResponseBodyJobListJobOutputTailSlateListTailSlate extends $tea.Model {
  start?: string;
  bgColor?: string;
  isMergeAudio?: boolean;
  width?: string;
  height?: string;
  blendDuration?: string;
  tailUrl?: string;
  static names(): { [key: string]: string } {
    return {
      start: 'Start',
      bgColor: 'BgColor',
      isMergeAudio: 'IsMergeAudio',
      width: 'Width',
      height: 'Height',
      blendDuration: 'BlendDuration',
      tailUrl: 'TailUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      start: 'string',
      bgColor: 'string',
      isMergeAudio: 'boolean',
      width: 'string',
      height: 'string',
      blendDuration: 'string',
      tailUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobListResponseBodyJobListJobOutputTailSlateList extends $tea.Model {
  tailSlate?: QueryJobListResponseBodyJobListJobOutputTailSlateListTailSlate[];
  static names(): { [key: string]: string } {
    return {
      tailSlate: 'TailSlate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tailSlate: { 'type': 'array', 'itemType': QueryJobListResponseBodyJobListJobOutputTailSlateListTailSlate },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput extends $tea.Model {
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitle extends $tea.Model {
  charEnc?: string;
  fontName?: string;
  input?: QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput;
  static names(): { [key: string]: string } {
    return {
      charEnc: 'CharEnc',
      fontName: 'FontName',
      input: 'Input',
    };
  }

  static types(): { [key: string]: any } {
    return {
      charEnc: 'string',
      fontName: 'string',
      input: QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleList extends $tea.Model {
  extSubtitle?: QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitle[];
  static names(): { [key: string]: string } {
    return {
      extSubtitle: 'ExtSubtitle',
    };
  }

  static types(): { [key: string]: any } {
    return {
      extSubtitle: { 'type': 'array', 'itemType': QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitle },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobListResponseBodyJobListJobOutputSubtitleConfigSubtitleListSubtitle extends $tea.Model {
  map?: string;
  static names(): { [key: string]: string } {
    return {
      map: 'Map',
    };
  }

  static types(): { [key: string]: any } {
    return {
      map: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobListResponseBodyJobListJobOutputSubtitleConfigSubtitleList extends $tea.Model {
  subtitle?: QueryJobListResponseBodyJobListJobOutputSubtitleConfigSubtitleListSubtitle[];
  static names(): { [key: string]: string } {
    return {
      subtitle: 'Subtitle',
    };
  }

  static types(): { [key: string]: any } {
    return {
      subtitle: { 'type': 'array', 'itemType': QueryJobListResponseBodyJobListJobOutputSubtitleConfigSubtitleListSubtitle },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobListResponseBodyJobListJobOutputSubtitleConfig extends $tea.Model {
  extSubtitleList?: QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleList;
  subtitleList?: QueryJobListResponseBodyJobListJobOutputSubtitleConfigSubtitleList;
  static names(): { [key: string]: string } {
    return {
      extSubtitleList: 'ExtSubtitleList',
      subtitleList: 'SubtitleList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      extSubtitleList: QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleList,
      subtitleList: QueryJobListResponseBodyJobListJobOutputSubtitleConfigSubtitleList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobListResponseBodyJobListJobOutputPropertiesSourceLogosSourceLogo extends $tea.Model {
  source?: string;
  static names(): { [key: string]: string } {
    return {
      source: 'Source',
    };
  }

  static types(): { [key: string]: any } {
    return {
      source: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobListResponseBodyJobListJobOutputPropertiesSourceLogos extends $tea.Model {
  sourceLogo?: QueryJobListResponseBodyJobListJobOutputPropertiesSourceLogosSourceLogo[];
  static names(): { [key: string]: string } {
    return {
      sourceLogo: 'SourceLogo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      sourceLogo: { 'type': 'array', 'itemType': QueryJobListResponseBodyJobListJobOutputPropertiesSourceLogosSourceLogo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost extends $tea.Model {
  preloadTime?: string;
  avgBitrate?: string;
  costBandwidth?: string;
  static names(): { [key: string]: string } {
    return {
      preloadTime: 'PreloadTime',
      avgBitrate: 'AvgBitrate',
      costBandwidth: 'CostBandwidth',
    };
  }

  static types(): { [key: string]: any } {
    return {
      preloadTime: 'string',
      avgBitrate: 'string',
      costBandwidth: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStream extends $tea.Model {
  index?: string;
  timebase?: string;
  avgFPS?: string;
  pixFmt?: string;
  sar?: string;
  lang?: string;
  codecLongName?: string;
  height?: string;
  numFrames?: string;
  bitrate?: string;
  codecTagString?: string;
  hasBFrames?: string;
  profile?: string;
  startTime?: string;
  networkCost?: QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost;
  dar?: string;
  codecName?: string;
  width?: string;
  duration?: string;
  fps?: string;
  codecTag?: string;
  codecTimeBase?: string;
  level?: string;
  static names(): { [key: string]: string } {
    return {
      index: 'Index',
      timebase: 'Timebase',
      avgFPS: 'AvgFPS',
      pixFmt: 'PixFmt',
      sar: 'Sar',
      lang: 'Lang',
      codecLongName: 'CodecLongName',
      height: 'Height',
      numFrames: 'NumFrames',
      bitrate: 'Bitrate',
      codecTagString: 'CodecTagString',
      hasBFrames: 'HasBFrames',
      profile: 'Profile',
      startTime: 'StartTime',
      networkCost: 'NetworkCost',
      dar: 'Dar',
      codecName: 'CodecName',
      width: 'Width',
      duration: 'Duration',
      fps: 'Fps',
      codecTag: 'CodecTag',
      codecTimeBase: 'CodecTimeBase',
      level: 'Level',
    };
  }

  static types(): { [key: string]: any } {
    return {
      index: 'string',
      timebase: 'string',
      avgFPS: 'string',
      pixFmt: 'string',
      sar: 'string',
      lang: 'string',
      codecLongName: 'string',
      height: 'string',
      numFrames: 'string',
      bitrate: 'string',
      codecTagString: 'string',
      hasBFrames: 'string',
      profile: 'string',
      startTime: 'string',
      networkCost: QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost,
      dar: 'string',
      codecName: 'string',
      width: 'string',
      duration: 'string',
      fps: 'string',
      codecTag: 'string',
      codecTimeBase: 'string',
      level: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamList extends $tea.Model {
  videoStream?: QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStream[];
  static names(): { [key: string]: string } {
    return {
      videoStream: 'VideoStream',
    };
  }

  static types(): { [key: string]: any } {
    return {
      videoStream: { 'type': 'array', 'itemType': QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStream },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobListResponseBodyJobListJobOutputPropertiesStreamsAudioStreamListAudioStream extends $tea.Model {
  timebase?: string;
  index?: string;
  sampleFmt?: string;
  channelLayout?: string;
  lang?: string;
  samplerate?: string;
  codecLongName?: string;
  channels?: string;
  numFrames?: string;
  bitrate?: string;
  codecTagString?: string;
  startTime?: string;
  codecName?: string;
  duration?: string;
  codecTag?: string;
  codecTimeBase?: string;
  static names(): { [key: string]: string } {
    return {
      timebase: 'Timebase',
      index: 'Index',
      sampleFmt: 'SampleFmt',
      channelLayout: 'ChannelLayout',
      lang: 'Lang',
      samplerate: 'Samplerate',
      codecLongName: 'CodecLongName',
      channels: 'Channels',
      numFrames: 'NumFrames',
      bitrate: 'Bitrate',
      codecTagString: 'CodecTagString',
      startTime: 'StartTime',
      codecName: 'CodecName',
      duration: 'Duration',
      codecTag: 'CodecTag',
      codecTimeBase: 'CodecTimeBase',
    };
  }

  static types(): { [key: string]: any } {
    return {
      timebase: 'string',
      index: 'string',
      sampleFmt: 'string',
      channelLayout: 'string',
      lang: 'string',
      samplerate: 'string',
      codecLongName: 'string',
      channels: 'string',
      numFrames: 'string',
      bitrate: 'string',
      codecTagString: 'string',
      startTime: 'string',
      codecName: 'string',
      duration: 'string',
      codecTag: 'string',
      codecTimeBase: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobListResponseBodyJobListJobOutputPropertiesStreamsAudioStreamList extends $tea.Model {
  audioStream?: QueryJobListResponseBodyJobListJobOutputPropertiesStreamsAudioStreamListAudioStream[];
  static names(): { [key: string]: string } {
    return {
      audioStream: 'AudioStream',
    };
  }

  static types(): { [key: string]: any } {
    return {
      audioStream: { 'type': 'array', 'itemType': QueryJobListResponseBodyJobListJobOutputPropertiesStreamsAudioStreamListAudioStream },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobListResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream extends $tea.Model {
  index?: string;
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      index: 'Index',
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      index: 'string',
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobListResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamList extends $tea.Model {
  subtitleStream?: QueryJobListResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream[];
  static names(): { [key: string]: string } {
    return {
      subtitleStream: 'SubtitleStream',
    };
  }

  static types(): { [key: string]: any } {
    return {
      subtitleStream: { 'type': 'array', 'itemType': QueryJobListResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobListResponseBodyJobListJobOutputPropertiesStreams extends $tea.Model {
  videoStreamList?: QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamList;
  audioStreamList?: QueryJobListResponseBodyJobListJobOutputPropertiesStreamsAudioStreamList;
  subtitleStreamList?: QueryJobListResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamList;
  static names(): { [key: string]: string } {
    return {
      videoStreamList: 'VideoStreamList',
      audioStreamList: 'AudioStreamList',
      subtitleStreamList: 'SubtitleStreamList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      videoStreamList: QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamList,
      audioStreamList: QueryJobListResponseBodyJobListJobOutputPropertiesStreamsAudioStreamList,
      subtitleStreamList: QueryJobListResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobListResponseBodyJobListJobOutputPropertiesFormat extends $tea.Model {
  startTime?: string;
  numPrograms?: string;
  size?: string;
  numStreams?: string;
  formatLongName?: string;
  duration?: string;
  bitrate?: string;
  formatName?: string;
  static names(): { [key: string]: string } {
    return {
      startTime: 'StartTime',
      numPrograms: 'NumPrograms',
      size: 'Size',
      numStreams: 'NumStreams',
      formatLongName: 'FormatLongName',
      duration: 'Duration',
      bitrate: 'Bitrate',
      formatName: 'FormatName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      startTime: 'string',
      numPrograms: 'string',
      size: 'string',
      numStreams: 'string',
      formatLongName: 'string',
      duration: 'string',
      bitrate: 'string',
      formatName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobListResponseBodyJobListJobOutputProperties extends $tea.Model {
  width?: string;
  height?: string;
  sourceLogos?: QueryJobListResponseBodyJobListJobOutputPropertiesSourceLogos;
  duration?: string;
  fps?: string;
  bitrate?: string;
  fileFormat?: string;
  streams?: QueryJobListResponseBodyJobListJobOutputPropertiesStreams;
  format?: QueryJobListResponseBodyJobListJobOutputPropertiesFormat;
  fileSize?: string;
  static names(): { [key: string]: string } {
    return {
      width: 'Width',
      height: 'Height',
      sourceLogos: 'SourceLogos',
      duration: 'Duration',
      fps: 'Fps',
      bitrate: 'Bitrate',
      fileFormat: 'FileFormat',
      streams: 'Streams',
      format: 'Format',
      fileSize: 'FileSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      width: 'string',
      height: 'string',
      sourceLogos: QueryJobListResponseBodyJobListJobOutputPropertiesSourceLogos,
      duration: 'string',
      fps: 'string',
      bitrate: 'string',
      fileFormat: 'string',
      streams: QueryJobListResponseBodyJobListJobOutputPropertiesStreams,
      format: QueryJobListResponseBodyJobListJobOutputPropertiesFormat,
      fileSize: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobListResponseBodyJobListJobOutput extends $tea.Model {
  video?: QueryJobListResponseBodyJobListJobOutputVideo;
  transConfig?: QueryJobListResponseBodyJobListJobOutputTransConfig;
  encryption?: QueryJobListResponseBodyJobListJobOutputEncryption;
  waterMarkList?: QueryJobListResponseBodyJobListJobOutputWaterMarkList;
  waterMarkConfigUrl?: string;
  deWatermark?: string;
  m3U8NonStandardSupport?: QueryJobListResponseBodyJobListJobOutputM3U8NonStandardSupport;
  priority?: string;
  audio?: QueryJobListResponseBodyJobListJobOutputAudio;
  audioStreamMap?: string;
  mergeList?: QueryJobListResponseBodyJobListJobOutputMergeList;
  superReso?: QueryJobListResponseBodyJobListJobOutputSuperReso;
  userData?: string;
  outSubtitleList?: QueryJobListResponseBodyJobListJobOutputOutSubtitleList;
  videoStreamMap?: string;
  outputFile?: QueryJobListResponseBodyJobListJobOutputOutputFile;
  rotate?: string;
  container?: QueryJobListResponseBodyJobListJobOutputContainer;
  clip?: QueryJobListResponseBodyJobListJobOutputClip;
  mergeConfigUrl?: string;
  openingList?: QueryJobListResponseBodyJobListJobOutputOpeningList;
  muxConfig?: QueryJobListResponseBodyJobListJobOutputMuxConfig;
  tailSlateList?: QueryJobListResponseBodyJobListJobOutputTailSlateList;
  templateId?: string;
  subtitleConfig?: QueryJobListResponseBodyJobListJobOutputSubtitleConfig;
  properties?: QueryJobListResponseBodyJobListJobOutputProperties;
  static names(): { [key: string]: string } {
    return {
      video: 'Video',
      transConfig: 'TransConfig',
      encryption: 'Encryption',
      waterMarkList: 'WaterMarkList',
      waterMarkConfigUrl: 'WaterMarkConfigUrl',
      deWatermark: 'DeWatermark',
      m3U8NonStandardSupport: 'M3U8NonStandardSupport',
      priority: 'Priority',
      audio: 'Audio',
      audioStreamMap: 'AudioStreamMap',
      mergeList: 'MergeList',
      superReso: 'SuperReso',
      userData: 'UserData',
      outSubtitleList: 'OutSubtitleList',
      videoStreamMap: 'VideoStreamMap',
      outputFile: 'OutputFile',
      rotate: 'Rotate',
      container: 'Container',
      clip: 'Clip',
      mergeConfigUrl: 'MergeConfigUrl',
      openingList: 'OpeningList',
      muxConfig: 'MuxConfig',
      tailSlateList: 'TailSlateList',
      templateId: 'TemplateId',
      subtitleConfig: 'SubtitleConfig',
      properties: 'Properties',
    };
  }

  static types(): { [key: string]: any } {
    return {
      video: QueryJobListResponseBodyJobListJobOutputVideo,
      transConfig: QueryJobListResponseBodyJobListJobOutputTransConfig,
      encryption: QueryJobListResponseBodyJobListJobOutputEncryption,
      waterMarkList: QueryJobListResponseBodyJobListJobOutputWaterMarkList,
      waterMarkConfigUrl: 'string',
      deWatermark: 'string',
      m3U8NonStandardSupport: QueryJobListResponseBodyJobListJobOutputM3U8NonStandardSupport,
      priority: 'string',
      audio: QueryJobListResponseBodyJobListJobOutputAudio,
      audioStreamMap: 'string',
      mergeList: QueryJobListResponseBodyJobListJobOutputMergeList,
      superReso: QueryJobListResponseBodyJobListJobOutputSuperReso,
      userData: 'string',
      outSubtitleList: QueryJobListResponseBodyJobListJobOutputOutSubtitleList,
      videoStreamMap: 'string',
      outputFile: QueryJobListResponseBodyJobListJobOutputOutputFile,
      rotate: 'string',
      container: QueryJobListResponseBodyJobListJobOutputContainer,
      clip: QueryJobListResponseBodyJobListJobOutputClip,
      mergeConfigUrl: 'string',
      openingList: QueryJobListResponseBodyJobListJobOutputOpeningList,
      muxConfig: QueryJobListResponseBodyJobListJobOutputMuxConfig,
      tailSlateList: QueryJobListResponseBodyJobListJobOutputTailSlateList,
      templateId: 'string',
      subtitleConfig: QueryJobListResponseBodyJobListJobOutputSubtitleConfig,
      properties: QueryJobListResponseBodyJobListJobOutputProperties,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobListResponseBodyJobListJobInput extends $tea.Model {
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobListResponseBodyJobListJobMNSMessageResult extends $tea.Model {
  messageId?: string;
  errorMessage?: string;
  errorCode?: string;
  static names(): { [key: string]: string } {
    return {
      messageId: 'MessageId',
      errorMessage: 'ErrorMessage',
      errorCode: 'ErrorCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      messageId: 'string',
      errorMessage: 'string',
      errorCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobListResponseBodyJobListJob extends $tea.Model {
  creationTime?: string;
  percent?: number;
  finishTime?: string;
  state?: string;
  jobId?: string;
  code?: string;
  message?: string;
  output?: QueryJobListResponseBodyJobListJobOutput;
  pipelineId?: string;
  input?: QueryJobListResponseBodyJobListJobInput;
  MNSMessageResult?: QueryJobListResponseBodyJobListJobMNSMessageResult;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      percent: 'Percent',
      finishTime: 'FinishTime',
      state: 'State',
      jobId: 'JobId',
      code: 'Code',
      message: 'Message',
      output: 'Output',
      pipelineId: 'PipelineId',
      input: 'Input',
      MNSMessageResult: 'MNSMessageResult',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      percent: 'number',
      finishTime: 'string',
      state: 'string',
      jobId: 'string',
      code: 'string',
      message: 'string',
      output: QueryJobListResponseBodyJobListJobOutput,
      pipelineId: 'string',
      input: QueryJobListResponseBodyJobListJobInput,
      MNSMessageResult: QueryJobListResponseBodyJobListJobMNSMessageResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobListResponseBodyJobList extends $tea.Model {
  job?: QueryJobListResponseBodyJobListJob[];
  static names(): { [key: string]: string } {
    return {
      job: 'Job',
    };
  }

  static types(): { [key: string]: any } {
    return {
      job: { 'type': 'array', 'itemType': QueryJobListResponseBodyJobListJob },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultPornResultPornTextsPornText extends $tea.Model {
  suggestion?: string;
  score?: string;
  text?: string;
  static names(): { [key: string]: string } {
    return {
      suggestion: 'Suggestion',
      score: 'Score',
      text: 'Text',
    };
  }

  static types(): { [key: string]: any } {
    return {
      suggestion: 'string',
      score: 'string',
      text: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultPornResultPornTexts extends $tea.Model {
  pornText?: QueryMCJobListResponseBodyJobListJobResultPornResultPornTextsPornText[];
  static names(): { [key: string]: string } {
    return {
      pornText: 'PornText',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pornText: { 'type': 'array', 'itemType': QueryMCJobListResponseBodyJobListJobResultPornResultPornTextsPornText },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultPornResultPornVideosPornVideo extends $tea.Model {
  time?: string;
  suggestion?: string;
  score?: string;
  object?: string;
  static names(): { [key: string]: string } {
    return {
      time: 'Time',
      suggestion: 'Suggestion',
      score: 'Score',
      object: 'Object',
    };
  }

  static types(): { [key: string]: any } {
    return {
      time: 'string',
      suggestion: 'string',
      score: 'string',
      object: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultPornResultPornVideos extends $tea.Model {
  pornVideo?: QueryMCJobListResponseBodyJobListJobResultPornResultPornVideosPornVideo[];
  static names(): { [key: string]: string } {
    return {
      pornVideo: 'PornVideo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pornVideo: { 'type': 'array', 'itemType': QueryMCJobListResponseBodyJobListJobResultPornResultPornVideosPornVideo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultPornResultPornAudiosPornAudio extends $tea.Model {
  endTime?: string;
  startTime?: string;
  suggestion?: string;
  score?: string;
  text?: string;
  object?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      startTime: 'StartTime',
      suggestion: 'Suggestion',
      score: 'Score',
      text: 'Text',
      object: 'Object',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      startTime: 'string',
      suggestion: 'string',
      score: 'string',
      text: 'string',
      object: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultPornResultPornAudios extends $tea.Model {
  pornAudio?: QueryMCJobListResponseBodyJobListJobResultPornResultPornAudiosPornAudio[];
  static names(): { [key: string]: string } {
    return {
      pornAudio: 'PornAudio',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pornAudio: { 'type': 'array', 'itemType': QueryMCJobListResponseBodyJobListJobResultPornResultPornAudiosPornAudio },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultPornResultPornImagesPornImage extends $tea.Model {
  suggestion?: string;
  score?: string;
  url?: string;
  text?: string;
  static names(): { [key: string]: string } {
    return {
      suggestion: 'Suggestion',
      score: 'Score',
      url: 'Url',
      text: 'Text',
    };
  }

  static types(): { [key: string]: any } {
    return {
      suggestion: 'string',
      score: 'string',
      url: 'string',
      text: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultPornResultPornImages extends $tea.Model {
  pornImage?: QueryMCJobListResponseBodyJobListJobResultPornResultPornImagesPornImage[];
  static names(): { [key: string]: string } {
    return {
      pornImage: 'PornImage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pornImage: { 'type': 'array', 'itemType': QueryMCJobListResponseBodyJobListJobResultPornResultPornImagesPornImage },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultPornResultPornOcrsPornOcr extends $tea.Model {
  time?: string;
  suggestion?: string;
  score?: string;
  text?: string;
  object?: string;
  static names(): { [key: string]: string } {
    return {
      time: 'Time',
      suggestion: 'Suggestion',
      score: 'Score',
      text: 'Text',
      object: 'Object',
    };
  }

  static types(): { [key: string]: any } {
    return {
      time: 'string',
      suggestion: 'string',
      score: 'string',
      text: 'string',
      object: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultPornResultPornOcrs extends $tea.Model {
  pornOcr?: QueryMCJobListResponseBodyJobListJobResultPornResultPornOcrsPornOcr[];
  static names(): { [key: string]: string } {
    return {
      pornOcr: 'PornOcr',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pornOcr: { 'type': 'array', 'itemType': QueryMCJobListResponseBodyJobListJobResultPornResultPornOcrsPornOcr },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultPornResult extends $tea.Model {
  pornTexts?: QueryMCJobListResponseBodyJobListJobResultPornResultPornTexts;
  pornVideos?: QueryMCJobListResponseBodyJobListJobResultPornResultPornVideos;
  pornAudios?: QueryMCJobListResponseBodyJobListJobResultPornResultPornAudios;
  pornImages?: QueryMCJobListResponseBodyJobListJobResultPornResultPornImages;
  pornOcrs?: QueryMCJobListResponseBodyJobListJobResultPornResultPornOcrs;
  static names(): { [key: string]: string } {
    return {
      pornTexts: 'PornTexts',
      pornVideos: 'PornVideos',
      pornAudios: 'PornAudios',
      pornImages: 'PornImages',
      pornOcrs: 'PornOcrs',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pornTexts: QueryMCJobListResponseBodyJobListJobResultPornResultPornTexts,
      pornVideos: QueryMCJobListResponseBodyJobListJobResultPornResultPornVideos,
      pornAudios: QueryMCJobListResponseBodyJobListJobResultPornResultPornAudios,
      pornImages: QueryMCJobListResponseBodyJobListJobResultPornResultPornImages,
      pornOcrs: QueryMCJobListResponseBodyJobListJobResultPornResultPornOcrs,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultAdResultAdOcrsAdOcr extends $tea.Model {
  time?: string;
  suggestion?: string;
  score?: string;
  text?: string;
  object?: string;
  static names(): { [key: string]: string } {
    return {
      time: 'Time',
      suggestion: 'Suggestion',
      score: 'Score',
      text: 'Text',
      object: 'Object',
    };
  }

  static types(): { [key: string]: any } {
    return {
      time: 'string',
      suggestion: 'string',
      score: 'string',
      text: 'string',
      object: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultAdResultAdOcrs extends $tea.Model {
  adOcr?: QueryMCJobListResponseBodyJobListJobResultAdResultAdOcrsAdOcr[];
  static names(): { [key: string]: string } {
    return {
      adOcr: 'AdOcr',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adOcr: { 'type': 'array', 'itemType': QueryMCJobListResponseBodyJobListJobResultAdResultAdOcrsAdOcr },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultAdResultAdTextsAdText extends $tea.Model {
  suggestion?: string;
  score?: string;
  text?: string;
  static names(): { [key: string]: string } {
    return {
      suggestion: 'Suggestion',
      score: 'Score',
      text: 'Text',
    };
  }

  static types(): { [key: string]: any } {
    return {
      suggestion: 'string',
      score: 'string',
      text: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultAdResultAdTexts extends $tea.Model {
  adText?: QueryMCJobListResponseBodyJobListJobResultAdResultAdTextsAdText[];
  static names(): { [key: string]: string } {
    return {
      adText: 'AdText',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adText: { 'type': 'array', 'itemType': QueryMCJobListResponseBodyJobListJobResultAdResultAdTextsAdText },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultAdResultAdImagesAdImage extends $tea.Model {
  suggestion?: string;
  score?: string;
  url?: string;
  text?: string;
  static names(): { [key: string]: string } {
    return {
      suggestion: 'Suggestion',
      score: 'Score',
      url: 'Url',
      text: 'Text',
    };
  }

  static types(): { [key: string]: any } {
    return {
      suggestion: 'string',
      score: 'string',
      url: 'string',
      text: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultAdResultAdImages extends $tea.Model {
  adImage?: QueryMCJobListResponseBodyJobListJobResultAdResultAdImagesAdImage[];
  static names(): { [key: string]: string } {
    return {
      adImage: 'AdImage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adImage: { 'type': 'array', 'itemType': QueryMCJobListResponseBodyJobListJobResultAdResultAdImagesAdImage },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultAdResultAdAudiosAdAudio extends $tea.Model {
  endTime?: string;
  startTime?: string;
  suggestion?: string;
  score?: string;
  text?: string;
  object?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      startTime: 'StartTime',
      suggestion: 'Suggestion',
      score: 'Score',
      text: 'Text',
      object: 'Object',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      startTime: 'string',
      suggestion: 'string',
      score: 'string',
      text: 'string',
      object: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultAdResultAdAudios extends $tea.Model {
  adAudio?: QueryMCJobListResponseBodyJobListJobResultAdResultAdAudiosAdAudio[];
  static names(): { [key: string]: string } {
    return {
      adAudio: 'AdAudio',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adAudio: { 'type': 'array', 'itemType': QueryMCJobListResponseBodyJobListJobResultAdResultAdAudiosAdAudio },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultAdResultAdVideosAdVideo extends $tea.Model {
  time?: string;
  suggestion?: string;
  score?: string;
  object?: string;
  static names(): { [key: string]: string } {
    return {
      time: 'Time',
      suggestion: 'Suggestion',
      score: 'Score',
      object: 'Object',
    };
  }

  static types(): { [key: string]: any } {
    return {
      time: 'string',
      suggestion: 'string',
      score: 'string',
      object: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultAdResultAdVideos extends $tea.Model {
  adVideo?: QueryMCJobListResponseBodyJobListJobResultAdResultAdVideosAdVideo[];
  static names(): { [key: string]: string } {
    return {
      adVideo: 'AdVideo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adVideo: { 'type': 'array', 'itemType': QueryMCJobListResponseBodyJobListJobResultAdResultAdVideosAdVideo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultAdResult extends $tea.Model {
  adOcrs?: QueryMCJobListResponseBodyJobListJobResultAdResultAdOcrs;
  adTexts?: QueryMCJobListResponseBodyJobListJobResultAdResultAdTexts;
  adImages?: QueryMCJobListResponseBodyJobListJobResultAdResultAdImages;
  adAudios?: QueryMCJobListResponseBodyJobListJobResultAdResultAdAudios;
  adVideos?: QueryMCJobListResponseBodyJobListJobResultAdResultAdVideos;
  static names(): { [key: string]: string } {
    return {
      adOcrs: 'AdOcrs',
      adTexts: 'AdTexts',
      adImages: 'AdImages',
      adAudios: 'AdAudios',
      adVideos: 'AdVideos',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adOcrs: QueryMCJobListResponseBodyJobListJobResultAdResultAdOcrs,
      adTexts: QueryMCJobListResponseBodyJobListJobResultAdResultAdTexts,
      adImages: QueryMCJobListResponseBodyJobListJobResultAdResultAdImages,
      adAudios: QueryMCJobListResponseBodyJobListJobResultAdResultAdAudios,
      adVideos: QueryMCJobListResponseBodyJobListJobResultAdResultAdVideos,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultLogoResultLogoImagesLogoImage extends $tea.Model {
  suggestion?: string;
  score?: string;
  url?: string;
  text?: string;
  static names(): { [key: string]: string } {
    return {
      suggestion: 'Suggestion',
      score: 'Score',
      url: 'Url',
      text: 'Text',
    };
  }

  static types(): { [key: string]: any } {
    return {
      suggestion: 'string',
      score: 'string',
      url: 'string',
      text: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultLogoResultLogoImages extends $tea.Model {
  logoImage?: QueryMCJobListResponseBodyJobListJobResultLogoResultLogoImagesLogoImage[];
  static names(): { [key: string]: string } {
    return {
      logoImage: 'LogoImage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      logoImage: { 'type': 'array', 'itemType': QueryMCJobListResponseBodyJobListJobResultLogoResultLogoImagesLogoImage },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultLogoResultLogoVideosLogoVideo extends $tea.Model {
  time?: string;
  suggestion?: string;
  score?: string;
  object?: string;
  static names(): { [key: string]: string } {
    return {
      time: 'Time',
      suggestion: 'Suggestion',
      score: 'Score',
      object: 'Object',
    };
  }

  static types(): { [key: string]: any } {
    return {
      time: 'string',
      suggestion: 'string',
      score: 'string',
      object: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultLogoResultLogoVideos extends $tea.Model {
  logoVideo?: QueryMCJobListResponseBodyJobListJobResultLogoResultLogoVideosLogoVideo[];
  static names(): { [key: string]: string } {
    return {
      logoVideo: 'LogoVideo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      logoVideo: { 'type': 'array', 'itemType': QueryMCJobListResponseBodyJobListJobResultLogoResultLogoVideosLogoVideo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultLogoResult extends $tea.Model {
  logoImages?: QueryMCJobListResponseBodyJobListJobResultLogoResultLogoImages;
  logoVideos?: QueryMCJobListResponseBodyJobListJobResultLogoResultLogoVideos;
  static names(): { [key: string]: string } {
    return {
      logoImages: 'LogoImages',
      logoVideos: 'LogoVideos',
    };
  }

  static types(): { [key: string]: any } {
    return {
      logoImages: QueryMCJobListResponseBodyJobListJobResultLogoResultLogoImages,
      logoVideos: QueryMCJobListResponseBodyJobListJobResultLogoResultLogoVideos,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultQrcodeResultQrcodeImagesQrcodeImage extends $tea.Model {
  suggestion?: string;
  score?: string;
  url?: string;
  text?: string;
  static names(): { [key: string]: string } {
    return {
      suggestion: 'Suggestion',
      score: 'Score',
      url: 'Url',
      text: 'Text',
    };
  }

  static types(): { [key: string]: any } {
    return {
      suggestion: 'string',
      score: 'string',
      url: 'string',
      text: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultQrcodeResultQrcodeImages extends $tea.Model {
  qrcodeImage?: QueryMCJobListResponseBodyJobListJobResultQrcodeResultQrcodeImagesQrcodeImage[];
  static names(): { [key: string]: string } {
    return {
      qrcodeImage: 'QrcodeImage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      qrcodeImage: { 'type': 'array', 'itemType': QueryMCJobListResponseBodyJobListJobResultQrcodeResultQrcodeImagesQrcodeImage },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultQrcodeResultQrcodeVideosQrcodeVideo extends $tea.Model {
  time?: string;
  suggestion?: string;
  score?: string;
  object?: string;
  static names(): { [key: string]: string } {
    return {
      time: 'Time',
      suggestion: 'Suggestion',
      score: 'Score',
      object: 'Object',
    };
  }

  static types(): { [key: string]: any } {
    return {
      time: 'string',
      suggestion: 'string',
      score: 'string',
      object: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultQrcodeResultQrcodeVideos extends $tea.Model {
  qrcodeVideo?: QueryMCJobListResponseBodyJobListJobResultQrcodeResultQrcodeVideosQrcodeVideo[];
  static names(): { [key: string]: string } {
    return {
      qrcodeVideo: 'QrcodeVideo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      qrcodeVideo: { 'type': 'array', 'itemType': QueryMCJobListResponseBodyJobListJobResultQrcodeResultQrcodeVideosQrcodeVideo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultQrcodeResult extends $tea.Model {
  qrcodeImages?: QueryMCJobListResponseBodyJobListJobResultQrcodeResultQrcodeImages;
  qrcodeVideos?: QueryMCJobListResponseBodyJobListJobResultQrcodeResultQrcodeVideos;
  static names(): { [key: string]: string } {
    return {
      qrcodeImages: 'QrcodeImages',
      qrcodeVideos: 'QrcodeVideos',
    };
  }

  static types(): { [key: string]: any } {
    return {
      qrcodeImages: QueryMCJobListResponseBodyJobListJobResultQrcodeResultQrcodeImages,
      qrcodeVideos: QueryMCJobListResponseBodyJobListJobResultQrcodeResultQrcodeVideos,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsOcrsPoliticsOcr extends $tea.Model {
  time?: string;
  suggestion?: string;
  score?: string;
  text?: string;
  object?: string;
  static names(): { [key: string]: string } {
    return {
      time: 'Time',
      suggestion: 'Suggestion',
      score: 'Score',
      text: 'Text',
      object: 'Object',
    };
  }

  static types(): { [key: string]: any } {
    return {
      time: 'string',
      suggestion: 'string',
      score: 'string',
      text: 'string',
      object: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsOcrs extends $tea.Model {
  politicsOcr?: QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsOcrsPoliticsOcr[];
  static names(): { [key: string]: string } {
    return {
      politicsOcr: 'PoliticsOcr',
    };
  }

  static types(): { [key: string]: any } {
    return {
      politicsOcr: { 'type': 'array', 'itemType': QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsOcrsPoliticsOcr },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsVideosPoliticsVideo extends $tea.Model {
  time?: string;
  suggestion?: string;
  score?: string;
  object?: string;
  static names(): { [key: string]: string } {
    return {
      time: 'Time',
      suggestion: 'Suggestion',
      score: 'Score',
      object: 'Object',
    };
  }

  static types(): { [key: string]: any } {
    return {
      time: 'string',
      suggestion: 'string',
      score: 'string',
      object: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsVideos extends $tea.Model {
  politicsVideo?: QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsVideosPoliticsVideo[];
  static names(): { [key: string]: string } {
    return {
      politicsVideo: 'PoliticsVideo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      politicsVideo: { 'type': 'array', 'itemType': QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsVideosPoliticsVideo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsImagesPoliticsImage extends $tea.Model {
  suggestion?: string;
  score?: string;
  url?: string;
  text?: string;
  static names(): { [key: string]: string } {
    return {
      suggestion: 'Suggestion',
      score: 'Score',
      url: 'Url',
      text: 'Text',
    };
  }

  static types(): { [key: string]: any } {
    return {
      suggestion: 'string',
      score: 'string',
      url: 'string',
      text: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsImages extends $tea.Model {
  politicsImage?: QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsImagesPoliticsImage[];
  static names(): { [key: string]: string } {
    return {
      politicsImage: 'PoliticsImage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      politicsImage: { 'type': 'array', 'itemType': QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsImagesPoliticsImage },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsTextsPoliticsText extends $tea.Model {
  suggestion?: string;
  score?: string;
  text?: string;
  static names(): { [key: string]: string } {
    return {
      suggestion: 'Suggestion',
      score: 'Score',
      text: 'Text',
    };
  }

  static types(): { [key: string]: any } {
    return {
      suggestion: 'string',
      score: 'string',
      text: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsTexts extends $tea.Model {
  politicsText?: QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsTextsPoliticsText[];
  static names(): { [key: string]: string } {
    return {
      politicsText: 'PoliticsText',
    };
  }

  static types(): { [key: string]: any } {
    return {
      politicsText: { 'type': 'array', 'itemType': QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsTextsPoliticsText },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsAudiosPoliticsAudio extends $tea.Model {
  endTime?: string;
  startTime?: string;
  suggestion?: string;
  score?: string;
  text?: string;
  object?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      startTime: 'StartTime',
      suggestion: 'Suggestion',
      score: 'Score',
      text: 'Text',
      object: 'Object',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      startTime: 'string',
      suggestion: 'string',
      score: 'string',
      text: 'string',
      object: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsAudios extends $tea.Model {
  politicsAudio?: QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsAudiosPoliticsAudio[];
  static names(): { [key: string]: string } {
    return {
      politicsAudio: 'PoliticsAudio',
    };
  }

  static types(): { [key: string]: any } {
    return {
      politicsAudio: { 'type': 'array', 'itemType': QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsAudiosPoliticsAudio },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultPoliticsResult extends $tea.Model {
  politicsOcrs?: QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsOcrs;
  politicsVideos?: QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsVideos;
  politicsImages?: QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsImages;
  politicsTexts?: QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsTexts;
  politicsAudios?: QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsAudios;
  static names(): { [key: string]: string } {
    return {
      politicsOcrs: 'PoliticsOcrs',
      politicsVideos: 'PoliticsVideos',
      politicsImages: 'PoliticsImages',
      politicsTexts: 'PoliticsTexts',
      politicsAudios: 'PoliticsAudios',
    };
  }

  static types(): { [key: string]: any } {
    return {
      politicsOcrs: QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsOcrs,
      politicsVideos: QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsVideos,
      politicsImages: QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsImages,
      politicsTexts: QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsTexts,
      politicsAudios: QueryMCJobListResponseBodyJobListJobResultPoliticsResultPoliticsAudios,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultLiveResultLiveImagesLiveImage extends $tea.Model {
  suggestion?: string;
  score?: string;
  url?: string;
  text?: string;
  static names(): { [key: string]: string } {
    return {
      suggestion: 'Suggestion',
      score: 'Score',
      url: 'Url',
      text: 'Text',
    };
  }

  static types(): { [key: string]: any } {
    return {
      suggestion: 'string',
      score: 'string',
      url: 'string',
      text: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultLiveResultLiveImages extends $tea.Model {
  liveImage?: QueryMCJobListResponseBodyJobListJobResultLiveResultLiveImagesLiveImage[];
  static names(): { [key: string]: string } {
    return {
      liveImage: 'LiveImage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      liveImage: { 'type': 'array', 'itemType': QueryMCJobListResponseBodyJobListJobResultLiveResultLiveImagesLiveImage },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultLiveResultLiveVideosLiveVideo extends $tea.Model {
  time?: string;
  suggestion?: string;
  score?: string;
  object?: string;
  static names(): { [key: string]: string } {
    return {
      time: 'Time',
      suggestion: 'Suggestion',
      score: 'Score',
      object: 'Object',
    };
  }

  static types(): { [key: string]: any } {
    return {
      time: 'string',
      suggestion: 'string',
      score: 'string',
      object: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultLiveResultLiveVideos extends $tea.Model {
  liveVideo?: QueryMCJobListResponseBodyJobListJobResultLiveResultLiveVideosLiveVideo[];
  static names(): { [key: string]: string } {
    return {
      liveVideo: 'LiveVideo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      liveVideo: { 'type': 'array', 'itemType': QueryMCJobListResponseBodyJobListJobResultLiveResultLiveVideosLiveVideo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultLiveResult extends $tea.Model {
  liveImages?: QueryMCJobListResponseBodyJobListJobResultLiveResultLiveImages;
  liveVideos?: QueryMCJobListResponseBodyJobListJobResultLiveResultLiveVideos;
  static names(): { [key: string]: string } {
    return {
      liveImages: 'LiveImages',
      liveVideos: 'LiveVideos',
    };
  }

  static types(): { [key: string]: any } {
    return {
      liveImages: QueryMCJobListResponseBodyJobListJobResultLiveResultLiveImages,
      liveVideos: QueryMCJobListResponseBodyJobListJobResultLiveResultLiveVideos,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultAbuseResultAbuseOcrsAbuseOcr extends $tea.Model {
  time?: string;
  suggestion?: string;
  score?: string;
  text?: string;
  object?: string;
  static names(): { [key: string]: string } {
    return {
      time: 'Time',
      suggestion: 'Suggestion',
      score: 'Score',
      text: 'Text',
      object: 'Object',
    };
  }

  static types(): { [key: string]: any } {
    return {
      time: 'string',
      suggestion: 'string',
      score: 'string',
      text: 'string',
      object: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultAbuseResultAbuseOcrs extends $tea.Model {
  abuseOcr?: QueryMCJobListResponseBodyJobListJobResultAbuseResultAbuseOcrsAbuseOcr[];
  static names(): { [key: string]: string } {
    return {
      abuseOcr: 'AbuseOcr',
    };
  }

  static types(): { [key: string]: any } {
    return {
      abuseOcr: { 'type': 'array', 'itemType': QueryMCJobListResponseBodyJobListJobResultAbuseResultAbuseOcrsAbuseOcr },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultAbuseResultAbuseAudiosAbuseAudio extends $tea.Model {
  endTime?: string;
  startTime?: string;
  suggestion?: string;
  score?: string;
  text?: string;
  object?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      startTime: 'StartTime',
      suggestion: 'Suggestion',
      score: 'Score',
      text: 'Text',
      object: 'Object',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      startTime: 'string',
      suggestion: 'string',
      score: 'string',
      text: 'string',
      object: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultAbuseResultAbuseAudios extends $tea.Model {
  abuseAudio?: QueryMCJobListResponseBodyJobListJobResultAbuseResultAbuseAudiosAbuseAudio[];
  static names(): { [key: string]: string } {
    return {
      abuseAudio: 'AbuseAudio',
    };
  }

  static types(): { [key: string]: any } {
    return {
      abuseAudio: { 'type': 'array', 'itemType': QueryMCJobListResponseBodyJobListJobResultAbuseResultAbuseAudiosAbuseAudio },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultAbuseResultAbuseTextsAbuseText extends $tea.Model {
  suggestion?: string;
  score?: string;
  text?: string;
  static names(): { [key: string]: string } {
    return {
      suggestion: 'Suggestion',
      score: 'Score',
      text: 'Text',
    };
  }

  static types(): { [key: string]: any } {
    return {
      suggestion: 'string',
      score: 'string',
      text: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultAbuseResultAbuseTexts extends $tea.Model {
  abuseText?: QueryMCJobListResponseBodyJobListJobResultAbuseResultAbuseTextsAbuseText[];
  static names(): { [key: string]: string } {
    return {
      abuseText: 'AbuseText',
    };
  }

  static types(): { [key: string]: any } {
    return {
      abuseText: { 'type': 'array', 'itemType': QueryMCJobListResponseBodyJobListJobResultAbuseResultAbuseTextsAbuseText },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultAbuseResult extends $tea.Model {
  abuseOcrs?: QueryMCJobListResponseBodyJobListJobResultAbuseResultAbuseOcrs;
  abuseAudios?: QueryMCJobListResponseBodyJobListJobResultAbuseResultAbuseAudios;
  abuseTexts?: QueryMCJobListResponseBodyJobListJobResultAbuseResultAbuseTexts;
  static names(): { [key: string]: string } {
    return {
      abuseOcrs: 'AbuseOcrs',
      abuseAudios: 'AbuseAudios',
      abuseTexts: 'AbuseTexts',
    };
  }

  static types(): { [key: string]: any } {
    return {
      abuseOcrs: QueryMCJobListResponseBodyJobListJobResultAbuseResultAbuseOcrs,
      abuseAudios: QueryMCJobListResponseBodyJobListJobResultAbuseResultAbuseAudios,
      abuseTexts: QueryMCJobListResponseBodyJobListJobResultAbuseResultAbuseTexts,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultSpamResultSpamTextsSpamText extends $tea.Model {
  suggestion?: string;
  score?: string;
  text?: string;
  static names(): { [key: string]: string } {
    return {
      suggestion: 'Suggestion',
      score: 'Score',
      text: 'Text',
    };
  }

  static types(): { [key: string]: any } {
    return {
      suggestion: 'string',
      score: 'string',
      text: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultSpamResultSpamTexts extends $tea.Model {
  spamText?: QueryMCJobListResponseBodyJobListJobResultSpamResultSpamTextsSpamText[];
  static names(): { [key: string]: string } {
    return {
      spamText: 'SpamText',
    };
  }

  static types(): { [key: string]: any } {
    return {
      spamText: { 'type': 'array', 'itemType': QueryMCJobListResponseBodyJobListJobResultSpamResultSpamTextsSpamText },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultSpamResultSpamAudiosSpamAudio extends $tea.Model {
  endTime?: string;
  startTime?: string;
  suggestion?: string;
  score?: string;
  text?: string;
  object?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      startTime: 'StartTime',
      suggestion: 'Suggestion',
      score: 'Score',
      text: 'Text',
      object: 'Object',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      startTime: 'string',
      suggestion: 'string',
      score: 'string',
      text: 'string',
      object: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultSpamResultSpamAudios extends $tea.Model {
  spamAudio?: QueryMCJobListResponseBodyJobListJobResultSpamResultSpamAudiosSpamAudio[];
  static names(): { [key: string]: string } {
    return {
      spamAudio: 'SpamAudio',
    };
  }

  static types(): { [key: string]: any } {
    return {
      spamAudio: { 'type': 'array', 'itemType': QueryMCJobListResponseBodyJobListJobResultSpamResultSpamAudiosSpamAudio },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultSpamResultSpamOcrsSpamOcr extends $tea.Model {
  time?: string;
  suggestion?: string;
  score?: string;
  text?: string;
  object?: string;
  static names(): { [key: string]: string } {
    return {
      time: 'Time',
      suggestion: 'Suggestion',
      score: 'Score',
      text: 'Text',
      object: 'Object',
    };
  }

  static types(): { [key: string]: any } {
    return {
      time: 'string',
      suggestion: 'string',
      score: 'string',
      text: 'string',
      object: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultSpamResultSpamOcrs extends $tea.Model {
  spamOcr?: QueryMCJobListResponseBodyJobListJobResultSpamResultSpamOcrsSpamOcr[];
  static names(): { [key: string]: string } {
    return {
      spamOcr: 'SpamOcr',
    };
  }

  static types(): { [key: string]: any } {
    return {
      spamOcr: { 'type': 'array', 'itemType': QueryMCJobListResponseBodyJobListJobResultSpamResultSpamOcrsSpamOcr },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultSpamResult extends $tea.Model {
  spamTexts?: QueryMCJobListResponseBodyJobListJobResultSpamResultSpamTexts;
  spamAudios?: QueryMCJobListResponseBodyJobListJobResultSpamResultSpamAudios;
  spamOcrs?: QueryMCJobListResponseBodyJobListJobResultSpamResultSpamOcrs;
  static names(): { [key: string]: string } {
    return {
      spamTexts: 'SpamTexts',
      spamAudios: 'SpamAudios',
      spamOcrs: 'SpamOcrs',
    };
  }

  static types(): { [key: string]: any } {
    return {
      spamTexts: QueryMCJobListResponseBodyJobListJobResultSpamResultSpamTexts,
      spamAudios: QueryMCJobListResponseBodyJobListJobResultSpamResultSpamAudios,
      spamOcrs: QueryMCJobListResponseBodyJobListJobResultSpamResultSpamOcrs,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultContrabandResultContrabandAudiosContrabandAudio extends $tea.Model {
  endTime?: string;
  startTime?: string;
  suggestion?: string;
  score?: string;
  text?: string;
  object?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      startTime: 'StartTime',
      suggestion: 'Suggestion',
      score: 'Score',
      text: 'Text',
      object: 'Object',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      startTime: 'string',
      suggestion: 'string',
      score: 'string',
      text: 'string',
      object: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultContrabandResultContrabandAudios extends $tea.Model {
  contrabandAudio?: QueryMCJobListResponseBodyJobListJobResultContrabandResultContrabandAudiosContrabandAudio[];
  static names(): { [key: string]: string } {
    return {
      contrabandAudio: 'ContrabandAudio',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contrabandAudio: { 'type': 'array', 'itemType': QueryMCJobListResponseBodyJobListJobResultContrabandResultContrabandAudiosContrabandAudio },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultContrabandResultContrabandOcrsContrabandOcr extends $tea.Model {
  time?: string;
  suggestion?: string;
  score?: string;
  text?: string;
  object?: string;
  static names(): { [key: string]: string } {
    return {
      time: 'Time',
      suggestion: 'Suggestion',
      score: 'Score',
      text: 'Text',
      object: 'Object',
    };
  }

  static types(): { [key: string]: any } {
    return {
      time: 'string',
      suggestion: 'string',
      score: 'string',
      text: 'string',
      object: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultContrabandResultContrabandOcrs extends $tea.Model {
  contrabandOcr?: QueryMCJobListResponseBodyJobListJobResultContrabandResultContrabandOcrsContrabandOcr[];
  static names(): { [key: string]: string } {
    return {
      contrabandOcr: 'ContrabandOcr',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contrabandOcr: { 'type': 'array', 'itemType': QueryMCJobListResponseBodyJobListJobResultContrabandResultContrabandOcrsContrabandOcr },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultContrabandResultContrabandTextsContrabandText extends $tea.Model {
  suggestion?: string;
  score?: string;
  text?: string;
  static names(): { [key: string]: string } {
    return {
      suggestion: 'Suggestion',
      score: 'Score',
      text: 'Text',
    };
  }

  static types(): { [key: string]: any } {
    return {
      suggestion: 'string',
      score: 'string',
      text: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultContrabandResultContrabandTexts extends $tea.Model {
  contrabandText?: QueryMCJobListResponseBodyJobListJobResultContrabandResultContrabandTextsContrabandText[];
  static names(): { [key: string]: string } {
    return {
      contrabandText: 'ContrabandText',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contrabandText: { 'type': 'array', 'itemType': QueryMCJobListResponseBodyJobListJobResultContrabandResultContrabandTextsContrabandText },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultContrabandResult extends $tea.Model {
  contrabandAudios?: QueryMCJobListResponseBodyJobListJobResultContrabandResultContrabandAudios;
  contrabandOcrs?: QueryMCJobListResponseBodyJobListJobResultContrabandResultContrabandOcrs;
  contrabandTexts?: QueryMCJobListResponseBodyJobListJobResultContrabandResultContrabandTexts;
  static names(): { [key: string]: string } {
    return {
      contrabandAudios: 'ContrabandAudios',
      contrabandOcrs: 'ContrabandOcrs',
      contrabandTexts: 'ContrabandTexts',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contrabandAudios: QueryMCJobListResponseBodyJobListJobResultContrabandResultContrabandAudios,
      contrabandOcrs: QueryMCJobListResponseBodyJobListJobResultContrabandResultContrabandOcrs,
      contrabandTexts: QueryMCJobListResponseBodyJobListJobResultContrabandResultContrabandTexts,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismOcrsTerrorismOcr extends $tea.Model {
  time?: string;
  suggestion?: string;
  score?: string;
  text?: string;
  object?: string;
  static names(): { [key: string]: string } {
    return {
      time: 'Time',
      suggestion: 'Suggestion',
      score: 'Score',
      text: 'Text',
      object: 'Object',
    };
  }

  static types(): { [key: string]: any } {
    return {
      time: 'string',
      suggestion: 'string',
      score: 'string',
      text: 'string',
      object: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismOcrs extends $tea.Model {
  terrorismOcr?: QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismOcrsTerrorismOcr[];
  static names(): { [key: string]: string } {
    return {
      terrorismOcr: 'TerrorismOcr',
    };
  }

  static types(): { [key: string]: any } {
    return {
      terrorismOcr: { 'type': 'array', 'itemType': QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismOcrsTerrorismOcr },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismAudiosTerrorismAudio extends $tea.Model {
  endTime?: string;
  startTime?: string;
  suggestion?: string;
  score?: string;
  text?: string;
  object?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      startTime: 'StartTime',
      suggestion: 'Suggestion',
      score: 'Score',
      text: 'Text',
      object: 'Object',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      startTime: 'string',
      suggestion: 'string',
      score: 'string',
      text: 'string',
      object: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismAudios extends $tea.Model {
  terrorismAudio?: QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismAudiosTerrorismAudio[];
  static names(): { [key: string]: string } {
    return {
      terrorismAudio: 'TerrorismAudio',
    };
  }

  static types(): { [key: string]: any } {
    return {
      terrorismAudio: { 'type': 'array', 'itemType': QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismAudiosTerrorismAudio },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismVideosTerrorismVideo extends $tea.Model {
  time?: string;
  suggestion?: string;
  score?: string;
  object?: string;
  static names(): { [key: string]: string } {
    return {
      time: 'Time',
      suggestion: 'Suggestion',
      score: 'Score',
      object: 'Object',
    };
  }

  static types(): { [key: string]: any } {
    return {
      time: 'string',
      suggestion: 'string',
      score: 'string',
      object: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismVideos extends $tea.Model {
  terrorismVideo?: QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismVideosTerrorismVideo[];
  static names(): { [key: string]: string } {
    return {
      terrorismVideo: 'TerrorismVideo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      terrorismVideo: { 'type': 'array', 'itemType': QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismVideosTerrorismVideo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismTextsTerrorismText extends $tea.Model {
  suggestion?: string;
  score?: string;
  text?: string;
  static names(): { [key: string]: string } {
    return {
      suggestion: 'Suggestion',
      score: 'Score',
      text: 'Text',
    };
  }

  static types(): { [key: string]: any } {
    return {
      suggestion: 'string',
      score: 'string',
      text: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismTexts extends $tea.Model {
  terrorismText?: QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismTextsTerrorismText[];
  static names(): { [key: string]: string } {
    return {
      terrorismText: 'TerrorismText',
    };
  }

  static types(): { [key: string]: any } {
    return {
      terrorismText: { 'type': 'array', 'itemType': QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismTextsTerrorismText },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismImagesTerrorismImage extends $tea.Model {
  suggestion?: string;
  score?: string;
  url?: string;
  text?: string;
  static names(): { [key: string]: string } {
    return {
      suggestion: 'Suggestion',
      score: 'Score',
      url: 'Url',
      text: 'Text',
    };
  }

  static types(): { [key: string]: any } {
    return {
      suggestion: 'string',
      score: 'string',
      url: 'string',
      text: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismImages extends $tea.Model {
  terrorismImage?: QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismImagesTerrorismImage[];
  static names(): { [key: string]: string } {
    return {
      terrorismImage: 'TerrorismImage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      terrorismImage: { 'type': 'array', 'itemType': QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismImagesTerrorismImage },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResultTerrorismResult extends $tea.Model {
  terrorismOcrs?: QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismOcrs;
  terrorismAudios?: QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismAudios;
  terrorismVideos?: QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismVideos;
  terrorismTexts?: QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismTexts;
  terrorismImages?: QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismImages;
  static names(): { [key: string]: string } {
    return {
      terrorismOcrs: 'TerrorismOcrs',
      terrorismAudios: 'TerrorismAudios',
      terrorismVideos: 'TerrorismVideos',
      terrorismTexts: 'TerrorismTexts',
      terrorismImages: 'TerrorismImages',
    };
  }

  static types(): { [key: string]: any } {
    return {
      terrorismOcrs: QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismOcrs,
      terrorismAudios: QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismAudios,
      terrorismVideos: QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismVideos,
      terrorismTexts: QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismTexts,
      terrorismImages: QueryMCJobListResponseBodyJobListJobResultTerrorismResultTerrorismImages,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJobResult extends $tea.Model {
  suggestion?: string;
  pornResult?: QueryMCJobListResponseBodyJobListJobResultPornResult;
  adResult?: QueryMCJobListResponseBodyJobListJobResultAdResult;
  score?: string;
  logoResult?: QueryMCJobListResponseBodyJobListJobResultLogoResult;
  qrcodeResult?: QueryMCJobListResponseBodyJobListJobResultQrcodeResult;
  politicsResult?: QueryMCJobListResponseBodyJobListJobResultPoliticsResult;
  liveResult?: QueryMCJobListResponseBodyJobListJobResultLiveResult;
  abuseResult?: QueryMCJobListResponseBodyJobListJobResultAbuseResult;
  spamResult?: QueryMCJobListResponseBodyJobListJobResultSpamResult;
  contrabandResult?: QueryMCJobListResponseBodyJobListJobResultContrabandResult;
  terrorismResult?: QueryMCJobListResponseBodyJobListJobResultTerrorismResult;
  static names(): { [key: string]: string } {
    return {
      suggestion: 'Suggestion',
      pornResult: 'PornResult',
      adResult: 'AdResult',
      score: 'Score',
      logoResult: 'LogoResult',
      qrcodeResult: 'QrcodeResult',
      politicsResult: 'PoliticsResult',
      liveResult: 'LiveResult',
      abuseResult: 'AbuseResult',
      spamResult: 'SpamResult',
      contrabandResult: 'ContrabandResult',
      terrorismResult: 'TerrorismResult',
    };
  }

  static types(): { [key: string]: any } {
    return {
      suggestion: 'string',
      pornResult: QueryMCJobListResponseBodyJobListJobResultPornResult,
      adResult: QueryMCJobListResponseBodyJobListJobResultAdResult,
      score: 'string',
      logoResult: QueryMCJobListResponseBodyJobListJobResultLogoResult,
      qrcodeResult: QueryMCJobListResponseBodyJobListJobResultQrcodeResult,
      politicsResult: QueryMCJobListResponseBodyJobListJobResultPoliticsResult,
      liveResult: QueryMCJobListResponseBodyJobListJobResultLiveResult,
      abuseResult: QueryMCJobListResponseBodyJobListJobResultAbuseResult,
      spamResult: QueryMCJobListResponseBodyJobListJobResultSpamResult,
      contrabandResult: QueryMCJobListResponseBodyJobListJobResultContrabandResult,
      terrorismResult: QueryMCJobListResponseBodyJobListJobResultTerrorismResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobListJob extends $tea.Model {
  creationTime?: string;
  resultOutputFile?: string;
  result?: QueryMCJobListResponseBodyJobListJobResult;
  state?: string;
  jobId?: string;
  userData?: string;
  code?: string;
  message?: string;
  pipelineId?: string;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      resultOutputFile: 'ResultOutputFile',
      result: 'Result',
      state: 'State',
      jobId: 'JobId',
      userData: 'UserData',
      code: 'Code',
      message: 'Message',
      pipelineId: 'PipelineId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      resultOutputFile: 'string',
      result: QueryMCJobListResponseBodyJobListJobResult,
      state: 'string',
      jobId: 'string',
      userData: 'string',
      code: 'string',
      message: 'string',
      pipelineId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyJobList extends $tea.Model {
  job?: QueryMCJobListResponseBodyJobListJob[];
  static names(): { [key: string]: string } {
    return {
      job: 'Job',
    };
  }

  static types(): { [key: string]: any } {
    return {
      job: { 'type': 'array', 'itemType': QueryMCJobListResponseBodyJobListJob },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCJobListResponseBodyNonExistIds extends $tea.Model {
  string?: string[];
  static names(): { [key: string]: string } {
    return {
      string: 'String',
    };
  }

  static types(): { [key: string]: any } {
    return {
      string: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCTemplateListResponseBodyNonExistTids extends $tea.Model {
  string?: string[];
  static names(): { [key: string]: string } {
    return {
      string: 'String',
    };
  }

  static types(): { [key: string]: any } {
    return {
      string: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCTemplateListResponseBodyTemplateListTemplate extends $tea.Model {
  logo?: string;
  abuse?: string;
  state?: string;
  terrorism?: string;
  politics?: string;
  qrcode?: string;
  live?: string;
  spam?: string;
  contraband?: string;
  ad?: string;
  porn?: string;
  name?: string;
  templateId?: string;
  static names(): { [key: string]: string } {
    return {
      logo: 'Logo',
      abuse: 'Abuse',
      state: 'State',
      terrorism: 'Terrorism',
      politics: 'Politics',
      qrcode: 'Qrcode',
      live: 'Live',
      spam: 'Spam',
      contraband: 'Contraband',
      ad: 'Ad',
      porn: 'Porn',
      name: 'Name',
      templateId: 'TemplateId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      logo: 'string',
      abuse: 'string',
      state: 'string',
      terrorism: 'string',
      politics: 'string',
      qrcode: 'string',
      live: 'string',
      spam: 'string',
      contraband: 'string',
      ad: 'string',
      porn: 'string',
      name: 'string',
      templateId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMCTemplateListResponseBodyTemplateList extends $tea.Model {
  template?: QueryMCTemplateListResponseBodyTemplateListTemplate[];
  static names(): { [key: string]: string } {
    return {
      template: 'Template',
    };
  }

  static types(): { [key: string]: any } {
    return {
      template: { 'type': 'array', 'itemType': QueryMCTemplateListResponseBodyTemplateListTemplate },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMcuJobResponseBodyNonExistJobIds extends $tea.Model {
  string?: string[];
  static names(): { [key: string]: string } {
    return {
      string: 'String',
    };
  }

  static types(): { [key: string]: any } {
    return {
      string: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMcuJobResponseBodyJobResultJobTagResultTagFrameTagInfosFrameTagInfo extends $tea.Model {
  score?: string;
  category?: string;
  tag?: string;
  static names(): { [key: string]: string } {
    return {
      score: 'Score',
      category: 'Category',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      score: 'string',
      category: 'string',
      tag: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMcuJobResponseBodyJobResultJobTagResultTagFrameTagInfos extends $tea.Model {
  frameTagInfo?: QueryMcuJobResponseBodyJobResultJobTagResultTagFrameTagInfosFrameTagInfo[];
  static names(): { [key: string]: string } {
    return {
      frameTagInfo: 'FrameTagInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      frameTagInfo: { 'type': 'array', 'itemType': QueryMcuJobResponseBodyJobResultJobTagResultTagFrameTagInfosFrameTagInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMcuJobResponseBodyJobResultJobTagResultTag extends $tea.Model {
  time?: string;
  imageUrl?: string;
  frameTagInfos?: QueryMcuJobResponseBodyJobResultJobTagResultTagFrameTagInfos;
  imageId?: string;
  static names(): { [key: string]: string } {
    return {
      time: 'Time',
      imageUrl: 'ImageUrl',
      frameTagInfos: 'FrameTagInfos',
      imageId: 'ImageId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      time: 'string',
      imageUrl: 'string',
      frameTagInfos: QueryMcuJobResponseBodyJobResultJobTagResultTagFrameTagInfos,
      imageId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMcuJobResponseBodyJobResultJobTagResult extends $tea.Model {
  tag?: QueryMcuJobResponseBodyJobResultJobTagResultTag[];
  static names(): { [key: string]: string } {
    return {
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tag: { 'type': 'array', 'itemType': QueryMcuJobResponseBodyJobResultJobTagResultTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMcuJobResponseBodyJobResultJobOcrResultOcr extends $tea.Model {
  time?: string;
  imageUrl?: string;
  ocrText?: string;
  imageId?: string;
  static names(): { [key: string]: string } {
    return {
      time: 'Time',
      imageUrl: 'ImageUrl',
      ocrText: 'OcrText',
      imageId: 'ImageId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      time: 'string',
      imageUrl: 'string',
      ocrText: 'string',
      imageId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMcuJobResponseBodyJobResultJobOcrResult extends $tea.Model {
  ocr?: QueryMcuJobResponseBodyJobResultJobOcrResultOcr[];
  static names(): { [key: string]: string } {
    return {
      ocr: 'Ocr',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ocr: { 'type': 'array', 'itemType': QueryMcuJobResponseBodyJobResultJobOcrResultOcr },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMcuJobResponseBodyJobResultJobSubTaskInfoSubTask extends $tea.Model {
  type?: string;
  code?: string;
  message?: string;
  static names(): { [key: string]: string } {
    return {
      type: 'Type',
      code: 'Code',
      message: 'Message',
    };
  }

  static types(): { [key: string]: any } {
    return {
      type: 'string',
      code: 'string',
      message: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMcuJobResponseBodyJobResultJobSubTaskInfo extends $tea.Model {
  subTask?: QueryMcuJobResponseBodyJobResultJobSubTaskInfoSubTask[];
  static names(): { [key: string]: string } {
    return {
      subTask: 'SubTask',
    };
  }

  static types(): { [key: string]: any } {
    return {
      subTask: { 'type': 'array', 'itemType': QueryMcuJobResponseBodyJobResultJobSubTaskInfoSubTask },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMcuJobResponseBodyJobResultJobCategoryResultCategoriesCategory extends $tea.Model {
  score?: string;
  label?: string;
  static names(): { [key: string]: string } {
    return {
      score: 'Score',
      label: 'Label',
    };
  }

  static types(): { [key: string]: any } {
    return {
      score: 'string',
      label: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMcuJobResponseBodyJobResultJobCategoryResultCategories extends $tea.Model {
  category?: QueryMcuJobResponseBodyJobResultJobCategoryResultCategoriesCategory[];
  static names(): { [key: string]: string } {
    return {
      category: 'Category',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: { 'type': 'array', 'itemType': QueryMcuJobResponseBodyJobResultJobCategoryResultCategoriesCategory },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMcuJobResponseBodyJobResultJobCategoryResult extends $tea.Model {
  categories?: QueryMcuJobResponseBodyJobResultJobCategoryResultCategories;
  details?: string;
  static names(): { [key: string]: string } {
    return {
      categories: 'Categories',
      details: 'Details',
    };
  }

  static types(): { [key: string]: any } {
    return {
      categories: QueryMcuJobResponseBodyJobResultJobCategoryResultCategories,
      details: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMcuJobResponseBodyJobResultJobFaceResultFaceCelebritiesCelebrity extends $tea.Model {
  score?: string;
  name?: string;
  target?: string;
  static names(): { [key: string]: string } {
    return {
      score: 'Score',
      name: 'Name',
      target: 'Target',
    };
  }

  static types(): { [key: string]: any } {
    return {
      score: 'string',
      name: 'string',
      target: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMcuJobResponseBodyJobResultJobFaceResultFaceCelebrities extends $tea.Model {
  celebrity?: QueryMcuJobResponseBodyJobResultJobFaceResultFaceCelebritiesCelebrity[];
  static names(): { [key: string]: string } {
    return {
      celebrity: 'Celebrity',
    };
  }

  static types(): { [key: string]: any } {
    return {
      celebrity: { 'type': 'array', 'itemType': QueryMcuJobResponseBodyJobResultJobFaceResultFaceCelebritiesCelebrity },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMcuJobResponseBodyJobResultJobFaceResultFace extends $tea.Model {
  time?: string;
  imageUrl?: string;
  celebrities?: QueryMcuJobResponseBodyJobResultJobFaceResultFaceCelebrities;
  imageId?: string;
  static names(): { [key: string]: string } {
    return {
      time: 'Time',
      imageUrl: 'ImageUrl',
      celebrities: 'Celebrities',
      imageId: 'ImageId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      time: 'string',
      imageUrl: 'string',
      celebrities: QueryMcuJobResponseBodyJobResultJobFaceResultFaceCelebrities,
      imageId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMcuJobResponseBodyJobResultJobFaceResult extends $tea.Model {
  face?: QueryMcuJobResponseBodyJobResultJobFaceResultFace[];
  static names(): { [key: string]: string } {
    return {
      face: 'Face',
    };
  }

  static types(): { [key: string]: any } {
    return {
      face: { 'type': 'array', 'itemType': QueryMcuJobResponseBodyJobResultJobFaceResultFace },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMcuJobResponseBodyJobResultJobInput extends $tea.Model {
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMcuJobResponseBodyJobResultJobAsrResultAsrTextListAsrText extends $tea.Model {
  endTime?: string;
  startTime?: number;
  channelId?: string;
  text?: string;
  speechRate?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      startTime: 'StartTime',
      channelId: 'ChannelId',
      text: 'Text',
      speechRate: 'SpeechRate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      startTime: 'number',
      channelId: 'string',
      text: 'string',
      speechRate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMcuJobResponseBodyJobResultJobAsrResultAsrTextList extends $tea.Model {
  asrText?: QueryMcuJobResponseBodyJobResultJobAsrResultAsrTextListAsrText[];
  static names(): { [key: string]: string } {
    return {
      asrText: 'AsrText',
    };
  }

  static types(): { [key: string]: any } {
    return {
      asrText: { 'type': 'array', 'itemType': QueryMcuJobResponseBodyJobResultJobAsrResultAsrTextListAsrText },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMcuJobResponseBodyJobResultJobAsrResult extends $tea.Model {
  duration?: string;
  asrTextList?: QueryMcuJobResponseBodyJobResultJobAsrResultAsrTextList;
  static names(): { [key: string]: string } {
    return {
      duration: 'Duration',
      asrTextList: 'AsrTextList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      duration: 'string',
      asrTextList: QueryMcuJobResponseBodyJobResultJobAsrResultAsrTextList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMcuJobResponseBodyJobResultJob extends $tea.Model {
  tagResult?: QueryMcuJobResponseBodyJobResultJobTagResult;
  jobId?: string;
  ocrResult?: QueryMcuJobResponseBodyJobResultJobOcrResult;
  template?: string;
  userData?: string;
  subTaskInfo?: QueryMcuJobResponseBodyJobResultJobSubTaskInfo;
  categoryResult?: QueryMcuJobResponseBodyJobResultJobCategoryResult;
  faceResult?: QueryMcuJobResponseBodyJobResultJobFaceResult;
  templateId?: string;
  input?: QueryMcuJobResponseBodyJobResultJobInput;
  asrResult?: QueryMcuJobResponseBodyJobResultJobAsrResult;
  static names(): { [key: string]: string } {
    return {
      tagResult: 'TagResult',
      jobId: 'JobId',
      ocrResult: 'OcrResult',
      template: 'Template',
      userData: 'UserData',
      subTaskInfo: 'SubTaskInfo',
      categoryResult: 'CategoryResult',
      faceResult: 'FaceResult',
      templateId: 'TemplateId',
      input: 'Input',
      asrResult: 'AsrResult',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagResult: QueryMcuJobResponseBodyJobResultJobTagResult,
      jobId: 'string',
      ocrResult: QueryMcuJobResponseBodyJobResultJobOcrResult,
      template: 'string',
      userData: 'string',
      subTaskInfo: QueryMcuJobResponseBodyJobResultJobSubTaskInfo,
      categoryResult: QueryMcuJobResponseBodyJobResultJobCategoryResult,
      faceResult: QueryMcuJobResponseBodyJobResultJobFaceResult,
      templateId: 'string',
      input: QueryMcuJobResponseBodyJobResultJobInput,
      asrResult: QueryMcuJobResponseBodyJobResultJobAsrResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMcuJobResponseBodyJobResult extends $tea.Model {
  job?: QueryMcuJobResponseBodyJobResultJob[];
  static names(): { [key: string]: string } {
    return {
      job: 'Job',
    };
  }

  static types(): { [key: string]: any } {
    return {
      job: { 'type': 'array', 'itemType': QueryMcuJobResponseBodyJobResultJob },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMcuTemplateResponseBodyTemplatesJob extends $tea.Model {
  template?: string;
  templateId?: string;
  static names(): { [key: string]: string } {
    return {
      template: 'Template',
      templateId: 'TemplateId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      template: 'string',
      templateId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMcuTemplateResponseBodyTemplates extends $tea.Model {
  job?: QueryMcuTemplateResponseBodyTemplatesJob[];
  static names(): { [key: string]: string } {
    return {
      job: 'Job',
    };
  }

  static types(): { [key: string]: any } {
    return {
      job: { 'type': 'array', 'itemType': QueryMcuTemplateResponseBodyTemplatesJob },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResultsResult extends $tea.Model {
  suggestion?: string;
  label?: string;
  scene?: string;
  rate?: string;
  static names(): { [key: string]: string } {
    return {
      suggestion: 'Suggestion',
      label: 'Label',
      scene: 'Scene',
      rate: 'Rate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      suggestion: 'string',
      label: 'string',
      scene: 'string',
      rate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResults extends $tea.Model {
  result?: QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResultsResult[];
  static names(): { [key: string]: string } {
    return {
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      result: { 'type': 'array', 'itemType': QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResultsResult },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResult extends $tea.Model {
  object?: string;
  location?: string;
  bucket?: string;
  results?: QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResults;
  static names(): { [key: string]: string } {
    return {
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
      results: 'Results',
    };
  }

  static types(): { [key: string]: any } {
    return {
      object: 'string',
      location: 'string',
      bucket: 'string',
      results: QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResults,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResults extends $tea.Model {
  coverImageCensorResult?: QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResult[];
  static names(): { [key: string]: string } {
    return {
      coverImageCensorResult: 'CoverImageCensorResult',
    };
  }

  static types(): { [key: string]: any } {
    return {
      coverImageCensorResult: { 'type': 'array', 'itemType': QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResult },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailTitleCensorResult extends $tea.Model {
  suggestion?: string;
  label?: string;
  scene?: string;
  rate?: string;
  static names(): { [key: string]: string } {
    return {
      suggestion: 'Suggestion',
      label: 'Label',
      scene: 'Scene',
      rate: 'Rate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      suggestion: 'string',
      label: 'string',
      scene: 'string',
      rate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailInput extends $tea.Model {
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailBarrageCensorResult extends $tea.Model {
  suggestion?: string;
  label?: string;
  scene?: string;
  rate?: string;
  static names(): { [key: string]: string } {
    return {
      suggestion: 'Suggestion',
      label: 'Label',
      scene: 'Scene',
      rate: 'Rate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      suggestion: 'string',
      label: 'string',
      scene: 'string',
      rate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailDescCensorResult extends $tea.Model {
  suggestion?: string;
  label?: string;
  scene?: string;
  rate?: string;
  static names(): { [key: string]: string } {
    return {
      suggestion: 'Suggestion',
      label: 'Label',
      scene: 'Scene',
      rate: 'Rate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      suggestion: 'string',
      label: 'string',
      scene: 'string',
      rate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfigOutputFile extends $tea.Model {
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfig extends $tea.Model {
  outputFile?: QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfigOutputFile;
  videoCensor?: string;
  bizType?: string;
  static names(): { [key: string]: string } {
    return {
      outputFile: 'OutputFile',
      videoCensor: 'VideoCensor',
      bizType: 'BizType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      outputFile: QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfigOutputFile,
      videoCensor: 'string',
      bizType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult extends $tea.Model {
  suggestion?: string;
  label?: string;
  scene?: string;
  rate?: string;
  static names(): { [key: string]: string } {
    return {
      suggestion: 'Suggestion',
      label: 'Label',
      scene: 'Scene',
      rate: 'Rate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      suggestion: 'string',
      label: 'string',
      scene: 'string',
      rate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResults extends $tea.Model {
  censorResult?: QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult[];
  static names(): { [key: string]: string } {
    return {
      censorResult: 'CensorResult',
    };
  }

  static types(): { [key: string]: any } {
    return {
      censorResult: { 'type': 'array', 'itemType': QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimeline extends $tea.Model {
  timestamp?: string;
  object?: string;
  censorResults?: QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResults;
  static names(): { [key: string]: string } {
    return {
      timestamp: 'Timestamp',
      object: 'Object',
      censorResults: 'CensorResults',
    };
  }

  static types(): { [key: string]: any } {
    return {
      timestamp: 'string',
      object: 'string',
      censorResults: QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResults,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelines extends $tea.Model {
  videoTimeline?: QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimeline[];
  static names(): { [key: string]: string } {
    return {
      videoTimeline: 'VideoTimeline',
    };
  }

  static types(): { [key: string]: any } {
    return {
      videoTimeline: { 'type': 'array', 'itemType': QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimeline },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResultsCensorResult extends $tea.Model {
  suggestion?: string;
  label?: string;
  scene?: string;
  rate?: string;
  static names(): { [key: string]: string } {
    return {
      suggestion: 'Suggestion',
      label: 'Label',
      scene: 'Scene',
      rate: 'Rate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      suggestion: 'string',
      label: 'string',
      scene: 'string',
      rate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResults extends $tea.Model {
  censorResult?: QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResultsCensorResult[];
  static names(): { [key: string]: string } {
    return {
      censorResult: 'CensorResult',
    };
  }

  static types(): { [key: string]: any } {
    return {
      censorResult: { 'type': 'array', 'itemType': QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResultsCensorResult },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResult extends $tea.Model {
  videoTimelines?: QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelines;
  nextPageToken?: string;
  censorResults?: QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResults;
  static names(): { [key: string]: string } {
    return {
      videoTimelines: 'VideoTimelines',
      nextPageToken: 'NextPageToken',
      censorResults: 'CensorResults',
    };
  }

  static types(): { [key: string]: any } {
    return {
      videoTimelines: QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelines,
      nextPageToken: 'string',
      censorResults: QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResults,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetail extends $tea.Model {
  creationTime?: string;
  finishTime?: string;
  suggestion?: string;
  coverImageCensorResults?: QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResults;
  state?: string;
  titleCensorResult?: QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailTitleCensorResult;
  message?: string;
  input?: QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailInput;
  barrageCensorResult?: QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailBarrageCensorResult;
  descCensorResult?: QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailDescCensorResult;
  videoCensorConfig?: QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfig;
  jobId?: string;
  userData?: string;
  code?: string;
  vensorCensorResult?: QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResult;
  pipelineId?: string;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      finishTime: 'FinishTime',
      suggestion: 'Suggestion',
      coverImageCensorResults: 'CoverImageCensorResults',
      state: 'State',
      titleCensorResult: 'TitleCensorResult',
      message: 'Message',
      input: 'Input',
      barrageCensorResult: 'BarrageCensorResult',
      descCensorResult: 'DescCensorResult',
      videoCensorConfig: 'VideoCensorConfig',
      jobId: 'JobId',
      userData: 'UserData',
      code: 'Code',
      vensorCensorResult: 'VensorCensorResult',
      pipelineId: 'PipelineId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      finishTime: 'string',
      suggestion: 'string',
      coverImageCensorResults: QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResults,
      state: 'string',
      titleCensorResult: QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailTitleCensorResult,
      message: 'string',
      input: QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailInput,
      barrageCensorResult: QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailBarrageCensorResult,
      descCensorResult: QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailDescCensorResult,
      videoCensorConfig: QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfig,
      jobId: 'string',
      userData: 'string',
      code: 'string',
      vensorCensorResult: QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResult,
      pipelineId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResultResultsResult extends $tea.Model {
  suggestion?: string;
  label?: string;
  scene?: string;
  rate?: string;
  static names(): { [key: string]: string } {
    return {
      suggestion: 'Suggestion',
      label: 'Label',
      scene: 'Scene',
      rate: 'Rate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      suggestion: 'string',
      label: 'string',
      scene: 'string',
      rate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResultResults extends $tea.Model {
  result?: QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResultResultsResult[];
  static names(): { [key: string]: string } {
    return {
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      result: { 'type': 'array', 'itemType': QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResultResultsResult },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResult extends $tea.Model {
  object?: string;
  location?: string;
  bucket?: string;
  results?: QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResultResults;
  static names(): { [key: string]: string } {
    return {
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
      results: 'Results',
    };
  }

  static types(): { [key: string]: any } {
    return {
      object: 'string',
      location: 'string',
      bucket: 'string',
      results: QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResultResults,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResults extends $tea.Model {
  coverImageCensorResult?: QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResult[];
  static names(): { [key: string]: string } {
    return {
      coverImageCensorResult: 'CoverImageCensorResult',
    };
  }

  static types(): { [key: string]: any } {
    return {
      coverImageCensorResult: { 'type': 'array', 'itemType': QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResult },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobTitleCensorResult extends $tea.Model {
  suggestion?: string;
  label?: string;
  scene?: string;
  rate?: string;
  static names(): { [key: string]: string } {
    return {
      suggestion: 'Suggestion',
      label: 'Label',
      scene: 'Scene',
      rate: 'Rate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      suggestion: 'string',
      label: 'string',
      scene: 'string',
      rate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobInput extends $tea.Model {
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobBarrageCensorResult extends $tea.Model {
  suggestion?: string;
  label?: string;
  scene?: string;
  rate?: string;
  static names(): { [key: string]: string } {
    return {
      suggestion: 'Suggestion',
      label: 'Label',
      scene: 'Scene',
      rate: 'Rate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      suggestion: 'string',
      label: 'string',
      scene: 'string',
      rate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobDescCensorResult extends $tea.Model {
  suggestion?: string;
  label?: string;
  scene?: string;
  rate?: string;
  static names(): { [key: string]: string } {
    return {
      suggestion: 'Suggestion',
      label: 'Label',
      scene: 'Scene',
      rate: 'Rate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      suggestion: 'string',
      label: 'string',
      scene: 'string',
      rate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVideoCensorConfigOutputFile extends $tea.Model {
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVideoCensorConfig extends $tea.Model {
  outputFile?: QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVideoCensorConfigOutputFile;
  videoCensor?: string;
  bizType?: string;
  static names(): { [key: string]: string } {
    return {
      outputFile: 'OutputFile',
      videoCensor: 'VideoCensor',
      bizType: 'BizType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      outputFile: QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVideoCensorConfigOutputFile,
      videoCensor: 'string',
      bizType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult extends $tea.Model {
  suggestion?: string;
  label?: string;
  scene?: string;
  rate?: string;
  static names(): { [key: string]: string } {
    return {
      suggestion: 'Suggestion',
      label: 'Label',
      scene: 'Scene',
      rate: 'Rate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      suggestion: 'string',
      label: 'string',
      scene: 'string',
      rate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimelineCensorResults extends $tea.Model {
  censorResult?: QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult[];
  static names(): { [key: string]: string } {
    return {
      censorResult: 'CensorResult',
    };
  }

  static types(): { [key: string]: any } {
    return {
      censorResult: { 'type': 'array', 'itemType': QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimeline extends $tea.Model {
  timestamp?: string;
  object?: string;
  censorResults?: QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimelineCensorResults;
  static names(): { [key: string]: string } {
    return {
      timestamp: 'Timestamp',
      object: 'Object',
      censorResults: 'CensorResults',
    };
  }

  static types(): { [key: string]: any } {
    return {
      timestamp: 'string',
      object: 'string',
      censorResults: QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimelineCensorResults,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelines extends $tea.Model {
  videoTimeline?: QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimeline[];
  static names(): { [key: string]: string } {
    return {
      videoTimeline: 'VideoTimeline',
    };
  }

  static types(): { [key: string]: any } {
    return {
      videoTimeline: { 'type': 'array', 'itemType': QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimeline },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultCensorResultsCensorResult extends $tea.Model {
  suggestion?: string;
  label?: string;
  scene?: string;
  rate?: string;
  static names(): { [key: string]: string } {
    return {
      suggestion: 'Suggestion',
      label: 'Label',
      scene: 'Scene',
      rate: 'Rate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      suggestion: 'string',
      label: 'string',
      scene: 'string',
      rate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultCensorResults extends $tea.Model {
  censorResult?: QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultCensorResultsCensorResult[];
  static names(): { [key: string]: string } {
    return {
      censorResult: 'CensorResult',
    };
  }

  static types(): { [key: string]: any } {
    return {
      censorResult: { 'type': 'array', 'itemType': QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultCensorResultsCensorResult },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResult extends $tea.Model {
  videoTimelines?: QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelines;
  nextPageToken?: string;
  censorResults?: QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultCensorResults;
  static names(): { [key: string]: string } {
    return {
      videoTimelines: 'VideoTimelines',
      nextPageToken: 'NextPageToken',
      censorResults: 'CensorResults',
    };
  }

  static types(): { [key: string]: any } {
    return {
      videoTimelines: QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelines,
      nextPageToken: 'string',
      censorResults: QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultCensorResults,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJob extends $tea.Model {
  creationTime?: string;
  finishTime?: string;
  suggestion?: string;
  coverImageCensorResults?: QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResults;
  state?: string;
  titleCensorResult?: QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobTitleCensorResult;
  message?: string;
  input?: QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobInput;
  barrageCensorResult?: QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobBarrageCensorResult;
  descCensorResult?: QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobDescCensorResult;
  videoCensorConfig?: QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVideoCensorConfig;
  jobId?: string;
  userData?: string;
  code?: string;
  vensorCensorResult?: QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResult;
  pipelineId?: string;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      finishTime: 'FinishTime',
      suggestion: 'Suggestion',
      coverImageCensorResults: 'CoverImageCensorResults',
      state: 'State',
      titleCensorResult: 'TitleCensorResult',
      message: 'Message',
      input: 'Input',
      barrageCensorResult: 'BarrageCensorResult',
      descCensorResult: 'DescCensorResult',
      videoCensorConfig: 'VideoCensorConfig',
      jobId: 'JobId',
      userData: 'UserData',
      code: 'Code',
      vensorCensorResult: 'VensorCensorResult',
      pipelineId: 'PipelineId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      finishTime: 'string',
      suggestion: 'string',
      coverImageCensorResults: QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResults,
      state: 'string',
      titleCensorResult: QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobTitleCensorResult,
      message: 'string',
      input: QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobInput,
      barrageCensorResult: QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobBarrageCensorResult,
      descCensorResult: QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobDescCensorResult,
      videoCensorConfig: QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVideoCensorConfig,
      jobId: 'string',
      userData: 'string',
      code: 'string',
      vensorCensorResult: QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResult,
      pipelineId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaCensorJobListResponseBodyMediaCensorJobList extends $tea.Model {
  mediaCensorJob?: QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJob[];
  static names(): { [key: string]: string } {
    return {
      mediaCensorJob: 'MediaCensorJob',
    };
  }

  static types(): { [key: string]: any } {
    return {
      mediaCensorJob: { 'type': 'array', 'itemType': QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJob },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaCensorJobListResponseBodyNonExistIds extends $tea.Model {
  string?: string[];
  static names(): { [key: string]: string } {
    return {
      string: 'String',
    };
  }

  static types(): { [key: string]: any } {
    return {
      string: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultSensitivesSensitive extends $tea.Model {
  score?: string;
  name?: string;
  target?: string;
  static names(): { [key: string]: string } {
    return {
      score: 'Score',
      name: 'Name',
      target: 'Target',
    };
  }

  static types(): { [key: string]: any } {
    return {
      score: 'string',
      name: 'string',
      target: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultSensitives extends $tea.Model {
  sensitive?: QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultSensitivesSensitive[];
  static names(): { [key: string]: string } {
    return {
      sensitive: 'Sensitive',
    };
  }

  static types(): { [key: string]: any } {
    return {
      sensitive: { 'type': 'array', 'itemType': QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultSensitivesSensitive },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultPoliticiansPolitician extends $tea.Model {
  score?: string;
  name?: string;
  target?: string;
  static names(): { [key: string]: string } {
    return {
      score: 'Score',
      name: 'Name',
      target: 'Target',
    };
  }

  static types(): { [key: string]: any } {
    return {
      score: 'string',
      name: 'string',
      target: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultPoliticians extends $tea.Model {
  politician?: QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultPoliticiansPolitician[];
  static names(): { [key: string]: string } {
    return {
      politician: 'Politician',
    };
  }

  static types(): { [key: string]: any } {
    return {
      politician: { 'type': 'array', 'itemType': QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultPoliticiansPolitician },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultFrameTags extends $tea.Model {
  string?: string[];
  static names(): { [key: string]: string } {
    return {
      string: 'String',
    };
  }

  static types(): { [key: string]: any } {
    return {
      string: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultCustomsCustomClipsClip extends $tea.Model {
  endTime?: string;
  minScore?: string;
  startTime?: string;
  avgScore?: string;
  maxScore?: string;
  endTarget?: string;
  startTarget?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      minScore: 'MinScore',
      startTime: 'StartTime',
      avgScore: 'AvgScore',
      maxScore: 'MaxScore',
      endTarget: 'EndTarget',
      startTarget: 'StartTarget',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      minScore: 'string',
      startTime: 'string',
      avgScore: 'string',
      maxScore: 'string',
      endTarget: 'string',
      startTarget: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultCustomsCustomClips extends $tea.Model {
  clip?: QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultCustomsCustomClipsClip[];
  static names(): { [key: string]: string } {
    return {
      clip: 'Clip',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clip: { 'type': 'array', 'itemType': QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultCustomsCustomClipsClip },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultCustomsCustom extends $tea.Model {
  name?: string;
  clips?: QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultCustomsCustomClips;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      clips: 'Clips',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      clips: QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultCustomsCustomClips,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultCustoms extends $tea.Model {
  custom?: QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultCustomsCustom[];
  static names(): { [key: string]: string } {
    return {
      custom: 'Custom',
    };
  }

  static types(): { [key: string]: any } {
    return {
      custom: { 'type': 'array', 'itemType': QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultCustomsCustom },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultFrameTagInfosFrameTagInfo extends $tea.Model {
  score?: string;
  category?: string;
  tag?: string;
  static names(): { [key: string]: string } {
    return {
      score: 'Score',
      category: 'Category',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      score: 'string',
      category: 'string',
      tag: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultFrameTagInfos extends $tea.Model {
  frameTagInfo?: QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultFrameTagInfosFrameTagInfo[];
  static names(): { [key: string]: string } {
    return {
      frameTagInfo: 'FrameTagInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      frameTagInfo: { 'type': 'array', 'itemType': QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultFrameTagInfosFrameTagInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultCelebritiesCelebrity extends $tea.Model {
  score?: string;
  name?: string;
  target?: string;
  static names(): { [key: string]: string } {
    return {
      score: 'Score',
      name: 'Name',
      target: 'Target',
    };
  }

  static types(): { [key: string]: any } {
    return {
      score: 'string',
      name: 'string',
      target: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultCelebrities extends $tea.Model {
  celebrity?: QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultCelebritiesCelebrity[];
  static names(): { [key: string]: string } {
    return {
      celebrity: 'Celebrity',
    };
  }

  static types(): { [key: string]: any } {
    return {
      celebrity: { 'type': 'array', 'itemType': QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultCelebritiesCelebrity },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResult extends $tea.Model {
  time?: string;
  sensitives?: QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultSensitives;
  politicians?: QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultPoliticians;
  frameTags?: QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultFrameTags;
  imageUrl?: string;
  customs?: QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultCustoms;
  frameTagInfos?: QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultFrameTagInfos;
  celebrities?: QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultCelebrities;
  ocrText?: string;
  static names(): { [key: string]: string } {
    return {
      time: 'Time',
      sensitives: 'Sensitives',
      politicians: 'Politicians',
      frameTags: 'FrameTags',
      imageUrl: 'ImageUrl',
      customs: 'Customs',
      frameTagInfos: 'FrameTagInfos',
      celebrities: 'Celebrities',
      ocrText: 'OcrText',
    };
  }

  static types(): { [key: string]: any } {
    return {
      time: 'string',
      sensitives: QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultSensitives,
      politicians: QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultPoliticians,
      frameTags: QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultFrameTags,
      imageUrl: 'string',
      customs: QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultCustoms,
      frameTagInfos: QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultFrameTagInfos,
      celebrities: QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResultCelebrities,
      ocrText: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResults extends $tea.Model {
  mediaDetailRecgResult?: QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResult[];
  static names(): { [key: string]: string } {
    return {
      mediaDetailRecgResult: 'MediaDetailRecgResult',
    };
  }

  static types(): { [key: string]: any } {
    return {
      mediaDetailRecgResult: { 'type': 'array', 'itemType': QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResultsMediaDetailRecgResult },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultTags extends $tea.Model {
  string?: string[];
  static names(): { [key: string]: string } {
    return {
      string: 'String',
    };
  }

  static types(): { [key: string]: any } {
    return {
      string: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResult extends $tea.Model {
  status?: string;
  mediaDetailRecgResults?: QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResults;
  tags?: QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultTags;
  static names(): { [key: string]: string } {
    return {
      status: 'Status',
      mediaDetailRecgResults: 'MediaDetailRecgResults',
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      status: 'string',
      mediaDetailRecgResults: QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultMediaDetailRecgResults,
      tags: QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResultTags,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaDetailJobListResponseBodyJobListJobMediaDetailConfigOutputFile extends $tea.Model {
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaDetailJobListResponseBodyJobListJobMediaDetailConfig extends $tea.Model {
  outputFile?: QueryMediaDetailJobListResponseBodyJobListJobMediaDetailConfigOutputFile;
  scenario?: string;
  detailType?: string;
  static names(): { [key: string]: string } {
    return {
      outputFile: 'OutputFile',
      scenario: 'Scenario',
      detailType: 'DetailType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      outputFile: QueryMediaDetailJobListResponseBodyJobListJobMediaDetailConfigOutputFile,
      scenario: 'string',
      detailType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaDetailJobListResponseBodyJobListJobInput extends $tea.Model {
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaDetailJobListResponseBodyJobListJob extends $tea.Model {
  creationTime?: string;
  state?: string;
  userData?: string;
  code?: string;
  mediaDetailResult?: QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResult;
  message?: string;
  mediaDetailConfig?: QueryMediaDetailJobListResponseBodyJobListJobMediaDetailConfig;
  pipelineId?: string;
  input?: QueryMediaDetailJobListResponseBodyJobListJobInput;
  id?: string;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      state: 'State',
      userData: 'UserData',
      code: 'Code',
      mediaDetailResult: 'MediaDetailResult',
      message: 'Message',
      mediaDetailConfig: 'MediaDetailConfig',
      pipelineId: 'PipelineId',
      input: 'Input',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      state: 'string',
      userData: 'string',
      code: 'string',
      mediaDetailResult: QueryMediaDetailJobListResponseBodyJobListJobMediaDetailResult,
      message: 'string',
      mediaDetailConfig: QueryMediaDetailJobListResponseBodyJobListJobMediaDetailConfig,
      pipelineId: 'string',
      input: QueryMediaDetailJobListResponseBodyJobListJobInput,
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaDetailJobListResponseBodyJobList extends $tea.Model {
  job?: QueryMediaDetailJobListResponseBodyJobListJob[];
  static names(): { [key: string]: string } {
    return {
      job: 'Job',
    };
  }

  static types(): { [key: string]: any } {
    return {
      job: { 'type': 'array', 'itemType': QueryMediaDetailJobListResponseBodyJobListJob },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaDetailJobListResponseBodyNonExistIds extends $tea.Model {
  string?: string[];
  static names(): { [key: string]: string } {
    return {
      string: 'String',
    };
  }

  static types(): { [key: string]: any } {
    return {
      string: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaFpDeleteJobListResponseBodyNonExistIds extends $tea.Model {
  string?: string[];
  static names(): { [key: string]: string } {
    return {
      string: 'String',
    };
  }

  static types(): { [key: string]: any } {
    return {
      string: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaFpDeleteJobListResponseBodyMediaFpDeleteJobListMediaFpDeleteJob extends $tea.Model {
  creationTime?: string;
  finishTime?: string;
  primaryKey?: string;
  state?: string;
  userData?: string;
  code?: string;
  message?: string;
  pipelineId?: string;
  fpDBId?: string;
  id?: string;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      finishTime: 'FinishTime',
      primaryKey: 'PrimaryKey',
      state: 'State',
      userData: 'UserData',
      code: 'Code',
      message: 'Message',
      pipelineId: 'PipelineId',
      fpDBId: 'FpDBId',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      finishTime: 'string',
      primaryKey: 'string',
      state: 'string',
      userData: 'string',
      code: 'string',
      message: 'string',
      pipelineId: 'string',
      fpDBId: 'string',
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaFpDeleteJobListResponseBodyMediaFpDeleteJobList extends $tea.Model {
  mediaFpDeleteJob?: QueryMediaFpDeleteJobListResponseBodyMediaFpDeleteJobListMediaFpDeleteJob[];
  static names(): { [key: string]: string } {
    return {
      mediaFpDeleteJob: 'MediaFpDeleteJob',
    };
  }

  static types(): { [key: string]: any } {
    return {
      mediaFpDeleteJob: { 'type': 'array', 'itemType': QueryMediaFpDeleteJobListResponseBodyMediaFpDeleteJobListMediaFpDeleteJob },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaInfoJobListResponseBodyNonExistMediaInfoJobIds extends $tea.Model {
  string?: string[];
  static names(): { [key: string]: string } {
    return {
      string: 'String',
    };
  }

  static types(): { [key: string]: any } {
    return {
      string: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobInput extends $tea.Model {
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobMNSMessageResult extends $tea.Model {
  messageId?: string;
  errorMessage?: string;
  errorCode?: string;
  static names(): { [key: string]: string } {
    return {
      messageId: 'MessageId',
      errorMessage: 'ErrorMessage',
      errorCode: 'ErrorCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      messageId: 'string',
      errorMessage: 'string',
      errorCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost extends $tea.Model {
  preloadTime?: string;
  avgBitrate?: string;
  costBandwidth?: string;
  static names(): { [key: string]: string } {
    return {
      preloadTime: 'PreloadTime',
      avgBitrate: 'AvgBitrate',
      costBandwidth: 'CostBandwidth',
    };
  }

  static types(): { [key: string]: any } {
    return {
      preloadTime: 'string',
      avgBitrate: 'string',
      costBandwidth: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamListVideoStream extends $tea.Model {
  sar?: string;
  height?: string;
  codecTagString?: string;
  networkCost?: QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost;
  width?: string;
  index?: string;
  timebase?: string;
  avgFPS?: string;
  pixFmt?: string;
  lang?: string;
  codecLongName?: string;
  numFrames?: string;
  rotate?: string;
  bitrate?: string;
  hasBFrames?: string;
  profile?: string;
  startTime?: string;
  dar?: string;
  codecName?: string;
  duration?: string;
  fps?: string;
  codecTag?: string;
  codecTimeBase?: string;
  level?: string;
  static names(): { [key: string]: string } {
    return {
      sar: 'Sar',
      height: 'Height',
      codecTagString: 'CodecTagString',
      networkCost: 'NetworkCost',
      width: 'Width',
      index: 'Index',
      timebase: 'Timebase',
      avgFPS: 'AvgFPS',
      pixFmt: 'PixFmt',
      lang: 'Lang',
      codecLongName: 'CodecLongName',
      numFrames: 'NumFrames',
      rotate: 'Rotate',
      bitrate: 'Bitrate',
      hasBFrames: 'HasBFrames',
      profile: 'Profile',
      startTime: 'StartTime',
      dar: 'Dar',
      codecName: 'CodecName',
      duration: 'Duration',
      fps: 'Fps',
      codecTag: 'CodecTag',
      codecTimeBase: 'CodecTimeBase',
      level: 'Level',
    };
  }

  static types(): { [key: string]: any } {
    return {
      sar: 'string',
      height: 'string',
      codecTagString: 'string',
      networkCost: QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost,
      width: 'string',
      index: 'string',
      timebase: 'string',
      avgFPS: 'string',
      pixFmt: 'string',
      lang: 'string',
      codecLongName: 'string',
      numFrames: 'string',
      rotate: 'string',
      bitrate: 'string',
      hasBFrames: 'string',
      profile: 'string',
      startTime: 'string',
      dar: 'string',
      codecName: 'string',
      duration: 'string',
      fps: 'string',
      codecTag: 'string',
      codecTimeBase: 'string',
      level: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamList extends $tea.Model {
  videoStream?: QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamListVideoStream[];
  static names(): { [key: string]: string } {
    return {
      videoStream: 'VideoStream',
    };
  }

  static types(): { [key: string]: any } {
    return {
      videoStream: { 'type': 'array', 'itemType': QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamListVideoStream },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsAudioStreamListAudioStream extends $tea.Model {
  timebase?: string;
  index?: string;
  sampleFmt?: string;
  channelLayout?: string;
  lang?: string;
  samplerate?: string;
  codecLongName?: string;
  channels?: string;
  numFrames?: string;
  bitrate?: string;
  codecTagString?: string;
  startTime?: string;
  codecName?: string;
  duration?: string;
  codecTag?: string;
  codecTimeBase?: string;
  static names(): { [key: string]: string } {
    return {
      timebase: 'Timebase',
      index: 'Index',
      sampleFmt: 'SampleFmt',
      channelLayout: 'ChannelLayout',
      lang: 'Lang',
      samplerate: 'Samplerate',
      codecLongName: 'CodecLongName',
      channels: 'Channels',
      numFrames: 'NumFrames',
      bitrate: 'Bitrate',
      codecTagString: 'CodecTagString',
      startTime: 'StartTime',
      codecName: 'CodecName',
      duration: 'Duration',
      codecTag: 'CodecTag',
      codecTimeBase: 'CodecTimeBase',
    };
  }

  static types(): { [key: string]: any } {
    return {
      timebase: 'string',
      index: 'string',
      sampleFmt: 'string',
      channelLayout: 'string',
      lang: 'string',
      samplerate: 'string',
      codecLongName: 'string',
      channels: 'string',
      numFrames: 'string',
      bitrate: 'string',
      codecTagString: 'string',
      startTime: 'string',
      codecName: 'string',
      duration: 'string',
      codecTag: 'string',
      codecTimeBase: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsAudioStreamList extends $tea.Model {
  audioStream?: QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsAudioStreamListAudioStream[];
  static names(): { [key: string]: string } {
    return {
      audioStream: 'AudioStream',
    };
  }

  static types(): { [key: string]: any } {
    return {
      audioStream: { 'type': 'array', 'itemType': QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsAudioStreamListAudioStream },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsSubtitleStreamListSubtitleStream extends $tea.Model {
  timebase?: string;
  index?: string;
  startTime?: string;
  codecName?: string;
  lang?: string;
  codecLongName?: string;
  duration?: string;
  codecTag?: string;
  codecTimeBase?: string;
  codecTagString?: string;
  static names(): { [key: string]: string } {
    return {
      timebase: 'Timebase',
      index: 'Index',
      startTime: 'StartTime',
      codecName: 'CodecName',
      lang: 'Lang',
      codecLongName: 'CodecLongName',
      duration: 'Duration',
      codecTag: 'CodecTag',
      codecTimeBase: 'CodecTimeBase',
      codecTagString: 'CodecTagString',
    };
  }

  static types(): { [key: string]: any } {
    return {
      timebase: 'string',
      index: 'string',
      startTime: 'string',
      codecName: 'string',
      lang: 'string',
      codecLongName: 'string',
      duration: 'string',
      codecTag: 'string',
      codecTimeBase: 'string',
      codecTagString: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsSubtitleStreamList extends $tea.Model {
  subtitleStream?: QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsSubtitleStreamListSubtitleStream[];
  static names(): { [key: string]: string } {
    return {
      subtitleStream: 'SubtitleStream',
    };
  }

  static types(): { [key: string]: any } {
    return {
      subtitleStream: { 'type': 'array', 'itemType': QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsSubtitleStreamListSubtitleStream },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreams extends $tea.Model {
  videoStreamList?: QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamList;
  audioStreamList?: QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsAudioStreamList;
  subtitleStreamList?: QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsSubtitleStreamList;
  static names(): { [key: string]: string } {
    return {
      videoStreamList: 'VideoStreamList',
      audioStreamList: 'AudioStreamList',
      subtitleStreamList: 'SubtitleStreamList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      videoStreamList: QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamList,
      audioStreamList: QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsAudioStreamList,
      subtitleStreamList: QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsSubtitleStreamList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesFormat extends $tea.Model {
  startTime?: string;
  numPrograms?: string;
  size?: string;
  numStreams?: string;
  formatLongName?: string;
  duration?: string;
  bitrate?: string;
  formatName?: string;
  static names(): { [key: string]: string } {
    return {
      startTime: 'StartTime',
      numPrograms: 'NumPrograms',
      size: 'Size',
      numStreams: 'NumStreams',
      formatLongName: 'FormatLongName',
      duration: 'Duration',
      bitrate: 'Bitrate',
      formatName: 'FormatName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      startTime: 'string',
      numPrograms: 'string',
      size: 'string',
      numStreams: 'string',
      formatLongName: 'string',
      duration: 'string',
      bitrate: 'string',
      formatName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobProperties extends $tea.Model {
  width?: string;
  height?: string;
  duration?: string;
  fps?: string;
  bitrate?: string;
  fileFormat?: string;
  streams?: QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreams;
  format?: QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesFormat;
  fileSize?: string;
  static names(): { [key: string]: string } {
    return {
      width: 'Width',
      height: 'Height',
      duration: 'Duration',
      fps: 'Fps',
      bitrate: 'Bitrate',
      fileFormat: 'FileFormat',
      streams: 'Streams',
      format: 'Format',
      fileSize: 'FileSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      width: 'string',
      height: 'string',
      duration: 'string',
      fps: 'string',
      bitrate: 'string',
      fileFormat: 'string',
      streams: QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreams,
      format: QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesFormat,
      fileSize: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJob extends $tea.Model {
  creationTime?: string;
  state?: string;
  jobId?: string;
  userData?: string;
  code?: string;
  message?: string;
  pipelineId?: string;
  async?: boolean;
  input?: QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobInput;
  MNSMessageResult?: QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobMNSMessageResult;
  properties?: QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobProperties;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      state: 'State',
      jobId: 'JobId',
      userData: 'UserData',
      code: 'Code',
      message: 'Message',
      pipelineId: 'PipelineId',
      async: 'Async',
      input: 'Input',
      MNSMessageResult: 'MNSMessageResult',
      properties: 'Properties',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      state: 'string',
      jobId: 'string',
      userData: 'string',
      code: 'string',
      message: 'string',
      pipelineId: 'string',
      async: 'boolean',
      input: QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobInput,
      MNSMessageResult: QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobMNSMessageResult,
      properties: QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobProperties,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaInfoJobListResponseBodyMediaInfoJobList extends $tea.Model {
  mediaInfoJob?: QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJob[];
  static names(): { [key: string]: string } {
    return {
      mediaInfoJob: 'MediaInfoJob',
    };
  }

  static types(): { [key: string]: any } {
    return {
      mediaInfoJob: { 'type': 'array', 'itemType': QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJob },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaListResponseBodyNonExistMediaIds extends $tea.Model {
  mediaId?: string[];
  static names(): { [key: string]: string } {
    return {
      mediaId: 'MediaId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      mediaId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaListResponseBodyMediaListMediaTags extends $tea.Model {
  tag?: string[];
  static names(): { [key: string]: string } {
    return {
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tag: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaListResponseBodyMediaListMediaPlayListPlayFile extends $tea.Model {
  state?: string;
  URL?: string;
  static names(): { [key: string]: string } {
    return {
      state: 'State',
      URL: 'URL',
    };
  }

  static types(): { [key: string]: any } {
    return {
      state: 'string',
      URL: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaListResponseBodyMediaListMediaPlayListPlay extends $tea.Model {
  encryption?: string;
  height?: string;
  bitrate?: string;
  file?: QueryMediaListResponseBodyMediaListMediaPlayListPlayFile;
  mediaWorkflowId?: string;
  width?: string;
  size?: string;
  fps?: string;
  duration?: string;
  activityName?: string;
  format?: string;
  mediaWorkflowName?: string;
  static names(): { [key: string]: string } {
    return {
      encryption: 'Encryption',
      height: 'Height',
      bitrate: 'Bitrate',
      file: 'File',
      mediaWorkflowId: 'MediaWorkflowId',
      width: 'Width',
      size: 'Size',
      fps: 'Fps',
      duration: 'Duration',
      activityName: 'ActivityName',
      format: 'Format',
      mediaWorkflowName: 'MediaWorkflowName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      encryption: 'string',
      height: 'string',
      bitrate: 'string',
      file: QueryMediaListResponseBodyMediaListMediaPlayListPlayFile,
      mediaWorkflowId: 'string',
      width: 'string',
      size: 'string',
      fps: 'string',
      duration: 'string',
      activityName: 'string',
      format: 'string',
      mediaWorkflowName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaListResponseBodyMediaListMediaPlayList extends $tea.Model {
  play?: QueryMediaListResponseBodyMediaListMediaPlayListPlay[];
  static names(): { [key: string]: string } {
    return {
      play: 'Play',
    };
  }

  static types(): { [key: string]: any } {
    return {
      play: { 'type': 'array', 'itemType': QueryMediaListResponseBodyMediaListMediaPlayListPlay },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaListResponseBodyMediaListMediaFile extends $tea.Model {
  state?: string;
  URL?: string;
  static names(): { [key: string]: string } {
    return {
      state: 'State',
      URL: 'URL',
    };
  }

  static types(): { [key: string]: any } {
    return {
      state: 'string',
      URL: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaListResponseBodyMediaListMediaSummaryListSummaryFile extends $tea.Model {
  state?: string;
  URL?: string;
  static names(): { [key: string]: string } {
    return {
      state: 'State',
      URL: 'URL',
    };
  }

  static types(): { [key: string]: any } {
    return {
      state: 'string',
      URL: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaListResponseBodyMediaListMediaSummaryListSummary extends $tea.Model {
  type?: string;
  mediaWorkflowId?: string;
  activityName?: string;
  mediaWorkflowName?: string;
  file?: QueryMediaListResponseBodyMediaListMediaSummaryListSummaryFile;
  static names(): { [key: string]: string } {
    return {
      type: 'Type',
      mediaWorkflowId: 'MediaWorkflowId',
      activityName: 'ActivityName',
      mediaWorkflowName: 'MediaWorkflowName',
      file: 'File',
    };
  }

  static types(): { [key: string]: any } {
    return {
      type: 'string',
      mediaWorkflowId: 'string',
      activityName: 'string',
      mediaWorkflowName: 'string',
      file: QueryMediaListResponseBodyMediaListMediaSummaryListSummaryFile,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaListResponseBodyMediaListMediaSummaryList extends $tea.Model {
  summary?: QueryMediaListResponseBodyMediaListMediaSummaryListSummary[];
  static names(): { [key: string]: string } {
    return {
      summary: 'Summary',
    };
  }

  static types(): { [key: string]: any } {
    return {
      summary: { 'type': 'array', 'itemType': QueryMediaListResponseBodyMediaListMediaSummaryListSummary },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStreamNetworkCost extends $tea.Model {
  preloadTime?: string;
  avgBitrate?: string;
  costBandwidth?: string;
  static names(): { [key: string]: string } {
    return {
      preloadTime: 'PreloadTime',
      avgBitrate: 'AvgBitrate',
      costBandwidth: 'CostBandwidth',
    };
  }

  static types(): { [key: string]: any } {
    return {
      preloadTime: 'string',
      avgBitrate: 'string',
      costBandwidth: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStream extends $tea.Model {
  sar?: string;
  height?: string;
  codecTagString?: string;
  networkCost?: QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStreamNetworkCost;
  width?: string;
  index?: string;
  timebase?: string;
  avgFPS?: string;
  pixFmt?: string;
  lang?: string;
  codecLongName?: string;
  numFrames?: string;
  rotate?: string;
  bitrate?: string;
  hasBFrames?: string;
  profile?: string;
  startTime?: string;
  dar?: string;
  codecName?: string;
  duration?: string;
  fps?: string;
  codecTag?: string;
  codecTimeBase?: string;
  level?: string;
  static names(): { [key: string]: string } {
    return {
      sar: 'Sar',
      height: 'Height',
      codecTagString: 'CodecTagString',
      networkCost: 'NetworkCost',
      width: 'Width',
      index: 'Index',
      timebase: 'Timebase',
      avgFPS: 'AvgFPS',
      pixFmt: 'PixFmt',
      lang: 'Lang',
      codecLongName: 'CodecLongName',
      numFrames: 'NumFrames',
      rotate: 'Rotate',
      bitrate: 'Bitrate',
      hasBFrames: 'HasBFrames',
      profile: 'Profile',
      startTime: 'StartTime',
      dar: 'Dar',
      codecName: 'CodecName',
      duration: 'Duration',
      fps: 'Fps',
      codecTag: 'CodecTag',
      codecTimeBase: 'CodecTimeBase',
      level: 'Level',
    };
  }

  static types(): { [key: string]: any } {
    return {
      sar: 'string',
      height: 'string',
      codecTagString: 'string',
      networkCost: QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStreamNetworkCost,
      width: 'string',
      index: 'string',
      timebase: 'string',
      avgFPS: 'string',
      pixFmt: 'string',
      lang: 'string',
      codecLongName: 'string',
      numFrames: 'string',
      rotate: 'string',
      bitrate: 'string',
      hasBFrames: 'string',
      profile: 'string',
      startTime: 'string',
      dar: 'string',
      codecName: 'string',
      duration: 'string',
      fps: 'string',
      codecTag: 'string',
      codecTimeBase: 'string',
      level: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamList extends $tea.Model {
  videoStream?: QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStream[];
  static names(): { [key: string]: string } {
    return {
      videoStream: 'VideoStream',
    };
  }

  static types(): { [key: string]: any } {
    return {
      videoStream: { 'type': 'array', 'itemType': QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStream },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsAudioStreamListAudioStream extends $tea.Model {
  timebase?: string;
  index?: string;
  sampleFmt?: string;
  channelLayout?: string;
  lang?: string;
  samplerate?: string;
  codecLongName?: string;
  channels?: string;
  numFrames?: string;
  bitrate?: string;
  codecTagString?: string;
  startTime?: string;
  codecName?: string;
  duration?: string;
  codecTag?: string;
  codecTimeBase?: string;
  static names(): { [key: string]: string } {
    return {
      timebase: 'Timebase',
      index: 'Index',
      sampleFmt: 'SampleFmt',
      channelLayout: 'ChannelLayout',
      lang: 'Lang',
      samplerate: 'Samplerate',
      codecLongName: 'CodecLongName',
      channels: 'Channels',
      numFrames: 'NumFrames',
      bitrate: 'Bitrate',
      codecTagString: 'CodecTagString',
      startTime: 'StartTime',
      codecName: 'CodecName',
      duration: 'Duration',
      codecTag: 'CodecTag',
      codecTimeBase: 'CodecTimeBase',
    };
  }

  static types(): { [key: string]: any } {
    return {
      timebase: 'string',
      index: 'string',
      sampleFmt: 'string',
      channelLayout: 'string',
      lang: 'string',
      samplerate: 'string',
      codecLongName: 'string',
      channels: 'string',
      numFrames: 'string',
      bitrate: 'string',
      codecTagString: 'string',
      startTime: 'string',
      codecName: 'string',
      duration: 'string',
      codecTag: 'string',
      codecTimeBase: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsAudioStreamList extends $tea.Model {
  audioStream?: QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsAudioStreamListAudioStream[];
  static names(): { [key: string]: string } {
    return {
      audioStream: 'AudioStream',
    };
  }

  static types(): { [key: string]: any } {
    return {
      audioStream: { 'type': 'array', 'itemType': QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsAudioStreamListAudioStream },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamListSubtitleStream extends $tea.Model {
  index?: string;
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      index: 'Index',
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      index: 'string',
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamList extends $tea.Model {
  subtitleStream?: QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamListSubtitleStream[];
  static names(): { [key: string]: string } {
    return {
      subtitleStream: 'SubtitleStream',
    };
  }

  static types(): { [key: string]: any } {
    return {
      subtitleStream: { 'type': 'array', 'itemType': QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamListSubtitleStream },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaListResponseBodyMediaListMediaMediaInfoStreams extends $tea.Model {
  videoStreamList?: QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamList;
  audioStreamList?: QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsAudioStreamList;
  subtitleStreamList?: QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamList;
  static names(): { [key: string]: string } {
    return {
      videoStreamList: 'VideoStreamList',
      audioStreamList: 'AudioStreamList',
      subtitleStreamList: 'SubtitleStreamList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      videoStreamList: QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamList,
      audioStreamList: QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsAudioStreamList,
      subtitleStreamList: QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaListResponseBodyMediaListMediaMediaInfoFormat extends $tea.Model {
  startTime?: string;
  numPrograms?: string;
  size?: string;
  numStreams?: string;
  formatLongName?: string;
  duration?: string;
  bitrate?: string;
  formatName?: string;
  static names(): { [key: string]: string } {
    return {
      startTime: 'StartTime',
      numPrograms: 'NumPrograms',
      size: 'Size',
      numStreams: 'NumStreams',
      formatLongName: 'FormatLongName',
      duration: 'Duration',
      bitrate: 'Bitrate',
      formatName: 'FormatName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      startTime: 'string',
      numPrograms: 'string',
      size: 'string',
      numStreams: 'string',
      formatLongName: 'string',
      duration: 'string',
      bitrate: 'string',
      formatName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaListResponseBodyMediaListMediaMediaInfo extends $tea.Model {
  streams?: QueryMediaListResponseBodyMediaListMediaMediaInfoStreams;
  format?: QueryMediaListResponseBodyMediaListMediaMediaInfoFormat;
  static names(): { [key: string]: string } {
    return {
      streams: 'Streams',
      format: 'Format',
    };
  }

  static types(): { [key: string]: any } {
    return {
      streams: QueryMediaListResponseBodyMediaListMediaMediaInfoStreams,
      format: QueryMediaListResponseBodyMediaListMediaMediaInfoFormat,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaListResponseBodyMediaListMediaSnapshotListSnapshotFile extends $tea.Model {
  state?: string;
  URL?: string;
  static names(): { [key: string]: string } {
    return {
      state: 'State',
      URL: 'URL',
    };
  }

  static types(): { [key: string]: any } {
    return {
      state: 'string',
      URL: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaListResponseBodyMediaListMediaSnapshotListSnapshot extends $tea.Model {
  type?: string;
  mediaWorkflowId?: string;
  activityName?: string;
  count?: string;
  mediaWorkflowName?: string;
  file?: QueryMediaListResponseBodyMediaListMediaSnapshotListSnapshotFile;
  static names(): { [key: string]: string } {
    return {
      type: 'Type',
      mediaWorkflowId: 'MediaWorkflowId',
      activityName: 'ActivityName',
      count: 'Count',
      mediaWorkflowName: 'MediaWorkflowName',
      file: 'File',
    };
  }

  static types(): { [key: string]: any } {
    return {
      type: 'string',
      mediaWorkflowId: 'string',
      activityName: 'string',
      count: 'string',
      mediaWorkflowName: 'string',
      file: QueryMediaListResponseBodyMediaListMediaSnapshotListSnapshotFile,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaListResponseBodyMediaListMediaSnapshotList extends $tea.Model {
  snapshot?: QueryMediaListResponseBodyMediaListMediaSnapshotListSnapshot[];
  static names(): { [key: string]: string } {
    return {
      snapshot: 'Snapshot',
    };
  }

  static types(): { [key: string]: any } {
    return {
      snapshot: { 'type': 'array', 'itemType': QueryMediaListResponseBodyMediaListMediaSnapshotListSnapshot },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaListResponseBodyMediaListMediaRunIdList extends $tea.Model {
  runId?: string[];
  static names(): { [key: string]: string } {
    return {
      runId: 'RunId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      runId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaListResponseBodyMediaListMedia extends $tea.Model {
  creationTime?: string;
  cateId?: number;
  height?: string;
  censorState?: string;
  tags?: QueryMediaListResponseBodyMediaListMediaTags;
  playList?: QueryMediaListResponseBodyMediaListMediaPlayList;
  bitrate?: string;
  mediaId?: string;
  file?: QueryMediaListResponseBodyMediaListMediaFile;
  summaryList?: QueryMediaListResponseBodyMediaListMediaSummaryList;
  publishState?: string;
  mediaInfo?: QueryMediaListResponseBodyMediaListMediaMediaInfo;
  description?: string;
  size?: string;
  width?: string;
  coverURL?: string;
  snapshotList?: QueryMediaListResponseBodyMediaListMediaSnapshotList;
  runIdList?: QueryMediaListResponseBodyMediaListMediaRunIdList;
  duration?: string;
  fps?: string;
  title?: string;
  format?: string;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      cateId: 'CateId',
      height: 'Height',
      censorState: 'CensorState',
      tags: 'Tags',
      playList: 'PlayList',
      bitrate: 'Bitrate',
      mediaId: 'MediaId',
      file: 'File',
      summaryList: 'SummaryList',
      publishState: 'PublishState',
      mediaInfo: 'MediaInfo',
      description: 'Description',
      size: 'Size',
      width: 'Width',
      coverURL: 'CoverURL',
      snapshotList: 'SnapshotList',
      runIdList: 'RunIdList',
      duration: 'Duration',
      fps: 'Fps',
      title: 'Title',
      format: 'Format',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      cateId: 'number',
      height: 'string',
      censorState: 'string',
      tags: QueryMediaListResponseBodyMediaListMediaTags,
      playList: QueryMediaListResponseBodyMediaListMediaPlayList,
      bitrate: 'string',
      mediaId: 'string',
      file: QueryMediaListResponseBodyMediaListMediaFile,
      summaryList: QueryMediaListResponseBodyMediaListMediaSummaryList,
      publishState: 'string',
      mediaInfo: QueryMediaListResponseBodyMediaListMediaMediaInfo,
      description: 'string',
      size: 'string',
      width: 'string',
      coverURL: 'string',
      snapshotList: QueryMediaListResponseBodyMediaListMediaSnapshotList,
      runIdList: QueryMediaListResponseBodyMediaListMediaRunIdList,
      duration: 'string',
      fps: 'string',
      title: 'string',
      format: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaListResponseBodyMediaList extends $tea.Model {
  media?: QueryMediaListResponseBodyMediaListMedia[];
  static names(): { [key: string]: string } {
    return {
      media: 'Media',
    };
  }

  static types(): { [key: string]: any } {
    return {
      media: { 'type': 'array', 'itemType': QueryMediaListResponseBodyMediaListMedia },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaListByURLResponseBodyMediaListMediaTags extends $tea.Model {
  tag?: string[];
  static names(): { [key: string]: string } {
    return {
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tag: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaListByURLResponseBodyMediaListMediaPlayListPlayFile extends $tea.Model {
  state?: string;
  URL?: string;
  static names(): { [key: string]: string } {
    return {
      state: 'State',
      URL: 'URL',
    };
  }

  static types(): { [key: string]: any } {
    return {
      state: 'string',
      URL: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaListByURLResponseBodyMediaListMediaPlayListPlay extends $tea.Model {
  encryption?: string;
  height?: string;
  bitrate?: string;
  file?: QueryMediaListByURLResponseBodyMediaListMediaPlayListPlayFile;
  mediaWorkflowId?: string;
  width?: string;
  size?: string;
  fps?: string;
  duration?: string;
  activityName?: string;
  format?: string;
  mediaWorkflowName?: string;
  static names(): { [key: string]: string } {
    return {
      encryption: 'Encryption',
      height: 'Height',
      bitrate: 'Bitrate',
      file: 'File',
      mediaWorkflowId: 'MediaWorkflowId',
      width: 'Width',
      size: 'Size',
      fps: 'Fps',
      duration: 'Duration',
      activityName: 'ActivityName',
      format: 'Format',
      mediaWorkflowName: 'MediaWorkflowName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      encryption: 'string',
      height: 'string',
      bitrate: 'string',
      file: QueryMediaListByURLResponseBodyMediaListMediaPlayListPlayFile,
      mediaWorkflowId: 'string',
      width: 'string',
      size: 'string',
      fps: 'string',
      duration: 'string',
      activityName: 'string',
      format: 'string',
      mediaWorkflowName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaListByURLResponseBodyMediaListMediaPlayList extends $tea.Model {
  play?: QueryMediaListByURLResponseBodyMediaListMediaPlayListPlay[];
  static names(): { [key: string]: string } {
    return {
      play: 'Play',
    };
  }

  static types(): { [key: string]: any } {
    return {
      play: { 'type': 'array', 'itemType': QueryMediaListByURLResponseBodyMediaListMediaPlayListPlay },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaListByURLResponseBodyMediaListMediaFile extends $tea.Model {
  state?: string;
  URL?: string;
  static names(): { [key: string]: string } {
    return {
      state: 'State',
      URL: 'URL',
    };
  }

  static types(): { [key: string]: any } {
    return {
      state: 'string',
      URL: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaListByURLResponseBodyMediaListMediaSummaryListSummaryFile extends $tea.Model {
  state?: string;
  URL?: string;
  static names(): { [key: string]: string } {
    return {
      state: 'State',
      URL: 'URL',
    };
  }

  static types(): { [key: string]: any } {
    return {
      state: 'string',
      URL: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaListByURLResponseBodyMediaListMediaSummaryListSummary extends $tea.Model {
  type?: string;
  mediaWorkflowId?: string;
  activityName?: string;
  mediaWorkflowName?: string;
  file?: QueryMediaListByURLResponseBodyMediaListMediaSummaryListSummaryFile;
  static names(): { [key: string]: string } {
    return {
      type: 'Type',
      mediaWorkflowId: 'MediaWorkflowId',
      activityName: 'ActivityName',
      mediaWorkflowName: 'MediaWorkflowName',
      file: 'File',
    };
  }

  static types(): { [key: string]: any } {
    return {
      type: 'string',
      mediaWorkflowId: 'string',
      activityName: 'string',
      mediaWorkflowName: 'string',
      file: QueryMediaListByURLResponseBodyMediaListMediaSummaryListSummaryFile,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaListByURLResponseBodyMediaListMediaSummaryList extends $tea.Model {
  summary?: QueryMediaListByURLResponseBodyMediaListMediaSummaryListSummary[];
  static names(): { [key: string]: string } {
    return {
      summary: 'Summary',
    };
  }

  static types(): { [key: string]: any } {
    return {
      summary: { 'type': 'array', 'itemType': QueryMediaListByURLResponseBodyMediaListMediaSummaryListSummary },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStreamNetworkCost extends $tea.Model {
  preloadTime?: string;
  avgBitrate?: string;
  costBandwidth?: string;
  static names(): { [key: string]: string } {
    return {
      preloadTime: 'PreloadTime',
      avgBitrate: 'AvgBitrate',
      costBandwidth: 'CostBandwidth',
    };
  }

  static types(): { [key: string]: any } {
    return {
      preloadTime: 'string',
      avgBitrate: 'string',
      costBandwidth: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStream extends $tea.Model {
  sar?: string;
  height?: string;
  codecTagString?: string;
  networkCost?: QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStreamNetworkCost;
  width?: string;
  index?: string;
  timebase?: string;
  avgFPS?: string;
  pixFmt?: string;
  lang?: string;
  codecLongName?: string;
  numFrames?: string;
  rotate?: string;
  bitrate?: string;
  hasBFrames?: string;
  profile?: string;
  startTime?: string;
  dar?: string;
  codecName?: string;
  duration?: string;
  fps?: string;
  codecTag?: string;
  codecTimeBase?: string;
  level?: string;
  static names(): { [key: string]: string } {
    return {
      sar: 'Sar',
      height: 'Height',
      codecTagString: 'CodecTagString',
      networkCost: 'NetworkCost',
      width: 'Width',
      index: 'Index',
      timebase: 'Timebase',
      avgFPS: 'AvgFPS',
      pixFmt: 'PixFmt',
      lang: 'Lang',
      codecLongName: 'CodecLongName',
      numFrames: 'NumFrames',
      rotate: 'Rotate',
      bitrate: 'Bitrate',
      hasBFrames: 'HasBFrames',
      profile: 'Profile',
      startTime: 'StartTime',
      dar: 'Dar',
      codecName: 'CodecName',
      duration: 'Duration',
      fps: 'Fps',
      codecTag: 'CodecTag',
      codecTimeBase: 'CodecTimeBase',
      level: 'Level',
    };
  }

  static types(): { [key: string]: any } {
    return {
      sar: 'string',
      height: 'string',
      codecTagString: 'string',
      networkCost: QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStreamNetworkCost,
      width: 'string',
      index: 'string',
      timebase: 'string',
      avgFPS: 'string',
      pixFmt: 'string',
      lang: 'string',
      codecLongName: 'string',
      numFrames: 'string',
      rotate: 'string',
      bitrate: 'string',
      hasBFrames: 'string',
      profile: 'string',
      startTime: 'string',
      dar: 'string',
      codecName: 'string',
      duration: 'string',
      fps: 'string',
      codecTag: 'string',
      codecTimeBase: 'string',
      level: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamList extends $tea.Model {
  videoStream?: QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStream[];
  static names(): { [key: string]: string } {
    return {
      videoStream: 'VideoStream',
    };
  }

  static types(): { [key: string]: any } {
    return {
      videoStream: { 'type': 'array', 'itemType': QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStream },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsAudioStreamListAudioStream extends $tea.Model {
  timebase?: string;
  index?: string;
  sampleFmt?: string;
  channelLayout?: string;
  lang?: string;
  samplerate?: string;
  codecLongName?: string;
  channels?: string;
  numFrames?: string;
  bitrate?: string;
  codecTagString?: string;
  startTime?: string;
  codecName?: string;
  duration?: string;
  codecTag?: string;
  codecTimeBase?: string;
  static names(): { [key: string]: string } {
    return {
      timebase: 'Timebase',
      index: 'Index',
      sampleFmt: 'SampleFmt',
      channelLayout: 'ChannelLayout',
      lang: 'Lang',
      samplerate: 'Samplerate',
      codecLongName: 'CodecLongName',
      channels: 'Channels',
      numFrames: 'NumFrames',
      bitrate: 'Bitrate',
      codecTagString: 'CodecTagString',
      startTime: 'StartTime',
      codecName: 'CodecName',
      duration: 'Duration',
      codecTag: 'CodecTag',
      codecTimeBase: 'CodecTimeBase',
    };
  }

  static types(): { [key: string]: any } {
    return {
      timebase: 'string',
      index: 'string',
      sampleFmt: 'string',
      channelLayout: 'string',
      lang: 'string',
      samplerate: 'string',
      codecLongName: 'string',
      channels: 'string',
      numFrames: 'string',
      bitrate: 'string',
      codecTagString: 'string',
      startTime: 'string',
      codecName: 'string',
      duration: 'string',
      codecTag: 'string',
      codecTimeBase: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsAudioStreamList extends $tea.Model {
  audioStream?: QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsAudioStreamListAudioStream[];
  static names(): { [key: string]: string } {
    return {
      audioStream: 'AudioStream',
    };
  }

  static types(): { [key: string]: any } {
    return {
      audioStream: { 'type': 'array', 'itemType': QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsAudioStreamListAudioStream },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamListSubtitleStream extends $tea.Model {
  index?: string;
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      index: 'Index',
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      index: 'string',
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamList extends $tea.Model {
  subtitleStream?: QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamListSubtitleStream[];
  static names(): { [key: string]: string } {
    return {
      subtitleStream: 'SubtitleStream',
    };
  }

  static types(): { [key: string]: any } {
    return {
      subtitleStream: { 'type': 'array', 'itemType': QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamListSubtitleStream },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreams extends $tea.Model {
  videoStreamList?: QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamList;
  audioStreamList?: QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsAudioStreamList;
  subtitleStreamList?: QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamList;
  static names(): { [key: string]: string } {
    return {
      videoStreamList: 'VideoStreamList',
      audioStreamList: 'AudioStreamList',
      subtitleStreamList: 'SubtitleStreamList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      videoStreamList: QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamList,
      audioStreamList: QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsAudioStreamList,
      subtitleStreamList: QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaListByURLResponseBodyMediaListMediaMediaInfoFormat extends $tea.Model {
  startTime?: string;
  numPrograms?: string;
  size?: string;
  numStreams?: string;
  formatLongName?: string;
  duration?: string;
  bitrate?: string;
  formatName?: string;
  static names(): { [key: string]: string } {
    return {
      startTime: 'StartTime',
      numPrograms: 'NumPrograms',
      size: 'Size',
      numStreams: 'NumStreams',
      formatLongName: 'FormatLongName',
      duration: 'Duration',
      bitrate: 'Bitrate',
      formatName: 'FormatName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      startTime: 'string',
      numPrograms: 'string',
      size: 'string',
      numStreams: 'string',
      formatLongName: 'string',
      duration: 'string',
      bitrate: 'string',
      formatName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaListByURLResponseBodyMediaListMediaMediaInfo extends $tea.Model {
  streams?: QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreams;
  format?: QueryMediaListByURLResponseBodyMediaListMediaMediaInfoFormat;
  static names(): { [key: string]: string } {
    return {
      streams: 'Streams',
      format: 'Format',
    };
  }

  static types(): { [key: string]: any } {
    return {
      streams: QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreams,
      format: QueryMediaListByURLResponseBodyMediaListMediaMediaInfoFormat,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaListByURLResponseBodyMediaListMediaSnapshotListSnapshotFile extends $tea.Model {
  state?: string;
  URL?: string;
  static names(): { [key: string]: string } {
    return {
      state: 'State',
      URL: 'URL',
    };
  }

  static types(): { [key: string]: any } {
    return {
      state: 'string',
      URL: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaListByURLResponseBodyMediaListMediaSnapshotListSnapshot extends $tea.Model {
  type?: string;
  mediaWorkflowId?: string;
  activityName?: string;
  count?: string;
  mediaWorkflowName?: string;
  file?: QueryMediaListByURLResponseBodyMediaListMediaSnapshotListSnapshotFile;
  static names(): { [key: string]: string } {
    return {
      type: 'Type',
      mediaWorkflowId: 'MediaWorkflowId',
      activityName: 'ActivityName',
      count: 'Count',
      mediaWorkflowName: 'MediaWorkflowName',
      file: 'File',
    };
  }

  static types(): { [key: string]: any } {
    return {
      type: 'string',
      mediaWorkflowId: 'string',
      activityName: 'string',
      count: 'string',
      mediaWorkflowName: 'string',
      file: QueryMediaListByURLResponseBodyMediaListMediaSnapshotListSnapshotFile,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaListByURLResponseBodyMediaListMediaSnapshotList extends $tea.Model {
  snapshot?: QueryMediaListByURLResponseBodyMediaListMediaSnapshotListSnapshot[];
  static names(): { [key: string]: string } {
    return {
      snapshot: 'Snapshot',
    };
  }

  static types(): { [key: string]: any } {
    return {
      snapshot: { 'type': 'array', 'itemType': QueryMediaListByURLResponseBodyMediaListMediaSnapshotListSnapshot },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaListByURLResponseBodyMediaListMediaRunIdList extends $tea.Model {
  runId?: string[];
  static names(): { [key: string]: string } {
    return {
      runId: 'RunId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      runId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaListByURLResponseBodyMediaListMedia extends $tea.Model {
  creationTime?: string;
  cateId?: number;
  height?: string;
  censorState?: string;
  tags?: QueryMediaListByURLResponseBodyMediaListMediaTags;
  playList?: QueryMediaListByURLResponseBodyMediaListMediaPlayList;
  bitrate?: string;
  mediaId?: string;
  file?: QueryMediaListByURLResponseBodyMediaListMediaFile;
  summaryList?: QueryMediaListByURLResponseBodyMediaListMediaSummaryList;
  publishState?: string;
  mediaInfo?: QueryMediaListByURLResponseBodyMediaListMediaMediaInfo;
  description?: string;
  size?: string;
  width?: string;
  coverURL?: string;
  snapshotList?: QueryMediaListByURLResponseBodyMediaListMediaSnapshotList;
  runIdList?: QueryMediaListByURLResponseBodyMediaListMediaRunIdList;
  duration?: string;
  fps?: string;
  title?: string;
  format?: string;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      cateId: 'CateId',
      height: 'Height',
      censorState: 'CensorState',
      tags: 'Tags',
      playList: 'PlayList',
      bitrate: 'Bitrate',
      mediaId: 'MediaId',
      file: 'File',
      summaryList: 'SummaryList',
      publishState: 'PublishState',
      mediaInfo: 'MediaInfo',
      description: 'Description',
      size: 'Size',
      width: 'Width',
      coverURL: 'CoverURL',
      snapshotList: 'SnapshotList',
      runIdList: 'RunIdList',
      duration: 'Duration',
      fps: 'Fps',
      title: 'Title',
      format: 'Format',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      cateId: 'number',
      height: 'string',
      censorState: 'string',
      tags: QueryMediaListByURLResponseBodyMediaListMediaTags,
      playList: QueryMediaListByURLResponseBodyMediaListMediaPlayList,
      bitrate: 'string',
      mediaId: 'string',
      file: QueryMediaListByURLResponseBodyMediaListMediaFile,
      summaryList: QueryMediaListByURLResponseBodyMediaListMediaSummaryList,
      publishState: 'string',
      mediaInfo: QueryMediaListByURLResponseBodyMediaListMediaMediaInfo,
      description: 'string',
      size: 'string',
      width: 'string',
      coverURL: 'string',
      snapshotList: QueryMediaListByURLResponseBodyMediaListMediaSnapshotList,
      runIdList: QueryMediaListByURLResponseBodyMediaListMediaRunIdList,
      duration: 'string',
      fps: 'string',
      title: 'string',
      format: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaListByURLResponseBodyMediaList extends $tea.Model {
  media?: QueryMediaListByURLResponseBodyMediaListMedia[];
  static names(): { [key: string]: string } {
    return {
      media: 'Media',
    };
  }

  static types(): { [key: string]: any } {
    return {
      media: { 'type': 'array', 'itemType': QueryMediaListByURLResponseBodyMediaListMedia },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaListByURLResponseBodyNonExistFileURLs extends $tea.Model {
  fileURL?: string[];
  static names(): { [key: string]: string } {
    return {
      fileURL: 'FileURL',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fileURL: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaWorkflowExecutionListResponseBodyNonExistRunIds extends $tea.Model {
  runId?: string[];
  static names(): { [key: string]: string } {
    return {
      runId: 'RunId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      runId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivityMNSMessageResult extends $tea.Model {
  messageId?: string;
  errorMessage?: string;
  errorCode?: string;
  static names(): { [key: string]: string } {
    return {
      messageId: 'MessageId',
      errorMessage: 'ErrorMessage',
      errorCode: 'ErrorCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      messageId: 'string',
      errorMessage: 'string',
      errorCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivity extends $tea.Model {
  endTime?: string;
  type?: string;
  startTime?: string;
  state?: string;
  jobId?: string;
  code?: string;
  message?: string;
  name?: string;
  MNSMessageResult?: QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivityMNSMessageResult;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      type: 'Type',
      startTime: 'StartTime',
      state: 'State',
      jobId: 'JobId',
      code: 'Code',
      message: 'Message',
      name: 'Name',
      MNSMessageResult: 'MNSMessageResult',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      type: 'string',
      startTime: 'string',
      state: 'string',
      jobId: 'string',
      code: 'string',
      message: 'string',
      name: 'string',
      MNSMessageResult: QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivityMNSMessageResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityList extends $tea.Model {
  activity?: QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivity[];
  static names(): { [key: string]: string } {
    return {
      activity: 'Activity',
    };
  }

  static types(): { [key: string]: any } {
    return {
      activity: { 'type': 'array', 'itemType': QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivity },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInputInputFile extends $tea.Model {
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInput extends $tea.Model {
  userData?: string;
  inputFile?: QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInputInputFile;
  static names(): { [key: string]: string } {
    return {
      userData: 'UserData',
      inputFile: 'InputFile',
    };
  }

  static types(): { [key: string]: any } {
    return {
      userData: 'string',
      inputFile: QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInputInputFile,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecution extends $tea.Model {
  creationTime?: string;
  mediaWorkflowId?: string;
  state?: string;
  activityList?: QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityList;
  name?: string;
  input?: QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInput;
  mediaId?: string;
  runId?: string;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      mediaWorkflowId: 'MediaWorkflowId',
      state: 'State',
      activityList: 'ActivityList',
      name: 'Name',
      input: 'Input',
      mediaId: 'MediaId',
      runId: 'RunId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      mediaWorkflowId: 'string',
      state: 'string',
      activityList: QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityList,
      name: 'string',
      input: QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInput,
      mediaId: 'string',
      runId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionList extends $tea.Model {
  mediaWorkflowExecution?: QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecution[];
  static names(): { [key: string]: string } {
    return {
      mediaWorkflowExecution: 'MediaWorkflowExecution',
    };
  }

  static types(): { [key: string]: any } {
    return {
      mediaWorkflowExecution: { 'type': 'array', 'itemType': QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecution },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaWorkflowListResponseBodyNonExistMediaWorkflowIds extends $tea.Model {
  mediaWorkflowId?: string[];
  static names(): { [key: string]: string } {
    return {
      mediaWorkflowId: 'MediaWorkflowId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      mediaWorkflowId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaWorkflowListResponseBodyMediaWorkflowListMediaWorkflow extends $tea.Model {
  creationTime?: string;
  mediaWorkflowId?: string;
  state?: string;
  triggerMode?: string;
  name?: string;
  topology?: string;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      mediaWorkflowId: 'MediaWorkflowId',
      state: 'State',
      triggerMode: 'TriggerMode',
      name: 'Name',
      topology: 'Topology',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      mediaWorkflowId: 'string',
      state: 'string',
      triggerMode: 'string',
      name: 'string',
      topology: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMediaWorkflowListResponseBodyMediaWorkflowList extends $tea.Model {
  mediaWorkflow?: QueryMediaWorkflowListResponseBodyMediaWorkflowListMediaWorkflow[];
  static names(): { [key: string]: string } {
    return {
      mediaWorkflow: 'MediaWorkflow',
    };
  }

  static types(): { [key: string]: any } {
    return {
      mediaWorkflow: { 'type': 'array', 'itemType': QueryMediaWorkflowListResponseBodyMediaWorkflowListMediaWorkflow },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryPipelineListResponseBodyPipelineListPipelineNotifyConfig extends $tea.Model {
  mqTopic?: string;
  queueName?: string;
  mqTag?: string;
  topic?: string;
  static names(): { [key: string]: string } {
    return {
      mqTopic: 'MqTopic',
      queueName: 'QueueName',
      mqTag: 'MqTag',
      topic: 'Topic',
    };
  }

  static types(): { [key: string]: any } {
    return {
      mqTopic: 'string',
      queueName: 'string',
      mqTag: 'string',
      topic: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryPipelineListResponseBodyPipelineListPipeline extends $tea.Model {
  speed?: string;
  state?: string;
  speedLevel?: number;
  notifyConfig?: QueryPipelineListResponseBodyPipelineListPipelineNotifyConfig;
  role?: string;
  name?: string;
  id?: string;
  quotaAllocate?: number;
  static names(): { [key: string]: string } {
    return {
      speed: 'Speed',
      state: 'State',
      speedLevel: 'SpeedLevel',
      notifyConfig: 'NotifyConfig',
      role: 'Role',
      name: 'Name',
      id: 'Id',
      quotaAllocate: 'QuotaAllocate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      speed: 'string',
      state: 'string',
      speedLevel: 'number',
      notifyConfig: QueryPipelineListResponseBodyPipelineListPipelineNotifyConfig,
      role: 'string',
      name: 'string',
      id: 'string',
      quotaAllocate: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryPipelineListResponseBodyPipelineList extends $tea.Model {
  pipeline?: QueryPipelineListResponseBodyPipelineListPipeline[];
  static names(): { [key: string]: string } {
    return {
      pipeline: 'Pipeline',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pipeline: { 'type': 'array', 'itemType': QueryPipelineListResponseBodyPipelineListPipeline },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryPipelineListResponseBodyNonExistPids extends $tea.Model {
  string?: string[];
  static names(): { [key: string]: string } {
    return {
      string: 'String',
    };
  }

  static types(): { [key: string]: any } {
    return {
      string: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryPornJobListResponseBodyPornJobListPornJobPornConfigOutputFile extends $tea.Model {
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryPornJobListResponseBodyPornJobListPornJobPornConfig extends $tea.Model {
  interval?: string;
  outputFile?: QueryPornJobListResponseBodyPornJobListPornJobPornConfigOutputFile;
  bizType?: string;
  static names(): { [key: string]: string } {
    return {
      interval: 'Interval',
      outputFile: 'OutputFile',
      bizType: 'BizType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      interval: 'string',
      outputFile: QueryPornJobListResponseBodyPornJobListPornJobPornConfigOutputFile,
      bizType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryPornJobListResponseBodyPornJobListPornJobCensorPornResultPornCounterListCounter extends $tea.Model {
  label?: string;
  count?: number;
  static names(): { [key: string]: string } {
    return {
      label: 'Label',
      count: 'Count',
    };
  }

  static types(): { [key: string]: any } {
    return {
      label: 'string',
      count: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryPornJobListResponseBodyPornJobListPornJobCensorPornResultPornCounterList extends $tea.Model {
  counter?: QueryPornJobListResponseBodyPornJobListPornJobCensorPornResultPornCounterListCounter[];
  static names(): { [key: string]: string } {
    return {
      counter: 'Counter',
    };
  }

  static types(): { [key: string]: any } {
    return {
      counter: { 'type': 'array', 'itemType': QueryPornJobListResponseBodyPornJobListPornJobCensorPornResultPornCounterListCounter },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryPornJobListResponseBodyPornJobListPornJobCensorPornResultPornTopListTop extends $tea.Model {
  index?: string;
  score?: string;
  timestamp?: string;
  object?: string;
  label?: string;
  static names(): { [key: string]: string } {
    return {
      index: 'Index',
      score: 'Score',
      timestamp: 'Timestamp',
      object: 'Object',
      label: 'Label',
    };
  }

  static types(): { [key: string]: any } {
    return {
      index: 'string',
      score: 'string',
      timestamp: 'string',
      object: 'string',
      label: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryPornJobListResponseBodyPornJobListPornJobCensorPornResultPornTopList extends $tea.Model {
  top?: QueryPornJobListResponseBodyPornJobListPornJobCensorPornResultPornTopListTop[];
  static names(): { [key: string]: string } {
    return {
      top: 'Top',
    };
  }

  static types(): { [key: string]: any } {
    return {
      top: { 'type': 'array', 'itemType': QueryPornJobListResponseBodyPornJobListPornJobCensorPornResultPornTopListTop },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryPornJobListResponseBodyPornJobListPornJobCensorPornResult extends $tea.Model {
  pornCounterList?: QueryPornJobListResponseBodyPornJobListPornJobCensorPornResultPornCounterList;
  suggestion?: string;
  averageScore?: string;
  pornTopList?: QueryPornJobListResponseBodyPornJobListPornJobCensorPornResultPornTopList;
  label?: string;
  maxScore?: string;
  static names(): { [key: string]: string } {
    return {
      pornCounterList: 'PornCounterList',
      suggestion: 'Suggestion',
      averageScore: 'AverageScore',
      pornTopList: 'PornTopList',
      label: 'Label',
      maxScore: 'MaxScore',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pornCounterList: QueryPornJobListResponseBodyPornJobListPornJobCensorPornResultPornCounterList,
      suggestion: 'string',
      averageScore: 'string',
      pornTopList: QueryPornJobListResponseBodyPornJobListPornJobCensorPornResultPornTopList,
      label: 'string',
      maxScore: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryPornJobListResponseBodyPornJobListPornJobInput extends $tea.Model {
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryPornJobListResponseBodyPornJobListPornJob extends $tea.Model {
  creationTime?: string;
  pornConfig?: QueryPornJobListResponseBodyPornJobListPornJobPornConfig;
  state?: string;
  userData?: string;
  code?: string;
  message?: string;
  censorPornResult?: QueryPornJobListResponseBodyPornJobListPornJobCensorPornResult;
  pipelineId?: string;
  input?: QueryPornJobListResponseBodyPornJobListPornJobInput;
  id?: string;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      pornConfig: 'PornConfig',
      state: 'State',
      userData: 'UserData',
      code: 'Code',
      message: 'Message',
      censorPornResult: 'CensorPornResult',
      pipelineId: 'PipelineId',
      input: 'Input',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      pornConfig: QueryPornJobListResponseBodyPornJobListPornJobPornConfig,
      state: 'string',
      userData: 'string',
      code: 'string',
      message: 'string',
      censorPornResult: QueryPornJobListResponseBodyPornJobListPornJobCensorPornResult,
      pipelineId: 'string',
      input: QueryPornJobListResponseBodyPornJobListPornJobInput,
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryPornJobListResponseBodyPornJobList extends $tea.Model {
  pornJob?: QueryPornJobListResponseBodyPornJobListPornJob[];
  static names(): { [key: string]: string } {
    return {
      pornJob: 'PornJob',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pornJob: { 'type': 'array', 'itemType': QueryPornJobListResponseBodyPornJobListPornJob },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryPornJobListResponseBodyNonExistIds extends $tea.Model {
  string?: string[];
  static names(): { [key: string]: string } {
    return {
      string: 'String',
    };
  }

  static types(): { [key: string]: any } {
    return {
      string: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryPornPipelineListResponseBodyPipelineListPipelineNotifyConfig extends $tea.Model {
  topic?: string;
  queue?: string;
  static names(): { [key: string]: string } {
    return {
      topic: 'Topic',
      queue: 'Queue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      topic: 'string',
      queue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryPornPipelineListResponseBodyPipelineListPipeline extends $tea.Model {
  state?: string;
  notifyConfig?: QueryPornPipelineListResponseBodyPipelineListPipelineNotifyConfig;
  priority?: string;
  name?: string;
  id?: string;
  static names(): { [key: string]: string } {
    return {
      state: 'State',
      notifyConfig: 'NotifyConfig',
      priority: 'Priority',
      name: 'Name',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      state: 'string',
      notifyConfig: QueryPornPipelineListResponseBodyPipelineListPipelineNotifyConfig,
      priority: 'string',
      name: 'string',
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryPornPipelineListResponseBodyPipelineList extends $tea.Model {
  pipeline?: QueryPornPipelineListResponseBodyPipelineListPipeline[];
  static names(): { [key: string]: string } {
    return {
      pipeline: 'Pipeline',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pipeline: { 'type': 'array', 'itemType': QueryPornPipelineListResponseBodyPipelineListPipeline },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryPornPipelineListResponseBodyNonExistIds extends $tea.Model {
  string?: string[];
  static names(): { [key: string]: string } {
    return {
      string: 'String',
    };
  }

  static types(): { [key: string]: any } {
    return {
      string: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySmarttagJobResponseBodyResultsResult extends $tea.Model {
  type?: string;
  data?: string;
  static names(): { [key: string]: string } {
    return {
      type: 'Type',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      type: 'string',
      data: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySmarttagJobResponseBodyResults extends $tea.Model {
  result?: QuerySmarttagJobResponseBodyResultsResult[];
  static names(): { [key: string]: string } {
    return {
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      result: { 'type': 'array', 'itemType': QuerySmarttagJobResponseBodyResultsResult },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySmarttagTemplateListResponseBodyTemplatesTemplate extends $tea.Model {
  analyseTypes?: string;
  industry?: string;
  isDefault?: boolean;
  templateName?: string;
  templateId?: string;
  faceCategoryIds?: string;
  scene?: string;
  static names(): { [key: string]: string } {
    return {
      analyseTypes: 'AnalyseTypes',
      industry: 'Industry',
      isDefault: 'IsDefault',
      templateName: 'TemplateName',
      templateId: 'TemplateId',
      faceCategoryIds: 'FaceCategoryIds',
      scene: 'Scene',
    };
  }

  static types(): { [key: string]: any } {
    return {
      analyseTypes: 'string',
      industry: 'string',
      isDefault: 'boolean',
      templateName: 'string',
      templateId: 'string',
      faceCategoryIds: 'string',
      scene: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySmarttagTemplateListResponseBodyTemplates extends $tea.Model {
  template?: QuerySmarttagTemplateListResponseBodyTemplatesTemplate[];
  static names(): { [key: string]: string } {
    return {
      template: 'Template',
    };
  }

  static types(): { [key: string]: any } {
    return {
      template: { 'type': 'array', 'itemType': QuerySmarttagTemplateListResponseBodyTemplatesTemplate },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigTileOut extends $tea.Model {
  padding?: string;
  color?: string;
  cellSelStep?: string;
  cellHeight?: string;
  cellWidth?: string;
  margin?: string;
  columns?: string;
  isKeepCellPic?: string;
  lines?: string;
  static names(): { [key: string]: string } {
    return {
      padding: 'Padding',
      color: 'Color',
      cellSelStep: 'CellSelStep',
      cellHeight: 'CellHeight',
      cellWidth: 'CellWidth',
      margin: 'Margin',
      columns: 'Columns',
      isKeepCellPic: 'IsKeepCellPic',
      lines: 'Lines',
    };
  }

  static types(): { [key: string]: any } {
    return {
      padding: 'string',
      color: 'string',
      cellSelStep: 'string',
      cellHeight: 'string',
      cellWidth: 'string',
      margin: 'string',
      columns: 'string',
      isKeepCellPic: 'string',
      lines: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigOutputFile extends $tea.Model {
  roleArn?: string;
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      roleArn: 'RoleArn',
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      roleArn: 'string',
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigTileOutputFile extends $tea.Model {
  roleArn?: string;
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      roleArn: 'RoleArn',
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      roleArn: 'string',
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfig extends $tea.Model {
  time?: string;
  tileOut?: QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigTileOut;
  interval?: string;
  frameType?: string;
  width?: string;
  height?: string;
  outputFile?: QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigOutputFile;
  num?: string;
  tileOutputFile?: QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigTileOutputFile;
  static names(): { [key: string]: string } {
    return {
      time: 'Time',
      tileOut: 'TileOut',
      interval: 'Interval',
      frameType: 'FrameType',
      width: 'Width',
      height: 'Height',
      outputFile: 'OutputFile',
      num: 'Num',
      tileOutputFile: 'TileOutputFile',
    };
  }

  static types(): { [key: string]: any } {
    return {
      time: 'string',
      tileOut: QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigTileOut,
      interval: 'string',
      frameType: 'string',
      width: 'string',
      height: 'string',
      outputFile: QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigOutputFile,
      num: 'string',
      tileOutputFile: QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigTileOutputFile,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobMNSMessageResult extends $tea.Model {
  messageId?: string;
  errorMessage?: string;
  errorCode?: string;
  static names(): { [key: string]: string } {
    return {
      messageId: 'MessageId',
      errorMessage: 'ErrorMessage',
      errorCode: 'ErrorCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      messageId: 'string',
      errorMessage: 'string',
      errorCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobInput extends $tea.Model {
  roleArn?: string;
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      roleArn: 'RoleArn',
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      roleArn: 'string',
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJob extends $tea.Model {
  creationTime?: string;
  snapshotConfig?: QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfig;
  state?: string;
  message?: string;
  MNSMessageResult?: QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobMNSMessageResult;
  input?: QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobInput;
  count?: string;
  tileCount?: string;
  userData?: string;
  code?: string;
  pipelineId?: string;
  id?: string;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      snapshotConfig: 'SnapshotConfig',
      state: 'State',
      message: 'Message',
      MNSMessageResult: 'MNSMessageResult',
      input: 'Input',
      count: 'Count',
      tileCount: 'TileCount',
      userData: 'UserData',
      code: 'Code',
      pipelineId: 'PipelineId',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      snapshotConfig: QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfig,
      state: 'string',
      message: 'string',
      MNSMessageResult: QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobMNSMessageResult,
      input: QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobInput,
      count: 'string',
      tileCount: 'string',
      userData: 'string',
      code: 'string',
      pipelineId: 'string',
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySnapshotJobListResponseBodySnapshotJobList extends $tea.Model {
  snapshotJob?: QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJob[];
  static names(): { [key: string]: string } {
    return {
      snapshotJob: 'SnapshotJob',
    };
  }

  static types(): { [key: string]: any } {
    return {
      snapshotJob: { 'type': 'array', 'itemType': QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJob },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySnapshotJobListResponseBodyNonExistSnapshotJobIds extends $tea.Model {
  string?: string[];
  static names(): { [key: string]: string } {
    return {
      string: 'String',
    };
  }

  static types(): { [key: string]: any } {
    return {
      string: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySubtitleJobListResponseBodyNonExistJobIds extends $tea.Model {
  string?: string[];
  static names(): { [key: string]: string } {
    return {
      string: 'String',
    };
  }

  static types(): { [key: string]: any } {
    return {
      string: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySubtitleJobListResponseBodyJobListJobMNSMessageResult extends $tea.Model {
  messageId?: string;
  errorMessage?: string;
  errorCode?: string;
  static names(): { [key: string]: string } {
    return {
      messageId: 'MessageId',
      errorMessage: 'ErrorMessage',
      errorCode: 'ErrorCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      messageId: 'string',
      errorMessage: 'string',
      errorCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySubtitleJobListResponseBodyJobListJob extends $tea.Model {
  outputConfig?: string;
  state?: string;
  jobId?: string;
  userData?: string;
  inputConfig?: string;
  MNSMessageResult?: QuerySubtitleJobListResponseBodyJobListJobMNSMessageResult;
  static names(): { [key: string]: string } {
    return {
      outputConfig: 'OutputConfig',
      state: 'State',
      jobId: 'JobId',
      userData: 'UserData',
      inputConfig: 'InputConfig',
      MNSMessageResult: 'MNSMessageResult',
    };
  }

  static types(): { [key: string]: any } {
    return {
      outputConfig: 'string',
      state: 'string',
      jobId: 'string',
      userData: 'string',
      inputConfig: 'string',
      MNSMessageResult: QuerySubtitleJobListResponseBodyJobListJobMNSMessageResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySubtitleJobListResponseBodyJobList extends $tea.Model {
  job?: QuerySubtitleJobListResponseBodyJobListJob[];
  static names(): { [key: string]: string } {
    return {
      job: 'Job',
    };
  }

  static types(): { [key: string]: any } {
    return {
      job: { 'type': 'array', 'itemType': QuerySubtitleJobListResponseBodyJobListJob },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTagJobListResponseBodyTagJobListTagJobVideoTagResultTagAnResultsTagAnResult extends $tea.Model {
  score?: string;
  label?: string;
  static names(): { [key: string]: string } {
    return {
      score: 'Score',
      label: 'Label',
    };
  }

  static types(): { [key: string]: any } {
    return {
      score: 'string',
      label: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTagJobListResponseBodyTagJobListTagJobVideoTagResultTagAnResults extends $tea.Model {
  tagAnResult?: QueryTagJobListResponseBodyTagJobListTagJobVideoTagResultTagAnResultsTagAnResult[];
  static names(): { [key: string]: string } {
    return {
      tagAnResult: 'TagAnResult',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagAnResult: { 'type': 'array', 'itemType': QueryTagJobListResponseBodyTagJobListTagJobVideoTagResultTagAnResultsTagAnResult },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTagJobListResponseBodyTagJobListTagJobVideoTagResultTagFrResultsTagFrResultTagFacesTagFace extends $tea.Model {
  score?: string;
  name?: string;
  target?: string;
  static names(): { [key: string]: string } {
    return {
      score: 'Score',
      name: 'Name',
      target: 'Target',
    };
  }

  static types(): { [key: string]: any } {
    return {
      score: 'string',
      name: 'string',
      target: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTagJobListResponseBodyTagJobListTagJobVideoTagResultTagFrResultsTagFrResultTagFaces extends $tea.Model {
  tagFace?: QueryTagJobListResponseBodyTagJobListTagJobVideoTagResultTagFrResultsTagFrResultTagFacesTagFace[];
  static names(): { [key: string]: string } {
    return {
      tagFace: 'TagFace',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagFace: { 'type': 'array', 'itemType': QueryTagJobListResponseBodyTagJobListTagJobVideoTagResultTagFrResultsTagFrResultTagFacesTagFace },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTagJobListResponseBodyTagJobListTagJobVideoTagResultTagFrResultsTagFrResult extends $tea.Model {
  tagFaces?: QueryTagJobListResponseBodyTagJobListTagJobVideoTagResultTagFrResultsTagFrResultTagFaces;
  time?: string;
  static names(): { [key: string]: string } {
    return {
      tagFaces: 'TagFaces',
      time: 'Time',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagFaces: QueryTagJobListResponseBodyTagJobListTagJobVideoTagResultTagFrResultsTagFrResultTagFaces,
      time: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTagJobListResponseBodyTagJobListTagJobVideoTagResultTagFrResults extends $tea.Model {
  tagFrResult?: QueryTagJobListResponseBodyTagJobListTagJobVideoTagResultTagFrResultsTagFrResult[];
  static names(): { [key: string]: string } {
    return {
      tagFrResult: 'TagFrResult',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagFrResult: { 'type': 'array', 'itemType': QueryTagJobListResponseBodyTagJobListTagJobVideoTagResultTagFrResultsTagFrResult },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTagJobListResponseBodyTagJobListTagJobVideoTagResult extends $tea.Model {
  tagAnResults?: QueryTagJobListResponseBodyTagJobListTagJobVideoTagResultTagAnResults;
  tagFrResults?: QueryTagJobListResponseBodyTagJobListTagJobVideoTagResultTagFrResults;
  details?: string;
  static names(): { [key: string]: string } {
    return {
      tagAnResults: 'TagAnResults',
      tagFrResults: 'TagFrResults',
      details: 'Details',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagAnResults: QueryTagJobListResponseBodyTagJobListTagJobVideoTagResultTagAnResults,
      tagFrResults: QueryTagJobListResponseBodyTagJobListTagJobVideoTagResultTagFrResults,
      details: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTagJobListResponseBodyTagJobListTagJobInput extends $tea.Model {
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTagJobListResponseBodyTagJobListTagJob extends $tea.Model {
  creationTime?: string;
  videoTagResult?: QueryTagJobListResponseBodyTagJobListTagJobVideoTagResult;
  state?: string;
  userData?: string;
  code?: string;
  message?: string;
  pipelineId?: string;
  input?: QueryTagJobListResponseBodyTagJobListTagJobInput;
  id?: string;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      videoTagResult: 'VideoTagResult',
      state: 'State',
      userData: 'UserData',
      code: 'Code',
      message: 'Message',
      pipelineId: 'PipelineId',
      input: 'Input',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      videoTagResult: QueryTagJobListResponseBodyTagJobListTagJobVideoTagResult,
      state: 'string',
      userData: 'string',
      code: 'string',
      message: 'string',
      pipelineId: 'string',
      input: QueryTagJobListResponseBodyTagJobListTagJobInput,
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTagJobListResponseBodyTagJobList extends $tea.Model {
  tagJob?: QueryTagJobListResponseBodyTagJobListTagJob[];
  static names(): { [key: string]: string } {
    return {
      tagJob: 'TagJob',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagJob: { 'type': 'array', 'itemType': QueryTagJobListResponseBodyTagJobListTagJob },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTagJobListResponseBodyNonExistIds extends $tea.Model {
  string?: string[];
  static names(): { [key: string]: string } {
    return {
      string: 'String',
    };
  }

  static types(): { [key: string]: any } {
    return {
      string: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTemplateListResponseBodyNonExistTids extends $tea.Model {
  string?: string[];
  static names(): { [key: string]: string } {
    return {
      string: 'String',
    };
  }

  static types(): { [key: string]: any } {
    return {
      string: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTemplateListResponseBodyTemplateListTemplateVideoBitrateBnd extends $tea.Model {
  max?: string;
  min?: string;
  static names(): { [key: string]: string } {
    return {
      max: 'Max',
      min: 'Min',
    };
  }

  static types(): { [key: string]: any } {
    return {
      max: 'string',
      min: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTemplateListResponseBodyTemplateListTemplateVideo extends $tea.Model {
  bufsize?: string;
  longShortMode?: string;
  degrain?: string;
  bitrateBnd?: QueryTemplateListResponseBodyTemplateListTemplateVideoBitrateBnd;
  pixFmt?: string;
  pad?: string;
  codec?: string;
  height?: string;
  qscale?: string;
  crop?: string;
  bitrate?: string;
  maxrate?: string;
  maxFps?: string;
  profile?: string;
  crf?: string;
  remove?: string;
  gop?: string;
  width?: string;
  fps?: string;
  preset?: string;
  scanMode?: string;
  resoPriority?: string;
  static names(): { [key: string]: string } {
    return {
      bufsize: 'Bufsize',
      longShortMode: 'LongShortMode',
      degrain: 'Degrain',
      bitrateBnd: 'BitrateBnd',
      pixFmt: 'PixFmt',
      pad: 'Pad',
      codec: 'Codec',
      height: 'Height',
      qscale: 'Qscale',
      crop: 'Crop',
      bitrate: 'Bitrate',
      maxrate: 'Maxrate',
      maxFps: 'MaxFps',
      profile: 'Profile',
      crf: 'Crf',
      remove: 'Remove',
      gop: 'Gop',
      width: 'Width',
      fps: 'Fps',
      preset: 'Preset',
      scanMode: 'ScanMode',
      resoPriority: 'ResoPriority',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bufsize: 'string',
      longShortMode: 'string',
      degrain: 'string',
      bitrateBnd: QueryTemplateListResponseBodyTemplateListTemplateVideoBitrateBnd,
      pixFmt: 'string',
      pad: 'string',
      codec: 'string',
      height: 'string',
      qscale: 'string',
      crop: 'string',
      bitrate: 'string',
      maxrate: 'string',
      maxFps: 'string',
      profile: 'string',
      crf: 'string',
      remove: 'string',
      gop: 'string',
      width: 'string',
      fps: 'string',
      preset: 'string',
      scanMode: 'string',
      resoPriority: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTemplateListResponseBodyTemplateListTemplateTransConfig extends $tea.Model {
  isCheckAudioBitrate?: string;
  transMode?: string;
  isCheckReso?: string;
  isCheckVideoBitrateFail?: string;
  adjDarMethod?: string;
  isCheckVideoBitrate?: string;
  isCheckResoFail?: string;
  isCheckAudioBitrateFail?: string;
  static names(): { [key: string]: string } {
    return {
      isCheckAudioBitrate: 'IsCheckAudioBitrate',
      transMode: 'TransMode',
      isCheckReso: 'IsCheckReso',
      isCheckVideoBitrateFail: 'IsCheckVideoBitrateFail',
      adjDarMethod: 'AdjDarMethod',
      isCheckVideoBitrate: 'IsCheckVideoBitrate',
      isCheckResoFail: 'IsCheckResoFail',
      isCheckAudioBitrateFail: 'IsCheckAudioBitrateFail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isCheckAudioBitrate: 'string',
      transMode: 'string',
      isCheckReso: 'string',
      isCheckVideoBitrateFail: 'string',
      adjDarMethod: 'string',
      isCheckVideoBitrate: 'string',
      isCheckResoFail: 'string',
      isCheckAudioBitrateFail: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTemplateListResponseBodyTemplateListTemplateMuxConfigWebp extends $tea.Model {
  loop?: string;
  static names(): { [key: string]: string } {
    return {
      loop: 'Loop',
    };
  }

  static types(): { [key: string]: any } {
    return {
      loop: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTemplateListResponseBodyTemplateListTemplateMuxConfigGif extends $tea.Model {
  finalDelay?: string;
  ditherMode?: string;
  loop?: string;
  isCustomPalette?: string;
  static names(): { [key: string]: string } {
    return {
      finalDelay: 'FinalDelay',
      ditherMode: 'DitherMode',
      loop: 'Loop',
      isCustomPalette: 'IsCustomPalette',
    };
  }

  static types(): { [key: string]: any } {
    return {
      finalDelay: 'string',
      ditherMode: 'string',
      loop: 'string',
      isCustomPalette: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTemplateListResponseBodyTemplateListTemplateMuxConfigSegment extends $tea.Model {
  duration?: string;
  static names(): { [key: string]: string } {
    return {
      duration: 'Duration',
    };
  }

  static types(): { [key: string]: any } {
    return {
      duration: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTemplateListResponseBodyTemplateListTemplateMuxConfig extends $tea.Model {
  webp?: QueryTemplateListResponseBodyTemplateListTemplateMuxConfigWebp;
  gif?: QueryTemplateListResponseBodyTemplateListTemplateMuxConfigGif;
  segment?: QueryTemplateListResponseBodyTemplateListTemplateMuxConfigSegment;
  static names(): { [key: string]: string } {
    return {
      webp: 'Webp',
      gif: 'Gif',
      segment: 'Segment',
    };
  }

  static types(): { [key: string]: any } {
    return {
      webp: QueryTemplateListResponseBodyTemplateListTemplateMuxConfigWebp,
      gif: QueryTemplateListResponseBodyTemplateListTemplateMuxConfigGif,
      segment: QueryTemplateListResponseBodyTemplateListTemplateMuxConfigSegment,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTemplateListResponseBodyTemplateListTemplateAudio extends $tea.Model {
  profile?: string;
  remove?: string;
  codec?: string;
  samplerate?: string;
  qscale?: string;
  channels?: string;
  bitrate?: string;
  static names(): { [key: string]: string } {
    return {
      profile: 'Profile',
      remove: 'Remove',
      codec: 'Codec',
      samplerate: 'Samplerate',
      qscale: 'Qscale',
      channels: 'Channels',
      bitrate: 'Bitrate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      profile: 'string',
      remove: 'string',
      codec: 'string',
      samplerate: 'string',
      qscale: 'string',
      channels: 'string',
      bitrate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTemplateListResponseBodyTemplateListTemplateContainer extends $tea.Model {
  format?: string;
  static names(): { [key: string]: string } {
    return {
      format: 'Format',
    };
  }

  static types(): { [key: string]: any } {
    return {
      format: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTemplateListResponseBodyTemplateListTemplate extends $tea.Model {
  video?: QueryTemplateListResponseBodyTemplateListTemplateVideo;
  transConfig?: QueryTemplateListResponseBodyTemplateListTemplateTransConfig;
  state?: string;
  muxConfig?: QueryTemplateListResponseBodyTemplateListTemplateMuxConfig;
  name?: string;
  audio?: QueryTemplateListResponseBodyTemplateListTemplateAudio;
  id?: string;
  container?: QueryTemplateListResponseBodyTemplateListTemplateContainer;
  static names(): { [key: string]: string } {
    return {
      video: 'Video',
      transConfig: 'TransConfig',
      state: 'State',
      muxConfig: 'MuxConfig',
      name: 'Name',
      audio: 'Audio',
      id: 'Id',
      container: 'Container',
    };
  }

  static types(): { [key: string]: any } {
    return {
      video: QueryTemplateListResponseBodyTemplateListTemplateVideo,
      transConfig: QueryTemplateListResponseBodyTemplateListTemplateTransConfig,
      state: 'string',
      muxConfig: QueryTemplateListResponseBodyTemplateListTemplateMuxConfig,
      name: 'string',
      audio: QueryTemplateListResponseBodyTemplateListTemplateAudio,
      id: 'string',
      container: QueryTemplateListResponseBodyTemplateListTemplateContainer,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTemplateListResponseBodyTemplateList extends $tea.Model {
  template?: QueryTemplateListResponseBodyTemplateListTemplate[];
  static names(): { [key: string]: string } {
    return {
      template: 'Template',
    };
  }

  static types(): { [key: string]: any } {
    return {
      template: { 'type': 'array', 'itemType': QueryTemplateListResponseBodyTemplateListTemplate },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobCensorTerrorismResultTerrorismTopListTop extends $tea.Model {
  index?: string;
  score?: string;
  timestamp?: string;
  object?: string;
  label?: string;
  static names(): { [key: string]: string } {
    return {
      index: 'Index',
      score: 'Score',
      timestamp: 'Timestamp',
      object: 'Object',
      label: 'Label',
    };
  }

  static types(): { [key: string]: any } {
    return {
      index: 'string',
      score: 'string',
      timestamp: 'string',
      object: 'string',
      label: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobCensorTerrorismResultTerrorismTopList extends $tea.Model {
  top?: QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobCensorTerrorismResultTerrorismTopListTop[];
  static names(): { [key: string]: string } {
    return {
      top: 'Top',
    };
  }

  static types(): { [key: string]: any } {
    return {
      top: { 'type': 'array', 'itemType': QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobCensorTerrorismResultTerrorismTopListTop },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobCensorTerrorismResultTerrorismCounterListCounter extends $tea.Model {
  label?: string;
  count?: number;
  static names(): { [key: string]: string } {
    return {
      label: 'Label',
      count: 'Count',
    };
  }

  static types(): { [key: string]: any } {
    return {
      label: 'string',
      count: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobCensorTerrorismResultTerrorismCounterList extends $tea.Model {
  counter?: QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobCensorTerrorismResultTerrorismCounterListCounter[];
  static names(): { [key: string]: string } {
    return {
      counter: 'Counter',
    };
  }

  static types(): { [key: string]: any } {
    return {
      counter: { 'type': 'array', 'itemType': QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobCensorTerrorismResultTerrorismCounterListCounter },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobCensorTerrorismResult extends $tea.Model {
  terrorismTopList?: QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobCensorTerrorismResultTerrorismTopList;
  suggestion?: string;
  averageScore?: string;
  terrorismCounterList?: QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobCensorTerrorismResultTerrorismCounterList;
  label?: string;
  maxScore?: string;
  static names(): { [key: string]: string } {
    return {
      terrorismTopList: 'TerrorismTopList',
      suggestion: 'Suggestion',
      averageScore: 'AverageScore',
      terrorismCounterList: 'TerrorismCounterList',
      label: 'Label',
      maxScore: 'MaxScore',
    };
  }

  static types(): { [key: string]: any } {
    return {
      terrorismTopList: QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobCensorTerrorismResultTerrorismTopList,
      suggestion: 'string',
      averageScore: 'string',
      terrorismCounterList: QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobCensorTerrorismResultTerrorismCounterList,
      label: 'string',
      maxScore: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobTerrorismConfigOutputFile extends $tea.Model {
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobTerrorismConfig extends $tea.Model {
  interval?: string;
  outputFile?: QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobTerrorismConfigOutputFile;
  bizType?: string;
  static names(): { [key: string]: string } {
    return {
      interval: 'Interval',
      outputFile: 'OutputFile',
      bizType: 'BizType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      interval: 'string',
      outputFile: QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobTerrorismConfigOutputFile,
      bizType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobInput extends $tea.Model {
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJob extends $tea.Model {
  creationTime?: string;
  state?: string;
  userData?: string;
  code?: string;
  message?: string;
  censorTerrorismResult?: QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobCensorTerrorismResult;
  terrorismConfig?: QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobTerrorismConfig;
  pipelineId?: string;
  input?: QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobInput;
  id?: string;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      state: 'State',
      userData: 'UserData',
      code: 'Code',
      message: 'Message',
      censorTerrorismResult: 'CensorTerrorismResult',
      terrorismConfig: 'TerrorismConfig',
      pipelineId: 'PipelineId',
      input: 'Input',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      state: 'string',
      userData: 'string',
      code: 'string',
      message: 'string',
      censorTerrorismResult: QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobCensorTerrorismResult,
      terrorismConfig: QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobTerrorismConfig,
      pipelineId: 'string',
      input: QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJobInput,
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTerrorismJobListResponseBodyTerrorismJobList extends $tea.Model {
  terrorismJob?: QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJob[];
  static names(): { [key: string]: string } {
    return {
      terrorismJob: 'TerrorismJob',
    };
  }

  static types(): { [key: string]: any } {
    return {
      terrorismJob: { 'type': 'array', 'itemType': QueryTerrorismJobListResponseBodyTerrorismJobListTerrorismJob },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTerrorismJobListResponseBodyNonExistIds extends $tea.Model {
  string?: string[];
  static names(): { [key: string]: string } {
    return {
      string: 'String',
    };
  }

  static types(): { [key: string]: any } {
    return {
      string: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTerrorismPipelineListResponseBodyPipelineListPipelineNotifyConfig extends $tea.Model {
  topic?: string;
  queue?: string;
  static names(): { [key: string]: string } {
    return {
      topic: 'Topic',
      queue: 'Queue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      topic: 'string',
      queue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTerrorismPipelineListResponseBodyPipelineListPipeline extends $tea.Model {
  state?: string;
  notifyConfig?: QueryTerrorismPipelineListResponseBodyPipelineListPipelineNotifyConfig;
  priority?: string;
  name?: string;
  id?: string;
  static names(): { [key: string]: string } {
    return {
      state: 'State',
      notifyConfig: 'NotifyConfig',
      priority: 'Priority',
      name: 'Name',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      state: 'string',
      notifyConfig: QueryTerrorismPipelineListResponseBodyPipelineListPipelineNotifyConfig,
      priority: 'string',
      name: 'string',
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTerrorismPipelineListResponseBodyPipelineList extends $tea.Model {
  pipeline?: QueryTerrorismPipelineListResponseBodyPipelineListPipeline[];
  static names(): { [key: string]: string } {
    return {
      pipeline: 'Pipeline',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pipeline: { 'type': 'array', 'itemType': QueryTerrorismPipelineListResponseBodyPipelineListPipeline },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTerrorismPipelineListResponseBodyNonExistIds extends $tea.Model {
  string?: string[];
  static names(): { [key: string]: string } {
    return {
      string: 'String',
    };
  }

  static types(): { [key: string]: any } {
    return {
      string: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryVideoGifJobListResponseBodyJobListJobVideoGifResultOutputFile extends $tea.Model {
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryVideoGifJobListResponseBodyJobListJobVideoGifResult extends $tea.Model {
  outputFile?: QueryVideoGifJobListResponseBodyJobListJobVideoGifResultOutputFile;
  static names(): { [key: string]: string } {
    return {
      outputFile: 'OutputFile',
    };
  }

  static types(): { [key: string]: any } {
    return {
      outputFile: QueryVideoGifJobListResponseBodyJobListJobVideoGifResultOutputFile,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryVideoGifJobListResponseBodyJobListJobInput extends $tea.Model {
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryVideoGifJobListResponseBodyJobListJob extends $tea.Model {
  creationTime?: string;
  state?: string;
  userData?: string;
  code?: string;
  videoGifResult?: QueryVideoGifJobListResponseBodyJobListJobVideoGifResult;
  message?: string;
  pipelineId?: string;
  input?: QueryVideoGifJobListResponseBodyJobListJobInput;
  id?: string;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      state: 'State',
      userData: 'UserData',
      code: 'Code',
      videoGifResult: 'VideoGifResult',
      message: 'Message',
      pipelineId: 'PipelineId',
      input: 'Input',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      state: 'string',
      userData: 'string',
      code: 'string',
      videoGifResult: QueryVideoGifJobListResponseBodyJobListJobVideoGifResult,
      message: 'string',
      pipelineId: 'string',
      input: QueryVideoGifJobListResponseBodyJobListJobInput,
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryVideoGifJobListResponseBodyJobList extends $tea.Model {
  job?: QueryVideoGifJobListResponseBodyJobListJob[];
  static names(): { [key: string]: string } {
    return {
      job: 'Job',
    };
  }

  static types(): { [key: string]: any } {
    return {
      job: { 'type': 'array', 'itemType': QueryVideoGifJobListResponseBodyJobListJob },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryVideoGifJobListResponseBodyNonExistIds extends $tea.Model {
  string?: string[];
  static names(): { [key: string]: string } {
    return {
      string: 'String',
    };
  }

  static types(): { [key: string]: any } {
    return {
      string: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryVideoPoseJobListResponseBodyNonExistJobIds extends $tea.Model {
  string?: string[];
  static names(): { [key: string]: string } {
    return {
      string: 'String',
    };
  }

  static types(): { [key: string]: any } {
    return {
      string: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryVideoPoseJobListResponseBodyJobListJobOutputConfigDataFile extends $tea.Model {
  roleArn?: string;
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      roleArn: 'RoleArn',
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      roleArn: 'string',
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryVideoPoseJobListResponseBodyJobListJobOutputConfigVideoFile extends $tea.Model {
  roleArn?: string;
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      roleArn: 'RoleArn',
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      roleArn: 'string',
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryVideoPoseJobListResponseBodyJobListJobOutputConfig extends $tea.Model {
  dataFile?: QueryVideoPoseJobListResponseBodyJobListJobOutputConfigDataFile;
  videoFile?: QueryVideoPoseJobListResponseBodyJobListJobOutputConfigVideoFile;
  static names(): { [key: string]: string } {
    return {
      dataFile: 'DataFile',
      videoFile: 'VideoFile',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataFile: QueryVideoPoseJobListResponseBodyJobListJobOutputConfigDataFile,
      videoFile: QueryVideoPoseJobListResponseBodyJobListJobOutputConfigVideoFile,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryVideoPoseJobListResponseBodyJobListJobMNSMessageResult extends $tea.Model {
  messageId?: string;
  errorMessage?: string;
  errorCode?: string;
  static names(): { [key: string]: string } {
    return {
      messageId: 'MessageId',
      errorMessage: 'ErrorMessage',
      errorCode: 'ErrorCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      messageId: 'string',
      errorMessage: 'string',
      errorCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryVideoPoseJobListResponseBodyJobListJobInput extends $tea.Model {
  roleArn?: string;
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      roleArn: 'RoleArn',
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      roleArn: 'string',
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost extends $tea.Model {
  preloadTime?: string;
  avgBitrate?: string;
  costBandwidth?: string;
  static names(): { [key: string]: string } {
    return {
      preloadTime: 'PreloadTime',
      avgBitrate: 'AvgBitrate',
      costBandwidth: 'CostBandwidth',
    };
  }

  static types(): { [key: string]: any } {
    return {
      preloadTime: 'string',
      avgBitrate: 'string',
      costBandwidth: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreamsVideoStreamListVideoStream extends $tea.Model {
  sar?: string;
  height?: string;
  codecTagString?: string;
  networkCost?: QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost;
  width?: string;
  index?: string;
  timebase?: string;
  avgFPS?: string;
  pixFmt?: string;
  lang?: string;
  codecLongName?: string;
  numFrames?: string;
  rotate?: string;
  bitrate?: string;
  hasBFrames?: string;
  profile?: string;
  startTime?: string;
  dar?: string;
  codecName?: string;
  duration?: string;
  fps?: string;
  codecTag?: string;
  codecTimeBase?: string;
  level?: string;
  static names(): { [key: string]: string } {
    return {
      sar: 'Sar',
      height: 'Height',
      codecTagString: 'CodecTagString',
      networkCost: 'NetworkCost',
      width: 'Width',
      index: 'Index',
      timebase: 'Timebase',
      avgFPS: 'AvgFPS',
      pixFmt: 'PixFmt',
      lang: 'Lang',
      codecLongName: 'CodecLongName',
      numFrames: 'NumFrames',
      rotate: 'Rotate',
      bitrate: 'Bitrate',
      hasBFrames: 'HasBFrames',
      profile: 'Profile',
      startTime: 'StartTime',
      dar: 'Dar',
      codecName: 'CodecName',
      duration: 'Duration',
      fps: 'Fps',
      codecTag: 'CodecTag',
      codecTimeBase: 'CodecTimeBase',
      level: 'Level',
    };
  }

  static types(): { [key: string]: any } {
    return {
      sar: 'string',
      height: 'string',
      codecTagString: 'string',
      networkCost: QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost,
      width: 'string',
      index: 'string',
      timebase: 'string',
      avgFPS: 'string',
      pixFmt: 'string',
      lang: 'string',
      codecLongName: 'string',
      numFrames: 'string',
      rotate: 'string',
      bitrate: 'string',
      hasBFrames: 'string',
      profile: 'string',
      startTime: 'string',
      dar: 'string',
      codecName: 'string',
      duration: 'string',
      fps: 'string',
      codecTag: 'string',
      codecTimeBase: 'string',
      level: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreamsVideoStreamList extends $tea.Model {
  videoStream?: QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreamsVideoStreamListVideoStream[];
  static names(): { [key: string]: string } {
    return {
      videoStream: 'VideoStream',
    };
  }

  static types(): { [key: string]: any } {
    return {
      videoStream: { 'type': 'array', 'itemType': QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreamsVideoStreamListVideoStream },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreamsAudioStreamListAudioStream extends $tea.Model {
  timebase?: string;
  index?: string;
  sampleFmt?: string;
  channelLayout?: string;
  lang?: string;
  samplerate?: string;
  codecLongName?: string;
  channels?: string;
  numFrames?: string;
  bitrate?: string;
  codecTagString?: string;
  startTime?: string;
  codecName?: string;
  duration?: string;
  codecTag?: string;
  codecTimeBase?: string;
  static names(): { [key: string]: string } {
    return {
      timebase: 'Timebase',
      index: 'Index',
      sampleFmt: 'SampleFmt',
      channelLayout: 'ChannelLayout',
      lang: 'Lang',
      samplerate: 'Samplerate',
      codecLongName: 'CodecLongName',
      channels: 'Channels',
      numFrames: 'NumFrames',
      bitrate: 'Bitrate',
      codecTagString: 'CodecTagString',
      startTime: 'StartTime',
      codecName: 'CodecName',
      duration: 'Duration',
      codecTag: 'CodecTag',
      codecTimeBase: 'CodecTimeBase',
    };
  }

  static types(): { [key: string]: any } {
    return {
      timebase: 'string',
      index: 'string',
      sampleFmt: 'string',
      channelLayout: 'string',
      lang: 'string',
      samplerate: 'string',
      codecLongName: 'string',
      channels: 'string',
      numFrames: 'string',
      bitrate: 'string',
      codecTagString: 'string',
      startTime: 'string',
      codecName: 'string',
      duration: 'string',
      codecTag: 'string',
      codecTimeBase: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreamsAudioStreamList extends $tea.Model {
  audioStream?: QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreamsAudioStreamListAudioStream[];
  static names(): { [key: string]: string } {
    return {
      audioStream: 'AudioStream',
    };
  }

  static types(): { [key: string]: any } {
    return {
      audioStream: { 'type': 'array', 'itemType': QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreamsAudioStreamListAudioStream },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreamsSubtitleStreamListSubtitleStream extends $tea.Model {
  timebase?: string;
  index?: string;
  startTime?: string;
  codecName?: string;
  lang?: string;
  codecLongName?: string;
  duration?: string;
  codecTag?: string;
  codecTimeBase?: string;
  codecTagString?: string;
  static names(): { [key: string]: string } {
    return {
      timebase: 'Timebase',
      index: 'Index',
      startTime: 'StartTime',
      codecName: 'CodecName',
      lang: 'Lang',
      codecLongName: 'CodecLongName',
      duration: 'Duration',
      codecTag: 'CodecTag',
      codecTimeBase: 'CodecTimeBase',
      codecTagString: 'CodecTagString',
    };
  }

  static types(): { [key: string]: any } {
    return {
      timebase: 'string',
      index: 'string',
      startTime: 'string',
      codecName: 'string',
      lang: 'string',
      codecLongName: 'string',
      duration: 'string',
      codecTag: 'string',
      codecTimeBase: 'string',
      codecTagString: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreamsSubtitleStreamList extends $tea.Model {
  subtitleStream?: QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreamsSubtitleStreamListSubtitleStream[];
  static names(): { [key: string]: string } {
    return {
      subtitleStream: 'SubtitleStream',
    };
  }

  static types(): { [key: string]: any } {
    return {
      subtitleStream: { 'type': 'array', 'itemType': QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreamsSubtitleStreamListSubtitleStream },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreams extends $tea.Model {
  videoStreamList?: QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreamsVideoStreamList;
  audioStreamList?: QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreamsAudioStreamList;
  subtitleStreamList?: QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreamsSubtitleStreamList;
  static names(): { [key: string]: string } {
    return {
      videoStreamList: 'VideoStreamList',
      audioStreamList: 'AudioStreamList',
      subtitleStreamList: 'SubtitleStreamList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      videoStreamList: QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreamsVideoStreamList,
      audioStreamList: QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreamsAudioStreamList,
      subtitleStreamList: QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreamsSubtitleStreamList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryVideoPoseJobListResponseBodyJobListJobPropertiesFormat extends $tea.Model {
  startTime?: string;
  numPrograms?: string;
  size?: string;
  numStreams?: string;
  formatLongName?: string;
  duration?: string;
  bitrate?: string;
  formatName?: string;
  static names(): { [key: string]: string } {
    return {
      startTime: 'StartTime',
      numPrograms: 'NumPrograms',
      size: 'Size',
      numStreams: 'NumStreams',
      formatLongName: 'FormatLongName',
      duration: 'Duration',
      bitrate: 'Bitrate',
      formatName: 'FormatName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      startTime: 'string',
      numPrograms: 'string',
      size: 'string',
      numStreams: 'string',
      formatLongName: 'string',
      duration: 'string',
      bitrate: 'string',
      formatName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryVideoPoseJobListResponseBodyJobListJobProperties extends $tea.Model {
  width?: string;
  height?: string;
  duration?: string;
  fps?: string;
  bitrate?: string;
  fileFormat?: string;
  streams?: QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreams;
  format?: QueryVideoPoseJobListResponseBodyJobListJobPropertiesFormat;
  fileSize?: string;
  static names(): { [key: string]: string } {
    return {
      width: 'Width',
      height: 'Height',
      duration: 'Duration',
      fps: 'Fps',
      bitrate: 'Bitrate',
      fileFormat: 'FileFormat',
      streams: 'Streams',
      format: 'Format',
      fileSize: 'FileSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      width: 'string',
      height: 'string',
      duration: 'string',
      fps: 'string',
      bitrate: 'string',
      fileFormat: 'string',
      streams: QueryVideoPoseJobListResponseBodyJobListJobPropertiesStreams,
      format: QueryVideoPoseJobListResponseBodyJobListJobPropertiesFormat,
      fileSize: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryVideoPoseJobListResponseBodyJobListJob extends $tea.Model {
  outputConfig?: QueryVideoPoseJobListResponseBodyJobListJobOutputConfig;
  state?: string;
  jobId?: string;
  userData?: string;
  pipelineId?: string;
  MNSMessageResult?: QueryVideoPoseJobListResponseBodyJobListJobMNSMessageResult;
  input?: QueryVideoPoseJobListResponseBodyJobListJobInput;
  properties?: QueryVideoPoseJobListResponseBodyJobListJobProperties;
  static names(): { [key: string]: string } {
    return {
      outputConfig: 'OutputConfig',
      state: 'State',
      jobId: 'JobId',
      userData: 'UserData',
      pipelineId: 'PipelineId',
      MNSMessageResult: 'MNSMessageResult',
      input: 'Input',
      properties: 'Properties',
    };
  }

  static types(): { [key: string]: any } {
    return {
      outputConfig: QueryVideoPoseJobListResponseBodyJobListJobOutputConfig,
      state: 'string',
      jobId: 'string',
      userData: 'string',
      pipelineId: 'string',
      MNSMessageResult: QueryVideoPoseJobListResponseBodyJobListJobMNSMessageResult,
      input: QueryVideoPoseJobListResponseBodyJobListJobInput,
      properties: QueryVideoPoseJobListResponseBodyJobListJobProperties,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryVideoPoseJobListResponseBodyJobList extends $tea.Model {
  job?: QueryVideoPoseJobListResponseBodyJobListJob[];
  static names(): { [key: string]: string } {
    return {
      job: 'Job',
    };
  }

  static types(): { [key: string]: any } {
    return {
      job: { 'type': 'array', 'itemType': QueryVideoPoseJobListResponseBodyJobListJob },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryVideoQualityJobResponseBodyJob extends $tea.Model {
  status?: string;
  jobId?: string;
  userId?: number;
  videoQualityResults?: string;
  message?: string;
  output?: string;
  static names(): { [key: string]: string } {
    return {
      status: 'Status',
      jobId: 'JobId',
      userId: 'UserId',
      videoQualityResults: 'VideoQualityResults',
      message: 'Message',
      output: 'Output',
    };
  }

  static types(): { [key: string]: any } {
    return {
      status: 'string',
      jobId: 'string',
      userId: 'number',
      videoQualityResults: 'string',
      message: 'string',
      output: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryVideoSplitJobListResponseBodyJobListJobVideoSplitResultVideoSplitListVideoSplit extends $tea.Model {
  endTime?: string;
  startTime?: string;
  path?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      startTime: 'StartTime',
      path: 'Path',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      startTime: 'string',
      path: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryVideoSplitJobListResponseBodyJobListJobVideoSplitResultVideoSplitList extends $tea.Model {
  videoSplit?: QueryVideoSplitJobListResponseBodyJobListJobVideoSplitResultVideoSplitListVideoSplit[];
  static names(): { [key: string]: string } {
    return {
      videoSplit: 'VideoSplit',
    };
  }

  static types(): { [key: string]: any } {
    return {
      videoSplit: { 'type': 'array', 'itemType': QueryVideoSplitJobListResponseBodyJobListJobVideoSplitResultVideoSplitListVideoSplit },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryVideoSplitJobListResponseBodyJobListJobVideoSplitResult extends $tea.Model {
  videoSplitList?: QueryVideoSplitJobListResponseBodyJobListJobVideoSplitResultVideoSplitList;
  static names(): { [key: string]: string } {
    return {
      videoSplitList: 'VideoSplitList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      videoSplitList: QueryVideoSplitJobListResponseBodyJobListJobVideoSplitResultVideoSplitList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryVideoSplitJobListResponseBodyJobListJobInput extends $tea.Model {
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryVideoSplitJobListResponseBodyJobListJob extends $tea.Model {
  creationTime?: string;
  state?: string;
  userData?: string;
  code?: string;
  message?: string;
  videoSplitResult?: QueryVideoSplitJobListResponseBodyJobListJobVideoSplitResult;
  pipelineId?: string;
  input?: QueryVideoSplitJobListResponseBodyJobListJobInput;
  id?: string;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      state: 'State',
      userData: 'UserData',
      code: 'Code',
      message: 'Message',
      videoSplitResult: 'VideoSplitResult',
      pipelineId: 'PipelineId',
      input: 'Input',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      state: 'string',
      userData: 'string',
      code: 'string',
      message: 'string',
      videoSplitResult: QueryVideoSplitJobListResponseBodyJobListJobVideoSplitResult,
      pipelineId: 'string',
      input: QueryVideoSplitJobListResponseBodyJobListJobInput,
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryVideoSplitJobListResponseBodyJobList extends $tea.Model {
  job?: QueryVideoSplitJobListResponseBodyJobListJob[];
  static names(): { [key: string]: string } {
    return {
      job: 'Job',
    };
  }

  static types(): { [key: string]: any } {
    return {
      job: { 'type': 'array', 'itemType': QueryVideoSplitJobListResponseBodyJobListJob },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryVideoSplitJobListResponseBodyNonExistIds extends $tea.Model {
  string?: string[];
  static names(): { [key: string]: string } {
    return {
      string: 'String',
    };
  }

  static types(): { [key: string]: any } {
    return {
      string: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryVideoSummaryJobListResponseBodyJobListJobVideoSummaryResultVideoSummaryListVideoSummary extends $tea.Model {
  endTime?: string;
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryVideoSummaryJobListResponseBodyJobListJobVideoSummaryResultVideoSummaryList extends $tea.Model {
  videoSummary?: QueryVideoSummaryJobListResponseBodyJobListJobVideoSummaryResultVideoSummaryListVideoSummary[];
  static names(): { [key: string]: string } {
    return {
      videoSummary: 'VideoSummary',
    };
  }

  static types(): { [key: string]: any } {
    return {
      videoSummary: { 'type': 'array', 'itemType': QueryVideoSummaryJobListResponseBodyJobListJobVideoSummaryResultVideoSummaryListVideoSummary },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryVideoSummaryJobListResponseBodyJobListJobVideoSummaryResultOutputFile extends $tea.Model {
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryVideoSummaryJobListResponseBodyJobListJobVideoSummaryResult extends $tea.Model {
  videoSummaryList?: QueryVideoSummaryJobListResponseBodyJobListJobVideoSummaryResultVideoSummaryList;
  outputFile?: QueryVideoSummaryJobListResponseBodyJobListJobVideoSummaryResultOutputFile;
  static names(): { [key: string]: string } {
    return {
      videoSummaryList: 'VideoSummaryList',
      outputFile: 'OutputFile',
    };
  }

  static types(): { [key: string]: any } {
    return {
      videoSummaryList: QueryVideoSummaryJobListResponseBodyJobListJobVideoSummaryResultVideoSummaryList,
      outputFile: QueryVideoSummaryJobListResponseBodyJobListJobVideoSummaryResultOutputFile,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryVideoSummaryJobListResponseBodyJobListJobInput extends $tea.Model {
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryVideoSummaryJobListResponseBodyJobListJob extends $tea.Model {
  creationTime?: string;
  state?: string;
  userData?: string;
  code?: string;
  message?: string;
  videoSummaryResult?: QueryVideoSummaryJobListResponseBodyJobListJobVideoSummaryResult;
  pipelineId?: string;
  input?: QueryVideoSummaryJobListResponseBodyJobListJobInput;
  id?: string;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      state: 'State',
      userData: 'UserData',
      code: 'Code',
      message: 'Message',
      videoSummaryResult: 'VideoSummaryResult',
      pipelineId: 'PipelineId',
      input: 'Input',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      state: 'string',
      userData: 'string',
      code: 'string',
      message: 'string',
      videoSummaryResult: QueryVideoSummaryJobListResponseBodyJobListJobVideoSummaryResult,
      pipelineId: 'string',
      input: QueryVideoSummaryJobListResponseBodyJobListJobInput,
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryVideoSummaryJobListResponseBodyJobList extends $tea.Model {
  job?: QueryVideoSummaryJobListResponseBodyJobListJob[];
  static names(): { [key: string]: string } {
    return {
      job: 'Job',
    };
  }

  static types(): { [key: string]: any } {
    return {
      job: { 'type': 'array', 'itemType': QueryVideoSummaryJobListResponseBodyJobListJob },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryVideoSummaryJobListResponseBodyNonExistIds extends $tea.Model {
  string?: string[];
  static names(): { [key: string]: string } {
    return {
      string: 'String',
    };
  }

  static types(): { [key: string]: any } {
    return {
      string: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryWaterMarkTemplateListResponseBodyNonExistWids extends $tea.Model {
  string?: string[];
  static names(): { [key: string]: string } {
    return {
      string: 'String',
    };
  }

  static types(): { [key: string]: any } {
    return {
      string: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplateRatioRefer extends $tea.Model {
  dx?: string;
  width?: string;
  height?: string;
  dy?: string;
  static names(): { [key: string]: string } {
    return {
      dx: 'Dx',
      width: 'Width',
      height: 'Height',
      dy: 'Dy',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dx: 'string',
      width: 'string',
      height: 'string',
      dy: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplateTimeline extends $tea.Model {
  start?: string;
  duration?: string;
  static names(): { [key: string]: string } {
    return {
      start: 'Start',
      duration: 'Duration',
    };
  }

  static types(): { [key: string]: any } {
    return {
      start: 'string',
      duration: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplate extends $tea.Model {
  type?: string;
  ratioRefer?: QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplateRatioRefer;
  referPos?: string;
  state?: string;
  dx?: string;
  width?: string;
  height?: string;
  timeline?: QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplateTimeline;
  name?: string;
  dy?: string;
  id?: string;
  static names(): { [key: string]: string } {
    return {
      type: 'Type',
      ratioRefer: 'RatioRefer',
      referPos: 'ReferPos',
      state: 'State',
      dx: 'Dx',
      width: 'Width',
      height: 'Height',
      timeline: 'Timeline',
      name: 'Name',
      dy: 'Dy',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      type: 'string',
      ratioRefer: QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplateRatioRefer,
      referPos: 'string',
      state: 'string',
      dx: 'string',
      width: 'string',
      height: 'string',
      timeline: QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplateTimeline,
      name: 'string',
      dy: 'string',
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateList extends $tea.Model {
  waterMarkTemplate?: QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplate[];
  static names(): { [key: string]: string } {
    return {
      waterMarkTemplate: 'WaterMarkTemplate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      waterMarkTemplate: { 'type': 'array', 'itemType': QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplate },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RefreshCdnDomainConfigsCacheResponseBodySucessDomains extends $tea.Model {
  string?: string[];
  static names(): { [key: string]: string } {
    return {
      string: 'String',
    };
  }

  static types(): { [key: string]: any } {
    return {
      string: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RefreshCdnDomainConfigsCacheResponseBodyFailedDomains extends $tea.Model {
  string?: string[];
  static names(): { [key: string]: string } {
    return {
      string: 'String',
    };
  }

  static types(): { [key: string]: any } {
    return {
      string: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RegisterMediaDetailPersonResponseBodyRegisteredPersonagesRegisteredPersonageImageFile extends $tea.Model {
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RegisterMediaDetailPersonResponseBodyRegisteredPersonagesRegisteredPersonage extends $tea.Model {
  quality?: string;
  imageFile?: RegisterMediaDetailPersonResponseBodyRegisteredPersonagesRegisteredPersonageImageFile;
  personName?: string;
  gender?: string;
  faceId?: string;
  target?: string;
  imageId?: string;
  static names(): { [key: string]: string } {
    return {
      quality: 'Quality',
      imageFile: 'ImageFile',
      personName: 'PersonName',
      gender: 'Gender',
      faceId: 'FaceId',
      target: 'Target',
      imageId: 'ImageId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      quality: 'string',
      imageFile: RegisterMediaDetailPersonResponseBodyRegisteredPersonagesRegisteredPersonageImageFile,
      personName: 'string',
      gender: 'string',
      faceId: 'string',
      target: 'string',
      imageId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RegisterMediaDetailPersonResponseBodyRegisteredPersonages extends $tea.Model {
  registeredPersonage?: RegisterMediaDetailPersonResponseBodyRegisteredPersonagesRegisteredPersonage[];
  static names(): { [key: string]: string } {
    return {
      registeredPersonage: 'RegisteredPersonage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      registeredPersonage: { 'type': 'array', 'itemType': RegisterMediaDetailPersonResponseBodyRegisteredPersonagesRegisteredPersonage },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RegisterMediaDetailPersonResponseBodyFailedImagesFailedImageImageFile extends $tea.Model {
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RegisterMediaDetailPersonResponseBodyFailedImagesFailedImage extends $tea.Model {
  imageFile?: RegisterMediaDetailPersonResponseBodyFailedImagesFailedImageImageFile;
  success?: string;
  code?: string;
  static names(): { [key: string]: string } {
    return {
      imageFile: 'ImageFile',
      success: 'Success',
      code: 'Code',
    };
  }

  static types(): { [key: string]: any } {
    return {
      imageFile: RegisterMediaDetailPersonResponseBodyFailedImagesFailedImageImageFile,
      success: 'string',
      code: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RegisterMediaDetailPersonResponseBodyFailedImages extends $tea.Model {
  failedImage?: RegisterMediaDetailPersonResponseBodyFailedImagesFailedImage[];
  static names(): { [key: string]: string } {
    return {
      failedImage: 'FailedImage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failedImage: { 'type': 'array', 'itemType': RegisterMediaDetailPersonResponseBodyFailedImagesFailedImage },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchMediaResponseBodyMediaListMediaTags extends $tea.Model {
  tag?: string[];
  static names(): { [key: string]: string } {
    return {
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tag: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchMediaResponseBodyMediaListMediaFile extends $tea.Model {
  state?: string;
  URL?: string;
  static names(): { [key: string]: string } {
    return {
      state: 'State',
      URL: 'URL',
    };
  }

  static types(): { [key: string]: any } {
    return {
      state: 'string',
      URL: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchMediaResponseBodyMediaListMediaRunIdList extends $tea.Model {
  runId?: string[];
  static names(): { [key: string]: string } {
    return {
      runId: 'RunId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      runId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchMediaResponseBodyMediaListMedia extends $tea.Model {
  creationTime?: string;
  cateId?: number;
  height?: string;
  tags?: SearchMediaResponseBodyMediaListMediaTags;
  bitrate?: string;
  mediaId?: string;
  file?: SearchMediaResponseBodyMediaListMediaFile;
  publishState?: string;
  description?: string;
  width?: string;
  size?: string;
  coverURL?: string;
  runIdList?: SearchMediaResponseBodyMediaListMediaRunIdList;
  duration?: string;
  fps?: string;
  title?: string;
  format?: string;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      cateId: 'CateId',
      height: 'Height',
      tags: 'Tags',
      bitrate: 'Bitrate',
      mediaId: 'MediaId',
      file: 'File',
      publishState: 'PublishState',
      description: 'Description',
      width: 'Width',
      size: 'Size',
      coverURL: 'CoverURL',
      runIdList: 'RunIdList',
      duration: 'Duration',
      fps: 'Fps',
      title: 'Title',
      format: 'Format',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      cateId: 'number',
      height: 'string',
      tags: SearchMediaResponseBodyMediaListMediaTags,
      bitrate: 'string',
      mediaId: 'string',
      file: SearchMediaResponseBodyMediaListMediaFile,
      publishState: 'string',
      description: 'string',
      width: 'string',
      size: 'string',
      coverURL: 'string',
      runIdList: SearchMediaResponseBodyMediaListMediaRunIdList,
      duration: 'string',
      fps: 'string',
      title: 'string',
      format: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchMediaResponseBodyMediaList extends $tea.Model {
  media?: SearchMediaResponseBodyMediaListMedia[];
  static names(): { [key: string]: string } {
    return {
      media: 'Media',
    };
  }

  static types(): { [key: string]: any } {
    return {
      media: { 'type': 'array', 'itemType': SearchMediaResponseBodyMediaListMedia },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchMediaWorkflowResponseBodyMediaWorkflowListMediaWorkflow extends $tea.Model {
  creationTime?: string;
  mediaWorkflowId?: string;
  state?: string;
  triggerMode?: string;
  name?: string;
  topology?: string;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      mediaWorkflowId: 'MediaWorkflowId',
      state: 'State',
      triggerMode: 'TriggerMode',
      name: 'Name',
      topology: 'Topology',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      mediaWorkflowId: 'string',
      state: 'string',
      triggerMode: 'string',
      name: 'string',
      topology: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchMediaWorkflowResponseBodyMediaWorkflowList extends $tea.Model {
  mediaWorkflow?: SearchMediaWorkflowResponseBodyMediaWorkflowListMediaWorkflow[];
  static names(): { [key: string]: string } {
    return {
      mediaWorkflow: 'MediaWorkflow',
    };
  }

  static types(): { [key: string]: any } {
    return {
      mediaWorkflow: { 'type': 'array', 'itemType': SearchMediaWorkflowResponseBodyMediaWorkflowListMediaWorkflow },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchPipelineResponseBodyPipelineListPipelineNotifyConfig extends $tea.Model {
  mqTopic?: string;
  queueName?: string;
  mqTag?: string;
  topic?: string;
  static names(): { [key: string]: string } {
    return {
      mqTopic: 'MqTopic',
      queueName: 'QueueName',
      mqTag: 'MqTag',
      topic: 'Topic',
    };
  }

  static types(): { [key: string]: any } {
    return {
      mqTopic: 'string',
      queueName: 'string',
      mqTag: 'string',
      topic: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchPipelineResponseBodyPipelineListPipeline extends $tea.Model {
  speed?: string;
  state?: string;
  speedLevel?: number;
  notifyConfig?: SearchPipelineResponseBodyPipelineListPipelineNotifyConfig;
  role?: string;
  name?: string;
  id?: string;
  quotaAllocate?: number;
  static names(): { [key: string]: string } {
    return {
      speed: 'Speed',
      state: 'State',
      speedLevel: 'SpeedLevel',
      notifyConfig: 'NotifyConfig',
      role: 'Role',
      name: 'Name',
      id: 'Id',
      quotaAllocate: 'QuotaAllocate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      speed: 'string',
      state: 'string',
      speedLevel: 'number',
      notifyConfig: SearchPipelineResponseBodyPipelineListPipelineNotifyConfig,
      role: 'string',
      name: 'string',
      id: 'string',
      quotaAllocate: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchPipelineResponseBodyPipelineList extends $tea.Model {
  pipeline?: SearchPipelineResponseBodyPipelineListPipeline[];
  static names(): { [key: string]: string } {
    return {
      pipeline: 'Pipeline',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pipeline: { 'type': 'array', 'itemType': SearchPipelineResponseBodyPipelineListPipeline },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchTemplateResponseBodyTemplateListTemplateVideoBitrateBnd extends $tea.Model {
  max?: string;
  min?: string;
  static names(): { [key: string]: string } {
    return {
      max: 'Max',
      min: 'Min',
    };
  }

  static types(): { [key: string]: any } {
    return {
      max: 'string',
      min: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchTemplateResponseBodyTemplateListTemplateVideo extends $tea.Model {
  bufsize?: string;
  longShortMode?: string;
  degrain?: string;
  bitrateBnd?: SearchTemplateResponseBodyTemplateListTemplateVideoBitrateBnd;
  pixFmt?: string;
  pad?: string;
  codec?: string;
  height?: string;
  qscale?: string;
  crop?: string;
  bitrate?: string;
  maxrate?: string;
  maxFps?: string;
  profile?: string;
  crf?: string;
  remove?: string;
  gop?: string;
  width?: string;
  fps?: string;
  preset?: string;
  scanMode?: string;
  static names(): { [key: string]: string } {
    return {
      bufsize: 'Bufsize',
      longShortMode: 'LongShortMode',
      degrain: 'Degrain',
      bitrateBnd: 'BitrateBnd',
      pixFmt: 'PixFmt',
      pad: 'Pad',
      codec: 'Codec',
      height: 'Height',
      qscale: 'Qscale',
      crop: 'Crop',
      bitrate: 'Bitrate',
      maxrate: 'Maxrate',
      maxFps: 'MaxFps',
      profile: 'Profile',
      crf: 'Crf',
      remove: 'Remove',
      gop: 'Gop',
      width: 'Width',
      fps: 'Fps',
      preset: 'Preset',
      scanMode: 'ScanMode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bufsize: 'string',
      longShortMode: 'string',
      degrain: 'string',
      bitrateBnd: SearchTemplateResponseBodyTemplateListTemplateVideoBitrateBnd,
      pixFmt: 'string',
      pad: 'string',
      codec: 'string',
      height: 'string',
      qscale: 'string',
      crop: 'string',
      bitrate: 'string',
      maxrate: 'string',
      maxFps: 'string',
      profile: 'string',
      crf: 'string',
      remove: 'string',
      gop: 'string',
      width: 'string',
      fps: 'string',
      preset: 'string',
      scanMode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchTemplateResponseBodyTemplateListTemplateTransConfig extends $tea.Model {
  isCheckAudioBitrate?: string;
  transMode?: string;
  isCheckReso?: string;
  isCheckVideoBitrateFail?: string;
  adjDarMethod?: string;
  isCheckVideoBitrate?: string;
  isCheckResoFail?: string;
  isCheckAudioBitrateFail?: string;
  static names(): { [key: string]: string } {
    return {
      isCheckAudioBitrate: 'IsCheckAudioBitrate',
      transMode: 'TransMode',
      isCheckReso: 'IsCheckReso',
      isCheckVideoBitrateFail: 'IsCheckVideoBitrateFail',
      adjDarMethod: 'AdjDarMethod',
      isCheckVideoBitrate: 'IsCheckVideoBitrate',
      isCheckResoFail: 'IsCheckResoFail',
      isCheckAudioBitrateFail: 'IsCheckAudioBitrateFail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isCheckAudioBitrate: 'string',
      transMode: 'string',
      isCheckReso: 'string',
      isCheckVideoBitrateFail: 'string',
      adjDarMethod: 'string',
      isCheckVideoBitrate: 'string',
      isCheckResoFail: 'string',
      isCheckAudioBitrateFail: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchTemplateResponseBodyTemplateListTemplateMuxConfigGif extends $tea.Model {
  finalDelay?: string;
  ditherMode?: string;
  loop?: string;
  isCustomPalette?: string;
  static names(): { [key: string]: string } {
    return {
      finalDelay: 'FinalDelay',
      ditherMode: 'DitherMode',
      loop: 'Loop',
      isCustomPalette: 'IsCustomPalette',
    };
  }

  static types(): { [key: string]: any } {
    return {
      finalDelay: 'string',
      ditherMode: 'string',
      loop: 'string',
      isCustomPalette: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchTemplateResponseBodyTemplateListTemplateMuxConfigSegment extends $tea.Model {
  duration?: string;
  static names(): { [key: string]: string } {
    return {
      duration: 'Duration',
    };
  }

  static types(): { [key: string]: any } {
    return {
      duration: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchTemplateResponseBodyTemplateListTemplateMuxConfig extends $tea.Model {
  gif?: SearchTemplateResponseBodyTemplateListTemplateMuxConfigGif;
  segment?: SearchTemplateResponseBodyTemplateListTemplateMuxConfigSegment;
  static names(): { [key: string]: string } {
    return {
      gif: 'Gif',
      segment: 'Segment',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gif: SearchTemplateResponseBodyTemplateListTemplateMuxConfigGif,
      segment: SearchTemplateResponseBodyTemplateListTemplateMuxConfigSegment,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchTemplateResponseBodyTemplateListTemplateAudio extends $tea.Model {
  profile?: string;
  remove?: string;
  codec?: string;
  samplerate?: string;
  qscale?: string;
  channels?: string;
  bitrate?: string;
  static names(): { [key: string]: string } {
    return {
      profile: 'Profile',
      remove: 'Remove',
      codec: 'Codec',
      samplerate: 'Samplerate',
      qscale: 'Qscale',
      channels: 'Channels',
      bitrate: 'Bitrate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      profile: 'string',
      remove: 'string',
      codec: 'string',
      samplerate: 'string',
      qscale: 'string',
      channels: 'string',
      bitrate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchTemplateResponseBodyTemplateListTemplateContainer extends $tea.Model {
  format?: string;
  static names(): { [key: string]: string } {
    return {
      format: 'Format',
    };
  }

  static types(): { [key: string]: any } {
    return {
      format: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchTemplateResponseBodyTemplateListTemplate extends $tea.Model {
  video?: SearchTemplateResponseBodyTemplateListTemplateVideo;
  transConfig?: SearchTemplateResponseBodyTemplateListTemplateTransConfig;
  state?: string;
  muxConfig?: SearchTemplateResponseBodyTemplateListTemplateMuxConfig;
  name?: string;
  audio?: SearchTemplateResponseBodyTemplateListTemplateAudio;
  id?: string;
  container?: SearchTemplateResponseBodyTemplateListTemplateContainer;
  static names(): { [key: string]: string } {
    return {
      video: 'Video',
      transConfig: 'TransConfig',
      state: 'State',
      muxConfig: 'MuxConfig',
      name: 'Name',
      audio: 'Audio',
      id: 'Id',
      container: 'Container',
    };
  }

  static types(): { [key: string]: any } {
    return {
      video: SearchTemplateResponseBodyTemplateListTemplateVideo,
      transConfig: SearchTemplateResponseBodyTemplateListTemplateTransConfig,
      state: 'string',
      muxConfig: SearchTemplateResponseBodyTemplateListTemplateMuxConfig,
      name: 'string',
      audio: SearchTemplateResponseBodyTemplateListTemplateAudio,
      id: 'string',
      container: SearchTemplateResponseBodyTemplateListTemplateContainer,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchTemplateResponseBodyTemplateList extends $tea.Model {
  template?: SearchTemplateResponseBodyTemplateListTemplate[];
  static names(): { [key: string]: string } {
    return {
      template: 'Template',
    };
  }

  static types(): { [key: string]: any } {
    return {
      template: { 'type': 'array', 'itemType': SearchTemplateResponseBodyTemplateListTemplate },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplateRatioRefer extends $tea.Model {
  dx?: string;
  width?: string;
  height?: string;
  dy?: string;
  static names(): { [key: string]: string } {
    return {
      dx: 'Dx',
      width: 'Width',
      height: 'Height',
      dy: 'Dy',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dx: 'string',
      width: 'string',
      height: 'string',
      dy: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplateTimeline extends $tea.Model {
  start?: string;
  duration?: string;
  static names(): { [key: string]: string } {
    return {
      start: 'Start',
      duration: 'Duration',
    };
  }

  static types(): { [key: string]: any } {
    return {
      start: 'string',
      duration: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplate extends $tea.Model {
  type?: string;
  ratioRefer?: SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplateRatioRefer;
  referPos?: string;
  state?: string;
  dx?: string;
  width?: string;
  height?: string;
  timeline?: SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplateTimeline;
  name?: string;
  dy?: string;
  id?: string;
  static names(): { [key: string]: string } {
    return {
      type: 'Type',
      ratioRefer: 'RatioRefer',
      referPos: 'ReferPos',
      state: 'State',
      dx: 'Dx',
      width: 'Width',
      height: 'Height',
      timeline: 'Timeline',
      name: 'Name',
      dy: 'Dy',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      type: 'string',
      ratioRefer: SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplateRatioRefer,
      referPos: 'string',
      state: 'string',
      dx: 'string',
      width: 'string',
      height: 'string',
      timeline: SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplateTimeline,
      name: 'string',
      dy: 'string',
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchWaterMarkTemplateResponseBodyWaterMarkTemplateList extends $tea.Model {
  waterMarkTemplate?: SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplate[];
  static names(): { [key: string]: string } {
    return {
      waterMarkTemplate: 'WaterMarkTemplate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      waterMarkTemplate: { 'type': 'array', 'itemType': SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplate },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigQualityControl extends $tea.Model {
  methodStreaming?: string;
  rateQuality?: string;
  static names(): { [key: string]: string } {
    return {
      methodStreaming: 'MethodStreaming',
      rateQuality: 'RateQuality',
    };
  }

  static types(): { [key: string]: any } {
    return {
      methodStreaming: 'string',
      rateQuality: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigPropertiesControlCrop extends $tea.Model {
  top?: string;
  width?: string;
  height?: string;
  left?: string;
  mode?: string;
  static names(): { [key: string]: string } {
    return {
      top: 'Top',
      width: 'Width',
      height: 'Height',
      left: 'Left',
      mode: 'Mode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      top: 'string',
      width: 'string',
      height: 'string',
      left: 'string',
      mode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigPropertiesControl extends $tea.Model {
  deinterlace?: string;
  crop?: SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigPropertiesControlCrop;
  static names(): { [key: string]: string } {
    return {
      deinterlace: 'Deinterlace',
      crop: 'Crop',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deinterlace: 'string',
      crop: SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigPropertiesControlCrop,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfig extends $tea.Model {
  qualityControl?: SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigQualityControl;
  propertiesControl?: SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigPropertiesControl;
  static names(): { [key: string]: string } {
    return {
      qualityControl: 'QualityControl',
      propertiesControl: 'PropertiesControl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      qualityControl: SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigQualityControl,
      propertiesControl: SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigPropertiesControl,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitAnalysisJobResponseBodyAnalysisJobMNSMessageResult extends $tea.Model {
  messageId?: string;
  errorMessage?: string;
  errorCode?: string;
  static names(): { [key: string]: string } {
    return {
      messageId: 'MessageId',
      errorMessage: 'ErrorMessage',
      errorCode: 'ErrorCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      messageId: 'string',
      errorMessage: 'string',
      errorCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateVideoBitrateBnd extends $tea.Model {
  max?: string;
  min?: string;
  static names(): { [key: string]: string } {
    return {
      max: 'Max',
      min: 'Min',
    };
  }

  static types(): { [key: string]: any } {
    return {
      max: 'string',
      min: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateVideo extends $tea.Model {
  bufsize?: string;
  degrain?: string;
  bitrateBnd?: SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateVideoBitrateBnd;
  pixFmt?: string;
  codec?: string;
  height?: string;
  qscale?: string;
  bitrate?: string;
  maxrate?: string;
  profile?: string;
  crf?: string;
  gop?: string;
  width?: string;
  fps?: string;
  preset?: string;
  scanMode?: string;
  static names(): { [key: string]: string } {
    return {
      bufsize: 'Bufsize',
      degrain: 'Degrain',
      bitrateBnd: 'BitrateBnd',
      pixFmt: 'PixFmt',
      codec: 'Codec',
      height: 'Height',
      qscale: 'Qscale',
      bitrate: 'Bitrate',
      maxrate: 'Maxrate',
      profile: 'Profile',
      crf: 'Crf',
      gop: 'Gop',
      width: 'Width',
      fps: 'Fps',
      preset: 'Preset',
      scanMode: 'ScanMode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bufsize: 'string',
      degrain: 'string',
      bitrateBnd: SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateVideoBitrateBnd,
      pixFmt: 'string',
      codec: 'string',
      height: 'string',
      qscale: 'string',
      bitrate: 'string',
      maxrate: 'string',
      profile: 'string',
      crf: 'string',
      gop: 'string',
      width: 'string',
      fps: 'string',
      preset: 'string',
      scanMode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateTransConfig extends $tea.Model {
  transMode?: string;
  static names(): { [key: string]: string } {
    return {
      transMode: 'TransMode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      transMode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfigGif extends $tea.Model {
  finalDelay?: string;
  loop?: string;
  static names(): { [key: string]: string } {
    return {
      finalDelay: 'FinalDelay',
      loop: 'Loop',
    };
  }

  static types(): { [key: string]: any } {
    return {
      finalDelay: 'string',
      loop: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfigSegment extends $tea.Model {
  duration?: string;
  static names(): { [key: string]: string } {
    return {
      duration: 'Duration',
    };
  }

  static types(): { [key: string]: any } {
    return {
      duration: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfig extends $tea.Model {
  gif?: SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfigGif;
  segment?: SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfigSegment;
  static names(): { [key: string]: string } {
    return {
      gif: 'Gif',
      segment: 'Segment',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gif: SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfigGif,
      segment: SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfigSegment,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateAudio extends $tea.Model {
  profile?: string;
  codec?: string;
  samplerate?: string;
  qscale?: string;
  channels?: string;
  bitrate?: string;
  static names(): { [key: string]: string } {
    return {
      profile: 'Profile',
      codec: 'Codec',
      samplerate: 'Samplerate',
      qscale: 'Qscale',
      channels: 'Channels',
      bitrate: 'Bitrate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      profile: 'string',
      codec: 'string',
      samplerate: 'string',
      qscale: 'string',
      channels: 'string',
      bitrate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateContainer extends $tea.Model {
  format?: string;
  static names(): { [key: string]: string } {
    return {
      format: 'Format',
    };
  }

  static types(): { [key: string]: any } {
    return {
      format: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplate extends $tea.Model {
  video?: SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateVideo;
  transConfig?: SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateTransConfig;
  state?: string;
  muxConfig?: SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfig;
  name?: string;
  audio?: SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateAudio;
  id?: string;
  container?: SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateContainer;
  static names(): { [key: string]: string } {
    return {
      video: 'Video',
      transConfig: 'TransConfig',
      state: 'State',
      muxConfig: 'MuxConfig',
      name: 'Name',
      audio: 'Audio',
      id: 'Id',
      container: 'Container',
    };
  }

  static types(): { [key: string]: any } {
    return {
      video: SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateVideo,
      transConfig: SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateTransConfig,
      state: 'string',
      muxConfig: SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfig,
      name: 'string',
      audio: SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateAudio,
      id: 'string',
      container: SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateContainer,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitAnalysisJobResponseBodyAnalysisJobTemplateList extends $tea.Model {
  template?: SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplate[];
  static names(): { [key: string]: string } {
    return {
      template: 'Template',
    };
  }

  static types(): { [key: string]: any } {
    return {
      template: { 'type': 'array', 'itemType': SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplate },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitAnalysisJobResponseBodyAnalysisJobInputFile extends $tea.Model {
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitAnalysisJobResponseBodyAnalysisJob extends $tea.Model {
  creationTime?: string;
  percent?: number;
  state?: string;
  analysisConfig?: SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfig;
  message?: string;
  priority?: string;
  MNSMessageResult?: SubmitAnalysisJobResponseBodyAnalysisJobMNSMessageResult;
  templateList?: SubmitAnalysisJobResponseBodyAnalysisJobTemplateList;
  userData?: string;
  code?: string;
  inputFile?: SubmitAnalysisJobResponseBodyAnalysisJobInputFile;
  pipelineId?: string;
  id?: string;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      percent: 'Percent',
      state: 'State',
      analysisConfig: 'AnalysisConfig',
      message: 'Message',
      priority: 'Priority',
      MNSMessageResult: 'MNSMessageResult',
      templateList: 'TemplateList',
      userData: 'UserData',
      code: 'Code',
      inputFile: 'InputFile',
      pipelineId: 'PipelineId',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      percent: 'number',
      state: 'string',
      analysisConfig: SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfig,
      message: 'string',
      priority: 'string',
      MNSMessageResult: SubmitAnalysisJobResponseBodyAnalysisJobMNSMessageResult,
      templateList: SubmitAnalysisJobResponseBodyAnalysisJobTemplateList,
      userData: 'string',
      code: 'string',
      inputFile: SubmitAnalysisJobResponseBodyAnalysisJobInputFile,
      pipelineId: 'string',
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitBeautifyJobsResponseBodyJobListJobBeautifyConfigOutputFile extends $tea.Model {
  roleArn?: string;
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      roleArn: 'RoleArn',
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      roleArn: 'string',
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitBeautifyJobsResponseBodyJobListJobBeautifyConfig extends $tea.Model {
  outputFile?: SubmitBeautifyJobsResponseBodyJobListJobBeautifyConfigOutputFile;
  static names(): { [key: string]: string } {
    return {
      outputFile: 'OutputFile',
    };
  }

  static types(): { [key: string]: any } {
    return {
      outputFile: SubmitBeautifyJobsResponseBodyJobListJobBeautifyConfigOutputFile,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitBeautifyJobsResponseBodyJobListJobInput extends $tea.Model {
  roleArn?: string;
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      roleArn: 'RoleArn',
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      roleArn: 'string',
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitBeautifyJobsResponseBodyJobListJobMNSMessageResult extends $tea.Model {
  messageId?: string;
  errorMessage?: string;
  errorCode?: string;
  static names(): { [key: string]: string } {
    return {
      messageId: 'MessageId',
      errorMessage: 'ErrorMessage',
      errorCode: 'ErrorCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      messageId: 'string',
      errorMessage: 'string',
      errorCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitBeautifyJobsResponseBodyJobListJob extends $tea.Model {
  creationTime?: string;
  beautifyConfig?: SubmitBeautifyJobsResponseBodyJobListJobBeautifyConfig;
  state?: string;
  userData?: string;
  code?: string;
  message?: string;
  pipelineId?: string;
  input?: SubmitBeautifyJobsResponseBodyJobListJobInput;
  MNSMessageResult?: SubmitBeautifyJobsResponseBodyJobListJobMNSMessageResult;
  id?: string;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      beautifyConfig: 'BeautifyConfig',
      state: 'State',
      userData: 'UserData',
      code: 'Code',
      message: 'Message',
      pipelineId: 'PipelineId',
      input: 'Input',
      MNSMessageResult: 'MNSMessageResult',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      beautifyConfig: SubmitBeautifyJobsResponseBodyJobListJobBeautifyConfig,
      state: 'string',
      userData: 'string',
      code: 'string',
      message: 'string',
      pipelineId: 'string',
      input: SubmitBeautifyJobsResponseBodyJobListJobInput,
      MNSMessageResult: SubmitBeautifyJobsResponseBodyJobListJobMNSMessageResult,
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitBeautifyJobsResponseBodyJobList extends $tea.Model {
  job?: SubmitBeautifyJobsResponseBodyJobListJob[];
  static names(): { [key: string]: string } {
    return {
      job: 'Job',
    };
  }

  static types(): { [key: string]: any } {
    return {
      job: { 'type': 'array', 'itemType': SubmitBeautifyJobsResponseBodyJobListJob },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitComplexJobResponseBodyComplexJobTranscodeOutputVideoBitrateBnd extends $tea.Model {
  max?: string;
  min?: string;
  static names(): { [key: string]: string } {
    return {
      max: 'Max',
      min: 'Min',
    };
  }

  static types(): { [key: string]: any } {
    return {
      max: 'string',
      min: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitComplexJobResponseBodyComplexJobTranscodeOutputVideo extends $tea.Model {
  bufsize?: string;
  degrain?: string;
  bitrateBnd?: SubmitComplexJobResponseBodyComplexJobTranscodeOutputVideoBitrateBnd;
  pixFmt?: string;
  pad?: string;
  codec?: string;
  height?: string;
  qscale?: string;
  crop?: string;
  bitrate?: string;
  maxrate?: string;
  maxFps?: string;
  profile?: string;
  crf?: string;
  gop?: string;
  width?: string;
  fps?: string;
  preset?: string;
  scanMode?: string;
  static names(): { [key: string]: string } {
    return {
      bufsize: 'Bufsize',
      degrain: 'Degrain',
      bitrateBnd: 'BitrateBnd',
      pixFmt: 'PixFmt',
      pad: 'Pad',
      codec: 'Codec',
      height: 'Height',
      qscale: 'Qscale',
      crop: 'Crop',
      bitrate: 'Bitrate',
      maxrate: 'Maxrate',
      maxFps: 'MaxFps',
      profile: 'Profile',
      crf: 'Crf',
      gop: 'Gop',
      width: 'Width',
      fps: 'Fps',
      preset: 'Preset',
      scanMode: 'ScanMode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bufsize: 'string',
      degrain: 'string',
      bitrateBnd: SubmitComplexJobResponseBodyComplexJobTranscodeOutputVideoBitrateBnd,
      pixFmt: 'string',
      pad: 'string',
      codec: 'string',
      height: 'string',
      qscale: 'string',
      crop: 'string',
      bitrate: 'string',
      maxrate: 'string',
      maxFps: 'string',
      profile: 'string',
      crf: 'string',
      gop: 'string',
      width: 'string',
      fps: 'string',
      preset: 'string',
      scanMode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitComplexJobResponseBodyComplexJobTranscodeOutputTransConfig extends $tea.Model {
  isCheckAudioBitrate?: string;
  isCheckReso?: string;
  transMode?: string;
  isCheckVideoBitrateFail?: string;
  adjDarMethod?: string;
  duration?: string;
  isCheckVideoBitrate?: string;
  isCheckResoFail?: string;
  isCheckAudioBitrateFail?: string;
  static names(): { [key: string]: string } {
    return {
      isCheckAudioBitrate: 'IsCheckAudioBitrate',
      isCheckReso: 'IsCheckReso',
      transMode: 'TransMode',
      isCheckVideoBitrateFail: 'IsCheckVideoBitrateFail',
      adjDarMethod: 'AdjDarMethod',
      duration: 'Duration',
      isCheckVideoBitrate: 'IsCheckVideoBitrate',
      isCheckResoFail: 'IsCheckResoFail',
      isCheckAudioBitrateFail: 'IsCheckAudioBitrateFail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isCheckAudioBitrate: 'string',
      isCheckReso: 'string',
      transMode: 'string',
      isCheckVideoBitrateFail: 'string',
      adjDarMethod: 'string',
      duration: 'string',
      isCheckVideoBitrate: 'string',
      isCheckResoFail: 'string',
      isCheckAudioBitrateFail: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitComplexJobResponseBodyComplexJobTranscodeOutputEncryption extends $tea.Model {
  type?: string;
  key?: string;
  keyType?: string;
  id?: string;
  keyUri?: string;
  skipCnt?: string;
  static names(): { [key: string]: string } {
    return {
      type: 'Type',
      key: 'Key',
      keyType: 'KeyType',
      id: 'Id',
      keyUri: 'KeyUri',
      skipCnt: 'SkipCnt',
    };
  }

  static types(): { [key: string]: any } {
    return {
      type: 'string',
      key: 'string',
      keyType: 'string',
      id: 'string',
      keyUri: 'string',
      skipCnt: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitComplexJobResponseBodyComplexJobTranscodeOutputWaterMarkListWaterMarkInputFile extends $tea.Model {
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitComplexJobResponseBodyComplexJobTranscodeOutputWaterMarkListWaterMark extends $tea.Model {
  type?: string;
  referPos?: string;
  dx?: string;
  width?: string;
  height?: string;
  inputFile?: SubmitComplexJobResponseBodyComplexJobTranscodeOutputWaterMarkListWaterMarkInputFile;
  waterMarkTemplateId?: string;
  dy?: string;
  static names(): { [key: string]: string } {
    return {
      type: 'Type',
      referPos: 'ReferPos',
      dx: 'Dx',
      width: 'Width',
      height: 'Height',
      inputFile: 'InputFile',
      waterMarkTemplateId: 'WaterMarkTemplateId',
      dy: 'Dy',
    };
  }

  static types(): { [key: string]: any } {
    return {
      type: 'string',
      referPos: 'string',
      dx: 'string',
      width: 'string',
      height: 'string',
      inputFile: SubmitComplexJobResponseBodyComplexJobTranscodeOutputWaterMarkListWaterMarkInputFile,
      waterMarkTemplateId: 'string',
      dy: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitComplexJobResponseBodyComplexJobTranscodeOutputWaterMarkList extends $tea.Model {
  waterMark?: SubmitComplexJobResponseBodyComplexJobTranscodeOutputWaterMarkListWaterMark[];
  static names(): { [key: string]: string } {
    return {
      waterMark: 'WaterMark',
    };
  }

  static types(): { [key: string]: any } {
    return {
      waterMark: { 'type': 'array', 'itemType': SubmitComplexJobResponseBodyComplexJobTranscodeOutputWaterMarkListWaterMark },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitComplexJobResponseBodyComplexJobTranscodeOutputM3U8NonStandardSupportTS extends $tea.Model {
  sizeSupport?: boolean;
  md5Support?: boolean;
  static names(): { [key: string]: string } {
    return {
      sizeSupport: 'SizeSupport',
      md5Support: 'Md5Support',
    };
  }

  static types(): { [key: string]: any } {
    return {
      sizeSupport: 'boolean',
      md5Support: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitComplexJobResponseBodyComplexJobTranscodeOutputM3U8NonStandardSupport extends $tea.Model {
  TS?: SubmitComplexJobResponseBodyComplexJobTranscodeOutputM3U8NonStandardSupportTS;
  static names(): { [key: string]: string } {
    return {
      TS: 'TS',
    };
  }

  static types(): { [key: string]: any } {
    return {
      TS: SubmitComplexJobResponseBodyComplexJobTranscodeOutputM3U8NonStandardSupportTS,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitComplexJobResponseBodyComplexJobTranscodeOutputAudioVolume extends $tea.Model {
  method?: string;
  level?: string;
  static names(): { [key: string]: string } {
    return {
      method: 'Method',
      level: 'Level',
    };
  }

  static types(): { [key: string]: any } {
    return {
      method: 'string',
      level: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitComplexJobResponseBodyComplexJobTranscodeOutputAudio extends $tea.Model {
  profile?: string;
  codec?: string;
  samplerate?: string;
  qscale?: string;
  channels?: string;
  volume?: SubmitComplexJobResponseBodyComplexJobTranscodeOutputAudioVolume;
  bitrate?: string;
  static names(): { [key: string]: string } {
    return {
      profile: 'Profile',
      codec: 'Codec',
      samplerate: 'Samplerate',
      qscale: 'Qscale',
      channels: 'Channels',
      volume: 'Volume',
      bitrate: 'Bitrate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      profile: 'string',
      codec: 'string',
      samplerate: 'string',
      qscale: 'string',
      channels: 'string',
      volume: SubmitComplexJobResponseBodyComplexJobTranscodeOutputAudioVolume,
      bitrate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitComplexJobResponseBodyComplexJobTranscodeOutputMergeListMerge extends $tea.Model {
  start?: string;
  roleArn?: string;
  mergeURL?: string;
  duration?: string;
  static names(): { [key: string]: string } {
    return {
      start: 'Start',
      roleArn: 'RoleArn',
      mergeURL: 'MergeURL',
      duration: 'Duration',
    };
  }

  static types(): { [key: string]: any } {
    return {
      start: 'string',
      roleArn: 'string',
      mergeURL: 'string',
      duration: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitComplexJobResponseBodyComplexJobTranscodeOutputMergeList extends $tea.Model {
  merge?: SubmitComplexJobResponseBodyComplexJobTranscodeOutputMergeListMerge[];
  static names(): { [key: string]: string } {
    return {
      merge: 'Merge',
    };
  }

  static types(): { [key: string]: any } {
    return {
      merge: { 'type': 'array', 'itemType': SubmitComplexJobResponseBodyComplexJobTranscodeOutputMergeListMerge },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitComplexJobResponseBodyComplexJobTranscodeOutputSuperReso extends $tea.Model {
  isHalfSample?: string;
  static names(): { [key: string]: string } {
    return {
      isHalfSample: 'IsHalfSample',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isHalfSample: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitComplexJobResponseBodyComplexJobTranscodeOutputDigiWaterMarkInputFile extends $tea.Model {
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitComplexJobResponseBodyComplexJobTranscodeOutputDigiWaterMark extends $tea.Model {
  type?: string;
  alpha?: string;
  inputFile?: SubmitComplexJobResponseBodyComplexJobTranscodeOutputDigiWaterMarkInputFile;
  static names(): { [key: string]: string } {
    return {
      type: 'Type',
      alpha: 'Alpha',
      inputFile: 'InputFile',
    };
  }

  static types(): { [key: string]: any } {
    return {
      type: 'string',
      alpha: 'string',
      inputFile: SubmitComplexJobResponseBodyComplexJobTranscodeOutputDigiWaterMarkInputFile,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitComplexJobResponseBodyComplexJobTranscodeOutputOutputFile extends $tea.Model {
  roleArn?: string;
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      roleArn: 'RoleArn',
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      roleArn: 'string',
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitComplexJobResponseBodyComplexJobTranscodeOutputContainer extends $tea.Model {
  format?: string;
  static names(): { [key: string]: string } {
    return {
      format: 'Format',
    };
  }

  static types(): { [key: string]: any } {
    return {
      format: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitComplexJobResponseBodyComplexJobTranscodeOutputClipTimeSpan extends $tea.Model {
  seek?: string;
  duration?: string;
  static names(): { [key: string]: string } {
    return {
      seek: 'Seek',
      duration: 'Duration',
    };
  }

  static types(): { [key: string]: any } {
    return {
      seek: 'string',
      duration: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitComplexJobResponseBodyComplexJobTranscodeOutputClip extends $tea.Model {
  timeSpan?: SubmitComplexJobResponseBodyComplexJobTranscodeOutputClipTimeSpan;
  static names(): { [key: string]: string } {
    return {
      timeSpan: 'TimeSpan',
    };
  }

  static types(): { [key: string]: any } {
    return {
      timeSpan: SubmitComplexJobResponseBodyComplexJobTranscodeOutputClipTimeSpan,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitComplexJobResponseBodyComplexJobTranscodeOutputMuxConfigGif extends $tea.Model {
  finalDelay?: string;
  ditherMode?: string;
  loop?: string;
  isCustomPalette?: string;
  static names(): { [key: string]: string } {
    return {
      finalDelay: 'FinalDelay',
      ditherMode: 'DitherMode',
      loop: 'Loop',
      isCustomPalette: 'IsCustomPalette',
    };
  }

  static types(): { [key: string]: any } {
    return {
      finalDelay: 'string',
      ditherMode: 'string',
      loop: 'string',
      isCustomPalette: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitComplexJobResponseBodyComplexJobTranscodeOutputMuxConfigSegment extends $tea.Model {
  duration?: string;
  static names(): { [key: string]: string } {
    return {
      duration: 'Duration',
    };
  }

  static types(): { [key: string]: any } {
    return {
      duration: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitComplexJobResponseBodyComplexJobTranscodeOutputMuxConfig extends $tea.Model {
  gif?: SubmitComplexJobResponseBodyComplexJobTranscodeOutputMuxConfigGif;
  segment?: SubmitComplexJobResponseBodyComplexJobTranscodeOutputMuxConfigSegment;
  static names(): { [key: string]: string } {
    return {
      gif: 'Gif',
      segment: 'Segment',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gif: SubmitComplexJobResponseBodyComplexJobTranscodeOutputMuxConfigGif,
      segment: SubmitComplexJobResponseBodyComplexJobTranscodeOutputMuxConfigSegment,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitComplexJobResponseBodyComplexJobTranscodeOutputSubtitleConfigExtSubtitleListExtSubtitleInput extends $tea.Model {
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitComplexJobResponseBodyComplexJobTranscodeOutputSubtitleConfigExtSubtitleListExtSubtitle extends $tea.Model {
  charEnc?: string;
  fontName?: string;
  input?: SubmitComplexJobResponseBodyComplexJobTranscodeOutputSubtitleConfigExtSubtitleListExtSubtitleInput;
  static names(): { [key: string]: string } {
    return {
      charEnc: 'CharEnc',
      fontName: 'FontName',
      input: 'Input',
    };
  }

  static types(): { [key: string]: any } {
    return {
      charEnc: 'string',
      fontName: 'string',
      input: SubmitComplexJobResponseBodyComplexJobTranscodeOutputSubtitleConfigExtSubtitleListExtSubtitleInput,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitComplexJobResponseBodyComplexJobTranscodeOutputSubtitleConfigExtSubtitleList extends $tea.Model {
  extSubtitle?: SubmitComplexJobResponseBodyComplexJobTranscodeOutputSubtitleConfigExtSubtitleListExtSubtitle[];
  static names(): { [key: string]: string } {
    return {
      extSubtitle: 'ExtSubtitle',
    };
  }

  static types(): { [key: string]: any } {
    return {
      extSubtitle: { 'type': 'array', 'itemType': SubmitComplexJobResponseBodyComplexJobTranscodeOutputSubtitleConfigExtSubtitleListExtSubtitle },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitComplexJobResponseBodyComplexJobTranscodeOutputSubtitleConfigSubtitleListSubtitle extends $tea.Model {
  map?: string;
  static names(): { [key: string]: string } {
    return {
      map: 'Map',
    };
  }

  static types(): { [key: string]: any } {
    return {
      map: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitComplexJobResponseBodyComplexJobTranscodeOutputSubtitleConfigSubtitleList extends $tea.Model {
  subtitle?: SubmitComplexJobResponseBodyComplexJobTranscodeOutputSubtitleConfigSubtitleListSubtitle[];
  static names(): { [key: string]: string } {
    return {
      subtitle: 'Subtitle',
    };
  }

  static types(): { [key: string]: any } {
    return {
      subtitle: { 'type': 'array', 'itemType': SubmitComplexJobResponseBodyComplexJobTranscodeOutputSubtitleConfigSubtitleListSubtitle },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitComplexJobResponseBodyComplexJobTranscodeOutputSubtitleConfig extends $tea.Model {
  extSubtitleList?: SubmitComplexJobResponseBodyComplexJobTranscodeOutputSubtitleConfigExtSubtitleList;
  subtitleList?: SubmitComplexJobResponseBodyComplexJobTranscodeOutputSubtitleConfigSubtitleList;
  static names(): { [key: string]: string } {
    return {
      extSubtitleList: 'ExtSubtitleList',
      subtitleList: 'SubtitleList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      extSubtitleList: SubmitComplexJobResponseBodyComplexJobTranscodeOutputSubtitleConfigExtSubtitleList,
      subtitleList: SubmitComplexJobResponseBodyComplexJobTranscodeOutputSubtitleConfigSubtitleList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost extends $tea.Model {
  preloadTime?: string;
  avgBitrate?: string;
  costBandwidth?: string;
  static names(): { [key: string]: string } {
    return {
      preloadTime: 'PreloadTime',
      avgBitrate: 'AvgBitrate',
      costBandwidth: 'CostBandwidth',
    };
  }

  static types(): { [key: string]: any } {
    return {
      preloadTime: 'string',
      avgBitrate: 'string',
      costBandwidth: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreamsVideoStreamListVideoStream extends $tea.Model {
  index?: string;
  timebase?: string;
  avgFPS?: string;
  pixFmt?: string;
  sar?: string;
  lang?: string;
  codecLongName?: string;
  height?: string;
  numFrames?: string;
  bitrate?: string;
  codecTagString?: string;
  hasBFrames?: string;
  profile?: string;
  startTime?: string;
  networkCost?: SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost;
  dar?: string;
  codecName?: string;
  width?: string;
  duration?: string;
  fps?: string;
  codecTag?: string;
  codecTimeBase?: string;
  level?: string;
  static names(): { [key: string]: string } {
    return {
      index: 'Index',
      timebase: 'Timebase',
      avgFPS: 'AvgFPS',
      pixFmt: 'PixFmt',
      sar: 'Sar',
      lang: 'Lang',
      codecLongName: 'CodecLongName',
      height: 'Height',
      numFrames: 'NumFrames',
      bitrate: 'Bitrate',
      codecTagString: 'CodecTagString',
      hasBFrames: 'HasBFrames',
      profile: 'Profile',
      startTime: 'StartTime',
      networkCost: 'NetworkCost',
      dar: 'Dar',
      codecName: 'CodecName',
      width: 'Width',
      duration: 'Duration',
      fps: 'Fps',
      codecTag: 'CodecTag',
      codecTimeBase: 'CodecTimeBase',
      level: 'Level',
    };
  }

  static types(): { [key: string]: any } {
    return {
      index: 'string',
      timebase: 'string',
      avgFPS: 'string',
      pixFmt: 'string',
      sar: 'string',
      lang: 'string',
      codecLongName: 'string',
      height: 'string',
      numFrames: 'string',
      bitrate: 'string',
      codecTagString: 'string',
      hasBFrames: 'string',
      profile: 'string',
      startTime: 'string',
      networkCost: SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost,
      dar: 'string',
      codecName: 'string',
      width: 'string',
      duration: 'string',
      fps: 'string',
      codecTag: 'string',
      codecTimeBase: 'string',
      level: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreamsVideoStreamList extends $tea.Model {
  videoStream?: SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreamsVideoStreamListVideoStream[];
  static names(): { [key: string]: string } {
    return {
      videoStream: 'VideoStream',
    };
  }

  static types(): { [key: string]: any } {
    return {
      videoStream: { 'type': 'array', 'itemType': SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreamsVideoStreamListVideoStream },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreamsAudioStreamListAudioStream extends $tea.Model {
  timebase?: string;
  index?: string;
  sampleFmt?: string;
  channelLayout?: string;
  lang?: string;
  samplerate?: string;
  codecLongName?: string;
  channels?: string;
  numFrames?: string;
  bitrate?: string;
  codecTagString?: string;
  startTime?: string;
  codecName?: string;
  duration?: string;
  codecTag?: string;
  codecTimeBase?: string;
  static names(): { [key: string]: string } {
    return {
      timebase: 'Timebase',
      index: 'Index',
      sampleFmt: 'SampleFmt',
      channelLayout: 'ChannelLayout',
      lang: 'Lang',
      samplerate: 'Samplerate',
      codecLongName: 'CodecLongName',
      channels: 'Channels',
      numFrames: 'NumFrames',
      bitrate: 'Bitrate',
      codecTagString: 'CodecTagString',
      startTime: 'StartTime',
      codecName: 'CodecName',
      duration: 'Duration',
      codecTag: 'CodecTag',
      codecTimeBase: 'CodecTimeBase',
    };
  }

  static types(): { [key: string]: any } {
    return {
      timebase: 'string',
      index: 'string',
      sampleFmt: 'string',
      channelLayout: 'string',
      lang: 'string',
      samplerate: 'string',
      codecLongName: 'string',
      channels: 'string',
      numFrames: 'string',
      bitrate: 'string',
      codecTagString: 'string',
      startTime: 'string',
      codecName: 'string',
      duration: 'string',
      codecTag: 'string',
      codecTimeBase: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreamsAudioStreamList extends $tea.Model {
  audioStream?: SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreamsAudioStreamListAudioStream[];
  static names(): { [key: string]: string } {
    return {
      audioStream: 'AudioStream',
    };
  }

  static types(): { [key: string]: any } {
    return {
      audioStream: { 'type': 'array', 'itemType': SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreamsAudioStreamListAudioStream },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreamsSubtitleStreamListSubtitleStream extends $tea.Model {
  index?: string;
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      index: 'Index',
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      index: 'string',
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreamsSubtitleStreamList extends $tea.Model {
  subtitleStream?: SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreamsSubtitleStreamListSubtitleStream[];
  static names(): { [key: string]: string } {
    return {
      subtitleStream: 'SubtitleStream',
    };
  }

  static types(): { [key: string]: any } {
    return {
      subtitleStream: { 'type': 'array', 'itemType': SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreamsSubtitleStreamListSubtitleStream },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreams extends $tea.Model {
  videoStreamList?: SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreamsVideoStreamList;
  audioStreamList?: SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreamsAudioStreamList;
  subtitleStreamList?: SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreamsSubtitleStreamList;
  static names(): { [key: string]: string } {
    return {
      videoStreamList: 'VideoStreamList',
      audioStreamList: 'AudioStreamList',
      subtitleStreamList: 'SubtitleStreamList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      videoStreamList: SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreamsVideoStreamList,
      audioStreamList: SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreamsAudioStreamList,
      subtitleStreamList: SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreamsSubtitleStreamList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesFormat extends $tea.Model {
  startTime?: string;
  numPrograms?: string;
  size?: string;
  numStreams?: string;
  formatLongName?: string;
  duration?: string;
  bitrate?: string;
  formatName?: string;
  static names(): { [key: string]: string } {
    return {
      startTime: 'StartTime',
      numPrograms: 'NumPrograms',
      size: 'Size',
      numStreams: 'NumStreams',
      formatLongName: 'FormatLongName',
      duration: 'Duration',
      bitrate: 'Bitrate',
      formatName: 'FormatName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      startTime: 'string',
      numPrograms: 'string',
      size: 'string',
      numStreams: 'string',
      formatLongName: 'string',
      duration: 'string',
      bitrate: 'string',
      formatName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitComplexJobResponseBodyComplexJobTranscodeOutputProperties extends $tea.Model {
  width?: string;
  height?: string;
  duration?: string;
  fps?: string;
  bitrate?: string;
  fileFormat?: string;
  streams?: SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreams;
  format?: SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesFormat;
  fileSize?: string;
  static names(): { [key: string]: string } {
    return {
      width: 'Width',
      height: 'Height',
      duration: 'Duration',
      fps: 'Fps',
      bitrate: 'Bitrate',
      fileFormat: 'FileFormat',
      streams: 'Streams',
      format: 'Format',
      fileSize: 'FileSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      width: 'string',
      height: 'string',
      duration: 'string',
      fps: 'string',
      bitrate: 'string',
      fileFormat: 'string',
      streams: SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesStreams,
      format: SubmitComplexJobResponseBodyComplexJobTranscodeOutputPropertiesFormat,
      fileSize: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitComplexJobResponseBodyComplexJobTranscodeOutput extends $tea.Model {
  video?: SubmitComplexJobResponseBodyComplexJobTranscodeOutputVideo;
  transConfig?: SubmitComplexJobResponseBodyComplexJobTranscodeOutputTransConfig;
  encryption?: SubmitComplexJobResponseBodyComplexJobTranscodeOutputEncryption;
  waterMarkList?: SubmitComplexJobResponseBodyComplexJobTranscodeOutputWaterMarkList;
  deWatermark?: string;
  waterMarkConfigUrl?: string;
  m3U8NonStandardSupport?: SubmitComplexJobResponseBodyComplexJobTranscodeOutputM3U8NonStandardSupport;
  priority?: string;
  audio?: SubmitComplexJobResponseBodyComplexJobTranscodeOutputAudio;
  audioStreamMap?: string;
  mergeList?: SubmitComplexJobResponseBodyComplexJobTranscodeOutputMergeList;
  superReso?: SubmitComplexJobResponseBodyComplexJobTranscodeOutputSuperReso;
  userData?: string;
  digiWaterMark?: SubmitComplexJobResponseBodyComplexJobTranscodeOutputDigiWaterMark;
  videoStreamMap?: string;
  outputFile?: SubmitComplexJobResponseBodyComplexJobTranscodeOutputOutputFile;
  rotate?: string;
  container?: SubmitComplexJobResponseBodyComplexJobTranscodeOutputContainer;
  clip?: SubmitComplexJobResponseBodyComplexJobTranscodeOutputClip;
  mergeConfigUrl?: string;
  muxConfig?: SubmitComplexJobResponseBodyComplexJobTranscodeOutputMuxConfig;
  templateId?: string;
  subtitleConfig?: SubmitComplexJobResponseBodyComplexJobTranscodeOutputSubtitleConfig;
  properties?: SubmitComplexJobResponseBodyComplexJobTranscodeOutputProperties;
  static names(): { [key: string]: string } {
    return {
      video: 'Video',
      transConfig: 'TransConfig',
      encryption: 'Encryption',
      waterMarkList: 'WaterMarkList',
      deWatermark: 'DeWatermark',
      waterMarkConfigUrl: 'WaterMarkConfigUrl',
      m3U8NonStandardSupport: 'M3U8NonStandardSupport',
      priority: 'Priority',
      audio: 'Audio',
      audioStreamMap: 'AudioStreamMap',
      mergeList: 'MergeList',
      superReso: 'SuperReso',
      userData: 'UserData',
      digiWaterMark: 'DigiWaterMark',
      videoStreamMap: 'VideoStreamMap',
      outputFile: 'OutputFile',
      rotate: 'Rotate',
      container: 'Container',
      clip: 'Clip',
      mergeConfigUrl: 'MergeConfigUrl',
      muxConfig: 'MuxConfig',
      templateId: 'TemplateId',
      subtitleConfig: 'SubtitleConfig',
      properties: 'Properties',
    };
  }

  static types(): { [key: string]: any } {
    return {
      video: SubmitComplexJobResponseBodyComplexJobTranscodeOutputVideo,
      transConfig: SubmitComplexJobResponseBodyComplexJobTranscodeOutputTransConfig,
      encryption: SubmitComplexJobResponseBodyComplexJobTranscodeOutputEncryption,
      waterMarkList: SubmitComplexJobResponseBodyComplexJobTranscodeOutputWaterMarkList,
      deWatermark: 'string',
      waterMarkConfigUrl: 'string',
      m3U8NonStandardSupport: SubmitComplexJobResponseBodyComplexJobTranscodeOutputM3U8NonStandardSupport,
      priority: 'string',
      audio: SubmitComplexJobResponseBodyComplexJobTranscodeOutputAudio,
      audioStreamMap: 'string',
      mergeList: SubmitComplexJobResponseBodyComplexJobTranscodeOutputMergeList,
      superReso: SubmitComplexJobResponseBodyComplexJobTranscodeOutputSuperReso,
      userData: 'string',
      digiWaterMark: SubmitComplexJobResponseBodyComplexJobTranscodeOutputDigiWaterMark,
      videoStreamMap: 'string',
      outputFile: SubmitComplexJobResponseBodyComplexJobTranscodeOutputOutputFile,
      rotate: 'string',
      container: SubmitComplexJobResponseBodyComplexJobTranscodeOutputContainer,
      clip: SubmitComplexJobResponseBodyComplexJobTranscodeOutputClip,
      mergeConfigUrl: 'string',
      muxConfig: SubmitComplexJobResponseBodyComplexJobTranscodeOutputMuxConfig,
      templateId: 'string',
      subtitleConfig: SubmitComplexJobResponseBodyComplexJobTranscodeOutputSubtitleConfig,
      properties: SubmitComplexJobResponseBodyComplexJobTranscodeOutputProperties,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitComplexJobResponseBodyComplexJobMNSMessageResult extends $tea.Model {
  messageId?: string;
  errorMessage?: string;
  errorCode?: string;
  static names(): { [key: string]: string } {
    return {
      messageId: 'MessageId',
      errorMessage: 'ErrorMessage',
      errorCode: 'ErrorCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      messageId: 'string',
      errorMessage: 'string',
      errorCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClipsClipClipsConfigClipsConfigVideo extends $tea.Model {
  t?: string;
  l?: string;
  static names(): { [key: string]: string } {
    return {
      t: 'T',
      l: 'L',
    };
  }

  static types(): { [key: string]: any } {
    return {
      t: 'string',
      l: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClipsClipClipsConfig extends $tea.Model {
  clipsConfigVideo?: SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClipsClipClipsConfigClipsConfigVideo;
  static names(): { [key: string]: string } {
    return {
      clipsConfigVideo: 'ClipsConfigVideo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clipsConfigVideo: SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClipsClipClipsConfigClipsConfigVideo,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClipsClip extends $tea.Model {
  clipsConfig?: SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClipsClipClipsConfig;
  out?: string;
  in?: string;
  clipID?: string;
  static names(): { [key: string]: string } {
    return {
      clipsConfig: 'ClipsConfig',
      out: 'Out',
      in: 'In',
      clipID: 'clipID',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clipsConfig: SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClipsClipClipsConfig,
      out: 'string',
      in: 'string',
      clipID: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClips extends $tea.Model {
  clip?: SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClipsClip[];
  static names(): { [key: string]: string } {
    return {
      clip: 'Clip',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clip: { 'type': 'array', 'itemType': SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClipsClip },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrack extends $tea.Model {
  type?: string;
  order?: string;
  id?: string;
  clips?: SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClips;
  static names(): { [key: string]: string } {
    return {
      type: 'Type',
      order: 'Order',
      id: 'Id',
      clips: 'Clips',
    };
  }

  static types(): { [key: string]: any } {
    return {
      type: 'string',
      order: 'string',
      id: 'string',
      clips: SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrackClips,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackList extends $tea.Model {
  track?: SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrack[];
  static names(): { [key: string]: string } {
    return {
      track: 'Track',
    };
  }

  static types(): { [key: string]: any } {
    return {
      track: { 'type': 'array', 'itemType': SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackListTrack },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTimelineConfigTimelineConfigAudio extends $tea.Model {
  channelLayout?: string;
  samplerate?: string;
  channels?: string;
  static names(): { [key: string]: string } {
    return {
      channelLayout: 'ChannelLayout',
      samplerate: 'Samplerate',
      channels: 'Channels',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelLayout: 'string',
      samplerate: 'string',
      channels: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTimelineConfigTimelineConfigVideo extends $tea.Model {
  bgColor?: string;
  width?: string;
  renderRatio?: string;
  isGpuData?: string;
  height?: string;
  isOneTrackData?: string;
  fps?: string;
  reclosePrec?: string;
  static names(): { [key: string]: string } {
    return {
      bgColor: 'BgColor',
      width: 'Width',
      renderRatio: 'RenderRatio',
      isGpuData: 'IsGpuData',
      height: 'Height',
      isOneTrackData: 'IsOneTrackData',
      fps: 'Fps',
      reclosePrec: 'ReclosePrec',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bgColor: 'string',
      width: 'string',
      renderRatio: 'string',
      isGpuData: 'string',
      height: 'string',
      isOneTrackData: 'string',
      fps: 'string',
      reclosePrec: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTimelineConfig extends $tea.Model {
  timelineConfigAudio?: SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTimelineConfigTimelineConfigAudio;
  timelineConfigVideo?: SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTimelineConfigTimelineConfigVideo;
  static names(): { [key: string]: string } {
    return {
      timelineConfigAudio: 'TimelineConfigAudio',
      timelineConfigVideo: 'TimelineConfigVideo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      timelineConfigAudio: SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTimelineConfigTimelineConfigAudio,
      timelineConfigVideo: SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTimelineConfigTimelineConfigVideo,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimeline extends $tea.Model {
  trackList?: SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackList;
  timelineConfig?: SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTimelineConfig;
  static names(): { [key: string]: string } {
    return {
      trackList: 'TrackList',
      timelineConfig: 'TimelineConfig',
    };
  }

  static types(): { [key: string]: any } {
    return {
      trackList: SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTrackList,
      timelineConfig: SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimelineTimelineConfig,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingClipListClipEffectsEffect extends $tea.Model {
  effect?: string;
  effectConfig?: string;
  static names(): { [key: string]: string } {
    return {
      effect: 'Effect',
      effectConfig: 'EffectConfig',
    };
  }

  static types(): { [key: string]: any } {
    return {
      effect: 'string',
      effectConfig: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingClipListClipEffects extends $tea.Model {
  effect?: SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingClipListClipEffectsEffect[];
  static names(): { [key: string]: string } {
    return {
      effect: 'Effect',
    };
  }

  static types(): { [key: string]: any } {
    return {
      effect: { 'type': 'array', 'itemType': SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingClipListClipEffectsEffect },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingClipListClip extends $tea.Model {
  type?: string;
  sourceID?: string;
  effects?: SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingClipListClipEffects;
  sourceType?: string;
  sourceStrmMap?: string;
  out?: string;
  in?: string;
  id?: string;
  static names(): { [key: string]: string } {
    return {
      type: 'Type',
      sourceID: 'SourceID',
      effects: 'Effects',
      sourceType: 'SourceType',
      sourceStrmMap: 'SourceStrmMap',
      out: 'Out',
      in: 'In',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      type: 'string',
      sourceID: 'string',
      effects: SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingClipListClipEffects,
      sourceType: 'string',
      sourceStrmMap: 'string',
      out: 'string',
      in: 'string',
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingClipList extends $tea.Model {
  clip?: SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingClipListClip[];
  static names(): { [key: string]: string } {
    return {
      clip: 'Clip',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clip: { 'type': 'array', 'itemType': SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingClipListClip },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditing extends $tea.Model {
  timeline?: SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimeline;
  clipList?: SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingClipList;
  static names(): { [key: string]: string } {
    return {
      timeline: 'Timeline',
      clipList: 'ClipList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      timeline: SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingTimeline,
      clipList: SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditingClipList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigs extends $tea.Model {
  editing?: SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditing;
  static names(): { [key: string]: string } {
    return {
      editing: 'Editing',
    };
  }

  static types(): { [key: string]: any } {
    return {
      editing: SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigsEditing,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitComplexJobResponseBodyComplexJobComplexEditingConfigs extends $tea.Model {
  complexEditingConfigs?: SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigs[];
  static names(): { [key: string]: string } {
    return {
      complexEditingConfigs: 'ComplexEditingConfigs',
    };
  }

  static types(): { [key: string]: any } {
    return {
      complexEditingConfigs: { 'type': 'array', 'itemType': SubmitComplexJobResponseBodyComplexJobComplexEditingConfigsComplexEditingConfigs },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitComplexJobResponseBodyComplexJobInputsInputsEditingInputsEditingInputInputFile extends $tea.Model {
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitComplexJobResponseBodyComplexJobInputsInputsEditingInputsEditingInputInputConfig extends $tea.Model {
  isNormalSar?: string;
  deinterlaceMethod?: string;
  static names(): { [key: string]: string } {
    return {
      isNormalSar: 'IsNormalSar',
      deinterlaceMethod: 'DeinterlaceMethod',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isNormalSar: 'string',
      deinterlaceMethod: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitComplexJobResponseBodyComplexJobInputsInputsEditingInputsEditingInput extends $tea.Model {
  inputFile?: SubmitComplexJobResponseBodyComplexJobInputsInputsEditingInputsEditingInputInputFile;
  inputConfig?: SubmitComplexJobResponseBodyComplexJobInputsInputsEditingInputsEditingInputInputConfig;
  id?: string;
  static names(): { [key: string]: string } {
    return {
      inputFile: 'InputFile',
      inputConfig: 'InputConfig',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      inputFile: SubmitComplexJobResponseBodyComplexJobInputsInputsEditingInputsEditingInputInputFile,
      inputConfig: SubmitComplexJobResponseBodyComplexJobInputsInputsEditingInputsEditingInputInputConfig,
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitComplexJobResponseBodyComplexJobInputsInputsEditingInputs extends $tea.Model {
  editingInput?: SubmitComplexJobResponseBodyComplexJobInputsInputsEditingInputsEditingInput[];
  static names(): { [key: string]: string } {
    return {
      editingInput: 'EditingInput',
    };
  }

  static types(): { [key: string]: any } {
    return {
      editingInput: { 'type': 'array', 'itemType': SubmitComplexJobResponseBodyComplexJobInputsInputsEditingInputsEditingInput },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitComplexJobResponseBodyComplexJobInputsInputs extends $tea.Model {
  editingInputs?: SubmitComplexJobResponseBodyComplexJobInputsInputsEditingInputs;
  static names(): { [key: string]: string } {
    return {
      editingInputs: 'EditingInputs',
    };
  }

  static types(): { [key: string]: any } {
    return {
      editingInputs: SubmitComplexJobResponseBodyComplexJobInputsInputsEditingInputs,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitComplexJobResponseBodyComplexJobInputs extends $tea.Model {
  inputs?: SubmitComplexJobResponseBodyComplexJobInputsInputs[];
  static names(): { [key: string]: string } {
    return {
      inputs: 'Inputs',
    };
  }

  static types(): { [key: string]: any } {
    return {
      inputs: { 'type': 'array', 'itemType': SubmitComplexJobResponseBodyComplexJobInputsInputs },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitComplexJobResponseBodyComplexJob extends $tea.Model {
  creationTime?: string;
  percent?: number;
  finishTime?: string;
  state?: string;
  transcodeOutput?: SubmitComplexJobResponseBodyComplexJobTranscodeOutput;
  message?: string;
  MNSMessageResult?: SubmitComplexJobResponseBodyComplexJobMNSMessageResult;
  complexEditingConfigs?: SubmitComplexJobResponseBodyComplexJobComplexEditingConfigs;
  inputs?: SubmitComplexJobResponseBodyComplexJobInputs;
  jobId?: string;
  code?: string;
  pipelineId?: string;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      percent: 'Percent',
      finishTime: 'FinishTime',
      state: 'State',
      transcodeOutput: 'transcodeOutput',
      message: 'Message',
      MNSMessageResult: 'MNSMessageResult',
      complexEditingConfigs: 'ComplexEditingConfigs',
      inputs: 'Inputs',
      jobId: 'JobId',
      code: 'Code',
      pipelineId: 'PipelineId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      percent: 'number',
      finishTime: 'string',
      state: 'string',
      transcodeOutput: SubmitComplexJobResponseBodyComplexJobTranscodeOutput,
      message: 'string',
      MNSMessageResult: SubmitComplexJobResponseBodyComplexJobMNSMessageResult,
      complexEditingConfigs: SubmitComplexJobResponseBodyComplexJobComplexEditingConfigs,
      inputs: SubmitComplexJobResponseBodyComplexJobInputs,
      jobId: 'string',
      code: 'string',
      pipelineId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputsEditingInputInputFile extends $tea.Model {
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputsEditingInputInputConfig extends $tea.Model {
  isNormalSar?: string;
  deinterlaceMethod?: string;
  static names(): { [key: string]: string } {
    return {
      isNormalSar: 'IsNormalSar',
      deinterlaceMethod: 'DeinterlaceMethod',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isNormalSar: 'string',
      deinterlaceMethod: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputsEditingInput extends $tea.Model {
  inputFile?: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputsEditingInputInputFile;
  inputConfig?: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputsEditingInputInputConfig;
  id?: string;
  static names(): { [key: string]: string } {
    return {
      inputFile: 'InputFile',
      inputConfig: 'InputConfig',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      inputFile: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputsEditingInputInputFile,
      inputConfig: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputsEditingInputInputConfig,
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputs extends $tea.Model {
  editingInput?: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputsEditingInput[];
  static names(): { [key: string]: string } {
    return {
      editingInput: 'EditingInput',
    };
  }

  static types(): { [key: string]: any } {
    return {
      editingInput: { 'type': 'array', 'itemType': SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputsEditingInput },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigVideoBitrateBnd extends $tea.Model {
  max?: string;
  min?: string;
  static names(): { [key: string]: string } {
    return {
      max: 'Max',
      min: 'Min',
    };
  }

  static types(): { [key: string]: any } {
    return {
      max: 'string',
      min: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigVideo extends $tea.Model {
  bufsize?: string;
  degrain?: string;
  bitrateBnd?: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigVideoBitrateBnd;
  pixFmt?: string;
  pad?: string;
  codec?: string;
  height?: string;
  qscale?: string;
  crop?: string;
  bitrate?: string;
  maxrate?: string;
  maxFps?: string;
  profile?: string;
  crf?: string;
  gop?: string;
  width?: string;
  fps?: string;
  preset?: string;
  scanMode?: string;
  static names(): { [key: string]: string } {
    return {
      bufsize: 'Bufsize',
      degrain: 'Degrain',
      bitrateBnd: 'BitrateBnd',
      pixFmt: 'PixFmt',
      pad: 'Pad',
      codec: 'Codec',
      height: 'Height',
      qscale: 'Qscale',
      crop: 'Crop',
      bitrate: 'Bitrate',
      maxrate: 'Maxrate',
      maxFps: 'MaxFps',
      profile: 'Profile',
      crf: 'Crf',
      gop: 'Gop',
      width: 'Width',
      fps: 'Fps',
      preset: 'Preset',
      scanMode: 'ScanMode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bufsize: 'string',
      degrain: 'string',
      bitrateBnd: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigVideoBitrateBnd,
      pixFmt: 'string',
      pad: 'string',
      codec: 'string',
      height: 'string',
      qscale: 'string',
      crop: 'string',
      bitrate: 'string',
      maxrate: 'string',
      maxFps: 'string',
      profile: 'string',
      crf: 'string',
      gop: 'string',
      width: 'string',
      fps: 'string',
      preset: 'string',
      scanMode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigTransConfig extends $tea.Model {
  isCheckAudioBitrate?: string;
  isCheckReso?: string;
  transMode?: string;
  isCheckVideoBitrateFail?: string;
  adjDarMethod?: string;
  duration?: string;
  isCheckVideoBitrate?: string;
  isCheckResoFail?: string;
  isCheckAudioBitrateFail?: string;
  static names(): { [key: string]: string } {
    return {
      isCheckAudioBitrate: 'IsCheckAudioBitrate',
      isCheckReso: 'IsCheckReso',
      transMode: 'TransMode',
      isCheckVideoBitrateFail: 'IsCheckVideoBitrateFail',
      adjDarMethod: 'AdjDarMethod',
      duration: 'Duration',
      isCheckVideoBitrate: 'IsCheckVideoBitrate',
      isCheckResoFail: 'IsCheckResoFail',
      isCheckAudioBitrateFail: 'IsCheckAudioBitrateFail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isCheckAudioBitrate: 'string',
      isCheckReso: 'string',
      transMode: 'string',
      isCheckVideoBitrateFail: 'string',
      adjDarMethod: 'string',
      duration: 'string',
      isCheckVideoBitrate: 'string',
      isCheckResoFail: 'string',
      isCheckAudioBitrateFail: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEncryption extends $tea.Model {
  type?: string;
  key?: string;
  keyType?: string;
  id?: string;
  keyUri?: string;
  skipCnt?: string;
  static names(): { [key: string]: string } {
    return {
      type: 'Type',
      key: 'Key',
      keyType: 'KeyType',
      id: 'Id',
      keyUri: 'KeyUri',
      skipCnt: 'SkipCnt',
    };
  }

  static types(): { [key: string]: any } {
    return {
      type: 'string',
      key: 'string',
      keyType: 'string',
      id: 'string',
      keyUri: 'string',
      skipCnt: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigWaterMarkListWaterMarkInputFile extends $tea.Model {
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigWaterMarkListWaterMark extends $tea.Model {
  type?: string;
  referPos?: string;
  dx?: string;
  width?: string;
  height?: string;
  inputFile?: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigWaterMarkListWaterMarkInputFile;
  waterMarkTemplateId?: string;
  dy?: string;
  static names(): { [key: string]: string } {
    return {
      type: 'Type',
      referPos: 'ReferPos',
      dx: 'Dx',
      width: 'Width',
      height: 'Height',
      inputFile: 'InputFile',
      waterMarkTemplateId: 'WaterMarkTemplateId',
      dy: 'Dy',
    };
  }

  static types(): { [key: string]: any } {
    return {
      type: 'string',
      referPos: 'string',
      dx: 'string',
      width: 'string',
      height: 'string',
      inputFile: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigWaterMarkListWaterMarkInputFile,
      waterMarkTemplateId: 'string',
      dy: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigWaterMarkList extends $tea.Model {
  waterMark?: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigWaterMarkListWaterMark[];
  static names(): { [key: string]: string } {
    return {
      waterMark: 'WaterMark',
    };
  }

  static types(): { [key: string]: any } {
    return {
      waterMark: { 'type': 'array', 'itemType': SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigWaterMarkListWaterMark },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigM3U8NonStandardSupportTS extends $tea.Model {
  sizeSupport?: boolean;
  md5Support?: boolean;
  static names(): { [key: string]: string } {
    return {
      sizeSupport: 'SizeSupport',
      md5Support: 'Md5Support',
    };
  }

  static types(): { [key: string]: any } {
    return {
      sizeSupport: 'boolean',
      md5Support: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigM3U8NonStandardSupport extends $tea.Model {
  TS?: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigM3U8NonStandardSupportTS;
  static names(): { [key: string]: string } {
    return {
      TS: 'TS',
    };
  }

  static types(): { [key: string]: any } {
    return {
      TS: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigM3U8NonStandardSupportTS,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigAudioVolume extends $tea.Model {
  method?: string;
  level?: string;
  static names(): { [key: string]: string } {
    return {
      method: 'Method',
      level: 'Level',
    };
  }

  static types(): { [key: string]: any } {
    return {
      method: 'string',
      level: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigAudio extends $tea.Model {
  profile?: string;
  codec?: string;
  samplerate?: string;
  qscale?: string;
  channels?: string;
  volume?: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigAudioVolume;
  bitrate?: string;
  static names(): { [key: string]: string } {
    return {
      profile: 'Profile',
      codec: 'Codec',
      samplerate: 'Samplerate',
      qscale: 'Qscale',
      channels: 'Channels',
      volume: 'Volume',
      bitrate: 'Bitrate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      profile: 'string',
      codec: 'string',
      samplerate: 'string',
      qscale: 'string',
      channels: 'string',
      volume: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigAudioVolume,
      bitrate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMergeListMerge extends $tea.Model {
  start?: string;
  roleArn?: string;
  mergeURL?: string;
  duration?: string;
  static names(): { [key: string]: string } {
    return {
      start: 'Start',
      roleArn: 'RoleArn',
      mergeURL: 'MergeURL',
      duration: 'Duration',
    };
  }

  static types(): { [key: string]: any } {
    return {
      start: 'string',
      roleArn: 'string',
      mergeURL: 'string',
      duration: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMergeList extends $tea.Model {
  merge?: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMergeListMerge[];
  static names(): { [key: string]: string } {
    return {
      merge: 'Merge',
    };
  }

  static types(): { [key: string]: any } {
    return {
      merge: { 'type': 'array', 'itemType': SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMergeListMerge },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSuperReso extends $tea.Model {
  isHalfSample?: string;
  static names(): { [key: string]: string } {
    return {
      isHalfSample: 'IsHalfSample',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isHalfSample: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigDigiWaterMarkInputFile extends $tea.Model {
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigDigiWaterMark extends $tea.Model {
  type?: string;
  alpha?: string;
  inputFile?: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigDigiWaterMarkInputFile;
  static names(): { [key: string]: string } {
    return {
      type: 'Type',
      alpha: 'Alpha',
      inputFile: 'InputFile',
    };
  }

  static types(): { [key: string]: any } {
    return {
      type: 'string',
      alpha: 'string',
      inputFile: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigDigiWaterMarkInputFile,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigOutputFile extends $tea.Model {
  roleArn?: string;
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      roleArn: 'RoleArn',
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      roleArn: 'string',
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfigClipsConfigVideo extends $tea.Model {
  t?: string;
  l?: string;
  static names(): { [key: string]: string } {
    return {
      t: 'T',
      l: 'L',
    };
  }

  static types(): { [key: string]: any } {
    return {
      t: 'string',
      l: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfig extends $tea.Model {
  clipsConfigVideo?: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfigClipsConfigVideo;
  static names(): { [key: string]: string } {
    return {
      clipsConfigVideo: 'ClipsConfigVideo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clipsConfigVideo: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfigClipsConfigVideo,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClipsClip extends $tea.Model {
  clipsConfig?: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfig;
  out?: string;
  in?: string;
  clipID?: string;
  static names(): { [key: string]: string } {
    return {
      clipsConfig: 'ClipsConfig',
      out: 'Out',
      in: 'In',
      clipID: 'clipID',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clipsConfig: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfig,
      out: 'string',
      in: 'string',
      clipID: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClips extends $tea.Model {
  clip?: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClipsClip[];
  static names(): { [key: string]: string } {
    return {
      clip: 'Clip',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clip: { 'type': 'array', 'itemType': SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClipsClip },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrack extends $tea.Model {
  type?: string;
  order?: string;
  id?: string;
  clips?: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClips;
  static names(): { [key: string]: string } {
    return {
      type: 'Type',
      order: 'Order',
      id: 'Id',
      clips: 'Clips',
    };
  }

  static types(): { [key: string]: any } {
    return {
      type: 'string',
      order: 'string',
      id: 'string',
      clips: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClips,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackList extends $tea.Model {
  track?: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrack[];
  static names(): { [key: string]: string } {
    return {
      track: 'Track',
    };
  }

  static types(): { [key: string]: any } {
    return {
      track: { 'type': 'array', 'itemType': SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrack },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTimelineConfigTimelineConfigAudio extends $tea.Model {
  channelLayout?: string;
  samplerate?: string;
  channels?: string;
  static names(): { [key: string]: string } {
    return {
      channelLayout: 'ChannelLayout',
      samplerate: 'Samplerate',
      channels: 'Channels',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelLayout: 'string',
      samplerate: 'string',
      channels: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTimelineConfigTimelineConfigVideo extends $tea.Model {
  bgColor?: string;
  width?: string;
  renderRatio?: string;
  isGpuData?: string;
  height?: string;
  isOneTrackData?: string;
  fps?: string;
  reclosePrec?: string;
  static names(): { [key: string]: string } {
    return {
      bgColor: 'BgColor',
      width: 'Width',
      renderRatio: 'RenderRatio',
      isGpuData: 'IsGpuData',
      height: 'Height',
      isOneTrackData: 'IsOneTrackData',
      fps: 'Fps',
      reclosePrec: 'ReclosePrec',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bgColor: 'string',
      width: 'string',
      renderRatio: 'string',
      isGpuData: 'string',
      height: 'string',
      isOneTrackData: 'string',
      fps: 'string',
      reclosePrec: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTimelineConfig extends $tea.Model {
  timelineConfigAudio?: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTimelineConfigTimelineConfigAudio;
  timelineConfigVideo?: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTimelineConfigTimelineConfigVideo;
  static names(): { [key: string]: string } {
    return {
      timelineConfigAudio: 'TimelineConfigAudio',
      timelineConfigVideo: 'TimelineConfigVideo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      timelineConfigAudio: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTimelineConfigTimelineConfigAudio,
      timelineConfigVideo: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTimelineConfigTimelineConfigVideo,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimeline extends $tea.Model {
  trackList?: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackList;
  timelineConfig?: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTimelineConfig;
  static names(): { [key: string]: string } {
    return {
      trackList: 'TrackList',
      timelineConfig: 'TimelineConfig',
    };
  }

  static types(): { [key: string]: any } {
    return {
      trackList: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackList,
      timelineConfig: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTimelineConfig,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipListClipEffectsEffect extends $tea.Model {
  effect?: string;
  effectConfig?: string;
  static names(): { [key: string]: string } {
    return {
      effect: 'Effect',
      effectConfig: 'EffectConfig',
    };
  }

  static types(): { [key: string]: any } {
    return {
      effect: 'string',
      effectConfig: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipListClipEffects extends $tea.Model {
  effect?: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipListClipEffectsEffect[];
  static names(): { [key: string]: string } {
    return {
      effect: 'Effect',
    };
  }

  static types(): { [key: string]: any } {
    return {
      effect: { 'type': 'array', 'itemType': SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipListClipEffectsEffect },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipListClip extends $tea.Model {
  type?: string;
  sourceID?: string;
  effects?: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipListClipEffects;
  sourceType?: string;
  sourceStrmMap?: string;
  out?: string;
  in?: string;
  id?: string;
  static names(): { [key: string]: string } {
    return {
      type: 'Type',
      sourceID: 'SourceID',
      effects: 'Effects',
      sourceType: 'SourceType',
      sourceStrmMap: 'SourceStrmMap',
      out: 'Out',
      in: 'In',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      type: 'string',
      sourceID: 'string',
      effects: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipListClipEffects,
      sourceType: 'string',
      sourceStrmMap: 'string',
      out: 'string',
      in: 'string',
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipList extends $tea.Model {
  clip?: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipListClip[];
  static names(): { [key: string]: string } {
    return {
      clip: 'Clip',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clip: { 'type': 'array', 'itemType': SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipListClip },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditing extends $tea.Model {
  timeline?: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimeline;
  clipList?: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipList;
  static names(): { [key: string]: string } {
    return {
      timeline: 'Timeline',
      clipList: 'ClipList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      timeline: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimeline,
      clipList: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigContainer extends $tea.Model {
  format?: string;
  static names(): { [key: string]: string } {
    return {
      format: 'Format',
    };
  }

  static types(): { [key: string]: any } {
    return {
      format: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigClipTimeSpan extends $tea.Model {
  seek?: string;
  duration?: string;
  static names(): { [key: string]: string } {
    return {
      seek: 'Seek',
      duration: 'Duration',
    };
  }

  static types(): { [key: string]: any } {
    return {
      seek: 'string',
      duration: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigClip extends $tea.Model {
  timeSpan?: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigClipTimeSpan;
  static names(): { [key: string]: string } {
    return {
      timeSpan: 'TimeSpan',
    };
  }

  static types(): { [key: string]: any } {
    return {
      timeSpan: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigClipTimeSpan,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMuxConfigGif extends $tea.Model {
  finalDelay?: string;
  ditherMode?: string;
  loop?: string;
  isCustomPalette?: string;
  static names(): { [key: string]: string } {
    return {
      finalDelay: 'FinalDelay',
      ditherMode: 'DitherMode',
      loop: 'Loop',
      isCustomPalette: 'IsCustomPalette',
    };
  }

  static types(): { [key: string]: any } {
    return {
      finalDelay: 'string',
      ditherMode: 'string',
      loop: 'string',
      isCustomPalette: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMuxConfigSegment extends $tea.Model {
  duration?: string;
  static names(): { [key: string]: string } {
    return {
      duration: 'Duration',
    };
  }

  static types(): { [key: string]: any } {
    return {
      duration: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMuxConfig extends $tea.Model {
  gif?: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMuxConfigGif;
  segment?: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMuxConfigSegment;
  static names(): { [key: string]: string } {
    return {
      gif: 'Gif',
      segment: 'Segment',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gif: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMuxConfigGif,
      segment: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMuxConfigSegment,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitleInput extends $tea.Model {
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitle extends $tea.Model {
  charEnc?: string;
  fontName?: string;
  input?: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitleInput;
  static names(): { [key: string]: string } {
    return {
      charEnc: 'CharEnc',
      fontName: 'FontName',
      input: 'Input',
    };
  }

  static types(): { [key: string]: any } {
    return {
      charEnc: 'string',
      fontName: 'string',
      input: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitleInput,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigExtSubtitleList extends $tea.Model {
  extSubtitle?: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitle[];
  static names(): { [key: string]: string } {
    return {
      extSubtitle: 'ExtSubtitle',
    };
  }

  static types(): { [key: string]: any } {
    return {
      extSubtitle: { 'type': 'array', 'itemType': SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitle },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigSubtitleListSubtitle extends $tea.Model {
  map?: string;
  static names(): { [key: string]: string } {
    return {
      map: 'Map',
    };
  }

  static types(): { [key: string]: any } {
    return {
      map: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigSubtitleList extends $tea.Model {
  subtitle?: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigSubtitleListSubtitle[];
  static names(): { [key: string]: string } {
    return {
      subtitle: 'Subtitle',
    };
  }

  static types(): { [key: string]: any } {
    return {
      subtitle: { 'type': 'array', 'itemType': SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigSubtitleListSubtitle },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfig extends $tea.Model {
  extSubtitleList?: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigExtSubtitleList;
  subtitleList?: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigSubtitleList;
  static names(): { [key: string]: string } {
    return {
      extSubtitleList: 'ExtSubtitleList',
      subtitleList: 'SubtitleList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      extSubtitleList: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigExtSubtitleList,
      subtitleList: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigSubtitleList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsVideoStreamListVideoStreamNetworkCost extends $tea.Model {
  preloadTime?: string;
  avgBitrate?: string;
  costBandwidth?: string;
  static names(): { [key: string]: string } {
    return {
      preloadTime: 'PreloadTime',
      avgBitrate: 'AvgBitrate',
      costBandwidth: 'CostBandwidth',
    };
  }

  static types(): { [key: string]: any } {
    return {
      preloadTime: 'string',
      avgBitrate: 'string',
      costBandwidth: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsVideoStreamListVideoStream extends $tea.Model {
  index?: string;
  timebase?: string;
  avgFPS?: string;
  pixFmt?: string;
  sar?: string;
  lang?: string;
  codecLongName?: string;
  height?: string;
  numFrames?: string;
  bitrate?: string;
  codecTagString?: string;
  hasBFrames?: string;
  profile?: string;
  startTime?: string;
  networkCost?: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsVideoStreamListVideoStreamNetworkCost;
  dar?: string;
  codecName?: string;
  width?: string;
  duration?: string;
  fps?: string;
  codecTag?: string;
  codecTimeBase?: string;
  level?: string;
  static names(): { [key: string]: string } {
    return {
      index: 'Index',
      timebase: 'Timebase',
      avgFPS: 'AvgFPS',
      pixFmt: 'PixFmt',
      sar: 'Sar',
      lang: 'Lang',
      codecLongName: 'CodecLongName',
      height: 'Height',
      numFrames: 'NumFrames',
      bitrate: 'Bitrate',
      codecTagString: 'CodecTagString',
      hasBFrames: 'HasBFrames',
      profile: 'Profile',
      startTime: 'StartTime',
      networkCost: 'NetworkCost',
      dar: 'Dar',
      codecName: 'CodecName',
      width: 'Width',
      duration: 'Duration',
      fps: 'Fps',
      codecTag: 'CodecTag',
      codecTimeBase: 'CodecTimeBase',
      level: 'Level',
    };
  }

  static types(): { [key: string]: any } {
    return {
      index: 'string',
      timebase: 'string',
      avgFPS: 'string',
      pixFmt: 'string',
      sar: 'string',
      lang: 'string',
      codecLongName: 'string',
      height: 'string',
      numFrames: 'string',
      bitrate: 'string',
      codecTagString: 'string',
      hasBFrames: 'string',
      profile: 'string',
      startTime: 'string',
      networkCost: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsVideoStreamListVideoStreamNetworkCost,
      dar: 'string',
      codecName: 'string',
      width: 'string',
      duration: 'string',
      fps: 'string',
      codecTag: 'string',
      codecTimeBase: 'string',
      level: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsVideoStreamList extends $tea.Model {
  videoStream?: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsVideoStreamListVideoStream[];
  static names(): { [key: string]: string } {
    return {
      videoStream: 'VideoStream',
    };
  }

  static types(): { [key: string]: any } {
    return {
      videoStream: { 'type': 'array', 'itemType': SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsVideoStreamListVideoStream },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsAudioStreamListAudioStream extends $tea.Model {
  timebase?: string;
  index?: string;
  sampleFmt?: string;
  channelLayout?: string;
  lang?: string;
  samplerate?: string;
  codecLongName?: string;
  channels?: string;
  numFrames?: string;
  bitrate?: string;
  codecTagString?: string;
  startTime?: string;
  codecName?: string;
  duration?: string;
  codecTag?: string;
  codecTimeBase?: string;
  static names(): { [key: string]: string } {
    return {
      timebase: 'Timebase',
      index: 'Index',
      sampleFmt: 'SampleFmt',
      channelLayout: 'ChannelLayout',
      lang: 'Lang',
      samplerate: 'Samplerate',
      codecLongName: 'CodecLongName',
      channels: 'Channels',
      numFrames: 'NumFrames',
      bitrate: 'Bitrate',
      codecTagString: 'CodecTagString',
      startTime: 'StartTime',
      codecName: 'CodecName',
      duration: 'Duration',
      codecTag: 'CodecTag',
      codecTimeBase: 'CodecTimeBase',
    };
  }

  static types(): { [key: string]: any } {
    return {
      timebase: 'string',
      index: 'string',
      sampleFmt: 'string',
      channelLayout: 'string',
      lang: 'string',
      samplerate: 'string',
      codecLongName: 'string',
      channels: 'string',
      numFrames: 'string',
      bitrate: 'string',
      codecTagString: 'string',
      startTime: 'string',
      codecName: 'string',
      duration: 'string',
      codecTag: 'string',
      codecTimeBase: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsAudioStreamList extends $tea.Model {
  audioStream?: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsAudioStreamListAudioStream[];
  static names(): { [key: string]: string } {
    return {
      audioStream: 'AudioStream',
    };
  }

  static types(): { [key: string]: any } {
    return {
      audioStream: { 'type': 'array', 'itemType': SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsAudioStreamListAudioStream },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsSubtitleStreamListSubtitleStream extends $tea.Model {
  index?: string;
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      index: 'Index',
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      index: 'string',
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsSubtitleStreamList extends $tea.Model {
  subtitleStream?: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsSubtitleStreamListSubtitleStream[];
  static names(): { [key: string]: string } {
    return {
      subtitleStream: 'SubtitleStream',
    };
  }

  static types(): { [key: string]: any } {
    return {
      subtitleStream: { 'type': 'array', 'itemType': SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsSubtitleStreamListSubtitleStream },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreams extends $tea.Model {
  videoStreamList?: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsVideoStreamList;
  audioStreamList?: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsAudioStreamList;
  subtitleStreamList?: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsSubtitleStreamList;
  static names(): { [key: string]: string } {
    return {
      videoStreamList: 'VideoStreamList',
      audioStreamList: 'AudioStreamList',
      subtitleStreamList: 'SubtitleStreamList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      videoStreamList: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsVideoStreamList,
      audioStreamList: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsAudioStreamList,
      subtitleStreamList: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsSubtitleStreamList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesFormat extends $tea.Model {
  startTime?: string;
  numPrograms?: string;
  size?: string;
  numStreams?: string;
  formatLongName?: string;
  duration?: string;
  bitrate?: string;
  formatName?: string;
  static names(): { [key: string]: string } {
    return {
      startTime: 'StartTime',
      numPrograms: 'NumPrograms',
      size: 'Size',
      numStreams: 'NumStreams',
      formatLongName: 'FormatLongName',
      duration: 'Duration',
      bitrate: 'Bitrate',
      formatName: 'FormatName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      startTime: 'string',
      numPrograms: 'string',
      size: 'string',
      numStreams: 'string',
      formatLongName: 'string',
      duration: 'string',
      bitrate: 'string',
      formatName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigProperties extends $tea.Model {
  width?: string;
  height?: string;
  duration?: string;
  fps?: string;
  bitrate?: string;
  fileFormat?: string;
  streams?: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreams;
  format?: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesFormat;
  fileSize?: string;
  static names(): { [key: string]: string } {
    return {
      width: 'Width',
      height: 'Height',
      duration: 'Duration',
      fps: 'Fps',
      bitrate: 'Bitrate',
      fileFormat: 'FileFormat',
      streams: 'Streams',
      format: 'Format',
      fileSize: 'FileSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      width: 'string',
      height: 'string',
      duration: 'string',
      fps: 'string',
      bitrate: 'string',
      fileFormat: 'string',
      streams: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreams,
      format: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesFormat,
      fileSize: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfig extends $tea.Model {
  video?: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigVideo;
  transConfig?: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigTransConfig;
  encryption?: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEncryption;
  waterMarkList?: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigWaterMarkList;
  deWatermark?: string;
  waterMarkConfigUrl?: string;
  m3U8NonStandardSupport?: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigM3U8NonStandardSupport;
  priority?: string;
  audio?: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigAudio;
  audioStreamMap?: string;
  mergeList?: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMergeList;
  superReso?: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSuperReso;
  userData?: string;
  digiWaterMark?: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigDigiWaterMark;
  videoStreamMap?: string;
  outputFile?: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigOutputFile;
  rotate?: string;
  editing?: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditing;
  container?: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigContainer;
  clip?: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigClip;
  mergeConfigUrl?: string;
  muxConfig?: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMuxConfig;
  templateId?: string;
  subtitleConfig?: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfig;
  properties?: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigProperties;
  static names(): { [key: string]: string } {
    return {
      video: 'Video',
      transConfig: 'TransConfig',
      encryption: 'Encryption',
      waterMarkList: 'WaterMarkList',
      deWatermark: 'DeWatermark',
      waterMarkConfigUrl: 'WaterMarkConfigUrl',
      m3U8NonStandardSupport: 'M3U8NonStandardSupport',
      priority: 'Priority',
      audio: 'Audio',
      audioStreamMap: 'AudioStreamMap',
      mergeList: 'MergeList',
      superReso: 'SuperReso',
      userData: 'UserData',
      digiWaterMark: 'DigiWaterMark',
      videoStreamMap: 'VideoStreamMap',
      outputFile: 'OutputFile',
      rotate: 'Rotate',
      editing: 'Editing',
      container: 'Container',
      clip: 'Clip',
      mergeConfigUrl: 'MergeConfigUrl',
      muxConfig: 'MuxConfig',
      templateId: 'TemplateId',
      subtitleConfig: 'SubtitleConfig',
      properties: 'Properties',
    };
  }

  static types(): { [key: string]: any } {
    return {
      video: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigVideo,
      transConfig: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigTransConfig,
      encryption: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEncryption,
      waterMarkList: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigWaterMarkList,
      deWatermark: 'string',
      waterMarkConfigUrl: 'string',
      m3U8NonStandardSupport: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigM3U8NonStandardSupport,
      priority: 'string',
      audio: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigAudio,
      audioStreamMap: 'string',
      mergeList: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMergeList,
      superReso: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSuperReso,
      userData: 'string',
      digiWaterMark: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigDigiWaterMark,
      videoStreamMap: 'string',
      outputFile: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigOutputFile,
      rotate: 'string',
      editing: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditing,
      container: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigContainer,
      clip: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigClip,
      mergeConfigUrl: 'string',
      muxConfig: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMuxConfig,
      templateId: 'string',
      subtitleConfig: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfig,
      properties: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigProperties,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitEditingJobsResponseBodyJobResultListJobResultJobMNSMessageResult extends $tea.Model {
  messageId?: string;
  errorMessage?: string;
  errorCode?: string;
  static names(): { [key: string]: string } {
    return {
      messageId: 'MessageId',
      errorMessage: 'ErrorMessage',
      errorCode: 'ErrorCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      messageId: 'string',
      errorMessage: 'string',
      errorCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitEditingJobsResponseBodyJobResultListJobResultJob extends $tea.Model {
  creationTime?: string;
  percent?: number;
  finishTime?: string;
  state?: string;
  jobId?: string;
  code?: string;
  message?: string;
  editingInputs?: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputs;
  pipelineId?: string;
  editingConfig?: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfig;
  MNSMessageResult?: SubmitEditingJobsResponseBodyJobResultListJobResultJobMNSMessageResult;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      percent: 'Percent',
      finishTime: 'FinishTime',
      state: 'State',
      jobId: 'JobId',
      code: 'Code',
      message: 'Message',
      editingInputs: 'EditingInputs',
      pipelineId: 'PipelineId',
      editingConfig: 'EditingConfig',
      MNSMessageResult: 'MNSMessageResult',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      percent: 'number',
      finishTime: 'string',
      state: 'string',
      jobId: 'string',
      code: 'string',
      message: 'string',
      editingInputs: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputs,
      pipelineId: 'string',
      editingConfig: SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfig,
      MNSMessageResult: SubmitEditingJobsResponseBodyJobResultListJobResultJobMNSMessageResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitEditingJobsResponseBodyJobResultListJobResult extends $tea.Model {
  job?: SubmitEditingJobsResponseBodyJobResultListJobResultJob;
  success?: boolean;
  code?: string;
  message?: string;
  static names(): { [key: string]: string } {
    return {
      job: 'Job',
      success: 'Success',
      code: 'Code',
      message: 'Message',
    };
  }

  static types(): { [key: string]: any } {
    return {
      job: SubmitEditingJobsResponseBodyJobResultListJobResultJob,
      success: 'boolean',
      code: 'string',
      message: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitEditingJobsResponseBodyJobResultList extends $tea.Model {
  jobResult?: SubmitEditingJobsResponseBodyJobResultListJobResult[];
  static names(): { [key: string]: string } {
    return {
      jobResult: 'JobResult',
    };
  }

  static types(): { [key: string]: any } {
    return {
      jobResult: { 'type': 'array', 'itemType': SubmitEditingJobsResponseBodyJobResultListJobResult },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitImageQualityJobResponseBodyImageQualityJobResult extends $tea.Model {
  code?: string;
  message?: string;
  score?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      score: 'Score',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      score: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitImageQualityJobResponseBodyImageQualityJobInput extends $tea.Model {
  url?: string;
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      url: 'Url',
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      url: 'string',
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitImageQualityJobResponseBodyImageQualityJob extends $tea.Model {
  creationTime?: string;
  result?: SubmitImageQualityJobResponseBodyImageQualityJobResult;
  state?: string;
  jobId?: string;
  userData?: string;
  pipelineId?: string;
  input?: SubmitImageQualityJobResponseBodyImageQualityJobInput;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      result: 'Result',
      state: 'State',
      jobId: 'JobId',
      userData: 'UserData',
      pipelineId: 'PipelineId',
      input: 'Input',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      result: SubmitImageQualityJobResponseBodyImageQualityJobResult,
      state: 'string',
      jobId: 'string',
      userData: 'string',
      pipelineId: 'string',
      input: SubmitImageQualityJobResponseBodyImageQualityJobInput,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitJobsResponseBodyJobResultListJobResultJobOutputVideoBitrateBnd extends $tea.Model {
  max?: string;
  min?: string;
  static names(): { [key: string]: string } {
    return {
      max: 'Max',
      min: 'Min',
    };
  }

  static types(): { [key: string]: any } {
    return {
      max: 'string',
      min: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitJobsResponseBodyJobResultListJobResultJobOutputVideo extends $tea.Model {
  bufsize?: string;
  degrain?: string;
  bitrateBnd?: SubmitJobsResponseBodyJobResultListJobResultJobOutputVideoBitrateBnd;
  pixFmt?: string;
  pad?: string;
  codec?: string;
  height?: string;
  qscale?: string;
  crop?: string;
  bitrate?: string;
  maxrate?: string;
  maxFps?: string;
  profile?: string;
  crf?: string;
  gop?: string;
  width?: string;
  fps?: string;
  preset?: string;
  scanMode?: string;
  resoPriority?: string;
  static names(): { [key: string]: string } {
    return {
      bufsize: 'Bufsize',
      degrain: 'Degrain',
      bitrateBnd: 'BitrateBnd',
      pixFmt: 'PixFmt',
      pad: 'Pad',
      codec: 'Codec',
      height: 'Height',
      qscale: 'Qscale',
      crop: 'Crop',
      bitrate: 'Bitrate',
      maxrate: 'Maxrate',
      maxFps: 'MaxFps',
      profile: 'Profile',
      crf: 'Crf',
      gop: 'Gop',
      width: 'Width',
      fps: 'Fps',
      preset: 'Preset',
      scanMode: 'ScanMode',
      resoPriority: 'ResoPriority',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bufsize: 'string',
      degrain: 'string',
      bitrateBnd: SubmitJobsResponseBodyJobResultListJobResultJobOutputVideoBitrateBnd,
      pixFmt: 'string',
      pad: 'string',
      codec: 'string',
      height: 'string',
      qscale: 'string',
      crop: 'string',
      bitrate: 'string',
      maxrate: 'string',
      maxFps: 'string',
      profile: 'string',
      crf: 'string',
      gop: 'string',
      width: 'string',
      fps: 'string',
      preset: 'string',
      scanMode: 'string',
      resoPriority: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitJobsResponseBodyJobResultListJobResultJobOutputTransConfig extends $tea.Model {
  isCheckAudioBitrate?: string;
  transMode?: string;
  isCheckReso?: string;
  isCheckVideoBitrateFail?: string;
  adjDarMethod?: string;
  isCheckVideoBitrate?: string;
  isCheckResoFail?: string;
  isCheckAudioBitrateFail?: string;
  static names(): { [key: string]: string } {
    return {
      isCheckAudioBitrate: 'IsCheckAudioBitrate',
      transMode: 'TransMode',
      isCheckReso: 'IsCheckReso',
      isCheckVideoBitrateFail: 'IsCheckVideoBitrateFail',
      adjDarMethod: 'AdjDarMethod',
      isCheckVideoBitrate: 'IsCheckVideoBitrate',
      isCheckResoFail: 'IsCheckResoFail',
      isCheckAudioBitrateFail: 'IsCheckAudioBitrateFail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isCheckAudioBitrate: 'string',
      transMode: 'string',
      isCheckReso: 'string',
      isCheckVideoBitrateFail: 'string',
      adjDarMethod: 'string',
      isCheckVideoBitrate: 'string',
      isCheckResoFail: 'string',
      isCheckAudioBitrateFail: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitJobsResponseBodyJobResultListJobResultJobOutputEncryption extends $tea.Model {
  type?: string;
  key?: string;
  keyType?: string;
  id?: string;
  keyUri?: string;
  skipCnt?: string;
  static names(): { [key: string]: string } {
    return {
      type: 'Type',
      key: 'Key',
      keyType: 'KeyType',
      id: 'Id',
      keyUri: 'KeyUri',
      skipCnt: 'SkipCnt',
    };
  }

  static types(): { [key: string]: any } {
    return {
      type: 'string',
      key: 'string',
      keyType: 'string',
      id: 'string',
      keyUri: 'string',
      skipCnt: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkListWaterMarkInputFile extends $tea.Model {
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkListWaterMark extends $tea.Model {
  type?: string;
  referPos?: string;
  dx?: string;
  width?: string;
  height?: string;
  inputFile?: SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkListWaterMarkInputFile;
  waterMarkTemplateId?: string;
  dy?: string;
  static names(): { [key: string]: string } {
    return {
      type: 'Type',
      referPos: 'ReferPos',
      dx: 'Dx',
      width: 'Width',
      height: 'Height',
      inputFile: 'InputFile',
      waterMarkTemplateId: 'WaterMarkTemplateId',
      dy: 'Dy',
    };
  }

  static types(): { [key: string]: any } {
    return {
      type: 'string',
      referPos: 'string',
      dx: 'string',
      width: 'string',
      height: 'string',
      inputFile: SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkListWaterMarkInputFile,
      waterMarkTemplateId: 'string',
      dy: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkList extends $tea.Model {
  waterMark?: SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkListWaterMark[];
  static names(): { [key: string]: string } {
    return {
      waterMark: 'WaterMark',
    };
  }

  static types(): { [key: string]: any } {
    return {
      waterMark: { 'type': 'array', 'itemType': SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkListWaterMark },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitJobsResponseBodyJobResultListJobResultJobOutputM3U8NonStandardSupportTS extends $tea.Model {
  sizeSupport?: boolean;
  md5Support?: boolean;
  static names(): { [key: string]: string } {
    return {
      sizeSupport: 'SizeSupport',
      md5Support: 'Md5Support',
    };
  }

  static types(): { [key: string]: any } {
    return {
      sizeSupport: 'boolean',
      md5Support: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitJobsResponseBodyJobResultListJobResultJobOutputM3U8NonStandardSupport extends $tea.Model {
  TS?: SubmitJobsResponseBodyJobResultListJobResultJobOutputM3U8NonStandardSupportTS;
  static names(): { [key: string]: string } {
    return {
      TS: 'TS',
    };
  }

  static types(): { [key: string]: any } {
    return {
      TS: SubmitJobsResponseBodyJobResultListJobResultJobOutputM3U8NonStandardSupportTS,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitJobsResponseBodyJobResultListJobResultJobOutputAudioVolume extends $tea.Model {
  method?: string;
  level?: string;
  static names(): { [key: string]: string } {
    return {
      method: 'Method',
      level: 'Level',
    };
  }

  static types(): { [key: string]: any } {
    return {
      method: 'string',
      level: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitJobsResponseBodyJobResultListJobResultJobOutputAudio extends $tea.Model {
  profile?: string;
  codec?: string;
  samplerate?: string;
  qscale?: string;
  channels?: string;
  volume?: SubmitJobsResponseBodyJobResultListJobResultJobOutputAudioVolume;
  bitrate?: string;
  static names(): { [key: string]: string } {
    return {
      profile: 'Profile',
      codec: 'Codec',
      samplerate: 'Samplerate',
      qscale: 'Qscale',
      channels: 'Channels',
      volume: 'Volume',
      bitrate: 'Bitrate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      profile: 'string',
      codec: 'string',
      samplerate: 'string',
      qscale: 'string',
      channels: 'string',
      volume: SubmitJobsResponseBodyJobResultListJobResultJobOutputAudioVolume,
      bitrate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitJobsResponseBodyJobResultListJobResultJobOutputMergeListMerge extends $tea.Model {
  start?: string;
  roleArn?: string;
  mergeURL?: string;
  duration?: string;
  static names(): { [key: string]: string } {
    return {
      start: 'Start',
      roleArn: 'RoleArn',
      mergeURL: 'MergeURL',
      duration: 'Duration',
    };
  }

  static types(): { [key: string]: any } {
    return {
      start: 'string',
      roleArn: 'string',
      mergeURL: 'string',
      duration: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitJobsResponseBodyJobResultListJobResultJobOutputMergeList extends $tea.Model {
  merge?: SubmitJobsResponseBodyJobResultListJobResultJobOutputMergeListMerge[];
  static names(): { [key: string]: string } {
    return {
      merge: 'Merge',
    };
  }

  static types(): { [key: string]: any } {
    return {
      merge: { 'type': 'array', 'itemType': SubmitJobsResponseBodyJobResultListJobResultJobOutputMergeListMerge },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitJobsResponseBodyJobResultListJobResultJobOutputSuperReso extends $tea.Model {
  isHalfSample?: string;
  static names(): { [key: string]: string } {
    return {
      isHalfSample: 'IsHalfSample',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isHalfSample: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleListOutSubtitleOutSubtitleFile extends $tea.Model {
  roleArn?: string;
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      roleArn: 'RoleArn',
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      roleArn: 'string',
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleListOutSubtitle extends $tea.Model {
  map?: string;
  outSubtitleFile?: SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleListOutSubtitleOutSubtitleFile;
  success?: boolean;
  message?: string;
  static names(): { [key: string]: string } {
    return {
      map: 'Map',
      outSubtitleFile: 'OutSubtitleFile',
      success: 'Success',
      message: 'Message',
    };
  }

  static types(): { [key: string]: any } {
    return {
      map: 'string',
      outSubtitleFile: SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleListOutSubtitleOutSubtitleFile,
      success: 'boolean',
      message: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleList extends $tea.Model {
  outSubtitle?: SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleListOutSubtitle[];
  static names(): { [key: string]: string } {
    return {
      outSubtitle: 'OutSubtitle',
    };
  }

  static types(): { [key: string]: any } {
    return {
      outSubtitle: { 'type': 'array', 'itemType': SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleListOutSubtitle },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitJobsResponseBodyJobResultListJobResultJobOutputDigiWaterMarkInputFile extends $tea.Model {
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitJobsResponseBodyJobResultListJobResultJobOutputDigiWaterMark extends $tea.Model {
  type?: string;
  alpha?: string;
  inputFile?: SubmitJobsResponseBodyJobResultListJobResultJobOutputDigiWaterMarkInputFile;
  static names(): { [key: string]: string } {
    return {
      type: 'Type',
      alpha: 'Alpha',
      inputFile: 'InputFile',
    };
  }

  static types(): { [key: string]: any } {
    return {
      type: 'string',
      alpha: 'string',
      inputFile: SubmitJobsResponseBodyJobResultListJobResultJobOutputDigiWaterMarkInputFile,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitJobsResponseBodyJobResultListJobResultJobOutputOutputFile extends $tea.Model {
  roleArn?: string;
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      roleArn: 'RoleArn',
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      roleArn: 'string',
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitJobsResponseBodyJobResultListJobResultJobOutputAmixListAmix extends $tea.Model {
  map?: string;
  start?: string;
  amixURL?: string;
  duration?: string;
  mixDurMode?: string;
  static names(): { [key: string]: string } {
    return {
      map: 'Map',
      start: 'Start',
      amixURL: 'AmixURL',
      duration: 'Duration',
      mixDurMode: 'MixDurMode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      map: 'string',
      start: 'string',
      amixURL: 'string',
      duration: 'string',
      mixDurMode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitJobsResponseBodyJobResultListJobResultJobOutputAmixList extends $tea.Model {
  amix?: SubmitJobsResponseBodyJobResultListJobResultJobOutputAmixListAmix[];
  static names(): { [key: string]: string } {
    return {
      amix: 'Amix',
    };
  }

  static types(): { [key: string]: any } {
    return {
      amix: { 'type': 'array', 'itemType': SubmitJobsResponseBodyJobResultListJobResultJobOutputAmixListAmix },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitJobsResponseBodyJobResultListJobResultJobOutputContainer extends $tea.Model {
  format?: string;
  static names(): { [key: string]: string } {
    return {
      format: 'Format',
    };
  }

  static types(): { [key: string]: any } {
    return {
      format: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitJobsResponseBodyJobResultListJobResultJobOutputClipTimeSpan extends $tea.Model {
  seek?: string;
  duration?: string;
  static names(): { [key: string]: string } {
    return {
      seek: 'Seek',
      duration: 'Duration',
    };
  }

  static types(): { [key: string]: any } {
    return {
      seek: 'string',
      duration: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitJobsResponseBodyJobResultListJobResultJobOutputClip extends $tea.Model {
  timeSpan?: SubmitJobsResponseBodyJobResultListJobResultJobOutputClipTimeSpan;
  static names(): { [key: string]: string } {
    return {
      timeSpan: 'TimeSpan',
    };
  }

  static types(): { [key: string]: any } {
    return {
      timeSpan: SubmitJobsResponseBodyJobResultListJobResultJobOutputClipTimeSpan,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitJobsResponseBodyJobResultListJobResultJobOutputOpeningListOpening extends $tea.Model {
  openUrl?: string;
  start?: string;
  width?: string;
  height?: string;
  static names(): { [key: string]: string } {
    return {
      openUrl: 'openUrl',
      start: 'Start',
      width: 'Width',
      height: 'Height',
    };
  }

  static types(): { [key: string]: any } {
    return {
      openUrl: 'string',
      start: 'string',
      width: 'string',
      height: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitJobsResponseBodyJobResultListJobResultJobOutputOpeningList extends $tea.Model {
  opening?: SubmitJobsResponseBodyJobResultListJobResultJobOutputOpeningListOpening[];
  static names(): { [key: string]: string } {
    return {
      opening: 'Opening',
    };
  }

  static types(): { [key: string]: any } {
    return {
      opening: { 'type': 'array', 'itemType': SubmitJobsResponseBodyJobResultListJobResultJobOutputOpeningListOpening },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigWebp extends $tea.Model {
  loop?: string;
  static names(): { [key: string]: string } {
    return {
      loop: 'Loop',
    };
  }

  static types(): { [key: string]: any } {
    return {
      loop: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigGif extends $tea.Model {
  finalDelay?: string;
  ditherMode?: string;
  loop?: string;
  isCustomPalette?: string;
  static names(): { [key: string]: string } {
    return {
      finalDelay: 'FinalDelay',
      ditherMode: 'DitherMode',
      loop: 'Loop',
      isCustomPalette: 'IsCustomPalette',
    };
  }

  static types(): { [key: string]: any } {
    return {
      finalDelay: 'string',
      ditherMode: 'string',
      loop: 'string',
      isCustomPalette: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigSegment extends $tea.Model {
  duration?: string;
  static names(): { [key: string]: string } {
    return {
      duration: 'Duration',
    };
  }

  static types(): { [key: string]: any } {
    return {
      duration: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfig extends $tea.Model {
  webp?: SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigWebp;
  gif?: SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigGif;
  segment?: SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigSegment;
  static names(): { [key: string]: string } {
    return {
      webp: 'Webp',
      gif: 'Gif',
      segment: 'Segment',
    };
  }

  static types(): { [key: string]: any } {
    return {
      webp: SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigWebp,
      gif: SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigGif,
      segment: SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigSegment,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitJobsResponseBodyJobResultListJobResultJobOutputTailSlateListTailSlate extends $tea.Model {
  start?: string;
  bgColor?: string;
  isMergeAudio?: boolean;
  width?: string;
  height?: string;
  blendDuration?: string;
  tailUrl?: string;
  static names(): { [key: string]: string } {
    return {
      start: 'Start',
      bgColor: 'BgColor',
      isMergeAudio: 'IsMergeAudio',
      width: 'Width',
      height: 'Height',
      blendDuration: 'BlendDuration',
      tailUrl: 'TailUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      start: 'string',
      bgColor: 'string',
      isMergeAudio: 'boolean',
      width: 'string',
      height: 'string',
      blendDuration: 'string',
      tailUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitJobsResponseBodyJobResultListJobResultJobOutputTailSlateList extends $tea.Model {
  tailSlate?: SubmitJobsResponseBodyJobResultListJobResultJobOutputTailSlateListTailSlate[];
  static names(): { [key: string]: string } {
    return {
      tailSlate: 'TailSlate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tailSlate: { 'type': 'array', 'itemType': SubmitJobsResponseBodyJobResultListJobResultJobOutputTailSlateListTailSlate },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput extends $tea.Model {
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleListExtSubtitle extends $tea.Model {
  charEnc?: string;
  fontName?: string;
  input?: SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput;
  static names(): { [key: string]: string } {
    return {
      charEnc: 'CharEnc',
      fontName: 'FontName',
      input: 'Input',
    };
  }

  static types(): { [key: string]: any } {
    return {
      charEnc: 'string',
      fontName: 'string',
      input: SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleList extends $tea.Model {
  extSubtitle?: SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleListExtSubtitle[];
  static names(): { [key: string]: string } {
    return {
      extSubtitle: 'ExtSubtitle',
    };
  }

  static types(): { [key: string]: any } {
    return {
      extSubtitle: { 'type': 'array', 'itemType': SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleListExtSubtitle },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigSubtitleListSubtitle extends $tea.Model {
  map?: string;
  static names(): { [key: string]: string } {
    return {
      map: 'Map',
    };
  }

  static types(): { [key: string]: any } {
    return {
      map: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigSubtitleList extends $tea.Model {
  subtitle?: SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigSubtitleListSubtitle[];
  static names(): { [key: string]: string } {
    return {
      subtitle: 'Subtitle',
    };
  }

  static types(): { [key: string]: any } {
    return {
      subtitle: { 'type': 'array', 'itemType': SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigSubtitleListSubtitle },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfig extends $tea.Model {
  extSubtitleList?: SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleList;
  subtitleList?: SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigSubtitleList;
  static names(): { [key: string]: string } {
    return {
      extSubtitleList: 'ExtSubtitleList',
      subtitleList: 'SubtitleList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      extSubtitleList: SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleList,
      subtitleList: SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigSubtitleList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost extends $tea.Model {
  preloadTime?: string;
  avgBitrate?: string;
  costBandwidth?: string;
  static names(): { [key: string]: string } {
    return {
      preloadTime: 'PreloadTime',
      avgBitrate: 'AvgBitrate',
      costBandwidth: 'CostBandwidth',
    };
  }

  static types(): { [key: string]: any } {
    return {
      preloadTime: 'string',
      avgBitrate: 'string',
      costBandwidth: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamListVideoStream extends $tea.Model {
  index?: string;
  timebase?: string;
  avgFPS?: string;
  pixFmt?: string;
  sar?: string;
  lang?: string;
  codecLongName?: string;
  height?: string;
  numFrames?: string;
  bitrate?: string;
  codecTagString?: string;
  hasBFrames?: string;
  profile?: string;
  startTime?: string;
  networkCost?: SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost;
  dar?: string;
  codecName?: string;
  width?: string;
  duration?: string;
  fps?: string;
  codecTag?: string;
  codecTimeBase?: string;
  level?: string;
  static names(): { [key: string]: string } {
    return {
      index: 'Index',
      timebase: 'Timebase',
      avgFPS: 'AvgFPS',
      pixFmt: 'PixFmt',
      sar: 'Sar',
      lang: 'Lang',
      codecLongName: 'CodecLongName',
      height: 'Height',
      numFrames: 'NumFrames',
      bitrate: 'Bitrate',
      codecTagString: 'CodecTagString',
      hasBFrames: 'HasBFrames',
      profile: 'Profile',
      startTime: 'StartTime',
      networkCost: 'NetworkCost',
      dar: 'Dar',
      codecName: 'CodecName',
      width: 'Width',
      duration: 'Duration',
      fps: 'Fps',
      codecTag: 'CodecTag',
      codecTimeBase: 'CodecTimeBase',
      level: 'Level',
    };
  }

  static types(): { [key: string]: any } {
    return {
      index: 'string',
      timebase: 'string',
      avgFPS: 'string',
      pixFmt: 'string',
      sar: 'string',
      lang: 'string',
      codecLongName: 'string',
      height: 'string',
      numFrames: 'string',
      bitrate: 'string',
      codecTagString: 'string',
      hasBFrames: 'string',
      profile: 'string',
      startTime: 'string',
      networkCost: SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost,
      dar: 'string',
      codecName: 'string',
      width: 'string',
      duration: 'string',
      fps: 'string',
      codecTag: 'string',
      codecTimeBase: 'string',
      level: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamList extends $tea.Model {
  videoStream?: SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamListVideoStream[];
  static names(): { [key: string]: string } {
    return {
      videoStream: 'VideoStream',
    };
  }

  static types(): { [key: string]: any } {
    return {
      videoStream: { 'type': 'array', 'itemType': SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamListVideoStream },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsAudioStreamListAudioStream extends $tea.Model {
  timebase?: string;
  index?: string;
  sampleFmt?: string;
  channelLayout?: string;
  lang?: string;
  samplerate?: string;
  codecLongName?: string;
  channels?: string;
  numFrames?: string;
  bitrate?: string;
  codecTagString?: string;
  startTime?: string;
  codecName?: string;
  duration?: string;
  codecTag?: string;
  codecTimeBase?: string;
  static names(): { [key: string]: string } {
    return {
      timebase: 'Timebase',
      index: 'Index',
      sampleFmt: 'SampleFmt',
      channelLayout: 'ChannelLayout',
      lang: 'Lang',
      samplerate: 'Samplerate',
      codecLongName: 'CodecLongName',
      channels: 'Channels',
      numFrames: 'NumFrames',
      bitrate: 'Bitrate',
      codecTagString: 'CodecTagString',
      startTime: 'StartTime',
      codecName: 'CodecName',
      duration: 'Duration',
      codecTag: 'CodecTag',
      codecTimeBase: 'CodecTimeBase',
    };
  }

  static types(): { [key: string]: any } {
    return {
      timebase: 'string',
      index: 'string',
      sampleFmt: 'string',
      channelLayout: 'string',
      lang: 'string',
      samplerate: 'string',
      codecLongName: 'string',
      channels: 'string',
      numFrames: 'string',
      bitrate: 'string',
      codecTagString: 'string',
      startTime: 'string',
      codecName: 'string',
      duration: 'string',
      codecTag: 'string',
      codecTimeBase: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsAudioStreamList extends $tea.Model {
  audioStream?: SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsAudioStreamListAudioStream[];
  static names(): { [key: string]: string } {
    return {
      audioStream: 'AudioStream',
    };
  }

  static types(): { [key: string]: any } {
    return {
      audioStream: { 'type': 'array', 'itemType': SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsAudioStreamListAudioStream },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream extends $tea.Model {
  index?: string;
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      index: 'Index',
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      index: 'string',
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsSubtitleStreamList extends $tea.Model {
  subtitleStream?: SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream[];
  static names(): { [key: string]: string } {
    return {
      subtitleStream: 'SubtitleStream',
    };
  }

  static types(): { [key: string]: any } {
    return {
      subtitleStream: { 'type': 'array', 'itemType': SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreams extends $tea.Model {
  videoStreamList?: SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamList;
  audioStreamList?: SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsAudioStreamList;
  subtitleStreamList?: SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsSubtitleStreamList;
  static names(): { [key: string]: string } {
    return {
      videoStreamList: 'VideoStreamList',
      audioStreamList: 'AudioStreamList',
      subtitleStreamList: 'SubtitleStreamList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      videoStreamList: SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamList,
      audioStreamList: SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsAudioStreamList,
      subtitleStreamList: SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsSubtitleStreamList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesFormat extends $tea.Model {
  startTime?: string;
  numPrograms?: string;
  size?: string;
  numStreams?: string;
  formatLongName?: string;
  duration?: string;
  bitrate?: string;
  formatName?: string;
  static names(): { [key: string]: string } {
    return {
      startTime: 'StartTime',
      numPrograms: 'NumPrograms',
      size: 'Size',
      numStreams: 'NumStreams',
      formatLongName: 'FormatLongName',
      duration: 'Duration',
      bitrate: 'Bitrate',
      formatName: 'FormatName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      startTime: 'string',
      numPrograms: 'string',
      size: 'string',
      numStreams: 'string',
      formatLongName: 'string',
      duration: 'string',
      bitrate: 'string',
      formatName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitJobsResponseBodyJobResultListJobResultJobOutputProperties extends $tea.Model {
  width?: string;
  height?: string;
  duration?: string;
  fps?: string;
  bitrate?: string;
  fileFormat?: string;
  streams?: SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreams;
  format?: SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesFormat;
  fileSize?: string;
  static names(): { [key: string]: string } {
    return {
      width: 'Width',
      height: 'Height',
      duration: 'Duration',
      fps: 'Fps',
      bitrate: 'Bitrate',
      fileFormat: 'FileFormat',
      streams: 'Streams',
      format: 'Format',
      fileSize: 'FileSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      width: 'string',
      height: 'string',
      duration: 'string',
      fps: 'string',
      bitrate: 'string',
      fileFormat: 'string',
      streams: SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreams,
      format: SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesFormat,
      fileSize: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitJobsResponseBodyJobResultListJobResultJobOutput extends $tea.Model {
  video?: SubmitJobsResponseBodyJobResultListJobResultJobOutputVideo;
  transConfig?: SubmitJobsResponseBodyJobResultListJobResultJobOutputTransConfig;
  encryption?: SubmitJobsResponseBodyJobResultListJobResultJobOutputEncryption;
  waterMarkList?: SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkList;
  waterMarkConfigUrl?: string;
  deWatermark?: string;
  m3U8NonStandardSupport?: SubmitJobsResponseBodyJobResultListJobResultJobOutputM3U8NonStandardSupport;
  priority?: string;
  audio?: SubmitJobsResponseBodyJobResultListJobResultJobOutputAudio;
  audioStreamMap?: string;
  mergeList?: SubmitJobsResponseBodyJobResultListJobResultJobOutputMergeList;
  superReso?: SubmitJobsResponseBodyJobResultListJobResultJobOutputSuperReso;
  userData?: string;
  outSubtitleList?: SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleList;
  digiWaterMark?: SubmitJobsResponseBodyJobResultListJobResultJobOutputDigiWaterMark;
  videoStreamMap?: string;
  outputFile?: SubmitJobsResponseBodyJobResultListJobResultJobOutputOutputFile;
  amixList?: SubmitJobsResponseBodyJobResultListJobResultJobOutputAmixList;
  rotate?: string;
  container?: SubmitJobsResponseBodyJobResultListJobResultJobOutputContainer;
  clip?: SubmitJobsResponseBodyJobResultListJobResultJobOutputClip;
  mergeConfigUrl?: string;
  openingList?: SubmitJobsResponseBodyJobResultListJobResultJobOutputOpeningList;
  muxConfig?: SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfig;
  tailSlateList?: SubmitJobsResponseBodyJobResultListJobResultJobOutputTailSlateList;
  templateId?: string;
  subtitleConfig?: SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfig;
  properties?: SubmitJobsResponseBodyJobResultListJobResultJobOutputProperties;
  static names(): { [key: string]: string } {
    return {
      video: 'Video',
      transConfig: 'TransConfig',
      encryption: 'Encryption',
      waterMarkList: 'WaterMarkList',
      waterMarkConfigUrl: 'WaterMarkConfigUrl',
      deWatermark: 'DeWatermark',
      m3U8NonStandardSupport: 'M3U8NonStandardSupport',
      priority: 'Priority',
      audio: 'Audio',
      audioStreamMap: 'AudioStreamMap',
      mergeList: 'MergeList',
      superReso: 'SuperReso',
      userData: 'UserData',
      outSubtitleList: 'OutSubtitleList',
      digiWaterMark: 'DigiWaterMark',
      videoStreamMap: 'VideoStreamMap',
      outputFile: 'OutputFile',
      amixList: 'AmixList',
      rotate: 'Rotate',
      container: 'Container',
      clip: 'Clip',
      mergeConfigUrl: 'MergeConfigUrl',
      openingList: 'OpeningList',
      muxConfig: 'MuxConfig',
      tailSlateList: 'TailSlateList',
      templateId: 'TemplateId',
      subtitleConfig: 'SubtitleConfig',
      properties: 'Properties',
    };
  }

  static types(): { [key: string]: any } {
    return {
      video: SubmitJobsResponseBodyJobResultListJobResultJobOutputVideo,
      transConfig: SubmitJobsResponseBodyJobResultListJobResultJobOutputTransConfig,
      encryption: SubmitJobsResponseBodyJobResultListJobResultJobOutputEncryption,
      waterMarkList: SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkList,
      waterMarkConfigUrl: 'string',
      deWatermark: 'string',
      m3U8NonStandardSupport: SubmitJobsResponseBodyJobResultListJobResultJobOutputM3U8NonStandardSupport,
      priority: 'string',
      audio: SubmitJobsResponseBodyJobResultListJobResultJobOutputAudio,
      audioStreamMap: 'string',
      mergeList: SubmitJobsResponseBodyJobResultListJobResultJobOutputMergeList,
      superReso: SubmitJobsResponseBodyJobResultListJobResultJobOutputSuperReso,
      userData: 'string',
      outSubtitleList: SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleList,
      digiWaterMark: SubmitJobsResponseBodyJobResultListJobResultJobOutputDigiWaterMark,
      videoStreamMap: 'string',
      outputFile: SubmitJobsResponseBodyJobResultListJobResultJobOutputOutputFile,
      amixList: SubmitJobsResponseBodyJobResultListJobResultJobOutputAmixList,
      rotate: 'string',
      container: SubmitJobsResponseBodyJobResultListJobResultJobOutputContainer,
      clip: SubmitJobsResponseBodyJobResultListJobResultJobOutputClip,
      mergeConfigUrl: 'string',
      openingList: SubmitJobsResponseBodyJobResultListJobResultJobOutputOpeningList,
      muxConfig: SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfig,
      tailSlateList: SubmitJobsResponseBodyJobResultListJobResultJobOutputTailSlateList,
      templateId: 'string',
      subtitleConfig: SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfig,
      properties: SubmitJobsResponseBodyJobResultListJobResultJobOutputProperties,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitJobsResponseBodyJobResultListJobResultJobInput extends $tea.Model {
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitJobsResponseBodyJobResultListJobResultJobMNSMessageResult extends $tea.Model {
  messageId?: string;
  errorMessage?: string;
  errorCode?: string;
  static names(): { [key: string]: string } {
    return {
      messageId: 'MessageId',
      errorMessage: 'ErrorMessage',
      errorCode: 'ErrorCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      messageId: 'string',
      errorMessage: 'string',
      errorCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitJobsResponseBodyJobResultListJobResultJob extends $tea.Model {
  creationTime?: string;
  percent?: number;
  finishTime?: string;
  state?: string;
  jobId?: string;
  code?: string;
  message?: string;
  output?: SubmitJobsResponseBodyJobResultListJobResultJobOutput;
  pipelineId?: string;
  input?: SubmitJobsResponseBodyJobResultListJobResultJobInput;
  MNSMessageResult?: SubmitJobsResponseBodyJobResultListJobResultJobMNSMessageResult;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      percent: 'Percent',
      finishTime: 'FinishTime',
      state: 'State',
      jobId: 'JobId',
      code: 'Code',
      message: 'Message',
      output: 'Output',
      pipelineId: 'PipelineId',
      input: 'Input',
      MNSMessageResult: 'MNSMessageResult',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      percent: 'number',
      finishTime: 'string',
      state: 'string',
      jobId: 'string',
      code: 'string',
      message: 'string',
      output: SubmitJobsResponseBodyJobResultListJobResultJobOutput,
      pipelineId: 'string',
      input: SubmitJobsResponseBodyJobResultListJobResultJobInput,
      MNSMessageResult: SubmitJobsResponseBodyJobResultListJobResultJobMNSMessageResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitJobsResponseBodyJobResultListJobResult extends $tea.Model {
  job?: SubmitJobsResponseBodyJobResultListJobResultJob;
  success?: boolean;
  code?: string;
  message?: string;
  static names(): { [key: string]: string } {
    return {
      job: 'Job',
      success: 'Success',
      code: 'Code',
      message: 'Message',
    };
  }

  static types(): { [key: string]: any } {
    return {
      job: SubmitJobsResponseBodyJobResultListJobResultJob,
      success: 'boolean',
      code: 'string',
      message: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitJobsResponseBodyJobResultList extends $tea.Model {
  jobResult?: SubmitJobsResponseBodyJobResultListJobResult[];
  static names(): { [key: string]: string } {
    return {
      jobResult: 'JobResult',
    };
  }

  static types(): { [key: string]: any } {
    return {
      jobResult: { 'type': 'array', 'itemType': SubmitJobsResponseBodyJobResultListJobResult },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitMediaInfoJobResponseBodyMediaInfoJobInput extends $tea.Model {
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitMediaInfoJobResponseBodyMediaInfoJobMNSMessageResult extends $tea.Model {
  messageId?: string;
  errorMessage?: string;
  errorCode?: string;
  static names(): { [key: string]: string } {
    return {
      messageId: 'MessageId',
      errorMessage: 'ErrorMessage',
      errorCode: 'ErrorCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      messageId: 'string',
      errorMessage: 'string',
      errorCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost extends $tea.Model {
  preloadTime?: string;
  avgBitrate?: string;
  costBandwidth?: string;
  static names(): { [key: string]: string } {
    return {
      preloadTime: 'PreloadTime',
      avgBitrate: 'AvgBitrate',
      costBandwidth: 'CostBandwidth',
    };
  }

  static types(): { [key: string]: any } {
    return {
      preloadTime: 'string',
      avgBitrate: 'string',
      costBandwidth: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamListVideoStream extends $tea.Model {
  sar?: string;
  height?: string;
  codecTagString?: string;
  networkCost?: SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost;
  width?: string;
  index?: string;
  timebase?: string;
  avgFPS?: string;
  pixFmt?: string;
  lang?: string;
  codecLongName?: string;
  numFrames?: string;
  rotate?: string;
  bitrate?: string;
  hasBFrames?: string;
  profile?: string;
  startTime?: string;
  dar?: string;
  codecName?: string;
  duration?: string;
  fps?: string;
  codecTag?: string;
  codecTimeBase?: string;
  level?: string;
  static names(): { [key: string]: string } {
    return {
      sar: 'Sar',
      height: 'Height',
      codecTagString: 'CodecTagString',
      networkCost: 'NetworkCost',
      width: 'Width',
      index: 'Index',
      timebase: 'Timebase',
      avgFPS: 'AvgFPS',
      pixFmt: 'PixFmt',
      lang: 'Lang',
      codecLongName: 'CodecLongName',
      numFrames: 'NumFrames',
      rotate: 'Rotate',
      bitrate: 'Bitrate',
      hasBFrames: 'HasBFrames',
      profile: 'Profile',
      startTime: 'StartTime',
      dar: 'Dar',
      codecName: 'CodecName',
      duration: 'Duration',
      fps: 'Fps',
      codecTag: 'CodecTag',
      codecTimeBase: 'CodecTimeBase',
      level: 'Level',
    };
  }

  static types(): { [key: string]: any } {
    return {
      sar: 'string',
      height: 'string',
      codecTagString: 'string',
      networkCost: SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost,
      width: 'string',
      index: 'string',
      timebase: 'string',
      avgFPS: 'string',
      pixFmt: 'string',
      lang: 'string',
      codecLongName: 'string',
      numFrames: 'string',
      rotate: 'string',
      bitrate: 'string',
      hasBFrames: 'string',
      profile: 'string',
      startTime: 'string',
      dar: 'string',
      codecName: 'string',
      duration: 'string',
      fps: 'string',
      codecTag: 'string',
      codecTimeBase: 'string',
      level: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamList extends $tea.Model {
  videoStream?: SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamListVideoStream[];
  static names(): { [key: string]: string } {
    return {
      videoStream: 'VideoStream',
    };
  }

  static types(): { [key: string]: any } {
    return {
      videoStream: { 'type': 'array', 'itemType': SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamListVideoStream },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsAudioStreamListAudioStream extends $tea.Model {
  timebase?: string;
  index?: string;
  sampleFmt?: string;
  channelLayout?: string;
  lang?: string;
  samplerate?: string;
  codecLongName?: string;
  channels?: string;
  numFrames?: string;
  bitrate?: string;
  codecTagString?: string;
  startTime?: string;
  codecName?: string;
  duration?: string;
  codecTag?: string;
  codecTimeBase?: string;
  static names(): { [key: string]: string } {
    return {
      timebase: 'Timebase',
      index: 'Index',
      sampleFmt: 'SampleFmt',
      channelLayout: 'ChannelLayout',
      lang: 'Lang',
      samplerate: 'Samplerate',
      codecLongName: 'CodecLongName',
      channels: 'Channels',
      numFrames: 'NumFrames',
      bitrate: 'Bitrate',
      codecTagString: 'CodecTagString',
      startTime: 'StartTime',
      codecName: 'CodecName',
      duration: 'Duration',
      codecTag: 'CodecTag',
      codecTimeBase: 'CodecTimeBase',
    };
  }

  static types(): { [key: string]: any } {
    return {
      timebase: 'string',
      index: 'string',
      sampleFmt: 'string',
      channelLayout: 'string',
      lang: 'string',
      samplerate: 'string',
      codecLongName: 'string',
      channels: 'string',
      numFrames: 'string',
      bitrate: 'string',
      codecTagString: 'string',
      startTime: 'string',
      codecName: 'string',
      duration: 'string',
      codecTag: 'string',
      codecTimeBase: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsAudioStreamList extends $tea.Model {
  audioStream?: SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsAudioStreamListAudioStream[];
  static names(): { [key: string]: string } {
    return {
      audioStream: 'AudioStream',
    };
  }

  static types(): { [key: string]: any } {
    return {
      audioStream: { 'type': 'array', 'itemType': SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsAudioStreamListAudioStream },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsSubtitleStreamListSubtitleStream extends $tea.Model {
  timebase?: string;
  index?: string;
  startTime?: string;
  codecName?: string;
  lang?: string;
  codecLongName?: string;
  duration?: string;
  codecTag?: string;
  codecTimeBase?: string;
  codecTagString?: string;
  static names(): { [key: string]: string } {
    return {
      timebase: 'Timebase',
      index: 'Index',
      startTime: 'StartTime',
      codecName: 'CodecName',
      lang: 'Lang',
      codecLongName: 'CodecLongName',
      duration: 'Duration',
      codecTag: 'CodecTag',
      codecTimeBase: 'CodecTimeBase',
      codecTagString: 'CodecTagString',
    };
  }

  static types(): { [key: string]: any } {
    return {
      timebase: 'string',
      index: 'string',
      startTime: 'string',
      codecName: 'string',
      lang: 'string',
      codecLongName: 'string',
      duration: 'string',
      codecTag: 'string',
      codecTimeBase: 'string',
      codecTagString: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsSubtitleStreamList extends $tea.Model {
  subtitleStream?: SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsSubtitleStreamListSubtitleStream[];
  static names(): { [key: string]: string } {
    return {
      subtitleStream: 'SubtitleStream',
    };
  }

  static types(): { [key: string]: any } {
    return {
      subtitleStream: { 'type': 'array', 'itemType': SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsSubtitleStreamListSubtitleStream },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreams extends $tea.Model {
  videoStreamList?: SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamList;
  audioStreamList?: SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsAudioStreamList;
  subtitleStreamList?: SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsSubtitleStreamList;
  static names(): { [key: string]: string } {
    return {
      videoStreamList: 'VideoStreamList',
      audioStreamList: 'AudioStreamList',
      subtitleStreamList: 'SubtitleStreamList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      videoStreamList: SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamList,
      audioStreamList: SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsAudioStreamList,
      subtitleStreamList: SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsSubtitleStreamList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesFormat extends $tea.Model {
  startTime?: string;
  numPrograms?: string;
  size?: string;
  numStreams?: string;
  formatLongName?: string;
  duration?: string;
  bitrate?: string;
  formatName?: string;
  static names(): { [key: string]: string } {
    return {
      startTime: 'StartTime',
      numPrograms: 'NumPrograms',
      size: 'Size',
      numStreams: 'NumStreams',
      formatLongName: 'FormatLongName',
      duration: 'Duration',
      bitrate: 'Bitrate',
      formatName: 'FormatName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      startTime: 'string',
      numPrograms: 'string',
      size: 'string',
      numStreams: 'string',
      formatLongName: 'string',
      duration: 'string',
      bitrate: 'string',
      formatName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitMediaInfoJobResponseBodyMediaInfoJobProperties extends $tea.Model {
  width?: string;
  height?: string;
  duration?: string;
  fps?: string;
  bitrate?: string;
  fileFormat?: string;
  streams?: SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreams;
  format?: SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesFormat;
  fileSize?: string;
  static names(): { [key: string]: string } {
    return {
      width: 'Width',
      height: 'Height',
      duration: 'Duration',
      fps: 'Fps',
      bitrate: 'Bitrate',
      fileFormat: 'FileFormat',
      streams: 'Streams',
      format: 'Format',
      fileSize: 'FileSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      width: 'string',
      height: 'string',
      duration: 'string',
      fps: 'string',
      bitrate: 'string',
      fileFormat: 'string',
      streams: SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreams,
      format: SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesFormat,
      fileSize: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitMediaInfoJobResponseBodyMediaInfoJob extends $tea.Model {
  creationTime?: string;
  state?: string;
  jobId?: string;
  userData?: string;
  code?: string;
  message?: string;
  pipelineId?: string;
  async?: boolean;
  input?: SubmitMediaInfoJobResponseBodyMediaInfoJobInput;
  MNSMessageResult?: SubmitMediaInfoJobResponseBodyMediaInfoJobMNSMessageResult;
  properties?: SubmitMediaInfoJobResponseBodyMediaInfoJobProperties;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      state: 'State',
      jobId: 'JobId',
      userData: 'UserData',
      code: 'Code',
      message: 'Message',
      pipelineId: 'PipelineId',
      async: 'Async',
      input: 'Input',
      MNSMessageResult: 'MNSMessageResult',
      properties: 'Properties',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      state: 'string',
      jobId: 'string',
      userData: 'string',
      code: 'string',
      message: 'string',
      pipelineId: 'string',
      async: 'boolean',
      input: SubmitMediaInfoJobResponseBodyMediaInfoJobInput,
      MNSMessageResult: SubmitMediaInfoJobResponseBodyMediaInfoJobMNSMessageResult,
      properties: SubmitMediaInfoJobResponseBodyMediaInfoJobProperties,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigTileOut extends $tea.Model {
  padding?: string;
  color?: string;
  cellSelStep?: string;
  cellHeight?: string;
  cellWidth?: string;
  margin?: string;
  columns?: string;
  isKeepCellPic?: string;
  lines?: string;
  static names(): { [key: string]: string } {
    return {
      padding: 'Padding',
      color: 'Color',
      cellSelStep: 'CellSelStep',
      cellHeight: 'CellHeight',
      cellWidth: 'CellWidth',
      margin: 'Margin',
      columns: 'Columns',
      isKeepCellPic: 'IsKeepCellPic',
      lines: 'Lines',
    };
  }

  static types(): { [key: string]: any } {
    return {
      padding: 'string',
      color: 'string',
      cellSelStep: 'string',
      cellHeight: 'string',
      cellWidth: 'string',
      margin: 'string',
      columns: 'string',
      isKeepCellPic: 'string',
      lines: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigOutputFile extends $tea.Model {
  roleArn?: string;
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      roleArn: 'RoleArn',
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      roleArn: 'string',
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigTileOutputFile extends $tea.Model {
  roleArn?: string;
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      roleArn: 'RoleArn',
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      roleArn: 'string',
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfig extends $tea.Model {
  time?: string;
  tileOut?: SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigTileOut;
  interval?: string;
  frameType?: string;
  width?: string;
  height?: string;
  outputFile?: SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigOutputFile;
  num?: string;
  tileOutputFile?: SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigTileOutputFile;
  static names(): { [key: string]: string } {
    return {
      time: 'Time',
      tileOut: 'TileOut',
      interval: 'Interval',
      frameType: 'FrameType',
      width: 'Width',
      height: 'Height',
      outputFile: 'OutputFile',
      num: 'Num',
      tileOutputFile: 'TileOutputFile',
    };
  }

  static types(): { [key: string]: any } {
    return {
      time: 'string',
      tileOut: SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigTileOut,
      interval: 'string',
      frameType: 'string',
      width: 'string',
      height: 'string',
      outputFile: SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigOutputFile,
      num: 'string',
      tileOutputFile: SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigTileOutputFile,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitSnapshotJobResponseBodySnapshotJobMNSMessageResult extends $tea.Model {
  messageId?: string;
  errorMessage?: string;
  errorCode?: string;
  static names(): { [key: string]: string } {
    return {
      messageId: 'MessageId',
      errorMessage: 'ErrorMessage',
      errorCode: 'ErrorCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      messageId: 'string',
      errorMessage: 'string',
      errorCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitSnapshotJobResponseBodySnapshotJobInput extends $tea.Model {
  roleArn?: string;
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      roleArn: 'RoleArn',
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      roleArn: 'string',
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitSnapshotJobResponseBodySnapshotJob extends $tea.Model {
  creationTime?: string;
  snapshotConfig?: SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfig;
  state?: string;
  message?: string;
  MNSMessageResult?: SubmitSnapshotJobResponseBodySnapshotJobMNSMessageResult;
  input?: SubmitSnapshotJobResponseBodySnapshotJobInput;
  count?: string;
  tileCount?: string;
  userData?: string;
  code?: string;
  pipelineId?: string;
  id?: string;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      snapshotConfig: 'SnapshotConfig',
      state: 'State',
      message: 'Message',
      MNSMessageResult: 'MNSMessageResult',
      input: 'Input',
      count: 'Count',
      tileCount: 'TileCount',
      userData: 'UserData',
      code: 'Code',
      pipelineId: 'PipelineId',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      snapshotConfig: SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfig,
      state: 'string',
      message: 'string',
      MNSMessageResult: SubmitSnapshotJobResponseBodySnapshotJobMNSMessageResult,
      input: SubmitSnapshotJobResponseBodySnapshotJobInput,
      count: 'string',
      tileCount: 'string',
      userData: 'string',
      code: 'string',
      pipelineId: 'string',
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitSubtitleJobResponseBodySubtitleJob extends $tea.Model {
  jobId?: string;
  inputConfig?: string;
  userData?: string;
  state?: string;
  static names(): { [key: string]: string } {
    return {
      jobId: 'JobId',
      inputConfig: 'InputConfig',
      userData: 'UserData',
      state: 'State',
    };
  }

  static types(): { [key: string]: any } {
    return {
      jobId: 'string',
      inputConfig: 'string',
      userData: 'string',
      state: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitVideoPoseJobResponseBodyVideoPoseJobOutputConfigDataFile extends $tea.Model {
  roleArn?: string;
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      roleArn: 'RoleArn',
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      roleArn: 'string',
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitVideoPoseJobResponseBodyVideoPoseJobOutputConfigVideoFile extends $tea.Model {
  roleArn?: string;
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      roleArn: 'RoleArn',
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      roleArn: 'string',
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitVideoPoseJobResponseBodyVideoPoseJobOutputConfig extends $tea.Model {
  dataFile?: SubmitVideoPoseJobResponseBodyVideoPoseJobOutputConfigDataFile;
  videoFile?: SubmitVideoPoseJobResponseBodyVideoPoseJobOutputConfigVideoFile;
  static names(): { [key: string]: string } {
    return {
      dataFile: 'DataFile',
      videoFile: 'VideoFile',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataFile: SubmitVideoPoseJobResponseBodyVideoPoseJobOutputConfigDataFile,
      videoFile: SubmitVideoPoseJobResponseBodyVideoPoseJobOutputConfigVideoFile,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitVideoPoseJobResponseBodyVideoPoseJobMNSMessageResult extends $tea.Model {
  messageId?: string;
  errorMessage?: string;
  errorCode?: string;
  static names(): { [key: string]: string } {
    return {
      messageId: 'MessageId',
      errorMessage: 'ErrorMessage',
      errorCode: 'ErrorCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      messageId: 'string',
      errorMessage: 'string',
      errorCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitVideoPoseJobResponseBodyVideoPoseJobInput extends $tea.Model {
  roleArn?: string;
  object?: string;
  location?: string;
  bucket?: string;
  static names(): { [key: string]: string } {
    return {
      roleArn: 'RoleArn',
      object: 'Object',
      location: 'Location',
      bucket: 'Bucket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      roleArn: 'string',
      object: 'string',
      location: 'string',
      bucket: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost extends $tea.Model {
  preloadTime?: string;
  avgBitrate?: string;
  costBandwidth?: string;
  static names(): { [key: string]: string } {
    return {
      preloadTime: 'PreloadTime',
      avgBitrate: 'AvgBitrate',
      costBandwidth: 'CostBandwidth',
    };
  }

  static types(): { [key: string]: any } {
    return {
      preloadTime: 'string',
      avgBitrate: 'string',
      costBandwidth: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreamsVideoStreamListVideoStream extends $tea.Model {
  sar?: string;
  height?: string;
  codecTagString?: string;
  networkCost?: SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost;
  width?: string;
  index?: string;
  timebase?: string;
  avgFPS?: string;
  pixFmt?: string;
  lang?: string;
  codecLongName?: string;
  numFrames?: string;
  rotate?: string;
  bitrate?: string;
  hasBFrames?: string;
  profile?: string;
  startTime?: string;
  dar?: string;
  codecName?: string;
  duration?: string;
  fps?: string;
  codecTag?: string;
  codecTimeBase?: string;
  level?: string;
  static names(): { [key: string]: string } {
    return {
      sar: 'Sar',
      height: 'Height',
      codecTagString: 'CodecTagString',
      networkCost: 'NetworkCost',
      width: 'Width',
      index: 'Index',
      timebase: 'Timebase',
      avgFPS: 'AvgFPS',
      pixFmt: 'PixFmt',
      lang: 'Lang',
      codecLongName: 'CodecLongName',
      numFrames: 'NumFrames',
      rotate: 'Rotate',
      bitrate: 'Bitrate',
      hasBFrames: 'HasBFrames',
      profile: 'Profile',
      startTime: 'StartTime',
      dar: 'Dar',
      codecName: 'CodecName',
      duration: 'Duration',
      fps: 'Fps',
      codecTag: 'CodecTag',
      codecTimeBase: 'CodecTimeBase',
      level: 'Level',
    };
  }

  static types(): { [key: string]: any } {
    return {
      sar: 'string',
      height: 'string',
      codecTagString: 'string',
      networkCost: SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost,
      width: 'string',
      index: 'string',
      timebase: 'string',
      avgFPS: 'string',
      pixFmt: 'string',
      lang: 'string',
      codecLongName: 'string',
      numFrames: 'string',
      rotate: 'string',
      bitrate: 'string',
      hasBFrames: 'string',
      profile: 'string',
      startTime: 'string',
      dar: 'string',
      codecName: 'string',
      duration: 'string',
      fps: 'string',
      codecTag: 'string',
      codecTimeBase: 'string',
      level: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreamsVideoStreamList extends $tea.Model {
  videoStream?: SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreamsVideoStreamListVideoStream[];
  static names(): { [key: string]: string } {
    return {
      videoStream: 'VideoStream',
    };
  }

  static types(): { [key: string]: any } {
    return {
      videoStream: { 'type': 'array', 'itemType': SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreamsVideoStreamListVideoStream },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreamsAudioStreamListAudioStream extends $tea.Model {
  timebase?: string;
  index?: string;
  sampleFmt?: string;
  channelLayout?: string;
  lang?: string;
  samplerate?: string;
  codecLongName?: string;
  channels?: string;
  numFrames?: string;
  bitrate?: string;
  codecTagString?: string;
  startTime?: string;
  codecName?: string;
  duration?: string;
  codecTag?: string;
  codecTimeBase?: string;
  static names(): { [key: string]: string } {
    return {
      timebase: 'Timebase',
      index: 'Index',
      sampleFmt: 'SampleFmt',
      channelLayout: 'ChannelLayout',
      lang: 'Lang',
      samplerate: 'Samplerate',
      codecLongName: 'CodecLongName',
      channels: 'Channels',
      numFrames: 'NumFrames',
      bitrate: 'Bitrate',
      codecTagString: 'CodecTagString',
      startTime: 'StartTime',
      codecName: 'CodecName',
      duration: 'Duration',
      codecTag: 'CodecTag',
      codecTimeBase: 'CodecTimeBase',
    };
  }

  static types(): { [key: string]: any } {
    return {
      timebase: 'string',
      index: 'string',
      sampleFmt: 'string',
      channelLayout: 'string',
      lang: 'string',
      samplerate: 'string',
      codecLongName: 'string',
      channels: 'string',
      numFrames: 'string',
      bitrate: 'string',
      codecTagString: 'string',
      startTime: 'string',
      codecName: 'string',
      duration: 'string',
      codecTag: 'string',
      codecTimeBase: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreamsAudioStreamList extends $tea.Model {
  audioStream?: SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreamsAudioStreamListAudioStream[];
  static names(): { [key: string]: string } {
    return {
      audioStream: 'AudioStream',
    };
  }

  static types(): { [key: string]: any } {
    return {
      audioStream: { 'type': 'array', 'itemType': SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreamsAudioStreamListAudioStream },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreamsSubtitleStreamListSubtitleStream extends $tea.Model {
  timebase?: string;
  index?: string;
  startTime?: string;
  codecName?: string;
  lang?: string;
  codecLongName?: string;
  duration?: string;
  codecTag?: string;
  codecTimeBase?: string;
  codecTagString?: string;
  static names(): { [key: string]: string } {
    return {
      timebase: 'Timebase',
      index: 'Index',
      startTime: 'StartTime',
      codecName: 'CodecName',
      lang: 'Lang',
      codecLongName: 'CodecLongName',
      duration: 'Duration',
      codecTag: 'CodecTag',
      codecTimeBase: 'CodecTimeBase',
      codecTagString: 'CodecTagString',
    };
  }

  static types(): { [key: string]: any } {
    return {
      timebase: 'string',
      index: 'string',
      startTime: 'string',
      codecName: 'string',
      lang: 'string',
      codecLongName: 'string',
      duration: 'string',
      codecTag: 'string',
      codecTimeBase: 'string',
      codecTagString: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreamsSubtitleStreamList extends $tea.Model {
  subtitleStream?: SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreamsSubtitleStreamListSubtitleStream[];
  static names(): { [key: string]: string } {
    return {
      subtitleStream: 'SubtitleStream',
    };
  }

  static types(): { [key: string]: any } {
    return {
      subtitleStream: { 'type': 'array', 'itemType': SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreamsSubtitleStreamListSubtitleStream },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreams extends $tea.Model {
  videoStreamList?: SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreamsVideoStreamList;
  audioStreamList?: SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreamsAudioStreamList;
  subtitleStreamList?: SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreamsSubtitleStreamList;
  static names(): { [key: string]: string } {
    return {
      videoStreamList: 'VideoStreamList',
      audioStreamList: 'AudioStreamList',
      subtitleStreamList: 'SubtitleStreamList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      videoStreamList: SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreamsVideoStreamList,
      audioStreamList: SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreamsAudioStreamList,
      subtitleStreamList: SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreamsSubtitleStreamList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesFormat extends $tea.Model {
  startTime?: string;
  numPrograms?: string;
  size?: string;
  numStreams?: string;
  formatLongName?: string;
  duration?: string;
  bitrate?: string;
  formatName?: string;
  static names(): { [key: string]: string } {
    return {
      startTime: 'StartTime',
      numPrograms: 'NumPrograms',
      size: 'Size',
      numStreams: 'NumStreams',
      formatLongName: 'FormatLongName',
      duration: 'Duration',
      bitrate: 'Bitrate',
      formatName: 'FormatName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      startTime: 'string',
      numPrograms: 'string',
      size: 'string',
      numStreams: 'string',
      formatLongName: 'string',
      duration: 'string',
      bitrate: 'string',
      formatName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitVideoPoseJobResponseBodyVideoPoseJobProperties extends $tea.Model {
  width?: string;
  height?: string;
  duration?: string;
  fps?: string;
  bitrate?: string;
  fileFormat?: string;
  streams?: SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreams;
  format?: SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesFormat;
  fileSize?: string;
  static names(): { [key: string]: string } {
    return {
      width: 'Width',
      height: 'Height',
      duration: 'Duration',
      fps: 'Fps',
      bitrate: 'Bitrate',
      fileFormat: 'FileFormat',
      streams: 'Streams',
      format: 'Format',
      fileSize: 'FileSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      width: 'string',
      height: 'string',
      duration: 'string',
      fps: 'string',
      bitrate: 'string',
      fileFormat: 'string',
      streams: SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesStreams,
      format: SubmitVideoPoseJobResponseBodyVideoPoseJobPropertiesFormat,
      fileSize: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitVideoPoseJobResponseBodyVideoPoseJob extends $tea.Model {
  outputConfig?: SubmitVideoPoseJobResponseBodyVideoPoseJobOutputConfig;
  state?: string;
  jobId?: string;
  userData?: string;
  pipelineId?: string;
  MNSMessageResult?: SubmitVideoPoseJobResponseBodyVideoPoseJobMNSMessageResult;
  input?: SubmitVideoPoseJobResponseBodyVideoPoseJobInput;
  properties?: SubmitVideoPoseJobResponseBodyVideoPoseJobProperties;
  static names(): { [key: string]: string } {
    return {
      outputConfig: 'OutputConfig',
      state: 'State',
      jobId: 'JobId',
      userData: 'UserData',
      pipelineId: 'PipelineId',
      MNSMessageResult: 'MNSMessageResult',
      input: 'Input',
      properties: 'Properties',
    };
  }

  static types(): { [key: string]: any } {
    return {
      outputConfig: SubmitVideoPoseJobResponseBodyVideoPoseJobOutputConfig,
      state: 'string',
      jobId: 'string',
      userData: 'string',
      pipelineId: 'string',
      MNSMessageResult: SubmitVideoPoseJobResponseBodyVideoPoseJobMNSMessageResult,
      input: SubmitVideoPoseJobResponseBodyVideoPoseJobInput,
      properties: SubmitVideoPoseJobResponseBodyVideoPoseJobProperties,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateAsrPipelineResponseBodyPipelineNotifyConfig extends $tea.Model {
  queueName?: string;
  topic?: string;
  static names(): { [key: string]: string } {
    return {
      queueName: 'QueueName',
      topic: 'Topic',
    };
  }

  static types(): { [key: string]: any } {
    return {
      queueName: 'string',
      topic: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateAsrPipelineResponseBodyPipeline extends $tea.Model {
  state?: string;
  notifyConfig?: UpdateAsrPipelineResponseBodyPipelineNotifyConfig;
  priority?: number;
  name?: string;
  id?: string;
  static names(): { [key: string]: string } {
    return {
      state: 'State',
      notifyConfig: 'NotifyConfig',
      priority: 'Priority',
      name: 'Name',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      state: 'string',
      notifyConfig: UpdateAsrPipelineResponseBodyPipelineNotifyConfig,
      priority: 'number',
      name: 'string',
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCensorPipelineResponseBodyPipelineNotifyConfig extends $tea.Model {
  topic?: string;
  queue?: string;
  static names(): { [key: string]: string } {
    return {
      topic: 'Topic',
      queue: 'Queue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      topic: 'string',
      queue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCensorPipelineResponseBodyPipeline extends $tea.Model {
  state?: string;
  notifyConfig?: UpdateCensorPipelineResponseBodyPipelineNotifyConfig;
  priority?: number;
  name?: string;
  id?: string;
  static names(): { [key: string]: string } {
    return {
      state: 'State',
      notifyConfig: 'NotifyConfig',
      priority: 'Priority',
      name: 'Name',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      state: 'string',
      notifyConfig: UpdateCensorPipelineResponseBodyPipelineNotifyConfig,
      priority: 'number',
      name: 'string',
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCoverPipelineResponseBodyPipelineNotifyConfig extends $tea.Model {
  topic?: string;
  queue?: string;
  static names(): { [key: string]: string } {
    return {
      topic: 'Topic',
      queue: 'Queue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      topic: 'string',
      queue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCoverPipelineResponseBodyPipeline extends $tea.Model {
  state?: string;
  notifyConfig?: UpdateCoverPipelineResponseBodyPipelineNotifyConfig;
  priority?: number;
  role?: string;
  name?: string;
  id?: string;
  static names(): { [key: string]: string } {
    return {
      state: 'State',
      notifyConfig: 'NotifyConfig',
      priority: 'Priority',
      role: 'Role',
      name: 'Name',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      state: 'string',
      notifyConfig: UpdateCoverPipelineResponseBodyPipelineNotifyConfig,
      priority: 'number',
      role: 'string',
      name: 'string',
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMCTemplateResponseBodyTemplate extends $tea.Model {
  logo?: string;
  abuse?: string;
  state?: string;
  terrorism?: string;
  politics?: string;
  qrcode?: string;
  live?: string;
  spam?: string;
  contraband?: string;
  ad?: string;
  porn?: string;
  name?: string;
  templateId?: string;
  static names(): { [key: string]: string } {
    return {
      logo: 'Logo',
      abuse: 'Abuse',
      state: 'State',
      terrorism: 'Terrorism',
      politics: 'Politics',
      qrcode: 'Qrcode',
      live: 'Live',
      spam: 'Spam',
      contraband: 'Contraband',
      ad: 'Ad',
      porn: 'Porn',
      name: 'Name',
      templateId: 'TemplateId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      logo: 'string',
      abuse: 'string',
      state: 'string',
      terrorism: 'string',
      politics: 'string',
      qrcode: 'string',
      live: 'string',
      spam: 'string',
      contraband: 'string',
      ad: 'string',
      porn: 'string',
      name: 'string',
      templateId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMediaResponseBodyMediaTags extends $tea.Model {
  tag?: string[];
  static names(): { [key: string]: string } {
    return {
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tag: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMediaResponseBodyMediaFile extends $tea.Model {
  state?: string;
  URL?: string;
  static names(): { [key: string]: string } {
    return {
      state: 'State',
      URL: 'URL',
    };
  }

  static types(): { [key: string]: any } {
    return {
      state: 'string',
      URL: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMediaResponseBodyMediaRunIdList extends $tea.Model {
  runId?: string[];
  static names(): { [key: string]: string } {
    return {
      runId: 'RunId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      runId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMediaResponseBodyMedia extends $tea.Model {
  creationTime?: string;
  cateId?: number;
  height?: string;
  censorState?: string;
  tags?: UpdateMediaResponseBodyMediaTags;
  bitrate?: string;
  mediaId?: string;
  file?: UpdateMediaResponseBodyMediaFile;
  publishState?: string;
  description?: string;
  width?: string;
  size?: string;
  coverURL?: string;
  runIdList?: UpdateMediaResponseBodyMediaRunIdList;
  duration?: string;
  fps?: string;
  title?: string;
  format?: string;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      cateId: 'CateId',
      height: 'Height',
      censorState: 'CensorState',
      tags: 'Tags',
      bitrate: 'Bitrate',
      mediaId: 'MediaId',
      file: 'File',
      publishState: 'PublishState',
      description: 'Description',
      width: 'Width',
      size: 'Size',
      coverURL: 'CoverURL',
      runIdList: 'RunIdList',
      duration: 'Duration',
      fps: 'Fps',
      title: 'Title',
      format: 'Format',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      cateId: 'number',
      height: 'string',
      censorState: 'string',
      tags: UpdateMediaResponseBodyMediaTags,
      bitrate: 'string',
      mediaId: 'string',
      file: UpdateMediaResponseBodyMediaFile,
      publishState: 'string',
      description: 'string',
      width: 'string',
      size: 'string',
      coverURL: 'string',
      runIdList: UpdateMediaResponseBodyMediaRunIdList,
      duration: 'string',
      fps: 'string',
      title: 'string',
      format: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMediaWorkflowResponseBodyMediaWorkflow extends $tea.Model {
  creationTime?: string;
  mediaWorkflowId?: string;
  state?: string;
  triggerMode?: string;
  name?: string;
  topology?: string;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      mediaWorkflowId: 'MediaWorkflowId',
      state: 'State',
      triggerMode: 'TriggerMode',
      name: 'Name',
      topology: 'Topology',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      mediaWorkflowId: 'string',
      state: 'string',
      triggerMode: 'string',
      name: 'string',
      topology: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMediaWorkflowTriggerModeResponseBodyMediaWorkflow extends $tea.Model {
  creationTime?: string;
  mediaWorkflowId?: string;
  state?: string;
  triggerMode?: string;
  name?: string;
  topology?: string;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      mediaWorkflowId: 'MediaWorkflowId',
      state: 'State',
      triggerMode: 'TriggerMode',
      name: 'Name',
      topology: 'Topology',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      mediaWorkflowId: 'string',
      state: 'string',
      triggerMode: 'string',
      name: 'string',
      topology: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePipelineResponseBodyPipelineNotifyConfig extends $tea.Model {
  mqTopic?: string;
  queueName?: string;
  mqTag?: string;
  topic?: string;
  static names(): { [key: string]: string } {
    return {
      mqTopic: 'MqTopic',
      queueName: 'QueueName',
      mqTag: 'MqTag',
      topic: 'Topic',
    };
  }

  static types(): { [key: string]: any } {
    return {
      mqTopic: 'string',
      queueName: 'string',
      mqTag: 'string',
      topic: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePipelineResponseBodyPipeline extends $tea.Model {
  speed?: string;
  state?: string;
  notifyConfig?: UpdatePipelineResponseBodyPipelineNotifyConfig;
  name?: string;
  role?: string;
  id?: string;
  quotaAllocate?: number;
  static names(): { [key: string]: string } {
    return {
      speed: 'Speed',
      state: 'State',
      notifyConfig: 'NotifyConfig',
      name: 'Name',
      role: 'Role',
      id: 'Id',
      quotaAllocate: 'QuotaAllocate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      speed: 'string',
      state: 'string',
      notifyConfig: UpdatePipelineResponseBodyPipelineNotifyConfig,
      name: 'string',
      role: 'string',
      id: 'string',
      quotaAllocate: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePornPipelineResponseBodyPipelineNotifyConfig extends $tea.Model {
  topic?: string;
  queue?: string;
  static names(): { [key: string]: string } {
    return {
      topic: 'Topic',
      queue: 'Queue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      topic: 'string',
      queue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePornPipelineResponseBodyPipeline extends $tea.Model {
  state?: string;
  notifyConfig?: UpdatePornPipelineResponseBodyPipelineNotifyConfig;
  priority?: number;
  name?: string;
  id?: string;
  static names(): { [key: string]: string } {
    return {
      state: 'State',
      notifyConfig: 'NotifyConfig',
      priority: 'Priority',
      name: 'Name',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      state: 'string',
      notifyConfig: UpdatePornPipelineResponseBodyPipelineNotifyConfig,
      priority: 'number',
      name: 'string',
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTemplateResponseBodyTemplateVideoBitrateBnd extends $tea.Model {
  max?: string;
  min?: string;
  static names(): { [key: string]: string } {
    return {
      max: 'Max',
      min: 'Min',
    };
  }

  static types(): { [key: string]: any } {
    return {
      max: 'string',
      min: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTemplateResponseBodyTemplateVideo extends $tea.Model {
  longShortMode?: string;
  bufsize?: string;
  degrain?: string;
  bitrateBnd?: UpdateTemplateResponseBodyTemplateVideoBitrateBnd;
  pixFmt?: string;
  pad?: string;
  codec?: string;
  height?: string;
  qscale?: string;
  crop?: string;
  bitrate?: string;
  maxrate?: string;
  maxFps?: string;
  profile?: string;
  crf?: string;
  remove?: string;
  gop?: string;
  width?: string;
  fps?: string;
  preset?: string;
  scanMode?: string;
  resoPriority?: string;
  static names(): { [key: string]: string } {
    return {
      longShortMode: 'LongShortMode',
      bufsize: 'Bufsize',
      degrain: 'Degrain',
      bitrateBnd: 'BitrateBnd',
      pixFmt: 'PixFmt',
      pad: 'Pad',
      codec: 'Codec',
      height: 'Height',
      qscale: 'Qscale',
      crop: 'Crop',
      bitrate: 'Bitrate',
      maxrate: 'Maxrate',
      maxFps: 'MaxFps',
      profile: 'Profile',
      crf: 'Crf',
      remove: 'Remove',
      gop: 'Gop',
      width: 'Width',
      fps: 'Fps',
      preset: 'Preset',
      scanMode: 'ScanMode',
      resoPriority: 'ResoPriority',
    };
  }

  static types(): { [key: string]: any } {
    return {
      longShortMode: 'string',
      bufsize: 'string',
      degrain: 'string',
      bitrateBnd: UpdateTemplateResponseBodyTemplateVideoBitrateBnd,
      pixFmt: 'string',
      pad: 'string',
      codec: 'string',
      height: 'string',
      qscale: 'string',
      crop: 'string',
      bitrate: 'string',
      maxrate: 'string',
      maxFps: 'string',
      profile: 'string',
      crf: 'string',
      remove: 'string',
      gop: 'string',
      width: 'string',
      fps: 'string',
      preset: 'string',
      scanMode: 'string',
      resoPriority: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTemplateResponseBodyTemplateTransConfig extends $tea.Model {
  isCheckAudioBitrate?: string;
  transMode?: string;
  isCheckReso?: string;
  isCheckVideoBitrateFail?: string;
  adjDarMethod?: string;
  isCheckVideoBitrate?: string;
  isCheckResoFail?: string;
  isCheckAudioBitrateFail?: string;
  static names(): { [key: string]: string } {
    return {
      isCheckAudioBitrate: 'IsCheckAudioBitrate',
      transMode: 'TransMode',
      isCheckReso: 'IsCheckReso',
      isCheckVideoBitrateFail: 'IsCheckVideoBitrateFail',
      adjDarMethod: 'AdjDarMethod',
      isCheckVideoBitrate: 'IsCheckVideoBitrate',
      isCheckResoFail: 'IsCheckResoFail',
      isCheckAudioBitrateFail: 'IsCheckAudioBitrateFail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isCheckAudioBitrate: 'string',
      transMode: 'string',
      isCheckReso: 'string',
      isCheckVideoBitrateFail: 'string',
      adjDarMethod: 'string',
      isCheckVideoBitrate: 'string',
      isCheckResoFail: 'string',
      isCheckAudioBitrateFail: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTemplateResponseBodyTemplateMuxConfigWebp extends $tea.Model {
  loop?: string;
  static names(): { [key: string]: string } {
    return {
      loop: 'Loop',
    };
  }

  static types(): { [key: string]: any } {
    return {
      loop: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTemplateResponseBodyTemplateMuxConfigGif extends $tea.Model {
  finalDelay?: string;
  ditherMode?: string;
  loop?: string;
  isCustomPalette?: string;
  static names(): { [key: string]: string } {
    return {
      finalDelay: 'FinalDelay',
      ditherMode: 'DitherMode',
      loop: 'Loop',
      isCustomPalette: 'IsCustomPalette',
    };
  }

  static types(): { [key: string]: any } {
    return {
      finalDelay: 'string',
      ditherMode: 'string',
      loop: 'string',
      isCustomPalette: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTemplateResponseBodyTemplateMuxConfigSegment extends $tea.Model {
  duration?: string;
  static names(): { [key: string]: string } {
    return {
      duration: 'Duration',
    };
  }

  static types(): { [key: string]: any } {
    return {
      duration: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTemplateResponseBodyTemplateMuxConfig extends $tea.Model {
  webp?: UpdateTemplateResponseBodyTemplateMuxConfigWebp;
  gif?: UpdateTemplateResponseBodyTemplateMuxConfigGif;
  segment?: UpdateTemplateResponseBodyTemplateMuxConfigSegment;
  static names(): { [key: string]: string } {
    return {
      webp: 'Webp',
      gif: 'Gif',
      segment: 'Segment',
    };
  }

  static types(): { [key: string]: any } {
    return {
      webp: UpdateTemplateResponseBodyTemplateMuxConfigWebp,
      gif: UpdateTemplateResponseBodyTemplateMuxConfigGif,
      segment: UpdateTemplateResponseBodyTemplateMuxConfigSegment,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTemplateResponseBodyTemplateAudio extends $tea.Model {
  profile?: string;
  remove?: string;
  codec?: string;
  samplerate?: string;
  qscale?: string;
  channels?: string;
  bitrate?: string;
  static names(): { [key: string]: string } {
    return {
      profile: 'Profile',
      remove: 'Remove',
      codec: 'Codec',
      samplerate: 'Samplerate',
      qscale: 'Qscale',
      channels: 'Channels',
      bitrate: 'Bitrate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      profile: 'string',
      remove: 'string',
      codec: 'string',
      samplerate: 'string',
      qscale: 'string',
      channels: 'string',
      bitrate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTemplateResponseBodyTemplateContainer extends $tea.Model {
  format?: string;
  static names(): { [key: string]: string } {
    return {
      format: 'Format',
    };
  }

  static types(): { [key: string]: any } {
    return {
      format: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTemplateResponseBodyTemplate extends $tea.Model {
  video?: UpdateTemplateResponseBodyTemplateVideo;
  transConfig?: UpdateTemplateResponseBodyTemplateTransConfig;
  state?: string;
  muxConfig?: UpdateTemplateResponseBodyTemplateMuxConfig;
  name?: string;
  audio?: UpdateTemplateResponseBodyTemplateAudio;
  id?: string;
  container?: UpdateTemplateResponseBodyTemplateContainer;
  static names(): { [key: string]: string } {
    return {
      video: 'Video',
      transConfig: 'TransConfig',
      state: 'State',
      muxConfig: 'MuxConfig',
      name: 'Name',
      audio: 'Audio',
      id: 'Id',
      container: 'Container',
    };
  }

  static types(): { [key: string]: any } {
    return {
      video: UpdateTemplateResponseBodyTemplateVideo,
      transConfig: UpdateTemplateResponseBodyTemplateTransConfig,
      state: 'string',
      muxConfig: UpdateTemplateResponseBodyTemplateMuxConfig,
      name: 'string',
      audio: UpdateTemplateResponseBodyTemplateAudio,
      id: 'string',
      container: UpdateTemplateResponseBodyTemplateContainer,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTerrorismPipelineResponseBodyPipelineNotifyConfig extends $tea.Model {
  topic?: string;
  queue?: string;
  static names(): { [key: string]: string } {
    return {
      topic: 'Topic',
      queue: 'Queue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      topic: 'string',
      queue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTerrorismPipelineResponseBodyPipeline extends $tea.Model {
  state?: string;
  notifyConfig?: UpdateTerrorismPipelineResponseBodyPipelineNotifyConfig;
  priority?: number;
  name?: string;
  id?: string;
  static names(): { [key: string]: string } {
    return {
      state: 'State',
      notifyConfig: 'NotifyConfig',
      priority: 'Priority',
      name: 'Name',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      state: 'string',
      notifyConfig: UpdateTerrorismPipelineResponseBodyPipelineNotifyConfig,
      priority: 'number',
      name: 'string',
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWaterMarkTemplateResponseBodyWaterMarkTemplateRatioRefer extends $tea.Model {
  dx?: string;
  width?: string;
  height?: string;
  dy?: string;
  static names(): { [key: string]: string } {
    return {
      dx: 'Dx',
      width: 'Width',
      height: 'Height',
      dy: 'Dy',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dx: 'string',
      width: 'string',
      height: 'string',
      dy: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWaterMarkTemplateResponseBodyWaterMarkTemplateTimeline extends $tea.Model {
  start?: string;
  duration?: string;
  static names(): { [key: string]: string } {
    return {
      start: 'Start',
      duration: 'Duration',
    };
  }

  static types(): { [key: string]: any } {
    return {
      start: 'string',
      duration: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWaterMarkTemplateResponseBodyWaterMarkTemplate extends $tea.Model {
  type?: string;
  ratioRefer?: UpdateWaterMarkTemplateResponseBodyWaterMarkTemplateRatioRefer;
  referPos?: string;
  state?: string;
  dx?: string;
  width?: string;
  height?: string;
  timeline?: UpdateWaterMarkTemplateResponseBodyWaterMarkTemplateTimeline;
  name?: string;
  dy?: string;
  id?: string;
  static names(): { [key: string]: string } {
    return {
      type: 'Type',
      ratioRefer: 'RatioRefer',
      referPos: 'ReferPos',
      state: 'State',
      dx: 'Dx',
      width: 'Width',
      height: 'Height',
      timeline: 'Timeline',
      name: 'Name',
      dy: 'Dy',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      type: 'string',
      ratioRefer: UpdateWaterMarkTemplateResponseBodyWaterMarkTemplateRatioRefer,
      referPos: 'string',
      state: 'string',
      dx: 'string',
      width: 'string',
      height: 'string',
      timeline: UpdateWaterMarkTemplateResponseBodyWaterMarkTemplateTimeline,
      name: 'string',
      dy: 'string',
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}


export default class Client extends OpenApi {

  constructor(config: $OpenApi.Config) {
    super(config);
    this._endpointRule = "regional";
    this._endpointMap = {
      'ap-northeast-2-pop': "mts.ap-northeast-1.aliyuncs.com",
      'ap-southeast-2': "mts.ap-northeast-1.aliyuncs.com",
      'ap-southeast-3': "mts.ap-northeast-1.aliyuncs.com",
      'cn-beijing-finance-1': "mts.aliyuncs.com",
      'cn-beijing-finance-pop': "mts.aliyuncs.com",
      'cn-beijing-gov-1': "mts.aliyuncs.com",
      'cn-beijing-nu16-b01': "mts.aliyuncs.com",
      'cn-chengdu': "mts.aliyuncs.com",
      'cn-edge-1': "mts.aliyuncs.com",
      'cn-fujian': "mts.aliyuncs.com",
      'cn-haidian-cm12-c01': "mts.aliyuncs.com",
      'cn-hangzhou-bj-b01': "mts.aliyuncs.com",
      'cn-hangzhou-finance': "mts.aliyuncs.com",
      'cn-hangzhou-internal-prod-1': "mts.aliyuncs.com",
      'cn-hangzhou-internal-test-1': "mts.aliyuncs.com",
      'cn-hangzhou-internal-test-2': "mts.aliyuncs.com",
      'cn-hangzhou-internal-test-3': "mts.aliyuncs.com",
      'cn-hangzhou-test-306': "mts.aliyuncs.com",
      'cn-hongkong-finance-pop': "mts.aliyuncs.com",
      'cn-north-2-gov-1': "mts.aliyuncs.com",
      'cn-qingdao': "mts.aliyuncs.com",
      'cn-qingdao-nebula': "mts.aliyuncs.com",
      'cn-shanghai-et15-b01': "mts.aliyuncs.com",
      'cn-shanghai-et2-b01': "mts.aliyuncs.com",
      'cn-shanghai-finance-1': "mts.aliyuncs.com",
      'cn-shanghai-inner': "mts.aliyuncs.com",
      'cn-shanghai-internal-test-1': "mts.aliyuncs.com",
      'cn-shenzhen-finance-1': "mts.aliyuncs.com",
      'cn-shenzhen-inner': "mts.aliyuncs.com",
      'cn-shenzhen-st4-d01': "mts.aliyuncs.com",
      'cn-shenzhen-su18-b01': "mts.aliyuncs.com",
      'cn-wuhan': "mts.aliyuncs.com",
      'cn-yushanfang': "mts.aliyuncs.com",
      'cn-zhangbei-na61-b01': "mts.aliyuncs.com",
      'cn-zhangjiakou-na62-a01': "mts.aliyuncs.com",
      'cn-zhengzhou-nebula-1': "mts.aliyuncs.com",
      'eu-west-1-oxs': "mts.ap-northeast-1.aliyuncs.com",
      'me-east-1': "mts.ap-northeast-1.aliyuncs.com",
      'rus-west-1-pop': "mts.ap-northeast-1.aliyuncs.com",
      'us-east-1': "mts.ap-northeast-1.aliyuncs.com",
    };
    this.checkConfig(config);
    this._endpoint = this.getEndpoint("mts", this._regionId, this._endpointRule, this._network, this._suffix, this._endpointMap, this._endpoint);
  }


  getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: {[key: string ]: string}, endpoint: string): string {
    if (!Util.empty(endpoint)) {
      return endpoint;
    }

    if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
      return endpointMap[regionId];
    }

    return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
  }

  async activateMediaWorkflowWithOptions(request: ActivateMediaWorkflowRequest, runtime: $Util.RuntimeOptions): Promise<ActivateMediaWorkflowResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ActivateMediaWorkflowResponse>(await this.doRPCRequest("ActivateMediaWorkflow", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new ActivateMediaWorkflowResponse({}));
  }

  async activateMediaWorkflow(request: ActivateMediaWorkflowRequest): Promise<ActivateMediaWorkflowResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.activateMediaWorkflowWithOptions(request, runtime);
  }

  async addAsrPipelineWithOptions(request: AddAsrPipelineRequest, runtime: $Util.RuntimeOptions): Promise<AddAsrPipelineResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<AddAsrPipelineResponse>(await this.doRPCRequest("AddAsrPipeline", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new AddAsrPipelineResponse({}));
  }

  async addAsrPipeline(request: AddAsrPipelineRequest): Promise<AddAsrPipelineResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addAsrPipelineWithOptions(request, runtime);
  }

  async addCategoryWithOptions(request: AddCategoryRequest, runtime: $Util.RuntimeOptions): Promise<AddCategoryResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<AddCategoryResponse>(await this.doRPCRequest("AddCategory", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new AddCategoryResponse({}));
  }

  async addCategory(request: AddCategoryRequest): Promise<AddCategoryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addCategoryWithOptions(request, runtime);
  }

  async addCensorPipelineWithOptions(request: AddCensorPipelineRequest, runtime: $Util.RuntimeOptions): Promise<AddCensorPipelineResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<AddCensorPipelineResponse>(await this.doRPCRequest("AddCensorPipeline", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new AddCensorPipelineResponse({}));
  }

  async addCensorPipeline(request: AddCensorPipelineRequest): Promise<AddCensorPipelineResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addCensorPipelineWithOptions(request, runtime);
  }

  async addCoverPipelineWithOptions(request: AddCoverPipelineRequest, runtime: $Util.RuntimeOptions): Promise<AddCoverPipelineResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<AddCoverPipelineResponse>(await this.doRPCRequest("AddCoverPipeline", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new AddCoverPipelineResponse({}));
  }

  async addCoverPipeline(request: AddCoverPipelineRequest): Promise<AddCoverPipelineResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addCoverPipelineWithOptions(request, runtime);
  }

  async addMCTemplateWithOptions(request: AddMCTemplateRequest, runtime: $Util.RuntimeOptions): Promise<AddMCTemplateResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<AddMCTemplateResponse>(await this.doRPCRequest("AddMCTemplate", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new AddMCTemplateResponse({}));
  }

  async addMCTemplate(request: AddMCTemplateRequest): Promise<AddMCTemplateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addMCTemplateWithOptions(request, runtime);
  }

  async addMediaWithOptions(request: AddMediaRequest, runtime: $Util.RuntimeOptions): Promise<AddMediaResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<AddMediaResponse>(await this.doRPCRequest("AddMedia", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new AddMediaResponse({}));
  }

  async addMedia(request: AddMediaRequest): Promise<AddMediaResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addMediaWithOptions(request, runtime);
  }

  async addMediaTagWithOptions(request: AddMediaTagRequest, runtime: $Util.RuntimeOptions): Promise<AddMediaTagResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<AddMediaTagResponse>(await this.doRPCRequest("AddMediaTag", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new AddMediaTagResponse({}));
  }

  async addMediaTag(request: AddMediaTagRequest): Promise<AddMediaTagResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addMediaTagWithOptions(request, runtime);
  }

  async addMediaWorkflowWithOptions(request: AddMediaWorkflowRequest, runtime: $Util.RuntimeOptions): Promise<AddMediaWorkflowResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<AddMediaWorkflowResponse>(await this.doRPCRequest("AddMediaWorkflow", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new AddMediaWorkflowResponse({}));
  }

  async addMediaWorkflow(request: AddMediaWorkflowRequest): Promise<AddMediaWorkflowResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addMediaWorkflowWithOptions(request, runtime);
  }

  async addPipelineWithOptions(request: AddPipelineRequest, runtime: $Util.RuntimeOptions): Promise<AddPipelineResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<AddPipelineResponse>(await this.doRPCRequest("AddPipeline", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new AddPipelineResponse({}));
  }

  async addPipeline(request: AddPipelineRequest): Promise<AddPipelineResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addPipelineWithOptions(request, runtime);
  }

  async addPornPipelineWithOptions(request: AddPornPipelineRequest, runtime: $Util.RuntimeOptions): Promise<AddPornPipelineResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<AddPornPipelineResponse>(await this.doRPCRequest("AddPornPipeline", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new AddPornPipelineResponse({}));
  }

  async addPornPipeline(request: AddPornPipelineRequest): Promise<AddPornPipelineResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addPornPipelineWithOptions(request, runtime);
  }

  async addSmarttagTemplateWithOptions(request: AddSmarttagTemplateRequest, runtime: $Util.RuntimeOptions): Promise<AddSmarttagTemplateResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<AddSmarttagTemplateResponse>(await this.doRPCRequest("AddSmarttagTemplate", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new AddSmarttagTemplateResponse({}));
  }

  async addSmarttagTemplate(request: AddSmarttagTemplateRequest): Promise<AddSmarttagTemplateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addSmarttagTemplateWithOptions(request, runtime);
  }

  async addTemplateWithOptions(request: AddTemplateRequest, runtime: $Util.RuntimeOptions): Promise<AddTemplateResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<AddTemplateResponse>(await this.doRPCRequest("AddTemplate", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new AddTemplateResponse({}));
  }

  async addTemplate(request: AddTemplateRequest): Promise<AddTemplateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addTemplateWithOptions(request, runtime);
  }

  async addTerrorismPipelineWithOptions(request: AddTerrorismPipelineRequest, runtime: $Util.RuntimeOptions): Promise<AddTerrorismPipelineResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<AddTerrorismPipelineResponse>(await this.doRPCRequest("AddTerrorismPipeline", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new AddTerrorismPipelineResponse({}));
  }

  async addTerrorismPipeline(request: AddTerrorismPipelineRequest): Promise<AddTerrorismPipelineResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addTerrorismPipelineWithOptions(request, runtime);
  }

  async addWaterMarkTemplateWithOptions(request: AddWaterMarkTemplateRequest, runtime: $Util.RuntimeOptions): Promise<AddWaterMarkTemplateResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<AddWaterMarkTemplateResponse>(await this.doRPCRequest("AddWaterMarkTemplate", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new AddWaterMarkTemplateResponse({}));
  }

  async addWaterMarkTemplate(request: AddWaterMarkTemplateRequest): Promise<AddWaterMarkTemplateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addWaterMarkTemplateWithOptions(request, runtime);
  }

  async bindInputBucketWithOptions(request: BindInputBucketRequest, runtime: $Util.RuntimeOptions): Promise<BindInputBucketResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<BindInputBucketResponse>(await this.doRPCRequest("BindInputBucket", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new BindInputBucketResponse({}));
  }

  async bindInputBucket(request: BindInputBucketRequest): Promise<BindInputBucketResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.bindInputBucketWithOptions(request, runtime);
  }

  async bindOutputBucketWithOptions(request: BindOutputBucketRequest, runtime: $Util.RuntimeOptions): Promise<BindOutputBucketResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<BindOutputBucketResponse>(await this.doRPCRequest("BindOutputBucket", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new BindOutputBucketResponse({}));
  }

  async bindOutputBucket(request: BindOutputBucketRequest): Promise<BindOutputBucketResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.bindOutputBucketWithOptions(request, runtime);
  }

  async cancelJobWithOptions(request: CancelJobRequest, runtime: $Util.RuntimeOptions): Promise<CancelJobResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<CancelJobResponse>(await this.doRPCRequest("CancelJob", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new CancelJobResponse({}));
  }

  async cancelJob(request: CancelJobRequest): Promise<CancelJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.cancelJobWithOptions(request, runtime);
  }

  async categoryTreeWithOptions(request: CategoryTreeRequest, runtime: $Util.RuntimeOptions): Promise<CategoryTreeResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<CategoryTreeResponse>(await this.doRPCRequest("CategoryTree", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new CategoryTreeResponse({}));
  }

  async categoryTree(request: CategoryTreeRequest): Promise<CategoryTreeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.categoryTreeWithOptions(request, runtime);
  }

  async checkResourceWithOptions(request: CheckResourceRequest, runtime: $Util.RuntimeOptions): Promise<CheckResourceResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<CheckResourceResponse>(await this.doRPCRequest("CheckResource", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new CheckResourceResponse({}));
  }

  async checkResource(request: CheckResourceRequest): Promise<CheckResourceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.checkResourceWithOptions(request, runtime);
  }

  async createFpShotDBWithOptions(request: CreateFpShotDBRequest, runtime: $Util.RuntimeOptions): Promise<CreateFpShotDBResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<CreateFpShotDBResponse>(await this.doRPCRequest("CreateFpShotDB", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new CreateFpShotDBResponse({}));
  }

  async createFpShotDB(request: CreateFpShotDBRequest): Promise<CreateFpShotDBResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createFpShotDBWithOptions(request, runtime);
  }

  async createMcuTemplateWithOptions(request: CreateMcuTemplateRequest, runtime: $Util.RuntimeOptions): Promise<CreateMcuTemplateResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<CreateMcuTemplateResponse>(await this.doRPCRequest("CreateMcuTemplate", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new CreateMcuTemplateResponse({}));
  }

  async createMcuTemplate(request: CreateMcuTemplateRequest): Promise<CreateMcuTemplateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createMcuTemplateWithOptions(request, runtime);
  }

  async createSessionWithOptions(request: CreateSessionRequest, runtime: $Util.RuntimeOptions): Promise<CreateSessionResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<CreateSessionResponse>(await this.doRPCRequest("CreateSession", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new CreateSessionResponse({}));
  }

  async createSession(request: CreateSessionRequest): Promise<CreateSessionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createSessionWithOptions(request, runtime);
  }

  async deactivateMediaWorkflowWithOptions(request: DeactivateMediaWorkflowRequest, runtime: $Util.RuntimeOptions): Promise<DeactivateMediaWorkflowResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DeactivateMediaWorkflowResponse>(await this.doRPCRequest("DeactivateMediaWorkflow", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new DeactivateMediaWorkflowResponse({}));
  }

  async deactivateMediaWorkflow(request: DeactivateMediaWorkflowRequest): Promise<DeactivateMediaWorkflowResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deactivateMediaWorkflowWithOptions(request, runtime);
  }

  async decryptKeyWithOptions(request: DecryptKeyRequest, runtime: $Util.RuntimeOptions): Promise<DecryptKeyResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DecryptKeyResponse>(await this.doRPCRequest("DecryptKey", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new DecryptKeyResponse({}));
  }

  async decryptKey(request: DecryptKeyRequest): Promise<DecryptKeyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.decryptKeyWithOptions(request, runtime);
  }

  async deleteCategoryWithOptions(request: DeleteCategoryRequest, runtime: $Util.RuntimeOptions): Promise<DeleteCategoryResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DeleteCategoryResponse>(await this.doRPCRequest("DeleteCategory", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new DeleteCategoryResponse({}));
  }

  async deleteCategory(request: DeleteCategoryRequest): Promise<DeleteCategoryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteCategoryWithOptions(request, runtime);
  }

  async deleteMCTemplateWithOptions(request: DeleteMCTemplateRequest, runtime: $Util.RuntimeOptions): Promise<DeleteMCTemplateResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DeleteMCTemplateResponse>(await this.doRPCRequest("DeleteMCTemplate", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new DeleteMCTemplateResponse({}));
  }

  async deleteMCTemplate(request: DeleteMCTemplateRequest): Promise<DeleteMCTemplateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteMCTemplateWithOptions(request, runtime);
  }

  async deleteMcuJobWithOptions(request: DeleteMcuJobRequest, runtime: $Util.RuntimeOptions): Promise<DeleteMcuJobResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DeleteMcuJobResponse>(await this.doRPCRequest("DeleteMcuJob", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new DeleteMcuJobResponse({}));
  }

  async deleteMcuJob(request: DeleteMcuJobRequest): Promise<DeleteMcuJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteMcuJobWithOptions(request, runtime);
  }

  async deleteMcuTemplateWithOptions(request: DeleteMcuTemplateRequest, runtime: $Util.RuntimeOptions): Promise<DeleteMcuTemplateResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DeleteMcuTemplateResponse>(await this.doRPCRequest("DeleteMcuTemplate", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new DeleteMcuTemplateResponse({}));
  }

  async deleteMcuTemplate(request: DeleteMcuTemplateRequest): Promise<DeleteMcuTemplateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteMcuTemplateWithOptions(request, runtime);
  }

  async deleteMediaWithOptions(request: DeleteMediaRequest, runtime: $Util.RuntimeOptions): Promise<DeleteMediaResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DeleteMediaResponse>(await this.doRPCRequest("DeleteMedia", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new DeleteMediaResponse({}));
  }

  async deleteMedia(request: DeleteMediaRequest): Promise<DeleteMediaResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteMediaWithOptions(request, runtime);
  }

  async deleteMediaTagWithOptions(request: DeleteMediaTagRequest, runtime: $Util.RuntimeOptions): Promise<DeleteMediaTagResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DeleteMediaTagResponse>(await this.doRPCRequest("DeleteMediaTag", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new DeleteMediaTagResponse({}));
  }

  async deleteMediaTag(request: DeleteMediaTagRequest): Promise<DeleteMediaTagResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteMediaTagWithOptions(request, runtime);
  }

  async deleteMediaWorkflowWithOptions(request: DeleteMediaWorkflowRequest, runtime: $Util.RuntimeOptions): Promise<DeleteMediaWorkflowResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DeleteMediaWorkflowResponse>(await this.doRPCRequest("DeleteMediaWorkflow", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new DeleteMediaWorkflowResponse({}));
  }

  async deleteMediaWorkflow(request: DeleteMediaWorkflowRequest): Promise<DeleteMediaWorkflowResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteMediaWorkflowWithOptions(request, runtime);
  }

  async deletePipelineWithOptions(request: DeletePipelineRequest, runtime: $Util.RuntimeOptions): Promise<DeletePipelineResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DeletePipelineResponse>(await this.doRPCRequest("DeletePipeline", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new DeletePipelineResponse({}));
  }

  async deletePipeline(request: DeletePipelineRequest): Promise<DeletePipelineResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deletePipelineWithOptions(request, runtime);
  }

  async deleteSmarttagTemplateWithOptions(request: DeleteSmarttagTemplateRequest, runtime: $Util.RuntimeOptions): Promise<DeleteSmarttagTemplateResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DeleteSmarttagTemplateResponse>(await this.doRPCRequest("DeleteSmarttagTemplate", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new DeleteSmarttagTemplateResponse({}));
  }

  async deleteSmarttagTemplate(request: DeleteSmarttagTemplateRequest): Promise<DeleteSmarttagTemplateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteSmarttagTemplateWithOptions(request, runtime);
  }

  async deleteTemplateWithOptions(request: DeleteTemplateRequest, runtime: $Util.RuntimeOptions): Promise<DeleteTemplateResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DeleteTemplateResponse>(await this.doRPCRequest("DeleteTemplate", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new DeleteTemplateResponse({}));
  }

  async deleteTemplate(request: DeleteTemplateRequest): Promise<DeleteTemplateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteTemplateWithOptions(request, runtime);
  }

  async deleteWaterMarkTemplateWithOptions(request: DeleteWaterMarkTemplateRequest, runtime: $Util.RuntimeOptions): Promise<DeleteWaterMarkTemplateResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DeleteWaterMarkTemplateResponse>(await this.doRPCRequest("DeleteWaterMarkTemplate", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new DeleteWaterMarkTemplateResponse({}));
  }

  async deleteWaterMarkTemplate(request: DeleteWaterMarkTemplateRequest): Promise<DeleteWaterMarkTemplateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteWaterMarkTemplateWithOptions(request, runtime);
  }

  async describeMtsUserResourcePackageWithOptions(request: DescribeMtsUserResourcePackageRequest, runtime: $Util.RuntimeOptions): Promise<DescribeMtsUserResourcePackageResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeMtsUserResourcePackageResponse>(await this.doRPCRequest("DescribeMtsUserResourcePackage", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeMtsUserResourcePackageResponse({}));
  }

  async describeMtsUserResourcePackage(request: DescribeMtsUserResourcePackageRequest): Promise<DescribeMtsUserResourcePackageResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeMtsUserResourcePackageWithOptions(request, runtime);
  }

  async getLicenseWithOptions(request: GetLicenseRequest, runtime: $Util.RuntimeOptions): Promise<GetLicenseResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<GetLicenseResponse>(await this.doRPCRequest("GetLicense", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new GetLicenseResponse({}));
  }

  async getLicense(request: GetLicenseRequest): Promise<GetLicenseResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getLicenseWithOptions(request, runtime);
  }

  async getPackageWithOptions(request: GetPackageRequest, runtime: $Util.RuntimeOptions): Promise<GetPackageResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<GetPackageResponse>(await this.doRPCRequest("GetPackage", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new GetPackageResponse({}));
  }

  async getPackage(request: GetPackageRequest): Promise<GetPackageResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getPackageWithOptions(request, runtime);
  }

  async listAllCategoryWithOptions(request: ListAllCategoryRequest, runtime: $Util.RuntimeOptions): Promise<ListAllCategoryResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ListAllCategoryResponse>(await this.doRPCRequest("ListAllCategory", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new ListAllCategoryResponse({}));
  }

  async listAllCategory(request: ListAllCategoryRequest): Promise<ListAllCategoryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listAllCategoryWithOptions(request, runtime);
  }

  async listAllMediaBucketWithOptions(request: ListAllMediaBucketRequest, runtime: $Util.RuntimeOptions): Promise<ListAllMediaBucketResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ListAllMediaBucketResponse>(await this.doRPCRequest("ListAllMediaBucket", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new ListAllMediaBucketResponse({}));
  }

  async listAllMediaBucket(request: ListAllMediaBucketRequest): Promise<ListAllMediaBucketResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listAllMediaBucketWithOptions(request, runtime);
  }

  async listAsrPipelineWithOptions(request: ListAsrPipelineRequest, runtime: $Util.RuntimeOptions): Promise<ListAsrPipelineResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ListAsrPipelineResponse>(await this.doRPCRequest("ListAsrPipeline", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new ListAsrPipelineResponse({}));
  }

  async listAsrPipeline(request: ListAsrPipelineRequest): Promise<ListAsrPipelineResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listAsrPipelineWithOptions(request, runtime);
  }

  async listCensorPipelineWithOptions(request: ListCensorPipelineRequest, runtime: $Util.RuntimeOptions): Promise<ListCensorPipelineResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ListCensorPipelineResponse>(await this.doRPCRequest("ListCensorPipeline", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new ListCensorPipelineResponse({}));
  }

  async listCensorPipeline(request: ListCensorPipelineRequest): Promise<ListCensorPipelineResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listCensorPipelineWithOptions(request, runtime);
  }

  async listCoverPipelineWithOptions(request: ListCoverPipelineRequest, runtime: $Util.RuntimeOptions): Promise<ListCoverPipelineResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ListCoverPipelineResponse>(await this.doRPCRequest("ListCoverPipeline", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new ListCoverPipelineResponse({}));
  }

  async listCoverPipeline(request: ListCoverPipelineRequest): Promise<ListCoverPipelineResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listCoverPipelineWithOptions(request, runtime);
  }

  async listCustomPersonsWithOptions(request: ListCustomPersonsRequest, runtime: $Util.RuntimeOptions): Promise<ListCustomPersonsResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ListCustomPersonsResponse>(await this.doRPCRequest("ListCustomPersons", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new ListCustomPersonsResponse({}));
  }

  async listCustomPersons(request: ListCustomPersonsRequest): Promise<ListCustomPersonsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listCustomPersonsWithOptions(request, runtime);
  }

  async listFpShotDBWithOptions(request: ListFpShotDBRequest, runtime: $Util.RuntimeOptions): Promise<ListFpShotDBResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ListFpShotDBResponse>(await this.doRPCRequest("ListFpShotDB", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new ListFpShotDBResponse({}));
  }

  async listFpShotDB(request: ListFpShotDBRequest): Promise<ListFpShotDBResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listFpShotDBWithOptions(request, runtime);
  }

  async listFpShotFilesWithOptions(request: ListFpShotFilesRequest, runtime: $Util.RuntimeOptions): Promise<ListFpShotFilesResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ListFpShotFilesResponse>(await this.doRPCRequest("ListFpShotFiles", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new ListFpShotFilesResponse({}));
  }

  async listFpShotFiles(request: ListFpShotFilesRequest): Promise<ListFpShotFilesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listFpShotFilesWithOptions(request, runtime);
  }

  async listFpShotNotaryWithOptions(request: ListFpShotNotaryRequest, runtime: $Util.RuntimeOptions): Promise<ListFpShotNotaryResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ListFpShotNotaryResponse>(await this.doRPCRequest("ListFpShotNotary", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new ListFpShotNotaryResponse({}));
  }

  async listFpShotNotary(request: ListFpShotNotaryRequest): Promise<ListFpShotNotaryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listFpShotNotaryWithOptions(request, runtime);
  }

  async listJobWithOptions(request: ListJobRequest, runtime: $Util.RuntimeOptions): Promise<ListJobResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ListJobResponse>(await this.doRPCRequest("ListJob", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new ListJobResponse({}));
  }

  async listJob(request: ListJobRequest): Promise<ListJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listJobWithOptions(request, runtime);
  }

  async listMediaWithOptions(request: ListMediaRequest, runtime: $Util.RuntimeOptions): Promise<ListMediaResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ListMediaResponse>(await this.doRPCRequest("ListMedia", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new ListMediaResponse({}));
  }

  async listMedia(request: ListMediaRequest): Promise<ListMediaResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listMediaWithOptions(request, runtime);
  }

  async listMediaWorkflowExecutionsWithOptions(request: ListMediaWorkflowExecutionsRequest, runtime: $Util.RuntimeOptions): Promise<ListMediaWorkflowExecutionsResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ListMediaWorkflowExecutionsResponse>(await this.doRPCRequest("ListMediaWorkflowExecutions", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new ListMediaWorkflowExecutionsResponse({}));
  }

  async listMediaWorkflowExecutions(request: ListMediaWorkflowExecutionsRequest): Promise<ListMediaWorkflowExecutionsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listMediaWorkflowExecutionsWithOptions(request, runtime);
  }

  async listPornPipelineWithOptions(request: ListPornPipelineRequest, runtime: $Util.RuntimeOptions): Promise<ListPornPipelineResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ListPornPipelineResponse>(await this.doRPCRequest("ListPornPipeline", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new ListPornPipelineResponse({}));
  }

  async listPornPipeline(request: ListPornPipelineRequest): Promise<ListPornPipelineResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listPornPipelineWithOptions(request, runtime);
  }

  async listTerrorismPipelineWithOptions(request: ListTerrorismPipelineRequest, runtime: $Util.RuntimeOptions): Promise<ListTerrorismPipelineResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ListTerrorismPipelineResponse>(await this.doRPCRequest("ListTerrorismPipeline", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new ListTerrorismPipelineResponse({}));
  }

  async listTerrorismPipeline(request: ListTerrorismPipelineRequest): Promise<ListTerrorismPipelineResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listTerrorismPipelineWithOptions(request, runtime);
  }

  async logicalDeleteResourceWithOptions(request: LogicalDeleteResourceRequest, runtime: $Util.RuntimeOptions): Promise<LogicalDeleteResourceResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<LogicalDeleteResourceResponse>(await this.doRPCRequest("LogicalDeleteResource", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new LogicalDeleteResourceResponse({}));
  }

  async logicalDeleteResource(request: LogicalDeleteResourceRequest): Promise<LogicalDeleteResourceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.logicalDeleteResourceWithOptions(request, runtime);
  }

  async physicalDeleteResourceWithOptions(request: PhysicalDeleteResourceRequest, runtime: $Util.RuntimeOptions): Promise<PhysicalDeleteResourceResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<PhysicalDeleteResourceResponse>(await this.doRPCRequest("PhysicalDeleteResource", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new PhysicalDeleteResourceResponse({}));
  }

  async physicalDeleteResource(request: PhysicalDeleteResourceRequest): Promise<PhysicalDeleteResourceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.physicalDeleteResourceWithOptions(request, runtime);
  }

  async playerAuthWithOptions(request: PlayerAuthRequest, runtime: $Util.RuntimeOptions): Promise<PlayerAuthResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<PlayerAuthResponse>(await this.doRPCRequest("PlayerAuth", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new PlayerAuthResponse({}));
  }

  async playerAuth(request: PlayerAuthRequest): Promise<PlayerAuthResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.playerAuthWithOptions(request, runtime);
  }

  async playInfoWithOptions(request: PlayInfoRequest, runtime: $Util.RuntimeOptions): Promise<PlayInfoResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<PlayInfoResponse>(await this.doRPCRequest("PlayInfo", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new PlayInfoResponse({}));
  }

  async playInfo(request: PlayInfoRequest): Promise<PlayInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.playInfoWithOptions(request, runtime);
  }

  async queryAnalysisJobListWithOptions(request: QueryAnalysisJobListRequest, runtime: $Util.RuntimeOptions): Promise<QueryAnalysisJobListResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<QueryAnalysisJobListResponse>(await this.doRPCRequest("QueryAnalysisJobList", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new QueryAnalysisJobListResponse({}));
  }

  async queryAnalysisJobList(request: QueryAnalysisJobListRequest): Promise<QueryAnalysisJobListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryAnalysisJobListWithOptions(request, runtime);
  }

  async queryAnnotationJobListWithOptions(request: QueryAnnotationJobListRequest, runtime: $Util.RuntimeOptions): Promise<QueryAnnotationJobListResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<QueryAnnotationJobListResponse>(await this.doRPCRequest("QueryAnnotationJobList", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new QueryAnnotationJobListResponse({}));
  }

  async queryAnnotationJobList(request: QueryAnnotationJobListRequest): Promise<QueryAnnotationJobListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryAnnotationJobListWithOptions(request, runtime);
  }

  async queryAsrJobListWithOptions(request: QueryAsrJobListRequest, runtime: $Util.RuntimeOptions): Promise<QueryAsrJobListResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<QueryAsrJobListResponse>(await this.doRPCRequest("QueryAsrJobList", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new QueryAsrJobListResponse({}));
  }

  async queryAsrJobList(request: QueryAsrJobListRequest): Promise<QueryAsrJobListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryAsrJobListWithOptions(request, runtime);
  }

  async queryAsrPipelineListWithOptions(request: QueryAsrPipelineListRequest, runtime: $Util.RuntimeOptions): Promise<QueryAsrPipelineListResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<QueryAsrPipelineListResponse>(await this.doRPCRequest("QueryAsrPipelineList", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new QueryAsrPipelineListResponse({}));
  }

  async queryAsrPipelineList(request: QueryAsrPipelineListRequest): Promise<QueryAsrPipelineListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryAsrPipelineListWithOptions(request, runtime);
  }

  async queryAuthConfigWithOptions(request: QueryAuthConfigRequest, runtime: $Util.RuntimeOptions): Promise<QueryAuthConfigResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<QueryAuthConfigResponse>(await this.doRPCRequest("QueryAuthConfig", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new QueryAuthConfigResponse({}));
  }

  async queryAuthConfig(request: QueryAuthConfigRequest): Promise<QueryAuthConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryAuthConfigWithOptions(request, runtime);
  }

  async queryCensorJobListWithOptions(request: QueryCensorJobListRequest, runtime: $Util.RuntimeOptions): Promise<QueryCensorJobListResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<QueryCensorJobListResponse>(await this.doRPCRequest("QueryCensorJobList", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new QueryCensorJobListResponse({}));
  }

  async queryCensorJobList(request: QueryCensorJobListRequest): Promise<QueryCensorJobListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryCensorJobListWithOptions(request, runtime);
  }

  async queryCensorPipelineListWithOptions(request: QueryCensorPipelineListRequest, runtime: $Util.RuntimeOptions): Promise<QueryCensorPipelineListResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<QueryCensorPipelineListResponse>(await this.doRPCRequest("QueryCensorPipelineList", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new QueryCensorPipelineListResponse({}));
  }

  async queryCensorPipelineList(request: QueryCensorPipelineListRequest): Promise<QueryCensorPipelineListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryCensorPipelineListWithOptions(request, runtime);
  }

  async queryComplexJobListWithOptions(request: QueryComplexJobListRequest, runtime: $Util.RuntimeOptions): Promise<QueryComplexJobListResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<QueryComplexJobListResponse>(await this.doRPCRequest("QueryComplexJobList", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new QueryComplexJobListResponse({}));
  }

  async queryComplexJobList(request: QueryComplexJobListRequest): Promise<QueryComplexJobListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryComplexJobListWithOptions(request, runtime);
  }

  async queryCoverJobListWithOptions(request: QueryCoverJobListRequest, runtime: $Util.RuntimeOptions): Promise<QueryCoverJobListResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<QueryCoverJobListResponse>(await this.doRPCRequest("QueryCoverJobList", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new QueryCoverJobListResponse({}));
  }

  async queryCoverJobList(request: QueryCoverJobListRequest): Promise<QueryCoverJobListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryCoverJobListWithOptions(request, runtime);
  }

  async queryCoverPipelineListWithOptions(request: QueryCoverPipelineListRequest, runtime: $Util.RuntimeOptions): Promise<QueryCoverPipelineListResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<QueryCoverPipelineListResponse>(await this.doRPCRequest("QueryCoverPipelineList", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new QueryCoverPipelineListResponse({}));
  }

  async queryCoverPipelineList(request: QueryCoverPipelineListRequest): Promise<QueryCoverPipelineListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryCoverPipelineListWithOptions(request, runtime);
  }

  async queryEditingJobListWithOptions(request: QueryEditingJobListRequest, runtime: $Util.RuntimeOptions): Promise<QueryEditingJobListResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<QueryEditingJobListResponse>(await this.doRPCRequest("QueryEditingJobList", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new QueryEditingJobListResponse({}));
  }

  async queryEditingJobList(request: QueryEditingJobListRequest): Promise<QueryEditingJobListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryEditingJobListWithOptions(request, runtime);
  }

  async queryFacerecogJobListWithOptions(request: QueryFacerecogJobListRequest, runtime: $Util.RuntimeOptions): Promise<QueryFacerecogJobListResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<QueryFacerecogJobListResponse>(await this.doRPCRequest("QueryFacerecogJobList", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new QueryFacerecogJobListResponse({}));
  }

  async queryFacerecogJobList(request: QueryFacerecogJobListRequest): Promise<QueryFacerecogJobListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryFacerecogJobListWithOptions(request, runtime);
  }

  async queryFpCompareJobListWithOptions(request: QueryFpCompareJobListRequest, runtime: $Util.RuntimeOptions): Promise<QueryFpCompareJobListResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<QueryFpCompareJobListResponse>(await this.doRPCRequest("QueryFpCompareJobList", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new QueryFpCompareJobListResponse({}));
  }

  async queryFpCompareJobList(request: QueryFpCompareJobListRequest): Promise<QueryFpCompareJobListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryFpCompareJobListWithOptions(request, runtime);
  }

  async queryFpDBDeleteJobListWithOptions(request: QueryFpDBDeleteJobListRequest, runtime: $Util.RuntimeOptions): Promise<QueryFpDBDeleteJobListResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<QueryFpDBDeleteJobListResponse>(await this.doRPCRequest("QueryFpDBDeleteJobList", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new QueryFpDBDeleteJobListResponse({}));
  }

  async queryFpDBDeleteJobList(request: QueryFpDBDeleteJobListRequest): Promise<QueryFpDBDeleteJobListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryFpDBDeleteJobListWithOptions(request, runtime);
  }

  async queryFpFileDeleteJobListWithOptions(request: QueryFpFileDeleteJobListRequest, runtime: $Util.RuntimeOptions): Promise<QueryFpFileDeleteJobListResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<QueryFpFileDeleteJobListResponse>(await this.doRPCRequest("QueryFpFileDeleteJobList", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new QueryFpFileDeleteJobListResponse({}));
  }

  async queryFpFileDeleteJobList(request: QueryFpFileDeleteJobListRequest): Promise<QueryFpFileDeleteJobListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryFpFileDeleteJobListWithOptions(request, runtime);
  }

  async queryFpImportResultWithOptions(request: QueryFpImportResultRequest, runtime: $Util.RuntimeOptions): Promise<QueryFpImportResultResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<QueryFpImportResultResponse>(await this.doRPCRequest("QueryFpImportResult", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new QueryFpImportResultResponse({}));
  }

  async queryFpImportResult(request: QueryFpImportResultRequest): Promise<QueryFpImportResultResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryFpImportResultWithOptions(request, runtime);
  }

  async queryFpShotJobListWithOptions(request: QueryFpShotJobListRequest, runtime: $Util.RuntimeOptions): Promise<QueryFpShotJobListResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<QueryFpShotJobListResponse>(await this.doRPCRequest("QueryFpShotJobList", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new QueryFpShotJobListResponse({}));
  }

  async queryFpShotJobList(request: QueryFpShotJobListRequest): Promise<QueryFpShotJobListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryFpShotJobListWithOptions(request, runtime);
  }

  async queryImageSearchJobListWithOptions(request: QueryImageSearchJobListRequest, runtime: $Util.RuntimeOptions): Promise<QueryImageSearchJobListResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<QueryImageSearchJobListResponse>(await this.doRPCRequest("QueryImageSearchJobList", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new QueryImageSearchJobListResponse({}));
  }

  async queryImageSearchJobList(request: QueryImageSearchJobListRequest): Promise<QueryImageSearchJobListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryImageSearchJobListWithOptions(request, runtime);
  }

  async queryInnerJobWithOptions(request: QueryInnerJobRequest, runtime: $Util.RuntimeOptions): Promise<QueryInnerJobResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<QueryInnerJobResponse>(await this.doRPCRequest("QueryInnerJob", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new QueryInnerJobResponse({}));
  }

  async queryInnerJob(request: QueryInnerJobRequest): Promise<QueryInnerJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryInnerJobWithOptions(request, runtime);
  }

  async queryIProductionJobWithOptions(request: QueryIProductionJobRequest, runtime: $Util.RuntimeOptions): Promise<QueryIProductionJobResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<QueryIProductionJobResponse>(await this.doRPCRequest("QueryIProductionJob", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new QueryIProductionJobResponse({}));
  }

  async queryIProductionJob(request: QueryIProductionJobRequest): Promise<QueryIProductionJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryIProductionJobWithOptions(request, runtime);
  }

  async queryIProductionJobListWithOptions(request: QueryIProductionJobListRequest, runtime: $Util.RuntimeOptions): Promise<QueryIProductionJobListResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<QueryIProductionJobListResponse>(await this.doRPCRequest("QueryIProductionJobList", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new QueryIProductionJobListResponse({}));
  }

  async queryIProductionJobList(request: QueryIProductionJobListRequest): Promise<QueryIProductionJobListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryIProductionJobListWithOptions(request, runtime);
  }

  async queryJobListWithOptions(request: QueryJobListRequest, runtime: $Util.RuntimeOptions): Promise<QueryJobListResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<QueryJobListResponse>(await this.doRPCRequest("QueryJobList", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new QueryJobListResponse({}));
  }

  async queryJobList(request: QueryJobListRequest): Promise<QueryJobListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryJobListWithOptions(request, runtime);
  }

  async queryMCJobListWithOptions(request: QueryMCJobListRequest, runtime: $Util.RuntimeOptions): Promise<QueryMCJobListResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<QueryMCJobListResponse>(await this.doRPCRequest("QueryMCJobList", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new QueryMCJobListResponse({}));
  }

  async queryMCJobList(request: QueryMCJobListRequest): Promise<QueryMCJobListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryMCJobListWithOptions(request, runtime);
  }

  async queryMCTemplateListWithOptions(request: QueryMCTemplateListRequest, runtime: $Util.RuntimeOptions): Promise<QueryMCTemplateListResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<QueryMCTemplateListResponse>(await this.doRPCRequest("QueryMCTemplateList", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new QueryMCTemplateListResponse({}));
  }

  async queryMCTemplateList(request: QueryMCTemplateListRequest): Promise<QueryMCTemplateListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryMCTemplateListWithOptions(request, runtime);
  }

  async queryMcuJobWithOptions(request: QueryMcuJobRequest, runtime: $Util.RuntimeOptions): Promise<QueryMcuJobResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<QueryMcuJobResponse>(await this.doRPCRequest("QueryMcuJob", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new QueryMcuJobResponse({}));
  }

  async queryMcuJob(request: QueryMcuJobRequest): Promise<QueryMcuJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryMcuJobWithOptions(request, runtime);
  }

  async queryMcuTemplateWithOptions(request: QueryMcuTemplateRequest, runtime: $Util.RuntimeOptions): Promise<QueryMcuTemplateResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<QueryMcuTemplateResponse>(await this.doRPCRequest("QueryMcuTemplate", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new QueryMcuTemplateResponse({}));
  }

  async queryMcuTemplate(request: QueryMcuTemplateRequest): Promise<QueryMcuTemplateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryMcuTemplateWithOptions(request, runtime);
  }

  async queryMediaCensorJobDetailWithOptions(request: QueryMediaCensorJobDetailRequest, runtime: $Util.RuntimeOptions): Promise<QueryMediaCensorJobDetailResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<QueryMediaCensorJobDetailResponse>(await this.doRPCRequest("QueryMediaCensorJobDetail", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new QueryMediaCensorJobDetailResponse({}));
  }

  async queryMediaCensorJobDetail(request: QueryMediaCensorJobDetailRequest): Promise<QueryMediaCensorJobDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryMediaCensorJobDetailWithOptions(request, runtime);
  }

  async queryMediaCensorJobListWithOptions(request: QueryMediaCensorJobListRequest, runtime: $Util.RuntimeOptions): Promise<QueryMediaCensorJobListResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<QueryMediaCensorJobListResponse>(await this.doRPCRequest("QueryMediaCensorJobList", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new QueryMediaCensorJobListResponse({}));
  }

  async queryMediaCensorJobList(request: QueryMediaCensorJobListRequest): Promise<QueryMediaCensorJobListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryMediaCensorJobListWithOptions(request, runtime);
  }

  async queryMediaDetailJobListWithOptions(request: QueryMediaDetailJobListRequest, runtime: $Util.RuntimeOptions): Promise<QueryMediaDetailJobListResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<QueryMediaDetailJobListResponse>(await this.doRPCRequest("QueryMediaDetailJobList", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new QueryMediaDetailJobListResponse({}));
  }

  async queryMediaDetailJobList(request: QueryMediaDetailJobListRequest): Promise<QueryMediaDetailJobListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryMediaDetailJobListWithOptions(request, runtime);
  }

  async queryMediaFpDeleteJobListWithOptions(request: QueryMediaFpDeleteJobListRequest, runtime: $Util.RuntimeOptions): Promise<QueryMediaFpDeleteJobListResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<QueryMediaFpDeleteJobListResponse>(await this.doRPCRequest("QueryMediaFpDeleteJobList", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new QueryMediaFpDeleteJobListResponse({}));
  }

  async queryMediaFpDeleteJobList(request: QueryMediaFpDeleteJobListRequest): Promise<QueryMediaFpDeleteJobListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryMediaFpDeleteJobListWithOptions(request, runtime);
  }

  async queryMediaInfoJobListWithOptions(request: QueryMediaInfoJobListRequest, runtime: $Util.RuntimeOptions): Promise<QueryMediaInfoJobListResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<QueryMediaInfoJobListResponse>(await this.doRPCRequest("QueryMediaInfoJobList", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new QueryMediaInfoJobListResponse({}));
  }

  async queryMediaInfoJobList(request: QueryMediaInfoJobListRequest): Promise<QueryMediaInfoJobListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryMediaInfoJobListWithOptions(request, runtime);
  }

  async queryMediaListWithOptions(request: QueryMediaListRequest, runtime: $Util.RuntimeOptions): Promise<QueryMediaListResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<QueryMediaListResponse>(await this.doRPCRequest("QueryMediaList", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new QueryMediaListResponse({}));
  }

  async queryMediaList(request: QueryMediaListRequest): Promise<QueryMediaListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryMediaListWithOptions(request, runtime);
  }

  async queryMediaListByURLWithOptions(request: QueryMediaListByURLRequest, runtime: $Util.RuntimeOptions): Promise<QueryMediaListByURLResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<QueryMediaListByURLResponse>(await this.doRPCRequest("QueryMediaListByURL", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new QueryMediaListByURLResponse({}));
  }

  async queryMediaListByURL(request: QueryMediaListByURLRequest): Promise<QueryMediaListByURLResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryMediaListByURLWithOptions(request, runtime);
  }

  async queryMediaWorkflowExecutionListWithOptions(request: QueryMediaWorkflowExecutionListRequest, runtime: $Util.RuntimeOptions): Promise<QueryMediaWorkflowExecutionListResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<QueryMediaWorkflowExecutionListResponse>(await this.doRPCRequest("QueryMediaWorkflowExecutionList", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new QueryMediaWorkflowExecutionListResponse({}));
  }

  async queryMediaWorkflowExecutionList(request: QueryMediaWorkflowExecutionListRequest): Promise<QueryMediaWorkflowExecutionListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryMediaWorkflowExecutionListWithOptions(request, runtime);
  }

  async queryMediaWorkflowListWithOptions(request: QueryMediaWorkflowListRequest, runtime: $Util.RuntimeOptions): Promise<QueryMediaWorkflowListResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<QueryMediaWorkflowListResponse>(await this.doRPCRequest("QueryMediaWorkflowList", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new QueryMediaWorkflowListResponse({}));
  }

  async queryMediaWorkflowList(request: QueryMediaWorkflowListRequest): Promise<QueryMediaWorkflowListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryMediaWorkflowListWithOptions(request, runtime);
  }

  async queryPipelineListWithOptions(request: QueryPipelineListRequest, runtime: $Util.RuntimeOptions): Promise<QueryPipelineListResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<QueryPipelineListResponse>(await this.doRPCRequest("QueryPipelineList", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new QueryPipelineListResponse({}));
  }

  async queryPipelineList(request: QueryPipelineListRequest): Promise<QueryPipelineListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryPipelineListWithOptions(request, runtime);
  }

  async queryPornJobListWithOptions(request: QueryPornJobListRequest, runtime: $Util.RuntimeOptions): Promise<QueryPornJobListResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<QueryPornJobListResponse>(await this.doRPCRequest("QueryPornJobList", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new QueryPornJobListResponse({}));
  }

  async queryPornJobList(request: QueryPornJobListRequest): Promise<QueryPornJobListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryPornJobListWithOptions(request, runtime);
  }

  async queryPornPipelineListWithOptions(request: QueryPornPipelineListRequest, runtime: $Util.RuntimeOptions): Promise<QueryPornPipelineListResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<QueryPornPipelineListResponse>(await this.doRPCRequest("QueryPornPipelineList", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new QueryPornPipelineListResponse({}));
  }

  async queryPornPipelineList(request: QueryPornPipelineListRequest): Promise<QueryPornPipelineListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryPornPipelineListWithOptions(request, runtime);
  }

  async querySmarttagJobWithOptions(request: QuerySmarttagJobRequest, runtime: $Util.RuntimeOptions): Promise<QuerySmarttagJobResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<QuerySmarttagJobResponse>(await this.doRPCRequest("QuerySmarttagJob", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new QuerySmarttagJobResponse({}));
  }

  async querySmarttagJob(request: QuerySmarttagJobRequest): Promise<QuerySmarttagJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.querySmarttagJobWithOptions(request, runtime);
  }

  async querySmarttagTemplateListWithOptions(request: QuerySmarttagTemplateListRequest, runtime: $Util.RuntimeOptions): Promise<QuerySmarttagTemplateListResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<QuerySmarttagTemplateListResponse>(await this.doRPCRequest("QuerySmarttagTemplateList", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new QuerySmarttagTemplateListResponse({}));
  }

  async querySmarttagTemplateList(request: QuerySmarttagTemplateListRequest): Promise<QuerySmarttagTemplateListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.querySmarttagTemplateListWithOptions(request, runtime);
  }

  async querySnapshotJobListWithOptions(request: QuerySnapshotJobListRequest, runtime: $Util.RuntimeOptions): Promise<QuerySnapshotJobListResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<QuerySnapshotJobListResponse>(await this.doRPCRequest("QuerySnapshotJobList", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new QuerySnapshotJobListResponse({}));
  }

  async querySnapshotJobList(request: QuerySnapshotJobListRequest): Promise<QuerySnapshotJobListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.querySnapshotJobListWithOptions(request, runtime);
  }

  async querySubtitleJobListWithOptions(request: QuerySubtitleJobListRequest, runtime: $Util.RuntimeOptions): Promise<QuerySubtitleJobListResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<QuerySubtitleJobListResponse>(await this.doRPCRequest("QuerySubtitleJobList", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new QuerySubtitleJobListResponse({}));
  }

  async querySubtitleJobList(request: QuerySubtitleJobListRequest): Promise<QuerySubtitleJobListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.querySubtitleJobListWithOptions(request, runtime);
  }

  async queryTagJobListWithOptions(request: QueryTagJobListRequest, runtime: $Util.RuntimeOptions): Promise<QueryTagJobListResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<QueryTagJobListResponse>(await this.doRPCRequest("QueryTagJobList", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new QueryTagJobListResponse({}));
  }

  async queryTagJobList(request: QueryTagJobListRequest): Promise<QueryTagJobListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryTagJobListWithOptions(request, runtime);
  }

  async queryTemplateListWithOptions(request: QueryTemplateListRequest, runtime: $Util.RuntimeOptions): Promise<QueryTemplateListResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<QueryTemplateListResponse>(await this.doRPCRequest("QueryTemplateList", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new QueryTemplateListResponse({}));
  }

  async queryTemplateList(request: QueryTemplateListRequest): Promise<QueryTemplateListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryTemplateListWithOptions(request, runtime);
  }

  async queryTerrorismJobListWithOptions(request: QueryTerrorismJobListRequest, runtime: $Util.RuntimeOptions): Promise<QueryTerrorismJobListResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<QueryTerrorismJobListResponse>(await this.doRPCRequest("QueryTerrorismJobList", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new QueryTerrorismJobListResponse({}));
  }

  async queryTerrorismJobList(request: QueryTerrorismJobListRequest): Promise<QueryTerrorismJobListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryTerrorismJobListWithOptions(request, runtime);
  }

  async queryTerrorismPipelineListWithOptions(request: QueryTerrorismPipelineListRequest, runtime: $Util.RuntimeOptions): Promise<QueryTerrorismPipelineListResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<QueryTerrorismPipelineListResponse>(await this.doRPCRequest("QueryTerrorismPipelineList", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new QueryTerrorismPipelineListResponse({}));
  }

  async queryTerrorismPipelineList(request: QueryTerrorismPipelineListRequest): Promise<QueryTerrorismPipelineListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryTerrorismPipelineListWithOptions(request, runtime);
  }

  async queryVideoGifJobListWithOptions(request: QueryVideoGifJobListRequest, runtime: $Util.RuntimeOptions): Promise<QueryVideoGifJobListResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<QueryVideoGifJobListResponse>(await this.doRPCRequest("QueryVideoGifJobList", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new QueryVideoGifJobListResponse({}));
  }

  async queryVideoGifJobList(request: QueryVideoGifJobListRequest): Promise<QueryVideoGifJobListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryVideoGifJobListWithOptions(request, runtime);
  }

  async queryVideoPoseJobListWithOptions(request: QueryVideoPoseJobListRequest, runtime: $Util.RuntimeOptions): Promise<QueryVideoPoseJobListResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<QueryVideoPoseJobListResponse>(await this.doRPCRequest("QueryVideoPoseJobList", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new QueryVideoPoseJobListResponse({}));
  }

  async queryVideoPoseJobList(request: QueryVideoPoseJobListRequest): Promise<QueryVideoPoseJobListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryVideoPoseJobListWithOptions(request, runtime);
  }

  async queryVideoQualityJobWithOptions(request: QueryVideoQualityJobRequest, runtime: $Util.RuntimeOptions): Promise<QueryVideoQualityJobResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<QueryVideoQualityJobResponse>(await this.doRPCRequest("QueryVideoQualityJob", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new QueryVideoQualityJobResponse({}));
  }

  async queryVideoQualityJob(request: QueryVideoQualityJobRequest): Promise<QueryVideoQualityJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryVideoQualityJobWithOptions(request, runtime);
  }

  async queryVideoSplitJobListWithOptions(request: QueryVideoSplitJobListRequest, runtime: $Util.RuntimeOptions): Promise<QueryVideoSplitJobListResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<QueryVideoSplitJobListResponse>(await this.doRPCRequest("QueryVideoSplitJobList", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new QueryVideoSplitJobListResponse({}));
  }

  async queryVideoSplitJobList(request: QueryVideoSplitJobListRequest): Promise<QueryVideoSplitJobListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryVideoSplitJobListWithOptions(request, runtime);
  }

  async queryVideoSummaryJobListWithOptions(request: QueryVideoSummaryJobListRequest, runtime: $Util.RuntimeOptions): Promise<QueryVideoSummaryJobListResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<QueryVideoSummaryJobListResponse>(await this.doRPCRequest("QueryVideoSummaryJobList", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new QueryVideoSummaryJobListResponse({}));
  }

  async queryVideoSummaryJobList(request: QueryVideoSummaryJobListRequest): Promise<QueryVideoSummaryJobListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryVideoSummaryJobListWithOptions(request, runtime);
  }

  async queryWaterMarkTemplateListWithOptions(request: QueryWaterMarkTemplateListRequest, runtime: $Util.RuntimeOptions): Promise<QueryWaterMarkTemplateListResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<QueryWaterMarkTemplateListResponse>(await this.doRPCRequest("QueryWaterMarkTemplateList", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new QueryWaterMarkTemplateListResponse({}));
  }

  async queryWaterMarkTemplateList(request: QueryWaterMarkTemplateListRequest): Promise<QueryWaterMarkTemplateListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryWaterMarkTemplateListWithOptions(request, runtime);
  }

  async refreshCdnDomainConfigsCacheWithOptions(request: RefreshCdnDomainConfigsCacheRequest, runtime: $Util.RuntimeOptions): Promise<RefreshCdnDomainConfigsCacheResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<RefreshCdnDomainConfigsCacheResponse>(await this.doRPCRequest("RefreshCdnDomainConfigsCache", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new RefreshCdnDomainConfigsCacheResponse({}));
  }

  async refreshCdnDomainConfigsCache(request: RefreshCdnDomainConfigsCacheRequest): Promise<RefreshCdnDomainConfigsCacheResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.refreshCdnDomainConfigsCacheWithOptions(request, runtime);
  }

  async registerCustomFaceWithOptions(request: RegisterCustomFaceRequest, runtime: $Util.RuntimeOptions): Promise<RegisterCustomFaceResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<RegisterCustomFaceResponse>(await this.doRPCRequest("RegisterCustomFace", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new RegisterCustomFaceResponse({}));
  }

  async registerCustomFace(request: RegisterCustomFaceRequest): Promise<RegisterCustomFaceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.registerCustomFaceWithOptions(request, runtime);
  }

  async registerMediaDetailPersonWithOptions(request: RegisterMediaDetailPersonRequest, runtime: $Util.RuntimeOptions): Promise<RegisterMediaDetailPersonResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<RegisterMediaDetailPersonResponse>(await this.doRPCRequest("RegisterMediaDetailPerson", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new RegisterMediaDetailPersonResponse({}));
  }

  async registerMediaDetailPerson(request: RegisterMediaDetailPersonRequest): Promise<RegisterMediaDetailPersonResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.registerMediaDetailPersonWithOptions(request, runtime);
  }

  async registerMediaDetailScenarioWithOptions(request: RegisterMediaDetailScenarioRequest, runtime: $Util.RuntimeOptions): Promise<RegisterMediaDetailScenarioResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<RegisterMediaDetailScenarioResponse>(await this.doRPCRequest("RegisterMediaDetailScenario", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new RegisterMediaDetailScenarioResponse({}));
  }

  async registerMediaDetailScenario(request: RegisterMediaDetailScenarioRequest): Promise<RegisterMediaDetailScenarioResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.registerMediaDetailScenarioWithOptions(request, runtime);
  }

  async reportAnnotationJobResultWithOptions(request: ReportAnnotationJobResultRequest, runtime: $Util.RuntimeOptions): Promise<ReportAnnotationJobResultResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ReportAnnotationJobResultResponse>(await this.doRPCRequest("ReportAnnotationJobResult", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new ReportAnnotationJobResultResponse({}));
  }

  async reportAnnotationJobResult(request: ReportAnnotationJobResultRequest): Promise<ReportAnnotationJobResultResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.reportAnnotationJobResultWithOptions(request, runtime);
  }

  async reportCensorJobResultWithOptions(request: ReportCensorJobResultRequest, runtime: $Util.RuntimeOptions): Promise<ReportCensorJobResultResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ReportCensorJobResultResponse>(await this.doRPCRequest("ReportCensorJobResult", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new ReportCensorJobResultResponse({}));
  }

  async reportCensorJobResult(request: ReportCensorJobResultRequest): Promise<ReportCensorJobResultResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.reportCensorJobResultWithOptions(request, runtime);
  }

  async reportCoverJobResultWithOptions(request: ReportCoverJobResultRequest, runtime: $Util.RuntimeOptions): Promise<ReportCoverJobResultResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ReportCoverJobResultResponse>(await this.doRPCRequest("ReportCoverJobResult", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new ReportCoverJobResultResponse({}));
  }

  async reportCoverJobResult(request: ReportCoverJobResultRequest): Promise<ReportCoverJobResultResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.reportCoverJobResultWithOptions(request, runtime);
  }

  async reportFacerecogJobResultWithOptions(request: ReportFacerecogJobResultRequest, runtime: $Util.RuntimeOptions): Promise<ReportFacerecogJobResultResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ReportFacerecogJobResultResponse>(await this.doRPCRequest("ReportFacerecogJobResult", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new ReportFacerecogJobResultResponse({}));
  }

  async reportFacerecogJobResult(request: ReportFacerecogJobResultRequest): Promise<ReportFacerecogJobResultResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.reportFacerecogJobResultWithOptions(request, runtime);
  }

  async reportFpShotJobResultWithOptions(request: ReportFpShotJobResultRequest, runtime: $Util.RuntimeOptions): Promise<ReportFpShotJobResultResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ReportFpShotJobResultResponse>(await this.doRPCRequest("ReportFpShotJobResult", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new ReportFpShotJobResultResponse({}));
  }

  async reportFpShotJobResult(request: ReportFpShotJobResultRequest): Promise<ReportFpShotJobResultResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.reportFpShotJobResultWithOptions(request, runtime);
  }

  async reportMediaDetailJobResultWithOptions(request: ReportMediaDetailJobResultRequest, runtime: $Util.RuntimeOptions): Promise<ReportMediaDetailJobResultResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ReportMediaDetailJobResultResponse>(await this.doRPCRequest("ReportMediaDetailJobResult", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new ReportMediaDetailJobResultResponse({}));
  }

  async reportMediaDetailJobResult(request: ReportMediaDetailJobResultRequest): Promise<ReportMediaDetailJobResultResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.reportMediaDetailJobResultWithOptions(request, runtime);
  }

  async reportPornJobResultWithOptions(request: ReportPornJobResultRequest, runtime: $Util.RuntimeOptions): Promise<ReportPornJobResultResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ReportPornJobResultResponse>(await this.doRPCRequest("ReportPornJobResult", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new ReportPornJobResultResponse({}));
  }

  async reportPornJobResult(request: ReportPornJobResultRequest): Promise<ReportPornJobResultResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.reportPornJobResultWithOptions(request, runtime);
  }

  async reportTagJobResultWithOptions(request: ReportTagJobResultRequest, runtime: $Util.RuntimeOptions): Promise<ReportTagJobResultResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ReportTagJobResultResponse>(await this.doRPCRequest("ReportTagJobResult", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new ReportTagJobResultResponse({}));
  }

  async reportTagJobResult(request: ReportTagJobResultRequest): Promise<ReportTagJobResultResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.reportTagJobResultWithOptions(request, runtime);
  }

  async reportTerrorismJobResultWithOptions(request: ReportTerrorismJobResultRequest, runtime: $Util.RuntimeOptions): Promise<ReportTerrorismJobResultResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ReportTerrorismJobResultResponse>(await this.doRPCRequest("ReportTerrorismJobResult", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new ReportTerrorismJobResultResponse({}));
  }

  async reportTerrorismJobResult(request: ReportTerrorismJobResultRequest): Promise<ReportTerrorismJobResultResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.reportTerrorismJobResultWithOptions(request, runtime);
  }

  async reportVideoSplitJobResultWithOptions(request: ReportVideoSplitJobResultRequest, runtime: $Util.RuntimeOptions): Promise<ReportVideoSplitJobResultResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ReportVideoSplitJobResultResponse>(await this.doRPCRequest("ReportVideoSplitJobResult", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new ReportVideoSplitJobResultResponse({}));
  }

  async reportVideoSplitJobResult(request: ReportVideoSplitJobResultRequest): Promise<ReportVideoSplitJobResultResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.reportVideoSplitJobResultWithOptions(request, runtime);
  }

  async searchMediaWithOptions(request: SearchMediaRequest, runtime: $Util.RuntimeOptions): Promise<SearchMediaResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<SearchMediaResponse>(await this.doRPCRequest("SearchMedia", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new SearchMediaResponse({}));
  }

  async searchMedia(request: SearchMediaRequest): Promise<SearchMediaResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.searchMediaWithOptions(request, runtime);
  }

  async searchMediaWorkflowWithOptions(request: SearchMediaWorkflowRequest, runtime: $Util.RuntimeOptions): Promise<SearchMediaWorkflowResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<SearchMediaWorkflowResponse>(await this.doRPCRequest("SearchMediaWorkflow", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new SearchMediaWorkflowResponse({}));
  }

  async searchMediaWorkflow(request: SearchMediaWorkflowRequest): Promise<SearchMediaWorkflowResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.searchMediaWorkflowWithOptions(request, runtime);
  }

  async searchPipelineWithOptions(request: SearchPipelineRequest, runtime: $Util.RuntimeOptions): Promise<SearchPipelineResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<SearchPipelineResponse>(await this.doRPCRequest("SearchPipeline", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new SearchPipelineResponse({}));
  }

  async searchPipeline(request: SearchPipelineRequest): Promise<SearchPipelineResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.searchPipelineWithOptions(request, runtime);
  }

  async searchTemplateWithOptions(request: SearchTemplateRequest, runtime: $Util.RuntimeOptions): Promise<SearchTemplateResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<SearchTemplateResponse>(await this.doRPCRequest("SearchTemplate", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new SearchTemplateResponse({}));
  }

  async searchTemplate(request: SearchTemplateRequest): Promise<SearchTemplateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.searchTemplateWithOptions(request, runtime);
  }

  async searchWaterMarkTemplateWithOptions(request: SearchWaterMarkTemplateRequest, runtime: $Util.RuntimeOptions): Promise<SearchWaterMarkTemplateResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<SearchWaterMarkTemplateResponse>(await this.doRPCRequest("SearchWaterMarkTemplate", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new SearchWaterMarkTemplateResponse({}));
  }

  async searchWaterMarkTemplate(request: SearchWaterMarkTemplateRequest): Promise<SearchWaterMarkTemplateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.searchWaterMarkTemplateWithOptions(request, runtime);
  }

  async setAuthConfigWithOptions(request: SetAuthConfigRequest, runtime: $Util.RuntimeOptions): Promise<SetAuthConfigResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<SetAuthConfigResponse>(await this.doRPCRequest("SetAuthConfig", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new SetAuthConfigResponse({}));
  }

  async setAuthConfig(request: SetAuthConfigRequest): Promise<SetAuthConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setAuthConfigWithOptions(request, runtime);
  }

  async stopIProductionJobWithOptions(request: StopIProductionJobRequest, runtime: $Util.RuntimeOptions): Promise<StopIProductionJobResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<StopIProductionJobResponse>(await this.doRPCRequest("StopIProductionJob", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new StopIProductionJobResponse({}));
  }

  async stopIProductionJob(request: StopIProductionJobRequest): Promise<StopIProductionJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.stopIProductionJobWithOptions(request, runtime);
  }

  async submitAnalysisJobWithOptions(request: SubmitAnalysisJobRequest, runtime: $Util.RuntimeOptions): Promise<SubmitAnalysisJobResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<SubmitAnalysisJobResponse>(await this.doRPCRequest("SubmitAnalysisJob", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new SubmitAnalysisJobResponse({}));
  }

  async submitAnalysisJob(request: SubmitAnalysisJobRequest): Promise<SubmitAnalysisJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.submitAnalysisJobWithOptions(request, runtime);
  }

  async submitAnnotationJobWithOptions(request: SubmitAnnotationJobRequest, runtime: $Util.RuntimeOptions): Promise<SubmitAnnotationJobResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<SubmitAnnotationJobResponse>(await this.doRPCRequest("SubmitAnnotationJob", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new SubmitAnnotationJobResponse({}));
  }

  async submitAnnotationJob(request: SubmitAnnotationJobRequest): Promise<SubmitAnnotationJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.submitAnnotationJobWithOptions(request, runtime);
  }

  async submitAsrJobWithOptions(request: SubmitAsrJobRequest, runtime: $Util.RuntimeOptions): Promise<SubmitAsrJobResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<SubmitAsrJobResponse>(await this.doRPCRequest("SubmitAsrJob", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new SubmitAsrJobResponse({}));
  }

  async submitAsrJob(request: SubmitAsrJobRequest): Promise<SubmitAsrJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.submitAsrJobWithOptions(request, runtime);
  }

  async submitBeautifyJobsWithOptions(request: SubmitBeautifyJobsRequest, runtime: $Util.RuntimeOptions): Promise<SubmitBeautifyJobsResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<SubmitBeautifyJobsResponse>(await this.doRPCRequest("SubmitBeautifyJobs", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new SubmitBeautifyJobsResponse({}));
  }

  async submitBeautifyJobs(request: SubmitBeautifyJobsRequest): Promise<SubmitBeautifyJobsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.submitBeautifyJobsWithOptions(request, runtime);
  }

  async submitComplexJobWithOptions(request: SubmitComplexJobRequest, runtime: $Util.RuntimeOptions): Promise<SubmitComplexJobResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<SubmitComplexJobResponse>(await this.doRPCRequest("SubmitComplexJob", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new SubmitComplexJobResponse({}));
  }

  async submitComplexJob(request: SubmitComplexJobRequest): Promise<SubmitComplexJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.submitComplexJobWithOptions(request, runtime);
  }

  async submitCoverJobWithOptions(request: SubmitCoverJobRequest, runtime: $Util.RuntimeOptions): Promise<SubmitCoverJobResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<SubmitCoverJobResponse>(await this.doRPCRequest("SubmitCoverJob", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new SubmitCoverJobResponse({}));
  }

  async submitCoverJob(request: SubmitCoverJobRequest): Promise<SubmitCoverJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.submitCoverJobWithOptions(request, runtime);
  }

  async submitEditingJobsWithOptions(request: SubmitEditingJobsRequest, runtime: $Util.RuntimeOptions): Promise<SubmitEditingJobsResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<SubmitEditingJobsResponse>(await this.doRPCRequest("SubmitEditingJobs", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new SubmitEditingJobsResponse({}));
  }

  async submitEditingJobs(request: SubmitEditingJobsRequest): Promise<SubmitEditingJobsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.submitEditingJobsWithOptions(request, runtime);
  }

  async submitFacerecogJobWithOptions(request: SubmitFacerecogJobRequest, runtime: $Util.RuntimeOptions): Promise<SubmitFacerecogJobResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<SubmitFacerecogJobResponse>(await this.doRPCRequest("SubmitFacerecogJob", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new SubmitFacerecogJobResponse({}));
  }

  async submitFacerecogJob(request: SubmitFacerecogJobRequest): Promise<SubmitFacerecogJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.submitFacerecogJobWithOptions(request, runtime);
  }

  async submitFpCompareJobWithOptions(request: SubmitFpCompareJobRequest, runtime: $Util.RuntimeOptions): Promise<SubmitFpCompareJobResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<SubmitFpCompareJobResponse>(await this.doRPCRequest("SubmitFpCompareJob", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new SubmitFpCompareJobResponse({}));
  }

  async submitFpCompareJob(request: SubmitFpCompareJobRequest): Promise<SubmitFpCompareJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.submitFpCompareJobWithOptions(request, runtime);
  }

  async submitFpDBDeleteJobWithOptions(request: SubmitFpDBDeleteJobRequest, runtime: $Util.RuntimeOptions): Promise<SubmitFpDBDeleteJobResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<SubmitFpDBDeleteJobResponse>(await this.doRPCRequest("SubmitFpDBDeleteJob", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new SubmitFpDBDeleteJobResponse({}));
  }

  async submitFpDBDeleteJob(request: SubmitFpDBDeleteJobRequest): Promise<SubmitFpDBDeleteJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.submitFpDBDeleteJobWithOptions(request, runtime);
  }

  async submitFpFileDeleteJobWithOptions(request: SubmitFpFileDeleteJobRequest, runtime: $Util.RuntimeOptions): Promise<SubmitFpFileDeleteJobResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<SubmitFpFileDeleteJobResponse>(await this.doRPCRequest("SubmitFpFileDeleteJob", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new SubmitFpFileDeleteJobResponse({}));
  }

  async submitFpFileDeleteJob(request: SubmitFpFileDeleteJobRequest): Promise<SubmitFpFileDeleteJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.submitFpFileDeleteJobWithOptions(request, runtime);
  }

  async submitFpShotJobWithOptions(request: SubmitFpShotJobRequest, runtime: $Util.RuntimeOptions): Promise<SubmitFpShotJobResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<SubmitFpShotJobResponse>(await this.doRPCRequest("SubmitFpShotJob", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new SubmitFpShotJobResponse({}));
  }

  async submitFpShotJob(request: SubmitFpShotJobRequest): Promise<SubmitFpShotJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.submitFpShotJobWithOptions(request, runtime);
  }

  async submitImageQualityJobWithOptions(request: SubmitImageQualityJobRequest, runtime: $Util.RuntimeOptions): Promise<SubmitImageQualityJobResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<SubmitImageQualityJobResponse>(await this.doRPCRequest("SubmitImageQualityJob", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new SubmitImageQualityJobResponse({}));
  }

  async submitImageQualityJob(request: SubmitImageQualityJobRequest): Promise<SubmitImageQualityJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.submitImageQualityJobWithOptions(request, runtime);
  }

  async submitImageSearchJobWithOptions(request: SubmitImageSearchJobRequest, runtime: $Util.RuntimeOptions): Promise<SubmitImageSearchJobResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<SubmitImageSearchJobResponse>(await this.doRPCRequest("SubmitImageSearchJob", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new SubmitImageSearchJobResponse({}));
  }

  async submitImageSearchJob(request: SubmitImageSearchJobRequest): Promise<SubmitImageSearchJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.submitImageSearchJobWithOptions(request, runtime);
  }

  async submitInnerJobWithOptions(request: SubmitInnerJobRequest, runtime: $Util.RuntimeOptions): Promise<SubmitInnerJobResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<SubmitInnerJobResponse>(await this.doRPCRequest("SubmitInnerJob", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new SubmitInnerJobResponse({}));
  }

  async submitInnerJob(request: SubmitInnerJobRequest): Promise<SubmitInnerJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.submitInnerJobWithOptions(request, runtime);
  }

  async submitIProductionJobWithOptions(request: SubmitIProductionJobRequest, runtime: $Util.RuntimeOptions): Promise<SubmitIProductionJobResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<SubmitIProductionJobResponse>(await this.doRPCRequest("SubmitIProductionJob", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new SubmitIProductionJobResponse({}));
  }

  async submitIProductionJob(request: SubmitIProductionJobRequest): Promise<SubmitIProductionJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.submitIProductionJobWithOptions(request, runtime);
  }

  async submitJobsWithOptions(request: SubmitJobsRequest, runtime: $Util.RuntimeOptions): Promise<SubmitJobsResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<SubmitJobsResponse>(await this.doRPCRequest("SubmitJobs", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new SubmitJobsResponse({}));
  }

  async submitJobs(request: SubmitJobsRequest): Promise<SubmitJobsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.submitJobsWithOptions(request, runtime);
  }

  async submitMCJobWithOptions(request: SubmitMCJobRequest, runtime: $Util.RuntimeOptions): Promise<SubmitMCJobResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<SubmitMCJobResponse>(await this.doRPCRequest("SubmitMCJob", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new SubmitMCJobResponse({}));
  }

  async submitMCJob(request: SubmitMCJobRequest): Promise<SubmitMCJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.submitMCJobWithOptions(request, runtime);
  }

  async submitMcuJobWithOptions(request: SubmitMcuJobRequest, runtime: $Util.RuntimeOptions): Promise<SubmitMcuJobResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<SubmitMcuJobResponse>(await this.doRPCRequest("SubmitMcuJob", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new SubmitMcuJobResponse({}));
  }

  async submitMcuJob(request: SubmitMcuJobRequest): Promise<SubmitMcuJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.submitMcuJobWithOptions(request, runtime);
  }

  async submitMediaCensorJobWithOptions(request: SubmitMediaCensorJobRequest, runtime: $Util.RuntimeOptions): Promise<SubmitMediaCensorJobResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<SubmitMediaCensorJobResponse>(await this.doRPCRequest("SubmitMediaCensorJob", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new SubmitMediaCensorJobResponse({}));
  }

  async submitMediaCensorJob(request: SubmitMediaCensorJobRequest): Promise<SubmitMediaCensorJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.submitMediaCensorJobWithOptions(request, runtime);
  }

  async submitMediaDetailJobWithOptions(request: SubmitMediaDetailJobRequest, runtime: $Util.RuntimeOptions): Promise<SubmitMediaDetailJobResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<SubmitMediaDetailJobResponse>(await this.doRPCRequest("SubmitMediaDetailJob", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new SubmitMediaDetailJobResponse({}));
  }

  async submitMediaDetailJob(request: SubmitMediaDetailJobRequest): Promise<SubmitMediaDetailJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.submitMediaDetailJobWithOptions(request, runtime);
  }

  async submitMediaFpDeleteJobWithOptions(request: SubmitMediaFpDeleteJobRequest, runtime: $Util.RuntimeOptions): Promise<SubmitMediaFpDeleteJobResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<SubmitMediaFpDeleteJobResponse>(await this.doRPCRequest("SubmitMediaFpDeleteJob", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new SubmitMediaFpDeleteJobResponse({}));
  }

  async submitMediaFpDeleteJob(request: SubmitMediaFpDeleteJobRequest): Promise<SubmitMediaFpDeleteJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.submitMediaFpDeleteJobWithOptions(request, runtime);
  }

  async submitMediaInfoJobWithOptions(request: SubmitMediaInfoJobRequest, runtime: $Util.RuntimeOptions): Promise<SubmitMediaInfoJobResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<SubmitMediaInfoJobResponse>(await this.doRPCRequest("SubmitMediaInfoJob", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new SubmitMediaInfoJobResponse({}));
  }

  async submitMediaInfoJob(request: SubmitMediaInfoJobRequest): Promise<SubmitMediaInfoJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.submitMediaInfoJobWithOptions(request, runtime);
  }

  async submitPornJobWithOptions(request: SubmitPornJobRequest, runtime: $Util.RuntimeOptions): Promise<SubmitPornJobResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<SubmitPornJobResponse>(await this.doRPCRequest("SubmitPornJob", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new SubmitPornJobResponse({}));
  }

  async submitPornJob(request: SubmitPornJobRequest): Promise<SubmitPornJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.submitPornJobWithOptions(request, runtime);
  }

  async submitSmarttagJobWithOptions(request: SubmitSmarttagJobRequest, runtime: $Util.RuntimeOptions): Promise<SubmitSmarttagJobResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<SubmitSmarttagJobResponse>(await this.doRPCRequest("SubmitSmarttagJob", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new SubmitSmarttagJobResponse({}));
  }

  async submitSmarttagJob(request: SubmitSmarttagJobRequest): Promise<SubmitSmarttagJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.submitSmarttagJobWithOptions(request, runtime);
  }

  async submitSnapshotJobWithOptions(request: SubmitSnapshotJobRequest, runtime: $Util.RuntimeOptions): Promise<SubmitSnapshotJobResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<SubmitSnapshotJobResponse>(await this.doRPCRequest("SubmitSnapshotJob", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new SubmitSnapshotJobResponse({}));
  }

  async submitSnapshotJob(request: SubmitSnapshotJobRequest): Promise<SubmitSnapshotJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.submitSnapshotJobWithOptions(request, runtime);
  }

  async submitSubtitleJobWithOptions(request: SubmitSubtitleJobRequest, runtime: $Util.RuntimeOptions): Promise<SubmitSubtitleJobResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<SubmitSubtitleJobResponse>(await this.doRPCRequest("SubmitSubtitleJob", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new SubmitSubtitleJobResponse({}));
  }

  async submitSubtitleJob(request: SubmitSubtitleJobRequest): Promise<SubmitSubtitleJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.submitSubtitleJobWithOptions(request, runtime);
  }

  async submitTagJobWithOptions(request: SubmitTagJobRequest, runtime: $Util.RuntimeOptions): Promise<SubmitTagJobResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<SubmitTagJobResponse>(await this.doRPCRequest("SubmitTagJob", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new SubmitTagJobResponse({}));
  }

  async submitTagJob(request: SubmitTagJobRequest): Promise<SubmitTagJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.submitTagJobWithOptions(request, runtime);
  }

  async submitTerrorismJobWithOptions(request: SubmitTerrorismJobRequest, runtime: $Util.RuntimeOptions): Promise<SubmitTerrorismJobResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<SubmitTerrorismJobResponse>(await this.doRPCRequest("SubmitTerrorismJob", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new SubmitTerrorismJobResponse({}));
  }

  async submitTerrorismJob(request: SubmitTerrorismJobRequest): Promise<SubmitTerrorismJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.submitTerrorismJobWithOptions(request, runtime);
  }

  async submitVideoGifJobWithOptions(request: SubmitVideoGifJobRequest, runtime: $Util.RuntimeOptions): Promise<SubmitVideoGifJobResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<SubmitVideoGifJobResponse>(await this.doRPCRequest("SubmitVideoGifJob", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new SubmitVideoGifJobResponse({}));
  }

  async submitVideoGifJob(request: SubmitVideoGifJobRequest): Promise<SubmitVideoGifJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.submitVideoGifJobWithOptions(request, runtime);
  }

  async submitVideoPoseJobWithOptions(request: SubmitVideoPoseJobRequest, runtime: $Util.RuntimeOptions): Promise<SubmitVideoPoseJobResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<SubmitVideoPoseJobResponse>(await this.doRPCRequest("SubmitVideoPoseJob", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new SubmitVideoPoseJobResponse({}));
  }

  async submitVideoPoseJob(request: SubmitVideoPoseJobRequest): Promise<SubmitVideoPoseJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.submitVideoPoseJobWithOptions(request, runtime);
  }

  async submitVideoQualityJobWithOptions(request: SubmitVideoQualityJobRequest, runtime: $Util.RuntimeOptions): Promise<SubmitVideoQualityJobResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<SubmitVideoQualityJobResponse>(await this.doRPCRequest("SubmitVideoQualityJob", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new SubmitVideoQualityJobResponse({}));
  }

  async submitVideoQualityJob(request: SubmitVideoQualityJobRequest): Promise<SubmitVideoQualityJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.submitVideoQualityJobWithOptions(request, runtime);
  }

  async submitVideoSplitJobWithOptions(request: SubmitVideoSplitJobRequest, runtime: $Util.RuntimeOptions): Promise<SubmitVideoSplitJobResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<SubmitVideoSplitJobResponse>(await this.doRPCRequest("SubmitVideoSplitJob", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new SubmitVideoSplitJobResponse({}));
  }

  async submitVideoSplitJob(request: SubmitVideoSplitJobRequest): Promise<SubmitVideoSplitJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.submitVideoSplitJobWithOptions(request, runtime);
  }

  async submitVideoSummaryJobWithOptions(request: SubmitVideoSummaryJobRequest, runtime: $Util.RuntimeOptions): Promise<SubmitVideoSummaryJobResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<SubmitVideoSummaryJobResponse>(await this.doRPCRequest("SubmitVideoSummaryJob", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new SubmitVideoSummaryJobResponse({}));
  }

  async submitVideoSummaryJob(request: SubmitVideoSummaryJobRequest): Promise<SubmitVideoSummaryJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.submitVideoSummaryJobWithOptions(request, runtime);
  }

  async tagCustomPersonWithOptions(request: TagCustomPersonRequest, runtime: $Util.RuntimeOptions): Promise<TagCustomPersonResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<TagCustomPersonResponse>(await this.doRPCRequest("TagCustomPerson", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new TagCustomPersonResponse({}));
  }

  async tagCustomPerson(request: TagCustomPersonRequest): Promise<TagCustomPersonResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.tagCustomPersonWithOptions(request, runtime);
  }

  async unbindInputBucketWithOptions(request: UnbindInputBucketRequest, runtime: $Util.RuntimeOptions): Promise<UnbindInputBucketResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<UnbindInputBucketResponse>(await this.doRPCRequest("UnbindInputBucket", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new UnbindInputBucketResponse({}));
  }

  async unbindInputBucket(request: UnbindInputBucketRequest): Promise<UnbindInputBucketResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.unbindInputBucketWithOptions(request, runtime);
  }

  async unbindOutputBucketWithOptions(request: UnbindOutputBucketRequest, runtime: $Util.RuntimeOptions): Promise<UnbindOutputBucketResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<UnbindOutputBucketResponse>(await this.doRPCRequest("UnbindOutputBucket", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new UnbindOutputBucketResponse({}));
  }

  async unbindOutputBucket(request: UnbindOutputBucketRequest): Promise<UnbindOutputBucketResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.unbindOutputBucketWithOptions(request, runtime);
  }

  async unregisterCustomFaceWithOptions(request: UnregisterCustomFaceRequest, runtime: $Util.RuntimeOptions): Promise<UnregisterCustomFaceResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<UnregisterCustomFaceResponse>(await this.doRPCRequest("UnregisterCustomFace", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new UnregisterCustomFaceResponse({}));
  }

  async unregisterCustomFace(request: UnregisterCustomFaceRequest): Promise<UnregisterCustomFaceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.unregisterCustomFaceWithOptions(request, runtime);
  }

  async updateAsrPipelineWithOptions(request: UpdateAsrPipelineRequest, runtime: $Util.RuntimeOptions): Promise<UpdateAsrPipelineResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<UpdateAsrPipelineResponse>(await this.doRPCRequest("UpdateAsrPipeline", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new UpdateAsrPipelineResponse({}));
  }

  async updateAsrPipeline(request: UpdateAsrPipelineRequest): Promise<UpdateAsrPipelineResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateAsrPipelineWithOptions(request, runtime);
  }

  async updateCategoryNameWithOptions(request: UpdateCategoryNameRequest, runtime: $Util.RuntimeOptions): Promise<UpdateCategoryNameResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<UpdateCategoryNameResponse>(await this.doRPCRequest("UpdateCategoryName", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new UpdateCategoryNameResponse({}));
  }

  async updateCategoryName(request: UpdateCategoryNameRequest): Promise<UpdateCategoryNameResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateCategoryNameWithOptions(request, runtime);
  }

  async updateCensorPipelineWithOptions(request: UpdateCensorPipelineRequest, runtime: $Util.RuntimeOptions): Promise<UpdateCensorPipelineResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<UpdateCensorPipelineResponse>(await this.doRPCRequest("UpdateCensorPipeline", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new UpdateCensorPipelineResponse({}));
  }

  async updateCensorPipeline(request: UpdateCensorPipelineRequest): Promise<UpdateCensorPipelineResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateCensorPipelineWithOptions(request, runtime);
  }

  async updateCoverPipelineWithOptions(request: UpdateCoverPipelineRequest, runtime: $Util.RuntimeOptions): Promise<UpdateCoverPipelineResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<UpdateCoverPipelineResponse>(await this.doRPCRequest("UpdateCoverPipeline", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new UpdateCoverPipelineResponse({}));
  }

  async updateCoverPipeline(request: UpdateCoverPipelineRequest): Promise<UpdateCoverPipelineResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateCoverPipelineWithOptions(request, runtime);
  }

  async updateMCTemplateWithOptions(request: UpdateMCTemplateRequest, runtime: $Util.RuntimeOptions): Promise<UpdateMCTemplateResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<UpdateMCTemplateResponse>(await this.doRPCRequest("UpdateMCTemplate", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new UpdateMCTemplateResponse({}));
  }

  async updateMCTemplate(request: UpdateMCTemplateRequest): Promise<UpdateMCTemplateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateMCTemplateWithOptions(request, runtime);
  }

  async updateMcuTemplateWithOptions(request: UpdateMcuTemplateRequest, runtime: $Util.RuntimeOptions): Promise<UpdateMcuTemplateResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<UpdateMcuTemplateResponse>(await this.doRPCRequest("UpdateMcuTemplate", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new UpdateMcuTemplateResponse({}));
  }

  async updateMcuTemplate(request: UpdateMcuTemplateRequest): Promise<UpdateMcuTemplateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateMcuTemplateWithOptions(request, runtime);
  }

  async updateMediaWithOptions(request: UpdateMediaRequest, runtime: $Util.RuntimeOptions): Promise<UpdateMediaResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<UpdateMediaResponse>(await this.doRPCRequest("UpdateMedia", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new UpdateMediaResponse({}));
  }

  async updateMedia(request: UpdateMediaRequest): Promise<UpdateMediaResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateMediaWithOptions(request, runtime);
  }

  async updateMediaCategoryWithOptions(request: UpdateMediaCategoryRequest, runtime: $Util.RuntimeOptions): Promise<UpdateMediaCategoryResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<UpdateMediaCategoryResponse>(await this.doRPCRequest("UpdateMediaCategory", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new UpdateMediaCategoryResponse({}));
  }

  async updateMediaCategory(request: UpdateMediaCategoryRequest): Promise<UpdateMediaCategoryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateMediaCategoryWithOptions(request, runtime);
  }

  async updateMediaCoverWithOptions(request: UpdateMediaCoverRequest, runtime: $Util.RuntimeOptions): Promise<UpdateMediaCoverResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<UpdateMediaCoverResponse>(await this.doRPCRequest("UpdateMediaCover", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new UpdateMediaCoverResponse({}));
  }

  async updateMediaCover(request: UpdateMediaCoverRequest): Promise<UpdateMediaCoverResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateMediaCoverWithOptions(request, runtime);
  }

  async updateMediaPublishStateWithOptions(request: UpdateMediaPublishStateRequest, runtime: $Util.RuntimeOptions): Promise<UpdateMediaPublishStateResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<UpdateMediaPublishStateResponse>(await this.doRPCRequest("UpdateMediaPublishState", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new UpdateMediaPublishStateResponse({}));
  }

  async updateMediaPublishState(request: UpdateMediaPublishStateRequest): Promise<UpdateMediaPublishStateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateMediaPublishStateWithOptions(request, runtime);
  }

  async updateMediaWorkflowWithOptions(request: UpdateMediaWorkflowRequest, runtime: $Util.RuntimeOptions): Promise<UpdateMediaWorkflowResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<UpdateMediaWorkflowResponse>(await this.doRPCRequest("UpdateMediaWorkflow", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new UpdateMediaWorkflowResponse({}));
  }

  async updateMediaWorkflow(request: UpdateMediaWorkflowRequest): Promise<UpdateMediaWorkflowResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateMediaWorkflowWithOptions(request, runtime);
  }

  async updateMediaWorkflowTriggerModeWithOptions(request: UpdateMediaWorkflowTriggerModeRequest, runtime: $Util.RuntimeOptions): Promise<UpdateMediaWorkflowTriggerModeResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<UpdateMediaWorkflowTriggerModeResponse>(await this.doRPCRequest("UpdateMediaWorkflowTriggerMode", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new UpdateMediaWorkflowTriggerModeResponse({}));
  }

  async updateMediaWorkflowTriggerMode(request: UpdateMediaWorkflowTriggerModeRequest): Promise<UpdateMediaWorkflowTriggerModeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateMediaWorkflowTriggerModeWithOptions(request, runtime);
  }

  async updatePipelineWithOptions(request: UpdatePipelineRequest, runtime: $Util.RuntimeOptions): Promise<UpdatePipelineResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<UpdatePipelineResponse>(await this.doRPCRequest("UpdatePipeline", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new UpdatePipelineResponse({}));
  }

  async updatePipeline(request: UpdatePipelineRequest): Promise<UpdatePipelineResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updatePipelineWithOptions(request, runtime);
  }

  async updatePornPipelineWithOptions(request: UpdatePornPipelineRequest, runtime: $Util.RuntimeOptions): Promise<UpdatePornPipelineResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<UpdatePornPipelineResponse>(await this.doRPCRequest("UpdatePornPipeline", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new UpdatePornPipelineResponse({}));
  }

  async updatePornPipeline(request: UpdatePornPipelineRequest): Promise<UpdatePornPipelineResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updatePornPipelineWithOptions(request, runtime);
  }

  async updateSmarttagTemplateWithOptions(request: UpdateSmarttagTemplateRequest, runtime: $Util.RuntimeOptions): Promise<UpdateSmarttagTemplateResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<UpdateSmarttagTemplateResponse>(await this.doRPCRequest("UpdateSmarttagTemplate", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new UpdateSmarttagTemplateResponse({}));
  }

  async updateSmarttagTemplate(request: UpdateSmarttagTemplateRequest): Promise<UpdateSmarttagTemplateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateSmarttagTemplateWithOptions(request, runtime);
  }

  async updateTemplateWithOptions(request: UpdateTemplateRequest, runtime: $Util.RuntimeOptions): Promise<UpdateTemplateResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<UpdateTemplateResponse>(await this.doRPCRequest("UpdateTemplate", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new UpdateTemplateResponse({}));
  }

  async updateTemplate(request: UpdateTemplateRequest): Promise<UpdateTemplateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateTemplateWithOptions(request, runtime);
  }

  async updateTerrorismPipelineWithOptions(request: UpdateTerrorismPipelineRequest, runtime: $Util.RuntimeOptions): Promise<UpdateTerrorismPipelineResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<UpdateTerrorismPipelineResponse>(await this.doRPCRequest("UpdateTerrorismPipeline", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new UpdateTerrorismPipelineResponse({}));
  }

  async updateTerrorismPipeline(request: UpdateTerrorismPipelineRequest): Promise<UpdateTerrorismPipelineResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateTerrorismPipelineWithOptions(request, runtime);
  }

  async updateWaterMarkTemplateWithOptions(request: UpdateWaterMarkTemplateRequest, runtime: $Util.RuntimeOptions): Promise<UpdateWaterMarkTemplateResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<UpdateWaterMarkTemplateResponse>(await this.doRPCRequest("UpdateWaterMarkTemplate", "2014-06-18", "HTTPS", "POST", "AK", "json", req, runtime), new UpdateWaterMarkTemplateResponse({}));
  }

  async updateWaterMarkTemplate(request: UpdateWaterMarkTemplateRequest): Promise<UpdateWaterMarkTemplateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateWaterMarkTemplateWithOptions(request, runtime);
  }

}
