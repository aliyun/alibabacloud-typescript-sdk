// This file is auto-generated, don't edit it
/**
 *
 */
import Util, * as $Util from '@alicloud/tea-util';
import OpenApi, * as $OpenApi from '@alicloud/openapi-client';
import OpenApiUtil from '@alicloud/openapi-util';
import EndpointUtil from '@alicloud/endpoint-util';
import * as $tea from '@alicloud/tea-typescript';

export class AcceptInquiredSystemEventRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  eventId?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      eventId: 'EventId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      eventId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AcceptInquiredSystemEventResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AcceptInquiredSystemEventResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: AcceptInquiredSystemEventResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: AcceptInquiredSystemEventResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ActivateRouterInterfaceRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  routerInterfaceId?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      routerInterfaceId: 'RouterInterfaceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      routerInterfaceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ActivateRouterInterfaceResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ActivateRouterInterfaceResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ActivateRouterInterfaceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ActivateRouterInterfaceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddBandwidthPackageIpsRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  bandwidthPackageId?: string;
  ipCount?: string;
  clientToken?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      bandwidthPackageId: 'BandwidthPackageId',
      ipCount: 'IpCount',
      clientToken: 'ClientToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      bandwidthPackageId: 'string',
      ipCount: 'string',
      clientToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddBandwidthPackageIpsResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddBandwidthPackageIpsResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: AddBandwidthPackageIpsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: AddBandwidthPackageIpsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddTagsRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  resourceType?: string;
  resourceId?: string;
  tag?: AddTagsRequestTag[];
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      resourceType: 'ResourceType',
      resourceId: 'ResourceId',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      resourceType: 'string',
      resourceId: 'string',
      tag: { 'type': 'array', 'itemType': AddTagsRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddTagsResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddTagsResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: AddTagsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: AddTagsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AllocateDedicatedHostsRequest extends $tea.Model {
  networkAttributes?: AllocateDedicatedHostsRequestNetworkAttributes;
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  tag?: AllocateDedicatedHostsRequestTag[];
  resourceGroupId?: string;
  zoneId?: string;
  dedicatedHostName?: string;
  dedicatedHostClusterId?: string;
  dedicatedHostType?: string;
  actionOnMaintenance?: string;
  description?: string;
  autoPlacement?: string;
  cpuOverCommitRatio?: number;
  chargeType?: string;
  quantity?: number;
  period?: number;
  periodUnit?: string;
  autoRenew?: boolean;
  autoRenewPeriod?: number;
  autoReleaseTime?: string;
  clientToken?: string;
  static names(): { [key: string]: string } {
    return {
      networkAttributes: 'NetworkAttributes',
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      tag: 'Tag',
      resourceGroupId: 'ResourceGroupId',
      zoneId: 'ZoneId',
      dedicatedHostName: 'DedicatedHostName',
      dedicatedHostClusterId: 'DedicatedHostClusterId',
      dedicatedHostType: 'DedicatedHostType',
      actionOnMaintenance: 'ActionOnMaintenance',
      description: 'Description',
      autoPlacement: 'AutoPlacement',
      cpuOverCommitRatio: 'CpuOverCommitRatio',
      chargeType: 'ChargeType',
      quantity: 'Quantity',
      period: 'Period',
      periodUnit: 'PeriodUnit',
      autoRenew: 'AutoRenew',
      autoRenewPeriod: 'AutoRenewPeriod',
      autoReleaseTime: 'AutoReleaseTime',
      clientToken: 'ClientToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      networkAttributes: AllocateDedicatedHostsRequestNetworkAttributes,
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      tag: { 'type': 'array', 'itemType': AllocateDedicatedHostsRequestTag },
      resourceGroupId: 'string',
      zoneId: 'string',
      dedicatedHostName: 'string',
      dedicatedHostClusterId: 'string',
      dedicatedHostType: 'string',
      actionOnMaintenance: 'string',
      description: 'string',
      autoPlacement: 'string',
      cpuOverCommitRatio: 'number',
      chargeType: 'string',
      quantity: 'number',
      period: 'number',
      periodUnit: 'string',
      autoRenew: 'boolean',
      autoRenewPeriod: 'number',
      autoReleaseTime: 'string',
      clientToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AllocateDedicatedHostsResponseBody extends $tea.Model {
  requestId?: string;
  dedicatedHostIdSets?: string[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      dedicatedHostIdSets: 'DedicatedHostIdSets',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      dedicatedHostIdSets: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AllocateDedicatedHostsResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: AllocateDedicatedHostsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: AllocateDedicatedHostsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AllocateEipAddressRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  bandwidth?: string;
  ISP?: string;
  internetChargeType?: string;
  activityId?: number;
  ownerAccount?: string;
  clientToken?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      bandwidth: 'Bandwidth',
      ISP: 'ISP',
      internetChargeType: 'InternetChargeType',
      activityId: 'ActivityId',
      ownerAccount: 'OwnerAccount',
      clientToken: 'ClientToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      bandwidth: 'string',
      ISP: 'string',
      internetChargeType: 'string',
      activityId: 'number',
      ownerAccount: 'string',
      clientToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AllocateEipAddressResponseBody extends $tea.Model {
  requestId?: string;
  allocationId?: string;
  eipAddress?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      allocationId: 'AllocationId',
      eipAddress: 'EipAddress',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      allocationId: 'string',
      eipAddress: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AllocateEipAddressResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: AllocateEipAddressResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: AllocateEipAddressResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AllocatePublicIpAddressRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  instanceId?: string;
  ipAddress?: string;
  vlanId?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      instanceId: 'InstanceId',
      ipAddress: 'IpAddress',
      vlanId: 'VlanId',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      instanceId: 'string',
      ipAddress: 'string',
      vlanId: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AllocatePublicIpAddressResponseBody extends $tea.Model {
  requestId?: string;
  ipAddress?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      ipAddress: 'IpAddress',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      ipAddress: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AllocatePublicIpAddressResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: AllocatePublicIpAddressResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: AllocatePublicIpAddressResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApplyAutoSnapshotPolicyRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  autoSnapshotPolicyId?: string;
  diskIds?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'regionId',
      autoSnapshotPolicyId: 'autoSnapshotPolicyId',
      diskIds: 'diskIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      autoSnapshotPolicyId: 'string',
      diskIds: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApplyAutoSnapshotPolicyResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApplyAutoSnapshotPolicyResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ApplyAutoSnapshotPolicyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ApplyAutoSnapshotPolicyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AssignIpv6AddressesRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  networkInterfaceId?: string;
  ipv6AddressCount?: number;
  ipv6Address?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      networkInterfaceId: 'NetworkInterfaceId',
      ipv6AddressCount: 'Ipv6AddressCount',
      ipv6Address: 'Ipv6Address',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      networkInterfaceId: 'string',
      ipv6AddressCount: 'number',
      ipv6Address: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AssignIpv6AddressesResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AssignIpv6AddressesResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: AssignIpv6AddressesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: AssignIpv6AddressesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AssignPrivateIpAddressesRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  networkInterfaceId?: string;
  secondaryPrivateIpAddressCount?: number;
  clientToken?: string;
  privateIpAddress?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      networkInterfaceId: 'NetworkInterfaceId',
      secondaryPrivateIpAddressCount: 'SecondaryPrivateIpAddressCount',
      clientToken: 'ClientToken',
      privateIpAddress: 'PrivateIpAddress',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      networkInterfaceId: 'string',
      secondaryPrivateIpAddressCount: 'number',
      clientToken: 'string',
      privateIpAddress: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AssignPrivateIpAddressesResponseBody extends $tea.Model {
  requestId?: string;
  assignedPrivateIpAddressesSet?: AssignPrivateIpAddressesResponseBodyAssignedPrivateIpAddressesSet;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      assignedPrivateIpAddressesSet: 'AssignedPrivateIpAddressesSet',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      assignedPrivateIpAddressesSet: AssignPrivateIpAddressesResponseBodyAssignedPrivateIpAddressesSet,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AssignPrivateIpAddressesResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: AssignPrivateIpAddressesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: AssignPrivateIpAddressesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AssociateEipAddressRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  allocationId?: string;
  instanceId?: string;
  ownerAccount?: string;
  instanceType?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      allocationId: 'AllocationId',
      instanceId: 'InstanceId',
      ownerAccount: 'OwnerAccount',
      instanceType: 'InstanceType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      allocationId: 'string',
      instanceId: 'string',
      ownerAccount: 'string',
      instanceType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AssociateEipAddressResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AssociateEipAddressResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: AssociateEipAddressResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: AssociateEipAddressResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AssociateHaVipRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  clientToken?: string;
  regionId?: string;
  haVipId?: string;
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      clientToken: 'ClientToken',
      regionId: 'RegionId',
      haVipId: 'HaVipId',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      clientToken: 'string',
      regionId: 'string',
      haVipId: 'string',
      instanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AssociateHaVipResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AssociateHaVipResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: AssociateHaVipResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: AssociateHaVipResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AttachClassicLinkVpcRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  instanceId?: string;
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      instanceId: 'InstanceId',
      vpcId: 'VpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      instanceId: 'string',
      vpcId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AttachClassicLinkVpcResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AttachClassicLinkVpcResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: AttachClassicLinkVpcResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: AttachClassicLinkVpcResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AttachDiskRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  instanceId?: string;
  diskId?: string;
  device?: string;
  deleteWithInstance?: boolean;
  bootable?: boolean;
  password?: string;
  keyPairName?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      instanceId: 'InstanceId',
      diskId: 'DiskId',
      device: 'Device',
      deleteWithInstance: 'DeleteWithInstance',
      bootable: 'Bootable',
      password: 'Password',
      keyPairName: 'KeyPairName',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      instanceId: 'string',
      diskId: 'string',
      device: 'string',
      deleteWithInstance: 'boolean',
      bootable: 'boolean',
      password: 'string',
      keyPairName: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AttachDiskResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AttachDiskResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: AttachDiskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: AttachDiskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AttachInstanceRamRoleRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  ramRoleName?: string;
  instanceIds?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      ramRoleName: 'RamRoleName',
      instanceIds: 'InstanceIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      ramRoleName: 'string',
      instanceIds: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AttachInstanceRamRoleResponseBody extends $tea.Model {
  attachInstanceRamRoleResults?: AttachInstanceRamRoleResponseBodyAttachInstanceRamRoleResults[];
  totalCount?: number;
  ramRoleName?: string;
  requestId?: string;
  failCount?: number;
  static names(): { [key: string]: string } {
    return {
      attachInstanceRamRoleResults: 'AttachInstanceRamRoleResults',
      totalCount: 'TotalCount',
      ramRoleName: 'RamRoleName',
      requestId: 'RequestId',
      failCount: 'FailCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attachInstanceRamRoleResults: { 'type': 'array', 'itemType': AttachInstanceRamRoleResponseBodyAttachInstanceRamRoleResults },
      totalCount: 'number',
      ramRoleName: 'string',
      requestId: 'string',
      failCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AttachInstanceRamRoleResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: AttachInstanceRamRoleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: AttachInstanceRamRoleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AttachKeyPairRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  keyPairName?: string;
  instanceIds?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      keyPairName: 'KeyPairName',
      instanceIds: 'InstanceIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      keyPairName: 'string',
      instanceIds: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AttachKeyPairResponseBody extends $tea.Model {
  keyPairName?: string;
  totalCount?: string;
  requestId?: string;
  results?: AttachKeyPairResponseBodyResults[];
  failCount?: string;
  static names(): { [key: string]: string } {
    return {
      keyPairName: 'KeyPairName',
      totalCount: 'TotalCount',
      requestId: 'RequestId',
      results: 'Results',
      failCount: 'FailCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      keyPairName: 'string',
      totalCount: 'string',
      requestId: 'string',
      results: { 'type': 'array', 'itemType': AttachKeyPairResponseBodyResults },
      failCount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AttachKeyPairResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: AttachKeyPairResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: AttachKeyPairResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AttachNetworkInterfaceRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  networkInterfaceId?: string;
  instanceId?: string;
  trunkNetworkInstanceId?: string;
  waitForNetworkConfigurationReady?: boolean;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      networkInterfaceId: 'NetworkInterfaceId',
      instanceId: 'InstanceId',
      trunkNetworkInstanceId: 'TrunkNetworkInstanceId',
      waitForNetworkConfigurationReady: 'WaitForNetworkConfigurationReady',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      networkInterfaceId: 'string',
      instanceId: 'string',
      trunkNetworkInstanceId: 'string',
      waitForNetworkConfigurationReady: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AttachNetworkInterfaceResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AttachNetworkInterfaceResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: AttachNetworkInterfaceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: AttachNetworkInterfaceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AuthorizeSecurityGroupRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  securityGroupId?: string;
  ipProtocol?: string;
  portRange?: string;
  sourceGroupId?: string;
  sourceGroupOwnerId?: number;
  sourceGroupOwnerAccount?: string;
  sourceCidrIp?: string;
  ipv6SourceCidrIp?: string;
  sourcePortRange?: string;
  destCidrIp?: string;
  ipv6DestCidrIp?: string;
  policy?: string;
  priority?: string;
  nicType?: string;
  clientToken?: string;
  description?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      securityGroupId: 'SecurityGroupId',
      ipProtocol: 'IpProtocol',
      portRange: 'PortRange',
      sourceGroupId: 'SourceGroupId',
      sourceGroupOwnerId: 'SourceGroupOwnerId',
      sourceGroupOwnerAccount: 'SourceGroupOwnerAccount',
      sourceCidrIp: 'SourceCidrIp',
      ipv6SourceCidrIp: 'Ipv6SourceCidrIp',
      sourcePortRange: 'SourcePortRange',
      destCidrIp: 'DestCidrIp',
      ipv6DestCidrIp: 'Ipv6DestCidrIp',
      policy: 'Policy',
      priority: 'Priority',
      nicType: 'NicType',
      clientToken: 'ClientToken',
      description: 'Description',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      securityGroupId: 'string',
      ipProtocol: 'string',
      portRange: 'string',
      sourceGroupId: 'string',
      sourceGroupOwnerId: 'number',
      sourceGroupOwnerAccount: 'string',
      sourceCidrIp: 'string',
      ipv6SourceCidrIp: 'string',
      sourcePortRange: 'string',
      destCidrIp: 'string',
      ipv6DestCidrIp: 'string',
      policy: 'string',
      priority: 'string',
      nicType: 'string',
      clientToken: 'string',
      description: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AuthorizeSecurityGroupResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AuthorizeSecurityGroupResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: AuthorizeSecurityGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: AuthorizeSecurityGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AuthorizeSecurityGroupEgressRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  securityGroupId?: string;
  ipProtocol?: string;
  portRange?: string;
  destGroupId?: string;
  destGroupOwnerId?: number;
  destGroupOwnerAccount?: string;
  destCidrIp?: string;
  ipv6DestCidrIp?: string;
  sourceCidrIp?: string;
  ipv6SourceCidrIp?: string;
  sourcePortRange?: string;
  policy?: string;
  priority?: string;
  nicType?: string;
  clientToken?: string;
  description?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      securityGroupId: 'SecurityGroupId',
      ipProtocol: 'IpProtocol',
      portRange: 'PortRange',
      destGroupId: 'DestGroupId',
      destGroupOwnerId: 'DestGroupOwnerId',
      destGroupOwnerAccount: 'DestGroupOwnerAccount',
      destCidrIp: 'DestCidrIp',
      ipv6DestCidrIp: 'Ipv6DestCidrIp',
      sourceCidrIp: 'SourceCidrIp',
      ipv6SourceCidrIp: 'Ipv6SourceCidrIp',
      sourcePortRange: 'SourcePortRange',
      policy: 'Policy',
      priority: 'Priority',
      nicType: 'NicType',
      clientToken: 'ClientToken',
      description: 'Description',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      securityGroupId: 'string',
      ipProtocol: 'string',
      portRange: 'string',
      destGroupId: 'string',
      destGroupOwnerId: 'number',
      destGroupOwnerAccount: 'string',
      destCidrIp: 'string',
      ipv6DestCidrIp: 'string',
      sourceCidrIp: 'string',
      ipv6SourceCidrIp: 'string',
      sourcePortRange: 'string',
      policy: 'string',
      priority: 'string',
      nicType: 'string',
      clientToken: 'string',
      description: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AuthorizeSecurityGroupEgressResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AuthorizeSecurityGroupEgressResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: AuthorizeSecurityGroupEgressResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: AuthorizeSecurityGroupEgressResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelAutoSnapshotPolicyRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  diskIds?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'regionId',
      diskIds: 'diskIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      diskIds: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelAutoSnapshotPolicyResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelAutoSnapshotPolicyResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CancelAutoSnapshotPolicyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CancelAutoSnapshotPolicyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelCopyImageRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  imageId?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      imageId: 'ImageId',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      imageId: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelCopyImageResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelCopyImageResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CancelCopyImageResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CancelCopyImageResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelPhysicalConnectionRequest extends $tea.Model {
  regionId?: string;
  physicalConnectionId?: string;
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  clientToken?: string;
  ownerAccount?: string;
  userCidr?: string;
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
      physicalConnectionId: 'PhysicalConnectionId',
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      clientToken: 'ClientToken',
      ownerAccount: 'OwnerAccount',
      userCidr: 'UserCidr',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
      physicalConnectionId: 'string',
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      clientToken: 'string',
      ownerAccount: 'string',
      userCidr: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelPhysicalConnectionResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelPhysicalConnectionResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CancelPhysicalConnectionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CancelPhysicalConnectionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelSimulatedSystemEventsRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  eventId?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      eventId: 'EventId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      eventId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelSimulatedSystemEventsResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelSimulatedSystemEventsResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CancelSimulatedSystemEventsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CancelSimulatedSystemEventsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelTaskRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  taskId?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      taskId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelTaskResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelTaskResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CancelTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CancelTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ConnectRouterInterfaceRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  routerInterfaceId?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      routerInterfaceId: 'RouterInterfaceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      routerInterfaceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ConnectRouterInterfaceResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ConnectRouterInterfaceResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ConnectRouterInterfaceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ConnectRouterInterfaceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ConvertNatPublicIpToEipRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  instanceId?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      instanceId: 'InstanceId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      instanceId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ConvertNatPublicIpToEipResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ConvertNatPublicIpToEipResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ConvertNatPublicIpToEipResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ConvertNatPublicIpToEipResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CopyImageRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  destinationImageName?: string;
  destinationDescription?: string;
  imageId?: string;
  regionId?: string;
  destinationRegionId?: string;
  ownerAccount?: string;
  encrypted?: boolean;
  KMSKeyId?: string;
  encryptAlgorithm?: string;
  resourceGroupId?: string;
  tag?: CopyImageRequestTag[];
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      destinationImageName: 'DestinationImageName',
      destinationDescription: 'DestinationDescription',
      imageId: 'ImageId',
      regionId: 'RegionId',
      destinationRegionId: 'DestinationRegionId',
      ownerAccount: 'OwnerAccount',
      encrypted: 'Encrypted',
      KMSKeyId: 'KMSKeyId',
      encryptAlgorithm: 'EncryptAlgorithm',
      resourceGroupId: 'ResourceGroupId',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      destinationImageName: 'string',
      destinationDescription: 'string',
      imageId: 'string',
      regionId: 'string',
      destinationRegionId: 'string',
      ownerAccount: 'string',
      encrypted: 'boolean',
      KMSKeyId: 'string',
      encryptAlgorithm: 'string',
      resourceGroupId: 'string',
      tag: { 'type': 'array', 'itemType': CopyImageRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CopyImageResponseBody extends $tea.Model {
  requestId?: string;
  imageId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      imageId: 'ImageId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      imageId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CopyImageResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CopyImageResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CopyImageResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CopySnapshotRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  resourceGroupId?: string;
  tag?: CopySnapshotRequestTag[];
  regionId?: string;
  destinationRegionId?: string;
  snapshotId?: string;
  destinationSnapshotName?: string;
  destinationSnapshotDescription?: string;
  retentionDays?: number;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      resourceGroupId: 'ResourceGroupId',
      tag: 'Tag',
      regionId: 'RegionId',
      destinationRegionId: 'DestinationRegionId',
      snapshotId: 'SnapshotId',
      destinationSnapshotName: 'DestinationSnapshotName',
      destinationSnapshotDescription: 'DestinationSnapshotDescription',
      retentionDays: 'RetentionDays',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      resourceGroupId: 'string',
      tag: { 'type': 'array', 'itemType': CopySnapshotRequestTag },
      regionId: 'string',
      destinationRegionId: 'string',
      snapshotId: 'string',
      destinationSnapshotName: 'string',
      destinationSnapshotDescription: 'string',
      retentionDays: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CopySnapshotResponseBody extends $tea.Model {
  snapshotId?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      snapshotId: 'SnapshotId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      snapshotId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CopySnapshotResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CopySnapshotResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CopySnapshotResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAutoProvisioningGroupRequest extends $tea.Model {
  launchConfiguration?: CreateAutoProvisioningGroupRequestLaunchConfiguration;
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  resourceGroupId?: string;
  autoProvisioningGroupName?: string;
  autoProvisioningGroupType?: string;
  spotAllocationStrategy?: string;
  spotInstanceInterruptionBehavior?: string;
  spotInstancePoolsToUseCount?: number;
  payAsYouGoAllocationStrategy?: string;
  excessCapacityTerminationPolicy?: string;
  validFrom?: string;
  validUntil?: string;
  terminateInstancesWithExpiration?: boolean;
  terminateInstances?: boolean;
  maxSpotPrice?: number;
  totalTargetCapacity?: string;
  payAsYouGoTargetCapacity?: string;
  spotTargetCapacity?: string;
  defaultTargetCapacityType?: string;
  launchTemplateId?: string;
  launchTemplateVersion?: string;
  description?: string;
  launchTemplateConfig?: CreateAutoProvisioningGroupRequestLaunchTemplateConfig[];
  systemDiskConfig?: CreateAutoProvisioningGroupRequestSystemDiskConfig[];
  dataDiskConfig?: CreateAutoProvisioningGroupRequestDataDiskConfig[];
  static names(): { [key: string]: string } {
    return {
      launchConfiguration: 'LaunchConfiguration',
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      autoProvisioningGroupName: 'AutoProvisioningGroupName',
      autoProvisioningGroupType: 'AutoProvisioningGroupType',
      spotAllocationStrategy: 'SpotAllocationStrategy',
      spotInstanceInterruptionBehavior: 'SpotInstanceInterruptionBehavior',
      spotInstancePoolsToUseCount: 'SpotInstancePoolsToUseCount',
      payAsYouGoAllocationStrategy: 'PayAsYouGoAllocationStrategy',
      excessCapacityTerminationPolicy: 'ExcessCapacityTerminationPolicy',
      validFrom: 'ValidFrom',
      validUntil: 'ValidUntil',
      terminateInstancesWithExpiration: 'TerminateInstancesWithExpiration',
      terminateInstances: 'TerminateInstances',
      maxSpotPrice: 'MaxSpotPrice',
      totalTargetCapacity: 'TotalTargetCapacity',
      payAsYouGoTargetCapacity: 'PayAsYouGoTargetCapacity',
      spotTargetCapacity: 'SpotTargetCapacity',
      defaultTargetCapacityType: 'DefaultTargetCapacityType',
      launchTemplateId: 'LaunchTemplateId',
      launchTemplateVersion: 'LaunchTemplateVersion',
      description: 'Description',
      launchTemplateConfig: 'LaunchTemplateConfig',
      systemDiskConfig: 'SystemDiskConfig',
      dataDiskConfig: 'DataDiskConfig',
    };
  }

  static types(): { [key: string]: any } {
    return {
      launchConfiguration: CreateAutoProvisioningGroupRequestLaunchConfiguration,
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      autoProvisioningGroupName: 'string',
      autoProvisioningGroupType: 'string',
      spotAllocationStrategy: 'string',
      spotInstanceInterruptionBehavior: 'string',
      spotInstancePoolsToUseCount: 'number',
      payAsYouGoAllocationStrategy: 'string',
      excessCapacityTerminationPolicy: 'string',
      validFrom: 'string',
      validUntil: 'string',
      terminateInstancesWithExpiration: 'boolean',
      terminateInstances: 'boolean',
      maxSpotPrice: 'number',
      totalTargetCapacity: 'string',
      payAsYouGoTargetCapacity: 'string',
      spotTargetCapacity: 'string',
      defaultTargetCapacityType: 'string',
      launchTemplateId: 'string',
      launchTemplateVersion: 'string',
      description: 'string',
      launchTemplateConfig: { 'type': 'array', 'itemType': CreateAutoProvisioningGroupRequestLaunchTemplateConfig },
      systemDiskConfig: { 'type': 'array', 'itemType': CreateAutoProvisioningGroupRequestSystemDiskConfig },
      dataDiskConfig: { 'type': 'array', 'itemType': CreateAutoProvisioningGroupRequestDataDiskConfig },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAutoProvisioningGroupResponseBody extends $tea.Model {
  requestId?: string;
  autoProvisioningGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      autoProvisioningGroupId: 'AutoProvisioningGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      autoProvisioningGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAutoProvisioningGroupResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateAutoProvisioningGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateAutoProvisioningGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAutoSnapshotPolicyRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  autoSnapshotPolicyName?: string;
  timePoints?: string;
  repeatWeekdays?: string;
  retentionDays?: number;
  enableCrossRegionCopy?: boolean;
  targetCopyRegions?: string;
  copiedSnapshotsRetentionDays?: number;
  tag?: CreateAutoSnapshotPolicyRequestTag[];
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'regionId',
      autoSnapshotPolicyName: 'autoSnapshotPolicyName',
      timePoints: 'timePoints',
      repeatWeekdays: 'repeatWeekdays',
      retentionDays: 'retentionDays',
      enableCrossRegionCopy: 'EnableCrossRegionCopy',
      targetCopyRegions: 'TargetCopyRegions',
      copiedSnapshotsRetentionDays: 'CopiedSnapshotsRetentionDays',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      autoSnapshotPolicyName: 'string',
      timePoints: 'string',
      repeatWeekdays: 'string',
      retentionDays: 'number',
      enableCrossRegionCopy: 'boolean',
      targetCopyRegions: 'string',
      copiedSnapshotsRetentionDays: 'number',
      tag: { 'type': 'array', 'itemType': CreateAutoSnapshotPolicyRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAutoSnapshotPolicyResponseBody extends $tea.Model {
  requestId?: string;
  autoSnapshotPolicyId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      autoSnapshotPolicyId: 'AutoSnapshotPolicyId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      autoSnapshotPolicyId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAutoSnapshotPolicyResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateAutoSnapshotPolicyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateAutoSnapshotPolicyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCapacityReservationRequest extends $tea.Model {
  privatePoolOptions?: CreateCapacityReservationRequestPrivatePoolOptions;
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  chargeType?: string;
  period?: number;
  periodUnit?: string;
  clientToken?: string;
  description?: string;
  instanceAmount?: number;
  instanceType?: string;
  startTime?: string;
  endTime?: string;
  endTimeType?: string;
  platform?: string;
  instanceChargeType?: string;
  packageType?: string;
  resourceType?: string;
  efficientStatus?: number;
  timeSlot?: string;
  zoneId?: string[];
  static names(): { [key: string]: string } {
    return {
      privatePoolOptions: 'PrivatePoolOptions',
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      chargeType: 'ChargeType',
      period: 'Period',
      periodUnit: 'PeriodUnit',
      clientToken: 'ClientToken',
      description: 'Description',
      instanceAmount: 'InstanceAmount',
      instanceType: 'InstanceType',
      startTime: 'StartTime',
      endTime: 'EndTime',
      endTimeType: 'EndTimeType',
      platform: 'Platform',
      instanceChargeType: 'InstanceChargeType',
      packageType: 'PackageType',
      resourceType: 'ResourceType',
      efficientStatus: 'EfficientStatus',
      timeSlot: 'TimeSlot',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      privatePoolOptions: CreateCapacityReservationRequestPrivatePoolOptions,
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      chargeType: 'string',
      period: 'number',
      periodUnit: 'string',
      clientToken: 'string',
      description: 'string',
      instanceAmount: 'number',
      instanceType: 'string',
      startTime: 'string',
      endTime: 'string',
      endTimeType: 'string',
      platform: 'string',
      instanceChargeType: 'string',
      packageType: 'string',
      resourceType: 'string',
      efficientStatus: 'number',
      timeSlot: 'string',
      zoneId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCapacityReservationResponseBody extends $tea.Model {
  requestId?: string;
  privatePoolOptionsId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      privatePoolOptionsId: 'PrivatePoolOptionsId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      privatePoolOptionsId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCapacityReservationResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateCapacityReservationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateCapacityReservationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCommandRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  name?: string;
  description?: string;
  type?: string;
  commandContent?: string;
  workingDir?: string;
  timeout?: number;
  enableParameter?: boolean;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      name: 'Name',
      description: 'Description',
      type: 'Type',
      commandContent: 'CommandContent',
      workingDir: 'WorkingDir',
      timeout: 'Timeout',
      enableParameter: 'EnableParameter',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      name: 'string',
      description: 'string',
      type: 'string',
      commandContent: 'string',
      workingDir: 'string',
      timeout: 'number',
      enableParameter: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCommandResponseBody extends $tea.Model {
  requestId?: string;
  commandId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      commandId: 'CommandId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      commandId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCommandResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateCommandResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateCommandResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDedicatedHostClusterRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  dryRun?: boolean;
  tag?: CreateDedicatedHostClusterRequestTag[];
  resourceGroupId?: string;
  zoneId?: string;
  dedicatedHostClusterName?: string;
  description?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      dryRun: 'DryRun',
      tag: 'Tag',
      resourceGroupId: 'ResourceGroupId',
      zoneId: 'ZoneId',
      dedicatedHostClusterName: 'DedicatedHostClusterName',
      description: 'Description',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      dryRun: 'boolean',
      tag: { 'type': 'array', 'itemType': CreateDedicatedHostClusterRequestTag },
      resourceGroupId: 'string',
      zoneId: 'string',
      dedicatedHostClusterName: 'string',
      description: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDedicatedHostClusterResponseBody extends $tea.Model {
  requestId?: string;
  dedicatedHostClusterId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      dedicatedHostClusterId: 'DedicatedHostClusterId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      dedicatedHostClusterId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDedicatedHostClusterResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateDedicatedHostClusterResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateDedicatedHostClusterResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDemandRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  clientToken?: string;
  regionId?: string;
  zoneId?: string;
  demandName?: string;
  demandDescription?: string;
  instanceType?: string;
  amount?: number;
  instanceChargeType?: string;
  period?: number;
  periodUnit?: string;
  startTime?: string;
  endTime?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      clientToken: 'ClientToken',
      regionId: 'RegionId',
      zoneId: 'ZoneId',
      demandName: 'DemandName',
      demandDescription: 'DemandDescription',
      instanceType: 'InstanceType',
      amount: 'Amount',
      instanceChargeType: 'InstanceChargeType',
      period: 'Period',
      periodUnit: 'PeriodUnit',
      startTime: 'StartTime',
      endTime: 'EndTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      clientToken: 'string',
      regionId: 'string',
      zoneId: 'string',
      demandName: 'string',
      demandDescription: 'string',
      instanceType: 'string',
      amount: 'number',
      instanceChargeType: 'string',
      period: 'number',
      periodUnit: 'string',
      startTime: 'string',
      endTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDemandResponseBody extends $tea.Model {
  requestId?: string;
  demandId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      demandId: 'DemandId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      demandId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDemandResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateDemandResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateDemandResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDeploymentSetRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  onUnableToRedeployFailedInstance?: string;
  description?: string;
  clientToken?: string;
  deploymentSetName?: string;
  domain?: string;
  granularity?: string;
  strategy?: string;
  groupCount?: number;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      onUnableToRedeployFailedInstance: 'OnUnableToRedeployFailedInstance',
      description: 'Description',
      clientToken: 'ClientToken',
      deploymentSetName: 'DeploymentSetName',
      domain: 'Domain',
      granularity: 'Granularity',
      strategy: 'Strategy',
      groupCount: 'GroupCount',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      onUnableToRedeployFailedInstance: 'string',
      description: 'string',
      clientToken: 'string',
      deploymentSetName: 'string',
      domain: 'string',
      granularity: 'string',
      strategy: 'string',
      groupCount: 'number',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDeploymentSetResponseBody extends $tea.Model {
  deploymentSetId?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      deploymentSetId: 'DeploymentSetId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deploymentSetId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDeploymentSetResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateDeploymentSetResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateDeploymentSetResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDiskRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  zoneId?: string;
  snapshotId?: string;
  diskName?: string;
  size?: number;
  diskCategory?: string;
  description?: string;
  encrypted?: boolean;
  clientToken?: string;
  ownerAccount?: string;
  instanceId?: string;
  resourceGroupId?: string;
  KMSKeyId?: string;
  performanceLevel?: string;
  advancedFeatures?: string;
  storageSetId?: string;
  encryptAlgorithm?: string;
  storageSetPartitionNumber?: number;
  tag?: CreateDiskRequestTag[];
  arn?: CreateDiskRequestArn[];
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      zoneId: 'ZoneId',
      snapshotId: 'SnapshotId',
      diskName: 'DiskName',
      size: 'Size',
      diskCategory: 'DiskCategory',
      description: 'Description',
      encrypted: 'Encrypted',
      clientToken: 'ClientToken',
      ownerAccount: 'OwnerAccount',
      instanceId: 'InstanceId',
      resourceGroupId: 'ResourceGroupId',
      KMSKeyId: 'KMSKeyId',
      performanceLevel: 'PerformanceLevel',
      advancedFeatures: 'AdvancedFeatures',
      storageSetId: 'StorageSetId',
      encryptAlgorithm: 'EncryptAlgorithm',
      storageSetPartitionNumber: 'StorageSetPartitionNumber',
      tag: 'Tag',
      arn: 'Arn',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      zoneId: 'string',
      snapshotId: 'string',
      diskName: 'string',
      size: 'number',
      diskCategory: 'string',
      description: 'string',
      encrypted: 'boolean',
      clientToken: 'string',
      ownerAccount: 'string',
      instanceId: 'string',
      resourceGroupId: 'string',
      KMSKeyId: 'string',
      performanceLevel: 'string',
      advancedFeatures: 'string',
      storageSetId: 'string',
      encryptAlgorithm: 'string',
      storageSetPartitionNumber: 'number',
      tag: { 'type': 'array', 'itemType': CreateDiskRequestTag },
      arn: { 'type': 'array', 'itemType': CreateDiskRequestArn },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDiskResponseBody extends $tea.Model {
  requestId?: string;
  diskId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      diskId: 'DiskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      diskId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDiskResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateDiskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateDiskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateElasticityAssuranceRequest extends $tea.Model {
  privatePoolOptions?: CreateElasticityAssuranceRequestPrivatePoolOptions;
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  chargeType?: string;
  period?: number;
  periodUnit?: string;
  clientToken?: string;
  description?: string;
  assuranceTimes?: string;
  instanceAmount?: number;
  instanceCpuCoreCount?: number;
  startTime?: string;
  instanceChargeType?: string;
  platform?: string;
  packageType?: string;
  resourceType?: string;
  zoneId?: string[];
  instanceType?: string[];
  static names(): { [key: string]: string } {
    return {
      privatePoolOptions: 'PrivatePoolOptions',
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      chargeType: 'ChargeType',
      period: 'Period',
      periodUnit: 'PeriodUnit',
      clientToken: 'ClientToken',
      description: 'Description',
      assuranceTimes: 'AssuranceTimes',
      instanceAmount: 'InstanceAmount',
      instanceCpuCoreCount: 'InstanceCpuCoreCount',
      startTime: 'StartTime',
      instanceChargeType: 'InstanceChargeType',
      platform: 'Platform',
      packageType: 'PackageType',
      resourceType: 'ResourceType',
      zoneId: 'ZoneId',
      instanceType: 'InstanceType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      privatePoolOptions: CreateElasticityAssuranceRequestPrivatePoolOptions,
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      chargeType: 'string',
      period: 'number',
      periodUnit: 'string',
      clientToken: 'string',
      description: 'string',
      assuranceTimes: 'string',
      instanceAmount: 'number',
      instanceCpuCoreCount: 'number',
      startTime: 'string',
      instanceChargeType: 'string',
      platform: 'string',
      packageType: 'string',
      resourceType: 'string',
      zoneId: { 'type': 'array', 'itemType': 'string' },
      instanceType: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateElasticityAssuranceResponseBody extends $tea.Model {
  requestId?: string;
  orderId?: string;
  privatePoolOptionsId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      orderId: 'OrderId',
      privatePoolOptionsId: 'PrivatePoolOptionsId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      orderId: 'string',
      privatePoolOptionsId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateElasticityAssuranceResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateElasticityAssuranceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateElasticityAssuranceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateForwardEntryRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  forwardTableId?: string;
  externalIp?: string;
  externalPort?: string;
  internalIp?: string;
  internalPort?: string;
  ipProtocol?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      forwardTableId: 'ForwardTableId',
      externalIp: 'ExternalIp',
      externalPort: 'ExternalPort',
      internalIp: 'InternalIp',
      internalPort: 'InternalPort',
      ipProtocol: 'IpProtocol',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      forwardTableId: 'string',
      externalIp: 'string',
      externalPort: 'string',
      internalIp: 'string',
      internalPort: 'string',
      ipProtocol: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateForwardEntryResponseBody extends $tea.Model {
  requestId?: string;
  forwardEntryId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      forwardEntryId: 'ForwardEntryId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      forwardEntryId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateForwardEntryResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateForwardEntryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateForwardEntryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateHaVipRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  clientToken?: string;
  regionId?: string;
  vSwitchId?: string;
  ipAddress?: string;
  description?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      clientToken: 'ClientToken',
      regionId: 'RegionId',
      vSwitchId: 'VSwitchId',
      ipAddress: 'IpAddress',
      description: 'Description',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      clientToken: 'string',
      regionId: 'string',
      vSwitchId: 'string',
      ipAddress: 'string',
      description: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateHaVipResponseBody extends $tea.Model {
  requestId?: string;
  haVipId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      haVipId: 'HaVipId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      haVipId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateHaVipResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateHaVipResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateHaVipResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateHpcClusterRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  clientToken?: string;
  ownerAccount?: string;
  description?: string;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      clientToken: 'ClientToken',
      ownerAccount: 'OwnerAccount',
      description: 'Description',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      clientToken: 'string',
      ownerAccount: 'string',
      description: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateHpcClusterResponseBody extends $tea.Model {
  requestId?: string;
  hpcClusterId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      hpcClusterId: 'HpcClusterId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      hpcClusterId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateHpcClusterResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateHpcClusterResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateHpcClusterResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateImageRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  snapshotId?: string;
  instanceId?: string;
  imageName?: string;
  imageFamily?: string;
  imageVersion?: string;
  description?: string;
  platform?: string;
  architecture?: string;
  clientToken?: string;
  ownerAccount?: string;
  resourceGroupId?: string;
  diskDeviceMapping?: CreateImageRequestDiskDeviceMapping[];
  tag?: CreateImageRequestTag[];
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      snapshotId: 'SnapshotId',
      instanceId: 'InstanceId',
      imageName: 'ImageName',
      imageFamily: 'ImageFamily',
      imageVersion: 'ImageVersion',
      description: 'Description',
      platform: 'Platform',
      architecture: 'Architecture',
      clientToken: 'ClientToken',
      ownerAccount: 'OwnerAccount',
      resourceGroupId: 'ResourceGroupId',
      diskDeviceMapping: 'DiskDeviceMapping',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      snapshotId: 'string',
      instanceId: 'string',
      imageName: 'string',
      imageFamily: 'string',
      imageVersion: 'string',
      description: 'string',
      platform: 'string',
      architecture: 'string',
      clientToken: 'string',
      ownerAccount: 'string',
      resourceGroupId: 'string',
      diskDeviceMapping: { 'type': 'array', 'itemType': CreateImageRequestDiskDeviceMapping },
      tag: { 'type': 'array', 'itemType': CreateImageRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateImageResponseBody extends $tea.Model {
  requestId?: string;
  imageId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      imageId: 'ImageId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      imageId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateImageResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateImageResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateImageResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateInstanceRequest extends $tea.Model {
  systemDisk?: CreateInstanceRequestSystemDisk;
  privatePoolOptions?: CreateInstanceRequestPrivatePoolOptions;
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  imageId?: string;
  imageFamily?: string;
  instanceType?: string;
  securityGroupId?: string;
  instanceName?: string;
  internetChargeType?: string;
  autoRenew?: boolean;
  autoRenewPeriod?: number;
  internetMaxBandwidthIn?: number;
  internetMaxBandwidthOut?: number;
  hostName?: string;
  password?: string;
  passwordInherit?: boolean;
  deploymentSetId?: string;
  deploymentSetGroupNo?: number;
  zoneId?: string;
  clusterId?: string;
  clientToken?: string;
  vlanId?: string;
  innerIpAddress?: string;
  nodeControllerId?: string;
  description?: string;
  vSwitchId?: string;
  privateIpAddress?: string;
  ioOptimized?: string;
  ownerAccount?: string;
  useAdditionalService?: boolean;
  instanceChargeType?: string;
  period?: number;
  periodUnit?: string;
  userData?: string;
  spotStrategy?: string;
  keyPairName?: string;
  spotPriceLimit?: number;
  spotDuration?: number;
  spotInterruptionBehavior?: string;
  ramRoleName?: string;
  securityEnhancementStrategy?: string;
  resourceGroupId?: string;
  hpcClusterId?: string;
  dryRun?: boolean;
  dedicatedHostId?: string;
  creditSpecification?: string;
  deletionProtection?: boolean;
  capacityReservationId?: string;
  capacityReservationPreference?: string;
  affinity?: string;
  tenancy?: string;
  storageSetId?: string;
  storageSetPartitionNumber?: number;
  httpEndpoint?: string;
  httpTokens?: string;
  httpPutResponseHopLimit?: number;
  dataDisk?: CreateInstanceRequestDataDisk[];
  arn?: CreateInstanceRequestArn[];
  tag?: CreateInstanceRequestTag[];
  static names(): { [key: string]: string } {
    return {
      systemDisk: 'SystemDisk',
      privatePoolOptions: 'PrivatePoolOptions',
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      imageId: 'ImageId',
      imageFamily: 'ImageFamily',
      instanceType: 'InstanceType',
      securityGroupId: 'SecurityGroupId',
      instanceName: 'InstanceName',
      internetChargeType: 'InternetChargeType',
      autoRenew: 'AutoRenew',
      autoRenewPeriod: 'AutoRenewPeriod',
      internetMaxBandwidthIn: 'InternetMaxBandwidthIn',
      internetMaxBandwidthOut: 'InternetMaxBandwidthOut',
      hostName: 'HostName',
      password: 'Password',
      passwordInherit: 'PasswordInherit',
      deploymentSetId: 'DeploymentSetId',
      deploymentSetGroupNo: 'DeploymentSetGroupNo',
      zoneId: 'ZoneId',
      clusterId: 'ClusterId',
      clientToken: 'ClientToken',
      vlanId: 'VlanId',
      innerIpAddress: 'InnerIpAddress',
      nodeControllerId: 'NodeControllerId',
      description: 'Description',
      vSwitchId: 'VSwitchId',
      privateIpAddress: 'PrivateIpAddress',
      ioOptimized: 'IoOptimized',
      ownerAccount: 'OwnerAccount',
      useAdditionalService: 'UseAdditionalService',
      instanceChargeType: 'InstanceChargeType',
      period: 'Period',
      periodUnit: 'PeriodUnit',
      userData: 'UserData',
      spotStrategy: 'SpotStrategy',
      keyPairName: 'KeyPairName',
      spotPriceLimit: 'SpotPriceLimit',
      spotDuration: 'SpotDuration',
      spotInterruptionBehavior: 'SpotInterruptionBehavior',
      ramRoleName: 'RamRoleName',
      securityEnhancementStrategy: 'SecurityEnhancementStrategy',
      resourceGroupId: 'ResourceGroupId',
      hpcClusterId: 'HpcClusterId',
      dryRun: 'DryRun',
      dedicatedHostId: 'DedicatedHostId',
      creditSpecification: 'CreditSpecification',
      deletionProtection: 'DeletionProtection',
      capacityReservationId: 'CapacityReservationId',
      capacityReservationPreference: 'CapacityReservationPreference',
      affinity: 'Affinity',
      tenancy: 'Tenancy',
      storageSetId: 'StorageSetId',
      storageSetPartitionNumber: 'StorageSetPartitionNumber',
      httpEndpoint: 'HttpEndpoint',
      httpTokens: 'HttpTokens',
      httpPutResponseHopLimit: 'HttpPutResponseHopLimit',
      dataDisk: 'DataDisk',
      arn: 'Arn',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      systemDisk: CreateInstanceRequestSystemDisk,
      privatePoolOptions: CreateInstanceRequestPrivatePoolOptions,
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      imageId: 'string',
      imageFamily: 'string',
      instanceType: 'string',
      securityGroupId: 'string',
      instanceName: 'string',
      internetChargeType: 'string',
      autoRenew: 'boolean',
      autoRenewPeriod: 'number',
      internetMaxBandwidthIn: 'number',
      internetMaxBandwidthOut: 'number',
      hostName: 'string',
      password: 'string',
      passwordInherit: 'boolean',
      deploymentSetId: 'string',
      deploymentSetGroupNo: 'number',
      zoneId: 'string',
      clusterId: 'string',
      clientToken: 'string',
      vlanId: 'string',
      innerIpAddress: 'string',
      nodeControllerId: 'string',
      description: 'string',
      vSwitchId: 'string',
      privateIpAddress: 'string',
      ioOptimized: 'string',
      ownerAccount: 'string',
      useAdditionalService: 'boolean',
      instanceChargeType: 'string',
      period: 'number',
      periodUnit: 'string',
      userData: 'string',
      spotStrategy: 'string',
      keyPairName: 'string',
      spotPriceLimit: 'number',
      spotDuration: 'number',
      spotInterruptionBehavior: 'string',
      ramRoleName: 'string',
      securityEnhancementStrategy: 'string',
      resourceGroupId: 'string',
      hpcClusterId: 'string',
      dryRun: 'boolean',
      dedicatedHostId: 'string',
      creditSpecification: 'string',
      deletionProtection: 'boolean',
      capacityReservationId: 'string',
      capacityReservationPreference: 'string',
      affinity: 'string',
      tenancy: 'string',
      storageSetId: 'string',
      storageSetPartitionNumber: 'number',
      httpEndpoint: 'string',
      httpTokens: 'string',
      httpPutResponseHopLimit: 'number',
      dataDisk: { 'type': 'array', 'itemType': CreateInstanceRequestDataDisk },
      arn: { 'type': 'array', 'itemType': CreateInstanceRequestArn },
      tag: { 'type': 'array', 'itemType': CreateInstanceRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateInstanceResponseBody extends $tea.Model {
  requestId?: string;
  instanceId?: string;
  orderId?: string;
  tradePrice?: number;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      instanceId: 'InstanceId',
      orderId: 'OrderId',
      tradePrice: 'TradePrice',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      instanceId: 'string',
      orderId: 'string',
      tradePrice: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateInstanceResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateKeyPairRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  keyPairName?: string;
  resourceGroupId?: string;
  tag?: CreateKeyPairRequestTag[];
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      keyPairName: 'KeyPairName',
      resourceGroupId: 'ResourceGroupId',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      keyPairName: 'string',
      resourceGroupId: 'string',
      tag: { 'type': 'array', 'itemType': CreateKeyPairRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateKeyPairResponseBody extends $tea.Model {
  keyPairFingerPrint?: string;
  keyPairName?: string;
  requestId?: string;
  keyPairId?: string;
  privateKeyBody?: string;
  static names(): { [key: string]: string } {
    return {
      keyPairFingerPrint: 'KeyPairFingerPrint',
      keyPairName: 'KeyPairName',
      requestId: 'RequestId',
      keyPairId: 'KeyPairId',
      privateKeyBody: 'PrivateKeyBody',
    };
  }

  static types(): { [key: string]: any } {
    return {
      keyPairFingerPrint: 'string',
      keyPairName: 'string',
      requestId: 'string',
      keyPairId: 'string',
      privateKeyBody: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateKeyPairResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateKeyPairResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateKeyPairResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLaunchTemplateRequest extends $tea.Model {
  systemDisk?: CreateLaunchTemplateRequestSystemDisk;
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  templateTag?: CreateLaunchTemplateRequestTemplateTag[];
  launchTemplateName?: string;
  versionDescription?: string;
  imageId?: string;
  imageOwnerAlias?: string;
  passwordInherit?: boolean;
  instanceType?: string;
  securityGroupId?: string;
  vpcId?: string;
  vSwitchId?: string;
  instanceName?: string;
  description?: string;
  internetMaxBandwidthIn?: number;
  internetMaxBandwidthOut?: number;
  hostName?: string;
  zoneId?: string;
  ioOptimized?: string;
  instanceChargeType?: string;
  period?: number;
  internetChargeType?: string;
  enableVmOsConfig?: boolean;
  networkType?: string;
  userData?: string;
  keyPairName?: string;
  ramRoleName?: string;
  autoReleaseTime?: string;
  spotStrategy?: string;
  spotPriceLimit?: number;
  spotDuration?: number;
  resourceGroupId?: string;
  templateResourceGroupId?: string;
  securityEnhancementStrategy?: string;
  dataDisk?: CreateLaunchTemplateRequestDataDisk[];
  networkInterface?: CreateLaunchTemplateRequestNetworkInterface[];
  tag?: CreateLaunchTemplateRequestTag[];
  static names(): { [key: string]: string } {
    return {
      systemDisk: 'SystemDisk',
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      templateTag: 'TemplateTag',
      launchTemplateName: 'LaunchTemplateName',
      versionDescription: 'VersionDescription',
      imageId: 'ImageId',
      imageOwnerAlias: 'ImageOwnerAlias',
      passwordInherit: 'PasswordInherit',
      instanceType: 'InstanceType',
      securityGroupId: 'SecurityGroupId',
      vpcId: 'VpcId',
      vSwitchId: 'VSwitchId',
      instanceName: 'InstanceName',
      description: 'Description',
      internetMaxBandwidthIn: 'InternetMaxBandwidthIn',
      internetMaxBandwidthOut: 'InternetMaxBandwidthOut',
      hostName: 'HostName',
      zoneId: 'ZoneId',
      ioOptimized: 'IoOptimized',
      instanceChargeType: 'InstanceChargeType',
      period: 'Period',
      internetChargeType: 'InternetChargeType',
      enableVmOsConfig: 'EnableVmOsConfig',
      networkType: 'NetworkType',
      userData: 'UserData',
      keyPairName: 'KeyPairName',
      ramRoleName: 'RamRoleName',
      autoReleaseTime: 'AutoReleaseTime',
      spotStrategy: 'SpotStrategy',
      spotPriceLimit: 'SpotPriceLimit',
      spotDuration: 'SpotDuration',
      resourceGroupId: 'ResourceGroupId',
      templateResourceGroupId: 'TemplateResourceGroupId',
      securityEnhancementStrategy: 'SecurityEnhancementStrategy',
      dataDisk: 'DataDisk',
      networkInterface: 'NetworkInterface',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      systemDisk: CreateLaunchTemplateRequestSystemDisk,
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      templateTag: { 'type': 'array', 'itemType': CreateLaunchTemplateRequestTemplateTag },
      launchTemplateName: 'string',
      versionDescription: 'string',
      imageId: 'string',
      imageOwnerAlias: 'string',
      passwordInherit: 'boolean',
      instanceType: 'string',
      securityGroupId: 'string',
      vpcId: 'string',
      vSwitchId: 'string',
      instanceName: 'string',
      description: 'string',
      internetMaxBandwidthIn: 'number',
      internetMaxBandwidthOut: 'number',
      hostName: 'string',
      zoneId: 'string',
      ioOptimized: 'string',
      instanceChargeType: 'string',
      period: 'number',
      internetChargeType: 'string',
      enableVmOsConfig: 'boolean',
      networkType: 'string',
      userData: 'string',
      keyPairName: 'string',
      ramRoleName: 'string',
      autoReleaseTime: 'string',
      spotStrategy: 'string',
      spotPriceLimit: 'number',
      spotDuration: 'number',
      resourceGroupId: 'string',
      templateResourceGroupId: 'string',
      securityEnhancementStrategy: 'string',
      dataDisk: { 'type': 'array', 'itemType': CreateLaunchTemplateRequestDataDisk },
      networkInterface: { 'type': 'array', 'itemType': CreateLaunchTemplateRequestNetworkInterface },
      tag: { 'type': 'array', 'itemType': CreateLaunchTemplateRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLaunchTemplateResponseBody extends $tea.Model {
  requestId?: string;
  launchTemplateId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      launchTemplateId: 'LaunchTemplateId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      launchTemplateId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLaunchTemplateResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateLaunchTemplateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateLaunchTemplateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLaunchTemplateVersionRequest extends $tea.Model {
  systemDisk?: CreateLaunchTemplateVersionRequestSystemDisk;
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  launchTemplateId?: string;
  launchTemplateName?: string;
  versionDescription?: string;
  imageId?: string;
  imageOwnerAlias?: string;
  passwordInherit?: boolean;
  instanceType?: string;
  securityGroupId?: string;
  vpcId?: string;
  vSwitchId?: string;
  instanceName?: string;
  description?: string;
  internetMaxBandwidthIn?: number;
  internetMaxBandwidthOut?: number;
  hostName?: string;
  zoneId?: string;
  ioOptimized?: string;
  instanceChargeType?: string;
  period?: number;
  internetChargeType?: string;
  enableVmOsConfig?: boolean;
  networkType?: string;
  userData?: string;
  keyPairName?: string;
  ramRoleName?: string;
  autoReleaseTime?: string;
  spotStrategy?: string;
  spotPriceLimit?: number;
  spotDuration?: number;
  resourceGroupId?: string;
  securityEnhancementStrategy?: string;
  dataDisk?: CreateLaunchTemplateVersionRequestDataDisk[];
  networkInterface?: CreateLaunchTemplateVersionRequestNetworkInterface[];
  tag?: CreateLaunchTemplateVersionRequestTag[];
  static names(): { [key: string]: string } {
    return {
      systemDisk: 'SystemDisk',
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      launchTemplateId: 'LaunchTemplateId',
      launchTemplateName: 'LaunchTemplateName',
      versionDescription: 'VersionDescription',
      imageId: 'ImageId',
      imageOwnerAlias: 'ImageOwnerAlias',
      passwordInherit: 'PasswordInherit',
      instanceType: 'InstanceType',
      securityGroupId: 'SecurityGroupId',
      vpcId: 'VpcId',
      vSwitchId: 'VSwitchId',
      instanceName: 'InstanceName',
      description: 'Description',
      internetMaxBandwidthIn: 'InternetMaxBandwidthIn',
      internetMaxBandwidthOut: 'InternetMaxBandwidthOut',
      hostName: 'HostName',
      zoneId: 'ZoneId',
      ioOptimized: 'IoOptimized',
      instanceChargeType: 'InstanceChargeType',
      period: 'Period',
      internetChargeType: 'InternetChargeType',
      enableVmOsConfig: 'EnableVmOsConfig',
      networkType: 'NetworkType',
      userData: 'UserData',
      keyPairName: 'KeyPairName',
      ramRoleName: 'RamRoleName',
      autoReleaseTime: 'AutoReleaseTime',
      spotStrategy: 'SpotStrategy',
      spotPriceLimit: 'SpotPriceLimit',
      spotDuration: 'SpotDuration',
      resourceGroupId: 'ResourceGroupId',
      securityEnhancementStrategy: 'SecurityEnhancementStrategy',
      dataDisk: 'DataDisk',
      networkInterface: 'NetworkInterface',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      systemDisk: CreateLaunchTemplateVersionRequestSystemDisk,
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      launchTemplateId: 'string',
      launchTemplateName: 'string',
      versionDescription: 'string',
      imageId: 'string',
      imageOwnerAlias: 'string',
      passwordInherit: 'boolean',
      instanceType: 'string',
      securityGroupId: 'string',
      vpcId: 'string',
      vSwitchId: 'string',
      instanceName: 'string',
      description: 'string',
      internetMaxBandwidthIn: 'number',
      internetMaxBandwidthOut: 'number',
      hostName: 'string',
      zoneId: 'string',
      ioOptimized: 'string',
      instanceChargeType: 'string',
      period: 'number',
      internetChargeType: 'string',
      enableVmOsConfig: 'boolean',
      networkType: 'string',
      userData: 'string',
      keyPairName: 'string',
      ramRoleName: 'string',
      autoReleaseTime: 'string',
      spotStrategy: 'string',
      spotPriceLimit: 'number',
      spotDuration: 'number',
      resourceGroupId: 'string',
      securityEnhancementStrategy: 'string',
      dataDisk: { 'type': 'array', 'itemType': CreateLaunchTemplateVersionRequestDataDisk },
      networkInterface: { 'type': 'array', 'itemType': CreateLaunchTemplateVersionRequestNetworkInterface },
      tag: { 'type': 'array', 'itemType': CreateLaunchTemplateVersionRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLaunchTemplateVersionResponseBody extends $tea.Model {
  requestId?: string;
  launchTemplateVersionNumber?: number;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      launchTemplateVersionNumber: 'LaunchTemplateVersionNumber',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      launchTemplateVersionNumber: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLaunchTemplateVersionResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateLaunchTemplateVersionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateLaunchTemplateVersionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateNatGatewayRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  vpcId?: string;
  name?: string;
  description?: string;
  clientToken?: string;
  bandwidthPackage?: CreateNatGatewayRequestBandwidthPackage[];
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      vpcId: 'VpcId',
      name: 'Name',
      description: 'Description',
      clientToken: 'ClientToken',
      bandwidthPackage: 'BandwidthPackage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      vpcId: 'string',
      name: 'string',
      description: 'string',
      clientToken: 'string',
      bandwidthPackage: { 'type': 'array', 'itemType': CreateNatGatewayRequestBandwidthPackage },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateNatGatewayResponseBody extends $tea.Model {
  requestId?: string;
  forwardTableIds?: string[];
  bandwidthPackageIds?: string[];
  natGatewayId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      forwardTableIds: 'ForwardTableIds',
      bandwidthPackageIds: 'BandwidthPackageIds',
      natGatewayId: 'NatGatewayId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      forwardTableIds: { 'type': 'array', 'itemType': 'string' },
      bandwidthPackageIds: { 'type': 'array', 'itemType': 'string' },
      natGatewayId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateNatGatewayResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateNatGatewayResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateNatGatewayResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateNetworkInterfaceRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  tag?: CreateNetworkInterfaceRequestTag[];
  resourceGroupId?: string;
  vSwitchId?: string;
  primaryIpAddress?: string;
  securityGroupId?: string;
  networkInterfaceName?: string;
  description?: string;
  visible?: boolean;
  instanceType?: string;
  businessType?: string;
  secondaryPrivateIpAddressCount?: number;
  queueNumber?: number;
  clientToken?: string;
  securityGroupIds?: string[];
  privateIpAddress?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      tag: 'Tag',
      resourceGroupId: 'ResourceGroupId',
      vSwitchId: 'VSwitchId',
      primaryIpAddress: 'PrimaryIpAddress',
      securityGroupId: 'SecurityGroupId',
      networkInterfaceName: 'NetworkInterfaceName',
      description: 'Description',
      visible: 'Visible',
      instanceType: 'InstanceType',
      businessType: 'BusinessType',
      secondaryPrivateIpAddressCount: 'SecondaryPrivateIpAddressCount',
      queueNumber: 'QueueNumber',
      clientToken: 'ClientToken',
      securityGroupIds: 'SecurityGroupIds',
      privateIpAddress: 'PrivateIpAddress',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      tag: { 'type': 'array', 'itemType': CreateNetworkInterfaceRequestTag },
      resourceGroupId: 'string',
      vSwitchId: 'string',
      primaryIpAddress: 'string',
      securityGroupId: 'string',
      networkInterfaceName: 'string',
      description: 'string',
      visible: 'boolean',
      instanceType: 'string',
      businessType: 'string',
      secondaryPrivateIpAddressCount: 'number',
      queueNumber: 'number',
      clientToken: 'string',
      securityGroupIds: { 'type': 'array', 'itemType': 'string' },
      privateIpAddress: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateNetworkInterfaceResponseBody extends $tea.Model {
  status?: string;
  description?: string;
  privateIpAddress?: string;
  serviceManaged?: boolean;
  requestId?: string;
  resourceGroupId?: string;
  zoneId?: string;
  vSwitchId?: string;
  networkInterfaceName?: string;
  macAddress?: string;
  networkInterfaceId?: string;
  securityGroupIds?: string[];
  serviceID?: number;
  type?: string;
  vpcId?: string;
  ownerId?: string;
  tags?: CreateNetworkInterfaceResponseBodyTags[];
  privateIpSets?: CreateNetworkInterfaceResponseBodyPrivateIpSets[];
  static names(): { [key: string]: string } {
    return {
      status: 'Status',
      description: 'Description',
      privateIpAddress: 'PrivateIpAddress',
      serviceManaged: 'ServiceManaged',
      requestId: 'RequestId',
      resourceGroupId: 'ResourceGroupId',
      zoneId: 'ZoneId',
      vSwitchId: 'VSwitchId',
      networkInterfaceName: 'NetworkInterfaceName',
      macAddress: 'MacAddress',
      networkInterfaceId: 'NetworkInterfaceId',
      securityGroupIds: 'SecurityGroupIds',
      serviceID: 'ServiceID',
      type: 'Type',
      vpcId: 'VpcId',
      ownerId: 'OwnerId',
      tags: 'Tags',
      privateIpSets: 'PrivateIpSets',
    };
  }

  static types(): { [key: string]: any } {
    return {
      status: 'string',
      description: 'string',
      privateIpAddress: 'string',
      serviceManaged: 'boolean',
      requestId: 'string',
      resourceGroupId: 'string',
      zoneId: 'string',
      vSwitchId: 'string',
      networkInterfaceName: 'string',
      macAddress: 'string',
      networkInterfaceId: 'string',
      securityGroupIds: { 'type': 'array', 'itemType': 'string' },
      serviceID: 'number',
      type: 'string',
      vpcId: 'string',
      ownerId: 'string',
      tags: { 'type': 'array', 'itemType': CreateNetworkInterfaceResponseBodyTags },
      privateIpSets: { 'type': 'array', 'itemType': CreateNetworkInterfaceResponseBodyPrivateIpSets },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateNetworkInterfaceResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateNetworkInterfaceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateNetworkInterfaceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateNetworkInterfacePermissionRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  accountId?: number;
  networkInterfaceId?: string;
  permission?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      accountId: 'AccountId',
      networkInterfaceId: 'NetworkInterfaceId',
      permission: 'Permission',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      accountId: 'number',
      networkInterfaceId: 'string',
      permission: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateNetworkInterfacePermissionResponseBody extends $tea.Model {
  requestId?: string;
  networkInterfacePermission?: CreateNetworkInterfacePermissionResponseBodyNetworkInterfacePermission;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      networkInterfacePermission: 'NetworkInterfacePermission',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      networkInterfacePermission: CreateNetworkInterfacePermissionResponseBodyNetworkInterfacePermission,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateNetworkInterfacePermissionResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateNetworkInterfacePermissionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateNetworkInterfacePermissionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePhysicalConnectionRequest extends $tea.Model {
  regionId?: string;
  accessPointId?: string;
  type?: string;
  lineOperator?: string;
  bandwidth?: number;
  peerLocation?: string;
  portType?: string;
  redundantPhysicalConnectionId?: string;
  description?: string;
  name?: string;
  circuitCode?: string;
  clientToken?: string;
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  userCidr?: string;
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
      accessPointId: 'AccessPointId',
      type: 'Type',
      lineOperator: 'LineOperator',
      bandwidth: 'bandwidth',
      peerLocation: 'PeerLocation',
      portType: 'PortType',
      redundantPhysicalConnectionId: 'RedundantPhysicalConnectionId',
      description: 'Description',
      name: 'Name',
      circuitCode: 'CircuitCode',
      clientToken: 'ClientToken',
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      userCidr: 'UserCidr',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
      accessPointId: 'string',
      type: 'string',
      lineOperator: 'string',
      bandwidth: 'number',
      peerLocation: 'string',
      portType: 'string',
      redundantPhysicalConnectionId: 'string',
      description: 'string',
      name: 'string',
      circuitCode: 'string',
      clientToken: 'string',
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      userCidr: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePhysicalConnectionResponseBody extends $tea.Model {
  requestId?: string;
  physicalConnectionId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      physicalConnectionId: 'PhysicalConnectionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      physicalConnectionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePhysicalConnectionResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreatePhysicalConnectionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreatePhysicalConnectionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateResource02Request extends $tea.Model {
  status?: string;
  filter?: CreateResource02RequestFilter[];
  static names(): { [key: string]: string } {
    return {
      status: 'Status',
      filter: 'Filter',
    };
  }

  static types(): { [key: string]: any } {
    return {
      status: 'string',
      filter: { 'type': 'array', 'itemType': CreateResource02RequestFilter },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateResource02ResponseBody extends $tea.Model {
  status?: string;
  requestId?: string;
  ids?: string;
  static names(): { [key: string]: string } {
    return {
      status: 'Status',
      requestId: 'RequestId',
      ids: 'ids',
    };
  }

  static types(): { [key: string]: any } {
    return {
      status: 'string',
      requestId: 'string',
      ids: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateResource02Response extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateResource02ResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateResource02ResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRouteEntryRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  routeTableId?: string;
  destinationCidrBlock?: string;
  nextHopId?: string;
  clientToken?: string;
  nextHopType?: string;
  ownerAccount?: string;
  nextHopList?: CreateRouteEntryRequestNextHopList[];
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      routeTableId: 'RouteTableId',
      destinationCidrBlock: 'DestinationCidrBlock',
      nextHopId: 'NextHopId',
      clientToken: 'ClientToken',
      nextHopType: 'NextHopType',
      ownerAccount: 'OwnerAccount',
      nextHopList: 'NextHopList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      routeTableId: 'string',
      destinationCidrBlock: 'string',
      nextHopId: 'string',
      clientToken: 'string',
      nextHopType: 'string',
      ownerAccount: 'string',
      nextHopList: { 'type': 'array', 'itemType': CreateRouteEntryRequestNextHopList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRouteEntryResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRouteEntryResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateRouteEntryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateRouteEntryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRouterInterfaceRequest extends $tea.Model {
  regionId?: string;
  role?: string;
  oppositeRegionId?: string;
  spec?: string;
  routerType?: string;
  routerId?: string;
  oppositeInterfaceId?: string;
  oppositeRouterId?: string;
  oppositeRouterType?: string;
  oppositeInterfaceOwnerId?: string;
  healthCheckSourceIp?: string;
  healthCheckTargetIp?: string;
  accessPointId?: string;
  oppositeAccessPointId?: string;
  description?: string;
  name?: string;
  period?: number;
  instanceChargeType?: string;
  autoPay?: boolean;
  pricingCycle?: string;
  clientToken?: string;
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  userCidr?: string;
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
      role: 'Role',
      oppositeRegionId: 'OppositeRegionId',
      spec: 'Spec',
      routerType: 'RouterType',
      routerId: 'RouterId',
      oppositeInterfaceId: 'OppositeInterfaceId',
      oppositeRouterId: 'OppositeRouterId',
      oppositeRouterType: 'OppositeRouterType',
      oppositeInterfaceOwnerId: 'OppositeInterfaceOwnerId',
      healthCheckSourceIp: 'HealthCheckSourceIp',
      healthCheckTargetIp: 'HealthCheckTargetIp',
      accessPointId: 'AccessPointId',
      oppositeAccessPointId: 'OppositeAccessPointId',
      description: 'Description',
      name: 'Name',
      period: 'Period',
      instanceChargeType: 'InstanceChargeType',
      autoPay: 'AutoPay',
      pricingCycle: 'PricingCycle',
      clientToken: 'ClientToken',
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      userCidr: 'UserCidr',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
      role: 'string',
      oppositeRegionId: 'string',
      spec: 'string',
      routerType: 'string',
      routerId: 'string',
      oppositeInterfaceId: 'string',
      oppositeRouterId: 'string',
      oppositeRouterType: 'string',
      oppositeInterfaceOwnerId: 'string',
      healthCheckSourceIp: 'string',
      healthCheckTargetIp: 'string',
      accessPointId: 'string',
      oppositeAccessPointId: 'string',
      description: 'string',
      name: 'string',
      period: 'number',
      instanceChargeType: 'string',
      autoPay: 'boolean',
      pricingCycle: 'string',
      clientToken: 'string',
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      userCidr: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRouterInterfaceResponseBody extends $tea.Model {
  requestId?: string;
  orderId?: number;
  routerInterfaceId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      orderId: 'OrderId',
      routerInterfaceId: 'RouterInterfaceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      orderId: 'number',
      routerInterfaceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRouterInterfaceResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateRouterInterfaceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateRouterInterfaceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSecurityGroupRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  description?: string;
  clientToken?: string;
  securityGroupName?: string;
  vpcId?: string;
  securityGroupType?: string;
  serviceManaged?: boolean;
  ownerAccount?: string;
  resourceGroupId?: string;
  tag?: CreateSecurityGroupRequestTag[];
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      description: 'Description',
      clientToken: 'ClientToken',
      securityGroupName: 'SecurityGroupName',
      vpcId: 'VpcId',
      securityGroupType: 'SecurityGroupType',
      serviceManaged: 'ServiceManaged',
      ownerAccount: 'OwnerAccount',
      resourceGroupId: 'ResourceGroupId',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      description: 'string',
      clientToken: 'string',
      securityGroupName: 'string',
      vpcId: 'string',
      securityGroupType: 'string',
      serviceManaged: 'boolean',
      ownerAccount: 'string',
      resourceGroupId: 'string',
      tag: { 'type': 'array', 'itemType': CreateSecurityGroupRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSecurityGroupResponseBody extends $tea.Model {
  requestId?: string;
  securityGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      securityGroupId: 'SecurityGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      securityGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSecurityGroupResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateSecurityGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateSecurityGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSimulatedSystemEventsRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  eventType?: string;
  notBefore?: string;
  instanceId?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      eventType: 'EventType',
      notBefore: 'NotBefore',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      eventType: 'string',
      notBefore: 'string',
      instanceId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSimulatedSystemEventsResponseBody extends $tea.Model {
  requestId?: string;
  eventIdSet?: string[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      eventIdSet: 'EventIdSet',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      eventIdSet: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSimulatedSystemEventsResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateSimulatedSystemEventsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateSimulatedSystemEventsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSnapshotRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  diskId?: string;
  snapshotName?: string;
  description?: string;
  retentionDays?: number;
  category?: string;
  clientToken?: string;
  ownerAccount?: string;
  resourceGroupId?: string;
  instantAccess?: boolean;
  instantAccessRetentionDays?: number;
  tag?: CreateSnapshotRequestTag[];
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      diskId: 'DiskId',
      snapshotName: 'SnapshotName',
      description: 'Description',
      retentionDays: 'RetentionDays',
      category: 'Category',
      clientToken: 'ClientToken',
      ownerAccount: 'OwnerAccount',
      resourceGroupId: 'ResourceGroupId',
      instantAccess: 'InstantAccess',
      instantAccessRetentionDays: 'InstantAccessRetentionDays',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      diskId: 'string',
      snapshotName: 'string',
      description: 'string',
      retentionDays: 'number',
      category: 'string',
      clientToken: 'string',
      ownerAccount: 'string',
      resourceGroupId: 'string',
      instantAccess: 'boolean',
      instantAccessRetentionDays: 'number',
      tag: { 'type': 'array', 'itemType': CreateSnapshotRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSnapshotResponseBody extends $tea.Model {
  snapshotId?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      snapshotId: 'SnapshotId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      snapshotId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSnapshotResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateSnapshotResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateSnapshotResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateStorageSetRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  clientToken?: string;
  regionId?: string;
  zoneId?: string;
  storageSetName?: string;
  description?: string;
  maxPartitionNumber?: number;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      clientToken: 'ClientToken',
      regionId: 'RegionId',
      zoneId: 'ZoneId',
      storageSetName: 'StorageSetName',
      description: 'Description',
      maxPartitionNumber: 'MaxPartitionNumber',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      clientToken: 'string',
      regionId: 'string',
      zoneId: 'string',
      storageSetName: 'string',
      description: 'string',
      maxPartitionNumber: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateStorageSetResponseBody extends $tea.Model {
  requestId?: string;
  storageSetId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      storageSetId: 'StorageSetId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      storageSetId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateStorageSetResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateStorageSetResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateStorageSetResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateVirtualBorderRouterRequest extends $tea.Model {
  regionId?: string;
  physicalConnectionId?: string;
  vbrOwnerId?: number;
  vlanId?: number;
  circuitCode?: string;
  localGatewayIp?: string;
  peerGatewayIp?: string;
  peeringSubnetMask?: string;
  description?: string;
  name?: string;
  clientToken?: string;
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  userCidr?: string;
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
      physicalConnectionId: 'PhysicalConnectionId',
      vbrOwnerId: 'VbrOwnerId',
      vlanId: 'VlanId',
      circuitCode: 'CircuitCode',
      localGatewayIp: 'LocalGatewayIp',
      peerGatewayIp: 'PeerGatewayIp',
      peeringSubnetMask: 'PeeringSubnetMask',
      description: 'Description',
      name: 'Name',
      clientToken: 'ClientToken',
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      userCidr: 'UserCidr',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
      physicalConnectionId: 'string',
      vbrOwnerId: 'number',
      vlanId: 'number',
      circuitCode: 'string',
      localGatewayIp: 'string',
      peerGatewayIp: 'string',
      peeringSubnetMask: 'string',
      description: 'string',
      name: 'string',
      clientToken: 'string',
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      userCidr: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateVirtualBorderRouterResponseBody extends $tea.Model {
  requestId?: string;
  vbrId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      vbrId: 'VbrId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      vbrId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateVirtualBorderRouterResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateVirtualBorderRouterResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateVirtualBorderRouterResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateVpcRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  cidrBlock?: string;
  vpcName?: string;
  description?: string;
  clientToken?: string;
  ownerAccount?: string;
  userCidr?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      cidrBlock: 'CidrBlock',
      vpcName: 'VpcName',
      description: 'Description',
      clientToken: 'ClientToken',
      ownerAccount: 'OwnerAccount',
      userCidr: 'UserCidr',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      cidrBlock: 'string',
      vpcName: 'string',
      description: 'string',
      clientToken: 'string',
      ownerAccount: 'string',
      userCidr: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateVpcResponseBody extends $tea.Model {
  VRouterId?: string;
  routeTableId?: string;
  vpcId?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      VRouterId: 'VRouterId',
      routeTableId: 'RouteTableId',
      vpcId: 'VpcId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      VRouterId: 'string',
      routeTableId: 'string',
      vpcId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateVpcResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateVpcResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateVpcResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateVSwitchRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  zoneId?: string;
  cidrBlock?: string;
  vpcId?: string;
  regionId?: string;
  vSwitchName?: string;
  description?: string;
  clientToken?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      zoneId: 'ZoneId',
      cidrBlock: 'CidrBlock',
      vpcId: 'VpcId',
      regionId: 'RegionId',
      vSwitchName: 'VSwitchName',
      description: 'Description',
      clientToken: 'ClientToken',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      zoneId: 'string',
      cidrBlock: 'string',
      vpcId: 'string',
      regionId: 'string',
      vSwitchName: 'string',
      description: 'string',
      clientToken: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateVSwitchResponseBody extends $tea.Model {
  requestId?: string;
  vSwitchId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      vSwitchId: 'VSwitchId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      vSwitchId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateVSwitchResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateVSwitchResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateVSwitchResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeactivateRouterInterfaceRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  routerInterfaceId?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      routerInterfaceId: 'RouterInterfaceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      routerInterfaceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeactivateRouterInterfaceResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeactivateRouterInterfaceResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeactivateRouterInterfaceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeactivateRouterInterfaceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAutoProvisioningGroupRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  autoProvisioningGroupId?: string;
  terminateInstances?: boolean;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      autoProvisioningGroupId: 'AutoProvisioningGroupId',
      terminateInstances: 'TerminateInstances',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      autoProvisioningGroupId: 'string',
      terminateInstances: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAutoProvisioningGroupResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAutoProvisioningGroupResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteAutoProvisioningGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteAutoProvisioningGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAutoSnapshotPolicyRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  autoSnapshotPolicyId?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'regionId',
      autoSnapshotPolicyId: 'autoSnapshotPolicyId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      autoSnapshotPolicyId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAutoSnapshotPolicyResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAutoSnapshotPolicyResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteAutoSnapshotPolicyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteAutoSnapshotPolicyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteBandwidthPackageRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  bandwidthPackageId?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      bandwidthPackageId: 'BandwidthPackageId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      bandwidthPackageId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteBandwidthPackageResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteBandwidthPackageResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteBandwidthPackageResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteBandwidthPackageResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCommandRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  commandId?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      commandId: 'CommandId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      commandId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCommandResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCommandResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteCommandResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteCommandResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDedicatedHostClusterRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  dedicatedHostClusterId?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      dedicatedHostClusterId: 'DedicatedHostClusterId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      dedicatedHostClusterId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDedicatedHostClusterResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDedicatedHostClusterResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteDedicatedHostClusterResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteDedicatedHostClusterResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDemandRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  clientToken?: string;
  regionId?: string;
  demandId?: string;
  reason?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      clientToken: 'ClientToken',
      regionId: 'RegionId',
      demandId: 'DemandId',
      reason: 'Reason',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      clientToken: 'string',
      regionId: 'string',
      demandId: 'string',
      reason: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDemandResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDemandResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteDemandResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteDemandResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDeploymentSetRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  deploymentSetId?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      deploymentSetId: 'DeploymentSetId',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      deploymentSetId: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDeploymentSetResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDeploymentSetResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteDeploymentSetResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteDeploymentSetResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDiskRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  diskId?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      diskId: 'DiskId',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      diskId: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDiskResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDiskResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteDiskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteDiskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteForwardEntryRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  forwardTableId?: string;
  forwardEntryId?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      forwardTableId: 'ForwardTableId',
      forwardEntryId: 'ForwardEntryId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      forwardTableId: 'string',
      forwardEntryId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteForwardEntryResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteForwardEntryResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteForwardEntryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteForwardEntryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteHaVipRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  clientToken?: string;
  regionId?: string;
  haVipId?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      clientToken: 'ClientToken',
      regionId: 'RegionId',
      haVipId: 'HaVipId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      clientToken: 'string',
      regionId: 'string',
      haVipId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteHaVipResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteHaVipResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteHaVipResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteHaVipResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteHpcClusterRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  clientToken?: string;
  ownerAccount?: string;
  hpcClusterId?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      clientToken: 'ClientToken',
      ownerAccount: 'OwnerAccount',
      hpcClusterId: 'HpcClusterId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      clientToken: 'string',
      ownerAccount: 'string',
      hpcClusterId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteHpcClusterResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteHpcClusterResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteHpcClusterResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteHpcClusterResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteImageRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  imageId?: string;
  force?: boolean;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      imageId: 'ImageId',
      force: 'Force',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      imageId: 'string',
      force: 'boolean',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteImageResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteImageResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteImageResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteImageResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteInstanceRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  instanceId?: string;
  ownerAccount?: string;
  force?: boolean;
  terminateSubscription?: boolean;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      instanceId: 'InstanceId',
      ownerAccount: 'OwnerAccount',
      force: 'Force',
      terminateSubscription: 'TerminateSubscription',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      instanceId: 'string',
      ownerAccount: 'string',
      force: 'boolean',
      terminateSubscription: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteInstanceResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteInstanceResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteInstancesRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  dryRun?: boolean;
  ownerAccount?: string;
  force?: boolean;
  terminateSubscription?: boolean;
  clientToken?: string;
  regionId?: string;
  instanceId?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      dryRun: 'DryRun',
      ownerAccount: 'OwnerAccount',
      force: 'Force',
      terminateSubscription: 'TerminateSubscription',
      clientToken: 'ClientToken',
      regionId: 'RegionId',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      dryRun: 'boolean',
      ownerAccount: 'string',
      force: 'boolean',
      terminateSubscription: 'boolean',
      clientToken: 'string',
      regionId: 'string',
      instanceId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteInstancesResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteInstancesResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteInstancesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteInstancesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteKeyPairsRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  keyPairNames?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      keyPairNames: 'KeyPairNames',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      keyPairNames: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteKeyPairsResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteKeyPairsResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteKeyPairsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteKeyPairsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLaunchTemplateRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  launchTemplateId?: string;
  launchTemplateName?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      launchTemplateId: 'LaunchTemplateId',
      launchTemplateName: 'LaunchTemplateName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      launchTemplateId: 'string',
      launchTemplateName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLaunchTemplateResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLaunchTemplateResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteLaunchTemplateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteLaunchTemplateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLaunchTemplateVersionRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  launchTemplateId?: string;
  launchTemplateName?: string;
  deleteVersion?: number[];
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      launchTemplateId: 'LaunchTemplateId',
      launchTemplateName: 'LaunchTemplateName',
      deleteVersion: 'DeleteVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      launchTemplateId: 'string',
      launchTemplateName: 'string',
      deleteVersion: { 'type': 'array', 'itemType': 'number' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLaunchTemplateVersionResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLaunchTemplateVersionResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteLaunchTemplateVersionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteLaunchTemplateVersionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteNatGatewayRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  natGatewayId?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      natGatewayId: 'NatGatewayId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      natGatewayId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteNatGatewayResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteNatGatewayResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteNatGatewayResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteNatGatewayResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteNetworkInterfaceRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  networkInterfaceId?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      networkInterfaceId: 'NetworkInterfaceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      networkInterfaceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteNetworkInterfaceResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteNetworkInterfaceResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteNetworkInterfaceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteNetworkInterfaceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteNetworkInterfacePermissionRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  networkInterfacePermissionId?: string;
  force?: boolean;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      networkInterfacePermissionId: 'NetworkInterfacePermissionId',
      force: 'Force',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      networkInterfacePermissionId: 'string',
      force: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteNetworkInterfacePermissionResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteNetworkInterfacePermissionResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteNetworkInterfacePermissionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteNetworkInterfacePermissionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeletePhysicalConnectionRequest extends $tea.Model {
  regionId?: string;
  physicalConnectionId?: string;
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  clientToken?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
      physicalConnectionId: 'PhysicalConnectionId',
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      clientToken: 'ClientToken',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
      physicalConnectionId: 'string',
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      clientToken: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeletePhysicalConnectionResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeletePhysicalConnectionResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeletePhysicalConnectionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeletePhysicalConnectionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRouteEntryRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  routeTableId?: string;
  destinationCidrBlock?: string;
  nextHopId?: string;
  ownerAccount?: string;
  nextHopList?: DeleteRouteEntryRequestNextHopList[];
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      routeTableId: 'RouteTableId',
      destinationCidrBlock: 'DestinationCidrBlock',
      nextHopId: 'NextHopId',
      ownerAccount: 'OwnerAccount',
      nextHopList: 'NextHopList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      routeTableId: 'string',
      destinationCidrBlock: 'string',
      nextHopId: 'string',
      ownerAccount: 'string',
      nextHopList: { 'type': 'array', 'itemType': DeleteRouteEntryRequestNextHopList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRouteEntryResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRouteEntryResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteRouteEntryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteRouteEntryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRouterInterfaceRequest extends $tea.Model {
  regionId?: string;
  routerInterfaceId?: string;
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  clientToken?: string;
  ownerAccount?: string;
  userCidr?: string;
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
      routerInterfaceId: 'RouterInterfaceId',
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      clientToken: 'ClientToken',
      ownerAccount: 'OwnerAccount',
      userCidr: 'UserCidr',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
      routerInterfaceId: 'string',
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      clientToken: 'string',
      ownerAccount: 'string',
      userCidr: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRouterInterfaceResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRouterInterfaceResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteRouterInterfaceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteRouterInterfaceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSecurityGroupRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  securityGroupId?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      securityGroupId: 'SecurityGroupId',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      securityGroupId: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSecurityGroupResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSecurityGroupResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteSecurityGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteSecurityGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSnapshotRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  snapshotId?: string;
  force?: boolean;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      snapshotId: 'SnapshotId',
      force: 'Force',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      snapshotId: 'string',
      force: 'boolean',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSnapshotResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSnapshotResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteSnapshotResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteSnapshotResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteStorageSetRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  clientToken?: string;
  regionId?: string;
  storageSetId?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      clientToken: 'ClientToken',
      regionId: 'RegionId',
      storageSetId: 'StorageSetId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      clientToken: 'string',
      regionId: 'string',
      storageSetId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteStorageSetResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteStorageSetResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteStorageSetResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteStorageSetResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteVirtualBorderRouterRequest extends $tea.Model {
  regionId?: string;
  vbrId?: string;
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  clientToken?: string;
  ownerAccount?: string;
  userCidr?: string;
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
      vbrId: 'VbrId',
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      clientToken: 'ClientToken',
      ownerAccount: 'OwnerAccount',
      userCidr: 'UserCidr',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
      vbrId: 'string',
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      clientToken: 'string',
      ownerAccount: 'string',
      userCidr: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteVirtualBorderRouterResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteVirtualBorderRouterResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteVirtualBorderRouterResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteVirtualBorderRouterResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteVpcRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  vpcId?: string;
  regionId?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      vpcId: 'VpcId',
      regionId: 'RegionId',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      vpcId: 'string',
      regionId: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteVpcResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteVpcResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteVpcResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteVpcResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteVSwitchRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  vSwitchId?: string;
  regionId?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      vSwitchId: 'VSwitchId',
      regionId: 'RegionId',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      vSwitchId: 'string',
      regionId: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteVSwitchResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteVSwitchResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteVSwitchResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteVSwitchResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAccessPointsRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  type?: string;
  pageNumber?: number;
  pageSize?: number;
  filter?: DescribeAccessPointsRequestFilter[];
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      type: 'Type',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      filter: 'Filter',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      type: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      filter: { 'type': 'array', 'itemType': DescribeAccessPointsRequestFilter },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAccessPointsResponseBody extends $tea.Model {
  accessPointSet?: DescribeAccessPointsResponseBodyAccessPointSet[];
  totalCount?: number;
  requestId?: string;
  pageSize?: number;
  pageNumber?: number;
  static names(): { [key: string]: string } {
    return {
      accessPointSet: 'AccessPointSet',
      totalCount: 'TotalCount',
      requestId: 'RequestId',
      pageSize: 'PageSize',
      pageNumber: 'PageNumber',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessPointSet: { 'type': 'array', 'itemType': DescribeAccessPointsResponseBodyAccessPointSet },
      totalCount: 'number',
      requestId: 'string',
      pageSize: 'number',
      pageNumber: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAccessPointsResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeAccessPointsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeAccessPointsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAccountAttributesRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  zoneId?: string;
  attributeName?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      zoneId: 'ZoneId',
      attributeName: 'AttributeName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      zoneId: 'string',
      attributeName: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAccountAttributesResponseBody extends $tea.Model {
  requestId?: string;
  accountAttributeItems?: DescribeAccountAttributesResponseBodyAccountAttributeItems[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      accountAttributeItems: 'AccountAttributeItems',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      accountAttributeItems: { 'type': 'array', 'itemType': DescribeAccountAttributesResponseBodyAccountAttributeItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAccountAttributesResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeAccountAttributesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeAccountAttributesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAutoProvisioningGroupHistoryRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  pageNumber?: number;
  pageSize?: number;
  autoProvisioningGroupId?: string;
  startTime?: string;
  endTime?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      autoProvisioningGroupId: 'AutoProvisioningGroupId',
      startTime: 'StartTime',
      endTime: 'EndTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      autoProvisioningGroupId: 'string',
      startTime: 'string',
      endTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAutoProvisioningGroupHistoryResponseBody extends $tea.Model {
  totalCount?: number;
  pageSize?: number;
  requestId?: string;
  pageNumber?: number;
  autoProvisioningGroupHistories?: DescribeAutoProvisioningGroupHistoryResponseBodyAutoProvisioningGroupHistories[];
  static names(): { [key: string]: string } {
    return {
      totalCount: 'TotalCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      pageNumber: 'PageNumber',
      autoProvisioningGroupHistories: 'AutoProvisioningGroupHistories',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      pageNumber: 'number',
      autoProvisioningGroupHistories: { 'type': 'array', 'itemType': DescribeAutoProvisioningGroupHistoryResponseBodyAutoProvisioningGroupHistories },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAutoProvisioningGroupHistoryResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeAutoProvisioningGroupHistoryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeAutoProvisioningGroupHistoryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAutoProvisioningGroupInstancesRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  pageNumber?: number;
  pageSize?: number;
  autoProvisioningGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      autoProvisioningGroupId: 'AutoProvisioningGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      autoProvisioningGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAutoProvisioningGroupInstancesResponseBody extends $tea.Model {
  instances?: DescribeAutoProvisioningGroupInstancesResponseBodyInstances[];
  totalCount?: number;
  pageSize?: number;
  requestId?: string;
  pageNumber?: number;
  static names(): { [key: string]: string } {
    return {
      instances: 'Instances',
      totalCount: 'TotalCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      pageNumber: 'PageNumber',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instances: { 'type': 'array', 'itemType': DescribeAutoProvisioningGroupInstancesResponseBodyInstances },
      totalCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      pageNumber: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAutoProvisioningGroupInstancesResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeAutoProvisioningGroupInstancesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeAutoProvisioningGroupInstancesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAutoProvisioningGroupsRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  pageNumber?: number;
  pageSize?: number;
  autoProvisioningGroupName?: string;
  autoProvisioningGroupId?: string[];
  autoProvisioningGroupStatus?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      autoProvisioningGroupName: 'AutoProvisioningGroupName',
      autoProvisioningGroupId: 'AutoProvisioningGroupId',
      autoProvisioningGroupStatus: 'AutoProvisioningGroupStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      autoProvisioningGroupName: 'string',
      autoProvisioningGroupId: { 'type': 'array', 'itemType': 'string' },
      autoProvisioningGroupStatus: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAutoProvisioningGroupsResponseBody extends $tea.Model {
  totalCount?: number;
  pageSize?: number;
  requestId?: string;
  pageNumber?: number;
  autoProvisioningGroups?: DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroups[];
  static names(): { [key: string]: string } {
    return {
      totalCount: 'TotalCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      pageNumber: 'PageNumber',
      autoProvisioningGroups: 'AutoProvisioningGroups',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      pageNumber: 'number',
      autoProvisioningGroups: { 'type': 'array', 'itemType': DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroups },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAutoProvisioningGroupsResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeAutoProvisioningGroupsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeAutoProvisioningGroupsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAutoSnapshotPolicyExRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  autoSnapshotPolicyId?: string;
  pageNumber?: number;
  pageSize?: number;
  tag?: DescribeAutoSnapshotPolicyExRequestTag[];
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      autoSnapshotPolicyId: 'AutoSnapshotPolicyId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      autoSnapshotPolicyId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      tag: { 'type': 'array', 'itemType': DescribeAutoSnapshotPolicyExRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAutoSnapshotPolicyExResponseBody extends $tea.Model {
  totalCount?: number;
  pageSize?: number;
  requestId?: string;
  pageNumber?: number;
  autoSnapshotPolicies?: DescribeAutoSnapshotPolicyExResponseBodyAutoSnapshotPolicies[];
  static names(): { [key: string]: string } {
    return {
      totalCount: 'TotalCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      pageNumber: 'PageNumber',
      autoSnapshotPolicies: 'AutoSnapshotPolicies',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      pageNumber: 'number',
      autoSnapshotPolicies: { 'type': 'array', 'itemType': DescribeAutoSnapshotPolicyExResponseBodyAutoSnapshotPolicies },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAutoSnapshotPolicyExResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeAutoSnapshotPolicyExResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeAutoSnapshotPolicyExResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAvailableResourceRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  instanceChargeType?: string;
  spotStrategy?: string;
  spotDuration?: number;
  destinationResource?: string;
  zoneId?: string;
  ioOptimized?: string;
  dedicatedHostId?: string;
  instanceType?: string;
  systemDiskCategory?: string;
  dataDiskCategory?: string;
  networkCategory?: string;
  cores?: number;
  memory?: number;
  resourceType?: string;
  scope?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      instanceChargeType: 'InstanceChargeType',
      spotStrategy: 'SpotStrategy',
      spotDuration: 'SpotDuration',
      destinationResource: 'DestinationResource',
      zoneId: 'ZoneId',
      ioOptimized: 'IoOptimized',
      dedicatedHostId: 'DedicatedHostId',
      instanceType: 'InstanceType',
      systemDiskCategory: 'SystemDiskCategory',
      dataDiskCategory: 'DataDiskCategory',
      networkCategory: 'NetworkCategory',
      cores: 'Cores',
      memory: 'Memory',
      resourceType: 'ResourceType',
      scope: 'Scope',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      instanceChargeType: 'string',
      spotStrategy: 'string',
      spotDuration: 'number',
      destinationResource: 'string',
      zoneId: 'string',
      ioOptimized: 'string',
      dedicatedHostId: 'string',
      instanceType: 'string',
      systemDiskCategory: 'string',
      dataDiskCategory: 'string',
      networkCategory: 'string',
      cores: 'number',
      memory: 'number',
      resourceType: 'string',
      scope: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAvailableResourceResponseBody extends $tea.Model {
  requestId?: string;
  availableZones?: DescribeAvailableResourceResponseBodyAvailableZones[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      availableZones: 'AvailableZones',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      availableZones: { 'type': 'array', 'itemType': DescribeAvailableResourceResponseBodyAvailableZones },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAvailableResourceResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeAvailableResourceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeAvailableResourceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBandwidthLimitationRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  instanceChargeType?: string;
  spotStrategy?: string;
  instanceType?: string;
  resourceId?: string;
  operationType?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      instanceChargeType: 'InstanceChargeType',
      spotStrategy: 'SpotStrategy',
      instanceType: 'InstanceType',
      resourceId: 'ResourceId',
      operationType: 'OperationType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      instanceChargeType: 'string',
      spotStrategy: 'string',
      instanceType: 'string',
      resourceId: 'string',
      operationType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBandwidthLimitationResponseBody extends $tea.Model {
  requestId?: string;
  bandwidths?: DescribeBandwidthLimitationResponseBodyBandwidths[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      bandwidths: 'Bandwidths',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      bandwidths: { 'type': 'array', 'itemType': DescribeBandwidthLimitationResponseBodyBandwidths },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBandwidthLimitationResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeBandwidthLimitationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeBandwidthLimitationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBandwidthPackagesRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  bandwidthPackageId?: string;
  natGatewayId?: string;
  pageNumber?: number;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      bandwidthPackageId: 'BandwidthPackageId',
      natGatewayId: 'NatGatewayId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      bandwidthPackageId: 'string',
      natGatewayId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBandwidthPackagesResponseBody extends $tea.Model {
  totalCount?: number;
  pageSize?: number;
  requestId?: string;
  pageNumber?: number;
  bandwidthPackages?: DescribeBandwidthPackagesResponseBodyBandwidthPackages[];
  static names(): { [key: string]: string } {
    return {
      totalCount: 'TotalCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      pageNumber: 'PageNumber',
      bandwidthPackages: 'BandwidthPackages',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      pageNumber: 'number',
      bandwidthPackages: { 'type': 'array', 'itemType': DescribeBandwidthPackagesResponseBodyBandwidthPackages },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBandwidthPackagesResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeBandwidthPackagesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeBandwidthPackagesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCapacityReservationInstancesRequest extends $tea.Model {
  privatePoolOptions?: DescribeCapacityReservationInstancesRequestPrivatePoolOptions;
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  maxResults?: number;
  nextToken?: string;
  packageType?: string;
  static names(): { [key: string]: string } {
    return {
      privatePoolOptions: 'PrivatePoolOptions',
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      packageType: 'PackageType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      privatePoolOptions: DescribeCapacityReservationInstancesRequestPrivatePoolOptions,
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      maxResults: 'number',
      nextToken: 'string',
      packageType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCapacityReservationInstancesResponseBody extends $tea.Model {
  capacityReservationItem?: DescribeCapacityReservationInstancesResponseBodyCapacityReservationItem[];
  totalCount?: number;
  nextToken?: string;
  requestId?: string;
  maxResults?: number;
  static names(): { [key: string]: string } {
    return {
      capacityReservationItem: 'CapacityReservationItem',
      totalCount: 'TotalCount',
      nextToken: 'NextToken',
      requestId: 'RequestId',
      maxResults: 'MaxResults',
    };
  }

  static types(): { [key: string]: any } {
    return {
      capacityReservationItem: { 'type': 'array', 'itemType': DescribeCapacityReservationInstancesResponseBodyCapacityReservationItem },
      totalCount: 'number',
      nextToken: 'string',
      requestId: 'string',
      maxResults: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCapacityReservationInstancesResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeCapacityReservationInstancesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeCapacityReservationInstancesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCapacityReservationsRequest extends $tea.Model {
  privatePoolOptions?: DescribeCapacityReservationsRequestPrivatePoolOptions;
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  maxResults?: number;
  nextToken?: string;
  platform?: string;
  instanceType?: string;
  zoneId?: string;
  instanceChargeType?: string;
  status?: string;
  packageType?: string;
  static names(): { [key: string]: string } {
    return {
      privatePoolOptions: 'PrivatePoolOptions',
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      platform: 'Platform',
      instanceType: 'InstanceType',
      zoneId: 'ZoneId',
      instanceChargeType: 'InstanceChargeType',
      status: 'Status',
      packageType: 'PackageType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      privatePoolOptions: DescribeCapacityReservationsRequestPrivatePoolOptions,
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      maxResults: 'number',
      nextToken: 'string',
      platform: 'string',
      instanceType: 'string',
      zoneId: 'string',
      instanceChargeType: 'string',
      status: 'string',
      packageType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCapacityReservationsResponseBody extends $tea.Model {
  totalCount?: number;
  nextToken?: string;
  requestId?: string;
  maxResults?: number;
  capacityReservationSet?: DescribeCapacityReservationsResponseBodyCapacityReservationSet[];
  static names(): { [key: string]: string } {
    return {
      totalCount: 'TotalCount',
      nextToken: 'NextToken',
      requestId: 'RequestId',
      maxResults: 'MaxResults',
      capacityReservationSet: 'CapacityReservationSet',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalCount: 'number',
      nextToken: 'string',
      requestId: 'string',
      maxResults: 'number',
      capacityReservationSet: { 'type': 'array', 'itemType': DescribeCapacityReservationsResponseBodyCapacityReservationSet },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCapacityReservationsResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeCapacityReservationsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeCapacityReservationsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClassicLinkInstancesRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  vpcId?: string;
  instanceId?: string;
  pageNumber?: string;
  pageSize?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      vpcId: 'VpcId',
      instanceId: 'InstanceId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      vpcId: 'string',
      instanceId: 'string',
      pageNumber: 'string',
      pageSize: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClassicLinkInstancesResponseBody extends $tea.Model {
  totalCount?: number;
  pageSize?: number;
  requestId?: string;
  pageNumber?: number;
  links?: DescribeClassicLinkInstancesResponseBodyLinks[];
  static names(): { [key: string]: string } {
    return {
      totalCount: 'TotalCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      pageNumber: 'PageNumber',
      links: 'Links',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      pageNumber: 'number',
      links: { 'type': 'array', 'itemType': DescribeClassicLinkInstancesResponseBodyLinks },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClassicLinkInstancesResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeClassicLinkInstancesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeClassicLinkInstancesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudAssistantStatusRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  instanceId?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      instanceId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudAssistantStatusResponseBody extends $tea.Model {
  requestId?: string;
  instanceCloudAssistantStatusSet?: DescribeCloudAssistantStatusResponseBodyInstanceCloudAssistantStatusSet[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      instanceCloudAssistantStatusSet: 'InstanceCloudAssistantStatusSet',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      instanceCloudAssistantStatusSet: { 'type': 'array', 'itemType': DescribeCloudAssistantStatusResponseBodyInstanceCloudAssistantStatusSet },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudAssistantStatusResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeCloudAssistantStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeCloudAssistantStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClustersRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClustersResponseBody extends $tea.Model {
  requestId?: string;
  clusters?: DescribeClustersResponseBodyClusters[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      clusters: 'Clusters',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      clusters: { 'type': 'array', 'itemType': DescribeClustersResponseBodyClusters },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClustersResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeClustersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeClustersResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCommandsRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  commandId?: string;
  name?: string;
  description?: string;
  type?: string;
  contentEncoding?: string;
  pageNumber?: number;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      commandId: 'CommandId',
      name: 'Name',
      description: 'Description',
      type: 'Type',
      contentEncoding: 'ContentEncoding',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      commandId: 'string',
      name: 'string',
      description: 'string',
      type: 'string',
      contentEncoding: 'string',
      pageNumber: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCommandsResponseBody extends $tea.Model {
  totalCount?: number;
  pageSize?: number;
  requestId?: string;
  pageNumber?: number;
  commands?: DescribeCommandsResponseBodyCommands[];
  static names(): { [key: string]: string } {
    return {
      totalCount: 'TotalCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      pageNumber: 'PageNumber',
      commands: 'Commands',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      pageNumber: 'number',
      commands: { 'type': 'array', 'itemType': DescribeCommandsResponseBodyCommands },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCommandsResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeCommandsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeCommandsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDedicatedHostAutoRenewRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  dedicatedHostIds?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      dedicatedHostIds: 'DedicatedHostIds',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      dedicatedHostIds: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDedicatedHostAutoRenewResponseBody extends $tea.Model {
  requestId?: string;
  dedicatedHostRenewAttributes?: DescribeDedicatedHostAutoRenewResponseBodyDedicatedHostRenewAttributes[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      dedicatedHostRenewAttributes: 'DedicatedHostRenewAttributes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      dedicatedHostRenewAttributes: { 'type': 'array', 'itemType': DescribeDedicatedHostAutoRenewResponseBodyDedicatedHostRenewAttributes },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDedicatedHostAutoRenewResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeDedicatedHostAutoRenewResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeDedicatedHostAutoRenewResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDedicatedHostClustersRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  status?: string;
  lockReason?: string;
  ownerAccount?: string;
  resourceGroupId?: string;
  tag?: DescribeDedicatedHostClustersRequestTag[];
  regionId?: string;
  zoneId?: string;
  dedicatedHostClusterIds?: string;
  dedicatedHostClusterName?: string;
  pageNumber?: number;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      status: 'Status',
      lockReason: 'LockReason',
      ownerAccount: 'OwnerAccount',
      resourceGroupId: 'ResourceGroupId',
      tag: 'Tag',
      regionId: 'RegionId',
      zoneId: 'ZoneId',
      dedicatedHostClusterIds: 'DedicatedHostClusterIds',
      dedicatedHostClusterName: 'DedicatedHostClusterName',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      status: 'string',
      lockReason: 'string',
      ownerAccount: 'string',
      resourceGroupId: 'string',
      tag: { 'type': 'array', 'itemType': DescribeDedicatedHostClustersRequestTag },
      regionId: 'string',
      zoneId: 'string',
      dedicatedHostClusterIds: 'string',
      dedicatedHostClusterName: 'string',
      pageNumber: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDedicatedHostClustersResponseBody extends $tea.Model {
  dedicatedHostClusters?: DescribeDedicatedHostClustersResponseBodyDedicatedHostClusters[];
  totalCount?: number;
  pageSize?: number;
  requestId?: string;
  pageNumber?: number;
  static names(): { [key: string]: string } {
    return {
      dedicatedHostClusters: 'DedicatedHostClusters',
      totalCount: 'TotalCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      pageNumber: 'PageNumber',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dedicatedHostClusters: { 'type': 'array', 'itemType': DescribeDedicatedHostClustersResponseBodyDedicatedHostClusters },
      totalCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      pageNumber: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDedicatedHostClustersResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeDedicatedHostClustersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeDedicatedHostClustersResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDedicatedHostsRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  zoneId?: string;
  dedicatedHostIds?: string;
  dedicatedHostName?: string;
  status?: string;
  dedicatedHostType?: string;
  lockReason?: string;
  pageNumber?: number;
  pageSize?: number;
  ownerAccount?: string;
  resourceGroupId?: string;
  tag?: DescribeDedicatedHostsRequestTag[];
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      zoneId: 'ZoneId',
      dedicatedHostIds: 'DedicatedHostIds',
      dedicatedHostName: 'DedicatedHostName',
      status: 'Status',
      dedicatedHostType: 'DedicatedHostType',
      lockReason: 'LockReason',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      ownerAccount: 'OwnerAccount',
      resourceGroupId: 'ResourceGroupId',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      zoneId: 'string',
      dedicatedHostIds: 'string',
      dedicatedHostName: 'string',
      status: 'string',
      dedicatedHostType: 'string',
      lockReason: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      ownerAccount: 'string',
      resourceGroupId: 'string',
      tag: { 'type': 'array', 'itemType': DescribeDedicatedHostsRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDedicatedHostsResponseBody extends $tea.Model {
  totalCount?: number;
  dedicatedHosts?: DescribeDedicatedHostsResponseBodyDedicatedHosts[];
  pageSize?: number;
  requestId?: string;
  pageNumber?: number;
  static names(): { [key: string]: string } {
    return {
      totalCount: 'TotalCount',
      dedicatedHosts: 'DedicatedHosts',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      pageNumber: 'PageNumber',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalCount: 'number',
      dedicatedHosts: { 'type': 'array', 'itemType': DescribeDedicatedHostsResponseBodyDedicatedHosts },
      pageSize: 'number',
      requestId: 'string',
      pageNumber: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDedicatedHostsResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeDedicatedHostsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeDedicatedHostsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDedicatedHostTypesRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  dedicatedHostType?: string;
  supportedInstanceTypeFamily?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      dedicatedHostType: 'DedicatedHostType',
      supportedInstanceTypeFamily: 'SupportedInstanceTypeFamily',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      dedicatedHostType: 'string',
      supportedInstanceTypeFamily: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDedicatedHostTypesResponseBody extends $tea.Model {
  requestId?: string;
  dedicatedHostTypes?: DescribeDedicatedHostTypesResponseBodyDedicatedHostTypes[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      dedicatedHostTypes: 'DedicatedHostTypes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      dedicatedHostTypes: { 'type': 'array', 'itemType': DescribeDedicatedHostTypesResponseBodyDedicatedHostTypes },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDedicatedHostTypesResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeDedicatedHostTypesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeDedicatedHostTypesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDemandsRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  pageNumber?: number;
  pageSize?: number;
  dryRun?: boolean;
  tag?: DescribeDemandsRequestTag[];
  zoneId?: string;
  demandId?: string;
  instanceTypeFamily?: string;
  instanceType?: string;
  instanceChargeType?: string;
  demandType?: string;
  demandStatus?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      dryRun: 'DryRun',
      tag: 'Tag',
      zoneId: 'ZoneId',
      demandId: 'DemandId',
      instanceTypeFamily: 'InstanceTypeFamily',
      instanceType: 'InstanceType',
      instanceChargeType: 'InstanceChargeType',
      demandType: 'DemandType',
      demandStatus: 'DemandStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      dryRun: 'boolean',
      tag: { 'type': 'array', 'itemType': DescribeDemandsRequestTag },
      zoneId: 'string',
      demandId: 'string',
      instanceTypeFamily: 'string',
      instanceType: 'string',
      instanceChargeType: 'string',
      demandType: 'string',
      demandStatus: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDemandsResponseBody extends $tea.Model {
  totalCount?: number;
  pageSize?: number;
  requestId?: string;
  pageNumber?: number;
  demands?: DescribeDemandsResponseBodyDemands[];
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      totalCount: 'TotalCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      pageNumber: 'PageNumber',
      demands: 'Demands',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      pageNumber: 'number',
      demands: { 'type': 'array', 'itemType': DescribeDemandsResponseBodyDemands },
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDemandsResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeDemandsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeDemandsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDeploymentSetsRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  pageNumber?: number;
  pageSize?: number;
  ownerAccount?: string;
  deploymentSetIds?: string;
  networkType?: string;
  strategy?: string;
  deploymentSetName?: string;
  granularity?: string;
  domain?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      ownerAccount: 'OwnerAccount',
      deploymentSetIds: 'DeploymentSetIds',
      networkType: 'NetworkType',
      strategy: 'Strategy',
      deploymentSetName: 'DeploymentSetName',
      granularity: 'Granularity',
      domain: 'Domain',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      ownerAccount: 'string',
      deploymentSetIds: 'string',
      networkType: 'string',
      strategy: 'string',
      deploymentSetName: 'string',
      granularity: 'string',
      domain: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDeploymentSetsResponseBody extends $tea.Model {
  totalCount?: number;
  pageSize?: number;
  requestId?: string;
  pageNumber?: number;
  deploymentSets?: DescribeDeploymentSetsResponseBodyDeploymentSets[];
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      totalCount: 'TotalCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      pageNumber: 'PageNumber',
      deploymentSets: 'DeploymentSets',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      pageNumber: 'number',
      deploymentSets: { 'type': 'array', 'itemType': DescribeDeploymentSetsResponseBodyDeploymentSets },
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDeploymentSetsResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeDeploymentSetsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeDeploymentSetsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDeploymentSetSupportedInstanceTypeFamilyRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDeploymentSetSupportedInstanceTypeFamilyResponseBody extends $tea.Model {
  requestId?: string;
  instanceTypeFamilies?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      instanceTypeFamilies: 'InstanceTypeFamilies',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      instanceTypeFamilies: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDeploymentSetSupportedInstanceTypeFamilyResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeDeploymentSetSupportedInstanceTypeFamilyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeDeploymentSetSupportedInstanceTypeFamilyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDiskMonitorDataRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  diskId?: string;
  startTime?: string;
  endTime?: string;
  period?: number;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      diskId: 'DiskId',
      startTime: 'StartTime',
      endTime: 'EndTime',
      period: 'Period',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      diskId: 'string',
      startTime: 'string',
      endTime: 'string',
      period: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDiskMonitorDataResponseBody extends $tea.Model {
  totalCount?: number;
  requestId?: string;
  monitorData?: DescribeDiskMonitorDataResponseBodyMonitorData[];
  static names(): { [key: string]: string } {
    return {
      totalCount: 'TotalCount',
      requestId: 'RequestId',
      monitorData: 'MonitorData',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalCount: 'number',
      requestId: 'string',
      monitorData: { 'type': 'array', 'itemType': DescribeDiskMonitorDataResponseBodyMonitorData },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDiskMonitorDataResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeDiskMonitorDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeDiskMonitorDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDisksRequest extends $tea.Model {
  filter?: DescribeDisksRequestFilter[];
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  zoneId?: string;
  diskIds?: string;
  instanceId?: string;
  diskType?: string;
  category?: string;
  status?: string;
  snapshotId?: string;
  portable?: boolean;
  deleteWithInstance?: boolean;
  deleteAutoSnapshot?: boolean;
  pageNumber?: number;
  pageSize?: number;
  nextToken?: string;
  maxResults?: number;
  ownerAccount?: string;
  diskName?: string;
  autoSnapshotPolicyId?: string;
  enableAutoSnapshot?: boolean;
  enableAutomatedSnapshotPolicy?: boolean;
  diskChargeType?: string;
  lockReason?: string;
  resourceGroupId?: string;
  enableShared?: boolean;
  encrypted?: boolean;
  dryRun?: boolean;
  KMSKeyId?: string;
  tag?: DescribeDisksRequestTag[];
  additionalAttributes?: string[];
  static names(): { [key: string]: string } {
    return {
      filter: 'Filter',
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      zoneId: 'ZoneId',
      diskIds: 'DiskIds',
      instanceId: 'InstanceId',
      diskType: 'DiskType',
      category: 'Category',
      status: 'Status',
      snapshotId: 'SnapshotId',
      portable: 'Portable',
      deleteWithInstance: 'DeleteWithInstance',
      deleteAutoSnapshot: 'DeleteAutoSnapshot',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      nextToken: 'NextToken',
      maxResults: 'MaxResults',
      ownerAccount: 'OwnerAccount',
      diskName: 'DiskName',
      autoSnapshotPolicyId: 'AutoSnapshotPolicyId',
      enableAutoSnapshot: 'EnableAutoSnapshot',
      enableAutomatedSnapshotPolicy: 'EnableAutomatedSnapshotPolicy',
      diskChargeType: 'DiskChargeType',
      lockReason: 'LockReason',
      resourceGroupId: 'ResourceGroupId',
      enableShared: 'EnableShared',
      encrypted: 'Encrypted',
      dryRun: 'DryRun',
      KMSKeyId: 'KMSKeyId',
      tag: 'Tag',
      additionalAttributes: 'AdditionalAttributes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      filter: { 'type': 'array', 'itemType': DescribeDisksRequestFilter },
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      zoneId: 'string',
      diskIds: 'string',
      instanceId: 'string',
      diskType: 'string',
      category: 'string',
      status: 'string',
      snapshotId: 'string',
      portable: 'boolean',
      deleteWithInstance: 'boolean',
      deleteAutoSnapshot: 'boolean',
      pageNumber: 'number',
      pageSize: 'number',
      nextToken: 'string',
      maxResults: 'number',
      ownerAccount: 'string',
      diskName: 'string',
      autoSnapshotPolicyId: 'string',
      enableAutoSnapshot: 'boolean',
      enableAutomatedSnapshotPolicy: 'boolean',
      diskChargeType: 'string',
      lockReason: 'string',
      resourceGroupId: 'string',
      enableShared: 'boolean',
      encrypted: 'boolean',
      dryRun: 'boolean',
      KMSKeyId: 'string',
      tag: { 'type': 'array', 'itemType': DescribeDisksRequestTag },
      additionalAttributes: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDisksResponseBody extends $tea.Model {
  totalCount?: number;
  nextToken?: string;
  pageSize?: number;
  requestId?: string;
  pageNumber?: number;
  disks?: DescribeDisksResponseBodyDisks[];
  static names(): { [key: string]: string } {
    return {
      totalCount: 'TotalCount',
      nextToken: 'NextToken',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      pageNumber: 'PageNumber',
      disks: 'Disks',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalCount: 'number',
      nextToken: 'string',
      pageSize: 'number',
      requestId: 'string',
      pageNumber: 'number',
      disks: { 'type': 'array', 'itemType': DescribeDisksResponseBodyDisks },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDisksResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeDisksResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeDisksResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDisksFullStatusRequest extends $tea.Model {
  eventTime?: DescribeDisksFullStatusRequestEventTime;
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  status?: string;
  healthStatus?: string;
  eventType?: string;
  pageNumber?: number;
  pageSize?: number;
  diskId?: string[];
  eventId?: string[];
  static names(): { [key: string]: string } {
    return {
      eventTime: 'EventTime',
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      status: 'Status',
      healthStatus: 'HealthStatus',
      eventType: 'EventType',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      diskId: 'DiskId',
      eventId: 'EventId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      eventTime: DescribeDisksFullStatusRequestEventTime,
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      status: 'string',
      healthStatus: 'string',
      eventType: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      diskId: { 'type': 'array', 'itemType': 'string' },
      eventId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDisksFullStatusResponseBody extends $tea.Model {
  totalCount?: number;
  pageSize?: number;
  requestId?: string;
  pageNumber?: number;
  diskFullStatusSet?: DescribeDisksFullStatusResponseBodyDiskFullStatusSet[];
  static names(): { [key: string]: string } {
    return {
      totalCount: 'TotalCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      pageNumber: 'PageNumber',
      diskFullStatusSet: 'DiskFullStatusSet',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      pageNumber: 'number',
      diskFullStatusSet: { 'type': 'array', 'itemType': DescribeDisksFullStatusResponseBodyDiskFullStatusSet },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDisksFullStatusResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeDisksFullStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeDisksFullStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEipAddressesRequest extends $tea.Model {
  filter?: DescribeEipAddressesRequestFilter[];
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  status?: string;
  eipAddress?: string;
  allocationId?: string;
  ISP?: string;
  pageNumber?: number;
  pageSize?: number;
  ownerAccount?: string;
  lockReason?: string;
  associatedInstanceType?: string;
  associatedInstanceId?: string;
  chargeType?: string;
  static names(): { [key: string]: string } {
    return {
      filter: 'Filter',
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      status: 'Status',
      eipAddress: 'EipAddress',
      allocationId: 'AllocationId',
      ISP: 'ISP',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      ownerAccount: 'OwnerAccount',
      lockReason: 'LockReason',
      associatedInstanceType: 'AssociatedInstanceType',
      associatedInstanceId: 'AssociatedInstanceId',
      chargeType: 'ChargeType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      filter: { 'type': 'array', 'itemType': DescribeEipAddressesRequestFilter },
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      status: 'string',
      eipAddress: 'string',
      allocationId: 'string',
      ISP: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      ownerAccount: 'string',
      lockReason: 'string',
      associatedInstanceType: 'string',
      associatedInstanceId: 'string',
      chargeType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEipAddressesResponseBody extends $tea.Model {
  totalCount?: number;
  pageSize?: number;
  requestId?: string;
  eipAddresses?: DescribeEipAddressesResponseBodyEipAddresses[];
  pageNumber?: number;
  static names(): { [key: string]: string } {
    return {
      totalCount: 'TotalCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      eipAddresses: 'EipAddresses',
      pageNumber: 'PageNumber',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      eipAddresses: { 'type': 'array', 'itemType': DescribeEipAddressesResponseBodyEipAddresses },
      pageNumber: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEipAddressesResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeEipAddressesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeEipAddressesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEipMonitorDataRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  allocationId?: string;
  startTime?: string;
  endTime?: string;
  period?: number;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      allocationId: 'AllocationId',
      startTime: 'StartTime',
      endTime: 'EndTime',
      period: 'Period',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      allocationId: 'string',
      startTime: 'string',
      endTime: 'string',
      period: 'number',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEipMonitorDataResponseBody extends $tea.Model {
  requestId?: string;
  eipMonitorDatas?: DescribeEipMonitorDataResponseBodyEipMonitorDatas[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      eipMonitorDatas: 'EipMonitorDatas',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      eipMonitorDatas: { 'type': 'array', 'itemType': DescribeEipMonitorDataResponseBodyEipMonitorDatas },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEipMonitorDataResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeEipMonitorDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeEipMonitorDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeElasticityAssuranceInstancesRequest extends $tea.Model {
  privatePoolOptions?: DescribeElasticityAssuranceInstancesRequestPrivatePoolOptions;
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  maxResults?: number;
  nextToken?: string;
  packageType?: string;
  static names(): { [key: string]: string } {
    return {
      privatePoolOptions: 'PrivatePoolOptions',
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      packageType: 'PackageType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      privatePoolOptions: DescribeElasticityAssuranceInstancesRequestPrivatePoolOptions,
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      maxResults: 'number',
      nextToken: 'string',
      packageType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeElasticityAssuranceInstancesResponseBody extends $tea.Model {
  totalCount?: number;
  nextToken?: string;
  requestId?: string;
  maxResults?: number;
  elasticityAssuranceItem?: DescribeElasticityAssuranceInstancesResponseBodyElasticityAssuranceItem[];
  static names(): { [key: string]: string } {
    return {
      totalCount: 'TotalCount',
      nextToken: 'NextToken',
      requestId: 'RequestId',
      maxResults: 'MaxResults',
      elasticityAssuranceItem: 'ElasticityAssuranceItem',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalCount: 'number',
      nextToken: 'string',
      requestId: 'string',
      maxResults: 'number',
      elasticityAssuranceItem: { 'type': 'array', 'itemType': DescribeElasticityAssuranceInstancesResponseBodyElasticityAssuranceItem },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeElasticityAssuranceInstancesResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeElasticityAssuranceInstancesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeElasticityAssuranceInstancesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeElasticityAssurancesRequest extends $tea.Model {
  privatePoolOptions?: DescribeElasticityAssurancesRequestPrivatePoolOptions;
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  maxResults?: number;
  nextToken?: string;
  platform?: string;
  instanceType?: string;
  zoneId?: string;
  instanceChargeType?: string;
  status?: string;
  packageType?: string;
  static names(): { [key: string]: string } {
    return {
      privatePoolOptions: 'PrivatePoolOptions',
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      platform: 'Platform',
      instanceType: 'InstanceType',
      zoneId: 'ZoneId',
      instanceChargeType: 'InstanceChargeType',
      status: 'Status',
      packageType: 'PackageType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      privatePoolOptions: DescribeElasticityAssurancesRequestPrivatePoolOptions,
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      maxResults: 'number',
      nextToken: 'string',
      platform: 'string',
      instanceType: 'string',
      zoneId: 'string',
      instanceChargeType: 'string',
      status: 'string',
      packageType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeElasticityAssurancesResponseBody extends $tea.Model {
  elasticityAssuranceSet?: DescribeElasticityAssurancesResponseBodyElasticityAssuranceSet[];
  totalCount?: number;
  nextToken?: string;
  requestId?: string;
  maxResults?: number;
  static names(): { [key: string]: string } {
    return {
      elasticityAssuranceSet: 'ElasticityAssuranceSet',
      totalCount: 'TotalCount',
      nextToken: 'NextToken',
      requestId: 'RequestId',
      maxResults: 'MaxResults',
    };
  }

  static types(): { [key: string]: any } {
    return {
      elasticityAssuranceSet: { 'type': 'array', 'itemType': DescribeElasticityAssurancesResponseBodyElasticityAssuranceSet },
      totalCount: 'number',
      nextToken: 'string',
      requestId: 'string',
      maxResults: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeElasticityAssurancesResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeElasticityAssurancesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeElasticityAssurancesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEniMonitorDataRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  eniId?: string;
  regionId?: string;
  instanceId?: string;
  startTime?: string;
  endTime?: string;
  period?: number;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      eniId: 'EniId',
      regionId: 'RegionId',
      instanceId: 'InstanceId',
      startTime: 'StartTime',
      endTime: 'EndTime',
      period: 'Period',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      eniId: 'string',
      regionId: 'string',
      instanceId: 'string',
      startTime: 'string',
      endTime: 'string',
      period: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEniMonitorDataResponseBody extends $tea.Model {
  totalCount?: number;
  requestId?: string;
  monitorData?: DescribeEniMonitorDataResponseBodyMonitorData[];
  static names(): { [key: string]: string } {
    return {
      totalCount: 'TotalCount',
      requestId: 'RequestId',
      monitorData: 'MonitorData',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalCount: 'number',
      requestId: 'string',
      monitorData: { 'type': 'array', 'itemType': DescribeEniMonitorDataResponseBodyMonitorData },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEniMonitorDataResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeEniMonitorDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeEniMonitorDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeForwardTableEntriesRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  forwardTableId?: string;
  forwardEntryId?: string;
  pageNumber?: number;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      forwardTableId: 'ForwardTableId',
      forwardEntryId: 'ForwardEntryId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      forwardTableId: 'string',
      forwardEntryId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeForwardTableEntriesResponseBody extends $tea.Model {
  totalCount?: number;
  pageSize?: number;
  requestId?: string;
  pageNumber?: number;
  forwardTableEntries?: DescribeForwardTableEntriesResponseBodyForwardTableEntries[];
  static names(): { [key: string]: string } {
    return {
      totalCount: 'TotalCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      pageNumber: 'PageNumber',
      forwardTableEntries: 'ForwardTableEntries',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      pageNumber: 'number',
      forwardTableEntries: { 'type': 'array', 'itemType': DescribeForwardTableEntriesResponseBodyForwardTableEntries },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeForwardTableEntriesResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeForwardTableEntriesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeForwardTableEntriesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHaVipsRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  pageNumber?: number;
  pageSize?: number;
  filter?: DescribeHaVipsRequestFilter[];
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      filter: 'Filter',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      filter: { 'type': 'array', 'itemType': DescribeHaVipsRequestFilter },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHaVipsResponseBody extends $tea.Model {
  totalCount?: number;
  haVips?: DescribeHaVipsResponseBodyHaVips[];
  pageSize?: number;
  requestId?: string;
  pageNumber?: number;
  static names(): { [key: string]: string } {
    return {
      totalCount: 'TotalCount',
      haVips: 'HaVips',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      pageNumber: 'PageNumber',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalCount: 'number',
      haVips: { 'type': 'array', 'itemType': DescribeHaVipsResponseBodyHaVips },
      pageSize: 'number',
      requestId: 'string',
      pageNumber: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHaVipsResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeHaVipsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeHaVipsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHpcClustersRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  clientToken?: string;
  ownerAccount?: string;
  hpcClusterIds?: string;
  pageNumber?: number;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      clientToken: 'ClientToken',
      ownerAccount: 'OwnerAccount',
      hpcClusterIds: 'HpcClusterIds',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      clientToken: 'string',
      ownerAccount: 'string',
      hpcClusterIds: 'string',
      pageNumber: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHpcClustersResponseBody extends $tea.Model {
  totalCount?: number;
  pageSize?: number;
  requestId?: string;
  pageNumber?: number;
  hpcClusters?: DescribeHpcClustersResponseBodyHpcClusters[];
  static names(): { [key: string]: string } {
    return {
      totalCount: 'TotalCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      pageNumber: 'PageNumber',
      hpcClusters: 'HpcClusters',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      pageNumber: 'number',
      hpcClusters: { 'type': 'array', 'itemType': DescribeHpcClustersResponseBodyHpcClusters },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHpcClustersResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeHpcClustersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeHpcClustersResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageFromFamilyRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  imageFamily?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      imageFamily: 'ImageFamily',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      imageFamily: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageFromFamilyResponseBody extends $tea.Model {
  requestId?: string;
  image?: DescribeImageFromFamilyResponseBodyImage;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      image: 'Image',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      image: DescribeImageFromFamilyResponseBodyImage,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageFromFamilyResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeImageFromFamilyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeImageFromFamilyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImagesRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  status?: string;
  imageId?: string;
  showExpired?: boolean;
  snapshotId?: string;
  imageName?: string;
  imageFamily?: string;
  imageOwnerAlias?: string;
  instanceType?: string;
  isSupportIoOptimized?: boolean;
  isSupportCloudinit?: boolean;
  OSType?: string;
  architecture?: string;
  pageNumber?: number;
  pageSize?: number;
  ownerAccount?: string;
  usage?: string;
  dryRun?: boolean;
  actionType?: string;
  resourceGroupId?: string;
  tag?: DescribeImagesRequestTag[];
  filter?: DescribeImagesRequestFilter[];
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      status: 'Status',
      imageId: 'ImageId',
      showExpired: 'ShowExpired',
      snapshotId: 'SnapshotId',
      imageName: 'ImageName',
      imageFamily: 'ImageFamily',
      imageOwnerAlias: 'ImageOwnerAlias',
      instanceType: 'InstanceType',
      isSupportIoOptimized: 'IsSupportIoOptimized',
      isSupportCloudinit: 'IsSupportCloudinit',
      OSType: 'OSType',
      architecture: 'Architecture',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      ownerAccount: 'OwnerAccount',
      usage: 'Usage',
      dryRun: 'DryRun',
      actionType: 'ActionType',
      resourceGroupId: 'ResourceGroupId',
      tag: 'Tag',
      filter: 'Filter',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      status: 'string',
      imageId: 'string',
      showExpired: 'boolean',
      snapshotId: 'string',
      imageName: 'string',
      imageFamily: 'string',
      imageOwnerAlias: 'string',
      instanceType: 'string',
      isSupportIoOptimized: 'boolean',
      isSupportCloudinit: 'boolean',
      OSType: 'string',
      architecture: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      ownerAccount: 'string',
      usage: 'string',
      dryRun: 'boolean',
      actionType: 'string',
      resourceGroupId: 'string',
      tag: { 'type': 'array', 'itemType': DescribeImagesRequestTag },
      filter: { 'type': 'array', 'itemType': DescribeImagesRequestFilter },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImagesResponseBody extends $tea.Model {
  totalCount?: number;
  pageSize?: number;
  requestId?: string;
  pageNumber?: number;
  images?: DescribeImagesResponseBodyImages[];
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      totalCount: 'TotalCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      pageNumber: 'PageNumber',
      images: 'Images',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      pageNumber: 'number',
      images: { 'type': 'array', 'itemType': DescribeImagesResponseBodyImages },
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImagesResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeImagesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeImagesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageSharePermissionRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  imageId?: string;
  pageNumber?: number;
  pageSize?: number;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      imageId: 'ImageId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      imageId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageSharePermissionResponseBody extends $tea.Model {
  totalCount?: number;
  requestId?: string;
  pageSize?: number;
  pageNumber?: number;
  imageId?: string;
  regionId?: string;
  shareGroups?: DescribeImageSharePermissionResponseBodyShareGroups[];
  accounts?: DescribeImageSharePermissionResponseBodyAccounts[];
  static names(): { [key: string]: string } {
    return {
      totalCount: 'TotalCount',
      requestId: 'RequestId',
      pageSize: 'PageSize',
      pageNumber: 'PageNumber',
      imageId: 'ImageId',
      regionId: 'RegionId',
      shareGroups: 'ShareGroups',
      accounts: 'Accounts',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalCount: 'number',
      requestId: 'string',
      pageSize: 'number',
      pageNumber: 'number',
      imageId: 'string',
      regionId: 'string',
      shareGroups: { 'type': 'array', 'itemType': DescribeImageSharePermissionResponseBodyShareGroups },
      accounts: { 'type': 'array', 'itemType': DescribeImageSharePermissionResponseBodyAccounts },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageSharePermissionResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeImageSharePermissionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeImageSharePermissionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageSupportInstanceTypesRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  imageId?: string;
  actionType?: string;
  filter?: DescribeImageSupportInstanceTypesRequestFilter[];
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      imageId: 'ImageId',
      actionType: 'ActionType',
      filter: 'Filter',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      imageId: 'string',
      actionType: 'string',
      filter: { 'type': 'array', 'itemType': DescribeImageSupportInstanceTypesRequestFilter },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageSupportInstanceTypesResponseBody extends $tea.Model {
  requestId?: string;
  imageId?: string;
  regionId?: string;
  instanceTypes?: DescribeImageSupportInstanceTypesResponseBodyInstanceTypes[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      imageId: 'ImageId',
      regionId: 'RegionId',
      instanceTypes: 'InstanceTypes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      imageId: 'string',
      regionId: 'string',
      instanceTypes: { 'type': 'array', 'itemType': DescribeImageSupportInstanceTypesResponseBodyInstanceTypes },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageSupportInstanceTypesResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeImageSupportInstanceTypesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeImageSupportInstanceTypesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceAttachmentAttributesRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  instanceIds?: string;
  pageNumber?: number;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      instanceIds: 'InstanceIds',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      instanceIds: 'string',
      pageNumber: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceAttachmentAttributesResponseBody extends $tea.Model {
  instances?: DescribeInstanceAttachmentAttributesResponseBodyInstances[];
  totalCount?: number;
  pageSize?: number;
  requestId?: string;
  pageNumber?: number;
  static names(): { [key: string]: string } {
    return {
      instances: 'Instances',
      totalCount: 'TotalCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      pageNumber: 'PageNumber',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instances: { 'type': 'array', 'itemType': DescribeInstanceAttachmentAttributesResponseBodyInstances },
      totalCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      pageNumber: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceAttachmentAttributesResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeInstanceAttachmentAttributesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeInstanceAttachmentAttributesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceAttributeRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  instanceId?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      instanceId: 'InstanceId',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      instanceId: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceAttributeResponseBody extends $tea.Model {
  description?: string;
  memory?: number;
  instanceChargeType?: string;
  cpu?: number;
  instanceNetworkType?: string;
  publicIpAddress?: string[];
  innerIpAddress?: string[];
  expiredTime?: string;
  imageId?: string;
  eipAddress?: DescribeInstanceAttributeResponseBodyEipAddress;
  instanceType?: string;
  vlanId?: string;
  hostName?: string;
  status?: string;
  ioOptimized?: string;
  requestId?: string;
  zoneId?: string;
  clusterId?: string;
  instanceId?: string;
  stoppedMode?: string;
  dedicatedHostAttribute?: DescribeInstanceAttributeResponseBodyDedicatedHostAttribute;
  securityGroupIds?: string[];
  vpcAttributes?: DescribeInstanceAttributeResponseBodyVpcAttributes;
  operationLocks?: DescribeInstanceAttributeResponseBodyOperationLocks[];
  internetChargeType?: string;
  instanceName?: string;
  internetMaxBandwidthOut?: number;
  serialNumber?: string;
  internetMaxBandwidthIn?: number;
  creationTime?: string;
  regionId?: string;
  creditSpecification?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      memory: 'Memory',
      instanceChargeType: 'InstanceChargeType',
      cpu: 'Cpu',
      instanceNetworkType: 'InstanceNetworkType',
      publicIpAddress: 'PublicIpAddress',
      innerIpAddress: 'InnerIpAddress',
      expiredTime: 'ExpiredTime',
      imageId: 'ImageId',
      eipAddress: 'EipAddress',
      instanceType: 'InstanceType',
      vlanId: 'VlanId',
      hostName: 'HostName',
      status: 'Status',
      ioOptimized: 'IoOptimized',
      requestId: 'RequestId',
      zoneId: 'ZoneId',
      clusterId: 'ClusterId',
      instanceId: 'InstanceId',
      stoppedMode: 'StoppedMode',
      dedicatedHostAttribute: 'DedicatedHostAttribute',
      securityGroupIds: 'SecurityGroupIds',
      vpcAttributes: 'VpcAttributes',
      operationLocks: 'OperationLocks',
      internetChargeType: 'InternetChargeType',
      instanceName: 'InstanceName',
      internetMaxBandwidthOut: 'InternetMaxBandwidthOut',
      serialNumber: 'SerialNumber',
      internetMaxBandwidthIn: 'InternetMaxBandwidthIn',
      creationTime: 'CreationTime',
      regionId: 'RegionId',
      creditSpecification: 'CreditSpecification',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      memory: 'number',
      instanceChargeType: 'string',
      cpu: 'number',
      instanceNetworkType: 'string',
      publicIpAddress: { 'type': 'array', 'itemType': 'string' },
      innerIpAddress: { 'type': 'array', 'itemType': 'string' },
      expiredTime: 'string',
      imageId: 'string',
      eipAddress: DescribeInstanceAttributeResponseBodyEipAddress,
      instanceType: 'string',
      vlanId: 'string',
      hostName: 'string',
      status: 'string',
      ioOptimized: 'string',
      requestId: 'string',
      zoneId: 'string',
      clusterId: 'string',
      instanceId: 'string',
      stoppedMode: 'string',
      dedicatedHostAttribute: DescribeInstanceAttributeResponseBodyDedicatedHostAttribute,
      securityGroupIds: { 'type': 'array', 'itemType': 'string' },
      vpcAttributes: DescribeInstanceAttributeResponseBodyVpcAttributes,
      operationLocks: { 'type': 'array', 'itemType': DescribeInstanceAttributeResponseBodyOperationLocks },
      internetChargeType: 'string',
      instanceName: 'string',
      internetMaxBandwidthOut: 'number',
      serialNumber: 'string',
      internetMaxBandwidthIn: 'number',
      creationTime: 'string',
      regionId: 'string',
      creditSpecification: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceAttributeResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeInstanceAttributeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeInstanceAttributeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceAutoRenewAttributeRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  instanceId?: string;
  regionId?: string;
  renewalStatus?: string;
  pageSize?: string;
  pageNumber?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      instanceId: 'InstanceId',
      regionId: 'RegionId',
      renewalStatus: 'RenewalStatus',
      pageSize: 'PageSize',
      pageNumber: 'PageNumber',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      instanceId: 'string',
      regionId: 'string',
      renewalStatus: 'string',
      pageSize: 'string',
      pageNumber: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceAutoRenewAttributeResponseBody extends $tea.Model {
  totalCount?: number;
  instanceRenewAttributes?: DescribeInstanceAutoRenewAttributeResponseBodyInstanceRenewAttributes[];
  requestId?: string;
  pageSize?: number;
  pageNumber?: number;
  static names(): { [key: string]: string } {
    return {
      totalCount: 'TotalCount',
      instanceRenewAttributes: 'InstanceRenewAttributes',
      requestId: 'RequestId',
      pageSize: 'PageSize',
      pageNumber: 'PageNumber',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalCount: 'number',
      instanceRenewAttributes: { 'type': 'array', 'itemType': DescribeInstanceAutoRenewAttributeResponseBodyInstanceRenewAttributes },
      requestId: 'string',
      pageSize: 'number',
      pageNumber: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceAutoRenewAttributeResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeInstanceAutoRenewAttributeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeInstanceAutoRenewAttributeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceHistoryEventsRequest extends $tea.Model {
  notBefore?: DescribeInstanceHistoryEventsRequestNotBefore;
  eventPublishTime?: DescribeInstanceHistoryEventsRequestEventPublishTime;
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  instanceId?: string;
  eventCycleStatus?: string;
  eventType?: string;
  impactLevel?: string;
  pageNumber?: number;
  pageSize?: number;
  eventId?: string[];
  instanceEventCycleStatus?: string[];
  instanceEventType?: string[];
  static names(): { [key: string]: string } {
    return {
      notBefore: 'NotBefore',
      eventPublishTime: 'EventPublishTime',
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      instanceId: 'InstanceId',
      eventCycleStatus: 'EventCycleStatus',
      eventType: 'EventType',
      impactLevel: 'ImpactLevel',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      eventId: 'EventId',
      instanceEventCycleStatus: 'InstanceEventCycleStatus',
      instanceEventType: 'InstanceEventType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      notBefore: DescribeInstanceHistoryEventsRequestNotBefore,
      eventPublishTime: DescribeInstanceHistoryEventsRequestEventPublishTime,
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      instanceId: 'string',
      eventCycleStatus: 'string',
      eventType: 'string',
      impactLevel: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      eventId: { 'type': 'array', 'itemType': 'string' },
      instanceEventCycleStatus: { 'type': 'array', 'itemType': 'string' },
      instanceEventType: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceHistoryEventsResponseBody extends $tea.Model {
  totalCount?: number;
  pageSize?: number;
  requestId?: string;
  pageNumber?: number;
  instanceSystemEventSet?: DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSet[];
  static names(): { [key: string]: string } {
    return {
      totalCount: 'TotalCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      pageNumber: 'PageNumber',
      instanceSystemEventSet: 'InstanceSystemEventSet',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      pageNumber: 'number',
      instanceSystemEventSet: { 'type': 'array', 'itemType': DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSet },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceHistoryEventsResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeInstanceHistoryEventsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeInstanceHistoryEventsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceMaintenanceAttributesRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  pageNumber?: number;
  pageSize?: number;
  instanceId?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      instanceId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceMaintenanceAttributesResponseBody extends $tea.Model {
  totalCount?: number;
  pageSize?: number;
  requestId?: string;
  pageNumber?: number;
  maintenanceAttributes?: DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributes[];
  static names(): { [key: string]: string } {
    return {
      totalCount: 'TotalCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      pageNumber: 'PageNumber',
      maintenanceAttributes: 'MaintenanceAttributes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      pageNumber: 'number',
      maintenanceAttributes: { 'type': 'array', 'itemType': DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributes },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceMaintenanceAttributesResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeInstanceMaintenanceAttributesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeInstanceMaintenanceAttributesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceMonitorDataRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  instanceId?: string;
  startTime?: string;
  endTime?: string;
  period?: number;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      instanceId: 'InstanceId',
      startTime: 'StartTime',
      endTime: 'EndTime',
      period: 'Period',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      instanceId: 'string',
      startTime: 'string',
      endTime: 'string',
      period: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceMonitorDataResponseBody extends $tea.Model {
  requestId?: string;
  monitorData?: DescribeInstanceMonitorDataResponseBodyMonitorData[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      monitorData: 'MonitorData',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      monitorData: { 'type': 'array', 'itemType': DescribeInstanceMonitorDataResponseBodyMonitorData },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceMonitorDataResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeInstanceMonitorDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeInstanceMonitorDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceRamRoleRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  pageNumber?: number;
  pageSize?: number;
  regionId?: string;
  instanceIds?: string;
  ramRoleName?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      instanceIds: 'InstanceIds',
      ramRoleName: 'RamRoleName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      regionId: 'string',
      instanceIds: 'string',
      ramRoleName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceRamRoleResponseBody extends $tea.Model {
  totalCount?: number;
  requestId?: string;
  regionId?: string;
  instanceRamRoleSets?: DescribeInstanceRamRoleResponseBodyInstanceRamRoleSets[];
  static names(): { [key: string]: string } {
    return {
      totalCount: 'TotalCount',
      requestId: 'RequestId',
      regionId: 'RegionId',
      instanceRamRoleSets: 'InstanceRamRoleSets',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalCount: 'number',
      requestId: 'string',
      regionId: 'string',
      instanceRamRoleSets: { 'type': 'array', 'itemType': DescribeInstanceRamRoleResponseBodyInstanceRamRoleSets },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceRamRoleResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeInstanceRamRoleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeInstanceRamRoleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancesRequest extends $tea.Model {
  filter?: DescribeInstancesRequestFilter[];
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  vpcId?: string;
  vSwitchId?: string;
  zoneId?: string;
  instanceNetworkType?: string;
  securityGroupId?: string;
  instanceIds?: string;
  pageNumber?: number;
  pageSize?: number;
  innerIpAddresses?: string;
  privateIpAddresses?: string;
  publicIpAddresses?: string;
  eipAddresses?: string;
  ownerAccount?: string;
  instanceChargeType?: string;
  internetChargeType?: string;
  instanceName?: string;
  imageId?: string;
  status?: string;
  lockReason?: string;
  deviceAvailable?: boolean;
  ioOptimized?: boolean;
  needSaleCycle?: boolean;
  instanceType?: string;
  instanceTypeFamily?: string;
  keyPairName?: string;
  resourceGroupId?: string;
  hpcClusterId?: string;
  rdmaIpAddresses?: string;
  dryRun?: boolean;
  httpEndpoint?: string;
  httpTokens?: string;
  httpPutResponseHopLimit?: number;
  tag?: DescribeInstancesRequestTag[];
  additionalAttributes?: string[];
  static names(): { [key: string]: string } {
    return {
      filter: 'Filter',
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      vpcId: 'VpcId',
      vSwitchId: 'VSwitchId',
      zoneId: 'ZoneId',
      instanceNetworkType: 'InstanceNetworkType',
      securityGroupId: 'SecurityGroupId',
      instanceIds: 'InstanceIds',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      innerIpAddresses: 'InnerIpAddresses',
      privateIpAddresses: 'PrivateIpAddresses',
      publicIpAddresses: 'PublicIpAddresses',
      eipAddresses: 'EipAddresses',
      ownerAccount: 'OwnerAccount',
      instanceChargeType: 'InstanceChargeType',
      internetChargeType: 'InternetChargeType',
      instanceName: 'InstanceName',
      imageId: 'ImageId',
      status: 'Status',
      lockReason: 'LockReason',
      deviceAvailable: 'DeviceAvailable',
      ioOptimized: 'IoOptimized',
      needSaleCycle: 'NeedSaleCycle',
      instanceType: 'InstanceType',
      instanceTypeFamily: 'InstanceTypeFamily',
      keyPairName: 'KeyPairName',
      resourceGroupId: 'ResourceGroupId',
      hpcClusterId: 'HpcClusterId',
      rdmaIpAddresses: 'RdmaIpAddresses',
      dryRun: 'DryRun',
      httpEndpoint: 'HttpEndpoint',
      httpTokens: 'HttpTokens',
      httpPutResponseHopLimit: 'HttpPutResponseHopLimit',
      tag: 'Tag',
      additionalAttributes: 'AdditionalAttributes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      filter: { 'type': 'array', 'itemType': DescribeInstancesRequestFilter },
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      vpcId: 'string',
      vSwitchId: 'string',
      zoneId: 'string',
      instanceNetworkType: 'string',
      securityGroupId: 'string',
      instanceIds: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      innerIpAddresses: 'string',
      privateIpAddresses: 'string',
      publicIpAddresses: 'string',
      eipAddresses: 'string',
      ownerAccount: 'string',
      instanceChargeType: 'string',
      internetChargeType: 'string',
      instanceName: 'string',
      imageId: 'string',
      status: 'string',
      lockReason: 'string',
      deviceAvailable: 'boolean',
      ioOptimized: 'boolean',
      needSaleCycle: 'boolean',
      instanceType: 'string',
      instanceTypeFamily: 'string',
      keyPairName: 'string',
      resourceGroupId: 'string',
      hpcClusterId: 'string',
      rdmaIpAddresses: 'string',
      dryRun: 'boolean',
      httpEndpoint: 'string',
      httpTokens: 'string',
      httpPutResponseHopLimit: 'number',
      tag: { 'type': 'array', 'itemType': DescribeInstancesRequestTag },
      additionalAttributes: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancesResponseBody extends $tea.Model {
  instances?: DescribeInstancesResponseBodyInstances[];
  totalCount?: number;
  pageSize?: number;
  requestId?: string;
  pageNumber?: number;
  static names(): { [key: string]: string } {
    return {
      instances: 'Instances',
      totalCount: 'TotalCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      pageNumber: 'PageNumber',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instances: { 'type': 'array', 'itemType': DescribeInstancesResponseBodyInstances },
      totalCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      pageNumber: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancesResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeInstancesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeInstancesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancesFullStatusRequest extends $tea.Model {
  notBefore?: DescribeInstancesFullStatusRequestNotBefore;
  eventPublishTime?: DescribeInstancesFullStatusRequestEventPublishTime;
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  status?: string;
  healthStatus?: string;
  eventType?: string;
  pageNumber?: number;
  pageSize?: number;
  instanceId?: string[];
  eventId?: string[];
  instanceEventType?: string[];
  static names(): { [key: string]: string } {
    return {
      notBefore: 'NotBefore',
      eventPublishTime: 'EventPublishTime',
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      status: 'Status',
      healthStatus: 'HealthStatus',
      eventType: 'EventType',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      instanceId: 'InstanceId',
      eventId: 'EventId',
      instanceEventType: 'InstanceEventType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      notBefore: DescribeInstancesFullStatusRequestNotBefore,
      eventPublishTime: DescribeInstancesFullStatusRequestEventPublishTime,
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      status: 'string',
      healthStatus: 'string',
      eventType: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      instanceId: { 'type': 'array', 'itemType': 'string' },
      eventId: { 'type': 'array', 'itemType': 'string' },
      instanceEventType: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancesFullStatusResponseBody extends $tea.Model {
  totalCount?: number;
  pageSize?: number;
  requestId?: string;
  pageNumber?: number;
  instanceFullStatusSet?: DescribeInstancesFullStatusResponseBodyInstanceFullStatusSet[];
  static names(): { [key: string]: string } {
    return {
      totalCount: 'TotalCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      pageNumber: 'PageNumber',
      instanceFullStatusSet: 'InstanceFullStatusSet',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      pageNumber: 'number',
      instanceFullStatusSet: { 'type': 'array', 'itemType': DescribeInstancesFullStatusResponseBodyInstanceFullStatusSet },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancesFullStatusResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeInstancesFullStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeInstancesFullStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceStatusRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  zoneId?: string;
  clusterId?: string;
  pageNumber?: number;
  pageSize?: number;
  ownerAccount?: string;
  instanceId?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      zoneId: 'ZoneId',
      clusterId: 'ClusterId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      ownerAccount: 'OwnerAccount',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      zoneId: 'string',
      clusterId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      ownerAccount: 'string',
      instanceId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceStatusResponseBody extends $tea.Model {
  totalCount?: number;
  pageSize?: number;
  requestId?: string;
  pageNumber?: number;
  instanceStatuses?: DescribeInstanceStatusResponseBodyInstanceStatuses[];
  static names(): { [key: string]: string } {
    return {
      totalCount: 'TotalCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      pageNumber: 'PageNumber',
      instanceStatuses: 'InstanceStatuses',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      pageNumber: 'number',
      instanceStatuses: { 'type': 'array', 'itemType': DescribeInstanceStatusResponseBodyInstanceStatuses },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceStatusResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeInstanceStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeInstanceStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTopologyRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  instanceIds?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      instanceIds: 'InstanceIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      instanceIds: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTopologyResponseBody extends $tea.Model {
  requestId?: string;
  topologys?: DescribeInstanceTopologyResponseBodyTopologys[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      topologys: 'Topologys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      topologys: { 'type': 'array', 'itemType': DescribeInstanceTopologyResponseBodyTopologys },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTopologyResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeInstanceTopologyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeInstanceTopologyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTypeFamiliesRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  generation?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      generation: 'Generation',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      generation: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTypeFamiliesResponseBody extends $tea.Model {
  requestId?: string;
  instanceTypeFamilies?: DescribeInstanceTypeFamiliesResponseBodyInstanceTypeFamilies[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      instanceTypeFamilies: 'InstanceTypeFamilies',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      instanceTypeFamilies: { 'type': 'array', 'itemType': DescribeInstanceTypeFamiliesResponseBodyInstanceTypeFamilies },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTypeFamiliesResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeInstanceTypeFamiliesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeInstanceTypeFamiliesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTypesRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  instanceTypeFamily?: string;
  instanceTypes?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      instanceTypeFamily: 'InstanceTypeFamily',
      instanceTypes: 'InstanceTypes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      instanceTypeFamily: 'string',
      instanceTypes: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTypesResponseBody extends $tea.Model {
  requestId?: string;
  instanceTypes?: DescribeInstanceTypesResponseBodyInstanceTypes[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      instanceTypes: 'InstanceTypes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      instanceTypes: { 'type': 'array', 'itemType': DescribeInstanceTypesResponseBodyInstanceTypes },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTypesResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeInstanceTypesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeInstanceTypesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceVncPasswdRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  instanceId?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      instanceId: 'InstanceId',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      instanceId: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceVncPasswdResponseBody extends $tea.Model {
  vncPasswd?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      vncPasswd: 'VncPasswd',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      vncPasswd: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceVncPasswdResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeInstanceVncPasswdResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeInstanceVncPasswdResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceVncUrlRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  instanceId?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      instanceId: 'InstanceId',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      instanceId: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceVncUrlResponseBody extends $tea.Model {
  requestId?: string;
  vncUrl?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      vncUrl: 'VncUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      vncUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceVncUrlResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeInstanceVncUrlResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeInstanceVncUrlResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInvocationResultsRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  invokeId?: string;
  instanceId?: string;
  commandId?: string;
  invokeRecordStatus?: string;
  includeHistory?: boolean;
  contentEncoding?: string;
  pageNumber?: number;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      invokeId: 'InvokeId',
      instanceId: 'InstanceId',
      commandId: 'CommandId',
      invokeRecordStatus: 'InvokeRecordStatus',
      includeHistory: 'IncludeHistory',
      contentEncoding: 'ContentEncoding',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      invokeId: 'string',
      instanceId: 'string',
      commandId: 'string',
      invokeRecordStatus: 'string',
      includeHistory: 'boolean',
      contentEncoding: 'string',
      pageNumber: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInvocationResultsResponseBody extends $tea.Model {
  requestId?: string;
  invocation?: DescribeInvocationResultsResponseBodyInvocation;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      invocation: 'Invocation',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      invocation: DescribeInvocationResultsResponseBodyInvocation,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInvocationResultsResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeInvocationResultsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeInvocationResultsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInvocationsRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  invokeId?: string;
  commandId?: string;
  commandName?: string;
  commandType?: string;
  timed?: boolean;
  invokeStatus?: string;
  instanceId?: string;
  contentEncoding?: string;
  includeOutput?: boolean;
  pageNumber?: number;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      invokeId: 'InvokeId',
      commandId: 'CommandId',
      commandName: 'CommandName',
      commandType: 'CommandType',
      timed: 'Timed',
      invokeStatus: 'InvokeStatus',
      instanceId: 'InstanceId',
      contentEncoding: 'ContentEncoding',
      includeOutput: 'IncludeOutput',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      invokeId: 'string',
      commandId: 'string',
      commandName: 'string',
      commandType: 'string',
      timed: 'boolean',
      invokeStatus: 'string',
      instanceId: 'string',
      contentEncoding: 'string',
      includeOutput: 'boolean',
      pageNumber: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInvocationsResponseBody extends $tea.Model {
  totalCount?: number;
  pageSize?: number;
  requestId?: string;
  pageNumber?: number;
  invocations?: DescribeInvocationsResponseBodyInvocations[];
  static names(): { [key: string]: string } {
    return {
      totalCount: 'TotalCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      pageNumber: 'PageNumber',
      invocations: 'Invocations',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      pageNumber: 'number',
      invocations: { 'type': 'array', 'itemType': DescribeInvocationsResponseBodyInvocations },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInvocationsResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeInvocationsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeInvocationsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeKeyPairsRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  keyPairName?: string;
  keyPairFingerPrint?: string;
  pageNumber?: number;
  pageSize?: number;
  resourceGroupId?: string;
  tag?: DescribeKeyPairsRequestTag[];
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      keyPairName: 'KeyPairName',
      keyPairFingerPrint: 'KeyPairFingerPrint',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      resourceGroupId: 'ResourceGroupId',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      keyPairName: 'string',
      keyPairFingerPrint: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      resourceGroupId: 'string',
      tag: { 'type': 'array', 'itemType': DescribeKeyPairsRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeKeyPairsResponseBody extends $tea.Model {
  totalCount?: number;
  pageSize?: number;
  requestId?: string;
  pageNumber?: number;
  keyPairs?: DescribeKeyPairsResponseBodyKeyPairs[];
  static names(): { [key: string]: string } {
    return {
      totalCount: 'TotalCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      pageNumber: 'PageNumber',
      keyPairs: 'KeyPairs',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      pageNumber: 'number',
      keyPairs: { 'type': 'array', 'itemType': DescribeKeyPairsResponseBodyKeyPairs },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeKeyPairsResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeKeyPairsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeKeyPairsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLaunchTemplatesRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  templateTag?: DescribeLaunchTemplatesRequestTemplateTag[];
  pageNumber?: number;
  pageSize?: number;
  templateResourceGroupId?: string;
  launchTemplateId?: string[];
  launchTemplateName?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      templateTag: 'TemplateTag',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      templateResourceGroupId: 'TemplateResourceGroupId',
      launchTemplateId: 'LaunchTemplateId',
      launchTemplateName: 'LaunchTemplateName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      templateTag: { 'type': 'array', 'itemType': DescribeLaunchTemplatesRequestTemplateTag },
      pageNumber: 'number',
      pageSize: 'number',
      templateResourceGroupId: 'string',
      launchTemplateId: { 'type': 'array', 'itemType': 'string' },
      launchTemplateName: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLaunchTemplatesResponseBody extends $tea.Model {
  totalCount?: number;
  launchTemplateSets?: DescribeLaunchTemplatesResponseBodyLaunchTemplateSets[];
  pageSize?: number;
  requestId?: string;
  pageNumber?: number;
  static names(): { [key: string]: string } {
    return {
      totalCount: 'TotalCount',
      launchTemplateSets: 'LaunchTemplateSets',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      pageNumber: 'PageNumber',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalCount: 'number',
      launchTemplateSets: { 'type': 'array', 'itemType': DescribeLaunchTemplatesResponseBodyLaunchTemplateSets },
      pageSize: 'number',
      requestId: 'string',
      pageNumber: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLaunchTemplatesResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeLaunchTemplatesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeLaunchTemplatesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLaunchTemplateVersionsRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  launchTemplateId?: string;
  launchTemplateName?: string;
  minVersion?: number;
  maxVersion?: number;
  defaultVersion?: boolean;
  detailFlag?: boolean;
  pageNumber?: number;
  pageSize?: number;
  launchTemplateVersion?: number[];
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      launchTemplateId: 'LaunchTemplateId',
      launchTemplateName: 'LaunchTemplateName',
      minVersion: 'MinVersion',
      maxVersion: 'MaxVersion',
      defaultVersion: 'DefaultVersion',
      detailFlag: 'DetailFlag',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      launchTemplateVersion: 'LaunchTemplateVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      launchTemplateId: 'string',
      launchTemplateName: 'string',
      minVersion: 'number',
      maxVersion: 'number',
      defaultVersion: 'boolean',
      detailFlag: 'boolean',
      pageNumber: 'number',
      pageSize: 'number',
      launchTemplateVersion: { 'type': 'array', 'itemType': 'number' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLaunchTemplateVersionsResponseBody extends $tea.Model {
  totalCount?: number;
  pageSize?: number;
  requestId?: string;
  pageNumber?: number;
  launchTemplateVersionSets?: DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSets[];
  static names(): { [key: string]: string } {
    return {
      totalCount: 'TotalCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      pageNumber: 'PageNumber',
      launchTemplateVersionSets: 'LaunchTemplateVersionSets',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      pageNumber: 'number',
      launchTemplateVersionSets: { 'type': 'array', 'itemType': DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSets },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLaunchTemplateVersionsResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeLaunchTemplateVersionsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeLaunchTemplateVersionsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLimitationRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  limitation?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      limitation: 'Limitation',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      limitation: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLimitationResponseBody extends $tea.Model {
  requestId?: string;
  limitation?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      limitation: 'Limitation',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      limitation: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLimitationResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeLimitationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeLimitationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNatGatewaysRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  natGatewayId?: string;
  vpcId?: string;
  pageNumber?: number;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      natGatewayId: 'NatGatewayId',
      vpcId: 'VpcId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      natGatewayId: 'string',
      vpcId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNatGatewaysResponseBody extends $tea.Model {
  totalCount?: number;
  pageSize?: number;
  requestId?: string;
  pageNumber?: number;
  natGateways?: DescribeNatGatewaysResponseBodyNatGateways[];
  static names(): { [key: string]: string } {
    return {
      totalCount: 'TotalCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      pageNumber: 'PageNumber',
      natGateways: 'NatGateways',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      pageNumber: 'number',
      natGateways: { 'type': 'array', 'itemType': DescribeNatGatewaysResponseBodyNatGateways },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNatGatewaysResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeNatGatewaysResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeNatGatewaysResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNetworkInterfaceAttributeRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  tag?: DescribeNetworkInterfaceAttributeRequestTag[];
  networkInterfaceId?: string;
  attribute?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      tag: 'Tag',
      networkInterfaceId: 'NetworkInterfaceId',
      attribute: 'Attribute',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      tag: { 'type': 'array', 'itemType': DescribeNetworkInterfaceAttributeRequestTag },
      networkInterfaceId: 'string',
      attribute: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNetworkInterfaceAttributeResponseBody extends $tea.Model {
  status?: string;
  description?: string;
  privateIpAddress?: string;
  serviceManaged?: boolean;
  requestId?: string;
  resourceGroupId?: string;
  zoneId?: string;
  instanceId?: string;
  vSwitchId?: string;
  networkInterfaceName?: string;
  attachment?: DescribeNetworkInterfaceAttributeResponseBodyAttachment;
  macAddress?: string;
  networkInterfaceId?: string;
  securityGroupIds?: string[];
  serviceID?: number;
  type?: string;
  queueNumber?: number;
  ipv6Sets?: DescribeNetworkInterfaceAttributeResponseBodyIpv6Sets[];
  vpcId?: string;
  ownerId?: string;
  associatedPublicIp?: DescribeNetworkInterfaceAttributeResponseBodyAssociatedPublicIp;
  creationTime?: string;
  tags?: DescribeNetworkInterfaceAttributeResponseBodyTags[];
  privateIpSets?: DescribeNetworkInterfaceAttributeResponseBodyPrivateIpSets[];
  static names(): { [key: string]: string } {
    return {
      status: 'Status',
      description: 'Description',
      privateIpAddress: 'PrivateIpAddress',
      serviceManaged: 'ServiceManaged',
      requestId: 'RequestId',
      resourceGroupId: 'ResourceGroupId',
      zoneId: 'ZoneId',
      instanceId: 'InstanceId',
      vSwitchId: 'VSwitchId',
      networkInterfaceName: 'NetworkInterfaceName',
      attachment: 'Attachment',
      macAddress: 'MacAddress',
      networkInterfaceId: 'NetworkInterfaceId',
      securityGroupIds: 'SecurityGroupIds',
      serviceID: 'ServiceID',
      type: 'Type',
      queueNumber: 'QueueNumber',
      ipv6Sets: 'Ipv6Sets',
      vpcId: 'VpcId',
      ownerId: 'OwnerId',
      associatedPublicIp: 'AssociatedPublicIp',
      creationTime: 'CreationTime',
      tags: 'Tags',
      privateIpSets: 'PrivateIpSets',
    };
  }

  static types(): { [key: string]: any } {
    return {
      status: 'string',
      description: 'string',
      privateIpAddress: 'string',
      serviceManaged: 'boolean',
      requestId: 'string',
      resourceGroupId: 'string',
      zoneId: 'string',
      instanceId: 'string',
      vSwitchId: 'string',
      networkInterfaceName: 'string',
      attachment: DescribeNetworkInterfaceAttributeResponseBodyAttachment,
      macAddress: 'string',
      networkInterfaceId: 'string',
      securityGroupIds: { 'type': 'array', 'itemType': 'string' },
      serviceID: 'number',
      type: 'string',
      queueNumber: 'number',
      ipv6Sets: { 'type': 'array', 'itemType': DescribeNetworkInterfaceAttributeResponseBodyIpv6Sets },
      vpcId: 'string',
      ownerId: 'string',
      associatedPublicIp: DescribeNetworkInterfaceAttributeResponseBodyAssociatedPublicIp,
      creationTime: 'string',
      tags: { 'type': 'array', 'itemType': DescribeNetworkInterfaceAttributeResponseBodyTags },
      privateIpSets: { 'type': 'array', 'itemType': DescribeNetworkInterfaceAttributeResponseBodyPrivateIpSets },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNetworkInterfaceAttributeResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeNetworkInterfaceAttributeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeNetworkInterfaceAttributeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNetworkInterfacePermissionsRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  networkInterfaceId?: string;
  pageNumber?: number;
  pageSize?: number;
  networkInterfacePermissionId?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      networkInterfaceId: 'NetworkInterfaceId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      networkInterfacePermissionId: 'NetworkInterfacePermissionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      networkInterfaceId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      networkInterfacePermissionId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNetworkInterfacePermissionsResponseBody extends $tea.Model {
  totalCount?: number;
  pageSize?: number;
  requestId?: string;
  pageNumber?: number;
  networkInterfacePermissions?: DescribeNetworkInterfacePermissionsResponseBodyNetworkInterfacePermissions[];
  static names(): { [key: string]: string } {
    return {
      totalCount: 'TotalCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      pageNumber: 'PageNumber',
      networkInterfacePermissions: 'NetworkInterfacePermissions',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      pageNumber: 'number',
      networkInterfacePermissions: { 'type': 'array', 'itemType': DescribeNetworkInterfacePermissionsResponseBodyNetworkInterfacePermissions },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNetworkInterfacePermissionsResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeNetworkInterfacePermissionsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeNetworkInterfacePermissionsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNetworkInterfacesRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  resourceGroupId?: string;
  tag?: DescribeNetworkInterfacesRequestTag[];
  vSwitchId?: string;
  vpcId?: string;
  primaryIpAddress?: string;
  securityGroupId?: string;
  networkInterfaceName?: string;
  type?: string;
  instanceId?: string;
  serviceManaged?: boolean;
  status?: string;
  pageNumber?: number;
  pageSize?: number;
  nextToken?: string;
  maxResults?: number;
  privateIpAddress?: string[];
  networkInterfaceId?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      tag: 'Tag',
      vSwitchId: 'VSwitchId',
      vpcId: 'VpcId',
      primaryIpAddress: 'PrimaryIpAddress',
      securityGroupId: 'SecurityGroupId',
      networkInterfaceName: 'NetworkInterfaceName',
      type: 'Type',
      instanceId: 'InstanceId',
      serviceManaged: 'ServiceManaged',
      status: 'Status',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      nextToken: 'NextToken',
      maxResults: 'MaxResults',
      privateIpAddress: 'PrivateIpAddress',
      networkInterfaceId: 'NetworkInterfaceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      tag: { 'type': 'array', 'itemType': DescribeNetworkInterfacesRequestTag },
      vSwitchId: 'string',
      vpcId: 'string',
      primaryIpAddress: 'string',
      securityGroupId: 'string',
      networkInterfaceName: 'string',
      type: 'string',
      instanceId: 'string',
      serviceManaged: 'boolean',
      status: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      nextToken: 'string',
      maxResults: 'number',
      privateIpAddress: { 'type': 'array', 'itemType': 'string' },
      networkInterfaceId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNetworkInterfacesResponseBody extends $tea.Model {
  totalCount?: number;
  nextToken?: string;
  pageSize?: number;
  requestId?: string;
  pageNumber?: number;
  networkInterfaceSets?: DescribeNetworkInterfacesResponseBodyNetworkInterfaceSets[];
  static names(): { [key: string]: string } {
    return {
      totalCount: 'TotalCount',
      nextToken: 'NextToken',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      pageNumber: 'PageNumber',
      networkInterfaceSets: 'NetworkInterfaceSets',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalCount: 'number',
      nextToken: 'string',
      pageSize: 'number',
      requestId: 'string',
      pageNumber: 'number',
      networkInterfaceSets: { 'type': 'array', 'itemType': DescribeNetworkInterfacesResponseBodyNetworkInterfaceSets },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNetworkInterfacesResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeNetworkInterfacesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeNetworkInterfacesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNewProjectEipMonitorDataRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  allocationId?: string;
  startTime?: string;
  endTime?: string;
  period?: number;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      allocationId: 'AllocationId',
      startTime: 'StartTime',
      endTime: 'EndTime',
      period: 'Period',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      allocationId: 'string',
      startTime: 'string',
      endTime: 'string',
      period: 'number',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNewProjectEipMonitorDataResponseBody extends $tea.Model {
  requestId?: string;
  eipMonitorDatas?: DescribeNewProjectEipMonitorDataResponseBodyEipMonitorDatas[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      eipMonitorDatas: 'EipMonitorDatas',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      eipMonitorDatas: { 'type': 'array', 'itemType': DescribeNewProjectEipMonitorDataResponseBodyEipMonitorDatas },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNewProjectEipMonitorDataResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeNewProjectEipMonitorDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeNewProjectEipMonitorDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePhysicalConnectionsRequest extends $tea.Model {
  regionId?: string;
  pageNumber?: number;
  pageSize?: number;
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  clientToken?: string;
  ownerAccount?: string;
  userCidr?: string;
  filter?: DescribePhysicalConnectionsRequestFilter[];
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      clientToken: 'ClientToken',
      ownerAccount: 'OwnerAccount',
      userCidr: 'UserCidr',
      filter: 'Filter',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      clientToken: 'string',
      ownerAccount: 'string',
      userCidr: 'string',
      filter: { 'type': 'array', 'itemType': DescribePhysicalConnectionsRequestFilter },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePhysicalConnectionsResponseBody extends $tea.Model {
  physicalConnectionSet?: DescribePhysicalConnectionsResponseBodyPhysicalConnectionSet[];
  totalCount?: number;
  requestId?: string;
  pageSize?: number;
  pageNumber?: number;
  static names(): { [key: string]: string } {
    return {
      physicalConnectionSet: 'PhysicalConnectionSet',
      totalCount: 'TotalCount',
      requestId: 'RequestId',
      pageSize: 'PageSize',
      pageNumber: 'PageNumber',
    };
  }

  static types(): { [key: string]: any } {
    return {
      physicalConnectionSet: { 'type': 'array', 'itemType': DescribePhysicalConnectionsResponseBodyPhysicalConnectionSet },
      totalCount: 'number',
      requestId: 'string',
      pageSize: 'number',
      pageNumber: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePhysicalConnectionsResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribePhysicalConnectionsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribePhysicalConnectionsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePriceRequest extends $tea.Model {
  systemDisk?: DescribePriceRequestSystemDisk;
  dataDisk?: DescribePriceRequestDataDisk[];
  ownerId?: number;
  ownerAccount?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  resourceType?: string;
  imageId?: string;
  instanceType?: string;
  ioOptimized?: string;
  instanceNetworkType?: string;
  internetChargeType?: string;
  internetMaxBandwidthOut?: number;
  period?: number;
  priceUnit?: string;
  amount?: number;
  offeringType?: string;
  instanceAmount?: number;
  scope?: string;
  platform?: string;
  capacity?: number;
  assuranceTimes?: string;
  instanceCpuCoreCount?: number;
  isp?: string;
  instanceTypeList?: string[];
  static names(): { [key: string]: string } {
    return {
      systemDisk: 'SystemDisk',
      dataDisk: 'DataDisk',
      ownerId: 'OwnerId',
      ownerAccount: 'OwnerAccount',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      resourceType: 'ResourceType',
      imageId: 'ImageId',
      instanceType: 'InstanceType',
      ioOptimized: 'IoOptimized',
      instanceNetworkType: 'InstanceNetworkType',
      internetChargeType: 'InternetChargeType',
      internetMaxBandwidthOut: 'InternetMaxBandwidthOut',
      period: 'Period',
      priceUnit: 'PriceUnit',
      amount: 'Amount',
      offeringType: 'OfferingType',
      instanceAmount: 'InstanceAmount',
      scope: 'Scope',
      platform: 'Platform',
      capacity: 'Capacity',
      assuranceTimes: 'AssuranceTimes',
      instanceCpuCoreCount: 'InstanceCpuCoreCount',
      isp: 'Isp',
      instanceTypeList: 'InstanceTypeList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      systemDisk: DescribePriceRequestSystemDisk,
      dataDisk: { 'type': 'array', 'itemType': DescribePriceRequestDataDisk },
      ownerId: 'number',
      ownerAccount: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      resourceType: 'string',
      imageId: 'string',
      instanceType: 'string',
      ioOptimized: 'string',
      instanceNetworkType: 'string',
      internetChargeType: 'string',
      internetMaxBandwidthOut: 'number',
      period: 'number',
      priceUnit: 'string',
      amount: 'number',
      offeringType: 'string',
      instanceAmount: 'number',
      scope: 'string',
      platform: 'string',
      capacity: 'number',
      assuranceTimes: 'string',
      instanceCpuCoreCount: 'number',
      isp: 'string',
      instanceTypeList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePriceResponseBody extends $tea.Model {
  requestId?: string;
  priceInfo?: DescribePriceResponseBodyPriceInfo;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      priceInfo: 'PriceInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      priceInfo: DescribePriceResponseBodyPriceInfo,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePriceResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribePriceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribePriceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRecommendInstanceTypeRequest extends $tea.Model {
  ownerId?: number;
  ownerAccount?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  cores?: number;
  memory?: number;
  instanceFamilyLevel?: string;
  instanceType?: string;
  networkType?: string;
  instanceChargeType?: string;
  spotStrategy?: string;
  ioOptimized?: string;
  priorityStrategy?: string;
  maxPrice?: number;
  instanceBandwidthRx?: number;
  instanceBandwidthTx?: number;
  instancePpsRx?: number;
  instancePpsTx?: number;
  regionId?: string;
  zoneId?: string;
  systemDiskCategory?: string;
  scene?: string;
  instanceTypeFamily?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      ownerAccount: 'OwnerAccount',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      cores: 'Cores',
      memory: 'Memory',
      instanceFamilyLevel: 'InstanceFamilyLevel',
      instanceType: 'InstanceType',
      networkType: 'NetworkType',
      instanceChargeType: 'InstanceChargeType',
      spotStrategy: 'SpotStrategy',
      ioOptimized: 'IoOptimized',
      priorityStrategy: 'PriorityStrategy',
      maxPrice: 'MaxPrice',
      instanceBandwidthRx: 'InstanceBandwidthRx',
      instanceBandwidthTx: 'InstanceBandwidthTx',
      instancePpsRx: 'InstancePpsRx',
      instancePpsTx: 'InstancePpsTx',
      regionId: 'RegionId',
      zoneId: 'ZoneId',
      systemDiskCategory: 'SystemDiskCategory',
      scene: 'Scene',
      instanceTypeFamily: 'InstanceTypeFamily',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      ownerAccount: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      cores: 'number',
      memory: 'number',
      instanceFamilyLevel: 'string',
      instanceType: 'string',
      networkType: 'string',
      instanceChargeType: 'string',
      spotStrategy: 'string',
      ioOptimized: 'string',
      priorityStrategy: 'string',
      maxPrice: 'number',
      instanceBandwidthRx: 'number',
      instanceBandwidthTx: 'number',
      instancePpsRx: 'number',
      instancePpsTx: 'number',
      regionId: 'string',
      zoneId: 'string',
      systemDiskCategory: 'string',
      scene: 'string',
      instanceTypeFamily: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRecommendInstanceTypeResponseBody extends $tea.Model {
  requestId?: string;
  data?: DescribeRecommendInstanceTypeResponseBodyData[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      data: { 'type': 'array', 'itemType': DescribeRecommendInstanceTypeResponseBodyData },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRecommendInstanceTypeResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeRecommendInstanceTypeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeRecommendInstanceTypeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRegionsRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  instanceChargeType?: string;
  resourceType?: string;
  acceptLanguage?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      instanceChargeType: 'InstanceChargeType',
      resourceType: 'ResourceType',
      acceptLanguage: 'AcceptLanguage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      instanceChargeType: 'string',
      resourceType: 'string',
      acceptLanguage: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRegionsResponseBody extends $tea.Model {
  requestId?: string;
  regions?: DescribeRegionsResponseBodyRegions[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      regions: 'Regions',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      regions: { 'type': 'array', 'itemType': DescribeRegionsResponseBodyRegions },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRegionsResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeRegionsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeRegionsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRenewalPriceRequest extends $tea.Model {
  ownerId?: number;
  ownerAccount?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  resourceType?: string;
  resourceId?: string;
  period?: number;
  priceUnit?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      ownerAccount: 'OwnerAccount',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      resourceType: 'ResourceType',
      resourceId: 'ResourceId',
      period: 'Period',
      priceUnit: 'PriceUnit',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      ownerAccount: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      resourceType: 'string',
      resourceId: 'string',
      period: 'number',
      priceUnit: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRenewalPriceResponseBody extends $tea.Model {
  requestId?: string;
  priceInfo?: DescribeRenewalPriceResponseBodyPriceInfo;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      priceInfo: 'PriceInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      priceInfo: DescribeRenewalPriceResponseBodyPriceInfo,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRenewalPriceResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeRenewalPriceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeRenewalPriceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeReservedInstancesRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  pageNumber?: number;
  pageSize?: number;
  tag?: DescribeReservedInstancesRequestTag[];
  zoneId?: string;
  reservedInstanceName?: string;
  lockReason?: string;
  instanceType?: string;
  instanceTypeFamily?: string;
  scope?: string;
  offeringType?: string;
  allocationType?: string;
  reservedInstanceId?: string[];
  status?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      tag: 'Tag',
      zoneId: 'ZoneId',
      reservedInstanceName: 'ReservedInstanceName',
      lockReason: 'LockReason',
      instanceType: 'InstanceType',
      instanceTypeFamily: 'InstanceTypeFamily',
      scope: 'Scope',
      offeringType: 'OfferingType',
      allocationType: 'AllocationType',
      reservedInstanceId: 'ReservedInstanceId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      tag: { 'type': 'array', 'itemType': DescribeReservedInstancesRequestTag },
      zoneId: 'string',
      reservedInstanceName: 'string',
      lockReason: 'string',
      instanceType: 'string',
      instanceTypeFamily: 'string',
      scope: 'string',
      offeringType: 'string',
      allocationType: 'string',
      reservedInstanceId: { 'type': 'array', 'itemType': 'string' },
      status: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeReservedInstancesResponseBody extends $tea.Model {
  totalCount?: number;
  pageSize?: number;
  requestId?: string;
  pageNumber?: number;
  reservedInstances?: DescribeReservedInstancesResponseBodyReservedInstances[];
  static names(): { [key: string]: string } {
    return {
      totalCount: 'TotalCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      pageNumber: 'PageNumber',
      reservedInstances: 'ReservedInstances',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      pageNumber: 'number',
      reservedInstances: { 'type': 'array', 'itemType': DescribeReservedInstancesResponseBodyReservedInstances },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeReservedInstancesResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeReservedInstancesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeReservedInstancesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourceByTagsRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  pageSize?: number;
  pageNumber?: number;
  resourceType?: string;
  regionId?: string;
  tag?: DescribeResourceByTagsRequestTag[];
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      pageSize: 'PageSize',
      pageNumber: 'PageNumber',
      resourceType: 'ResourceType',
      regionId: 'RegionId',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      pageSize: 'number',
      pageNumber: 'number',
      resourceType: 'string',
      regionId: 'string',
      tag: { 'type': 'array', 'itemType': DescribeResourceByTagsRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourceByTagsResponseBody extends $tea.Model {
  totalCount?: number;
  requestId?: string;
  pageSize?: number;
  pageNumber?: number;
  resources?: DescribeResourceByTagsResponseBodyResources[];
  static names(): { [key: string]: string } {
    return {
      totalCount: 'TotalCount',
      requestId: 'RequestId',
      pageSize: 'PageSize',
      pageNumber: 'PageNumber',
      resources: 'Resources',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalCount: 'number',
      requestId: 'string',
      pageSize: 'number',
      pageNumber: 'number',
      resources: { 'type': 'array', 'itemType': DescribeResourceByTagsResponseBodyResources },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourceByTagsResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeResourceByTagsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeResourceByTagsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourcesModificationRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  resourceId?: string;
  migrateAcrossZone?: boolean;
  destinationResource?: string;
  operationType?: string;
  instanceType?: string;
  cores?: number;
  memory?: number;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      resourceId: 'ResourceId',
      migrateAcrossZone: 'MigrateAcrossZone',
      destinationResource: 'DestinationResource',
      operationType: 'OperationType',
      instanceType: 'InstanceType',
      cores: 'Cores',
      memory: 'Memory',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      resourceId: 'string',
      migrateAcrossZone: 'boolean',
      destinationResource: 'string',
      operationType: 'string',
      instanceType: 'string',
      cores: 'number',
      memory: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourcesModificationResponseBody extends $tea.Model {
  requestId?: string;
  availableZones?: DescribeResourcesModificationResponseBodyAvailableZones[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      availableZones: 'AvailableZones',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      availableZones: { 'type': 'array', 'itemType': DescribeResourcesModificationResponseBodyAvailableZones },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourcesModificationResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeResourcesModificationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeResourcesModificationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRouterInterfacesRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  pageNumber?: number;
  pageSize?: number;
  filter?: DescribeRouterInterfacesRequestFilter[];
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      filter: 'Filter',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      filter: { 'type': 'array', 'itemType': DescribeRouterInterfacesRequestFilter },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRouterInterfacesResponseBody extends $tea.Model {
  totalCount?: number;
  requestId?: string;
  pageSize?: number;
  pageNumber?: number;
  routerInterfaceSet?: DescribeRouterInterfacesResponseBodyRouterInterfaceSet[];
  static names(): { [key: string]: string } {
    return {
      totalCount: 'TotalCount',
      requestId: 'RequestId',
      pageSize: 'PageSize',
      pageNumber: 'PageNumber',
      routerInterfaceSet: 'RouterInterfaceSet',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalCount: 'number',
      requestId: 'string',
      pageSize: 'number',
      pageNumber: 'number',
      routerInterfaceSet: { 'type': 'array', 'itemType': DescribeRouterInterfacesResponseBodyRouterInterfaceSet },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRouterInterfacesResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeRouterInterfacesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeRouterInterfacesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRouteTablesRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  VRouterId?: string;
  routeTableId?: string;
  routerType?: string;
  routerId?: string;
  routeTableName?: string;
  pageNumber?: number;
  pageSize?: number;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      VRouterId: 'VRouterId',
      routeTableId: 'RouteTableId',
      routerType: 'RouterType',
      routerId: 'RouterId',
      routeTableName: 'RouteTableName',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      VRouterId: 'string',
      routeTableId: 'string',
      routerType: 'string',
      routerId: 'string',
      routeTableName: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRouteTablesResponseBody extends $tea.Model {
  totalCount?: number;
  pageSize?: number;
  requestId?: string;
  pageNumber?: number;
  routeTables?: DescribeRouteTablesResponseBodyRouteTables[];
  static names(): { [key: string]: string } {
    return {
      totalCount: 'TotalCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      pageNumber: 'PageNumber',
      routeTables: 'RouteTables',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      pageNumber: 'number',
      routeTables: { 'type': 'array', 'itemType': DescribeRouteTablesResponseBodyRouteTables },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRouteTablesResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeRouteTablesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeRouteTablesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSecurityGroupAttributeRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  securityGroupId?: string;
  regionId?: string;
  nicType?: string;
  ownerAccount?: string;
  direction?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      securityGroupId: 'SecurityGroupId',
      regionId: 'RegionId',
      nicType: 'NicType',
      ownerAccount: 'OwnerAccount',
      direction: 'Direction',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      securityGroupId: 'string',
      regionId: 'string',
      nicType: 'string',
      ownerAccount: 'string',
      direction: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSecurityGroupAttributeResponseBody extends $tea.Model {
  description?: string;
  vpcId?: string;
  requestId?: string;
  securityGroupName?: string;
  securityGroupId?: string;
  permissions?: DescribeSecurityGroupAttributeResponseBodyPermissions[];
  innerAccessPolicy?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      vpcId: 'VpcId',
      requestId: 'RequestId',
      securityGroupName: 'SecurityGroupName',
      securityGroupId: 'SecurityGroupId',
      permissions: 'Permissions',
      innerAccessPolicy: 'InnerAccessPolicy',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      vpcId: 'string',
      requestId: 'string',
      securityGroupName: 'string',
      securityGroupId: 'string',
      permissions: { 'type': 'array', 'itemType': DescribeSecurityGroupAttributeResponseBodyPermissions },
      innerAccessPolicy: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSecurityGroupAttributeResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeSecurityGroupAttributeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeSecurityGroupAttributeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSecurityGroupReferencesRequest extends $tea.Model {
  regionId?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  ownerId?: number;
  securityGroupId?: string[];
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      securityGroupId: 'SecurityGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      ownerId: 'number',
      securityGroupId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSecurityGroupReferencesResponseBody extends $tea.Model {
  requestId?: string;
  securityGroupReferences?: DescribeSecurityGroupReferencesResponseBodySecurityGroupReferences[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      securityGroupReferences: 'SecurityGroupReferences',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      securityGroupReferences: { 'type': 'array', 'itemType': DescribeSecurityGroupReferencesResponseBodySecurityGroupReferences },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSecurityGroupReferencesResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeSecurityGroupReferencesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeSecurityGroupReferencesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSecurityGroupsRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  vpcId?: string;
  pageNumber?: number;
  pageSize?: number;
  ownerAccount?: string;
  securityGroupIds?: string;
  resourceGroupId?: string;
  networkType?: string;
  securityGroupId?: string;
  securityGroupName?: string;
  isQueryEcsCount?: boolean;
  fuzzyQuery?: boolean;
  securityGroupType?: string;
  dryRun?: boolean;
  tag?: DescribeSecurityGroupsRequestTag[];
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      vpcId: 'VpcId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      ownerAccount: 'OwnerAccount',
      securityGroupIds: 'SecurityGroupIds',
      resourceGroupId: 'ResourceGroupId',
      networkType: 'NetworkType',
      securityGroupId: 'SecurityGroupId',
      securityGroupName: 'SecurityGroupName',
      isQueryEcsCount: 'IsQueryEcsCount',
      fuzzyQuery: 'FuzzyQuery',
      securityGroupType: 'SecurityGroupType',
      dryRun: 'DryRun',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      vpcId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      ownerAccount: 'string',
      securityGroupIds: 'string',
      resourceGroupId: 'string',
      networkType: 'string',
      securityGroupId: 'string',
      securityGroupName: 'string',
      isQueryEcsCount: 'boolean',
      fuzzyQuery: 'boolean',
      securityGroupType: 'string',
      dryRun: 'boolean',
      tag: { 'type': 'array', 'itemType': DescribeSecurityGroupsRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSecurityGroupsResponseBody extends $tea.Model {
  securityGroups?: DescribeSecurityGroupsResponseBodySecurityGroups[];
  totalCount?: number;
  pageSize?: number;
  requestId?: string;
  pageNumber?: number;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      securityGroups: 'SecurityGroups',
      totalCount: 'TotalCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      pageNumber: 'PageNumber',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      securityGroups: { 'type': 'array', 'itemType': DescribeSecurityGroupsResponseBodySecurityGroups },
      totalCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      pageNumber: 'number',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSecurityGroupsResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeSecurityGroupsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeSecurityGroupsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSendFileResultsRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  invokeId?: string;
  name?: string;
  instanceId?: string;
  pageNumber?: number;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      invokeId: 'InvokeId',
      name: 'Name',
      instanceId: 'InstanceId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      invokeId: 'string',
      name: 'string',
      instanceId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSendFileResultsResponseBody extends $tea.Model {
  totalCount?: number;
  pageSize?: number;
  requestId?: string;
  pageNumber?: number;
  invocations?: DescribeSendFileResultsResponseBodyInvocations[];
  static names(): { [key: string]: string } {
    return {
      totalCount: 'TotalCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      pageNumber: 'PageNumber',
      invocations: 'Invocations',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      pageNumber: 'number',
      invocations: { 'type': 'array', 'itemType': DescribeSendFileResultsResponseBodyInvocations },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSendFileResultsResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeSendFileResultsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeSendFileResultsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSnapshotLinksRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  instanceId?: string;
  diskIds?: string;
  snapshotLinkIds?: string;
  pageNumber?: number;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      instanceId: 'InstanceId',
      diskIds: 'DiskIds',
      snapshotLinkIds: 'SnapshotLinkIds',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      instanceId: 'string',
      diskIds: 'string',
      snapshotLinkIds: 'string',
      pageNumber: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSnapshotLinksResponseBody extends $tea.Model {
  totalCount?: number;
  snapshotLinks?: DescribeSnapshotLinksResponseBodySnapshotLinks[];
  pageSize?: number;
  requestId?: string;
  pageNumber?: number;
  static names(): { [key: string]: string } {
    return {
      totalCount: 'TotalCount',
      snapshotLinks: 'SnapshotLinks',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      pageNumber: 'PageNumber',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalCount: 'number',
      snapshotLinks: { 'type': 'array', 'itemType': DescribeSnapshotLinksResponseBodySnapshotLinks },
      pageSize: 'number',
      requestId: 'string',
      pageNumber: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSnapshotLinksResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeSnapshotLinksResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeSnapshotLinksResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSnapshotMonitorDataRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  startTime?: string;
  endTime?: string;
  period?: number;
  category?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      startTime: 'StartTime',
      endTime: 'EndTime',
      period: 'Period',
      category: 'Category',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      startTime: 'string',
      endTime: 'string',
      period: 'number',
      category: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSnapshotMonitorDataResponseBody extends $tea.Model {
  requestId?: string;
  monitorData?: DescribeSnapshotMonitorDataResponseBodyMonitorData[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      monitorData: 'MonitorData',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      monitorData: { 'type': 'array', 'itemType': DescribeSnapshotMonitorDataResponseBodyMonitorData },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSnapshotMonitorDataResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeSnapshotMonitorDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeSnapshotMonitorDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSnapshotPackageRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  pageNumber?: number;
  pageSize?: number;
  regionId?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      regionId: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSnapshotPackageResponseBody extends $tea.Model {
  totalCount?: number;
  pageSize?: number;
  requestId?: string;
  pageNumber?: number;
  snapshotPackages?: DescribeSnapshotPackageResponseBodySnapshotPackages[];
  static names(): { [key: string]: string } {
    return {
      totalCount: 'TotalCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      pageNumber: 'PageNumber',
      snapshotPackages: 'SnapshotPackages',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      pageNumber: 'number',
      snapshotPackages: { 'type': 'array', 'itemType': DescribeSnapshotPackageResponseBodySnapshotPackages },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSnapshotPackageResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeSnapshotPackageResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeSnapshotPackageResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSnapshotsRequest extends $tea.Model {
  filter?: DescribeSnapshotsRequestFilter[];
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  instanceId?: string;
  diskId?: string;
  snapshotLinkId?: string;
  regionId?: string;
  snapshotIds?: string;
  pageNumber?: number;
  pageSize?: number;
  nextToken?: string;
  maxResults?: number;
  ownerAccount?: string;
  snapshotName?: string;
  status?: string;
  snapshotType?: string;
  usage?: string;
  sourceDiskType?: string;
  encrypted?: boolean;
  resourceGroupId?: string;
  dryRun?: boolean;
  KMSKeyId?: string;
  category?: string;
  tag?: DescribeSnapshotsRequestTag[];
  static names(): { [key: string]: string } {
    return {
      filter: 'Filter',
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      instanceId: 'InstanceId',
      diskId: 'DiskId',
      snapshotLinkId: 'SnapshotLinkId',
      regionId: 'RegionId',
      snapshotIds: 'SnapshotIds',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      nextToken: 'NextToken',
      maxResults: 'MaxResults',
      ownerAccount: 'OwnerAccount',
      snapshotName: 'SnapshotName',
      status: 'Status',
      snapshotType: 'SnapshotType',
      usage: 'Usage',
      sourceDiskType: 'SourceDiskType',
      encrypted: 'Encrypted',
      resourceGroupId: 'ResourceGroupId',
      dryRun: 'DryRun',
      KMSKeyId: 'KMSKeyId',
      category: 'Category',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      filter: { 'type': 'array', 'itemType': DescribeSnapshotsRequestFilter },
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      instanceId: 'string',
      diskId: 'string',
      snapshotLinkId: 'string',
      regionId: 'string',
      snapshotIds: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      nextToken: 'string',
      maxResults: 'number',
      ownerAccount: 'string',
      snapshotName: 'string',
      status: 'string',
      snapshotType: 'string',
      usage: 'string',
      sourceDiskType: 'string',
      encrypted: 'boolean',
      resourceGroupId: 'string',
      dryRun: 'boolean',
      KMSKeyId: 'string',
      category: 'string',
      tag: { 'type': 'array', 'itemType': DescribeSnapshotsRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSnapshotsResponseBody extends $tea.Model {
  totalCount?: number;
  nextToken?: string;
  pageSize?: number;
  requestId?: string;
  pageNumber?: number;
  snapshots?: DescribeSnapshotsResponseBodySnapshots[];
  static names(): { [key: string]: string } {
    return {
      totalCount: 'TotalCount',
      nextToken: 'NextToken',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      pageNumber: 'PageNumber',
      snapshots: 'Snapshots',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalCount: 'number',
      nextToken: 'string',
      pageSize: 'number',
      requestId: 'string',
      pageNumber: 'number',
      snapshots: { 'type': 'array', 'itemType': DescribeSnapshotsResponseBodySnapshots },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSnapshotsResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeSnapshotsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeSnapshotsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSnapshotsUsageRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSnapshotsUsageResponseBody extends $tea.Model {
  snapshotCount?: number;
  snapshotSize?: number;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      snapshotCount: 'SnapshotCount',
      snapshotSize: 'SnapshotSize',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      snapshotCount: 'number',
      snapshotSize: 'number',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSnapshotsUsageResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeSnapshotsUsageResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeSnapshotsUsageResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSpotAdviceRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  cores?: number;
  memory?: number;
  minCores?: number;
  minMemory?: number;
  zoneId?: string;
  instanceTypeFamily?: string;
  instanceFamilyLevel?: string;
  gpuSpec?: string;
  gpuAmount?: number;
  networkType?: string;
  ioOptimized?: string;
  instanceTypes?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      cores: 'Cores',
      memory: 'Memory',
      minCores: 'MinCores',
      minMemory: 'MinMemory',
      zoneId: 'ZoneId',
      instanceTypeFamily: 'InstanceTypeFamily',
      instanceFamilyLevel: 'InstanceFamilyLevel',
      gpuSpec: 'GpuSpec',
      gpuAmount: 'GpuAmount',
      networkType: 'NetworkType',
      ioOptimized: 'IoOptimized',
      instanceTypes: 'InstanceTypes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      cores: 'number',
      memory: 'number',
      minCores: 'number',
      minMemory: 'number',
      zoneId: 'string',
      instanceTypeFamily: 'string',
      instanceFamilyLevel: 'string',
      gpuSpec: 'string',
      gpuAmount: 'number',
      networkType: 'string',
      ioOptimized: 'string',
      instanceTypes: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSpotAdviceResponseBody extends $tea.Model {
  requestId?: string;
  availableSpotZones?: DescribeSpotAdviceResponseBodyAvailableSpotZones[];
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      availableSpotZones: 'AvailableSpotZones',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      availableSpotZones: { 'type': 'array', 'itemType': DescribeSpotAdviceResponseBodyAvailableSpotZones },
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSpotAdviceResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeSpotAdviceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeSpotAdviceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSpotPriceHistoryRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  zoneId?: string;
  networkType?: string;
  instanceType?: string;
  spotDuration?: number;
  ioOptimized?: string;
  startTime?: string;
  endTime?: string;
  OSType?: string;
  offset?: number;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      zoneId: 'ZoneId',
      networkType: 'NetworkType',
      instanceType: 'InstanceType',
      spotDuration: 'SpotDuration',
      ioOptimized: 'IoOptimized',
      startTime: 'StartTime',
      endTime: 'EndTime',
      OSType: 'OSType',
      offset: 'Offset',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      zoneId: 'string',
      networkType: 'string',
      instanceType: 'string',
      spotDuration: 'number',
      ioOptimized: 'string',
      startTime: 'string',
      endTime: 'string',
      OSType: 'string',
      offset: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSpotPriceHistoryResponseBody extends $tea.Model {
  requestId?: string;
  currency?: string;
  nextOffset?: number;
  spotPrices?: DescribeSpotPriceHistoryResponseBodySpotPrices[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      currency: 'Currency',
      nextOffset: 'NextOffset',
      spotPrices: 'SpotPrices',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      currency: 'string',
      nextOffset: 'number',
      spotPrices: { 'type': 'array', 'itemType': DescribeSpotPriceHistoryResponseBodySpotPrices },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSpotPriceHistoryResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeSpotPriceHistoryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeSpotPriceHistoryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeStorageCapacityUnitsRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  pageNumber?: number;
  pageSize?: number;
  name?: string;
  capacity?: number;
  allocationType?: string;
  storageCapacityUnitId?: string[];
  status?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      name: 'Name',
      capacity: 'Capacity',
      allocationType: 'AllocationType',
      storageCapacityUnitId: 'StorageCapacityUnitId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      name: 'string',
      capacity: 'number',
      allocationType: 'string',
      storageCapacityUnitId: { 'type': 'array', 'itemType': 'string' },
      status: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeStorageCapacityUnitsResponseBody extends $tea.Model {
  totalCount?: number;
  pageSize?: number;
  requestId?: string;
  pageNumber?: number;
  storageCapacityUnits?: DescribeStorageCapacityUnitsResponseBodyStorageCapacityUnits[];
  static names(): { [key: string]: string } {
    return {
      totalCount: 'TotalCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      pageNumber: 'PageNumber',
      storageCapacityUnits: 'StorageCapacityUnits',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      pageNumber: 'number',
      storageCapacityUnits: { 'type': 'array', 'itemType': DescribeStorageCapacityUnitsResponseBodyStorageCapacityUnits },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeStorageCapacityUnitsResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeStorageCapacityUnitsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeStorageCapacityUnitsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeStorageSetDetailsRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  clientToken?: string;
  regionId?: string;
  storageSetId?: string;
  storageSetPartitionNumber?: number;
  diskIds?: string;
  pageNumber?: number;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      clientToken: 'ClientToken',
      regionId: 'RegionId',
      storageSetId: 'StorageSetId',
      storageSetPartitionNumber: 'StorageSetPartitionNumber',
      diskIds: 'DiskIds',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      clientToken: 'string',
      regionId: 'string',
      storageSetId: 'string',
      storageSetPartitionNumber: 'number',
      diskIds: 'string',
      pageNumber: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeStorageSetDetailsResponseBody extends $tea.Model {
  totalCount?: number;
  pageSize?: number;
  requestId?: string;
  pageNumber?: number;
  disks?: DescribeStorageSetDetailsResponseBodyDisks[];
  static names(): { [key: string]: string } {
    return {
      totalCount: 'TotalCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      pageNumber: 'PageNumber',
      disks: 'Disks',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      pageNumber: 'number',
      disks: { 'type': 'array', 'itemType': DescribeStorageSetDetailsResponseBodyDisks },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeStorageSetDetailsResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeStorageSetDetailsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeStorageSetDetailsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeStorageSetsRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  clientToken?: string;
  regionId?: string;
  storageSetIds?: string;
  zoneId?: string;
  storageSetName?: string;
  pageNumber?: number;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      clientToken: 'ClientToken',
      regionId: 'RegionId',
      storageSetIds: 'StorageSetIds',
      zoneId: 'ZoneId',
      storageSetName: 'StorageSetName',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      clientToken: 'string',
      regionId: 'string',
      storageSetIds: 'string',
      zoneId: 'string',
      storageSetName: 'string',
      pageNumber: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeStorageSetsResponseBody extends $tea.Model {
  totalCount?: number;
  pageSize?: number;
  requestId?: string;
  pageNumber?: number;
  storageSets?: DescribeStorageSetsResponseBodyStorageSets[];
  static names(): { [key: string]: string } {
    return {
      totalCount: 'TotalCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      pageNumber: 'PageNumber',
      storageSets: 'StorageSets',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      pageNumber: 'number',
      storageSets: { 'type': 'array', 'itemType': DescribeStorageSetsResponseBodyStorageSets },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeStorageSetsResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeStorageSetsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeStorageSetsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTagsRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  pageSize?: number;
  pageNumber?: number;
  resourceType?: string;
  resourceId?: string;
  regionId?: string;
  category?: string;
  tag?: DescribeTagsRequestTag[];
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      pageSize: 'PageSize',
      pageNumber: 'PageNumber',
      resourceType: 'ResourceType',
      resourceId: 'ResourceId',
      regionId: 'RegionId',
      category: 'Category',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      pageSize: 'number',
      pageNumber: 'number',
      resourceType: 'string',
      resourceId: 'string',
      regionId: 'string',
      category: 'string',
      tag: { 'type': 'array', 'itemType': DescribeTagsRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTagsResponseBody extends $tea.Model {
  totalCount?: number;
  requestId?: string;
  pageSize?: number;
  pageNumber?: number;
  tags?: DescribeTagsResponseBodyTags[];
  static names(): { [key: string]: string } {
    return {
      totalCount: 'TotalCount',
      requestId: 'RequestId',
      pageSize: 'PageSize',
      pageNumber: 'PageNumber',
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalCount: 'number',
      requestId: 'string',
      pageSize: 'number',
      pageNumber: 'number',
      tags: { 'type': 'array', 'itemType': DescribeTagsResponseBodyTags },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTagsResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeTagsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeTagsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTaskAttributeRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  taskId?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      taskId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTaskAttributeResponseBody extends $tea.Model {
  taskId?: string;
  requestId?: string;
  taskAction?: string;
  successCount?: number;
  taskStatus?: string;
  finishedTime?: string;
  totalCount?: number;
  taskProcess?: string;
  supportCancel?: string;
  operationProgressSet?: DescribeTaskAttributeResponseBodyOperationProgressSet[];
  creationTime?: string;
  failedCount?: number;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      taskId: 'TaskId',
      requestId: 'RequestId',
      taskAction: 'TaskAction',
      successCount: 'SuccessCount',
      taskStatus: 'TaskStatus',
      finishedTime: 'FinishedTime',
      totalCount: 'TotalCount',
      taskProcess: 'TaskProcess',
      supportCancel: 'SupportCancel',
      operationProgressSet: 'OperationProgressSet',
      creationTime: 'CreationTime',
      failedCount: 'FailedCount',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      taskId: 'string',
      requestId: 'string',
      taskAction: 'string',
      successCount: 'number',
      taskStatus: 'string',
      finishedTime: 'string',
      totalCount: 'number',
      taskProcess: 'string',
      supportCancel: 'string',
      operationProgressSet: { 'type': 'array', 'itemType': DescribeTaskAttributeResponseBodyOperationProgressSet },
      creationTime: 'string',
      failedCount: 'number',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTaskAttributeResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeTaskAttributeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeTaskAttributeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTasksRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  pageNumber?: number;
  pageSize?: number;
  ownerAccount?: string;
  regionId?: string;
  taskIds?: string;
  taskAction?: string;
  taskStatus?: string;
  startTime?: string;
  endTime?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      taskIds: 'TaskIds',
      taskAction: 'TaskAction',
      taskStatus: 'TaskStatus',
      startTime: 'StartTime',
      endTime: 'EndTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      taskIds: 'string',
      taskAction: 'string',
      taskStatus: 'string',
      startTime: 'string',
      endTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTasksResponseBody extends $tea.Model {
  totalCount?: number;
  pageSize?: number;
  requestId?: string;
  pageNumber?: number;
  taskSet?: DescribeTasksResponseBodyTaskSet[];
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      totalCount: 'TotalCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      pageNumber: 'PageNumber',
      taskSet: 'TaskSet',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      pageNumber: 'number',
      taskSet: { 'type': 'array', 'itemType': DescribeTasksResponseBodyTaskSet },
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTasksResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeTasksResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeTasksResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUserBusinessBehaviorRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  statusKey?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      statusKey: 'statusKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      statusKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUserBusinessBehaviorResponseBody extends $tea.Model {
  requestId?: string;
  statusValue?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      statusValue: 'StatusValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      statusValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUserBusinessBehaviorResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeUserBusinessBehaviorResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeUserBusinessBehaviorResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUserDataRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      instanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUserDataResponseBody extends $tea.Model {
  requestId?: string;
  instanceId?: string;
  userData?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      instanceId: 'InstanceId',
      userData: 'UserData',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      instanceId: 'string',
      userData: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUserDataResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeUserDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeUserDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVirtualBorderRoutersRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  pageNumber?: number;
  pageSize?: number;
  filter?: DescribeVirtualBorderRoutersRequestFilter[];
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      filter: 'Filter',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      filter: { 'type': 'array', 'itemType': DescribeVirtualBorderRoutersRequestFilter },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVirtualBorderRoutersResponseBody extends $tea.Model {
  totalCount?: number;
  requestId?: string;
  pageSize?: number;
  pageNumber?: number;
  virtualBorderRouterSet?: DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSet[];
  static names(): { [key: string]: string } {
    return {
      totalCount: 'TotalCount',
      requestId: 'RequestId',
      pageSize: 'PageSize',
      pageNumber: 'PageNumber',
      virtualBorderRouterSet: 'VirtualBorderRouterSet',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalCount: 'number',
      requestId: 'string',
      pageSize: 'number',
      pageNumber: 'number',
      virtualBorderRouterSet: { 'type': 'array', 'itemType': DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSet },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVirtualBorderRoutersResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeVirtualBorderRoutersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeVirtualBorderRoutersResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVirtualBorderRoutersForPhysicalConnectionRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  physicalConnectionId?: string;
  pageNumber?: number;
  pageSize?: number;
  filter?: DescribeVirtualBorderRoutersForPhysicalConnectionRequestFilter[];
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      physicalConnectionId: 'PhysicalConnectionId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      filter: 'Filter',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      physicalConnectionId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      filter: { 'type': 'array', 'itemType': DescribeVirtualBorderRoutersForPhysicalConnectionRequestFilter },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody extends $tea.Model {
  totalCount?: number;
  requestId?: string;
  pageSize?: number;
  pageNumber?: number;
  virtualBorderRouterForPhysicalConnectionSet?: DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSet[];
  static names(): { [key: string]: string } {
    return {
      totalCount: 'TotalCount',
      requestId: 'RequestId',
      pageSize: 'PageSize',
      pageNumber: 'PageNumber',
      virtualBorderRouterForPhysicalConnectionSet: 'VirtualBorderRouterForPhysicalConnectionSet',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalCount: 'number',
      requestId: 'string',
      pageSize: 'number',
      pageNumber: 'number',
      virtualBorderRouterForPhysicalConnectionSet: { 'type': 'array', 'itemType': DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSet },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVirtualBorderRoutersForPhysicalConnectionResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVpcsRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  vpcId?: string;
  regionId?: string;
  isDefault?: boolean;
  pageNumber?: number;
  pageSize?: number;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      vpcId: 'VpcId',
      regionId: 'RegionId',
      isDefault: 'IsDefault',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      vpcId: 'string',
      regionId: 'string',
      isDefault: 'boolean',
      pageNumber: 'number',
      pageSize: 'number',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVpcsResponseBody extends $tea.Model {
  totalCount?: number;
  vpcs?: DescribeVpcsResponseBodyVpcs[];
  pageSize?: number;
  requestId?: string;
  pageNumber?: number;
  static names(): { [key: string]: string } {
    return {
      totalCount: 'TotalCount',
      vpcs: 'Vpcs',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      pageNumber: 'PageNumber',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalCount: 'number',
      vpcs: { 'type': 'array', 'itemType': DescribeVpcsResponseBodyVpcs },
      pageSize: 'number',
      requestId: 'string',
      pageNumber: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVpcsResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeVpcsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeVpcsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVRoutersRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  VRouterId?: string;
  regionId?: string;
  pageNumber?: number;
  pageSize?: number;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      VRouterId: 'VRouterId',
      regionId: 'RegionId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      VRouterId: 'string',
      regionId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVRoutersResponseBody extends $tea.Model {
  VRouters?: DescribeVRoutersResponseBodyVRouters[];
  totalCount?: number;
  pageSize?: number;
  requestId?: string;
  pageNumber?: number;
  static names(): { [key: string]: string } {
    return {
      VRouters: 'VRouters',
      totalCount: 'TotalCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      pageNumber: 'PageNumber',
    };
  }

  static types(): { [key: string]: any } {
    return {
      VRouters: { 'type': 'array', 'itemType': DescribeVRoutersResponseBodyVRouters },
      totalCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      pageNumber: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVRoutersResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeVRoutersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeVRoutersResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVSwitchesRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  vpcId?: string;
  vSwitchId?: string;
  zoneId?: string;
  regionId?: string;
  isDefault?: boolean;
  pageNumber?: number;
  pageSize?: number;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      vpcId: 'VpcId',
      vSwitchId: 'VSwitchId',
      zoneId: 'ZoneId',
      regionId: 'RegionId',
      isDefault: 'IsDefault',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      vpcId: 'string',
      vSwitchId: 'string',
      zoneId: 'string',
      regionId: 'string',
      isDefault: 'boolean',
      pageNumber: 'number',
      pageSize: 'number',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVSwitchesResponseBody extends $tea.Model {
  totalCount?: number;
  pageSize?: number;
  requestId?: string;
  pageNumber?: number;
  vSwitches?: DescribeVSwitchesResponseBodyVSwitches[];
  static names(): { [key: string]: string } {
    return {
      totalCount: 'TotalCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      pageNumber: 'PageNumber',
      vSwitches: 'VSwitches',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      pageNumber: 'number',
      vSwitches: { 'type': 'array', 'itemType': DescribeVSwitchesResponseBodyVSwitches },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVSwitchesResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeVSwitchesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeVSwitchesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeZonesRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  ownerAccount?: string;
  verbose?: boolean;
  instanceChargeType?: string;
  spotStrategy?: string;
  acceptLanguage?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      ownerAccount: 'OwnerAccount',
      verbose: 'Verbose',
      instanceChargeType: 'InstanceChargeType',
      spotStrategy: 'SpotStrategy',
      acceptLanguage: 'AcceptLanguage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      ownerAccount: 'string',
      verbose: 'boolean',
      instanceChargeType: 'string',
      spotStrategy: 'string',
      acceptLanguage: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeZonesResponseBody extends $tea.Model {
  requestId?: string;
  zones?: DescribeZonesResponseBodyZones[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      zones: 'Zones',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      zones: { 'type': 'array', 'itemType': DescribeZonesResponseBodyZones },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeZonesResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeZonesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeZonesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DetachClassicLinkVpcRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  instanceId?: string;
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      instanceId: 'InstanceId',
      vpcId: 'VpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      instanceId: 'string',
      vpcId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DetachClassicLinkVpcResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DetachClassicLinkVpcResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DetachClassicLinkVpcResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DetachClassicLinkVpcResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DetachDiskRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  instanceId?: string;
  diskId?: string;
  deleteWithInstance?: boolean;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      instanceId: 'InstanceId',
      diskId: 'DiskId',
      deleteWithInstance: 'DeleteWithInstance',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      instanceId: 'string',
      diskId: 'string',
      deleteWithInstance: 'boolean',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DetachDiskResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DetachDiskResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DetachDiskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DetachDiskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DetachInstanceRamRoleRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  ramRoleName?: string;
  instanceIds?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      ramRoleName: 'RamRoleName',
      instanceIds: 'InstanceIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      ramRoleName: 'string',
      instanceIds: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DetachInstanceRamRoleResponseBody extends $tea.Model {
  totalCount?: number;
  ramRoleName?: string;
  requestId?: string;
  failCount?: number;
  detachInstanceRamRoleResults?: DetachInstanceRamRoleResponseBodyDetachInstanceRamRoleResults[];
  static names(): { [key: string]: string } {
    return {
      totalCount: 'TotalCount',
      ramRoleName: 'RamRoleName',
      requestId: 'RequestId',
      failCount: 'FailCount',
      detachInstanceRamRoleResults: 'DetachInstanceRamRoleResults',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalCount: 'number',
      ramRoleName: 'string',
      requestId: 'string',
      failCount: 'number',
      detachInstanceRamRoleResults: { 'type': 'array', 'itemType': DetachInstanceRamRoleResponseBodyDetachInstanceRamRoleResults },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DetachInstanceRamRoleResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DetachInstanceRamRoleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DetachInstanceRamRoleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DetachKeyPairRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  keyPairName?: string;
  instanceIds?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      keyPairName: 'KeyPairName',
      instanceIds: 'InstanceIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      keyPairName: 'string',
      instanceIds: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DetachKeyPairResponseBody extends $tea.Model {
  keyPairName?: string;
  totalCount?: string;
  requestId?: string;
  results?: DetachKeyPairResponseBodyResults[];
  failCount?: string;
  static names(): { [key: string]: string } {
    return {
      keyPairName: 'KeyPairName',
      totalCount: 'TotalCount',
      requestId: 'RequestId',
      results: 'Results',
      failCount: 'FailCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      keyPairName: 'string',
      totalCount: 'string',
      requestId: 'string',
      results: { 'type': 'array', 'itemType': DetachKeyPairResponseBodyResults },
      failCount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DetachKeyPairResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DetachKeyPairResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DetachKeyPairResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DetachNetworkInterfaceRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  networkInterfaceId?: string;
  instanceId?: string;
  trunkNetworkInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      networkInterfaceId: 'NetworkInterfaceId',
      instanceId: 'InstanceId',
      trunkNetworkInstanceId: 'TrunkNetworkInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      networkInterfaceId: 'string',
      instanceId: 'string',
      trunkNetworkInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DetachNetworkInterfaceResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DetachNetworkInterfaceResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DetachNetworkInterfaceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DetachNetworkInterfaceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EipFillParamsRequest extends $tea.Model {
  data?: string;
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  clientToken?: string;
  ownerAccount?: string;
  userCidr?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'data',
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      clientToken: 'ClientToken',
      ownerAccount: 'OwnerAccount',
      userCidr: 'UserCidr',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'string',
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      clientToken: 'string',
      ownerAccount: 'string',
      userCidr: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EipFillParamsResponseBody extends $tea.Model {
  code?: string;
  data?: string;
  success?: boolean;
  requestId?: string;
  message?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'code',
      data: 'data',
      success: 'success',
      requestId: 'requestId',
      message: 'message',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'string',
      success: 'boolean',
      requestId: 'string',
      message: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EipFillParamsResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: EipFillParamsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: EipFillParamsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EipFillProductRequest extends $tea.Model {
  data?: string;
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  clientToken?: string;
  ownerAccount?: string;
  userCidr?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'data',
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      clientToken: 'ClientToken',
      ownerAccount: 'OwnerAccount',
      userCidr: 'UserCidr',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'string',
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      clientToken: 'string',
      ownerAccount: 'string',
      userCidr: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EipFillProductResponseBody extends $tea.Model {
  code?: string;
  data?: string;
  success?: boolean;
  requestId?: string;
  message?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'code',
      data: 'data',
      success: 'success',
      requestId: 'requestId',
      message: 'message',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'string',
      success: 'boolean',
      requestId: 'string',
      message: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EipFillProductResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: EipFillProductResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: EipFillProductResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EipNotifyPaidRequest extends $tea.Model {
  data?: string;
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  clientToken?: string;
  ownerAccount?: string;
  userCidr?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'data',
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      clientToken: 'ClientToken',
      ownerAccount: 'OwnerAccount',
      userCidr: 'UserCidr',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'string',
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      clientToken: 'string',
      ownerAccount: 'string',
      userCidr: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EipNotifyPaidResponseBody extends $tea.Model {
  code?: string;
  data?: string;
  success?: boolean;
  requestId?: string;
  message?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'code',
      data: 'data',
      success: 'success',
      requestId: 'requestId',
      message: 'message',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'string',
      success: 'boolean',
      requestId: 'string',
      message: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EipNotifyPaidResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: EipNotifyPaidResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: EipNotifyPaidResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnablePhysicalConnectionRequest extends $tea.Model {
  regionId?: string;
  physicalConnectionId?: string;
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  clientToken?: string;
  ownerAccount?: string;
  userCidr?: string;
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
      physicalConnectionId: 'PhysicalConnectionId',
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      clientToken: 'ClientToken',
      ownerAccount: 'OwnerAccount',
      userCidr: 'UserCidr',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
      physicalConnectionId: 'string',
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      clientToken: 'string',
      ownerAccount: 'string',
      userCidr: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnablePhysicalConnectionResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnablePhysicalConnectionResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: EnablePhysicalConnectionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: EnablePhysicalConnectionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportImageRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  imageId?: string;
  OSSBucket?: string;
  OSSPrefix?: string;
  imageFormat?: string;
  roleName?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      imageId: 'ImageId',
      OSSBucket: 'OSSBucket',
      OSSPrefix: 'OSSPrefix',
      imageFormat: 'ImageFormat',
      roleName: 'RoleName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      imageId: 'string',
      OSSBucket: 'string',
      OSSPrefix: 'string',
      imageFormat: 'string',
      roleName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportImageResponseBody extends $tea.Model {
  taskId?: string;
  requestId?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      taskId: 'TaskId',
      requestId: 'RequestId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      taskId: 'string',
      requestId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportImageResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ExportImageResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ExportImageResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportSnapshotRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  snapshotId?: string;
  regionId?: string;
  ossBucket?: string;
  roleName?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      snapshotId: 'SnapshotId',
      regionId: 'RegionId',
      ossBucket: 'OssBucket',
      roleName: 'RoleName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      snapshotId: 'string',
      regionId: 'string',
      ossBucket: 'string',
      roleName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportSnapshotResponseBody extends $tea.Model {
  taskId?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      taskId: 'TaskId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      taskId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportSnapshotResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ExportSnapshotResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ExportSnapshotResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstanceConsoleOutputRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  instanceId?: string;
  removeSymbols?: boolean;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      instanceId: 'InstanceId',
      removeSymbols: 'RemoveSymbols',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      instanceId: 'string',
      removeSymbols: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstanceConsoleOutputResponseBody extends $tea.Model {
  consoleOutput?: string;
  requestId?: string;
  lastUpdateTime?: string;
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      consoleOutput: 'ConsoleOutput',
      requestId: 'RequestId',
      lastUpdateTime: 'LastUpdateTime',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consoleOutput: 'string',
      requestId: 'string',
      lastUpdateTime: 'string',
      instanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstanceConsoleOutputResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: GetInstanceConsoleOutputResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: GetInstanceConsoleOutputResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstanceScreenshotRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  instanceId?: string;
  wakeUp?: boolean;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      instanceId: 'InstanceId',
      wakeUp: 'WakeUp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      instanceId: 'string',
      wakeUp: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstanceScreenshotResponseBody extends $tea.Model {
  requestId?: string;
  instanceId?: string;
  screenshot?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      instanceId: 'InstanceId',
      screenshot: 'Screenshot',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      instanceId: 'string',
      screenshot: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstanceScreenshotResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: GetInstanceScreenshotResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: GetInstanceScreenshotResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportImageRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  imageName?: string;
  description?: string;
  architecture?: string;
  OSType?: string;
  platform?: string;
  bootMode?: string;
  roleName?: string;
  licenseType?: string;
  resourceGroupId?: string;
  diskDeviceMapping?: ImportImageRequestDiskDeviceMapping[];
  tag?: ImportImageRequestTag[];
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      imageName: 'ImageName',
      description: 'Description',
      architecture: 'Architecture',
      OSType: 'OSType',
      platform: 'Platform',
      bootMode: 'BootMode',
      roleName: 'RoleName',
      licenseType: 'LicenseType',
      resourceGroupId: 'ResourceGroupId',
      diskDeviceMapping: 'DiskDeviceMapping',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      imageName: 'string',
      description: 'string',
      architecture: 'string',
      OSType: 'string',
      platform: 'string',
      bootMode: 'string',
      roleName: 'string',
      licenseType: 'string',
      resourceGroupId: 'string',
      diskDeviceMapping: { 'type': 'array', 'itemType': ImportImageRequestDiskDeviceMapping },
      tag: { 'type': 'array', 'itemType': ImportImageRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportImageResponseBody extends $tea.Model {
  taskId?: string;
  requestId?: string;
  imageId?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      taskId: 'TaskId',
      requestId: 'RequestId',
      imageId: 'ImageId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      taskId: 'string',
      requestId: 'string',
      imageId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportImageResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ImportImageResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ImportImageResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportKeyPairRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  keyPairName?: string;
  publicKeyBody?: string;
  resourceGroupId?: string;
  tag?: ImportKeyPairRequestTag[];
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      keyPairName: 'KeyPairName',
      publicKeyBody: 'PublicKeyBody',
      resourceGroupId: 'ResourceGroupId',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      keyPairName: 'string',
      publicKeyBody: 'string',
      resourceGroupId: 'string',
      tag: { 'type': 'array', 'itemType': ImportKeyPairRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportKeyPairResponseBody extends $tea.Model {
  keyPairFingerPrint?: string;
  keyPairName?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      keyPairFingerPrint: 'KeyPairFingerPrint',
      keyPairName: 'KeyPairName',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      keyPairFingerPrint: 'string',
      keyPairName: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportKeyPairResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ImportKeyPairResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ImportKeyPairResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportSnapshotRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  snapshotName?: string;
  regionId?: string;
  ossBucket?: string;
  ossObject?: string;
  roleName?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      snapshotName: 'SnapshotName',
      regionId: 'RegionId',
      ossBucket: 'OssBucket',
      ossObject: 'OssObject',
      roleName: 'RoleName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      snapshotName: 'string',
      regionId: 'string',
      ossBucket: 'string',
      ossObject: 'string',
      roleName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportSnapshotResponseBody extends $tea.Model {
  snapshotId?: string;
  taskId?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      snapshotId: 'SnapshotId',
      taskId: 'TaskId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      snapshotId: 'string',
      taskId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportSnapshotResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ImportSnapshotResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ImportSnapshotResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InstallCloudAssistantRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  instanceId?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      instanceId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InstallCloudAssistantResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InstallCloudAssistantResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: InstallCloudAssistantResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: InstallCloudAssistantResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InvokeCommandRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  commandId?: string;
  timed?: boolean;
  frequency?: string;
  parameters?: { [key: string]: any };
  username?: string;
  instanceId?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      commandId: 'CommandId',
      timed: 'Timed',
      frequency: 'Frequency',
      parameters: 'Parameters',
      username: 'Username',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      commandId: 'string',
      timed: 'boolean',
      frequency: 'string',
      parameters: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      username: 'string',
      instanceId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InvokeCommandShrinkRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  commandId?: string;
  timed?: boolean;
  frequency?: string;
  parametersShrink?: string;
  username?: string;
  instanceId?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      commandId: 'CommandId',
      timed: 'Timed',
      frequency: 'Frequency',
      parametersShrink: 'Parameters',
      username: 'Username',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      commandId: 'string',
      timed: 'boolean',
      frequency: 'string',
      parametersShrink: 'string',
      username: 'string',
      instanceId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InvokeCommandResponseBody extends $tea.Model {
  requestId?: string;
  invokeId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      invokeId: 'InvokeId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      invokeId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InvokeCommandResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: InvokeCommandResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: InvokeCommandResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class JoinResourceGroupRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  resourceType?: string;
  resourceId?: string;
  regionId?: string;
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      resourceType: 'ResourceType',
      resourceId: 'ResourceId',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      resourceType: 'string',
      resourceId: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class JoinResourceGroupResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class JoinResourceGroupResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: JoinResourceGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: JoinResourceGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class JoinSecurityGroupRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  securityGroupId?: string;
  instanceId?: string;
  networkInterfaceId?: string;
  regionId?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      securityGroupId: 'SecurityGroupId',
      instanceId: 'InstanceId',
      networkInterfaceId: 'NetworkInterfaceId',
      regionId: 'RegionId',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      securityGroupId: 'string',
      instanceId: 'string',
      networkInterfaceId: 'string',
      regionId: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class JoinSecurityGroupResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class JoinSecurityGroupResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: JoinSecurityGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: JoinSecurityGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class LeaveSecurityGroupRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  securityGroupId?: string;
  instanceId?: string;
  networkInterfaceId?: string;
  regionId?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      securityGroupId: 'SecurityGroupId',
      instanceId: 'InstanceId',
      networkInterfaceId: 'NetworkInterfaceId',
      regionId: 'RegionId',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      securityGroupId: 'string',
      instanceId: 'string',
      networkInterfaceId: 'string',
      regionId: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class LeaveSecurityGroupResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class LeaveSecurityGroupResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: LeaveSecurityGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: LeaveSecurityGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTagResourcesRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  nextToken?: string;
  resourceType?: string;
  resourceId?: string[];
  tag?: ListTagResourcesRequestTag[];
  tagFilter?: ListTagResourcesRequestTagFilter[];
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      nextToken: 'NextToken',
      resourceType: 'ResourceType',
      resourceId: 'ResourceId',
      tag: 'Tag',
      tagFilter: 'TagFilter',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      nextToken: 'string',
      resourceType: 'string',
      resourceId: { 'type': 'array', 'itemType': 'string' },
      tag: { 'type': 'array', 'itemType': ListTagResourcesRequestTag },
      tagFilter: { 'type': 'array', 'itemType': ListTagResourcesRequestTagFilter },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTagResourcesResponseBody extends $tea.Model {
  nextToken?: string;
  requestId?: string;
  tagResources?: ListTagResourcesResponseBodyTagResources[];
  static names(): { [key: string]: string } {
    return {
      nextToken: 'NextToken',
      requestId: 'RequestId',
      tagResources: 'TagResources',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nextToken: 'string',
      requestId: 'string',
      tagResources: { 'type': 'array', 'itemType': ListTagResourcesResponseBodyTagResources },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTagResourcesResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListTagResourcesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListTagResourcesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyAutoProvisioningGroupRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  autoProvisioningGroupId?: string;
  excessCapacityTerminationPolicy?: string;
  defaultTargetCapacityType?: string;
  terminateInstancesWithExpiration?: boolean;
  maxSpotPrice?: number;
  totalTargetCapacity?: string;
  payAsYouGoTargetCapacity?: string;
  spotTargetCapacity?: string;
  autoProvisioningGroupName?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      autoProvisioningGroupId: 'AutoProvisioningGroupId',
      excessCapacityTerminationPolicy: 'ExcessCapacityTerminationPolicy',
      defaultTargetCapacityType: 'DefaultTargetCapacityType',
      terminateInstancesWithExpiration: 'TerminateInstancesWithExpiration',
      maxSpotPrice: 'MaxSpotPrice',
      totalTargetCapacity: 'TotalTargetCapacity',
      payAsYouGoTargetCapacity: 'PayAsYouGoTargetCapacity',
      spotTargetCapacity: 'SpotTargetCapacity',
      autoProvisioningGroupName: 'AutoProvisioningGroupName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      autoProvisioningGroupId: 'string',
      excessCapacityTerminationPolicy: 'string',
      defaultTargetCapacityType: 'string',
      terminateInstancesWithExpiration: 'boolean',
      maxSpotPrice: 'number',
      totalTargetCapacity: 'string',
      payAsYouGoTargetCapacity: 'string',
      spotTargetCapacity: 'string',
      autoProvisioningGroupName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyAutoProvisioningGroupResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyAutoProvisioningGroupResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ModifyAutoProvisioningGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ModifyAutoProvisioningGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyAutoSnapshotPolicyRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  systemDiskPolicyEnabled?: boolean;
  systemDiskPolicyTimePeriod?: number;
  systemDiskPolicyRetentionDays?: number;
  systemDiskPolicyRetentionLastWeek?: boolean;
  dataDiskPolicyEnabled?: boolean;
  dataDiskPolicyTimePeriod?: number;
  dataDiskPolicyRetentionDays?: number;
  dataDiskPolicyRetentionLastWeek?: boolean;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      systemDiskPolicyEnabled: 'SystemDiskPolicyEnabled',
      systemDiskPolicyTimePeriod: 'SystemDiskPolicyTimePeriod',
      systemDiskPolicyRetentionDays: 'SystemDiskPolicyRetentionDays',
      systemDiskPolicyRetentionLastWeek: 'SystemDiskPolicyRetentionLastWeek',
      dataDiskPolicyEnabled: 'DataDiskPolicyEnabled',
      dataDiskPolicyTimePeriod: 'DataDiskPolicyTimePeriod',
      dataDiskPolicyRetentionDays: 'DataDiskPolicyRetentionDays',
      dataDiskPolicyRetentionLastWeek: 'DataDiskPolicyRetentionLastWeek',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      systemDiskPolicyEnabled: 'boolean',
      systemDiskPolicyTimePeriod: 'number',
      systemDiskPolicyRetentionDays: 'number',
      systemDiskPolicyRetentionLastWeek: 'boolean',
      dataDiskPolicyEnabled: 'boolean',
      dataDiskPolicyTimePeriod: 'number',
      dataDiskPolicyRetentionDays: 'number',
      dataDiskPolicyRetentionLastWeek: 'boolean',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyAutoSnapshotPolicyResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyAutoSnapshotPolicyResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ModifyAutoSnapshotPolicyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ModifyAutoSnapshotPolicyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyAutoSnapshotPolicyExRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  autoSnapshotPolicyId?: string;
  autoSnapshotPolicyName?: string;
  timePoints?: string;
  repeatWeekdays?: string;
  retentionDays?: number;
  enableCrossRegionCopy?: boolean;
  targetCopyRegions?: string;
  copiedSnapshotsRetentionDays?: number;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'regionId',
      autoSnapshotPolicyId: 'autoSnapshotPolicyId',
      autoSnapshotPolicyName: 'autoSnapshotPolicyName',
      timePoints: 'timePoints',
      repeatWeekdays: 'repeatWeekdays',
      retentionDays: 'retentionDays',
      enableCrossRegionCopy: 'EnableCrossRegionCopy',
      targetCopyRegions: 'TargetCopyRegions',
      copiedSnapshotsRetentionDays: 'CopiedSnapshotsRetentionDays',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      autoSnapshotPolicyId: 'string',
      autoSnapshotPolicyName: 'string',
      timePoints: 'string',
      repeatWeekdays: 'string',
      retentionDays: 'number',
      enableCrossRegionCopy: 'boolean',
      targetCopyRegions: 'string',
      copiedSnapshotsRetentionDays: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyAutoSnapshotPolicyExResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyAutoSnapshotPolicyExResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ModifyAutoSnapshotPolicyExResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ModifyAutoSnapshotPolicyExResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyBandwidthPackageSpecRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  bandwidthPackageId?: string;
  bandwidth?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      bandwidthPackageId: 'BandwidthPackageId',
      bandwidth: 'Bandwidth',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      bandwidthPackageId: 'string',
      bandwidth: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyBandwidthPackageSpecResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyBandwidthPackageSpecResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ModifyBandwidthPackageSpecResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ModifyBandwidthPackageSpecResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyCommandRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  commandId?: string;
  name?: string;
  description?: string;
  commandContent?: string;
  workingDir?: string;
  timeout?: number;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      commandId: 'CommandId',
      name: 'Name',
      description: 'Description',
      commandContent: 'CommandContent',
      workingDir: 'WorkingDir',
      timeout: 'Timeout',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      commandId: 'string',
      name: 'string',
      description: 'string',
      commandContent: 'string',
      workingDir: 'string',
      timeout: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyCommandResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyCommandResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ModifyCommandResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ModifyCommandResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDedicatedHostAttributeRequest extends $tea.Model {
  networkAttributes?: ModifyDedicatedHostAttributeRequestNetworkAttributes;
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  dedicatedHostId?: string;
  dedicatedHostName?: string;
  description?: string;
  actionOnMaintenance?: string;
  autoPlacement?: string;
  dedicatedHostClusterId?: string;
  cpuOverCommitRatio?: number;
  static names(): { [key: string]: string } {
    return {
      networkAttributes: 'NetworkAttributes',
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      dedicatedHostId: 'DedicatedHostId',
      dedicatedHostName: 'DedicatedHostName',
      description: 'Description',
      actionOnMaintenance: 'ActionOnMaintenance',
      autoPlacement: 'AutoPlacement',
      dedicatedHostClusterId: 'DedicatedHostClusterId',
      cpuOverCommitRatio: 'CpuOverCommitRatio',
    };
  }

  static types(): { [key: string]: any } {
    return {
      networkAttributes: ModifyDedicatedHostAttributeRequestNetworkAttributes,
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      dedicatedHostId: 'string',
      dedicatedHostName: 'string',
      description: 'string',
      actionOnMaintenance: 'string',
      autoPlacement: 'string',
      dedicatedHostClusterId: 'string',
      cpuOverCommitRatio: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDedicatedHostAttributeResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDedicatedHostAttributeResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ModifyDedicatedHostAttributeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ModifyDedicatedHostAttributeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDedicatedHostAutoReleaseTimeRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  dedicatedHostId?: string;
  autoReleaseTime?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      dedicatedHostId: 'DedicatedHostId',
      autoReleaseTime: 'AutoReleaseTime',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      dedicatedHostId: 'string',
      autoReleaseTime: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDedicatedHostAutoReleaseTimeResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDedicatedHostAutoReleaseTimeResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ModifyDedicatedHostAutoReleaseTimeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ModifyDedicatedHostAutoReleaseTimeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDedicatedHostAutoRenewAttributeRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  dedicatedHostIds?: string;
  regionId?: string;
  duration?: number;
  periodUnit?: string;
  autoRenew?: boolean;
  renewalStatus?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      dedicatedHostIds: 'DedicatedHostIds',
      regionId: 'RegionId',
      duration: 'Duration',
      periodUnit: 'PeriodUnit',
      autoRenew: 'AutoRenew',
      renewalStatus: 'RenewalStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      dedicatedHostIds: 'string',
      regionId: 'string',
      duration: 'number',
      periodUnit: 'string',
      autoRenew: 'boolean',
      renewalStatus: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDedicatedHostAutoRenewAttributeResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDedicatedHostAutoRenewAttributeResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ModifyDedicatedHostAutoRenewAttributeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ModifyDedicatedHostAutoRenewAttributeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDedicatedHostClusterAttributeRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  dedicatedHostClusterId?: string;
  dedicatedHostClusterName?: string;
  description?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      dedicatedHostClusterId: 'DedicatedHostClusterId',
      dedicatedHostClusterName: 'DedicatedHostClusterName',
      description: 'Description',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      dedicatedHostClusterId: 'string',
      dedicatedHostClusterName: 'string',
      description: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDedicatedHostClusterAttributeResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDedicatedHostClusterAttributeResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ModifyDedicatedHostClusterAttributeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ModifyDedicatedHostClusterAttributeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDedicatedHostsChargeTypeRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  dedicatedHostIds?: string;
  regionId?: string;
  period?: number;
  periodUnit?: string;
  dryRun?: boolean;
  autoPay?: boolean;
  dedicatedHostChargeType?: string;
  clientToken?: string;
  ownerAccount?: string;
  detailFee?: boolean;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      dedicatedHostIds: 'DedicatedHostIds',
      regionId: 'RegionId',
      period: 'Period',
      periodUnit: 'PeriodUnit',
      dryRun: 'DryRun',
      autoPay: 'AutoPay',
      dedicatedHostChargeType: 'DedicatedHostChargeType',
      clientToken: 'ClientToken',
      ownerAccount: 'OwnerAccount',
      detailFee: 'DetailFee',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      dedicatedHostIds: 'string',
      regionId: 'string',
      period: 'number',
      periodUnit: 'string',
      dryRun: 'boolean',
      autoPay: 'boolean',
      dedicatedHostChargeType: 'string',
      clientToken: 'string',
      ownerAccount: 'string',
      detailFee: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDedicatedHostsChargeTypeResponseBody extends $tea.Model {
  feeOfInstances?: ModifyDedicatedHostsChargeTypeResponseBodyFeeOfInstances[];
  requestId?: string;
  orderId?: string;
  static names(): { [key: string]: string } {
    return {
      feeOfInstances: 'FeeOfInstances',
      requestId: 'RequestId',
      orderId: 'OrderId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      feeOfInstances: { 'type': 'array', 'itemType': ModifyDedicatedHostsChargeTypeResponseBodyFeeOfInstances },
      requestId: 'string',
      orderId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDedicatedHostsChargeTypeResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ModifyDedicatedHostsChargeTypeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ModifyDedicatedHostsChargeTypeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDemandRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  clientToken?: string;
  regionId?: string;
  zoneId?: string;
  demandId?: string;
  demandName?: string;
  demandDescription?: string;
  instanceType?: string;
  amount?: number;
  instanceChargeType?: string;
  period?: number;
  periodUnit?: string;
  startTime?: string;
  endTime?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      clientToken: 'ClientToken',
      regionId: 'RegionId',
      zoneId: 'ZoneId',
      demandId: 'DemandId',
      demandName: 'DemandName',
      demandDescription: 'DemandDescription',
      instanceType: 'InstanceType',
      amount: 'Amount',
      instanceChargeType: 'InstanceChargeType',
      period: 'Period',
      periodUnit: 'PeriodUnit',
      startTime: 'StartTime',
      endTime: 'EndTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      clientToken: 'string',
      regionId: 'string',
      zoneId: 'string',
      demandId: 'string',
      demandName: 'string',
      demandDescription: 'string',
      instanceType: 'string',
      amount: 'number',
      instanceChargeType: 'string',
      period: 'number',
      periodUnit: 'string',
      startTime: 'string',
      endTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDemandResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDemandResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ModifyDemandResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ModifyDemandResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDeploymentSetAttributeRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  deploymentSetId?: string;
  description?: string;
  deploymentSetName?: string;
  regionId?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      deploymentSetId: 'DeploymentSetId',
      description: 'Description',
      deploymentSetName: 'DeploymentSetName',
      regionId: 'RegionId',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      deploymentSetId: 'string',
      description: 'string',
      deploymentSetName: 'string',
      regionId: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDeploymentSetAttributeResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDeploymentSetAttributeResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ModifyDeploymentSetAttributeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ModifyDeploymentSetAttributeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDiskAttributeRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  diskId?: string;
  diskName?: string;
  description?: string;
  deleteWithInstance?: boolean;
  deleteAutoSnapshot?: boolean;
  enableAutoSnapshot?: boolean;
  ownerAccount?: string;
  diskIds?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      diskId: 'DiskId',
      diskName: 'DiskName',
      description: 'Description',
      deleteWithInstance: 'DeleteWithInstance',
      deleteAutoSnapshot: 'DeleteAutoSnapshot',
      enableAutoSnapshot: 'EnableAutoSnapshot',
      ownerAccount: 'OwnerAccount',
      diskIds: 'DiskIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      diskId: 'string',
      diskName: 'string',
      description: 'string',
      deleteWithInstance: 'boolean',
      deleteAutoSnapshot: 'boolean',
      enableAutoSnapshot: 'boolean',
      ownerAccount: 'string',
      diskIds: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDiskAttributeResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDiskAttributeResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ModifyDiskAttributeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ModifyDiskAttributeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDiskChargeTypeRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  instanceId?: string;
  regionId?: string;
  diskIds?: string;
  autoPay?: boolean;
  clientToken?: string;
  ownerAccount?: string;
  diskChargeType?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      instanceId: 'InstanceId',
      regionId: 'RegionId',
      diskIds: 'DiskIds',
      autoPay: 'AutoPay',
      clientToken: 'ClientToken',
      ownerAccount: 'OwnerAccount',
      diskChargeType: 'DiskChargeType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      instanceId: 'string',
      regionId: 'string',
      diskIds: 'string',
      autoPay: 'boolean',
      clientToken: 'string',
      ownerAccount: 'string',
      diskChargeType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDiskChargeTypeResponseBody extends $tea.Model {
  requestId?: string;
  orderId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      orderId: 'OrderId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      orderId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDiskChargeTypeResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ModifyDiskChargeTypeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ModifyDiskChargeTypeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDiskSpecRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  diskId?: string;
  performanceLevel?: string;
  diskCategory?: string;
  dryRun?: boolean;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      diskId: 'DiskId',
      performanceLevel: 'PerformanceLevel',
      diskCategory: 'DiskCategory',
      dryRun: 'DryRun',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      diskId: 'string',
      performanceLevel: 'string',
      diskCategory: 'string',
      dryRun: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDiskSpecResponseBody extends $tea.Model {
  taskId?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      taskId: 'TaskId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      taskId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDiskSpecResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ModifyDiskSpecResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ModifyDiskSpecResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyEipAddressAttributeRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  allocationId?: string;
  bandwidth?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      allocationId: 'AllocationId',
      bandwidth: 'Bandwidth',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      allocationId: 'string',
      bandwidth: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyEipAddressAttributeResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyEipAddressAttributeResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ModifyEipAddressAttributeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ModifyEipAddressAttributeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyForwardEntryRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  forwardTableId?: string;
  forwardEntryId?: string;
  externalIp?: string;
  externalPort?: string;
  internalIp?: string;
  internalPort?: string;
  ipProtocol?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      forwardTableId: 'ForwardTableId',
      forwardEntryId: 'ForwardEntryId',
      externalIp: 'ExternalIp',
      externalPort: 'ExternalPort',
      internalIp: 'InternalIp',
      internalPort: 'InternalPort',
      ipProtocol: 'IpProtocol',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      forwardTableId: 'string',
      forwardEntryId: 'string',
      externalIp: 'string',
      externalPort: 'string',
      internalIp: 'string',
      internalPort: 'string',
      ipProtocol: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyForwardEntryResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyForwardEntryResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ModifyForwardEntryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ModifyForwardEntryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyHaVipAttributeRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  clientToken?: string;
  regionId?: string;
  haVipId?: string;
  description?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      clientToken: 'ClientToken',
      regionId: 'RegionId',
      haVipId: 'HaVipId',
      description: 'Description',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      clientToken: 'string',
      regionId: 'string',
      haVipId: 'string',
      description: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyHaVipAttributeResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyHaVipAttributeResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ModifyHaVipAttributeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ModifyHaVipAttributeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyHpcClusterAttributeRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  clientToken?: string;
  ownerAccount?: string;
  hpcClusterId?: string;
  description?: string;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      clientToken: 'ClientToken',
      ownerAccount: 'OwnerAccount',
      hpcClusterId: 'HpcClusterId',
      description: 'Description',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      clientToken: 'string',
      ownerAccount: 'string',
      hpcClusterId: 'string',
      description: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyHpcClusterAttributeResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyHpcClusterAttributeResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ModifyHpcClusterAttributeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ModifyHpcClusterAttributeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyImageAttributeRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  imageId?: string;
  imageName?: string;
  status?: string;
  imageFamily?: string;
  bootMode?: string;
  licenseType?: string;
  description?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      imageId: 'ImageId',
      imageName: 'ImageName',
      status: 'Status',
      imageFamily: 'ImageFamily',
      bootMode: 'BootMode',
      licenseType: 'LicenseType',
      description: 'Description',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      imageId: 'string',
      imageName: 'string',
      status: 'string',
      imageFamily: 'string',
      bootMode: 'string',
      licenseType: 'string',
      description: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyImageAttributeResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyImageAttributeResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ModifyImageAttributeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ModifyImageAttributeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyImageShareGroupPermissionRequest extends $tea.Model {
  addGroup?: string[];
  removeGroup?: string[];
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  imageId?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      addGroup: 'AddGroup',
      removeGroup: 'RemoveGroup',
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      imageId: 'ImageId',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addGroup: { 'type': 'array', 'itemType': 'string' },
      removeGroup: { 'type': 'array', 'itemType': 'string' },
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      imageId: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyImageShareGroupPermissionResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyImageShareGroupPermissionResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ModifyImageShareGroupPermissionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ModifyImageShareGroupPermissionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyImageSharePermissionRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  imageId?: string;
  ownerAccount?: string;
  launchPermission?: string;
  addAccount?: string[];
  removeAccount?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      imageId: 'ImageId',
      ownerAccount: 'OwnerAccount',
      launchPermission: 'LaunchPermission',
      addAccount: 'AddAccount',
      removeAccount: 'RemoveAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      imageId: 'string',
      ownerAccount: 'string',
      launchPermission: 'string',
      addAccount: { 'type': 'array', 'itemType': 'string' },
      removeAccount: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyImageSharePermissionResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyImageSharePermissionResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ModifyImageSharePermissionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ModifyImageSharePermissionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceAttachmentAttributesRequest extends $tea.Model {
  privatePoolOptions?: ModifyInstanceAttachmentAttributesRequestPrivatePoolOptions;
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      privatePoolOptions: 'PrivatePoolOptions',
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      privatePoolOptions: ModifyInstanceAttachmentAttributesRequestPrivatePoolOptions,
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      instanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceAttachmentAttributesResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceAttachmentAttributesResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ModifyInstanceAttachmentAttributesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ModifyInstanceAttachmentAttributesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceAttributeRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  instanceId?: string;
  password?: string;
  hostName?: string;
  instanceName?: string;
  description?: string;
  ownerAccount?: string;
  userData?: string;
  recyclable?: boolean;
  creditSpecification?: string;
  deletionProtection?: boolean;
  networkInterfaceQueueNumber?: number;
  securityGroupIds?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      instanceId: 'InstanceId',
      password: 'Password',
      hostName: 'HostName',
      instanceName: 'InstanceName',
      description: 'Description',
      ownerAccount: 'OwnerAccount',
      userData: 'UserData',
      recyclable: 'Recyclable',
      creditSpecification: 'CreditSpecification',
      deletionProtection: 'DeletionProtection',
      networkInterfaceQueueNumber: 'NetworkInterfaceQueueNumber',
      securityGroupIds: 'SecurityGroupIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      instanceId: 'string',
      password: 'string',
      hostName: 'string',
      instanceName: 'string',
      description: 'string',
      ownerAccount: 'string',
      userData: 'string',
      recyclable: 'boolean',
      creditSpecification: 'string',
      deletionProtection: 'boolean',
      networkInterfaceQueueNumber: 'number',
      securityGroupIds: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceAttributeResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceAttributeResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ModifyInstanceAttributeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ModifyInstanceAttributeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceAutoReleaseTimeRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  instanceId?: string;
  autoReleaseTime?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      instanceId: 'InstanceId',
      autoReleaseTime: 'AutoReleaseTime',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      instanceId: 'string',
      autoReleaseTime: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceAutoReleaseTimeResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceAutoReleaseTimeResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ModifyInstanceAutoReleaseTimeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ModifyInstanceAutoReleaseTimeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceAutoRenewAttributeRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  instanceId?: string;
  regionId?: string;
  duration?: number;
  autoRenew?: boolean;
  renewalStatus?: string;
  periodUnit?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      instanceId: 'InstanceId',
      regionId: 'RegionId',
      duration: 'Duration',
      autoRenew: 'AutoRenew',
      renewalStatus: 'RenewalStatus',
      periodUnit: 'PeriodUnit',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      instanceId: 'string',
      regionId: 'string',
      duration: 'number',
      autoRenew: 'boolean',
      renewalStatus: 'string',
      periodUnit: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceAutoRenewAttributeResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceAutoRenewAttributeResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ModifyInstanceAutoRenewAttributeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ModifyInstanceAutoRenewAttributeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceChargeTypeRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  instanceIds?: string;
  regionId?: string;
  period?: number;
  periodUnit?: string;
  includeDataDisks?: boolean;
  dryRun?: boolean;
  autoPay?: boolean;
  instanceChargeType?: string;
  clientToken?: string;
  ownerAccount?: string;
  isDetailFee?: boolean;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      instanceIds: 'InstanceIds',
      regionId: 'RegionId',
      period: 'Period',
      periodUnit: 'PeriodUnit',
      includeDataDisks: 'IncludeDataDisks',
      dryRun: 'DryRun',
      autoPay: 'AutoPay',
      instanceChargeType: 'InstanceChargeType',
      clientToken: 'ClientToken',
      ownerAccount: 'OwnerAccount',
      isDetailFee: 'IsDetailFee',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      instanceIds: 'string',
      regionId: 'string',
      period: 'number',
      periodUnit: 'string',
      includeDataDisks: 'boolean',
      dryRun: 'boolean',
      autoPay: 'boolean',
      instanceChargeType: 'string',
      clientToken: 'string',
      ownerAccount: 'string',
      isDetailFee: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceChargeTypeResponseBody extends $tea.Model {
  feeOfInstances?: ModifyInstanceChargeTypeResponseBodyFeeOfInstances[];
  requestId?: string;
  orderId?: string;
  static names(): { [key: string]: string } {
    return {
      feeOfInstances: 'FeeOfInstances',
      requestId: 'RequestId',
      orderId: 'OrderId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      feeOfInstances: { 'type': 'array', 'itemType': ModifyInstanceChargeTypeResponseBodyFeeOfInstances },
      requestId: 'string',
      orderId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceChargeTypeResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ModifyInstanceChargeTypeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ModifyInstanceChargeTypeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceDeploymentRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  instanceId?: string;
  dedicatedHostId?: string;
  deploymentSetId?: string;
  deploymentSetGroupNo?: number;
  force?: boolean;
  affinity?: string;
  tenancy?: string;
  migrationType?: string;
  instanceType?: string;
  dedicatedHostClusterId?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      instanceId: 'InstanceId',
      dedicatedHostId: 'DedicatedHostId',
      deploymentSetId: 'DeploymentSetId',
      deploymentSetGroupNo: 'DeploymentSetGroupNo',
      force: 'Force',
      affinity: 'Affinity',
      tenancy: 'Tenancy',
      migrationType: 'MigrationType',
      instanceType: 'InstanceType',
      dedicatedHostClusterId: 'DedicatedHostClusterId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      instanceId: 'string',
      dedicatedHostId: 'string',
      deploymentSetId: 'string',
      deploymentSetGroupNo: 'number',
      force: 'boolean',
      affinity: 'string',
      tenancy: 'string',
      migrationType: 'string',
      instanceType: 'string',
      dedicatedHostClusterId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceDeploymentResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceDeploymentResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ModifyInstanceDeploymentResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ModifyInstanceDeploymentResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceMaintenanceAttributesRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  actionOnMaintenance?: string;
  instanceId?: string[];
  maintenanceWindow?: ModifyInstanceMaintenanceAttributesRequestMaintenanceWindow[];
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      actionOnMaintenance: 'ActionOnMaintenance',
      instanceId: 'InstanceId',
      maintenanceWindow: 'MaintenanceWindow',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      actionOnMaintenance: 'string',
      instanceId: { 'type': 'array', 'itemType': 'string' },
      maintenanceWindow: { 'type': 'array', 'itemType': ModifyInstanceMaintenanceAttributesRequestMaintenanceWindow },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceMaintenanceAttributesResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceMaintenanceAttributesResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ModifyInstanceMaintenanceAttributesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ModifyInstanceMaintenanceAttributesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceMetadataOptionsRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  instanceId?: string;
  httpEndpoint?: string;
  httpTokens?: string;
  httpPutResponseHopLimit?: number;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      instanceId: 'InstanceId',
      httpEndpoint: 'HttpEndpoint',
      httpTokens: 'HttpTokens',
      httpPutResponseHopLimit: 'HttpPutResponseHopLimit',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      instanceId: 'string',
      httpEndpoint: 'string',
      httpTokens: 'string',
      httpPutResponseHopLimit: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceMetadataOptionsResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceMetadataOptionsResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ModifyInstanceMetadataOptionsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ModifyInstanceMetadataOptionsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceNetworkSpecRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  instanceId?: string;
  internetMaxBandwidthOut?: number;
  internetMaxBandwidthIn?: number;
  ISP?: string;
  networkChargeType?: string;
  allocatePublicIp?: boolean;
  startTime?: string;
  endTime?: string;
  autoPay?: boolean;
  clientToken?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      instanceId: 'InstanceId',
      internetMaxBandwidthOut: 'InternetMaxBandwidthOut',
      internetMaxBandwidthIn: 'InternetMaxBandwidthIn',
      ISP: 'ISP',
      networkChargeType: 'NetworkChargeType',
      allocatePublicIp: 'AllocatePublicIp',
      startTime: 'StartTime',
      endTime: 'EndTime',
      autoPay: 'AutoPay',
      clientToken: 'ClientToken',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      instanceId: 'string',
      internetMaxBandwidthOut: 'number',
      internetMaxBandwidthIn: 'number',
      ISP: 'string',
      networkChargeType: 'string',
      allocatePublicIp: 'boolean',
      startTime: 'string',
      endTime: 'string',
      autoPay: 'boolean',
      clientToken: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceNetworkSpecResponseBody extends $tea.Model {
  requestId?: string;
  orderId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      orderId: 'OrderId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      orderId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceNetworkSpecResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ModifyInstanceNetworkSpecResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ModifyInstanceNetworkSpecResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceSpecRequest extends $tea.Model {
  temporary?: ModifyInstanceSpecRequestTemporary;
  systemDisk?: ModifyInstanceSpecRequestSystemDisk;
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  instanceId?: string;
  instanceType?: string;
  internetMaxBandwidthOut?: number;
  internetMaxBandwidthIn?: number;
  ownerAccount?: string;
  async?: boolean;
  allowMigrateAcrossZone?: boolean;
  clientToken?: string;
  static names(): { [key: string]: string } {
    return {
      temporary: 'Temporary',
      systemDisk: 'SystemDisk',
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      instanceId: 'InstanceId',
      instanceType: 'InstanceType',
      internetMaxBandwidthOut: 'InternetMaxBandwidthOut',
      internetMaxBandwidthIn: 'InternetMaxBandwidthIn',
      ownerAccount: 'OwnerAccount',
      async: 'Async',
      allowMigrateAcrossZone: 'AllowMigrateAcrossZone',
      clientToken: 'ClientToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      temporary: ModifyInstanceSpecRequestTemporary,
      systemDisk: ModifyInstanceSpecRequestSystemDisk,
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      instanceId: 'string',
      instanceType: 'string',
      internetMaxBandwidthOut: 'number',
      internetMaxBandwidthIn: 'number',
      ownerAccount: 'string',
      async: 'boolean',
      allowMigrateAcrossZone: 'boolean',
      clientToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceSpecResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceSpecResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ModifyInstanceSpecResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ModifyInstanceSpecResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceVncPasswdRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  instanceId?: string;
  regionId?: string;
  vncPassword?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      instanceId: 'InstanceId',
      regionId: 'RegionId',
      vncPassword: 'VncPassword',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      instanceId: 'string',
      regionId: 'string',
      vncPassword: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceVncPasswdResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceVncPasswdResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ModifyInstanceVncPasswdResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ModifyInstanceVncPasswdResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceVpcAttributeRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  instanceId?: string;
  vSwitchId?: string;
  privateIpAddress?: string;
  vpcId?: string;
  ownerAccount?: string;
  securityGroupId?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      instanceId: 'InstanceId',
      vSwitchId: 'VSwitchId',
      privateIpAddress: 'PrivateIpAddress',
      vpcId: 'VpcId',
      ownerAccount: 'OwnerAccount',
      securityGroupId: 'SecurityGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      instanceId: 'string',
      vSwitchId: 'string',
      privateIpAddress: 'string',
      vpcId: 'string',
      ownerAccount: 'string',
      securityGroupId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceVpcAttributeResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceVpcAttributeResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ModifyInstanceVpcAttributeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ModifyInstanceVpcAttributeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyLaunchTemplateDefaultVersionRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  launchTemplateId?: string;
  launchTemplateName?: string;
  defaultVersionNumber?: number;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      launchTemplateId: 'LaunchTemplateId',
      launchTemplateName: 'LaunchTemplateName',
      defaultVersionNumber: 'DefaultVersionNumber',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      launchTemplateId: 'string',
      launchTemplateName: 'string',
      defaultVersionNumber: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyLaunchTemplateDefaultVersionResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyLaunchTemplateDefaultVersionResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ModifyLaunchTemplateDefaultVersionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ModifyLaunchTemplateDefaultVersionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyNetworkInterfaceAttributeRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  networkInterfaceName?: string;
  networkInterfaceId?: string;
  queueNumber?: number;
  description?: string;
  securityGroupId?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      networkInterfaceName: 'NetworkInterfaceName',
      networkInterfaceId: 'NetworkInterfaceId',
      queueNumber: 'QueueNumber',
      description: 'Description',
      securityGroupId: 'SecurityGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      networkInterfaceName: 'string',
      networkInterfaceId: 'string',
      queueNumber: 'number',
      description: 'string',
      securityGroupId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyNetworkInterfaceAttributeResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyNetworkInterfaceAttributeResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ModifyNetworkInterfaceAttributeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ModifyNetworkInterfaceAttributeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyPrepayInstanceSpecRequest extends $tea.Model {
  systemDisk?: ModifyPrepayInstanceSpecRequestSystemDisk;
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  instanceId?: string;
  regionId?: string;
  instanceType?: string;
  operatorType?: string;
  clientToken?: string;
  autoPay?: boolean;
  migrateAcrossZone?: boolean;
  ownerAccount?: string;
  rebootTime?: string;
  endTime?: string;
  rebootWhenFinished?: boolean;
  static names(): { [key: string]: string } {
    return {
      systemDisk: 'SystemDisk',
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      instanceId: 'InstanceId',
      regionId: 'RegionId',
      instanceType: 'InstanceType',
      operatorType: 'OperatorType',
      clientToken: 'ClientToken',
      autoPay: 'AutoPay',
      migrateAcrossZone: 'MigrateAcrossZone',
      ownerAccount: 'OwnerAccount',
      rebootTime: 'RebootTime',
      endTime: 'EndTime',
      rebootWhenFinished: 'RebootWhenFinished',
    };
  }

  static types(): { [key: string]: any } {
    return {
      systemDisk: ModifyPrepayInstanceSpecRequestSystemDisk,
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      instanceId: 'string',
      regionId: 'string',
      instanceType: 'string',
      operatorType: 'string',
      clientToken: 'string',
      autoPay: 'boolean',
      migrateAcrossZone: 'boolean',
      ownerAccount: 'string',
      rebootTime: 'string',
      endTime: 'string',
      rebootWhenFinished: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyPrepayInstanceSpecResponseBody extends $tea.Model {
  requestId?: string;
  orderId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      orderId: 'OrderId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      orderId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyPrepayInstanceSpecResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ModifyPrepayInstanceSpecResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ModifyPrepayInstanceSpecResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyReservedInstanceAttributeRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  reservedInstanceId?: string;
  reservedInstanceName?: string;
  description?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      reservedInstanceId: 'ReservedInstanceId',
      reservedInstanceName: 'ReservedInstanceName',
      description: 'Description',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      reservedInstanceId: 'string',
      reservedInstanceName: 'string',
      description: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyReservedInstanceAttributeResponseBody extends $tea.Model {
  message?: string;
  requestId?: string;
  httpStatusCode?: number;
  code?: string;
  static names(): { [key: string]: string } {
    return {
      message: 'Message',
      requestId: 'RequestId',
      httpStatusCode: 'HttpStatusCode',
      code: 'Code',
    };
  }

  static types(): { [key: string]: any } {
    return {
      message: 'string',
      requestId: 'string',
      httpStatusCode: 'number',
      code: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyReservedInstanceAttributeResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ModifyReservedInstanceAttributeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ModifyReservedInstanceAttributeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyReservedInstancesRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  reservedInstanceId?: string[];
  configuration?: ModifyReservedInstancesRequestConfiguration[];
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      reservedInstanceId: 'ReservedInstanceId',
      configuration: 'Configuration',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      reservedInstanceId: { 'type': 'array', 'itemType': 'string' },
      configuration: { 'type': 'array', 'itemType': ModifyReservedInstancesRequestConfiguration },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyReservedInstancesResponseBody extends $tea.Model {
  reservedInstanceIdSets?: string[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      reservedInstanceIdSets: 'ReservedInstanceIdSets',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      reservedInstanceIdSets: { 'type': 'array', 'itemType': 'string' },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyReservedInstancesResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ModifyReservedInstancesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ModifyReservedInstancesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyRouterInterfaceAttributeRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  routerInterfaceId?: string;
  name?: string;
  description?: string;
  oppositeInterfaceId?: string;
  oppositeRouterId?: string;
  oppositeRouterType?: string;
  oppositeInterfaceOwnerId?: number;
  healthCheckSourceIp?: string;
  healthCheckTargetIp?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      routerInterfaceId: 'RouterInterfaceId',
      name: 'Name',
      description: 'Description',
      oppositeInterfaceId: 'OppositeInterfaceId',
      oppositeRouterId: 'OppositeRouterId',
      oppositeRouterType: 'OppositeRouterType',
      oppositeInterfaceOwnerId: 'OppositeInterfaceOwnerId',
      healthCheckSourceIp: 'HealthCheckSourceIp',
      healthCheckTargetIp: 'HealthCheckTargetIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      routerInterfaceId: 'string',
      name: 'string',
      description: 'string',
      oppositeInterfaceId: 'string',
      oppositeRouterId: 'string',
      oppositeRouterType: 'string',
      oppositeInterfaceOwnerId: 'number',
      healthCheckSourceIp: 'string',
      healthCheckTargetIp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyRouterInterfaceAttributeResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyRouterInterfaceAttributeResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ModifyRouterInterfaceAttributeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ModifyRouterInterfaceAttributeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyRouterInterfaceSpecRequest extends $tea.Model {
  regionId?: string;
  routerInterfaceId?: string;
  spec?: string;
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  clientToken?: string;
  ownerAccount?: string;
  userCidr?: string;
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
      routerInterfaceId: 'RouterInterfaceId',
      spec: 'Spec',
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      clientToken: 'ClientToken',
      ownerAccount: 'OwnerAccount',
      userCidr: 'UserCidr',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
      routerInterfaceId: 'string',
      spec: 'string',
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      clientToken: 'string',
      ownerAccount: 'string',
      userCidr: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyRouterInterfaceSpecResponseBody extends $tea.Model {
  requestId?: string;
  spec?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      spec: 'Spec',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      spec: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyRouterInterfaceSpecResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ModifyRouterInterfaceSpecResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ModifyRouterInterfaceSpecResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifySecurityGroupAttributeRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  securityGroupId?: string;
  description?: string;
  securityGroupName?: string;
  regionId?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      securityGroupId: 'SecurityGroupId',
      description: 'Description',
      securityGroupName: 'SecurityGroupName',
      regionId: 'RegionId',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      securityGroupId: 'string',
      description: 'string',
      securityGroupName: 'string',
      regionId: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifySecurityGroupAttributeResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifySecurityGroupAttributeResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ModifySecurityGroupAttributeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ModifySecurityGroupAttributeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifySecurityGroupEgressRuleRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  securityGroupId?: string;
  ipProtocol?: string;
  portRange?: string;
  destGroupId?: string;
  destGroupOwnerId?: number;
  destGroupOwnerAccount?: string;
  destCidrIp?: string;
  ipv6DestCidrIp?: string;
  sourceCidrIp?: string;
  ipv6SourceCidrIp?: string;
  sourcePortRange?: string;
  policy?: string;
  priority?: string;
  nicType?: string;
  clientToken?: string;
  description?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      securityGroupId: 'SecurityGroupId',
      ipProtocol: 'IpProtocol',
      portRange: 'PortRange',
      destGroupId: 'DestGroupId',
      destGroupOwnerId: 'DestGroupOwnerId',
      destGroupOwnerAccount: 'DestGroupOwnerAccount',
      destCidrIp: 'DestCidrIp',
      ipv6DestCidrIp: 'Ipv6DestCidrIp',
      sourceCidrIp: 'SourceCidrIp',
      ipv6SourceCidrIp: 'Ipv6SourceCidrIp',
      sourcePortRange: 'SourcePortRange',
      policy: 'Policy',
      priority: 'Priority',
      nicType: 'NicType',
      clientToken: 'ClientToken',
      description: 'Description',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      securityGroupId: 'string',
      ipProtocol: 'string',
      portRange: 'string',
      destGroupId: 'string',
      destGroupOwnerId: 'number',
      destGroupOwnerAccount: 'string',
      destCidrIp: 'string',
      ipv6DestCidrIp: 'string',
      sourceCidrIp: 'string',
      ipv6SourceCidrIp: 'string',
      sourcePortRange: 'string',
      policy: 'string',
      priority: 'string',
      nicType: 'string',
      clientToken: 'string',
      description: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifySecurityGroupEgressRuleResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifySecurityGroupEgressRuleResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ModifySecurityGroupEgressRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ModifySecurityGroupEgressRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifySecurityGroupPolicyRequest extends $tea.Model {
  securityGroupId?: string;
  regionId?: string;
  innerAccessPolicy?: string;
  clientToken?: string;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  ownerId?: number;
  static names(): { [key: string]: string } {
    return {
      securityGroupId: 'SecurityGroupId',
      regionId: 'RegionId',
      innerAccessPolicy: 'InnerAccessPolicy',
      clientToken: 'ClientToken',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      securityGroupId: 'string',
      regionId: 'string',
      innerAccessPolicy: 'string',
      clientToken: 'string',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      ownerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifySecurityGroupPolicyResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifySecurityGroupPolicyResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ModifySecurityGroupPolicyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ModifySecurityGroupPolicyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifySecurityGroupRuleRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  securityGroupId?: string;
  ipProtocol?: string;
  portRange?: string;
  sourceGroupId?: string;
  sourceGroupOwnerId?: number;
  sourceGroupOwnerAccount?: string;
  sourceCidrIp?: string;
  ipv6SourceCidrIp?: string;
  sourcePortRange?: string;
  destCidrIp?: string;
  ipv6DestCidrIp?: string;
  policy?: string;
  priority?: string;
  nicType?: string;
  clientToken?: string;
  description?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      securityGroupId: 'SecurityGroupId',
      ipProtocol: 'IpProtocol',
      portRange: 'PortRange',
      sourceGroupId: 'SourceGroupId',
      sourceGroupOwnerId: 'SourceGroupOwnerId',
      sourceGroupOwnerAccount: 'SourceGroupOwnerAccount',
      sourceCidrIp: 'SourceCidrIp',
      ipv6SourceCidrIp: 'Ipv6SourceCidrIp',
      sourcePortRange: 'SourcePortRange',
      destCidrIp: 'DestCidrIp',
      ipv6DestCidrIp: 'Ipv6DestCidrIp',
      policy: 'Policy',
      priority: 'Priority',
      nicType: 'NicType',
      clientToken: 'ClientToken',
      description: 'Description',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      securityGroupId: 'string',
      ipProtocol: 'string',
      portRange: 'string',
      sourceGroupId: 'string',
      sourceGroupOwnerId: 'number',
      sourceGroupOwnerAccount: 'string',
      sourceCidrIp: 'string',
      ipv6SourceCidrIp: 'string',
      sourcePortRange: 'string',
      destCidrIp: 'string',
      ipv6DestCidrIp: 'string',
      policy: 'string',
      priority: 'string',
      nicType: 'string',
      clientToken: 'string',
      description: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifySecurityGroupRuleResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifySecurityGroupRuleResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ModifySecurityGroupRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ModifySecurityGroupRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifySnapshotAttributeRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  snapshotId?: string;
  snapshotName?: string;
  description?: string;
  disableInstantAccess?: boolean;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      snapshotId: 'SnapshotId',
      snapshotName: 'SnapshotName',
      description: 'Description',
      disableInstantAccess: 'DisableInstantAccess',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      snapshotId: 'string',
      snapshotName: 'string',
      description: 'string',
      disableInstantAccess: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifySnapshotAttributeResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifySnapshotAttributeResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ModifySnapshotAttributeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ModifySnapshotAttributeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyStorageCapacityUnitAttributeRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  storageCapacityUnitId?: string;
  name?: string;
  description?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      storageCapacityUnitId: 'StorageCapacityUnitId',
      name: 'Name',
      description: 'Description',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      storageCapacityUnitId: 'string',
      name: 'string',
      description: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyStorageCapacityUnitAttributeResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyStorageCapacityUnitAttributeResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ModifyStorageCapacityUnitAttributeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ModifyStorageCapacityUnitAttributeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyStorageSetAttributeRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  clientToken?: string;
  regionId?: string;
  storageSetId?: string;
  storageSetName?: string;
  description?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      clientToken: 'ClientToken',
      regionId: 'RegionId',
      storageSetId: 'StorageSetId',
      storageSetName: 'StorageSetName',
      description: 'Description',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      clientToken: 'string',
      regionId: 'string',
      storageSetId: 'string',
      storageSetName: 'string',
      description: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyStorageSetAttributeResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyStorageSetAttributeResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ModifyStorageSetAttributeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ModifyStorageSetAttributeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyUserBusinessBehaviorRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  statusKey?: string;
  statusValue?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      statusKey: 'statusKey',
      statusValue: 'statusValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      statusKey: 'string',
      statusValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyUserBusinessBehaviorResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyUserBusinessBehaviorResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ModifyUserBusinessBehaviorResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ModifyUserBusinessBehaviorResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyVirtualBorderRouterAttributeRequest extends $tea.Model {
  regionId?: string;
  vbrId?: string;
  vlanId?: number;
  circuitCode?: string;
  localGatewayIp?: string;
  peerGatewayIp?: string;
  peeringSubnetMask?: string;
  description?: string;
  name?: string;
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  clientToken?: string;
  ownerAccount?: string;
  userCidr?: string;
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
      vbrId: 'VbrId',
      vlanId: 'VlanId',
      circuitCode: 'CircuitCode',
      localGatewayIp: 'LocalGatewayIp',
      peerGatewayIp: 'PeerGatewayIp',
      peeringSubnetMask: 'PeeringSubnetMask',
      description: 'Description',
      name: 'Name',
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      clientToken: 'ClientToken',
      ownerAccount: 'OwnerAccount',
      userCidr: 'UserCidr',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
      vbrId: 'string',
      vlanId: 'number',
      circuitCode: 'string',
      localGatewayIp: 'string',
      peerGatewayIp: 'string',
      peeringSubnetMask: 'string',
      description: 'string',
      name: 'string',
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      clientToken: 'string',
      ownerAccount: 'string',
      userCidr: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyVirtualBorderRouterAttributeResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyVirtualBorderRouterAttributeResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ModifyVirtualBorderRouterAttributeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ModifyVirtualBorderRouterAttributeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyVpcAttributeRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  vpcId?: string;
  description?: string;
  vpcName?: string;
  cidrBlock?: string;
  regionId?: string;
  ownerAccount?: string;
  userCidr?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      vpcId: 'VpcId',
      description: 'Description',
      vpcName: 'VpcName',
      cidrBlock: 'CidrBlock',
      regionId: 'RegionId',
      ownerAccount: 'OwnerAccount',
      userCidr: 'UserCidr',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      vpcId: 'string',
      description: 'string',
      vpcName: 'string',
      cidrBlock: 'string',
      regionId: 'string',
      ownerAccount: 'string',
      userCidr: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyVpcAttributeResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyVpcAttributeResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ModifyVpcAttributeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ModifyVpcAttributeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyVRouterAttributeRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  VRouterId?: string;
  VRouterName?: string;
  description?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      VRouterId: 'VRouterId',
      VRouterName: 'VRouterName',
      description: 'Description',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      VRouterId: 'string',
      VRouterName: 'string',
      description: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyVRouterAttributeResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyVRouterAttributeResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ModifyVRouterAttributeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ModifyVRouterAttributeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyVSwitchAttributeRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  vSwitchId?: string;
  vSwitchName?: string;
  regionId?: string;
  description?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      vSwitchId: 'VSwitchId',
      vSwitchName: 'VSwitchName',
      regionId: 'RegionId',
      description: 'Description',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      vSwitchId: 'string',
      vSwitchName: 'string',
      regionId: 'string',
      description: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyVSwitchAttributeResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyVSwitchAttributeResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ModifyVSwitchAttributeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ModifyVSwitchAttributeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PurchaseReservedInstancesOfferingRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  tag?: PurchaseReservedInstancesOfferingRequestTag[];
  resourceGroupId?: string;
  zoneId?: string;
  reservedInstanceName?: string;
  instanceType?: string;
  scope?: string;
  instanceAmount?: number;
  offeringType?: string;
  description?: string;
  platform?: string;
  period?: number;
  periodUnit?: string;
  clientToken?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      tag: 'Tag',
      resourceGroupId: 'ResourceGroupId',
      zoneId: 'ZoneId',
      reservedInstanceName: 'ReservedInstanceName',
      instanceType: 'InstanceType',
      scope: 'Scope',
      instanceAmount: 'InstanceAmount',
      offeringType: 'OfferingType',
      description: 'Description',
      platform: 'Platform',
      period: 'Period',
      periodUnit: 'PeriodUnit',
      clientToken: 'ClientToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      tag: { 'type': 'array', 'itemType': PurchaseReservedInstancesOfferingRequestTag },
      resourceGroupId: 'string',
      zoneId: 'string',
      reservedInstanceName: 'string',
      instanceType: 'string',
      scope: 'string',
      instanceAmount: 'number',
      offeringType: 'string',
      description: 'string',
      platform: 'string',
      period: 'number',
      periodUnit: 'string',
      clientToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PurchaseReservedInstancesOfferingResponseBody extends $tea.Model {
  reservedInstanceIdSets?: string[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      reservedInstanceIdSets: 'ReservedInstanceIdSets',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      reservedInstanceIdSets: { 'type': 'array', 'itemType': 'string' },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PurchaseReservedInstancesOfferingResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: PurchaseReservedInstancesOfferingResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: PurchaseReservedInstancesOfferingResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PurchaseStorageCapacityUnitRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  name?: string;
  capacity?: number;
  description?: string;
  startTime?: string;
  period?: number;
  periodUnit?: string;
  fromApp?: string;
  clientToken?: string;
  amount?: number;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      name: 'Name',
      capacity: 'Capacity',
      description: 'Description',
      startTime: 'StartTime',
      period: 'Period',
      periodUnit: 'PeriodUnit',
      fromApp: 'FromApp',
      clientToken: 'ClientToken',
      amount: 'Amount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      name: 'string',
      capacity: 'number',
      description: 'string',
      startTime: 'string',
      period: 'number',
      periodUnit: 'string',
      fromApp: 'string',
      clientToken: 'string',
      amount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PurchaseStorageCapacityUnitResponseBody extends $tea.Model {
  storageCapacityUnitIds?: string[];
  requestId?: string;
  orderId?: string;
  static names(): { [key: string]: string } {
    return {
      storageCapacityUnitIds: 'StorageCapacityUnitIds',
      requestId: 'RequestId',
      orderId: 'OrderId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      storageCapacityUnitIds: { 'type': 'array', 'itemType': 'string' },
      requestId: 'string',
      orderId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PurchaseStorageCapacityUnitResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: PurchaseStorageCapacityUnitResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: PurchaseStorageCapacityUnitResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReActivateInstancesRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  instanceId?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      instanceId: 'InstanceId',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      instanceId: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReActivateInstancesResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReActivateInstancesResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ReActivateInstancesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ReActivateInstancesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RebootInstanceRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  instanceId?: string;
  forceStop?: boolean;
  ownerAccount?: string;
  dryRun?: boolean;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      instanceId: 'InstanceId',
      forceStop: 'ForceStop',
      ownerAccount: 'OwnerAccount',
      dryRun: 'DryRun',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      instanceId: 'string',
      forceStop: 'boolean',
      ownerAccount: 'string',
      dryRun: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RebootInstanceResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RebootInstanceResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: RebootInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: RebootInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RebootInstancesRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  dryRun?: boolean;
  regionId?: string;
  forceReboot?: boolean;
  batchOptimization?: string;
  instanceId?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      dryRun: 'DryRun',
      regionId: 'RegionId',
      forceReboot: 'ForceReboot',
      batchOptimization: 'BatchOptimization',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      dryRun: 'boolean',
      regionId: 'string',
      forceReboot: 'boolean',
      batchOptimization: 'string',
      instanceId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RebootInstancesResponseBody extends $tea.Model {
  requestId?: string;
  instanceResponses?: RebootInstancesResponseBodyInstanceResponses[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      instanceResponses: 'InstanceResponses',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      instanceResponses: { 'type': 'array', 'itemType': RebootInstancesResponseBodyInstanceResponses },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RebootInstancesResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: RebootInstancesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: RebootInstancesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RecoverVirtualBorderRouterRequest extends $tea.Model {
  regionId?: string;
  vbrId?: string;
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  clientToken?: string;
  ownerAccount?: string;
  userCidr?: string;
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
      vbrId: 'VbrId',
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      clientToken: 'ClientToken',
      ownerAccount: 'OwnerAccount',
      userCidr: 'UserCidr',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
      vbrId: 'string',
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      clientToken: 'string',
      ownerAccount: 'string',
      userCidr: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RecoverVirtualBorderRouterResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RecoverVirtualBorderRouterResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: RecoverVirtualBorderRouterResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: RecoverVirtualBorderRouterResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RedeployDedicatedHostRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  dedicatedHostId?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      dedicatedHostId: 'DedicatedHostId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      dedicatedHostId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RedeployDedicatedHostResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RedeployDedicatedHostResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: RedeployDedicatedHostResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: RedeployDedicatedHostResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RedeployInstanceRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  instanceId?: string;
  forceStop?: boolean;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      instanceId: 'InstanceId',
      forceStop: 'ForceStop',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      instanceId: 'string',
      forceStop: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RedeployInstanceResponseBody extends $tea.Model {
  taskId?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      taskId: 'TaskId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      taskId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RedeployInstanceResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: RedeployInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: RedeployInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReInitDiskRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  diskId?: string;
  ownerAccount?: string;
  password?: string;
  keyPairName?: string;
  autoStartInstance?: boolean;
  securityEnhancementStrategy?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      diskId: 'DiskId',
      ownerAccount: 'OwnerAccount',
      password: 'Password',
      keyPairName: 'KeyPairName',
      autoStartInstance: 'AutoStartInstance',
      securityEnhancementStrategy: 'SecurityEnhancementStrategy',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      diskId: 'string',
      ownerAccount: 'string',
      password: 'string',
      keyPairName: 'string',
      autoStartInstance: 'boolean',
      securityEnhancementStrategy: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReInitDiskResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReInitDiskResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ReInitDiskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ReInitDiskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReleaseCapacityReservationRequest extends $tea.Model {
  privatePoolOptions?: ReleaseCapacityReservationRequestPrivatePoolOptions;
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  dryRun?: boolean;
  static names(): { [key: string]: string } {
    return {
      privatePoolOptions: 'PrivatePoolOptions',
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      dryRun: 'DryRun',
    };
  }

  static types(): { [key: string]: any } {
    return {
      privatePoolOptions: ReleaseCapacityReservationRequestPrivatePoolOptions,
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      dryRun: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReleaseCapacityReservationResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReleaseCapacityReservationResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ReleaseCapacityReservationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ReleaseCapacityReservationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReleaseDedicatedHostRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  dedicatedHostId?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      dedicatedHostId: 'DedicatedHostId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      dedicatedHostId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReleaseDedicatedHostResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReleaseDedicatedHostResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ReleaseDedicatedHostResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ReleaseDedicatedHostResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReleaseEipAddressRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  allocationId?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      allocationId: 'AllocationId',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      allocationId: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReleaseEipAddressResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReleaseEipAddressResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ReleaseEipAddressResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ReleaseEipAddressResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReleasePublicIpAddressRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  instanceId?: string;
  publicIpAddress?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      instanceId: 'InstanceId',
      publicIpAddress: 'PublicIpAddress',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      instanceId: 'string',
      publicIpAddress: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReleasePublicIpAddressResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReleasePublicIpAddressResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ReleasePublicIpAddressResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ReleasePublicIpAddressResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveBandwidthPackageIpsRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  bandwidthPackageId?: string;
  clientToken?: string;
  removedIpAddresses?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      bandwidthPackageId: 'BandwidthPackageId',
      clientToken: 'ClientToken',
      removedIpAddresses: 'RemovedIpAddresses',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      bandwidthPackageId: 'string',
      clientToken: 'string',
      removedIpAddresses: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveBandwidthPackageIpsResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveBandwidthPackageIpsResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: RemoveBandwidthPackageIpsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: RemoveBandwidthPackageIpsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveTagsRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  resourceType?: string;
  resourceId?: string;
  tag?: RemoveTagsRequestTag[];
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      resourceType: 'ResourceType',
      resourceId: 'ResourceId',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      resourceType: 'string',
      resourceId: 'string',
      tag: { 'type': 'array', 'itemType': RemoveTagsRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveTagsResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveTagsResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: RemoveTagsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: RemoveTagsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RenewDedicatedHostsRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  dedicatedHostIds?: string;
  regionId?: string;
  period?: number;
  periodUnit?: string;
  clientToken?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      dedicatedHostIds: 'DedicatedHostIds',
      regionId: 'RegionId',
      period: 'Period',
      periodUnit: 'PeriodUnit',
      clientToken: 'ClientToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      dedicatedHostIds: 'string',
      regionId: 'string',
      period: 'number',
      periodUnit: 'string',
      clientToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RenewDedicatedHostsResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RenewDedicatedHostsResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: RenewDedicatedHostsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: RenewDedicatedHostsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RenewInstanceRequest extends $tea.Model {
  clientToken?: string;
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  instanceId?: string;
  period?: number;
  periodUnit?: string;
  static names(): { [key: string]: string } {
    return {
      clientToken: 'ClientToken',
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      instanceId: 'InstanceId',
      period: 'Period',
      periodUnit: 'PeriodUnit',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clientToken: 'string',
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      instanceId: 'string',
      period: 'number',
      periodUnit: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RenewInstanceResponseBody extends $tea.Model {
  requestId?: string;
  orderId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      orderId: 'OrderId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      orderId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RenewInstanceResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: RenewInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: RenewInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReplaceSystemDiskRequest extends $tea.Model {
  systemDisk?: ReplaceSystemDiskRequestSystemDisk;
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  instanceId?: string;
  imageId?: string;
  clientToken?: string;
  ownerAccount?: string;
  useAdditionalService?: boolean;
  password?: string;
  passwordInherit?: boolean;
  keyPairName?: string;
  diskId?: string;
  platform?: string;
  architecture?: string;
  securityEnhancementStrategy?: string;
  static names(): { [key: string]: string } {
    return {
      systemDisk: 'SystemDisk',
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      instanceId: 'InstanceId',
      imageId: 'ImageId',
      clientToken: 'ClientToken',
      ownerAccount: 'OwnerAccount',
      useAdditionalService: 'UseAdditionalService',
      password: 'Password',
      passwordInherit: 'PasswordInherit',
      keyPairName: 'KeyPairName',
      diskId: 'DiskId',
      platform: 'Platform',
      architecture: 'Architecture',
      securityEnhancementStrategy: 'SecurityEnhancementStrategy',
    };
  }

  static types(): { [key: string]: any } {
    return {
      systemDisk: ReplaceSystemDiskRequestSystemDisk,
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      instanceId: 'string',
      imageId: 'string',
      clientToken: 'string',
      ownerAccount: 'string',
      useAdditionalService: 'boolean',
      password: 'string',
      passwordInherit: 'boolean',
      keyPairName: 'string',
      diskId: 'string',
      platform: 'string',
      architecture: 'string',
      securityEnhancementStrategy: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReplaceSystemDiskResponseBody extends $tea.Model {
  requestId?: string;
  diskId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      diskId: 'DiskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      diskId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReplaceSystemDiskResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ReplaceSystemDiskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ReplaceSystemDiskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReportInstancesStatusRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  reason?: string;
  description?: string;
  startTime?: string;
  endTime?: string;
  issueCategory?: string;
  instanceId?: string[];
  diskId?: string[];
  device?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      reason: 'Reason',
      description: 'Description',
      startTime: 'StartTime',
      endTime: 'EndTime',
      issueCategory: 'IssueCategory',
      instanceId: 'InstanceId',
      diskId: 'DiskId',
      device: 'Device',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      reason: 'string',
      description: 'string',
      startTime: 'string',
      endTime: 'string',
      issueCategory: 'string',
      instanceId: { 'type': 'array', 'itemType': 'string' },
      diskId: { 'type': 'array', 'itemType': 'string' },
      device: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReportInstancesStatusResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReportInstancesStatusResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ReportInstancesStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ReportInstancesStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResetDiskRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  diskId?: string;
  snapshotId?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      diskId: 'DiskId',
      snapshotId: 'SnapshotId',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      diskId: 'string',
      snapshotId: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResetDiskResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResetDiskResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ResetDiskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ResetDiskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResizeDiskRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  diskId?: string;
  type?: string;
  newSize?: number;
  clientToken?: string;
  ownerAccount?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      diskId: 'DiskId',
      type: 'Type',
      newSize: 'NewSize',
      clientToken: 'ClientToken',
      ownerAccount: 'OwnerAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      diskId: 'string',
      type: 'string',
      newSize: 'number',
      clientToken: 'string',
      ownerAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResizeDiskResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResizeDiskResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ResizeDiskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ResizeDiskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RevokeSecurityGroupRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  securityGroupId?: string;
  destCidrIp?: string;
  ipv6DestCidrIp?: string;
  portRange?: string;
  ipProtocol?: string;
  sourceGroupId?: string;
  sourceGroupOwnerId?: number;
  sourceGroupOwnerAccount?: string;
  sourceCidrIp?: string;
  ipv6SourceCidrIp?: string;
  sourcePortRange?: string;
  policy?: string;
  priority?: string;
  nicType?: string;
  clientToken?: string;
  description?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      securityGroupId: 'SecurityGroupId',
      destCidrIp: 'DestCidrIp',
      ipv6DestCidrIp: 'Ipv6DestCidrIp',
      portRange: 'PortRange',
      ipProtocol: 'IpProtocol',
      sourceGroupId: 'SourceGroupId',
      sourceGroupOwnerId: 'SourceGroupOwnerId',
      sourceGroupOwnerAccount: 'SourceGroupOwnerAccount',
      sourceCidrIp: 'SourceCidrIp',
      ipv6SourceCidrIp: 'Ipv6SourceCidrIp',
      sourcePortRange: 'SourcePortRange',
      policy: 'Policy',
      priority: 'Priority',
      nicType: 'NicType',
      clientToken: 'ClientToken',
      description: 'Description',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      securityGroupId: 'string',
      destCidrIp: 'string',
      ipv6DestCidrIp: 'string',
      portRange: 'string',
      ipProtocol: 'string',
      sourceGroupId: 'string',
      sourceGroupOwnerId: 'number',
      sourceGroupOwnerAccount: 'string',
      sourceCidrIp: 'string',
      ipv6SourceCidrIp: 'string',
      sourcePortRange: 'string',
      policy: 'string',
      priority: 'string',
      nicType: 'string',
      clientToken: 'string',
      description: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RevokeSecurityGroupResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RevokeSecurityGroupResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: RevokeSecurityGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: RevokeSecurityGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RevokeSecurityGroupEgressRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  securityGroupId?: string;
  ipProtocol?: string;
  portRange?: string;
  destGroupId?: string;
  destGroupOwnerId?: number;
  destGroupOwnerAccount?: string;
  destCidrIp?: string;
  ipv6DestCidrIp?: string;
  sourceCidrIp?: string;
  ipv6SourceCidrIp?: string;
  sourcePortRange?: string;
  policy?: string;
  priority?: string;
  nicType?: string;
  clientToken?: string;
  description?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      securityGroupId: 'SecurityGroupId',
      ipProtocol: 'IpProtocol',
      portRange: 'PortRange',
      destGroupId: 'DestGroupId',
      destGroupOwnerId: 'DestGroupOwnerId',
      destGroupOwnerAccount: 'DestGroupOwnerAccount',
      destCidrIp: 'DestCidrIp',
      ipv6DestCidrIp: 'Ipv6DestCidrIp',
      sourceCidrIp: 'SourceCidrIp',
      ipv6SourceCidrIp: 'Ipv6SourceCidrIp',
      sourcePortRange: 'SourcePortRange',
      policy: 'Policy',
      priority: 'Priority',
      nicType: 'NicType',
      clientToken: 'ClientToken',
      description: 'Description',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      securityGroupId: 'string',
      ipProtocol: 'string',
      portRange: 'string',
      destGroupId: 'string',
      destGroupOwnerId: 'number',
      destGroupOwnerAccount: 'string',
      destCidrIp: 'string',
      ipv6DestCidrIp: 'string',
      sourceCidrIp: 'string',
      ipv6SourceCidrIp: 'string',
      sourcePortRange: 'string',
      policy: 'string',
      priority: 'string',
      nicType: 'string',
      clientToken: 'string',
      description: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RevokeSecurityGroupEgressResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RevokeSecurityGroupEgressResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: RevokeSecurityGroupEgressResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: RevokeSecurityGroupEgressResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RunCommandRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  name?: string;
  description?: string;
  type?: string;
  commandContent?: string;
  workingDir?: string;
  timeout?: number;
  enableParameter?: boolean;
  timed?: boolean;
  frequency?: string;
  parameters?: { [key: string]: any };
  keepCommand?: boolean;
  contentEncoding?: string;
  username?: string;
  instanceId?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      name: 'Name',
      description: 'Description',
      type: 'Type',
      commandContent: 'CommandContent',
      workingDir: 'WorkingDir',
      timeout: 'Timeout',
      enableParameter: 'EnableParameter',
      timed: 'Timed',
      frequency: 'Frequency',
      parameters: 'Parameters',
      keepCommand: 'KeepCommand',
      contentEncoding: 'ContentEncoding',
      username: 'Username',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      name: 'string',
      description: 'string',
      type: 'string',
      commandContent: 'string',
      workingDir: 'string',
      timeout: 'number',
      enableParameter: 'boolean',
      timed: 'boolean',
      frequency: 'string',
      parameters: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      keepCommand: 'boolean',
      contentEncoding: 'string',
      username: 'string',
      instanceId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RunCommandShrinkRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  name?: string;
  description?: string;
  type?: string;
  commandContent?: string;
  workingDir?: string;
  timeout?: number;
  enableParameter?: boolean;
  timed?: boolean;
  frequency?: string;
  parametersShrink?: string;
  keepCommand?: boolean;
  contentEncoding?: string;
  username?: string;
  instanceId?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      name: 'Name',
      description: 'Description',
      type: 'Type',
      commandContent: 'CommandContent',
      workingDir: 'WorkingDir',
      timeout: 'Timeout',
      enableParameter: 'EnableParameter',
      timed: 'Timed',
      frequency: 'Frequency',
      parametersShrink: 'Parameters',
      keepCommand: 'KeepCommand',
      contentEncoding: 'ContentEncoding',
      username: 'Username',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      name: 'string',
      description: 'string',
      type: 'string',
      commandContent: 'string',
      workingDir: 'string',
      timeout: 'number',
      enableParameter: 'boolean',
      timed: 'boolean',
      frequency: 'string',
      parametersShrink: 'string',
      keepCommand: 'boolean',
      contentEncoding: 'string',
      username: 'string',
      instanceId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RunCommandResponseBody extends $tea.Model {
  requestId?: string;
  commandId?: string;
  invokeId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      commandId: 'CommandId',
      invokeId: 'InvokeId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      commandId: 'string',
      invokeId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RunCommandResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: RunCommandResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: RunCommandResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SendFileRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  name?: string;
  description?: string;
  timeout?: number;
  targetDir?: string;
  contentType?: string;
  content?: string;
  fileOwner?: string;
  fileGroup?: string;
  fileMode?: string;
  overwrite?: boolean;
  instanceId?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      name: 'Name',
      description: 'Description',
      timeout: 'Timeout',
      targetDir: 'TargetDir',
      contentType: 'ContentType',
      content: 'Content',
      fileOwner: 'FileOwner',
      fileGroup: 'FileGroup',
      fileMode: 'FileMode',
      overwrite: 'Overwrite',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      name: 'string',
      description: 'string',
      timeout: 'number',
      targetDir: 'string',
      contentType: 'string',
      content: 'string',
      fileOwner: 'string',
      fileGroup: 'string',
      fileMode: 'string',
      overwrite: 'boolean',
      instanceId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SendFileResponseBody extends $tea.Model {
  requestId?: string;
  invokeId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      invokeId: 'InvokeId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      invokeId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SendFileResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: SendFileResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: SendFileResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartElasticityAssuranceRequest extends $tea.Model {
  privatePoolOptions?: StartElasticityAssuranceRequestPrivatePoolOptions;
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      privatePoolOptions: 'PrivatePoolOptions',
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      privatePoolOptions: StartElasticityAssuranceRequestPrivatePoolOptions,
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartElasticityAssuranceResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartElasticityAssuranceResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: StartElasticityAssuranceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: StartElasticityAssuranceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartInstanceRequest extends $tea.Model {
  sourceRegionId?: string;
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  instanceId?: string;
  initLocalDisk?: boolean;
  ownerAccount?: string;
  dryRun?: boolean;
  static names(): { [key: string]: string } {
    return {
      sourceRegionId: 'SourceRegionId',
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      instanceId: 'InstanceId',
      initLocalDisk: 'InitLocalDisk',
      ownerAccount: 'OwnerAccount',
      dryRun: 'DryRun',
    };
  }

  static types(): { [key: string]: any } {
    return {
      sourceRegionId: 'string',
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      instanceId: 'string',
      initLocalDisk: 'boolean',
      ownerAccount: 'string',
      dryRun: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartInstanceResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartInstanceResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: StartInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: StartInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartInstancesRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  dryRun?: boolean;
  regionId?: string;
  batchOptimization?: string;
  instanceId?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      dryRun: 'DryRun',
      regionId: 'RegionId',
      batchOptimization: 'BatchOptimization',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      dryRun: 'boolean',
      regionId: 'string',
      batchOptimization: 'string',
      instanceId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartInstancesResponseBody extends $tea.Model {
  requestId?: string;
  instanceResponses?: StartInstancesResponseBodyInstanceResponses[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      instanceResponses: 'InstanceResponses',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      instanceResponses: { 'type': 'array', 'itemType': StartInstancesResponseBodyInstanceResponses },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartInstancesResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: StartInstancesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: StartInstancesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopInstanceRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  instanceId?: string;
  confirmStop?: boolean;
  forceStop?: boolean;
  ownerAccount?: string;
  stoppedMode?: string;
  dryRun?: boolean;
  hibernate?: boolean;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      instanceId: 'InstanceId',
      confirmStop: 'ConfirmStop',
      forceStop: 'ForceStop',
      ownerAccount: 'OwnerAccount',
      stoppedMode: 'StoppedMode',
      dryRun: 'DryRun',
      hibernate: 'Hibernate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      instanceId: 'string',
      confirmStop: 'boolean',
      forceStop: 'boolean',
      ownerAccount: 'string',
      stoppedMode: 'string',
      dryRun: 'boolean',
      hibernate: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopInstanceResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopInstanceResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: StopInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: StopInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopInstancesRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  dryRun?: boolean;
  regionId?: string;
  forceStop?: boolean;
  stoppedMode?: string;
  batchOptimization?: string;
  instanceId?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      dryRun: 'DryRun',
      regionId: 'RegionId',
      forceStop: 'ForceStop',
      stoppedMode: 'StoppedMode',
      batchOptimization: 'BatchOptimization',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      dryRun: 'boolean',
      regionId: 'string',
      forceStop: 'boolean',
      stoppedMode: 'string',
      batchOptimization: 'string',
      instanceId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopInstancesResponseBody extends $tea.Model {
  requestId?: string;
  instanceResponses?: StopInstancesResponseBodyInstanceResponses[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      instanceResponses: 'InstanceResponses',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      instanceResponses: { 'type': 'array', 'itemType': StopInstancesResponseBodyInstanceResponses },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopInstancesResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: StopInstancesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: StopInstancesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopInvocationRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  invokeId?: string;
  instanceId?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      invokeId: 'InvokeId',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      invokeId: 'string',
      instanceId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopInvocationResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopInvocationResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: StopInvocationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: StopInvocationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TagResourcesRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  ownerAccount?: string;
  regionId?: string;
  resourceType?: string;
  resourceId?: string[];
  tag?: TagResourcesRequestTag[];
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      resourceType: 'ResourceType',
      resourceId: 'ResourceId',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      ownerAccount: 'string',
      regionId: 'string',
      resourceType: 'string',
      resourceId: { 'type': 'array', 'itemType': 'string' },
      tag: { 'type': 'array', 'itemType': TagResourcesRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TagResourcesResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TagResourcesResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: TagResourcesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: TagResourcesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TerminatePhysicalConnectionRequest extends $tea.Model {
  regionId?: string;
  physicalConnectionId?: string;
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  clientToken?: string;
  ownerAccount?: string;
  userCidr?: string;
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
      physicalConnectionId: 'PhysicalConnectionId',
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      clientToken: 'ClientToken',
      ownerAccount: 'OwnerAccount',
      userCidr: 'UserCidr',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
      physicalConnectionId: 'string',
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      clientToken: 'string',
      ownerAccount: 'string',
      userCidr: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TerminatePhysicalConnectionResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TerminatePhysicalConnectionResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: TerminatePhysicalConnectionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: TerminatePhysicalConnectionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TerminateVirtualBorderRouterRequest extends $tea.Model {
  regionId?: string;
  vbrId?: string;
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  clientToken?: string;
  ownerAccount?: string;
  userCidr?: string;
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
      vbrId: 'VbrId',
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      clientToken: 'ClientToken',
      ownerAccount: 'OwnerAccount',
      userCidr: 'UserCidr',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
      vbrId: 'string',
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      clientToken: 'string',
      ownerAccount: 'string',
      userCidr: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TerminateVirtualBorderRouterResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TerminateVirtualBorderRouterResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: TerminateVirtualBorderRouterResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: TerminateVirtualBorderRouterResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnassignIpv6AddressesRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  networkInterfaceId?: string;
  ipv6Address?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      networkInterfaceId: 'NetworkInterfaceId',
      ipv6Address: 'Ipv6Address',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      networkInterfaceId: 'string',
      ipv6Address: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnassignIpv6AddressesResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnassignIpv6AddressesResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: UnassignIpv6AddressesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: UnassignIpv6AddressesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnassignPrivateIpAddressesRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  networkInterfaceId?: string;
  privateIpAddress?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      networkInterfaceId: 'NetworkInterfaceId',
      privateIpAddress: 'PrivateIpAddress',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      networkInterfaceId: 'string',
      privateIpAddress: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnassignPrivateIpAddressesResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnassignPrivateIpAddressesResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: UnassignPrivateIpAddressesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: UnassignPrivateIpAddressesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnassociateEipAddressRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  regionId?: string;
  allocationId?: string;
  instanceId?: string;
  ownerAccount?: string;
  instanceType?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      regionId: 'RegionId',
      allocationId: 'AllocationId',
      instanceId: 'InstanceId',
      ownerAccount: 'OwnerAccount',
      instanceType: 'InstanceType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      regionId: 'string',
      allocationId: 'string',
      instanceId: 'string',
      ownerAccount: 'string',
      instanceType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnassociateEipAddressResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnassociateEipAddressResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: UnassociateEipAddressResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: UnassociateEipAddressResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnassociateHaVipRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  clientToken?: string;
  regionId?: string;
  haVipId?: string;
  instanceId?: string;
  force?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      clientToken: 'ClientToken',
      regionId: 'RegionId',
      haVipId: 'HaVipId',
      instanceId: 'InstanceId',
      force: 'Force',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      clientToken: 'string',
      regionId: 'string',
      haVipId: 'string',
      instanceId: 'string',
      force: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnassociateHaVipResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnassociateHaVipResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: UnassociateHaVipResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: UnassociateHaVipResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UntagResourcesRequest extends $tea.Model {
  ownerId?: number;
  resourceOwnerAccount?: string;
  resourceOwnerId?: number;
  ownerAccount?: string;
  regionId?: string;
  resourceType?: string;
  all?: boolean;
  resourceId?: string[];
  tagKey?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      resourceOwnerAccount: 'ResourceOwnerAccount',
      resourceOwnerId: 'ResourceOwnerId',
      ownerAccount: 'OwnerAccount',
      regionId: 'RegionId',
      resourceType: 'ResourceType',
      all: 'All',
      resourceId: 'ResourceId',
      tagKey: 'TagKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      resourceOwnerAccount: 'string',
      resourceOwnerId: 'number',
      ownerAccount: 'string',
      regionId: 'string',
      resourceType: 'string',
      all: 'boolean',
      resourceId: { 'type': 'array', 'itemType': 'string' },
      tagKey: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UntagResourcesResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UntagResourcesResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: UntagResourcesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: UntagResourcesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddTagsRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AllocateDedicatedHostsRequestNetworkAttributes extends $tea.Model {
  slbUdpTimeout?: number;
  udpTimeout?: number;
  static names(): { [key: string]: string } {
    return {
      slbUdpTimeout: 'SlbUdpTimeout',
      udpTimeout: 'UdpTimeout',
    };
  }

  static types(): { [key: string]: any } {
    return {
      slbUdpTimeout: 'number',
      udpTimeout: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AllocateDedicatedHostsRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AssignPrivateIpAddressesResponseBodyAssignedPrivateIpAddressesSet extends $tea.Model {
  networkInterfaceId?: string;
  privateIpSet?: string[];
  static names(): { [key: string]: string } {
    return {
      networkInterfaceId: 'NetworkInterfaceId',
      privateIpSet: 'PrivateIpSet',
    };
  }

  static types(): { [key: string]: any } {
    return {
      networkInterfaceId: 'string',
      privateIpSet: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AttachInstanceRamRoleResponseBodyAttachInstanceRamRoleResults extends $tea.Model {
  success?: boolean;
  code?: string;
  message?: string;
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      success: 'Success',
      code: 'Code',
      message: 'Message',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      success: 'boolean',
      code: 'string',
      message: 'string',
      instanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AttachKeyPairResponseBodyResults extends $tea.Model {
  success?: string;
  code?: string;
  message?: string;
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      success: 'Success',
      code: 'Code',
      message: 'Message',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      success: 'string',
      code: 'string',
      message: 'string',
      instanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CopyImageRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CopySnapshotRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAutoProvisioningGroupRequestLaunchConfigurationDataDisk extends $tea.Model {
  performanceLevel?: string;
  description?: string;
  kmsKeyId?: string;
  snapshotId?: string;
  size?: number;
  device?: string;
  diskName?: string;
  category?: string;
  deleteWithInstance?: boolean;
  encrypted?: boolean;
  static names(): { [key: string]: string } {
    return {
      performanceLevel: 'PerformanceLevel',
      description: 'Description',
      kmsKeyId: 'KmsKeyId',
      snapshotId: 'SnapshotId',
      size: 'Size',
      device: 'Device',
      diskName: 'DiskName',
      category: 'Category',
      deleteWithInstance: 'DeleteWithInstance',
      encrypted: 'Encrypted',
    };
  }

  static types(): { [key: string]: any } {
    return {
      performanceLevel: 'string',
      description: 'string',
      kmsKeyId: 'string',
      snapshotId: 'string',
      size: 'number',
      device: 'string',
      diskName: 'string',
      category: 'string',
      deleteWithInstance: 'boolean',
      encrypted: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAutoProvisioningGroupRequestLaunchConfigurationTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAutoProvisioningGroupRequestLaunchConfiguration extends $tea.Model {
  imageId?: string;
  securityGroupId?: string;
  ioOptimized?: string;
  internetChargeType?: string;
  internetMaxBandwidthIn?: number;
  internetMaxBandwidthOut?: number;
  instanceName?: string;
  hostName?: string;
  instanceDescription?: string;
  keyPairName?: string;
  ramRoleName?: string;
  securityEnhancementStrategy?: string;
  userData?: string;
  systemDiskCategory?: string;
  systemDiskSize?: number;
  systemDiskName?: string;
  systemDiskDescription?: string;
  systemDiskPerformanceLevel?: string;
  passwordInherit?: boolean;
  resourceGroupId?: string;
  creditSpecification?: string;
  dataDisk?: CreateAutoProvisioningGroupRequestLaunchConfigurationDataDisk[];
  tag?: CreateAutoProvisioningGroupRequestLaunchConfigurationTag[];
  static names(): { [key: string]: string } {
    return {
      imageId: 'ImageId',
      securityGroupId: 'SecurityGroupId',
      ioOptimized: 'IoOptimized',
      internetChargeType: 'InternetChargeType',
      internetMaxBandwidthIn: 'InternetMaxBandwidthIn',
      internetMaxBandwidthOut: 'InternetMaxBandwidthOut',
      instanceName: 'InstanceName',
      hostName: 'HostName',
      instanceDescription: 'InstanceDescription',
      keyPairName: 'KeyPairName',
      ramRoleName: 'RamRoleName',
      securityEnhancementStrategy: 'SecurityEnhancementStrategy',
      userData: 'UserData',
      systemDiskCategory: 'SystemDiskCategory',
      systemDiskSize: 'SystemDiskSize',
      systemDiskName: 'SystemDiskName',
      systemDiskDescription: 'SystemDiskDescription',
      systemDiskPerformanceLevel: 'SystemDiskPerformanceLevel',
      passwordInherit: 'PasswordInherit',
      resourceGroupId: 'ResourceGroupId',
      creditSpecification: 'CreditSpecification',
      dataDisk: 'DataDisk',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      imageId: 'string',
      securityGroupId: 'string',
      ioOptimized: 'string',
      internetChargeType: 'string',
      internetMaxBandwidthIn: 'number',
      internetMaxBandwidthOut: 'number',
      instanceName: 'string',
      hostName: 'string',
      instanceDescription: 'string',
      keyPairName: 'string',
      ramRoleName: 'string',
      securityEnhancementStrategy: 'string',
      userData: 'string',
      systemDiskCategory: 'string',
      systemDiskSize: 'number',
      systemDiskName: 'string',
      systemDiskDescription: 'string',
      systemDiskPerformanceLevel: 'string',
      passwordInherit: 'boolean',
      resourceGroupId: 'string',
      creditSpecification: 'string',
      dataDisk: { 'type': 'array', 'itemType': CreateAutoProvisioningGroupRequestLaunchConfigurationDataDisk },
      tag: { 'type': 'array', 'itemType': CreateAutoProvisioningGroupRequestLaunchConfigurationTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAutoProvisioningGroupRequestLaunchTemplateConfig extends $tea.Model {
  vSwitchId?: string;
  maxPrice?: number;
  priority?: number;
  weightedCapacity?: number;
  instanceType?: string;
  static names(): { [key: string]: string } {
    return {
      vSwitchId: 'VSwitchId',
      maxPrice: 'MaxPrice',
      priority: 'Priority',
      weightedCapacity: 'WeightedCapacity',
      instanceType: 'InstanceType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      vSwitchId: 'string',
      maxPrice: 'number',
      priority: 'number',
      weightedCapacity: 'number',
      instanceType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAutoProvisioningGroupRequestSystemDiskConfig extends $tea.Model {
  diskCategory?: string;
  static names(): { [key: string]: string } {
    return {
      diskCategory: 'DiskCategory',
    };
  }

  static types(): { [key: string]: any } {
    return {
      diskCategory: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAutoProvisioningGroupRequestDataDiskConfig extends $tea.Model {
  diskCategory?: string;
  static names(): { [key: string]: string } {
    return {
      diskCategory: 'DiskCategory',
    };
  }

  static types(): { [key: string]: any } {
    return {
      diskCategory: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAutoSnapshotPolicyRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCapacityReservationRequestPrivatePoolOptions extends $tea.Model {
  name?: string;
  matchCriteria?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      matchCriteria: 'MatchCriteria',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      matchCriteria: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDedicatedHostClusterRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDiskRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDiskRequestArn extends $tea.Model {
  roleType?: string;
  rolearn?: string;
  assumeRoleFor?: number;
  static names(): { [key: string]: string } {
    return {
      roleType: 'RoleType',
      rolearn: 'Rolearn',
      assumeRoleFor: 'AssumeRoleFor',
    };
  }

  static types(): { [key: string]: any } {
    return {
      roleType: 'string',
      rolearn: 'string',
      assumeRoleFor: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateElasticityAssuranceRequestPrivatePoolOptions extends $tea.Model {
  name?: string;
  matchCriteria?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      matchCriteria: 'MatchCriteria',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      matchCriteria: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateImageRequestDiskDeviceMapping extends $tea.Model {
  snapshotId?: string;
  size?: number;
  device?: string;
  diskType?: string;
  static names(): { [key: string]: string } {
    return {
      snapshotId: 'SnapshotId',
      size: 'Size',
      device: 'Device',
      diskType: 'DiskType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      snapshotId: 'string',
      size: 'number',
      device: 'string',
      diskType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateImageRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateInstanceRequestSystemDisk extends $tea.Model {
  size?: number;
  category?: string;
  diskName?: string;
  description?: string;
  performanceLevel?: string;
  static names(): { [key: string]: string } {
    return {
      size: 'Size',
      category: 'Category',
      diskName: 'DiskName',
      description: 'Description',
      performanceLevel: 'PerformanceLevel',
    };
  }

  static types(): { [key: string]: any } {
    return {
      size: 'number',
      category: 'string',
      diskName: 'string',
      description: 'string',
      performanceLevel: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateInstanceRequestPrivatePoolOptions extends $tea.Model {
  matchCriteria?: string;
  id?: string;
  static names(): { [key: string]: string } {
    return {
      matchCriteria: 'MatchCriteria',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      matchCriteria: 'string',
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateInstanceRequestDataDisk extends $tea.Model {
  performanceLevel?: string;
  description?: string;
  snapshotId?: string;
  size?: number;
  device?: string;
  diskName?: string;
  category?: string;
  KMSKeyId?: string;
  deleteWithInstance?: boolean;
  encryptAlgorithm?: string;
  encrypted?: boolean;
  static names(): { [key: string]: string } {
    return {
      performanceLevel: 'PerformanceLevel',
      description: 'Description',
      snapshotId: 'SnapshotId',
      size: 'Size',
      device: 'Device',
      diskName: 'DiskName',
      category: 'Category',
      KMSKeyId: 'KMSKeyId',
      deleteWithInstance: 'DeleteWithInstance',
      encryptAlgorithm: 'EncryptAlgorithm',
      encrypted: 'Encrypted',
    };
  }

  static types(): { [key: string]: any } {
    return {
      performanceLevel: 'string',
      description: 'string',
      snapshotId: 'string',
      size: 'number',
      device: 'string',
      diskName: 'string',
      category: 'string',
      KMSKeyId: 'string',
      deleteWithInstance: 'boolean',
      encryptAlgorithm: 'string',
      encrypted: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateInstanceRequestArn extends $tea.Model {
  roleType?: string;
  rolearn?: string;
  assumeRoleFor?: number;
  static names(): { [key: string]: string } {
    return {
      roleType: 'RoleType',
      rolearn: 'Rolearn',
      assumeRoleFor: 'AssumeRoleFor',
    };
  }

  static types(): { [key: string]: any } {
    return {
      roleType: 'string',
      rolearn: 'string',
      assumeRoleFor: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateInstanceRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateKeyPairRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLaunchTemplateRequestSystemDisk extends $tea.Model {
  category?: string;
  size?: number;
  diskName?: string;
  description?: string;
  iops?: number;
  static names(): { [key: string]: string } {
    return {
      category: 'Category',
      size: 'Size',
      diskName: 'DiskName',
      description: 'Description',
      iops: 'Iops',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
      size: 'number',
      diskName: 'string',
      description: 'string',
      iops: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLaunchTemplateRequestTemplateTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLaunchTemplateRequestDataDisk extends $tea.Model {
  description?: string;
  snapshotId?: string;
  size?: number;
  device?: string;
  diskName?: string;
  category?: string;
  deleteWithInstance?: boolean;
  encrypted?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      snapshotId: 'SnapshotId',
      size: 'Size',
      device: 'Device',
      diskName: 'DiskName',
      category: 'Category',
      deleteWithInstance: 'DeleteWithInstance',
      encrypted: 'Encrypted',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      snapshotId: 'string',
      size: 'number',
      device: 'string',
      diskName: 'string',
      category: 'string',
      deleteWithInstance: 'boolean',
      encrypted: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLaunchTemplateRequestNetworkInterface extends $tea.Model {
  networkInterfaceName?: string;
  vSwitchId?: string;
  description?: string;
  securityGroupId?: string;
  primaryIpAddress?: string;
  static names(): { [key: string]: string } {
    return {
      networkInterfaceName: 'NetworkInterfaceName',
      vSwitchId: 'VSwitchId',
      description: 'Description',
      securityGroupId: 'SecurityGroupId',
      primaryIpAddress: 'PrimaryIpAddress',
    };
  }

  static types(): { [key: string]: any } {
    return {
      networkInterfaceName: 'string',
      vSwitchId: 'string',
      description: 'string',
      securityGroupId: 'string',
      primaryIpAddress: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLaunchTemplateRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLaunchTemplateVersionRequestSystemDisk extends $tea.Model {
  category?: string;
  size?: number;
  diskName?: string;
  description?: string;
  iops?: number;
  static names(): { [key: string]: string } {
    return {
      category: 'Category',
      size: 'Size',
      diskName: 'DiskName',
      description: 'Description',
      iops: 'Iops',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
      size: 'number',
      diskName: 'string',
      description: 'string',
      iops: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLaunchTemplateVersionRequestDataDisk extends $tea.Model {
  description?: string;
  snapshotId?: string;
  size?: number;
  device?: string;
  diskName?: string;
  category?: string;
  deleteWithInstance?: boolean;
  encrypted?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      snapshotId: 'SnapshotId',
      size: 'Size',
      device: 'Device',
      diskName: 'DiskName',
      category: 'Category',
      deleteWithInstance: 'DeleteWithInstance',
      encrypted: 'Encrypted',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      snapshotId: 'string',
      size: 'number',
      device: 'string',
      diskName: 'string',
      category: 'string',
      deleteWithInstance: 'boolean',
      encrypted: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLaunchTemplateVersionRequestNetworkInterface extends $tea.Model {
  networkInterfaceName?: string;
  vSwitchId?: string;
  description?: string;
  securityGroupId?: string;
  primaryIpAddress?: string;
  static names(): { [key: string]: string } {
    return {
      networkInterfaceName: 'NetworkInterfaceName',
      vSwitchId: 'VSwitchId',
      description: 'Description',
      securityGroupId: 'SecurityGroupId',
      primaryIpAddress: 'PrimaryIpAddress',
    };
  }

  static types(): { [key: string]: any } {
    return {
      networkInterfaceName: 'string',
      vSwitchId: 'string',
      description: 'string',
      securityGroupId: 'string',
      primaryIpAddress: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLaunchTemplateVersionRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateNatGatewayRequestBandwidthPackage extends $tea.Model {
  bandwidth?: number;
  zone?: string;
  ipCount?: number;
  static names(): { [key: string]: string } {
    return {
      bandwidth: 'Bandwidth',
      zone: 'Zone',
      ipCount: 'IpCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bandwidth: 'number',
      zone: 'string',
      ipCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateNetworkInterfaceRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateNetworkInterfaceResponseBodyTags extends $tea.Model {
  tagValue?: string;
  tagKey?: string;
  static names(): { [key: string]: string } {
    return {
      tagValue: 'TagValue',
      tagKey: 'TagKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagValue: 'string',
      tagKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateNetworkInterfaceResponseBodyPrivateIpSets extends $tea.Model {
  primary?: boolean;
  privateIpAddress?: string;
  static names(): { [key: string]: string } {
    return {
      primary: 'Primary',
      privateIpAddress: 'PrivateIpAddress',
    };
  }

  static types(): { [key: string]: any } {
    return {
      primary: 'boolean',
      privateIpAddress: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateNetworkInterfacePermissionResponseBodyNetworkInterfacePermission extends $tea.Model {
  permission?: string;
  networkInterfaceId?: string;
  accountId?: number;
  networkInterfacePermissionId?: string;
  serviceName?: string;
  permissionState?: string;
  static names(): { [key: string]: string } {
    return {
      permission: 'Permission',
      networkInterfaceId: 'NetworkInterfaceId',
      accountId: 'AccountId',
      networkInterfacePermissionId: 'NetworkInterfacePermissionId',
      serviceName: 'ServiceName',
      permissionState: 'PermissionState',
    };
  }

  static types(): { [key: string]: any } {
    return {
      permission: 'string',
      networkInterfaceId: 'string',
      accountId: 'number',
      networkInterfacePermissionId: 'string',
      serviceName: 'string',
      permissionState: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateResource02RequestFilter extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRouteEntryRequestNextHopList extends $tea.Model {
  nextHopId?: string;
  nextHopType?: string;
  static names(): { [key: string]: string } {
    return {
      nextHopId: 'NextHopId',
      nextHopType: 'NextHopType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nextHopId: 'string',
      nextHopType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSecurityGroupRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSnapshotRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRouteEntryRequestNextHopList extends $tea.Model {
  nextHopId?: string;
  nextHopType?: string;
  static names(): { [key: string]: string } {
    return {
      nextHopId: 'NextHopId',
      nextHopType: 'NextHopType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nextHopId: 'string',
      nextHopType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAccessPointsRequestFilter extends $tea.Model {
  key?: string;
  value?: string[];
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAccessPointsResponseBodyAccessPointSet extends $tea.Model {
  status?: string;
  type?: string;
  hostOperator?: string;
  description?: string;
  attachedRegionNo?: string;
  name?: string;
  accessPointId?: string;
  location?: string;
  static names(): { [key: string]: string } {
    return {
      status: 'Status',
      type: 'Type',
      hostOperator: 'HostOperator',
      description: 'Description',
      attachedRegionNo: 'AttachedRegionNo',
      name: 'Name',
      accessPointId: 'AccessPointId',
      location: 'Location',
    };
  }

  static types(): { [key: string]: any } {
    return {
      status: 'string',
      type: 'string',
      hostOperator: 'string',
      description: 'string',
      attachedRegionNo: 'string',
      name: 'string',
      accessPointId: 'string',
      location: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAccountAttributesResponseBodyAccountAttributeItemsAttributeValues extends $tea.Model {
  diskCategory?: string;
  value?: string;
  expiredTime?: string;
  zoneId?: string;
  instanceType?: string;
  count?: number;
  instanceChargeType?: string;
  static names(): { [key: string]: string } {
    return {
      diskCategory: 'DiskCategory',
      value: 'Value',
      expiredTime: 'ExpiredTime',
      zoneId: 'ZoneId',
      instanceType: 'InstanceType',
      count: 'Count',
      instanceChargeType: 'InstanceChargeType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      diskCategory: 'string',
      value: 'string',
      expiredTime: 'string',
      zoneId: 'string',
      instanceType: 'string',
      count: 'number',
      instanceChargeType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAccountAttributesResponseBodyAccountAttributeItems extends $tea.Model {
  attributeName?: string;
  attributeValues?: DescribeAccountAttributesResponseBodyAccountAttributeItemsAttributeValues[];
  static names(): { [key: string]: string } {
    return {
      attributeName: 'AttributeName',
      attributeValues: 'AttributeValues',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attributeName: 'string',
      attributeValues: { 'type': 'array', 'itemType': DescribeAccountAttributesResponseBodyAccountAttributeItemsAttributeValues },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAutoProvisioningGroupHistoryResponseBodyAutoProvisioningGroupHistoriesActivityDetails extends $tea.Model {
  status?: string;
  detail?: string;
  static names(): { [key: string]: string } {
    return {
      status: 'Status',
      detail: 'Detail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      status: 'string',
      detail: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAutoProvisioningGroupHistoryResponseBodyAutoProvisioningGroupHistories extends $tea.Model {
  status?: string;
  startTime?: string;
  activityDetails?: DescribeAutoProvisioningGroupHistoryResponseBodyAutoProvisioningGroupHistoriesActivityDetails[];
  taskId?: string;
  lastEventTime?: string;
  static names(): { [key: string]: string } {
    return {
      status: 'Status',
      startTime: 'StartTime',
      activityDetails: 'ActivityDetails',
      taskId: 'TaskId',
      lastEventTime: 'LastEventTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      status: 'string',
      startTime: 'string',
      activityDetails: { 'type': 'array', 'itemType': DescribeAutoProvisioningGroupHistoryResponseBodyAutoProvisioningGroupHistoriesActivityDetails },
      taskId: 'string',
      lastEventTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAutoProvisioningGroupInstancesResponseBodyInstances extends $tea.Model {
  creationTime?: string;
  status?: string;
  isSpot?: boolean;
  CPU?: number;
  networkType?: string;
  instanceId?: string;
  instanceType?: string;
  regionId?: string;
  ioOptimized?: boolean;
  osType?: string;
  zoneId?: string;
  memory?: number;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      status: 'Status',
      isSpot: 'IsSpot',
      CPU: 'CPU',
      networkType: 'NetworkType',
      instanceId: 'InstanceId',
      instanceType: 'InstanceType',
      regionId: 'RegionId',
      ioOptimized: 'IoOptimized',
      osType: 'OsType',
      zoneId: 'ZoneId',
      memory: 'Memory',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      status: 'string',
      isSpot: 'boolean',
      CPU: 'number',
      networkType: 'string',
      instanceId: 'string',
      instanceType: 'string',
      regionId: 'string',
      ioOptimized: 'boolean',
      osType: 'string',
      zoneId: 'string',
      memory: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsPayAsYouGoOptions extends $tea.Model {
  allocationStrategy?: string;
  static names(): { [key: string]: string } {
    return {
      allocationStrategy: 'AllocationStrategy',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allocationStrategy: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsTargetCapacitySpecification extends $tea.Model {
  spotTargetCapacity?: number;
  defaultTargetCapacityType?: string;
  totalTargetCapacity?: number;
  payAsYouGoTargetCapacity?: number;
  static names(): { [key: string]: string } {
    return {
      spotTargetCapacity: 'SpotTargetCapacity',
      defaultTargetCapacityType: 'DefaultTargetCapacityType',
      totalTargetCapacity: 'TotalTargetCapacity',
      payAsYouGoTargetCapacity: 'PayAsYouGoTargetCapacity',
    };
  }

  static types(): { [key: string]: any } {
    return {
      spotTargetCapacity: 'number',
      defaultTargetCapacityType: 'string',
      totalTargetCapacity: 'number',
      payAsYouGoTargetCapacity: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsSpotOptions extends $tea.Model {
  instancePoolsToUseCount?: number;
  instanceInterruptionBehavior?: string;
  allocationStrategy?: string;
  static names(): { [key: string]: string } {
    return {
      instancePoolsToUseCount: 'InstancePoolsToUseCount',
      instanceInterruptionBehavior: 'InstanceInterruptionBehavior',
      allocationStrategy: 'AllocationStrategy',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instancePoolsToUseCount: 'number',
      instanceInterruptionBehavior: 'string',
      allocationStrategy: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsLaunchTemplateConfigs extends $tea.Model {
  vSwitchId?: string;
  maxPrice?: number;
  priority?: number;
  weightedCapacity?: number;
  instanceType?: string;
  static names(): { [key: string]: string } {
    return {
      vSwitchId: 'VSwitchId',
      maxPrice: 'MaxPrice',
      priority: 'Priority',
      weightedCapacity: 'WeightedCapacity',
      instanceType: 'InstanceType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      vSwitchId: 'string',
      maxPrice: 'number',
      priority: 'number',
      weightedCapacity: 'number',
      instanceType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroups extends $tea.Model {
  status?: string;
  autoProvisioningGroupName?: string;
  creationTime?: string;
  maxSpotPrice?: number;
  terminateInstances?: boolean;
  launchTemplateId?: string;
  state?: string;
  validFrom?: string;
  launchTemplateVersion?: string;
  validUntil?: string;
  regionId?: string;
  terminateInstancesWithExpiration?: boolean;
  autoProvisioningGroupType?: string;
  autoProvisioningGroupId?: string;
  payAsYouGoOptions?: DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsPayAsYouGoOptions;
  targetCapacitySpecification?: DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsTargetCapacitySpecification;
  spotOptions?: DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsSpotOptions;
  launchTemplateConfigs?: DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsLaunchTemplateConfigs[];
  excessCapacityTerminationPolicy?: string;
  static names(): { [key: string]: string } {
    return {
      status: 'Status',
      autoProvisioningGroupName: 'AutoProvisioningGroupName',
      creationTime: 'CreationTime',
      maxSpotPrice: 'MaxSpotPrice',
      terminateInstances: 'TerminateInstances',
      launchTemplateId: 'LaunchTemplateId',
      state: 'State',
      validFrom: 'ValidFrom',
      launchTemplateVersion: 'LaunchTemplateVersion',
      validUntil: 'ValidUntil',
      regionId: 'RegionId',
      terminateInstancesWithExpiration: 'TerminateInstancesWithExpiration',
      autoProvisioningGroupType: 'AutoProvisioningGroupType',
      autoProvisioningGroupId: 'AutoProvisioningGroupId',
      payAsYouGoOptions: 'PayAsYouGoOptions',
      targetCapacitySpecification: 'TargetCapacitySpecification',
      spotOptions: 'SpotOptions',
      launchTemplateConfigs: 'LaunchTemplateConfigs',
      excessCapacityTerminationPolicy: 'ExcessCapacityTerminationPolicy',
    };
  }

  static types(): { [key: string]: any } {
    return {
      status: 'string',
      autoProvisioningGroupName: 'string',
      creationTime: 'string',
      maxSpotPrice: 'number',
      terminateInstances: 'boolean',
      launchTemplateId: 'string',
      state: 'string',
      validFrom: 'string',
      launchTemplateVersion: 'string',
      validUntil: 'string',
      regionId: 'string',
      terminateInstancesWithExpiration: 'boolean',
      autoProvisioningGroupType: 'string',
      autoProvisioningGroupId: 'string',
      payAsYouGoOptions: DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsPayAsYouGoOptions,
      targetCapacitySpecification: DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsTargetCapacitySpecification,
      spotOptions: DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsSpotOptions,
      launchTemplateConfigs: { 'type': 'array', 'itemType': DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsLaunchTemplateConfigs },
      excessCapacityTerminationPolicy: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAutoSnapshotPolicyExRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAutoSnapshotPolicyExResponseBodyAutoSnapshotPoliciesTags extends $tea.Model {
  tagValue?: string;
  tagKey?: string;
  static names(): { [key: string]: string } {
    return {
      tagValue: 'TagValue',
      tagKey: 'TagKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagValue: 'string',
      tagKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAutoSnapshotPolicyExResponseBodyAutoSnapshotPolicies extends $tea.Model {
  status?: string;
  creationTime?: string;
  timePoints?: string;
  autoSnapshotPolicyName?: string;
  targetCopyRegions?: string;
  copiedSnapshotsRetentionDays?: number;
  autoSnapshotPolicyId?: string;
  tags?: DescribeAutoSnapshotPolicyExResponseBodyAutoSnapshotPoliciesTags[];
  retentionDays?: number;
  regionId?: string;
  diskNums?: number;
  enableCrossRegionCopy?: boolean;
  repeatWeekdays?: string;
  volumeNums?: number;
  static names(): { [key: string]: string } {
    return {
      status: 'Status',
      creationTime: 'CreationTime',
      timePoints: 'TimePoints',
      autoSnapshotPolicyName: 'AutoSnapshotPolicyName',
      targetCopyRegions: 'TargetCopyRegions',
      copiedSnapshotsRetentionDays: 'CopiedSnapshotsRetentionDays',
      autoSnapshotPolicyId: 'AutoSnapshotPolicyId',
      tags: 'Tags',
      retentionDays: 'RetentionDays',
      regionId: 'RegionId',
      diskNums: 'DiskNums',
      enableCrossRegionCopy: 'EnableCrossRegionCopy',
      repeatWeekdays: 'RepeatWeekdays',
      volumeNums: 'VolumeNums',
    };
  }

  static types(): { [key: string]: any } {
    return {
      status: 'string',
      creationTime: 'string',
      timePoints: 'string',
      autoSnapshotPolicyName: 'string',
      targetCopyRegions: 'string',
      copiedSnapshotsRetentionDays: 'number',
      autoSnapshotPolicyId: 'string',
      tags: { 'type': 'array', 'itemType': DescribeAutoSnapshotPolicyExResponseBodyAutoSnapshotPoliciesTags },
      retentionDays: 'number',
      regionId: 'string',
      diskNums: 'number',
      enableCrossRegionCopy: 'boolean',
      repeatWeekdays: 'string',
      volumeNums: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAvailableResourceResponseBodyAvailableZonesAvailableResourcesSupportedResources extends $tea.Model {
  status?: string;
  value?: string;
  max?: number;
  unit?: string;
  statusCategory?: string;
  min?: number;
  static names(): { [key: string]: string } {
    return {
      status: 'Status',
      value: 'Value',
      max: 'Max',
      unit: 'Unit',
      statusCategory: 'StatusCategory',
      min: 'Min',
    };
  }

  static types(): { [key: string]: any } {
    return {
      status: 'string',
      value: 'string',
      max: 'number',
      unit: 'string',
      statusCategory: 'string',
      min: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAvailableResourceResponseBodyAvailableZonesAvailableResources extends $tea.Model {
  type?: string;
  supportedResources?: DescribeAvailableResourceResponseBodyAvailableZonesAvailableResourcesSupportedResources[];
  static names(): { [key: string]: string } {
    return {
      type: 'Type',
      supportedResources: 'SupportedResources',
    };
  }

  static types(): { [key: string]: any } {
    return {
      type: 'string',
      supportedResources: { 'type': 'array', 'itemType': DescribeAvailableResourceResponseBodyAvailableZonesAvailableResourcesSupportedResources },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAvailableResourceResponseBodyAvailableZones extends $tea.Model {
  status?: string;
  zoneId?: string;
  statusCategory?: string;
  regionId?: string;
  availableResources?: DescribeAvailableResourceResponseBodyAvailableZonesAvailableResources[];
  static names(): { [key: string]: string } {
    return {
      status: 'Status',
      zoneId: 'ZoneId',
      statusCategory: 'StatusCategory',
      regionId: 'RegionId',
      availableResources: 'AvailableResources',
    };
  }

  static types(): { [key: string]: any } {
    return {
      status: 'string',
      zoneId: 'string',
      statusCategory: 'string',
      regionId: 'string',
      availableResources: { 'type': 'array', 'itemType': DescribeAvailableResourceResponseBodyAvailableZonesAvailableResources },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBandwidthLimitationResponseBodyBandwidths extends $tea.Model {
  max?: number;
  unit?: string;
  internetChargeType?: string;
  min?: number;
  static names(): { [key: string]: string } {
    return {
      max: 'Max',
      unit: 'Unit',
      internetChargeType: 'InternetChargeType',
      min: 'Min',
    };
  }

  static types(): { [key: string]: any } {
    return {
      max: 'number',
      unit: 'string',
      internetChargeType: 'string',
      min: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBandwidthPackagesResponseBodyBandwidthPackagesPublicIpAddresses extends $tea.Model {
  ipAddress?: string;
  allocationId?: string;
  static names(): { [key: string]: string } {
    return {
      ipAddress: 'IpAddress',
      allocationId: 'AllocationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ipAddress: 'string',
      allocationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBandwidthPackagesResponseBodyBandwidthPackages extends $tea.Model {
  publicIpAddresses?: DescribeBandwidthPackagesResponseBodyBandwidthPackagesPublicIpAddresses[];
  creationTime?: string;
  status?: string;
  ipCount?: string;
  instanceChargeType?: string;
  regionId?: string;
  bandwidthPackageId?: string;
  bandwidth?: string;
  description?: string;
  natGatewayId?: string;
  internetChargeType?: string;
  zoneId?: string;
  businessStatus?: string;
  name?: string;
  ISP?: string;
  static names(): { [key: string]: string } {
    return {
      publicIpAddresses: 'PublicIpAddresses',
      creationTime: 'CreationTime',
      status: 'Status',
      ipCount: 'IpCount',
      instanceChargeType: 'InstanceChargeType',
      regionId: 'RegionId',
      bandwidthPackageId: 'BandwidthPackageId',
      bandwidth: 'Bandwidth',
      description: 'Description',
      natGatewayId: 'NatGatewayId',
      internetChargeType: 'InternetChargeType',
      zoneId: 'ZoneId',
      businessStatus: 'BusinessStatus',
      name: 'Name',
      ISP: 'ISP',
    };
  }

  static types(): { [key: string]: any } {
    return {
      publicIpAddresses: { 'type': 'array', 'itemType': DescribeBandwidthPackagesResponseBodyBandwidthPackagesPublicIpAddresses },
      creationTime: 'string',
      status: 'string',
      ipCount: 'string',
      instanceChargeType: 'string',
      regionId: 'string',
      bandwidthPackageId: 'string',
      bandwidth: 'string',
      description: 'string',
      natGatewayId: 'string',
      internetChargeType: 'string',
      zoneId: 'string',
      businessStatus: 'string',
      name: 'string',
      ISP: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCapacityReservationInstancesRequestPrivatePoolOptions extends $tea.Model {
  id?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCapacityReservationInstancesResponseBodyCapacityReservationItem extends $tea.Model {
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCapacityReservationsRequestPrivatePoolOptions extends $tea.Model {
  ids?: string;
  static names(): { [key: string]: string } {
    return {
      ids: 'Ids',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ids: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCapacityReservationsResponseBodyCapacityReservationSetAllocatedResources extends $tea.Model {
  zoneId?: string;
  usedAmount?: number;
  totalAmount?: number;
  instanceType?: string;
  static names(): { [key: string]: string } {
    return {
      zoneId: 'zoneId',
      usedAmount: 'UsedAmount',
      totalAmount: 'TotalAmount',
      instanceType: 'InstanceType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      zoneId: 'string',
      usedAmount: 'number',
      totalAmount: 'number',
      instanceType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCapacityReservationsResponseBodyCapacityReservationSet extends $tea.Model {
  status?: string;
  timeSlot?: string;
  privatePoolOptionsMatchCriteria?: string;
  privatePoolOptionsId?: string;
  allocatedResources?: DescribeCapacityReservationsResponseBodyCapacityReservationSetAllocatedResources[];
  privatePoolOptionsName?: string;
  instanceChargeType?: string;
  regionId?: string;
  endTime?: string;
  startTime?: string;
  description?: string;
  endTimeType?: string;
  platform?: string;
  static names(): { [key: string]: string } {
    return {
      status: 'Status',
      timeSlot: 'TimeSlot',
      privatePoolOptionsMatchCriteria: 'PrivatePoolOptionsMatchCriteria',
      privatePoolOptionsId: 'PrivatePoolOptionsId',
      allocatedResources: 'AllocatedResources',
      privatePoolOptionsName: 'PrivatePoolOptionsName',
      instanceChargeType: 'InstanceChargeType',
      regionId: 'RegionId',
      endTime: 'EndTime',
      startTime: 'StartTime',
      description: 'Description',
      endTimeType: 'EndTimeType',
      platform: 'Platform',
    };
  }

  static types(): { [key: string]: any } {
    return {
      status: 'string',
      timeSlot: 'string',
      privatePoolOptionsMatchCriteria: 'string',
      privatePoolOptionsId: 'string',
      allocatedResources: { 'type': 'array', 'itemType': DescribeCapacityReservationsResponseBodyCapacityReservationSetAllocatedResources },
      privatePoolOptionsName: 'string',
      instanceChargeType: 'string',
      regionId: 'string',
      endTime: 'string',
      startTime: 'string',
      description: 'string',
      endTimeType: 'string',
      platform: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClassicLinkInstancesResponseBodyLinks extends $tea.Model {
  vpcId?: string;
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      vpcId: 'VpcId',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      vpcId: 'string',
      instanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudAssistantStatusResponseBodyInstanceCloudAssistantStatusSet extends $tea.Model {
  cloudAssistantStatus?: string;
  cloudAssistantVersion?: string;
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      cloudAssistantStatus: 'CloudAssistantStatus',
      cloudAssistantVersion: 'CloudAssistantVersion',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cloudAssistantStatus: 'string',
      cloudAssistantVersion: 'string',
      instanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClustersResponseBodyClusters extends $tea.Model {
  clusterId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCommandsResponseBodyCommands extends $tea.Model {
  creationTime?: string;
  timeout?: number;
  type?: string;
  parameterNames?: string[];
  invokeTimes?: number;
  workingDir?: string;
  description?: string;
  commandContent?: string;
  commandId?: string;
  name?: string;
  enableParameter?: boolean;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      timeout: 'Timeout',
      type: 'Type',
      parameterNames: 'ParameterNames',
      invokeTimes: 'InvokeTimes',
      workingDir: 'WorkingDir',
      description: 'Description',
      commandContent: 'CommandContent',
      commandId: 'CommandId',
      name: 'Name',
      enableParameter: 'EnableParameter',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      timeout: 'number',
      type: 'string',
      parameterNames: { 'type': 'array', 'itemType': 'string' },
      invokeTimes: 'number',
      workingDir: 'string',
      description: 'string',
      commandContent: 'string',
      commandId: 'string',
      name: 'string',
      enableParameter: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDedicatedHostAutoRenewResponseBodyDedicatedHostRenewAttributes extends $tea.Model {
  periodUnit?: string;
  duration?: number;
  dedicatedHostId?: string;
  renewalStatus?: string;
  autoRenewEnabled?: boolean;
  static names(): { [key: string]: string } {
    return {
      periodUnit: 'PeriodUnit',
      duration: 'Duration',
      dedicatedHostId: 'DedicatedHostId',
      renewalStatus: 'RenewalStatus',
      autoRenewEnabled: 'AutoRenewEnabled',
    };
  }

  static types(): { [key: string]: any } {
    return {
      periodUnit: 'string',
      duration: 'number',
      dedicatedHostId: 'string',
      renewalStatus: 'string',
      autoRenewEnabled: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDedicatedHostClustersRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersTags extends $tea.Model {
  tagValue?: string;
  tagKey?: string;
  static names(): { [key: string]: string } {
    return {
      tagValue: 'TagValue',
      tagKey: 'TagKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagValue: 'string',
      tagKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterCapacityLocalStorageCapacities extends $tea.Model {
  dataDiskCategory?: string;
  availableDisk?: number;
  totalDisk?: number;
  static names(): { [key: string]: string } {
    return {
      dataDiskCategory: 'DataDiskCategory',
      availableDisk: 'AvailableDisk',
      totalDisk: 'TotalDisk',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataDiskCategory: 'string',
      availableDisk: 'number',
      totalDisk: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterCapacity extends $tea.Model {
  localStorageCapacities?: DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterCapacityLocalStorageCapacities[];
  availableMemory?: number;
  totalMemory?: number;
  totalVcpus?: number;
  availableVcpus?: number;
  static names(): { [key: string]: string } {
    return {
      localStorageCapacities: 'LocalStorageCapacities',
      availableMemory: 'AvailableMemory',
      totalMemory: 'TotalMemory',
      totalVcpus: 'TotalVcpus',
      availableVcpus: 'AvailableVcpus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      localStorageCapacities: { 'type': 'array', 'itemType': DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterCapacityLocalStorageCapacities },
      availableMemory: 'number',
      totalMemory: 'number',
      totalVcpus: 'number',
      availableVcpus: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDedicatedHostClustersResponseBodyDedicatedHostClusters extends $tea.Model {
  description?: string;
  dedicatedHostClusterId?: string;
  resourceGroupId?: string;
  zoneId?: string;
  tags?: DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersTags[];
  dedicatedHostClusterCapacity?: DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterCapacity;
  dedicatedHostIds?: string[];
  regionId?: string;
  dedicatedHostClusterName?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      dedicatedHostClusterId: 'DedicatedHostClusterId',
      resourceGroupId: 'ResourceGroupId',
      zoneId: 'ZoneId',
      tags: 'Tags',
      dedicatedHostClusterCapacity: 'DedicatedHostClusterCapacity',
      dedicatedHostIds: 'DedicatedHostIds',
      regionId: 'RegionId',
      dedicatedHostClusterName: 'DedicatedHostClusterName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      dedicatedHostClusterId: 'string',
      resourceGroupId: 'string',
      zoneId: 'string',
      tags: { 'type': 'array', 'itemType': DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersTags },
      dedicatedHostClusterCapacity: DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterCapacity,
      dedicatedHostIds: { 'type': 'array', 'itemType': 'string' },
      regionId: 'string',
      dedicatedHostClusterName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDedicatedHostsRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDedicatedHostsResponseBodyDedicatedHostsCapacity extends $tea.Model {
  availableMemory?: number;
  localStorageCategory?: string;
  totalMemory?: number;
  totalLocalStorage?: number;
  totalVcpus?: number;
  totalVgpus?: number;
  availableLocalStorage?: number;
  availableVcpus?: number;
  availableVgpus?: number;
  static names(): { [key: string]: string } {
    return {
      availableMemory: 'AvailableMemory',
      localStorageCategory: 'LocalStorageCategory',
      totalMemory: 'TotalMemory',
      totalLocalStorage: 'TotalLocalStorage',
      totalVcpus: 'TotalVcpus',
      totalVgpus: 'TotalVgpus',
      availableLocalStorage: 'AvailableLocalStorage',
      availableVcpus: 'AvailableVcpus',
      availableVgpus: 'AvailableVgpus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      availableMemory: 'number',
      localStorageCategory: 'string',
      totalMemory: 'number',
      totalLocalStorage: 'number',
      totalVcpus: 'number',
      totalVgpus: 'number',
      availableLocalStorage: 'number',
      availableVcpus: 'number',
      availableVgpus: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDedicatedHostsResponseBodyDedicatedHostsOperationLocks extends $tea.Model {
  lockReason?: string;
  static names(): { [key: string]: string } {
    return {
      lockReason: 'LockReason',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lockReason: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDedicatedHostsResponseBodyDedicatedHostsTags extends $tea.Model {
  tagValue?: string;
  tagKey?: string;
  static names(): { [key: string]: string } {
    return {
      tagValue: 'TagValue',
      tagKey: 'TagKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagValue: 'string',
      tagKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDedicatedHostsResponseBodyDedicatedHostsInstances extends $tea.Model {
  instanceId?: string;
  instanceType?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      instanceType: 'InstanceType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      instanceType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDedicatedHostsResponseBodyDedicatedHostsNetworkAttributes extends $tea.Model {
  udpTimeout?: number;
  slbUdpTimeout?: number;
  static names(): { [key: string]: string } {
    return {
      udpTimeout: 'UdpTimeout',
      slbUdpTimeout: 'SlbUdpTimeout',
    };
  }

  static types(): { [key: string]: any } {
    return {
      udpTimeout: 'number',
      slbUdpTimeout: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDedicatedHostsResponseBodyDedicatedHosts extends $tea.Model {
  status?: string;
  creationTime?: string;
  capacity?: DescribeDedicatedHostsResponseBodyDedicatedHostsCapacity;
  autoPlacement?: string;
  operationLocks?: DescribeDedicatedHostsResponseBodyDedicatedHostsOperationLocks[];
  chargeType?: string;
  tags?: DescribeDedicatedHostsResponseBodyDedicatedHostsTags[];
  actionOnMaintenance?: string;
  physicalGpus?: number;
  saleCycle?: string;
  description?: string;
  dedicatedHostType?: string;
  dedicatedHostId?: string;
  sockets?: number;
  cores?: number;
  GPUSpec?: string;
  autoReleaseTime?: string;
  cpuOverCommitRatio?: number;
  supportedInstanceTypesList?: string[];
  supportedCustomInstanceTypeFamilies?: string[];
  instances?: DescribeDedicatedHostsResponseBodyDedicatedHostsInstances[];
  regionId?: string;
  networkAttributes?: DescribeDedicatedHostsResponseBodyDedicatedHostsNetworkAttributes;
  dedicatedHostName?: string;
  expiredTime?: string;
  dedicatedHostClusterId?: string;
  resourceGroupId?: string;
  zoneId?: string;
  supportedInstanceTypeFamilies?: string[];
  machineId?: string;
  static names(): { [key: string]: string } {
    return {
      status: 'Status',
      creationTime: 'CreationTime',
      capacity: 'Capacity',
      autoPlacement: 'AutoPlacement',
      operationLocks: 'OperationLocks',
      chargeType: 'ChargeType',
      tags: 'Tags',
      actionOnMaintenance: 'ActionOnMaintenance',
      physicalGpus: 'PhysicalGpus',
      saleCycle: 'SaleCycle',
      description: 'Description',
      dedicatedHostType: 'DedicatedHostType',
      dedicatedHostId: 'DedicatedHostId',
      sockets: 'Sockets',
      cores: 'Cores',
      GPUSpec: 'GPUSpec',
      autoReleaseTime: 'AutoReleaseTime',
      cpuOverCommitRatio: 'CpuOverCommitRatio',
      supportedInstanceTypesList: 'SupportedInstanceTypesList',
      supportedCustomInstanceTypeFamilies: 'SupportedCustomInstanceTypeFamilies',
      instances: 'Instances',
      regionId: 'RegionId',
      networkAttributes: 'NetworkAttributes',
      dedicatedHostName: 'DedicatedHostName',
      expiredTime: 'ExpiredTime',
      dedicatedHostClusterId: 'DedicatedHostClusterId',
      resourceGroupId: 'ResourceGroupId',
      zoneId: 'ZoneId',
      supportedInstanceTypeFamilies: 'SupportedInstanceTypeFamilies',
      machineId: 'MachineId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      status: 'string',
      creationTime: 'string',
      capacity: DescribeDedicatedHostsResponseBodyDedicatedHostsCapacity,
      autoPlacement: 'string',
      operationLocks: { 'type': 'array', 'itemType': DescribeDedicatedHostsResponseBodyDedicatedHostsOperationLocks },
      chargeType: 'string',
      tags: { 'type': 'array', 'itemType': DescribeDedicatedHostsResponseBodyDedicatedHostsTags },
      actionOnMaintenance: 'string',
      physicalGpus: 'number',
      saleCycle: 'string',
      description: 'string',
      dedicatedHostType: 'string',
      dedicatedHostId: 'string',
      sockets: 'number',
      cores: 'number',
      GPUSpec: 'string',
      autoReleaseTime: 'string',
      cpuOverCommitRatio: 'number',
      supportedInstanceTypesList: { 'type': 'array', 'itemType': 'string' },
      supportedCustomInstanceTypeFamilies: { 'type': 'array', 'itemType': 'string' },
      instances: { 'type': 'array', 'itemType': DescribeDedicatedHostsResponseBodyDedicatedHostsInstances },
      regionId: 'string',
      networkAttributes: DescribeDedicatedHostsResponseBodyDedicatedHostsNetworkAttributes,
      dedicatedHostName: 'string',
      expiredTime: 'string',
      dedicatedHostClusterId: 'string',
      resourceGroupId: 'string',
      zoneId: 'string',
      supportedInstanceTypeFamilies: { 'type': 'array', 'itemType': 'string' },
      machineId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDedicatedHostTypesResponseBodyDedicatedHostTypes extends $tea.Model {
  cores?: number;
  GPUSpec?: string;
  localStorageCategory?: string;
  totalVcpus?: number;
  cpuOverCommitRatioRange?: string;
  supportedInstanceTypesList?: string[];
  physicalGpus?: number;
  memorySize?: number;
  supportCpuOverCommitRatio?: boolean;
  localStorageCapacity?: number;
  localStorageAmount?: number;
  dedicatedHostType?: string;
  totalVgpus?: number;
  sockets?: number;
  supportedInstanceTypeFamilies?: string[];
  static names(): { [key: string]: string } {
    return {
      cores: 'Cores',
      GPUSpec: 'GPUSpec',
      localStorageCategory: 'LocalStorageCategory',
      totalVcpus: 'TotalVcpus',
      cpuOverCommitRatioRange: 'CpuOverCommitRatioRange',
      supportedInstanceTypesList: 'SupportedInstanceTypesList',
      physicalGpus: 'PhysicalGpus',
      memorySize: 'MemorySize',
      supportCpuOverCommitRatio: 'SupportCpuOverCommitRatio',
      localStorageCapacity: 'LocalStorageCapacity',
      localStorageAmount: 'LocalStorageAmount',
      dedicatedHostType: 'DedicatedHostType',
      totalVgpus: 'TotalVgpus',
      sockets: 'Sockets',
      supportedInstanceTypeFamilies: 'SupportedInstanceTypeFamilies',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cores: 'number',
      GPUSpec: 'string',
      localStorageCategory: 'string',
      totalVcpus: 'number',
      cpuOverCommitRatioRange: 'string',
      supportedInstanceTypesList: { 'type': 'array', 'itemType': 'string' },
      physicalGpus: 'number',
      memorySize: 'number',
      supportCpuOverCommitRatio: 'boolean',
      localStorageCapacity: 'number',
      localStorageAmount: 'number',
      dedicatedHostType: 'string',
      totalVgpus: 'number',
      sockets: 'number',
      supportedInstanceTypeFamilies: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDemandsRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDemandsResponseBodyDemandsSupplyInfos extends $tea.Model {
  amount?: number;
  supplyEndTime?: string;
  supplyStatus?: string;
  supplyStartTime?: string;
  static names(): { [key: string]: string } {
    return {
      amount: 'Amount',
      supplyEndTime: 'SupplyEndTime',
      supplyStatus: 'SupplyStatus',
      supplyStartTime: 'SupplyStartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      amount: 'number',
      supplyEndTime: 'string',
      supplyStatus: 'string',
      supplyStartTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDemandsResponseBodyDemands extends $tea.Model {
  comment?: string;
  demandId?: string;
  demandDescription?: string;
  demandTime?: string;
  supplyInfos?: DescribeDemandsResponseBodyDemandsSupplyInfos[];
  demandName?: string;
  instanceType?: string;
  instanceChargeType?: string;
  period?: number;
  endTime?: string;
  availableAmount?: number;
  startTime?: string;
  periodUnit?: string;
  zoneId?: string;
  usedAmount?: number;
  totalAmount?: number;
  deliveringAmount?: number;
  instanceTypeFamily?: string;
  demandStatus?: string;
  static names(): { [key: string]: string } {
    return {
      comment: 'Comment',
      demandId: 'DemandId',
      demandDescription: 'DemandDescription',
      demandTime: 'DemandTime',
      supplyInfos: 'SupplyInfos',
      demandName: 'DemandName',
      instanceType: 'InstanceType',
      instanceChargeType: 'InstanceChargeType',
      period: 'Period',
      endTime: 'EndTime',
      availableAmount: 'AvailableAmount',
      startTime: 'StartTime',
      periodUnit: 'PeriodUnit',
      zoneId: 'ZoneId',
      usedAmount: 'UsedAmount',
      totalAmount: 'TotalAmount',
      deliveringAmount: 'DeliveringAmount',
      instanceTypeFamily: 'InstanceTypeFamily',
      demandStatus: 'DemandStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comment: 'string',
      demandId: 'string',
      demandDescription: 'string',
      demandTime: 'string',
      supplyInfos: { 'type': 'array', 'itemType': DescribeDemandsResponseBodyDemandsSupplyInfos },
      demandName: 'string',
      instanceType: 'string',
      instanceChargeType: 'string',
      period: 'number',
      endTime: 'string',
      availableAmount: 'number',
      startTime: 'string',
      periodUnit: 'string',
      zoneId: 'string',
      usedAmount: 'number',
      totalAmount: 'number',
      deliveringAmount: 'number',
      instanceTypeFamily: 'string',
      demandStatus: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDeploymentSetsResponseBodyDeploymentSets extends $tea.Model {
  creationTime?: string;
  strategy?: string;
  deploymentSetId?: string;
  deploymentStrategy?: string;
  deploymentSetDescription?: string;
  domain?: string;
  groupCount?: number;
  granularity?: string;
  instanceIds?: string[];
  deploymentSetName?: string;
  instanceAmount?: number;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      strategy: 'Strategy',
      deploymentSetId: 'DeploymentSetId',
      deploymentStrategy: 'DeploymentStrategy',
      deploymentSetDescription: 'DeploymentSetDescription',
      domain: 'Domain',
      groupCount: 'GroupCount',
      granularity: 'Granularity',
      instanceIds: 'InstanceIds',
      deploymentSetName: 'DeploymentSetName',
      instanceAmount: 'InstanceAmount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      strategy: 'string',
      deploymentSetId: 'string',
      deploymentStrategy: 'string',
      deploymentSetDescription: 'string',
      domain: 'string',
      groupCount: 'number',
      granularity: 'string',
      instanceIds: { 'type': 'array', 'itemType': 'string' },
      deploymentSetName: 'string',
      instanceAmount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDiskMonitorDataResponseBodyMonitorData extends $tea.Model {
  BPSRead?: number;
  IOPSRead?: number;
  latencyRead?: number;
  BPSTotal?: number;
  IOPSTotal?: number;
  timeStamp?: string;
  latencyWrite?: number;
  IOPSWrite?: number;
  diskId?: string;
  BPSWrite?: number;
  static names(): { [key: string]: string } {
    return {
      BPSRead: 'BPSRead',
      IOPSRead: 'IOPSRead',
      latencyRead: 'LatencyRead',
      BPSTotal: 'BPSTotal',
      IOPSTotal: 'IOPSTotal',
      timeStamp: 'TimeStamp',
      latencyWrite: 'LatencyWrite',
      IOPSWrite: 'IOPSWrite',
      diskId: 'DiskId',
      BPSWrite: 'BPSWrite',
    };
  }

  static types(): { [key: string]: any } {
    return {
      BPSRead: 'number',
      IOPSRead: 'number',
      latencyRead: 'number',
      BPSTotal: 'number',
      IOPSTotal: 'number',
      timeStamp: 'string',
      latencyWrite: 'number',
      IOPSWrite: 'number',
      diskId: 'string',
      BPSWrite: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDisksRequestFilter extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDisksRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDisksResponseBodyDisksOperationLocks extends $tea.Model {
  lockReason?: string;
  static names(): { [key: string]: string } {
    return {
      lockReason: 'LockReason',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lockReason: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDisksResponseBodyDisksTags extends $tea.Model {
  tagValue?: string;
  tagKey?: string;
  static names(): { [key: string]: string } {
    return {
      tagValue: 'TagValue',
      tagKey: 'TagKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagValue: 'string',
      tagKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDisksResponseBodyDisksMountInstances extends $tea.Model {
  device?: string;
  attachedTime?: string;
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      device: 'Device',
      attachedTime: 'AttachedTime',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      device: 'string',
      attachedTime: 'string',
      instanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDisksResponseBodyDisks extends $tea.Model {
  serialNumber?: string;
  creationTime?: string;
  status?: string;
  type?: string;
  performanceLevel?: string;
  operationLocks?: DescribeDisksResponseBodyDisksOperationLocks[];
  bdfId?: string;
  enableAutoSnapshot?: boolean;
  storageSetId?: string;
  tags?: DescribeDisksResponseBodyDisksTags[];
  storageSetPartitionNumber?: number;
  diskId?: string;
  mountInstances?: DescribeDisksResponseBodyDisksMountInstances[];
  deleteAutoSnapshot?: boolean;
  encrypted?: boolean;
  IOPSRead?: number;
  mountInstanceNum?: number;
  description?: string;
  device?: string;
  diskName?: string;
  portable?: boolean;
  imageId?: string;
  deleteWithInstance?: boolean;
  KMSKeyId?: string;
  detachedTime?: string;
  sourceSnapshotId?: string;
  autoSnapshotPolicyId?: string;
  enableAutomatedSnapshotPolicy?: boolean;
  IOPSWrite?: number;
  instanceId?: string;
  IOPS?: number;
  regionId?: string;
  expiredTime?: string;
  size?: number;
  resourceGroupId?: string;
  diskChargeType?: string;
  zoneId?: string;
  attachedTime?: string;
  category?: string;
  productCode?: string;
  static names(): { [key: string]: string } {
    return {
      serialNumber: 'SerialNumber',
      creationTime: 'CreationTime',
      status: 'Status',
      type: 'Type',
      performanceLevel: 'PerformanceLevel',
      operationLocks: 'OperationLocks',
      bdfId: 'BdfId',
      enableAutoSnapshot: 'EnableAutoSnapshot',
      storageSetId: 'StorageSetId',
      tags: 'Tags',
      storageSetPartitionNumber: 'StorageSetPartitionNumber',
      diskId: 'DiskId',
      mountInstances: 'MountInstances',
      deleteAutoSnapshot: 'DeleteAutoSnapshot',
      encrypted: 'Encrypted',
      IOPSRead: 'IOPSRead',
      mountInstanceNum: 'MountInstanceNum',
      description: 'Description',
      device: 'Device',
      diskName: 'DiskName',
      portable: 'Portable',
      imageId: 'ImageId',
      deleteWithInstance: 'DeleteWithInstance',
      KMSKeyId: 'KMSKeyId',
      detachedTime: 'DetachedTime',
      sourceSnapshotId: 'SourceSnapshotId',
      autoSnapshotPolicyId: 'AutoSnapshotPolicyId',
      enableAutomatedSnapshotPolicy: 'EnableAutomatedSnapshotPolicy',
      IOPSWrite: 'IOPSWrite',
      instanceId: 'InstanceId',
      IOPS: 'IOPS',
      regionId: 'RegionId',
      expiredTime: 'ExpiredTime',
      size: 'Size',
      resourceGroupId: 'ResourceGroupId',
      diskChargeType: 'DiskChargeType',
      zoneId: 'ZoneId',
      attachedTime: 'AttachedTime',
      category: 'Category',
      productCode: 'ProductCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      serialNumber: 'string',
      creationTime: 'string',
      status: 'string',
      type: 'string',
      performanceLevel: 'string',
      operationLocks: { 'type': 'array', 'itemType': DescribeDisksResponseBodyDisksOperationLocks },
      bdfId: 'string',
      enableAutoSnapshot: 'boolean',
      storageSetId: 'string',
      tags: { 'type': 'array', 'itemType': DescribeDisksResponseBodyDisksTags },
      storageSetPartitionNumber: 'number',
      diskId: 'string',
      mountInstances: { 'type': 'array', 'itemType': DescribeDisksResponseBodyDisksMountInstances },
      deleteAutoSnapshot: 'boolean',
      encrypted: 'boolean',
      IOPSRead: 'number',
      mountInstanceNum: 'number',
      description: 'string',
      device: 'string',
      diskName: 'string',
      portable: 'boolean',
      imageId: 'string',
      deleteWithInstance: 'boolean',
      KMSKeyId: 'string',
      detachedTime: 'string',
      sourceSnapshotId: 'string',
      autoSnapshotPolicyId: 'string',
      enableAutomatedSnapshotPolicy: 'boolean',
      IOPSWrite: 'number',
      instanceId: 'string',
      IOPS: 'number',
      regionId: 'string',
      expiredTime: 'string',
      size: 'number',
      resourceGroupId: 'string',
      diskChargeType: 'string',
      zoneId: 'string',
      attachedTime: 'string',
      category: 'string',
      productCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDisksFullStatusRequestEventTime extends $tea.Model {
  start?: string;
  end?: string;
  static names(): { [key: string]: string } {
    return {
      start: 'Start',
      end: 'End',
    };
  }

  static types(): { [key: string]: any } {
    return {
      start: 'string',
      end: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDisksFullStatusResponseBodyDiskFullStatusSetStatus extends $tea.Model {
  code?: number;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDisksFullStatusResponseBodyDiskFullStatusSetDiskEventSetEventType extends $tea.Model {
  code?: number;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDisksFullStatusResponseBodyDiskFullStatusSetDiskEventSet extends $tea.Model {
  eventId?: string;
  eventEndTime?: string;
  eventTime?: string;
  impactLevel?: string;
  eventType?: DescribeDisksFullStatusResponseBodyDiskFullStatusSetDiskEventSetEventType;
  static names(): { [key: string]: string } {
    return {
      eventId: 'EventId',
      eventEndTime: 'EventEndTime',
      eventTime: 'EventTime',
      impactLevel: 'ImpactLevel',
      eventType: 'EventType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      eventId: 'string',
      eventEndTime: 'string',
      eventTime: 'string',
      impactLevel: 'string',
      eventType: DescribeDisksFullStatusResponseBodyDiskFullStatusSetDiskEventSetEventType,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDisksFullStatusResponseBodyDiskFullStatusSetHealthStatus extends $tea.Model {
  code?: number;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDisksFullStatusResponseBodyDiskFullStatusSet extends $tea.Model {
  status?: DescribeDisksFullStatusResponseBodyDiskFullStatusSetStatus;
  diskEventSet?: DescribeDisksFullStatusResponseBodyDiskFullStatusSetDiskEventSet[];
  device?: string;
  diskId?: string;
  instanceId?: string;
  healthStatus?: DescribeDisksFullStatusResponseBodyDiskFullStatusSetHealthStatus;
  static names(): { [key: string]: string } {
    return {
      status: 'Status',
      diskEventSet: 'DiskEventSet',
      device: 'Device',
      diskId: 'DiskId',
      instanceId: 'InstanceId',
      healthStatus: 'HealthStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      status: DescribeDisksFullStatusResponseBodyDiskFullStatusSetStatus,
      diskEventSet: { 'type': 'array', 'itemType': DescribeDisksFullStatusResponseBodyDiskFullStatusSetDiskEventSet },
      device: 'string',
      diskId: 'string',
      instanceId: 'string',
      healthStatus: DescribeDisksFullStatusResponseBodyDiskFullStatusSetHealthStatus,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEipAddressesRequestFilter extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEipAddressesResponseBodyEipAddressesOperationLocks extends $tea.Model {
  lockReason?: string;
  static names(): { [key: string]: string } {
    return {
      lockReason: 'LockReason',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lockReason: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEipAddressesResponseBodyEipAddresses extends $tea.Model {
  status?: string;
  operationLocks?: DescribeEipAddressesResponseBodyEipAddressesOperationLocks[];
  allocationTime?: string;
  chargeType?: string;
  instanceId?: string;
  instanceType?: string;
  regionId?: string;
  ipAddress?: string;
  bandwidth?: string;
  expiredTime?: string;
  allocationId?: string;
  internetChargeType?: string;
  eipBandwidth?: string;
  static names(): { [key: string]: string } {
    return {
      status: 'Status',
      operationLocks: 'OperationLocks',
      allocationTime: 'AllocationTime',
      chargeType: 'ChargeType',
      instanceId: 'InstanceId',
      instanceType: 'InstanceType',
      regionId: 'RegionId',
      ipAddress: 'IpAddress',
      bandwidth: 'Bandwidth',
      expiredTime: 'ExpiredTime',
      allocationId: 'AllocationId',
      internetChargeType: 'InternetChargeType',
      eipBandwidth: 'EipBandwidth',
    };
  }

  static types(): { [key: string]: any } {
    return {
      status: 'string',
      operationLocks: { 'type': 'array', 'itemType': DescribeEipAddressesResponseBodyEipAddressesOperationLocks },
      allocationTime: 'string',
      chargeType: 'string',
      instanceId: 'string',
      instanceType: 'string',
      regionId: 'string',
      ipAddress: 'string',
      bandwidth: 'string',
      expiredTime: 'string',
      allocationId: 'string',
      internetChargeType: 'string',
      eipBandwidth: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEipMonitorDataResponseBodyEipMonitorDatas extends $tea.Model {
  eipTX?: number;
  eipPackets?: number;
  eipBandwidth?: number;
  timeStamp?: string;
  eipFlow?: number;
  eipRX?: number;
  static names(): { [key: string]: string } {
    return {
      eipTX: 'EipTX',
      eipPackets: 'EipPackets',
      eipBandwidth: 'EipBandwidth',
      timeStamp: 'TimeStamp',
      eipFlow: 'EipFlow',
      eipRX: 'EipRX',
    };
  }

  static types(): { [key: string]: any } {
    return {
      eipTX: 'number',
      eipPackets: 'number',
      eipBandwidth: 'number',
      timeStamp: 'string',
      eipFlow: 'number',
      eipRX: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeElasticityAssuranceInstancesRequestPrivatePoolOptions extends $tea.Model {
  id?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeElasticityAssuranceInstancesResponseBodyElasticityAssuranceItem extends $tea.Model {
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeElasticityAssurancesRequestPrivatePoolOptions extends $tea.Model {
  ids?: string;
  static names(): { [key: string]: string } {
    return {
      ids: 'Ids',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ids: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeElasticityAssurancesResponseBodyElasticityAssuranceSetAllocatedResources extends $tea.Model {
  zoneId?: string;
  usedAmount?: number;
  totalAmount?: number;
  instanceType?: string;
  static names(): { [key: string]: string } {
    return {
      zoneId: 'zoneId',
      usedAmount: 'UsedAmount',
      totalAmount: 'TotalAmount',
      instanceType: 'InstanceType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      zoneId: 'string',
      usedAmount: 'number',
      totalAmount: 'number',
      instanceType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeElasticityAssurancesResponseBodyElasticityAssuranceSet extends $tea.Model {
  status?: string;
  privatePoolOptionsMatchCriteria?: string;
  privatePoolOptionsId?: string;
  usedAssuranceTimes?: number;
  latestStartTime?: string;
  allocatedResources?: DescribeElasticityAssurancesResponseBodyElasticityAssuranceSetAllocatedResources[];
  privatePoolOptionsName?: string;
  regionId?: string;
  endTime?: string;
  startTime?: string;
  description?: string;
  totalAssuranceTimes?: string;
  static names(): { [key: string]: string } {
    return {
      status: 'Status',
      privatePoolOptionsMatchCriteria: 'PrivatePoolOptionsMatchCriteria',
      privatePoolOptionsId: 'PrivatePoolOptionsId',
      usedAssuranceTimes: 'UsedAssuranceTimes',
      latestStartTime: 'LatestStartTime',
      allocatedResources: 'AllocatedResources',
      privatePoolOptionsName: 'PrivatePoolOptionsName',
      regionId: 'RegionId',
      endTime: 'EndTime',
      startTime: 'StartTime',
      description: 'Description',
      totalAssuranceTimes: 'TotalAssuranceTimes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      status: 'string',
      privatePoolOptionsMatchCriteria: 'string',
      privatePoolOptionsId: 'string',
      usedAssuranceTimes: 'number',
      latestStartTime: 'string',
      allocatedResources: { 'type': 'array', 'itemType': DescribeElasticityAssurancesResponseBodyElasticityAssuranceSetAllocatedResources },
      privatePoolOptionsName: 'string',
      regionId: 'string',
      endTime: 'string',
      startTime: 'string',
      description: 'string',
      totalAssuranceTimes: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEniMonitorDataResponseBodyMonitorData extends $tea.Model {
  packetRx?: string;
  timeStamp?: string;
  dropPacketRx?: string;
  eniId?: string;
  dropPacketTx?: string;
  packetTx?: string;
  intranetTx?: string;
  intranetRx?: string;
  static names(): { [key: string]: string } {
    return {
      packetRx: 'PacketRx',
      timeStamp: 'TimeStamp',
      dropPacketRx: 'DropPacketRx',
      eniId: 'EniId',
      dropPacketTx: 'DropPacketTx',
      packetTx: 'PacketTx',
      intranetTx: 'IntranetTx',
      intranetRx: 'IntranetRx',
    };
  }

  static types(): { [key: string]: any } {
    return {
      packetRx: 'string',
      timeStamp: 'string',
      dropPacketRx: 'string',
      eniId: 'string',
      dropPacketTx: 'string',
      packetTx: 'string',
      intranetTx: 'string',
      intranetRx: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeForwardTableEntriesResponseBodyForwardTableEntries extends $tea.Model {
  status?: string;
  forwardEntryId?: string;
  internalIp?: string;
  internalPort?: string;
  forwardTableId?: string;
  externalPort?: string;
  ipProtocol?: string;
  externalIp?: string;
  static names(): { [key: string]: string } {
    return {
      status: 'Status',
      forwardEntryId: 'ForwardEntryId',
      internalIp: 'InternalIp',
      internalPort: 'InternalPort',
      forwardTableId: 'ForwardTableId',
      externalPort: 'ExternalPort',
      ipProtocol: 'IpProtocol',
      externalIp: 'ExternalIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      status: 'string',
      forwardEntryId: 'string',
      internalIp: 'string',
      internalPort: 'string',
      forwardTableId: 'string',
      externalPort: 'string',
      ipProtocol: 'string',
      externalIp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHaVipsRequestFilter extends $tea.Model {
  key?: string;
  value?: string[];
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHaVipsResponseBodyHaVips extends $tea.Model {
  status?: string;
  vpcId?: string;
  vSwitchId?: string;
  ipAddress?: string;
  description?: string;
  haVipId?: string;
  createTime?: string;
  associatedInstances?: string[];
  masterInstanceId?: string;
  associatedEipAddresses?: string[];
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      status: 'Status',
      vpcId: 'VpcId',
      vSwitchId: 'VSwitchId',
      ipAddress: 'IpAddress',
      description: 'Description',
      haVipId: 'HaVipId',
      createTime: 'CreateTime',
      associatedInstances: 'AssociatedInstances',
      masterInstanceId: 'MasterInstanceId',
      associatedEipAddresses: 'AssociatedEipAddresses',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      status: 'string',
      vpcId: 'string',
      vSwitchId: 'string',
      ipAddress: 'string',
      description: 'string',
      haVipId: 'string',
      createTime: 'string',
      associatedInstances: { 'type': 'array', 'itemType': 'string' },
      masterInstanceId: 'string',
      associatedEipAddresses: { 'type': 'array', 'itemType': 'string' },
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHpcClustersResponseBodyHpcClusters extends $tea.Model {
  description?: string;
  hpcClusterId?: string;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      hpcClusterId: 'HpcClusterId',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      hpcClusterId: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageFromFamilyResponseBodyImageTags extends $tea.Model {
  tagValue?: string;
  tagKey?: string;
  static names(): { [key: string]: string } {
    return {
      tagValue: 'TagValue',
      tagKey: 'TagKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagValue: 'string',
      tagKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageFromFamilyResponseBodyImageDiskDeviceMappings extends $tea.Model {
  type?: string;
  importOSSBucket?: string;
  snapshotId?: string;
  importOSSObject?: string;
  size?: string;
  device?: string;
  format?: string;
  static names(): { [key: string]: string } {
    return {
      type: 'Type',
      importOSSBucket: 'ImportOSSBucket',
      snapshotId: 'SnapshotId',
      importOSSObject: 'ImportOSSObject',
      size: 'Size',
      device: 'Device',
      format: 'Format',
    };
  }

  static types(): { [key: string]: any } {
    return {
      type: 'string',
      importOSSBucket: 'string',
      snapshotId: 'string',
      importOSSObject: 'string',
      size: 'string',
      device: 'string',
      format: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageFromFamilyResponseBodyImage extends $tea.Model {
  imageFamily?: string;
  status?: string;
  creationTime?: string;
  progress?: string;
  isCopied?: boolean;
  imageOwnerAlias?: string;
  isSupportIoOptimized?: boolean;
  tags?: DescribeImageFromFamilyResponseBodyImageTags[];
  isSupportCloudinit?: boolean;
  imageVersion?: string;
  diskDeviceMappings?: DescribeImageFromFamilyResponseBodyImageDiskDeviceMappings[];
  usage?: string;
  isSelfShared?: string;
  description?: string;
  size?: number;
  platform?: string;
  imageName?: string;
  OSName?: string;
  imageId?: string;
  OSType?: string;
  isSubscribed?: boolean;
  productCode?: string;
  architecture?: string;
  static names(): { [key: string]: string } {
    return {
      imageFamily: 'ImageFamily',
      status: 'Status',
      creationTime: 'CreationTime',
      progress: 'Progress',
      isCopied: 'IsCopied',
      imageOwnerAlias: 'ImageOwnerAlias',
      isSupportIoOptimized: 'IsSupportIoOptimized',
      tags: 'Tags',
      isSupportCloudinit: 'IsSupportCloudinit',
      imageVersion: 'ImageVersion',
      diskDeviceMappings: 'DiskDeviceMappings',
      usage: 'Usage',
      isSelfShared: 'IsSelfShared',
      description: 'Description',
      size: 'Size',
      platform: 'Platform',
      imageName: 'ImageName',
      OSName: 'OSName',
      imageId: 'ImageId',
      OSType: 'OSType',
      isSubscribed: 'IsSubscribed',
      productCode: 'ProductCode',
      architecture: 'Architecture',
    };
  }

  static types(): { [key: string]: any } {
    return {
      imageFamily: 'string',
      status: 'string',
      creationTime: 'string',
      progress: 'string',
      isCopied: 'boolean',
      imageOwnerAlias: 'string',
      isSupportIoOptimized: 'boolean',
      tags: { 'type': 'array', 'itemType': DescribeImageFromFamilyResponseBodyImageTags },
      isSupportCloudinit: 'boolean',
      imageVersion: 'string',
      diskDeviceMappings: { 'type': 'array', 'itemType': DescribeImageFromFamilyResponseBodyImageDiskDeviceMappings },
      usage: 'string',
      isSelfShared: 'string',
      description: 'string',
      size: 'number',
      platform: 'string',
      imageName: 'string',
      OSName: 'string',
      imageId: 'string',
      OSType: 'string',
      isSubscribed: 'boolean',
      productCode: 'string',
      architecture: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImagesRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImagesRequestFilter extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImagesResponseBodyImagesTags extends $tea.Model {
  tagValue?: string;
  tagKey?: string;
  static names(): { [key: string]: string } {
    return {
      tagValue: 'TagValue',
      tagKey: 'TagKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagValue: 'string',
      tagKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImagesResponseBodyImagesDiskDeviceMappings extends $tea.Model {
  type?: string;
  importOSSBucket?: string;
  progress?: string;
  snapshotId?: string;
  importOSSObject?: string;
  device?: string;
  size?: string;
  remainTime?: number;
  format?: string;
  static names(): { [key: string]: string } {
    return {
      type: 'Type',
      importOSSBucket: 'ImportOSSBucket',
      progress: 'Progress',
      snapshotId: 'SnapshotId',
      importOSSObject: 'ImportOSSObject',
      device: 'Device',
      size: 'Size',
      remainTime: 'RemainTime',
      format: 'Format',
    };
  }

  static types(): { [key: string]: any } {
    return {
      type: 'string',
      importOSSBucket: 'string',
      progress: 'string',
      snapshotId: 'string',
      importOSSObject: 'string',
      device: 'string',
      size: 'string',
      remainTime: 'number',
      format: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImagesResponseBodyImages extends $tea.Model {
  status?: string;
  creationTime?: string;
  isSupportIoOptimized?: boolean;
  tags?: DescribeImagesResponseBodyImagesTags[];
  imageVersion?: string;
  isSelfShared?: string;
  description?: string;
  OSNameEn?: string;
  platform?: string;
  OSName?: string;
  imageId?: string;
  isSubscribed?: boolean;
  imageFamily?: string;
  progress?: string;
  isCopied?: boolean;
  imageOwnerAlias?: string;
  isSupportCloudinit?: boolean;
  diskDeviceMappings?: DescribeImagesResponseBodyImagesDiskDeviceMappings[];
  usage?: string;
  size?: number;
  resourceGroupId?: string;
  imageName?: string;
  OSType?: string;
  architecture?: string;
  productCode?: string;
  static names(): { [key: string]: string } {
    return {
      status: 'Status',
      creationTime: 'CreationTime',
      isSupportIoOptimized: 'IsSupportIoOptimized',
      tags: 'Tags',
      imageVersion: 'ImageVersion',
      isSelfShared: 'IsSelfShared',
      description: 'Description',
      OSNameEn: 'OSNameEn',
      platform: 'Platform',
      OSName: 'OSName',
      imageId: 'ImageId',
      isSubscribed: 'IsSubscribed',
      imageFamily: 'ImageFamily',
      progress: 'Progress',
      isCopied: 'IsCopied',
      imageOwnerAlias: 'ImageOwnerAlias',
      isSupportCloudinit: 'IsSupportCloudinit',
      diskDeviceMappings: 'DiskDeviceMappings',
      usage: 'Usage',
      size: 'Size',
      resourceGroupId: 'ResourceGroupId',
      imageName: 'ImageName',
      OSType: 'OSType',
      architecture: 'Architecture',
      productCode: 'ProductCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      status: 'string',
      creationTime: 'string',
      isSupportIoOptimized: 'boolean',
      tags: { 'type': 'array', 'itemType': DescribeImagesResponseBodyImagesTags },
      imageVersion: 'string',
      isSelfShared: 'string',
      description: 'string',
      OSNameEn: 'string',
      platform: 'string',
      OSName: 'string',
      imageId: 'string',
      isSubscribed: 'boolean',
      imageFamily: 'string',
      progress: 'string',
      isCopied: 'boolean',
      imageOwnerAlias: 'string',
      isSupportCloudinit: 'boolean',
      diskDeviceMappings: { 'type': 'array', 'itemType': DescribeImagesResponseBodyImagesDiskDeviceMappings },
      usage: 'string',
      size: 'number',
      resourceGroupId: 'string',
      imageName: 'string',
      OSType: 'string',
      architecture: 'string',
      productCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageSharePermissionResponseBodyShareGroups extends $tea.Model {
  group?: string;
  static names(): { [key: string]: string } {
    return {
      group: 'Group',
    };
  }

  static types(): { [key: string]: any } {
    return {
      group: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageSharePermissionResponseBodyAccounts extends $tea.Model {
  aliyunId?: string;
  static names(): { [key: string]: string } {
    return {
      aliyunId: 'AliyunId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageSupportInstanceTypesRequestFilter extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageSupportInstanceTypesResponseBodyInstanceTypes extends $tea.Model {
  instanceTypeId?: string;
  instanceTypeFamily?: string;
  cpuCoreCount?: number;
  memorySize?: number;
  static names(): { [key: string]: string } {
    return {
      instanceTypeId: 'InstanceTypeId',
      instanceTypeFamily: 'InstanceTypeFamily',
      cpuCoreCount: 'CpuCoreCount',
      memorySize: 'MemorySize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceTypeId: 'string',
      instanceTypeFamily: 'string',
      cpuCoreCount: 'number',
      memorySize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceAttachmentAttributesResponseBodyInstances extends $tea.Model {
  privatePoolOptionsMatchCriteria?: string;
  privatePoolOptionsId?: string;
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      privatePoolOptionsMatchCriteria: 'PrivatePoolOptionsMatchCriteria',
      privatePoolOptionsId: 'PrivatePoolOptionsId',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      privatePoolOptionsMatchCriteria: 'string',
      privatePoolOptionsId: 'string',
      instanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceAttributeResponseBodyEipAddress extends $tea.Model {
  ipAddress?: string;
  bandwidth?: number;
  allocationId?: string;
  internetChargeType?: string;
  static names(): { [key: string]: string } {
    return {
      ipAddress: 'IpAddress',
      bandwidth: 'Bandwidth',
      allocationId: 'AllocationId',
      internetChargeType: 'InternetChargeType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ipAddress: 'string',
      bandwidth: 'number',
      allocationId: 'string',
      internetChargeType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceAttributeResponseBodyDedicatedHostAttribute extends $tea.Model {
  dedicatedHostName?: string;
  dedicatedHostId?: string;
  static names(): { [key: string]: string } {
    return {
      dedicatedHostName: 'DedicatedHostName',
      dedicatedHostId: 'DedicatedHostId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dedicatedHostName: 'string',
      dedicatedHostId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceAttributeResponseBodyVpcAttributes extends $tea.Model {
  vpcId?: string;
  natIpAddress?: string;
  vSwitchId?: string;
  privateIpAddress?: string[];
  static names(): { [key: string]: string } {
    return {
      vpcId: 'VpcId',
      natIpAddress: 'NatIpAddress',
      vSwitchId: 'VSwitchId',
      privateIpAddress: 'PrivateIpAddress',
    };
  }

  static types(): { [key: string]: any } {
    return {
      vpcId: 'string',
      natIpAddress: 'string',
      vSwitchId: 'string',
      privateIpAddress: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceAttributeResponseBodyOperationLocks extends $tea.Model {
  lockReason?: string;
  static names(): { [key: string]: string } {
    return {
      lockReason: 'LockReason',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lockReason: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceAutoRenewAttributeResponseBodyInstanceRenewAttributes extends $tea.Model {
  periodUnit?: string;
  duration?: number;
  renewalStatus?: string;
  instanceId?: string;
  autoRenewEnabled?: boolean;
  static names(): { [key: string]: string } {
    return {
      periodUnit: 'PeriodUnit',
      duration: 'Duration',
      renewalStatus: 'RenewalStatus',
      instanceId: 'InstanceId',
      autoRenewEnabled: 'AutoRenewEnabled',
    };
  }

  static types(): { [key: string]: any } {
    return {
      periodUnit: 'string',
      duration: 'number',
      renewalStatus: 'string',
      instanceId: 'string',
      autoRenewEnabled: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceHistoryEventsRequestNotBefore extends $tea.Model {
  start?: string;
  end?: string;
  static names(): { [key: string]: string } {
    return {
      start: 'Start',
      end: 'End',
    };
  }

  static types(): { [key: string]: any } {
    return {
      start: 'string',
      end: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceHistoryEventsRequestEventPublishTime extends $tea.Model {
  start?: string;
  end?: string;
  static names(): { [key: string]: string } {
    return {
      start: 'Start',
      end: 'End',
    };
  }

  static types(): { [key: string]: any } {
    return {
      start: 'string',
      end: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetEventType extends $tea.Model {
  code?: number;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetExtendedAttributeInactiveDisks extends $tea.Model {
  creationTime?: string;
  deviceCategory?: string;
  deviceType?: string;
  releaseTime?: string;
  deviceSize?: string;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      deviceCategory: 'DeviceCategory',
      deviceType: 'DeviceType',
      releaseTime: 'ReleaseTime',
      deviceSize: 'DeviceSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      deviceCategory: 'string',
      deviceType: 'string',
      releaseTime: 'string',
      deviceSize: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetExtendedAttribute extends $tea.Model {
  device?: string;
  diskId?: string;
  inactiveDisks?: DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetExtendedAttributeInactiveDisks[];
  static names(): { [key: string]: string } {
    return {
      device: 'Device',
      diskId: 'DiskId',
      inactiveDisks: 'InactiveDisks',
    };
  }

  static types(): { [key: string]: any } {
    return {
      device: 'string',
      diskId: 'string',
      inactiveDisks: { 'type': 'array', 'itemType': DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetExtendedAttributeInactiveDisks },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetEventCycleStatus extends $tea.Model {
  code?: number;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSet extends $tea.Model {
  eventId?: string;
  eventPublishTime?: string;
  eventFinishTime?: string;
  impactLevel?: string;
  eventType?: DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetEventType;
  extendedAttribute?: DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetExtendedAttribute;
  notBefore?: string;
  instanceId?: string;
  reason?: string;
  eventCycleStatus?: DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetEventCycleStatus;
  static names(): { [key: string]: string } {
    return {
      eventId: 'EventId',
      eventPublishTime: 'EventPublishTime',
      eventFinishTime: 'EventFinishTime',
      impactLevel: 'ImpactLevel',
      eventType: 'EventType',
      extendedAttribute: 'ExtendedAttribute',
      notBefore: 'NotBefore',
      instanceId: 'InstanceId',
      reason: 'Reason',
      eventCycleStatus: 'EventCycleStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      eventId: 'string',
      eventPublishTime: 'string',
      eventFinishTime: 'string',
      impactLevel: 'string',
      eventType: DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetEventType,
      extendedAttribute: DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetExtendedAttribute,
      notBefore: 'string',
      instanceId: 'string',
      reason: 'string',
      eventCycleStatus: DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetEventCycleStatus,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceWindows extends $tea.Model {
  endTime?: string;
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesActionOnMaintenance extends $tea.Model {
  value?: string;
  supportedValues?: string[];
  defaultValue?: string;
  static names(): { [key: string]: string } {
    return {
      value: 'Value',
      supportedValues: 'SupportedValues',
      defaultValue: 'DefaultValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      value: 'string',
      supportedValues: { 'type': 'array', 'itemType': 'string' },
      defaultValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributes extends $tea.Model {
  maintenanceWindows?: DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceWindows[];
  instanceId?: string;
  actionOnMaintenance?: DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesActionOnMaintenance;
  static names(): { [key: string]: string } {
    return {
      maintenanceWindows: 'MaintenanceWindows',
      instanceId: 'InstanceId',
      actionOnMaintenance: 'ActionOnMaintenance',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maintenanceWindows: { 'type': 'array', 'itemType': DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceWindows },
      instanceId: 'string',
      actionOnMaintenance: DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesActionOnMaintenance,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceMonitorDataResponseBodyMonitorData extends $tea.Model {
  CPUCreditBalance?: number;
  BPSRead?: number;
  internetTX?: number;
  CPU?: number;
  CPUCreditUsage?: number;
  IOPSWrite?: number;
  instanceId?: string;
  intranetTX?: number;
  BPSWrite?: number;
  CPUNotpaidSurplusCreditUsage?: number;
  IOPSRead?: number;
  CPUAdvanceCreditBalance?: number;
  internetBandwidth?: number;
  internetRX?: number;
  timeStamp?: string;
  intranetRX?: number;
  intranetBandwidth?: number;
  static names(): { [key: string]: string } {
    return {
      CPUCreditBalance: 'CPUCreditBalance',
      BPSRead: 'BPSRead',
      internetTX: 'InternetTX',
      CPU: 'CPU',
      CPUCreditUsage: 'CPUCreditUsage',
      IOPSWrite: 'IOPSWrite',
      instanceId: 'InstanceId',
      intranetTX: 'IntranetTX',
      BPSWrite: 'BPSWrite',
      CPUNotpaidSurplusCreditUsage: 'CPUNotpaidSurplusCreditUsage',
      IOPSRead: 'IOPSRead',
      CPUAdvanceCreditBalance: 'CPUAdvanceCreditBalance',
      internetBandwidth: 'InternetBandwidth',
      internetRX: 'InternetRX',
      timeStamp: 'TimeStamp',
      intranetRX: 'IntranetRX',
      intranetBandwidth: 'IntranetBandwidth',
    };
  }

  static types(): { [key: string]: any } {
    return {
      CPUCreditBalance: 'number',
      BPSRead: 'number',
      internetTX: 'number',
      CPU: 'number',
      CPUCreditUsage: 'number',
      IOPSWrite: 'number',
      instanceId: 'string',
      intranetTX: 'number',
      BPSWrite: 'number',
      CPUNotpaidSurplusCreditUsage: 'number',
      IOPSRead: 'number',
      CPUAdvanceCreditBalance: 'number',
      internetBandwidth: 'number',
      internetRX: 'number',
      timeStamp: 'string',
      intranetRX: 'number',
      intranetBandwidth: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceRamRoleResponseBodyInstanceRamRoleSets extends $tea.Model {
  ramRoleName?: string;
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      ramRoleName: 'RamRoleName',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ramRoleName: 'string',
      instanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancesRequestFilter extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancesRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancesResponseBodyInstancesDedicatedHostAttribute extends $tea.Model {
  dedicatedHostName?: string;
  dedicatedHostClusterId?: string;
  dedicatedHostId?: string;
  static names(): { [key: string]: string } {
    return {
      dedicatedHostName: 'DedicatedHostName',
      dedicatedHostClusterId: 'DedicatedHostClusterId',
      dedicatedHostId: 'DedicatedHostId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dedicatedHostName: 'string',
      dedicatedHostClusterId: 'string',
      dedicatedHostId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancesResponseBodyInstancesOperationLocks extends $tea.Model {
  lockReason?: string;
  lockMsg?: string;
  static names(): { [key: string]: string } {
    return {
      lockReason: 'LockReason',
      lockMsg: 'LockMsg',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lockReason: 'string',
      lockMsg: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancesResponseBodyInstancesTags extends $tea.Model {
  tagValue?: string;
  tagKey?: string;
  static names(): { [key: string]: string } {
    return {
      tagValue: 'TagValue',
      tagKey: 'TagKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagValue: 'string',
      tagKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancesResponseBodyInstancesMetadataOptions extends $tea.Model {
  httpPutResponseHopLimit?: number;
  httpEndpoint?: string;
  httpTokens?: string;
  static names(): { [key: string]: string } {
    return {
      httpPutResponseHopLimit: 'HttpPutResponseHopLimit',
      httpEndpoint: 'HttpEndpoint',
      httpTokens: 'HttpTokens',
    };
  }

  static types(): { [key: string]: any } {
    return {
      httpPutResponseHopLimit: 'number',
      httpEndpoint: 'string',
      httpTokens: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancesResponseBodyInstancesEipAddress extends $tea.Model {
  ipAddress?: string;
  bandwidth?: number;
  allocationId?: string;
  isSupportUnassociate?: boolean;
  internetChargeType?: string;
  static names(): { [key: string]: string } {
    return {
      ipAddress: 'IpAddress',
      bandwidth: 'Bandwidth',
      allocationId: 'AllocationId',
      isSupportUnassociate: 'IsSupportUnassociate',
      internetChargeType: 'InternetChargeType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ipAddress: 'string',
      bandwidth: 'number',
      allocationId: 'string',
      isSupportUnassociate: 'boolean',
      internetChargeType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancesResponseBodyInstancesDedicatedInstanceAttribute extends $tea.Model {
  affinity?: string;
  tenancy?: string;
  static names(): { [key: string]: string } {
    return {
      affinity: 'Affinity',
      tenancy: 'Tenancy',
    };
  }

  static types(): { [key: string]: any } {
    return {
      affinity: 'string',
      tenancy: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancesResponseBodyInstancesCpuOptions extends $tea.Model {
  numa?: string;
  coreCount?: number;
  threadsPerCore?: number;
  static names(): { [key: string]: string } {
    return {
      numa: 'Numa',
      coreCount: 'CoreCount',
      threadsPerCore: 'ThreadsPerCore',
    };
  }

  static types(): { [key: string]: any } {
    return {
      numa: 'string',
      coreCount: 'number',
      threadsPerCore: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancesResponseBodyInstancesVpcAttributes extends $tea.Model {
  vpcId?: string;
  natIpAddress?: string;
  vSwitchId?: string;
  privateIpAddress?: string[];
  static names(): { [key: string]: string } {
    return {
      vpcId: 'VpcId',
      natIpAddress: 'NatIpAddress',
      vSwitchId: 'VSwitchId',
      privateIpAddress: 'PrivateIpAddress',
    };
  }

  static types(): { [key: string]: any } {
    return {
      vpcId: 'string',
      natIpAddress: 'string',
      vSwitchId: 'string',
      privateIpAddress: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancesResponseBodyInstancesEcsCapacityReservationAttr extends $tea.Model {
  capacityReservationPreference?: string;
  capacityReservationId?: string;
  static names(): { [key: string]: string } {
    return {
      capacityReservationPreference: 'CapacityReservationPreference',
      capacityReservationId: 'CapacityReservationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      capacityReservationPreference: 'string',
      capacityReservationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancesResponseBodyInstancesNetworkInterfacesIpv6Sets extends $tea.Model {
  ipv6Address?: string;
  static names(): { [key: string]: string } {
    return {
      ipv6Address: 'Ipv6Address',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ipv6Address: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancesResponseBodyInstancesNetworkInterfacesPrivateIpSets extends $tea.Model {
  primary?: boolean;
  privateIpAddress?: string;
  static names(): { [key: string]: string } {
    return {
      primary: 'Primary',
      privateIpAddress: 'PrivateIpAddress',
    };
  }

  static types(): { [key: string]: any } {
    return {
      primary: 'boolean',
      privateIpAddress: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancesResponseBodyInstancesNetworkInterfaces extends $tea.Model {
  type?: string;
  macAddress?: string;
  networkInterfaceId?: string;
  ipv6Sets?: DescribeInstancesResponseBodyInstancesNetworkInterfacesIpv6Sets[];
  primaryIpAddress?: string;
  privateIpSets?: DescribeInstancesResponseBodyInstancesNetworkInterfacesPrivateIpSets[];
  static names(): { [key: string]: string } {
    return {
      type: 'Type',
      macAddress: 'MacAddress',
      networkInterfaceId: 'NetworkInterfaceId',
      ipv6Sets: 'Ipv6Sets',
      primaryIpAddress: 'PrimaryIpAddress',
      privateIpSets: 'PrivateIpSets',
    };
  }

  static types(): { [key: string]: any } {
    return {
      type: 'string',
      macAddress: 'string',
      networkInterfaceId: 'string',
      ipv6Sets: { 'type': 'array', 'itemType': DescribeInstancesResponseBodyInstancesNetworkInterfacesIpv6Sets },
      primaryIpAddress: 'string',
      privateIpSets: { 'type': 'array', 'itemType': DescribeInstancesResponseBodyInstancesNetworkInterfacesPrivateIpSets },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancesResponseBodyInstances extends $tea.Model {
  creationTime?: string;
  serialNumber?: string;
  dedicatedHostAttribute?: DescribeInstancesResponseBodyInstancesDedicatedHostAttribute;
  operationLocks?: DescribeInstancesResponseBodyInstancesOperationLocks[];
  tags?: DescribeInstancesResponseBodyInstancesTags[];
  metadataOptions?: DescribeInstancesResponseBodyInstancesMetadataOptions;
  saleCycle?: string;
  publicIpAddress?: string[];
  spotStrategy?: string;
  deviceAvailable?: boolean;
  eipAddress?: DescribeInstancesResponseBodyInstancesEipAddress;
  instanceName?: string;
  instanceNetworkType?: string;
  spotDuration?: number;
  OSNameEn?: string;
  spotPriceLimit?: number;
  OSName?: string;
  imageId?: string;
  deploymentSetGroupNo?: number;
  clusterId?: string;
  dedicatedInstanceAttribute?: DescribeInstancesResponseBodyInstancesDedicatedInstanceAttribute;
  GPUSpec?: string;
  autoReleaseTime?: string;
  innerIpAddress?: string[];
  stoppedMode?: string;
  GPUAmount?: number;
  hostName?: string;
  instanceId?: string;
  instanceType?: string;
  instanceChargeType?: string;
  startTime?: string;
  internetChargeType?: string;
  zoneId?: string;
  recyclable?: boolean;
  creditSpecification?: string;
  OSType?: string;
  status?: string;
  deploymentSetId?: string;
  keyPairName?: string;
  cpuOptions?: DescribeInstancesResponseBodyInstancesCpuOptions;
  localStorageCapacity?: number;
  description?: string;
  hpcClusterId?: string;
  memory?: number;
  vlanId?: string;
  vpcAttributes?: DescribeInstancesResponseBodyInstancesVpcAttributes;
  deletionProtection?: boolean;
  ecsCapacityReservationAttr?: DescribeInstancesResponseBodyInstancesEcsCapacityReservationAttr;
  internetMaxBandwidthIn?: number;
  internetMaxBandwidthOut?: number;
  securityGroupIds?: string[];
  regionId?: string;
  ioOptimized?: boolean;
  cpu?: number;
  rdmaIpAddress?: string[];
  expiredTime?: string;
  localStorageAmount?: number;
  resourceGroupId?: string;
  instanceTypeFamily?: string;
  ISP?: string;
  networkInterfaces?: DescribeInstancesResponseBodyInstancesNetworkInterfaces[];
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      serialNumber: 'SerialNumber',
      dedicatedHostAttribute: 'DedicatedHostAttribute',
      operationLocks: 'OperationLocks',
      tags: 'Tags',
      metadataOptions: 'MetadataOptions',
      saleCycle: 'SaleCycle',
      publicIpAddress: 'PublicIpAddress',
      spotStrategy: 'SpotStrategy',
      deviceAvailable: 'DeviceAvailable',
      eipAddress: 'EipAddress',
      instanceName: 'InstanceName',
      instanceNetworkType: 'InstanceNetworkType',
      spotDuration: 'SpotDuration',
      OSNameEn: 'OSNameEn',
      spotPriceLimit: 'SpotPriceLimit',
      OSName: 'OSName',
      imageId: 'ImageId',
      deploymentSetGroupNo: 'DeploymentSetGroupNo',
      clusterId: 'ClusterId',
      dedicatedInstanceAttribute: 'DedicatedInstanceAttribute',
      GPUSpec: 'GPUSpec',
      autoReleaseTime: 'AutoReleaseTime',
      innerIpAddress: 'InnerIpAddress',
      stoppedMode: 'StoppedMode',
      GPUAmount: 'GPUAmount',
      hostName: 'HostName',
      instanceId: 'InstanceId',
      instanceType: 'InstanceType',
      instanceChargeType: 'InstanceChargeType',
      startTime: 'StartTime',
      internetChargeType: 'InternetChargeType',
      zoneId: 'ZoneId',
      recyclable: 'Recyclable',
      creditSpecification: 'CreditSpecification',
      OSType: 'OSType',
      status: 'Status',
      deploymentSetId: 'DeploymentSetId',
      keyPairName: 'KeyPairName',
      cpuOptions: 'CpuOptions',
      localStorageCapacity: 'LocalStorageCapacity',
      description: 'Description',
      hpcClusterId: 'HpcClusterId',
      memory: 'Memory',
      vlanId: 'VlanId',
      vpcAttributes: 'VpcAttributes',
      deletionProtection: 'DeletionProtection',
      ecsCapacityReservationAttr: 'EcsCapacityReservationAttr',
      internetMaxBandwidthIn: 'InternetMaxBandwidthIn',
      internetMaxBandwidthOut: 'InternetMaxBandwidthOut',
      securityGroupIds: 'SecurityGroupIds',
      regionId: 'RegionId',
      ioOptimized: 'IoOptimized',
      cpu: 'Cpu',
      rdmaIpAddress: 'RdmaIpAddress',
      expiredTime: 'ExpiredTime',
      localStorageAmount: 'LocalStorageAmount',
      resourceGroupId: 'ResourceGroupId',
      instanceTypeFamily: 'InstanceTypeFamily',
      ISP: 'ISP',
      networkInterfaces: 'NetworkInterfaces',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      serialNumber: 'string',
      dedicatedHostAttribute: DescribeInstancesResponseBodyInstancesDedicatedHostAttribute,
      operationLocks: { 'type': 'array', 'itemType': DescribeInstancesResponseBodyInstancesOperationLocks },
      tags: { 'type': 'array', 'itemType': DescribeInstancesResponseBodyInstancesTags },
      metadataOptions: DescribeInstancesResponseBodyInstancesMetadataOptions,
      saleCycle: 'string',
      publicIpAddress: { 'type': 'array', 'itemType': 'string' },
      spotStrategy: 'string',
      deviceAvailable: 'boolean',
      eipAddress: DescribeInstancesResponseBodyInstancesEipAddress,
      instanceName: 'string',
      instanceNetworkType: 'string',
      spotDuration: 'number',
      OSNameEn: 'string',
      spotPriceLimit: 'number',
      OSName: 'string',
      imageId: 'string',
      deploymentSetGroupNo: 'number',
      clusterId: 'string',
      dedicatedInstanceAttribute: DescribeInstancesResponseBodyInstancesDedicatedInstanceAttribute,
      GPUSpec: 'string',
      autoReleaseTime: 'string',
      innerIpAddress: { 'type': 'array', 'itemType': 'string' },
      stoppedMode: 'string',
      GPUAmount: 'number',
      hostName: 'string',
      instanceId: 'string',
      instanceType: 'string',
      instanceChargeType: 'string',
      startTime: 'string',
      internetChargeType: 'string',
      zoneId: 'string',
      recyclable: 'boolean',
      creditSpecification: 'string',
      OSType: 'string',
      status: 'string',
      deploymentSetId: 'string',
      keyPairName: 'string',
      cpuOptions: DescribeInstancesResponseBodyInstancesCpuOptions,
      localStorageCapacity: 'number',
      description: 'string',
      hpcClusterId: 'string',
      memory: 'number',
      vlanId: 'string',
      vpcAttributes: DescribeInstancesResponseBodyInstancesVpcAttributes,
      deletionProtection: 'boolean',
      ecsCapacityReservationAttr: DescribeInstancesResponseBodyInstancesEcsCapacityReservationAttr,
      internetMaxBandwidthIn: 'number',
      internetMaxBandwidthOut: 'number',
      securityGroupIds: { 'type': 'array', 'itemType': 'string' },
      regionId: 'string',
      ioOptimized: 'boolean',
      cpu: 'number',
      rdmaIpAddress: { 'type': 'array', 'itemType': 'string' },
      expiredTime: 'string',
      localStorageAmount: 'number',
      resourceGroupId: 'string',
      instanceTypeFamily: 'string',
      ISP: 'string',
      networkInterfaces: { 'type': 'array', 'itemType': DescribeInstancesResponseBodyInstancesNetworkInterfaces },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancesFullStatusRequestNotBefore extends $tea.Model {
  start?: string;
  end?: string;
  static names(): { [key: string]: string } {
    return {
      start: 'Start',
      end: 'End',
    };
  }

  static types(): { [key: string]: any } {
    return {
      start: 'string',
      end: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancesFullStatusRequestEventPublishTime extends $tea.Model {
  start?: string;
  end?: string;
  static names(): { [key: string]: string } {
    return {
      start: 'Start',
      end: 'End',
    };
  }

  static types(): { [key: string]: any } {
    return {
      start: 'string',
      end: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetStatus extends $tea.Model {
  code?: number;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetScheduledSystemEventSetEventType extends $tea.Model {
  code?: number;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetScheduledSystemEventSetExtendedAttributeInactiveDisks extends $tea.Model {
  creationTime?: string;
  deviceCategory?: string;
  deviceType?: string;
  releaseTime?: string;
  deviceSize?: string;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      deviceCategory: 'DeviceCategory',
      deviceType: 'DeviceType',
      releaseTime: 'ReleaseTime',
      deviceSize: 'DeviceSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      deviceCategory: 'string',
      deviceType: 'string',
      releaseTime: 'string',
      deviceSize: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetScheduledSystemEventSetExtendedAttribute extends $tea.Model {
  device?: string;
  diskId?: string;
  inactiveDisks?: DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetScheduledSystemEventSetExtendedAttributeInactiveDisks[];
  static names(): { [key: string]: string } {
    return {
      device: 'Device',
      diskId: 'DiskId',
      inactiveDisks: 'InactiveDisks',
    };
  }

  static types(): { [key: string]: any } {
    return {
      device: 'string',
      diskId: 'string',
      inactiveDisks: { 'type': 'array', 'itemType': DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetScheduledSystemEventSetExtendedAttributeInactiveDisks },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetScheduledSystemEventSetEventCycleStatus extends $tea.Model {
  code?: number;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetScheduledSystemEventSet extends $tea.Model {
  eventPublishTime?: string;
  eventId?: string;
  impactLevel?: string;
  eventType?: DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetScheduledSystemEventSetEventType;
  extendedAttribute?: DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetScheduledSystemEventSetExtendedAttribute;
  notBefore?: string;
  reason?: string;
  eventCycleStatus?: DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetScheduledSystemEventSetEventCycleStatus;
  static names(): { [key: string]: string } {
    return {
      eventPublishTime: 'EventPublishTime',
      eventId: 'EventId',
      impactLevel: 'ImpactLevel',
      eventType: 'EventType',
      extendedAttribute: 'ExtendedAttribute',
      notBefore: 'NotBefore',
      reason: 'Reason',
      eventCycleStatus: 'EventCycleStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      eventPublishTime: 'string',
      eventId: 'string',
      impactLevel: 'string',
      eventType: DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetScheduledSystemEventSetEventType,
      extendedAttribute: DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetScheduledSystemEventSetExtendedAttribute,
      notBefore: 'string',
      reason: 'string',
      eventCycleStatus: DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetScheduledSystemEventSetEventCycleStatus,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetHealthStatus extends $tea.Model {
  code?: number;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancesFullStatusResponseBodyInstanceFullStatusSet extends $tea.Model {
  status?: DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetStatus;
  scheduledSystemEventSet?: DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetScheduledSystemEventSet[];
  instanceId?: string;
  healthStatus?: DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetHealthStatus;
  static names(): { [key: string]: string } {
    return {
      status: 'Status',
      scheduledSystemEventSet: 'ScheduledSystemEventSet',
      instanceId: 'InstanceId',
      healthStatus: 'HealthStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      status: DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetStatus,
      scheduledSystemEventSet: { 'type': 'array', 'itemType': DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetScheduledSystemEventSet },
      instanceId: 'string',
      healthStatus: DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetHealthStatus,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceStatusResponseBodyInstanceStatuses extends $tea.Model {
  status?: string;
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      status: 'Status',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      status: 'string',
      instanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTopologyResponseBodyTopologys extends $tea.Model {
  instanceId?: string;
  hostId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      hostId: 'HostId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      hostId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTypeFamiliesResponseBodyInstanceTypeFamilies extends $tea.Model {
  instanceTypeFamilyId?: string;
  generation?: string;
  static names(): { [key: string]: string } {
    return {
      instanceTypeFamilyId: 'InstanceTypeFamilyId',
      generation: 'Generation',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceTypeFamilyId: 'string',
      generation: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTypesResponseBodyInstanceTypes extends $tea.Model {
  eniTotalQuantity?: number;
  localStorageCategory?: string;
  primaryEniQueueNumber?: number;
  memorySize?: number;
  localStorageCapacity?: number;
  instanceFamilyLevel?: string;
  instancePpsRx?: number;
  eniIpv6AddressQuantity?: number;
  maximumQueueNumberPerEni?: number;
  instanceTypeId?: string;
  instanceBandwidthRx?: number;
  GPUSpec?: string;
  secondaryEniQueueNumber?: number;
  instanceBandwidthTx?: number;
  GPUAmount?: number;
  totalEniQueueQuantity?: number;
  initialCredit?: number;
  localStorageAmount?: number;
  baselineCredit?: number;
  instancePpsTx?: number;
  eniPrivateIpAddressQuantity?: number;
  instanceTypeFamily?: string;
  cpuCoreCount?: number;
  eniQuantity?: number;
  eniTrunkSupported?: boolean;
  static names(): { [key: string]: string } {
    return {
      eniTotalQuantity: 'EniTotalQuantity',
      localStorageCategory: 'LocalStorageCategory',
      primaryEniQueueNumber: 'PrimaryEniQueueNumber',
      memorySize: 'MemorySize',
      localStorageCapacity: 'LocalStorageCapacity',
      instanceFamilyLevel: 'InstanceFamilyLevel',
      instancePpsRx: 'InstancePpsRx',
      eniIpv6AddressQuantity: 'EniIpv6AddressQuantity',
      maximumQueueNumberPerEni: 'MaximumQueueNumberPerEni',
      instanceTypeId: 'InstanceTypeId',
      instanceBandwidthRx: 'InstanceBandwidthRx',
      GPUSpec: 'GPUSpec',
      secondaryEniQueueNumber: 'SecondaryEniQueueNumber',
      instanceBandwidthTx: 'InstanceBandwidthTx',
      GPUAmount: 'GPUAmount',
      totalEniQueueQuantity: 'TotalEniQueueQuantity',
      initialCredit: 'InitialCredit',
      localStorageAmount: 'LocalStorageAmount',
      baselineCredit: 'BaselineCredit',
      instancePpsTx: 'InstancePpsTx',
      eniPrivateIpAddressQuantity: 'EniPrivateIpAddressQuantity',
      instanceTypeFamily: 'InstanceTypeFamily',
      cpuCoreCount: 'CpuCoreCount',
      eniQuantity: 'EniQuantity',
      eniTrunkSupported: 'EniTrunkSupported',
    };
  }

  static types(): { [key: string]: any } {
    return {
      eniTotalQuantity: 'number',
      localStorageCategory: 'string',
      primaryEniQueueNumber: 'number',
      memorySize: 'number',
      localStorageCapacity: 'number',
      instanceFamilyLevel: 'string',
      instancePpsRx: 'number',
      eniIpv6AddressQuantity: 'number',
      maximumQueueNumberPerEni: 'number',
      instanceTypeId: 'string',
      instanceBandwidthRx: 'number',
      GPUSpec: 'string',
      secondaryEniQueueNumber: 'number',
      instanceBandwidthTx: 'number',
      GPUAmount: 'number',
      totalEniQueueQuantity: 'number',
      initialCredit: 'number',
      localStorageAmount: 'number',
      baselineCredit: 'number',
      instancePpsTx: 'number',
      eniPrivateIpAddressQuantity: 'number',
      instanceTypeFamily: 'string',
      cpuCoreCount: 'number',
      eniQuantity: 'number',
      eniTrunkSupported: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInvocationResultsResponseBodyInvocationInvocationResults extends $tea.Model {
  invocationStatus?: string;
  repeats?: number;
  output?: string;
  instanceId?: string;
  commandId?: string;
  dropped?: number;
  stopTime?: string;
  exitCode?: number;
  startTime?: string;
  errorInfo?: string;
  errorCode?: string;
  finishedTime?: string;
  invokeId?: string;
  invokeRecordStatus?: string;
  username?: string;
  static names(): { [key: string]: string } {
    return {
      invocationStatus: 'InvocationStatus',
      repeats: 'Repeats',
      output: 'Output',
      instanceId: 'InstanceId',
      commandId: 'CommandId',
      dropped: 'Dropped',
      stopTime: 'StopTime',
      exitCode: 'ExitCode',
      startTime: 'StartTime',
      errorInfo: 'ErrorInfo',
      errorCode: 'ErrorCode',
      finishedTime: 'FinishedTime',
      invokeId: 'InvokeId',
      invokeRecordStatus: 'InvokeRecordStatus',
      username: 'Username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      invocationStatus: 'string',
      repeats: 'number',
      output: 'string',
      instanceId: 'string',
      commandId: 'string',
      dropped: 'number',
      stopTime: 'string',
      exitCode: 'number',
      startTime: 'string',
      errorInfo: 'string',
      errorCode: 'string',
      finishedTime: 'string',
      invokeId: 'string',
      invokeRecordStatus: 'string',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInvocationResultsResponseBodyInvocation extends $tea.Model {
  pageSize?: number;
  pageNumber?: number;
  invocationResults?: DescribeInvocationResultsResponseBodyInvocationInvocationResults[];
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      pageSize: 'PageSize',
      pageNumber: 'PageNumber',
      invocationResults: 'InvocationResults',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageSize: 'number',
      pageNumber: 'number',
      invocationResults: { 'type': 'array', 'itemType': DescribeInvocationResultsResponseBodyInvocationInvocationResults },
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInvocationsResponseBodyInvocationsInvokeInstances extends $tea.Model {
  creationTime?: string;
  invocationStatus?: string;
  finishTime?: string;
  updateTime?: string;
  repeats?: number;
  output?: string;
  instanceId?: string;
  dropped?: number;
  stopTime?: string;
  exitCode?: number;
  startTime?: string;
  errorInfo?: string;
  errorCode?: string;
  instanceInvokeStatus?: string;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      invocationStatus: 'InvocationStatus',
      finishTime: 'FinishTime',
      updateTime: 'UpdateTime',
      repeats: 'Repeats',
      output: 'Output',
      instanceId: 'InstanceId',
      dropped: 'Dropped',
      stopTime: 'StopTime',
      exitCode: 'ExitCode',
      startTime: 'StartTime',
      errorInfo: 'ErrorInfo',
      errorCode: 'ErrorCode',
      instanceInvokeStatus: 'InstanceInvokeStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      invocationStatus: 'string',
      finishTime: 'string',
      updateTime: 'string',
      repeats: 'number',
      output: 'string',
      instanceId: 'string',
      dropped: 'number',
      stopTime: 'string',
      exitCode: 'number',
      startTime: 'string',
      errorInfo: 'string',
      errorCode: 'string',
      instanceInvokeStatus: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInvocationsResponseBodyInvocations extends $tea.Model {
  frequency?: string;
  creationTime?: string;
  invocationStatus?: string;
  invokeInstances?: DescribeInvocationsResponseBodyInvocationsInvokeInstances[];
  commandId?: string;
  invokeStatus?: string;
  commandType?: string;
  parameters?: string;
  timed?: boolean;
  commandContent?: string;
  commandName?: string;
  invokeId?: string;
  username?: string;
  static names(): { [key: string]: string } {
    return {
      frequency: 'Frequency',
      creationTime: 'CreationTime',
      invocationStatus: 'InvocationStatus',
      invokeInstances: 'InvokeInstances',
      commandId: 'CommandId',
      invokeStatus: 'InvokeStatus',
      commandType: 'CommandType',
      parameters: 'Parameters',
      timed: 'Timed',
      commandContent: 'CommandContent',
      commandName: 'CommandName',
      invokeId: 'InvokeId',
      username: 'Username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      frequency: 'string',
      creationTime: 'string',
      invocationStatus: 'string',
      invokeInstances: { 'type': 'array', 'itemType': DescribeInvocationsResponseBodyInvocationsInvokeInstances },
      commandId: 'string',
      invokeStatus: 'string',
      commandType: 'string',
      parameters: 'string',
      timed: 'boolean',
      commandContent: 'string',
      commandName: 'string',
      invokeId: 'string',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeKeyPairsRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeKeyPairsResponseBodyKeyPairsTags extends $tea.Model {
  tagValue?: string;
  tagKey?: string;
  static names(): { [key: string]: string } {
    return {
      tagValue: 'TagValue',
      tagKey: 'TagKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagValue: 'string',
      tagKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeKeyPairsResponseBodyKeyPairs extends $tea.Model {
  creationTime?: string;
  keyPairName?: string;
  resourceGroupId?: string;
  tags?: DescribeKeyPairsResponseBodyKeyPairsTags[];
  keyPairFingerPrint?: string;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      keyPairName: 'KeyPairName',
      resourceGroupId: 'ResourceGroupId',
      tags: 'Tags',
      keyPairFingerPrint: 'KeyPairFingerPrint',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      keyPairName: 'string',
      resourceGroupId: 'string',
      tags: { 'type': 'array', 'itemType': DescribeKeyPairsResponseBodyKeyPairsTags },
      keyPairFingerPrint: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLaunchTemplatesRequestTemplateTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLaunchTemplatesResponseBodyLaunchTemplateSetsTags extends $tea.Model {
  tagValue?: string;
  tagKey?: string;
  static names(): { [key: string]: string } {
    return {
      tagValue: 'TagValue',
      tagKey: 'TagKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagValue: 'string',
      tagKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLaunchTemplatesResponseBodyLaunchTemplateSets extends $tea.Model {
  launchTemplateName?: string;
  defaultVersionNumber?: number;
  modifiedTime?: string;
  launchTemplateId?: string;
  createTime?: string;
  resourceGroupId?: string;
  createdBy?: string;
  tags?: DescribeLaunchTemplatesResponseBodyLaunchTemplateSetsTags[];
  latestVersionNumber?: number;
  static names(): { [key: string]: string } {
    return {
      launchTemplateName: 'LaunchTemplateName',
      defaultVersionNumber: 'DefaultVersionNumber',
      modifiedTime: 'ModifiedTime',
      launchTemplateId: 'LaunchTemplateId',
      createTime: 'CreateTime',
      resourceGroupId: 'ResourceGroupId',
      createdBy: 'CreatedBy',
      tags: 'Tags',
      latestVersionNumber: 'LatestVersionNumber',
    };
  }

  static types(): { [key: string]: any } {
    return {
      launchTemplateName: 'string',
      defaultVersionNumber: 'number',
      modifiedTime: 'string',
      launchTemplateId: 'string',
      createTime: 'string',
      resourceGroupId: 'string',
      createdBy: 'string',
      tags: { 'type': 'array', 'itemType': DescribeLaunchTemplatesResponseBodyLaunchTemplateSetsTags },
      latestVersionNumber: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateDataSystemDisk extends $tea.Model {
  size?: number;
  diskName?: string;
  category?: string;
  description?: string;
  iops?: number;
  static names(): { [key: string]: string } {
    return {
      size: 'Size',
      diskName: 'DiskName',
      category: 'Category',
      description: 'Description',
      iops: 'Iops',
    };
  }

  static types(): { [key: string]: any } {
    return {
      size: 'number',
      diskName: 'string',
      category: 'string',
      description: 'string',
      iops: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateDataTags extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateDataDataDisks extends $tea.Model {
  description?: string;
  snapshotId?: string;
  device?: string;
  size?: number;
  diskName?: string;
  category?: string;
  deleteWithInstance?: boolean;
  encrypted?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      snapshotId: 'SnapshotId',
      device: 'Device',
      size: 'Size',
      diskName: 'DiskName',
      category: 'Category',
      deleteWithInstance: 'DeleteWithInstance',
      encrypted: 'Encrypted',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      snapshotId: 'string',
      device: 'string',
      size: 'number',
      diskName: 'string',
      category: 'string',
      deleteWithInstance: 'boolean',
      encrypted: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateDataNetworkInterfaces extends $tea.Model {
  networkInterfaceName?: string;
  vSwitchId?: string;
  description?: string;
  securityGroupId?: string;
  primaryIpAddress?: string;
  static names(): { [key: string]: string } {
    return {
      networkInterfaceName: 'NetworkInterfaceName',
      vSwitchId: 'VSwitchId',
      description: 'Description',
      securityGroupId: 'SecurityGroupId',
      primaryIpAddress: 'PrimaryIpAddress',
    };
  }

  static types(): { [key: string]: any } {
    return {
      networkInterfaceName: 'string',
      vSwitchId: 'string',
      description: 'string',
      securityGroupId: 'string',
      primaryIpAddress: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateData extends $tea.Model {
  systemDisk: DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateDataSystemDisk;
  vpcId?: string;
  keyPairName?: string;
  securityGroupId?: string;
  tags?: DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateDataTags[];
  networkType?: string;
  dataDisks?: DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateDataDataDisks[];
  spotStrategy?: string;
  enableVmOsConfig?: boolean;
  description?: string;
  spotDuration?: number;
  instanceName?: string;
  userData?: string;
  securityEnhancementStrategy?: string;
  passwordInherit?: boolean;
  spotPriceLimit?: number;
  imageId?: string;
  autoReleaseTime?: string;
  imageOwnerAlias?: string;
  hostName?: string;
  internetMaxBandwidthOut?: number;
  internetMaxBandwidthIn?: number;
  instanceType?: string;
  period?: number;
  instanceChargeType?: string;
  ioOptimized?: string;
  ramRoleName?: string;
  vSwitchId?: string;
  resourceGroupId?: string;
  internetChargeType?: string;
  zoneId?: string;
  networkInterfaces?: DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateDataNetworkInterfaces[];
  static names(): { [key: string]: string } {
    return {
      systemDisk: 'SystemDisk',
      vpcId: 'VpcId',
      keyPairName: 'KeyPairName',
      securityGroupId: 'SecurityGroupId',
      tags: 'Tags',
      networkType: 'NetworkType',
      dataDisks: 'DataDisks',
      spotStrategy: 'SpotStrategy',
      enableVmOsConfig: 'EnableVmOsConfig',
      description: 'Description',
      spotDuration: 'SpotDuration',
      instanceName: 'InstanceName',
      userData: 'UserData',
      securityEnhancementStrategy: 'SecurityEnhancementStrategy',
      passwordInherit: 'PasswordInherit',
      spotPriceLimit: 'SpotPriceLimit',
      imageId: 'ImageId',
      autoReleaseTime: 'AutoReleaseTime',
      imageOwnerAlias: 'ImageOwnerAlias',
      hostName: 'HostName',
      internetMaxBandwidthOut: 'InternetMaxBandwidthOut',
      internetMaxBandwidthIn: 'InternetMaxBandwidthIn',
      instanceType: 'InstanceType',
      period: 'Period',
      instanceChargeType: 'InstanceChargeType',
      ioOptimized: 'IoOptimized',
      ramRoleName: 'RamRoleName',
      vSwitchId: 'VSwitchId',
      resourceGroupId: 'ResourceGroupId',
      internetChargeType: 'InternetChargeType',
      zoneId: 'ZoneId',
      networkInterfaces: 'NetworkInterfaces',
    };
  }

  static types(): { [key: string]: any } {
    return {
      systemDisk: DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateDataSystemDisk,
      vpcId: 'string',
      keyPairName: 'string',
      securityGroupId: 'string',
      tags: { 'type': 'array', 'itemType': DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateDataTags },
      networkType: 'string',
      dataDisks: { 'type': 'array', 'itemType': DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateDataDataDisks },
      spotStrategy: 'string',
      enableVmOsConfig: 'boolean',
      description: 'string',
      spotDuration: 'number',
      instanceName: 'string',
      userData: 'string',
      securityEnhancementStrategy: 'string',
      passwordInherit: 'boolean',
      spotPriceLimit: 'number',
      imageId: 'string',
      autoReleaseTime: 'string',
      imageOwnerAlias: 'string',
      hostName: 'string',
      internetMaxBandwidthOut: 'number',
      internetMaxBandwidthIn: 'number',
      instanceType: 'string',
      period: 'number',
      instanceChargeType: 'string',
      ioOptimized: 'string',
      ramRoleName: 'string',
      vSwitchId: 'string',
      resourceGroupId: 'string',
      internetChargeType: 'string',
      zoneId: 'string',
      networkInterfaces: { 'type': 'array', 'itemType': DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateDataNetworkInterfaces },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSets extends $tea.Model {
  launchTemplateName?: string;
  defaultVersion?: boolean;
  versionNumber?: number;
  modifiedTime?: string;
  launchTemplateData?: DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateData;
  launchTemplateId?: string;
  createTime?: string;
  createdBy?: string;
  versionDescription?: string;
  static names(): { [key: string]: string } {
    return {
      launchTemplateName: 'LaunchTemplateName',
      defaultVersion: 'DefaultVersion',
      versionNumber: 'VersionNumber',
      modifiedTime: 'ModifiedTime',
      launchTemplateData: 'LaunchTemplateData',
      launchTemplateId: 'LaunchTemplateId',
      createTime: 'CreateTime',
      createdBy: 'CreatedBy',
      versionDescription: 'VersionDescription',
    };
  }

  static types(): { [key: string]: any } {
    return {
      launchTemplateName: 'string',
      defaultVersion: 'boolean',
      versionNumber: 'number',
      modifiedTime: 'string',
      launchTemplateData: DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateData,
      launchTemplateId: 'string',
      createTime: 'string',
      createdBy: 'string',
      versionDescription: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNatGatewaysResponseBodyNatGateways extends $tea.Model {
  status?: string;
  creationTime?: string;
  vpcId?: string;
  bandwidthPackageIds?: string[];
  spec?: string;
  instanceChargeType?: string;
  regionId?: string;
  description?: string;
  natGatewayId?: string;
  forwardTableIds?: string[];
  businessStatus?: string;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      status: 'Status',
      creationTime: 'CreationTime',
      vpcId: 'VpcId',
      bandwidthPackageIds: 'BandwidthPackageIds',
      spec: 'Spec',
      instanceChargeType: 'InstanceChargeType',
      regionId: 'RegionId',
      description: 'Description',
      natGatewayId: 'NatGatewayId',
      forwardTableIds: 'ForwardTableIds',
      businessStatus: 'BusinessStatus',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      status: 'string',
      creationTime: 'string',
      vpcId: 'string',
      bandwidthPackageIds: { 'type': 'array', 'itemType': 'string' },
      spec: 'string',
      instanceChargeType: 'string',
      regionId: 'string',
      description: 'string',
      natGatewayId: 'string',
      forwardTableIds: { 'type': 'array', 'itemType': 'string' },
      businessStatus: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNetworkInterfaceAttributeRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNetworkInterfaceAttributeResponseBodyAttachment extends $tea.Model {
  deviceIndex?: number;
  instanceId?: string;
  memberNetworkInterfaceIds?: string[];
  trunkNetworkInterfaceId?: string;
  static names(): { [key: string]: string } {
    return {
      deviceIndex: 'DeviceIndex',
      instanceId: 'InstanceId',
      memberNetworkInterfaceIds: 'MemberNetworkInterfaceIds',
      trunkNetworkInterfaceId: 'TrunkNetworkInterfaceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceIndex: 'number',
      instanceId: 'string',
      memberNetworkInterfaceIds: { 'type': 'array', 'itemType': 'string' },
      trunkNetworkInterfaceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNetworkInterfaceAttributeResponseBodyIpv6Sets extends $tea.Model {
  ipv6Address?: string;
  static names(): { [key: string]: string } {
    return {
      ipv6Address: 'Ipv6Address',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ipv6Address: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNetworkInterfaceAttributeResponseBodyAssociatedPublicIp extends $tea.Model {
  allocationId?: string;
  publicIpAddress?: string;
  static names(): { [key: string]: string } {
    return {
      allocationId: 'AllocationId',
      publicIpAddress: 'PublicIpAddress',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allocationId: 'string',
      publicIpAddress: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNetworkInterfaceAttributeResponseBodyTags extends $tea.Model {
  tagValue?: string;
  tagKey?: string;
  static names(): { [key: string]: string } {
    return {
      tagValue: 'TagValue',
      tagKey: 'TagKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagValue: 'string',
      tagKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNetworkInterfaceAttributeResponseBodyPrivateIpSetsAssociatedPublicIp extends $tea.Model {
  allocationId?: string;
  publicIpAddress?: string;
  static names(): { [key: string]: string } {
    return {
      allocationId: 'AllocationId',
      publicIpAddress: 'PublicIpAddress',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allocationId: 'string',
      publicIpAddress: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNetworkInterfaceAttributeResponseBodyPrivateIpSets extends $tea.Model {
  associatedPublicIp?: DescribeNetworkInterfaceAttributeResponseBodyPrivateIpSetsAssociatedPublicIp;
  primary?: boolean;
  privateIpAddress?: string;
  static names(): { [key: string]: string } {
    return {
      associatedPublicIp: 'AssociatedPublicIp',
      primary: 'Primary',
      privateIpAddress: 'PrivateIpAddress',
    };
  }

  static types(): { [key: string]: any } {
    return {
      associatedPublicIp: DescribeNetworkInterfaceAttributeResponseBodyPrivateIpSetsAssociatedPublicIp,
      primary: 'boolean',
      privateIpAddress: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNetworkInterfacePermissionsResponseBodyNetworkInterfacePermissions extends $tea.Model {
  permission?: string;
  networkInterfaceId?: string;
  accountId?: number;
  networkInterfacePermissionId?: string;
  serviceName?: string;
  permissionState?: string;
  static names(): { [key: string]: string } {
    return {
      permission: 'Permission',
      networkInterfaceId: 'NetworkInterfaceId',
      accountId: 'AccountId',
      networkInterfacePermissionId: 'NetworkInterfacePermissionId',
      serviceName: 'ServiceName',
      permissionState: 'PermissionState',
    };
  }

  static types(): { [key: string]: any } {
    return {
      permission: 'string',
      networkInterfaceId: 'string',
      accountId: 'number',
      networkInterfacePermissionId: 'string',
      serviceName: 'string',
      permissionState: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNetworkInterfacesRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsTags extends $tea.Model {
  tagValue?: string;
  tagKey?: string;
  static names(): { [key: string]: string } {
    return {
      tagValue: 'TagValue',
      tagKey: 'TagKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagValue: 'string',
      tagKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsAttachment extends $tea.Model {
  deviceIndex?: number;
  instanceId?: string;
  trunkNetworkInterfaceId?: string;
  static names(): { [key: string]: string } {
    return {
      deviceIndex: 'DeviceIndex',
      instanceId: 'InstanceId',
      trunkNetworkInterfaceId: 'TrunkNetworkInterfaceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceIndex: 'number',
      instanceId: 'string',
      trunkNetworkInterfaceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsIpv6Sets extends $tea.Model {
  ipv6Address?: string;
  static names(): { [key: string]: string } {
    return {
      ipv6Address: 'Ipv6Address',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ipv6Address: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsAssociatedPublicIp extends $tea.Model {
  allocationId?: string;
  publicIpAddress?: string;
  static names(): { [key: string]: string } {
    return {
      allocationId: 'AllocationId',
      publicIpAddress: 'PublicIpAddress',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allocationId: 'string',
      publicIpAddress: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsPrivateIpSetsAssociatedPublicIp extends $tea.Model {
  allocationId?: string;
  publicIpAddress?: string;
  static names(): { [key: string]: string } {
    return {
      allocationId: 'AllocationId',
      publicIpAddress: 'PublicIpAddress',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allocationId: 'string',
      publicIpAddress: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsPrivateIpSets extends $tea.Model {
  associatedPublicIp?: DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsPrivateIpSetsAssociatedPublicIp;
  primary?: boolean;
  privateIpAddress?: string;
  static names(): { [key: string]: string } {
    return {
      associatedPublicIp: 'AssociatedPublicIp',
      primary: 'Primary',
      privateIpAddress: 'PrivateIpAddress',
    };
  }

  static types(): { [key: string]: any } {
    return {
      associatedPublicIp: DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsPrivateIpSetsAssociatedPublicIp,
      primary: 'boolean',
      privateIpAddress: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNetworkInterfacesResponseBodyNetworkInterfaceSets extends $tea.Model {
  status?: string;
  type?: string;
  vpcId?: string;
  creationTime?: string;
  networkInterfaceName?: string;
  macAddress?: string;
  networkInterfaceId?: string;
  tags?: DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsTags[];
  attachment?: DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsAttachment;
  serviceID?: number;
  ipv6Sets?: DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsIpv6Sets[];
  instanceId?: string;
  ownerId?: string;
  securityGroupIds?: string[];
  serviceManaged?: boolean;
  vSwitchId?: string;
  description?: string;
  resourceGroupId?: string;
  associatedPublicIp?: DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsAssociatedPublicIp;
  zoneId?: string;
  privateIpAddress?: string;
  queueNumber?: number;
  privateIpSets?: DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsPrivateIpSets[];
  static names(): { [key: string]: string } {
    return {
      status: 'Status',
      type: 'Type',
      vpcId: 'VpcId',
      creationTime: 'CreationTime',
      networkInterfaceName: 'NetworkInterfaceName',
      macAddress: 'MacAddress',
      networkInterfaceId: 'NetworkInterfaceId',
      tags: 'Tags',
      attachment: 'Attachment',
      serviceID: 'ServiceID',
      ipv6Sets: 'Ipv6Sets',
      instanceId: 'InstanceId',
      ownerId: 'OwnerId',
      securityGroupIds: 'SecurityGroupIds',
      serviceManaged: 'ServiceManaged',
      vSwitchId: 'VSwitchId',
      description: 'Description',
      resourceGroupId: 'ResourceGroupId',
      associatedPublicIp: 'AssociatedPublicIp',
      zoneId: 'ZoneId',
      privateIpAddress: 'PrivateIpAddress',
      queueNumber: 'QueueNumber',
      privateIpSets: 'PrivateIpSets',
    };
  }

  static types(): { [key: string]: any } {
    return {
      status: 'string',
      type: 'string',
      vpcId: 'string',
      creationTime: 'string',
      networkInterfaceName: 'string',
      macAddress: 'string',
      networkInterfaceId: 'string',
      tags: { 'type': 'array', 'itemType': DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsTags },
      attachment: DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsAttachment,
      serviceID: 'number',
      ipv6Sets: { 'type': 'array', 'itemType': DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsIpv6Sets },
      instanceId: 'string',
      ownerId: 'string',
      securityGroupIds: { 'type': 'array', 'itemType': 'string' },
      serviceManaged: 'boolean',
      vSwitchId: 'string',
      description: 'string',
      resourceGroupId: 'string',
      associatedPublicIp: DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsAssociatedPublicIp,
      zoneId: 'string',
      privateIpAddress: 'string',
      queueNumber: 'number',
      privateIpSets: { 'type': 'array', 'itemType': DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsPrivateIpSets },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNewProjectEipMonitorDataResponseBodyEipMonitorDatas extends $tea.Model {
  eipTX?: number;
  eipPackets?: number;
  eipBandwidth?: number;
  timeStamp?: string;
  eipFlow?: number;
  eipRX?: number;
  static names(): { [key: string]: string } {
    return {
      eipTX: 'EipTX',
      eipPackets: 'EipPackets',
      eipBandwidth: 'EipBandwidth',
      timeStamp: 'TimeStamp',
      eipFlow: 'EipFlow',
      eipRX: 'EipRX',
    };
  }

  static types(): { [key: string]: any } {
    return {
      eipTX: 'number',
      eipPackets: 'number',
      eipBandwidth: 'number',
      timeStamp: 'string',
      eipFlow: 'number',
      eipRX: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePhysicalConnectionsRequestFilter extends $tea.Model {
  key?: string;
  value?: string[];
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePhysicalConnectionsResponseBodyPhysicalConnectionSet extends $tea.Model {
  type?: string;
  status?: string;
  creationTime?: string;
  adLocation?: string;
  portNumber?: string;
  spec?: string;
  circuitCode?: string;
  description?: string;
  bandwidth?: number;
  portType?: string;
  businessStatus?: string;
  enabledTime?: string;
  lineOperator?: string;
  name?: string;
  redundantPhysicalConnectionId?: string;
  peerLocation?: string;
  accessPointId?: string;
  physicalConnectionId?: string;
  static names(): { [key: string]: string } {
    return {
      type: 'Type',
      status: 'Status',
      creationTime: 'CreationTime',
      adLocation: 'AdLocation',
      portNumber: 'PortNumber',
      spec: 'Spec',
      circuitCode: 'CircuitCode',
      description: 'Description',
      bandwidth: 'Bandwidth',
      portType: 'PortType',
      businessStatus: 'BusinessStatus',
      enabledTime: 'EnabledTime',
      lineOperator: 'LineOperator',
      name: 'Name',
      redundantPhysicalConnectionId: 'RedundantPhysicalConnectionId',
      peerLocation: 'PeerLocation',
      accessPointId: 'AccessPointId',
      physicalConnectionId: 'PhysicalConnectionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      type: 'string',
      status: 'string',
      creationTime: 'string',
      adLocation: 'string',
      portNumber: 'string',
      spec: 'string',
      circuitCode: 'string',
      description: 'string',
      bandwidth: 'number',
      portType: 'string',
      businessStatus: 'string',
      enabledTime: 'string',
      lineOperator: 'string',
      name: 'string',
      redundantPhysicalConnectionId: 'string',
      peerLocation: 'string',
      accessPointId: 'string',
      physicalConnectionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePriceRequestSystemDisk extends $tea.Model {
  category?: string;
  size?: number;
  performanceLevel?: string;
  static names(): { [key: string]: string } {
    return {
      category: 'Category',
      size: 'Size',
      performanceLevel: 'PerformanceLevel',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
      size: 'number',
      performanceLevel: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePriceRequestDataDisk extends $tea.Model {
  size?: number;
  category?: string;
  performanceLevel?: string;
  static names(): { [key: string]: string } {
    return {
      size: 'Size',
      category: 'Category',
      performanceLevel: 'PerformanceLevel',
    };
  }

  static types(): { [key: string]: any } {
    return {
      size: 'number',
      category: 'string',
      performanceLevel: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePriceResponseBodyPriceInfoPriceDetailInfosSubRules extends $tea.Model {
  description?: string;
  ruleId?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      ruleId: 'RuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      ruleId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePriceResponseBodyPriceInfoPriceDetailInfos extends $tea.Model {
  resource?: string;
  discountPrice?: number;
  tradePrice?: number;
  originalPrice?: number;
  subRules?: DescribePriceResponseBodyPriceInfoPriceDetailInfosSubRules[];
  static names(): { [key: string]: string } {
    return {
      resource: 'Resource',
      discountPrice: 'DiscountPrice',
      tradePrice: 'TradePrice',
      originalPrice: 'OriginalPrice',
      subRules: 'SubRules',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resource: 'string',
      discountPrice: 'number',
      tradePrice: 'number',
      originalPrice: 'number',
      subRules: { 'type': 'array', 'itemType': DescribePriceResponseBodyPriceInfoPriceDetailInfosSubRules },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePriceResponseBodyPriceInfoPrice extends $tea.Model {
  reservedInstanceHourPrice?: number;
  discountPrice?: number;
  tradePrice?: number;
  originalPrice?: number;
  detailInfos?: DescribePriceResponseBodyPriceInfoPriceDetailInfos[];
  currency?: string;
  static names(): { [key: string]: string } {
    return {
      reservedInstanceHourPrice: 'ReservedInstanceHourPrice',
      discountPrice: 'DiscountPrice',
      tradePrice: 'TradePrice',
      originalPrice: 'OriginalPrice',
      detailInfos: 'DetailInfos',
      currency: 'Currency',
    };
  }

  static types(): { [key: string]: any } {
    return {
      reservedInstanceHourPrice: 'number',
      discountPrice: 'number',
      tradePrice: 'number',
      originalPrice: 'number',
      detailInfos: { 'type': 'array', 'itemType': DescribePriceResponseBodyPriceInfoPriceDetailInfos },
      currency: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePriceResponseBodyPriceInfoRules extends $tea.Model {
  description?: string;
  ruleId?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      ruleId: 'RuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      ruleId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePriceResponseBodyPriceInfo extends $tea.Model {
  price?: DescribePriceResponseBodyPriceInfoPrice;
  rules?: DescribePriceResponseBodyPriceInfoRules[];
  static names(): { [key: string]: string } {
    return {
      price: 'Price',
      rules: 'Rules',
    };
  }

  static types(): { [key: string]: any } {
    return {
      price: DescribePriceResponseBodyPriceInfoPrice,
      rules: { 'type': 'array', 'itemType': DescribePriceResponseBodyPriceInfoRules },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRecommendInstanceTypeResponseBodyDataZones extends $tea.Model {
  zoneNo?: string;
  networkTypes?: string[];
  static names(): { [key: string]: string } {
    return {
      zoneNo: 'ZoneNo',
      networkTypes: 'NetworkTypes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      zoneNo: 'string',
      networkTypes: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRecommendInstanceTypeResponseBodyDataInstanceType extends $tea.Model {
  supportIoOptimized?: string;
  cores?: number;
  memory?: number;
  instanceType?: string;
  instanceTypeFamily?: string;
  generation?: string;
  static names(): { [key: string]: string } {
    return {
      supportIoOptimized: 'SupportIoOptimized',
      cores: 'Cores',
      memory: 'Memory',
      instanceType: 'InstanceType',
      instanceTypeFamily: 'InstanceTypeFamily',
      generation: 'Generation',
    };
  }

  static types(): { [key: string]: any } {
    return {
      supportIoOptimized: 'string',
      cores: 'number',
      memory: 'number',
      instanceType: 'string',
      instanceTypeFamily: 'string',
      generation: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRecommendInstanceTypeResponseBodyData extends $tea.Model {
  zones?: DescribeRecommendInstanceTypeResponseBodyDataZones[];
  commodityCode?: string;
  priority?: number;
  instanceType?: DescribeRecommendInstanceTypeResponseBodyDataInstanceType;
  scene?: string;
  spotStrategy?: string;
  regionId?: string;
  instanceChargeType?: string;
  static names(): { [key: string]: string } {
    return {
      zones: 'Zones',
      commodityCode: 'CommodityCode',
      priority: 'Priority',
      instanceType: 'InstanceType',
      scene: 'Scene',
      spotStrategy: 'SpotStrategy',
      regionId: 'RegionId',
      instanceChargeType: 'InstanceChargeType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      zones: { 'type': 'array', 'itemType': DescribeRecommendInstanceTypeResponseBodyDataZones },
      commodityCode: 'string',
      priority: 'number',
      instanceType: DescribeRecommendInstanceTypeResponseBodyDataInstanceType,
      scene: 'string',
      spotStrategy: 'string',
      regionId: 'string',
      instanceChargeType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRegionsResponseBodyRegions extends $tea.Model {
  status?: string;
  localName?: string;
  regionEndpoint?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      status: 'Status',
      localName: 'LocalName',
      regionEndpoint: 'RegionEndpoint',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      status: 'string',
      localName: 'string',
      regionEndpoint: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRenewalPriceResponseBodyPriceInfoPriceDetailInfosSubRules extends $tea.Model {
  description?: string;
  ruleId?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      ruleId: 'RuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      ruleId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRenewalPriceResponseBodyPriceInfoPriceDetailInfos extends $tea.Model {
  resource?: string;
  discountPrice?: number;
  tradePrice?: number;
  originalPrice?: number;
  subRules?: DescribeRenewalPriceResponseBodyPriceInfoPriceDetailInfosSubRules[];
  static names(): { [key: string]: string } {
    return {
      resource: 'Resource',
      discountPrice: 'DiscountPrice',
      tradePrice: 'TradePrice',
      originalPrice: 'OriginalPrice',
      subRules: 'SubRules',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resource: 'string',
      discountPrice: 'number',
      tradePrice: 'number',
      originalPrice: 'number',
      subRules: { 'type': 'array', 'itemType': DescribeRenewalPriceResponseBodyPriceInfoPriceDetailInfosSubRules },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRenewalPriceResponseBodyPriceInfoPrice extends $tea.Model {
  discountPrice?: number;
  tradePrice?: number;
  originalPrice?: number;
  detailInfos?: DescribeRenewalPriceResponseBodyPriceInfoPriceDetailInfos[];
  currency?: string;
  static names(): { [key: string]: string } {
    return {
      discountPrice: 'DiscountPrice',
      tradePrice: 'TradePrice',
      originalPrice: 'OriginalPrice',
      detailInfos: 'DetailInfos',
      currency: 'Currency',
    };
  }

  static types(): { [key: string]: any } {
    return {
      discountPrice: 'number',
      tradePrice: 'number',
      originalPrice: 'number',
      detailInfos: { 'type': 'array', 'itemType': DescribeRenewalPriceResponseBodyPriceInfoPriceDetailInfos },
      currency: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRenewalPriceResponseBodyPriceInfoRules extends $tea.Model {
  description?: string;
  ruleId?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      ruleId: 'RuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      ruleId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRenewalPriceResponseBodyPriceInfo extends $tea.Model {
  price?: DescribeRenewalPriceResponseBodyPriceInfoPrice;
  rules?: DescribeRenewalPriceResponseBodyPriceInfoRules[];
  static names(): { [key: string]: string } {
    return {
      price: 'Price',
      rules: 'Rules',
    };
  }

  static types(): { [key: string]: any } {
    return {
      price: DescribeRenewalPriceResponseBodyPriceInfoPrice,
      rules: { 'type': 'array', 'itemType': DescribeRenewalPriceResponseBodyPriceInfoRules },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeReservedInstancesRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeReservedInstancesResponseBodyReservedInstancesOperationLocks extends $tea.Model {
  lockReason?: string;
  static names(): { [key: string]: string } {
    return {
      lockReason: 'LockReason',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lockReason: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeReservedInstancesResponseBodyReservedInstancesTags extends $tea.Model {
  tagValue?: string;
  tagKey?: string;
  static names(): { [key: string]: string } {
    return {
      tagValue: 'TagValue',
      tagKey: 'TagKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagValue: 'string',
      tagKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeReservedInstancesResponseBodyReservedInstances extends $tea.Model {
  creationTime?: string;
  status?: string;
  reservedInstanceName?: string;
  operationLocks?: DescribeReservedInstancesResponseBodyReservedInstancesOperationLocks[];
  reservedInstanceId?: string;
  tags?: DescribeReservedInstancesResponseBodyReservedInstancesTags[];
  instanceType?: string;
  instanceAmount?: number;
  offeringType?: string;
  regionId?: string;
  startTime?: string;
  description?: string;
  allocationStatus?: string;
  expiredTime?: string;
  resourceGroupId?: string;
  zoneId?: string;
  platform?: string;
  scope?: string;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      status: 'Status',
      reservedInstanceName: 'ReservedInstanceName',
      operationLocks: 'OperationLocks',
      reservedInstanceId: 'ReservedInstanceId',
      tags: 'Tags',
      instanceType: 'InstanceType',
      instanceAmount: 'InstanceAmount',
      offeringType: 'OfferingType',
      regionId: 'RegionId',
      startTime: 'StartTime',
      description: 'Description',
      allocationStatus: 'AllocationStatus',
      expiredTime: 'ExpiredTime',
      resourceGroupId: 'ResourceGroupId',
      zoneId: 'ZoneId',
      platform: 'Platform',
      scope: 'Scope',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      status: 'string',
      reservedInstanceName: 'string',
      operationLocks: { 'type': 'array', 'itemType': DescribeReservedInstancesResponseBodyReservedInstancesOperationLocks },
      reservedInstanceId: 'string',
      tags: { 'type': 'array', 'itemType': DescribeReservedInstancesResponseBodyReservedInstancesTags },
      instanceType: 'string',
      instanceAmount: 'number',
      offeringType: 'string',
      regionId: 'string',
      startTime: 'string',
      description: 'string',
      allocationStatus: 'string',
      expiredTime: 'string',
      resourceGroupId: 'string',
      zoneId: 'string',
      platform: 'string',
      scope: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourceByTagsRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourceByTagsResponseBodyResources extends $tea.Model {
  resourceType?: string;
  resourceId?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      resourceType: 'ResourceType',
      resourceId: 'ResourceId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resourceType: 'string',
      resourceId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourcesModificationResponseBodyAvailableZonesAvailableResourcesSupportedResources extends $tea.Model {
  status?: string;
  value?: string;
  max?: number;
  unit?: string;
  statusCategory?: string;
  min?: number;
  static names(): { [key: string]: string } {
    return {
      status: 'Status',
      value: 'Value',
      max: 'Max',
      unit: 'Unit',
      statusCategory: 'StatusCategory',
      min: 'Min',
    };
  }

  static types(): { [key: string]: any } {
    return {
      status: 'string',
      value: 'string',
      max: 'number',
      unit: 'string',
      statusCategory: 'string',
      min: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourcesModificationResponseBodyAvailableZonesAvailableResources extends $tea.Model {
  type?: string;
  supportedResources?: DescribeResourcesModificationResponseBodyAvailableZonesAvailableResourcesSupportedResources[];
  static names(): { [key: string]: string } {
    return {
      type: 'Type',
      supportedResources: 'SupportedResources',
    };
  }

  static types(): { [key: string]: any } {
    return {
      type: 'string',
      supportedResources: { 'type': 'array', 'itemType': DescribeResourcesModificationResponseBodyAvailableZonesAvailableResourcesSupportedResources },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourcesModificationResponseBodyAvailableZones extends $tea.Model {
  status?: string;
  zoneId?: string;
  statusCategory?: string;
  regionId?: string;
  availableResources?: DescribeResourcesModificationResponseBodyAvailableZonesAvailableResources[];
  static names(): { [key: string]: string } {
    return {
      status: 'Status',
      zoneId: 'ZoneId',
      statusCategory: 'StatusCategory',
      regionId: 'RegionId',
      availableResources: 'AvailableResources',
    };
  }

  static types(): { [key: string]: any } {
    return {
      status: 'string',
      zoneId: 'string',
      statusCategory: 'string',
      regionId: 'string',
      availableResources: { 'type': 'array', 'itemType': DescribeResourcesModificationResponseBodyAvailableZonesAvailableResources },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRouterInterfacesRequestFilter extends $tea.Model {
  key?: string;
  value?: string[];
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRouterInterfacesResponseBodyRouterInterfaceSet extends $tea.Model {
  healthCheckTargetIp?: string;
  creationTime?: string;
  status?: string;
  spec?: string;
  oppositeInterfaceId?: string;
  routerInterfaceId?: string;
  chargeType?: string;
  oppositeRouterType?: string;
  oppositeInterfaceOwnerId?: string;
  description?: string;
  name?: string;
  oppositeRouterId?: string;
  oppositeInterfaceSpec?: string;
  routerId?: string;
  oppositeInterfaceBusinessStatus?: string;
  connectedTime?: string;
  healthCheckSourceIp?: string;
  oppositeInterfaceStatus?: string;
  endTime?: string;
  oppositeRegionId?: string;
  oppositeAccessPointId?: string;
  businessStatus?: string;
  routerType?: string;
  role?: string;
  accessPointId?: string;
  static names(): { [key: string]: string } {
    return {
      healthCheckTargetIp: 'HealthCheckTargetIp',
      creationTime: 'CreationTime',
      status: 'Status',
      spec: 'Spec',
      oppositeInterfaceId: 'OppositeInterfaceId',
      routerInterfaceId: 'RouterInterfaceId',
      chargeType: 'ChargeType',
      oppositeRouterType: 'OppositeRouterType',
      oppositeInterfaceOwnerId: 'OppositeInterfaceOwnerId',
      description: 'Description',
      name: 'Name',
      oppositeRouterId: 'OppositeRouterId',
      oppositeInterfaceSpec: 'OppositeInterfaceSpec',
      routerId: 'RouterId',
      oppositeInterfaceBusinessStatus: 'OppositeInterfaceBusinessStatus',
      connectedTime: 'ConnectedTime',
      healthCheckSourceIp: 'HealthCheckSourceIp',
      oppositeInterfaceStatus: 'OppositeInterfaceStatus',
      endTime: 'EndTime',
      oppositeRegionId: 'OppositeRegionId',
      oppositeAccessPointId: 'OppositeAccessPointId',
      businessStatus: 'BusinessStatus',
      routerType: 'RouterType',
      role: 'Role',
      accessPointId: 'AccessPointId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      healthCheckTargetIp: 'string',
      creationTime: 'string',
      status: 'string',
      spec: 'string',
      oppositeInterfaceId: 'string',
      routerInterfaceId: 'string',
      chargeType: 'string',
      oppositeRouterType: 'string',
      oppositeInterfaceOwnerId: 'string',
      description: 'string',
      name: 'string',
      oppositeRouterId: 'string',
      oppositeInterfaceSpec: 'string',
      routerId: 'string',
      oppositeInterfaceBusinessStatus: 'string',
      connectedTime: 'string',
      healthCheckSourceIp: 'string',
      oppositeInterfaceStatus: 'string',
      endTime: 'string',
      oppositeRegionId: 'string',
      oppositeAccessPointId: 'string',
      businessStatus: 'string',
      routerType: 'string',
      role: 'string',
      accessPointId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRouteTablesResponseBodyRouteTablesRouteEntrysNextHops extends $tea.Model {
  weight?: number;
  nextHopId?: string;
  nextHopType?: string;
  enabled?: number;
  static names(): { [key: string]: string } {
    return {
      weight: 'Weight',
      nextHopId: 'NextHopId',
      nextHopType: 'NextHopType',
      enabled: 'Enabled',
    };
  }

  static types(): { [key: string]: any } {
    return {
      weight: 'number',
      nextHopId: 'string',
      nextHopType: 'string',
      enabled: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRouteTablesResponseBodyRouteTablesRouteEntrys extends $tea.Model {
  type?: string;
  status?: string;
  nextHopType?: string;
  destinationCidrBlock?: string;
  nextHops?: DescribeRouteTablesResponseBodyRouteTablesRouteEntrysNextHops[];
  instanceId?: string;
  routeTableId?: string;
  static names(): { [key: string]: string } {
    return {
      type: 'Type',
      status: 'Status',
      nextHopType: 'NextHopType',
      destinationCidrBlock: 'DestinationCidrBlock',
      nextHops: 'NextHops',
      instanceId: 'InstanceId',
      routeTableId: 'RouteTableId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      type: 'string',
      status: 'string',
      nextHopType: 'string',
      destinationCidrBlock: 'string',
      nextHops: { 'type': 'array', 'itemType': DescribeRouteTablesResponseBodyRouteTablesRouteEntrysNextHops },
      instanceId: 'string',
      routeTableId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRouteTablesResponseBodyRouteTables extends $tea.Model {
  creationTime?: string;
  VRouterId?: string;
  routeEntrys?: DescribeRouteTablesResponseBodyRouteTablesRouteEntrys[];
  resourceGroupId?: string;
  routeTableType?: string;
  routeTableId?: string;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      VRouterId: 'VRouterId',
      routeEntrys: 'RouteEntrys',
      resourceGroupId: 'ResourceGroupId',
      routeTableType: 'RouteTableType',
      routeTableId: 'RouteTableId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      VRouterId: 'string',
      routeEntrys: { 'type': 'array', 'itemType': DescribeRouteTablesResponseBodyRouteTablesRouteEntrys },
      resourceGroupId: 'string',
      routeTableType: 'string',
      routeTableId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSecurityGroupAttributeResponseBodyPermissions extends $tea.Model {
  direction?: string;
  sourceGroupId?: string;
  destGroupOwnerAccount?: string;
  sourceCidrIp?: string;
  ipv6DestCidrIp?: string;
  ipv6SourceCidrIp?: string;
  createTime?: string;
  destGroupId?: string;
  ipProtocol?: string;
  destCidrIp?: string;
  priority?: string;
  destGroupName?: string;
  nicType?: string;
  policy?: string;
  description?: string;
  portRange?: string;
  sourceGroupOwnerAccount?: string;
  sourceGroupName?: string;
  sourcePortRange?: string;
  static names(): { [key: string]: string } {
    return {
      direction: 'Direction',
      sourceGroupId: 'SourceGroupId',
      destGroupOwnerAccount: 'DestGroupOwnerAccount',
      sourceCidrIp: 'SourceCidrIp',
      ipv6DestCidrIp: 'Ipv6DestCidrIp',
      ipv6SourceCidrIp: 'Ipv6SourceCidrIp',
      createTime: 'CreateTime',
      destGroupId: 'DestGroupId',
      ipProtocol: 'IpProtocol',
      destCidrIp: 'DestCidrIp',
      priority: 'Priority',
      destGroupName: 'DestGroupName',
      nicType: 'NicType',
      policy: 'Policy',
      description: 'Description',
      portRange: 'PortRange',
      sourceGroupOwnerAccount: 'SourceGroupOwnerAccount',
      sourceGroupName: 'SourceGroupName',
      sourcePortRange: 'SourcePortRange',
    };
  }

  static types(): { [key: string]: any } {
    return {
      direction: 'string',
      sourceGroupId: 'string',
      destGroupOwnerAccount: 'string',
      sourceCidrIp: 'string',
      ipv6DestCidrIp: 'string',
      ipv6SourceCidrIp: 'string',
      createTime: 'string',
      destGroupId: 'string',
      ipProtocol: 'string',
      destCidrIp: 'string',
      priority: 'string',
      destGroupName: 'string',
      nicType: 'string',
      policy: 'string',
      description: 'string',
      portRange: 'string',
      sourceGroupOwnerAccount: 'string',
      sourceGroupName: 'string',
      sourcePortRange: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSecurityGroupReferencesResponseBodySecurityGroupReferencesReferencingSecurityGroups extends $tea.Model {
  securityGroupId?: string;
  aliUid?: string;
  static names(): { [key: string]: string } {
    return {
      securityGroupId: 'SecurityGroupId',
      aliUid: 'AliUid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      securityGroupId: 'string',
      aliUid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSecurityGroupReferencesResponseBodySecurityGroupReferences extends $tea.Model {
  securityGroupId?: string;
  referencingSecurityGroups?: DescribeSecurityGroupReferencesResponseBodySecurityGroupReferencesReferencingSecurityGroups[];
  static names(): { [key: string]: string } {
    return {
      securityGroupId: 'SecurityGroupId',
      referencingSecurityGroups: 'ReferencingSecurityGroups',
    };
  }

  static types(): { [key: string]: any } {
    return {
      securityGroupId: 'string',
      referencingSecurityGroups: { 'type': 'array', 'itemType': DescribeSecurityGroupReferencesResponseBodySecurityGroupReferencesReferencingSecurityGroups },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSecurityGroupsRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSecurityGroupsResponseBodySecurityGroupsTags extends $tea.Model {
  tagValue?: string;
  tagKey?: string;
  static names(): { [key: string]: string } {
    return {
      tagValue: 'TagValue',
      tagKey: 'TagKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagValue: 'string',
      tagKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSecurityGroupsResponseBodySecurityGroups extends $tea.Model {
  creationTime?: string;
  vpcId?: string;
  securityGroupId?: string;
  tags?: DescribeSecurityGroupsResponseBodySecurityGroupsTags[];
  serviceID?: number;
  serviceManaged?: boolean;
  description?: string;
  resourceGroupId?: string;
  securityGroupName?: string;
  ecsCount?: number;
  securityGroupType?: string;
  availableInstanceAmount?: number;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      vpcId: 'VpcId',
      securityGroupId: 'SecurityGroupId',
      tags: 'Tags',
      serviceID: 'ServiceID',
      serviceManaged: 'ServiceManaged',
      description: 'Description',
      resourceGroupId: 'ResourceGroupId',
      securityGroupName: 'SecurityGroupName',
      ecsCount: 'EcsCount',
      securityGroupType: 'SecurityGroupType',
      availableInstanceAmount: 'AvailableInstanceAmount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      vpcId: 'string',
      securityGroupId: 'string',
      tags: { 'type': 'array', 'itemType': DescribeSecurityGroupsResponseBodySecurityGroupsTags },
      serviceID: 'number',
      serviceManaged: 'boolean',
      description: 'string',
      resourceGroupId: 'string',
      securityGroupName: 'string',
      ecsCount: 'number',
      securityGroupType: 'string',
      availableInstanceAmount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSendFileResultsResponseBodyInvocationsInvokeInstances extends $tea.Model {
  creationTime?: string;
  startTime?: string;
  invocationStatus?: string;
  finishTime?: string;
  updateTime?: string;
  errorInfo?: string;
  errorCode?: string;
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      startTime: 'StartTime',
      invocationStatus: 'InvocationStatus',
      finishTime: 'FinishTime',
      updateTime: 'UpdateTime',
      errorInfo: 'ErrorInfo',
      errorCode: 'ErrorCode',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      startTime: 'string',
      invocationStatus: 'string',
      finishTime: 'string',
      updateTime: 'string',
      errorInfo: 'string',
      errorCode: 'string',
      instanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSendFileResultsResponseBodyInvocations extends $tea.Model {
  creationTime?: string;
  contentType?: string;
  invocationStatus?: string;
  targetDir?: string;
  invokeInstances?: DescribeSendFileResultsResponseBodyInvocationsInvokeInstances[];
  fileOwner?: string;
  vmCount?: number;
  description?: string;
  fileMode?: string;
  fileGroup?: string;
  name?: string;
  invokeId?: string;
  content?: string;
  overwrite?: string;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      contentType: 'ContentType',
      invocationStatus: 'InvocationStatus',
      targetDir: 'TargetDir',
      invokeInstances: 'InvokeInstances',
      fileOwner: 'FileOwner',
      vmCount: 'VmCount',
      description: 'Description',
      fileMode: 'FileMode',
      fileGroup: 'FileGroup',
      name: 'Name',
      invokeId: 'InvokeId',
      content: 'Content',
      overwrite: 'Overwrite',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      contentType: 'string',
      invocationStatus: 'string',
      targetDir: 'string',
      invokeInstances: { 'type': 'array', 'itemType': DescribeSendFileResultsResponseBodyInvocationsInvokeInstances },
      fileOwner: 'string',
      vmCount: 'number',
      description: 'string',
      fileMode: 'string',
      fileGroup: 'string',
      name: 'string',
      invokeId: 'string',
      content: 'string',
      overwrite: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSnapshotLinksResponseBodySnapshotLinks extends $tea.Model {
  instantAccess?: boolean;
  totalSize?: number;
  sourceDiskName?: string;
  sourceDiskSize?: number;
  sourceDiskType?: string;
  instanceId?: string;
  totalCount?: number;
  snapshotLinkId?: string;
  regionId?: string;
  sourceDiskId?: string;
  instanceName?: string;
  category?: string;
  static names(): { [key: string]: string } {
    return {
      instantAccess: 'InstantAccess',
      totalSize: 'TotalSize',
      sourceDiskName: 'SourceDiskName',
      sourceDiskSize: 'SourceDiskSize',
      sourceDiskType: 'SourceDiskType',
      instanceId: 'InstanceId',
      totalCount: 'TotalCount',
      snapshotLinkId: 'SnapshotLinkId',
      regionId: 'RegionId',
      sourceDiskId: 'SourceDiskId',
      instanceName: 'InstanceName',
      category: 'Category',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instantAccess: 'boolean',
      totalSize: 'number',
      sourceDiskName: 'string',
      sourceDiskSize: 'number',
      sourceDiskType: 'string',
      instanceId: 'string',
      totalCount: 'number',
      snapshotLinkId: 'string',
      regionId: 'string',
      sourceDiskId: 'string',
      instanceName: 'string',
      category: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSnapshotMonitorDataResponseBodyMonitorData extends $tea.Model {
  size?: number;
  timeStamp?: string;
  static names(): { [key: string]: string } {
    return {
      size: 'Size',
      timeStamp: 'TimeStamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      size: 'number',
      timeStamp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSnapshotPackageResponseBodySnapshotPackages extends $tea.Model {
  displayName?: string;
  endTime?: string;
  startTime?: string;
  initCapacity?: number;
  static names(): { [key: string]: string } {
    return {
      displayName: 'DisplayName',
      endTime: 'EndTime',
      startTime: 'StartTime',
      initCapacity: 'InitCapacity',
    };
  }

  static types(): { [key: string]: any } {
    return {
      displayName: 'string',
      endTime: 'string',
      startTime: 'string',
      initCapacity: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSnapshotsRequestFilter extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSnapshotsRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSnapshotsResponseBodySnapshotsTags extends $tea.Model {
  tagValue?: string;
  tagKey?: string;
  static names(): { [key: string]: string } {
    return {
      tagValue: 'TagValue',
      tagKey: 'TagKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagValue: 'string',
      tagKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSnapshotsResponseBodySnapshots extends $tea.Model {
  creationTime?: string;
  status?: string;
  instantAccess?: boolean;
  retentionDays?: number;
  sourceDiskSize?: string;
  tags?: DescribeSnapshotsResponseBodySnapshotsTags[];
  lastModifiedTime?: string;
  encrypted?: boolean;
  sourceDiskId?: string;
  description?: string;
  instantAccessRetentionDays?: number;
  KMSKeyId?: string;
  progress?: string;
  remainTime?: number;
  sourceDiskType?: string;
  sourceStorageType?: string;
  usage?: string;
  snapshotType?: string;
  snapshotName?: string;
  snapshotId?: string;
  resourceGroupId?: string;
  category?: string;
  snapshotSN?: string;
  productCode?: string;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      status: 'Status',
      instantAccess: 'InstantAccess',
      retentionDays: 'RetentionDays',
      sourceDiskSize: 'SourceDiskSize',
      tags: 'Tags',
      lastModifiedTime: 'LastModifiedTime',
      encrypted: 'Encrypted',
      sourceDiskId: 'SourceDiskId',
      description: 'Description',
      instantAccessRetentionDays: 'InstantAccessRetentionDays',
      KMSKeyId: 'KMSKeyId',
      progress: 'Progress',
      remainTime: 'RemainTime',
      sourceDiskType: 'SourceDiskType',
      sourceStorageType: 'SourceStorageType',
      usage: 'Usage',
      snapshotType: 'SnapshotType',
      snapshotName: 'SnapshotName',
      snapshotId: 'SnapshotId',
      resourceGroupId: 'ResourceGroupId',
      category: 'Category',
      snapshotSN: 'SnapshotSN',
      productCode: 'ProductCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      status: 'string',
      instantAccess: 'boolean',
      retentionDays: 'number',
      sourceDiskSize: 'string',
      tags: { 'type': 'array', 'itemType': DescribeSnapshotsResponseBodySnapshotsTags },
      lastModifiedTime: 'string',
      encrypted: 'boolean',
      sourceDiskId: 'string',
      description: 'string',
      instantAccessRetentionDays: 'number',
      KMSKeyId: 'string',
      progress: 'string',
      remainTime: 'number',
      sourceDiskType: 'string',
      sourceStorageType: 'string',
      usage: 'string',
      snapshotType: 'string',
      snapshotName: 'string',
      snapshotId: 'string',
      resourceGroupId: 'string',
      category: 'string',
      snapshotSN: 'string',
      productCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSpotAdviceResponseBodyAvailableSpotZonesAvailableSpotResources extends $tea.Model {
  interruptRateDesc?: string;
  averageSpotDiscount?: number;
  instanceType?: string;
  interruptionRate?: number;
  static names(): { [key: string]: string } {
    return {
      interruptRateDesc: 'InterruptRateDesc',
      averageSpotDiscount: 'AverageSpotDiscount',
      instanceType: 'InstanceType',
      interruptionRate: 'InterruptionRate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      interruptRateDesc: 'string',
      averageSpotDiscount: 'number',
      instanceType: 'string',
      interruptionRate: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSpotAdviceResponseBodyAvailableSpotZones extends $tea.Model {
  availableSpotResources?: DescribeSpotAdviceResponseBodyAvailableSpotZonesAvailableSpotResources[];
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      availableSpotResources: 'AvailableSpotResources',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      availableSpotResources: { 'type': 'array', 'itemType': DescribeSpotAdviceResponseBodyAvailableSpotZonesAvailableSpotResources },
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSpotPriceHistoryResponseBodySpotPrices extends $tea.Model {
  ioOptimized?: string;
  zoneId?: string;
  spotPrice?: number;
  timestamp?: string;
  networkType?: string;
  instanceType?: string;
  originPrice?: number;
  static names(): { [key: string]: string } {
    return {
      ioOptimized: 'IoOptimized',
      zoneId: 'ZoneId',
      spotPrice: 'SpotPrice',
      timestamp: 'Timestamp',
      networkType: 'NetworkType',
      instanceType: 'InstanceType',
      originPrice: 'OriginPrice',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ioOptimized: 'string',
      zoneId: 'string',
      spotPrice: 'number',
      timestamp: 'string',
      networkType: 'string',
      instanceType: 'string',
      originPrice: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeStorageCapacityUnitsResponseBodyStorageCapacityUnits extends $tea.Model {
  creationTime?: string;
  status?: string;
  startTime?: string;
  capacity?: number;
  description?: string;
  allocationStatus?: string;
  expiredTime?: string;
  storageCapacityUnitId?: string;
  name?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      status: 'Status',
      startTime: 'StartTime',
      capacity: 'Capacity',
      description: 'Description',
      allocationStatus: 'AllocationStatus',
      expiredTime: 'ExpiredTime',
      storageCapacityUnitId: 'StorageCapacityUnitId',
      name: 'Name',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      status: 'string',
      startTime: 'string',
      capacity: 'number',
      description: 'string',
      allocationStatus: 'string',
      expiredTime: 'string',
      storageCapacityUnitId: 'string',
      name: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeStorageSetDetailsResponseBodyDisks extends $tea.Model {
  creationTime?: string;
  diskName?: string;
  zoneId?: string;
  storageSetId?: string;
  diskId?: string;
  category?: string;
  storageSetPartitionNumber?: number;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      diskName: 'DiskName',
      zoneId: 'ZoneId',
      storageSetId: 'StorageSetId',
      diskId: 'DiskId',
      category: 'Category',
      storageSetPartitionNumber: 'StorageSetPartitionNumber',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      diskName: 'string',
      zoneId: 'string',
      storageSetId: 'string',
      diskId: 'string',
      category: 'string',
      storageSetPartitionNumber: 'number',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeStorageSetsResponseBodyStorageSets extends $tea.Model {
  creationTime?: string;
  description?: string;
  zoneId?: string;
  storageSetId?: string;
  storageSetPartitionNumber?: number;
  storageSetName?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      description: 'Description',
      zoneId: 'ZoneId',
      storageSetId: 'StorageSetId',
      storageSetPartitionNumber: 'StorageSetPartitionNumber',
      storageSetName: 'StorageSetName',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      description: 'string',
      zoneId: 'string',
      storageSetId: 'string',
      storageSetPartitionNumber: 'number',
      storageSetName: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTagsRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTagsResponseBodyTagsResourceTypeCount extends $tea.Model {
  instance?: number;
  image?: number;
  snapshotPolicy?: number;
  ddh?: number;
  securitygroup?: number;
  snapshot?: number;
  reservedInstance?: number;
  eni?: number;
  launchTemplate?: number;
  keyPair?: number;
  disk?: number;
  volume?: number;
  static names(): { [key: string]: string } {
    return {
      instance: 'Instance',
      image: 'Image',
      snapshotPolicy: 'SnapshotPolicy',
      ddh: 'Ddh',
      securitygroup: 'Securitygroup',
      snapshot: 'Snapshot',
      reservedInstance: 'ReservedInstance',
      eni: 'Eni',
      launchTemplate: 'LaunchTemplate',
      keyPair: 'KeyPair',
      disk: 'Disk',
      volume: 'Volume',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instance: 'number',
      image: 'number',
      snapshotPolicy: 'number',
      ddh: 'number',
      securitygroup: 'number',
      snapshot: 'number',
      reservedInstance: 'number',
      eni: 'number',
      launchTemplate: 'number',
      keyPair: 'number',
      disk: 'number',
      volume: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTagsResponseBodyTags extends $tea.Model {
  resourceTypeCount?: DescribeTagsResponseBodyTagsResourceTypeCount;
  tagValue?: string;
  tagKey?: string;
  static names(): { [key: string]: string } {
    return {
      resourceTypeCount: 'ResourceTypeCount',
      tagValue: 'TagValue',
      tagKey: 'TagKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resourceTypeCount: DescribeTagsResponseBodyTagsResourceTypeCount,
      tagValue: 'string',
      tagKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTaskAttributeResponseBodyOperationProgressSetRelatedItemSet extends $tea.Model {
  value?: string;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      value: 'Value',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      value: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTaskAttributeResponseBodyOperationProgressSet extends $tea.Model {
  errorCode?: string;
  errorMsg?: string;
  relatedItemSet?: DescribeTaskAttributeResponseBodyOperationProgressSetRelatedItemSet[];
  operationStatus?: string;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMsg: 'ErrorMsg',
      relatedItemSet: 'RelatedItemSet',
      operationStatus: 'OperationStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMsg: 'string',
      relatedItemSet: { 'type': 'array', 'itemType': DescribeTaskAttributeResponseBodyOperationProgressSetRelatedItemSet },
      operationStatus: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTasksResponseBodyTaskSet extends $tea.Model {
  creationTime?: string;
  taskStatus?: string;
  finishedTime?: string;
  supportCancel?: string;
  taskId?: string;
  taskAction?: string;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      taskStatus: 'TaskStatus',
      finishedTime: 'FinishedTime',
      supportCancel: 'SupportCancel',
      taskId: 'TaskId',
      taskAction: 'TaskAction',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      taskStatus: 'string',
      finishedTime: 'string',
      supportCancel: 'string',
      taskId: 'string',
      taskAction: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVirtualBorderRoutersRequestFilter extends $tea.Model {
  key?: string;
  value?: string[];
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSet extends $tea.Model {
  creationTime?: string;
  status?: string;
  vlanInterfaceId?: string;
  circuitCode?: string;
  physicalConnectionOwnerUid?: string;
  localGatewayIp?: string;
  activationTime?: string;
  physicalConnectionBusinessStatus?: string;
  peeringSubnetMask?: string;
  routeTableId?: string;
  description?: string;
  physicalConnectionStatus?: string;
  recoveryTime?: string;
  terminationTime?: string;
  peerGatewayIp?: string;
  name?: string;
  accessPointId?: string;
  vbrId?: string;
  physicalConnectionId?: string;
  vlanId?: number;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      status: 'Status',
      vlanInterfaceId: 'VlanInterfaceId',
      circuitCode: 'CircuitCode',
      physicalConnectionOwnerUid: 'PhysicalConnectionOwnerUid',
      localGatewayIp: 'LocalGatewayIp',
      activationTime: 'ActivationTime',
      physicalConnectionBusinessStatus: 'PhysicalConnectionBusinessStatus',
      peeringSubnetMask: 'PeeringSubnetMask',
      routeTableId: 'RouteTableId',
      description: 'Description',
      physicalConnectionStatus: 'PhysicalConnectionStatus',
      recoveryTime: 'RecoveryTime',
      terminationTime: 'TerminationTime',
      peerGatewayIp: 'PeerGatewayIp',
      name: 'Name',
      accessPointId: 'AccessPointId',
      vbrId: 'VbrId',
      physicalConnectionId: 'PhysicalConnectionId',
      vlanId: 'VlanId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      status: 'string',
      vlanInterfaceId: 'string',
      circuitCode: 'string',
      physicalConnectionOwnerUid: 'string',
      localGatewayIp: 'string',
      activationTime: 'string',
      physicalConnectionBusinessStatus: 'string',
      peeringSubnetMask: 'string',
      routeTableId: 'string',
      description: 'string',
      physicalConnectionStatus: 'string',
      recoveryTime: 'string',
      terminationTime: 'string',
      peerGatewayIp: 'string',
      name: 'string',
      accessPointId: 'string',
      vbrId: 'string',
      physicalConnectionId: 'string',
      vlanId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVirtualBorderRoutersForPhysicalConnectionRequestFilter extends $tea.Model {
  key?: string;
  value?: string[];
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSet extends $tea.Model {
  creationTime?: string;
  circuitCode?: string;
  recoveryTime?: string;
  terminationTime?: string;
  activationTime?: string;
  vbrOwnerUid?: number;
  vbrId?: string;
  vlanId?: number;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      circuitCode: 'CircuitCode',
      recoveryTime: 'RecoveryTime',
      terminationTime: 'TerminationTime',
      activationTime: 'ActivationTime',
      vbrOwnerUid: 'VbrOwnerUid',
      vbrId: 'VbrId',
      vlanId: 'VlanId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      circuitCode: 'string',
      recoveryTime: 'string',
      terminationTime: 'string',
      activationTime: 'string',
      vbrOwnerUid: 'number',
      vbrId: 'string',
      vlanId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVpcsResponseBodyVpcs extends $tea.Model {
  creationTime?: string;
  vpcName?: string;
  status?: string;
  vpcId?: string;
  VRouterId?: string;
  isDefault?: boolean;
  cidrBlock?: string;
  description?: string;
  vSwitchIds?: string[];
  userCidrs?: string[];
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      vpcName: 'VpcName',
      status: 'Status',
      vpcId: 'VpcId',
      VRouterId: 'VRouterId',
      isDefault: 'IsDefault',
      cidrBlock: 'CidrBlock',
      description: 'Description',
      vSwitchIds: 'VSwitchIds',
      userCidrs: 'UserCidrs',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      vpcName: 'string',
      status: 'string',
      vpcId: 'string',
      VRouterId: 'string',
      isDefault: 'boolean',
      cidrBlock: 'string',
      description: 'string',
      vSwitchIds: { 'type': 'array', 'itemType': 'string' },
      userCidrs: { 'type': 'array', 'itemType': 'string' },
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVRoutersResponseBodyVRouters extends $tea.Model {
  vpcId?: string;
  creationTime?: string;
  VRouterId?: string;
  description?: string;
  VRouterName?: string;
  routeTableIds?: string[];
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      vpcId: 'VpcId',
      creationTime: 'CreationTime',
      VRouterId: 'VRouterId',
      description: 'Description',
      VRouterName: 'VRouterName',
      routeTableIds: 'RouteTableIds',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      vpcId: 'string',
      creationTime: 'string',
      VRouterId: 'string',
      description: 'string',
      VRouterName: 'string',
      routeTableIds: { 'type': 'array', 'itemType': 'string' },
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVSwitchesResponseBodyVSwitches extends $tea.Model {
  creationTime?: string;
  status?: string;
  vpcId?: string;
  isDefault?: boolean;
  vSwitchId?: string;
  cidrBlock?: string;
  description?: string;
  availableIpAddressCount?: number;
  resourceGroupId?: string;
  zoneId?: string;
  vSwitchName?: string;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      status: 'Status',
      vpcId: 'VpcId',
      isDefault: 'IsDefault',
      vSwitchId: 'VSwitchId',
      cidrBlock: 'CidrBlock',
      description: 'Description',
      availableIpAddressCount: 'AvailableIpAddressCount',
      resourceGroupId: 'ResourceGroupId',
      zoneId: 'ZoneId',
      vSwitchName: 'VSwitchName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      status: 'string',
      vpcId: 'string',
      isDefault: 'boolean',
      vSwitchId: 'string',
      cidrBlock: 'string',
      description: 'string',
      availableIpAddressCount: 'number',
      resourceGroupId: 'string',
      zoneId: 'string',
      vSwitchName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeZonesResponseBodyZonesAvailableResources extends $tea.Model {
  ioOptimized?: boolean;
  systemDiskCategories?: string[];
  instanceGenerations?: string[];
  dataDiskCategories?: string[];
  instanceTypes?: string[];
  instanceTypeFamilies?: string[];
  networkTypes?: string[];
  static names(): { [key: string]: string } {
    return {
      ioOptimized: 'IoOptimized',
      systemDiskCategories: 'SystemDiskCategories',
      instanceGenerations: 'InstanceGenerations',
      dataDiskCategories: 'DataDiskCategories',
      instanceTypes: 'InstanceTypes',
      instanceTypeFamilies: 'InstanceTypeFamilies',
      networkTypes: 'NetworkTypes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ioOptimized: 'boolean',
      systemDiskCategories: { 'type': 'array', 'itemType': 'string' },
      instanceGenerations: { 'type': 'array', 'itemType': 'string' },
      dataDiskCategories: { 'type': 'array', 'itemType': 'string' },
      instanceTypes: { 'type': 'array', 'itemType': 'string' },
      instanceTypeFamilies: { 'type': 'array', 'itemType': 'string' },
      networkTypes: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeZonesResponseBodyZones extends $tea.Model {
  availableResourceCreation?: string[];
  dedicatedHostGenerations?: string[];
  localName?: string;
  availableInstanceTypes?: string[];
  zoneId?: string;
  availableDiskCategories?: string[];
  availableDedicatedHostTypes?: string[];
  availableVolumeCategories?: string[];
  availableResources?: DescribeZonesResponseBodyZonesAvailableResources[];
  static names(): { [key: string]: string } {
    return {
      availableResourceCreation: 'AvailableResourceCreation',
      dedicatedHostGenerations: 'DedicatedHostGenerations',
      localName: 'LocalName',
      availableInstanceTypes: 'AvailableInstanceTypes',
      zoneId: 'ZoneId',
      availableDiskCategories: 'AvailableDiskCategories',
      availableDedicatedHostTypes: 'AvailableDedicatedHostTypes',
      availableVolumeCategories: 'AvailableVolumeCategories',
      availableResources: 'AvailableResources',
    };
  }

  static types(): { [key: string]: any } {
    return {
      availableResourceCreation: { 'type': 'array', 'itemType': 'string' },
      dedicatedHostGenerations: { 'type': 'array', 'itemType': 'string' },
      localName: 'string',
      availableInstanceTypes: { 'type': 'array', 'itemType': 'string' },
      zoneId: 'string',
      availableDiskCategories: { 'type': 'array', 'itemType': 'string' },
      availableDedicatedHostTypes: { 'type': 'array', 'itemType': 'string' },
      availableVolumeCategories: { 'type': 'array', 'itemType': 'string' },
      availableResources: { 'type': 'array', 'itemType': DescribeZonesResponseBodyZonesAvailableResources },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DetachInstanceRamRoleResponseBodyDetachInstanceRamRoleResultsInstanceRamRoleSets extends $tea.Model {
  ramRoleName?: string;
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      ramRoleName: 'RamRoleName',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ramRoleName: 'string',
      instanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DetachInstanceRamRoleResponseBodyDetachInstanceRamRoleResults extends $tea.Model {
  instanceRamRoleSets?: DetachInstanceRamRoleResponseBodyDetachInstanceRamRoleResultsInstanceRamRoleSets[];
  success?: boolean;
  code?: string;
  message?: string;
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceRamRoleSets: 'InstanceRamRoleSets',
      success: 'Success',
      code: 'Code',
      message: 'Message',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceRamRoleSets: { 'type': 'array', 'itemType': DetachInstanceRamRoleResponseBodyDetachInstanceRamRoleResultsInstanceRamRoleSets },
      success: 'boolean',
      code: 'string',
      message: 'string',
      instanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DetachKeyPairResponseBodyResults extends $tea.Model {
  success?: string;
  code?: string;
  message?: string;
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      success: 'Success',
      code: 'Code',
      message: 'Message',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      success: 'string',
      code: 'string',
      message: 'string',
      instanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportImageRequestDiskDeviceMapping extends $tea.Model {
  diskImSize?: number;
  device?: string;
  OSSBucket?: string;
  format?: string;
  OSSObject?: string;
  diskImageSize?: number;
  static names(): { [key: string]: string } {
    return {
      diskImSize: 'DiskImSize',
      device: 'Device',
      OSSBucket: 'OSSBucket',
      format: 'Format',
      OSSObject: 'OSSObject',
      diskImageSize: 'DiskImageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      diskImSize: 'number',
      device: 'string',
      OSSBucket: 'string',
      format: 'string',
      OSSObject: 'string',
      diskImageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportImageRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportKeyPairRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTagResourcesRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTagResourcesRequestTagFilter extends $tea.Model {
  tagValues?: string[];
  tagKey?: string;
  static names(): { [key: string]: string } {
    return {
      tagValues: 'TagValues',
      tagKey: 'TagKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagValues: { 'type': 'array', 'itemType': 'string' },
      tagKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTagResourcesResponseBodyTagResources extends $tea.Model {
  resourceType?: string;
  tagValue?: string;
  resourceId?: string;
  tagKey?: string;
  static names(): { [key: string]: string } {
    return {
      resourceType: 'ResourceType',
      tagValue: 'TagValue',
      resourceId: 'ResourceId',
      tagKey: 'TagKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resourceType: 'string',
      tagValue: 'string',
      resourceId: 'string',
      tagKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDedicatedHostAttributeRequestNetworkAttributes extends $tea.Model {
  slbUdpTimeout?: number;
  udpTimeout?: number;
  static names(): { [key: string]: string } {
    return {
      slbUdpTimeout: 'SlbUdpTimeout',
      udpTimeout: 'UdpTimeout',
    };
  }

  static types(): { [key: string]: any } {
    return {
      slbUdpTimeout: 'number',
      udpTimeout: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDedicatedHostsChargeTypeResponseBodyFeeOfInstances extends $tea.Model {
  instanceId?: string;
  currency?: string;
  fee?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      currency: 'Currency',
      fee: 'Fee',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      currency: 'string',
      fee: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceAttachmentAttributesRequestPrivatePoolOptions extends $tea.Model {
  matchCriteria?: string;
  id?: string;
  static names(): { [key: string]: string } {
    return {
      matchCriteria: 'MatchCriteria',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      matchCriteria: 'string',
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceChargeTypeResponseBodyFeeOfInstances extends $tea.Model {
  instanceId?: string;
  currency?: string;
  fee?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      currency: 'Currency',
      fee: 'Fee',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      currency: 'string',
      fee: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceMaintenanceAttributesRequestMaintenanceWindow extends $tea.Model {
  endTime?: string;
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceSpecRequestTemporary extends $tea.Model {
  startTime?: string;
  endTime?: string;
  internetMaxBandwidthOut?: number;
  static names(): { [key: string]: string } {
    return {
      startTime: 'StartTime',
      endTime: 'EndTime',
      internetMaxBandwidthOut: 'InternetMaxBandwidthOut',
    };
  }

  static types(): { [key: string]: any } {
    return {
      startTime: 'string',
      endTime: 'string',
      internetMaxBandwidthOut: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceSpecRequestSystemDisk extends $tea.Model {
  category?: string;
  static names(): { [key: string]: string } {
    return {
      category: 'Category',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyPrepayInstanceSpecRequestSystemDisk extends $tea.Model {
  category?: string;
  static names(): { [key: string]: string } {
    return {
      category: 'Category',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyReservedInstancesRequestConfiguration extends $tea.Model {
  reservedInstanceName?: string;
  zoneId?: string;
  scope?: string;
  instanceType?: string;
  instanceAmount?: number;
  static names(): { [key: string]: string } {
    return {
      reservedInstanceName: 'ReservedInstanceName',
      zoneId: 'ZoneId',
      scope: 'Scope',
      instanceType: 'InstanceType',
      instanceAmount: 'InstanceAmount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      reservedInstanceName: 'string',
      zoneId: 'string',
      scope: 'string',
      instanceType: 'string',
      instanceAmount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PurchaseReservedInstancesOfferingRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RebootInstancesResponseBodyInstanceResponses extends $tea.Model {
  currentStatus?: string;
  previousStatus?: string;
  code?: string;
  message?: string;
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      currentStatus: 'CurrentStatus',
      previousStatus: 'PreviousStatus',
      code: 'Code',
      message: 'Message',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentStatus: 'string',
      previousStatus: 'string',
      code: 'string',
      message: 'string',
      instanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReleaseCapacityReservationRequestPrivatePoolOptions extends $tea.Model {
  id?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveTagsRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReplaceSystemDiskRequestSystemDisk extends $tea.Model {
  size?: number;
  static names(): { [key: string]: string } {
    return {
      size: 'Size',
    };
  }

  static types(): { [key: string]: any } {
    return {
      size: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartElasticityAssuranceRequestPrivatePoolOptions extends $tea.Model {
  id?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartInstancesResponseBodyInstanceResponses extends $tea.Model {
  currentStatus?: string;
  previousStatus?: string;
  code?: string;
  message?: string;
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      currentStatus: 'CurrentStatus',
      previousStatus: 'PreviousStatus',
      code: 'Code',
      message: 'Message',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentStatus: 'string',
      previousStatus: 'string',
      code: 'string',
      message: 'string',
      instanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopInstancesResponseBodyInstanceResponses extends $tea.Model {
  currentStatus?: string;
  previousStatus?: string;
  code?: string;
  message?: string;
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      currentStatus: 'CurrentStatus',
      previousStatus: 'PreviousStatus',
      code: 'Code',
      message: 'Message',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentStatus: 'string',
      previousStatus: 'string',
      code: 'string',
      message: 'string',
      instanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TagResourcesRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}


export default class Client extends OpenApi {

  constructor(config: $OpenApi.Config) {
    super(config);
    this._endpointRule = "regional";
    this._endpointMap = {
      'cn-qingdao': "ecs-cn-hangzhou.aliyuncs.com",
      'cn-beijing': "ecs-cn-hangzhou.aliyuncs.com",
      'cn-hangzhou': "ecs-cn-hangzhou.aliyuncs.com",
      'cn-shanghai': "ecs-cn-hangzhou.aliyuncs.com",
      'cn-shenzhen': "ecs-cn-hangzhou.aliyuncs.com",
      'cn-hongkong': "ecs-cn-hangzhou.aliyuncs.com",
      'ap-southeast-1': "ecs-cn-hangzhou.aliyuncs.com",
      'us-west-1': "ecs-cn-hangzhou.aliyuncs.com",
      'us-east-1': "ecs-cn-hangzhou.aliyuncs.com",
      'cn-shanghai-finance-1': "ecs-cn-hangzhou.aliyuncs.com",
      'cn-shenzhen-finance-1': "ecs-cn-hangzhou.aliyuncs.com",
      'cn-north-2-gov-1': "ecs.aliyuncs.com",
      'ap-northeast-2-pop': "ecs.ap-northeast-1.aliyuncs.com",
      'cn-beijing-finance-1': "ecs.aliyuncs.com",
      'cn-beijing-finance-pop': "ecs.aliyuncs.com",
      'cn-beijing-gov-1': "ecs.aliyuncs.com",
      'cn-beijing-nu16-b01': "ecs-cn-hangzhou.aliyuncs.com",
      'cn-edge-1': "ecs.cn-qingdao-nebula.aliyuncs.com",
      'cn-fujian': "ecs-cn-hangzhou.aliyuncs.com",
      'cn-haidian-cm12-c01': "ecs-cn-hangzhou.aliyuncs.com",
      'cn-hangzhou-bj-b01': "ecs-cn-hangzhou.aliyuncs.com",
      'cn-hangzhou-finance': "ecs.aliyuncs.com",
      'cn-hangzhou-internal-prod-1': "ecs-cn-hangzhou.aliyuncs.com",
      'cn-hangzhou-internal-test-1': "ecs-cn-hangzhou.aliyuncs.com",
      'cn-hangzhou-internal-test-2': "ecs-cn-hangzhou.aliyuncs.com",
      'cn-hangzhou-internal-test-3': "ecs-cn-hangzhou.aliyuncs.com",
      'cn-hangzhou-test-306': "ecs-cn-hangzhou.aliyuncs.com",
      'cn-hongkong-finance-pop': "ecs.aliyuncs.com",
      'cn-shanghai-et15-b01': "ecs-cn-hangzhou.aliyuncs.com",
      'cn-shanghai-et2-b01': "ecs-cn-hangzhou.aliyuncs.com",
      'cn-shanghai-inner': "ecs.aliyuncs.com",
      'cn-shanghai-internal-test-1': "ecs-cn-hangzhou.aliyuncs.com",
      'cn-shenzhen-inner': "ecs.aliyuncs.com",
      'cn-shenzhen-st4-d01': "ecs-cn-hangzhou.aliyuncs.com",
      'cn-shenzhen-su18-b01': "ecs-cn-hangzhou.aliyuncs.com",
      'cn-wuhan': "ecs.aliyuncs.com",
      'cn-yushanfang': "ecs.aliyuncs.com",
      'cn-zhangbei-na61-b01': "ecs-cn-hangzhou.aliyuncs.com",
      'cn-zhangjiakou-na62-a01': "ecs.cn-zhangjiakou.aliyuncs.com",
      'cn-zhengzhou-nebula-1': "ecs.cn-qingdao-nebula.aliyuncs.com",
      'eu-west-1-oxs': "ecs.cn-shenzhen-cloudstone.aliyuncs.com",
      'rus-west-1-pop': "ecs.ap-northeast-1.aliyuncs.com",
    };
    this.checkConfig(config);
    this._endpoint = this.getEndpoint("ecs", this._regionId, this._endpointRule, this._network, this._suffix, this._endpointMap, this._endpoint);
  }


  getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: {[key: string ]: string}, endpoint: string): string {
    if (!Util.empty(endpoint)) {
      return endpoint;
    }

    if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
      return endpointMap[regionId];
    }

    return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
  }

  async acceptInquiredSystemEventWithOptions(request: AcceptInquiredSystemEventRequest, runtime: $Util.RuntimeOptions): Promise<AcceptInquiredSystemEventResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<AcceptInquiredSystemEventResponse>(await this.doRPCRequest("AcceptInquiredSystemEvent", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new AcceptInquiredSystemEventResponse({}));
  }

  async acceptInquiredSystemEvent(request: AcceptInquiredSystemEventRequest): Promise<AcceptInquiredSystemEventResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.acceptInquiredSystemEventWithOptions(request, runtime);
  }

  async activateRouterInterfaceWithOptions(request: ActivateRouterInterfaceRequest, runtime: $Util.RuntimeOptions): Promise<ActivateRouterInterfaceResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ActivateRouterInterfaceResponse>(await this.doRPCRequest("ActivateRouterInterface", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new ActivateRouterInterfaceResponse({}));
  }

  async activateRouterInterface(request: ActivateRouterInterfaceRequest): Promise<ActivateRouterInterfaceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.activateRouterInterfaceWithOptions(request, runtime);
  }

  async addBandwidthPackageIpsWithOptions(request: AddBandwidthPackageIpsRequest, runtime: $Util.RuntimeOptions): Promise<AddBandwidthPackageIpsResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<AddBandwidthPackageIpsResponse>(await this.doRPCRequest("AddBandwidthPackageIps", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new AddBandwidthPackageIpsResponse({}));
  }

  async addBandwidthPackageIps(request: AddBandwidthPackageIpsRequest): Promise<AddBandwidthPackageIpsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addBandwidthPackageIpsWithOptions(request, runtime);
  }

  async addTagsWithOptions(request: AddTagsRequest, runtime: $Util.RuntimeOptions): Promise<AddTagsResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<AddTagsResponse>(await this.doRPCRequest("AddTags", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new AddTagsResponse({}));
  }

  async addTags(request: AddTagsRequest): Promise<AddTagsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addTagsWithOptions(request, runtime);
  }

  async allocateDedicatedHostsWithOptions(request: AllocateDedicatedHostsRequest, runtime: $Util.RuntimeOptions): Promise<AllocateDedicatedHostsResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<AllocateDedicatedHostsResponse>(await this.doRPCRequest("AllocateDedicatedHosts", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new AllocateDedicatedHostsResponse({}));
  }

  async allocateDedicatedHosts(request: AllocateDedicatedHostsRequest): Promise<AllocateDedicatedHostsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.allocateDedicatedHostsWithOptions(request, runtime);
  }

  async allocateEipAddressWithOptions(request: AllocateEipAddressRequest, runtime: $Util.RuntimeOptions): Promise<AllocateEipAddressResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<AllocateEipAddressResponse>(await this.doRPCRequest("AllocateEipAddress", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new AllocateEipAddressResponse({}));
  }

  async allocateEipAddress(request: AllocateEipAddressRequest): Promise<AllocateEipAddressResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.allocateEipAddressWithOptions(request, runtime);
  }

  async allocatePublicIpAddressWithOptions(request: AllocatePublicIpAddressRequest, runtime: $Util.RuntimeOptions): Promise<AllocatePublicIpAddressResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<AllocatePublicIpAddressResponse>(await this.doRPCRequest("AllocatePublicIpAddress", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new AllocatePublicIpAddressResponse({}));
  }

  async allocatePublicIpAddress(request: AllocatePublicIpAddressRequest): Promise<AllocatePublicIpAddressResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.allocatePublicIpAddressWithOptions(request, runtime);
  }

  async applyAutoSnapshotPolicyWithOptions(request: ApplyAutoSnapshotPolicyRequest, runtime: $Util.RuntimeOptions): Promise<ApplyAutoSnapshotPolicyResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ApplyAutoSnapshotPolicyResponse>(await this.doRPCRequest("ApplyAutoSnapshotPolicy", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new ApplyAutoSnapshotPolicyResponse({}));
  }

  async applyAutoSnapshotPolicy(request: ApplyAutoSnapshotPolicyRequest): Promise<ApplyAutoSnapshotPolicyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.applyAutoSnapshotPolicyWithOptions(request, runtime);
  }

  async assignIpv6AddressesWithOptions(request: AssignIpv6AddressesRequest, runtime: $Util.RuntimeOptions): Promise<AssignIpv6AddressesResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<AssignIpv6AddressesResponse>(await this.doRPCRequest("AssignIpv6Addresses", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new AssignIpv6AddressesResponse({}));
  }

  async assignIpv6Addresses(request: AssignIpv6AddressesRequest): Promise<AssignIpv6AddressesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.assignIpv6AddressesWithOptions(request, runtime);
  }

  async assignPrivateIpAddressesWithOptions(request: AssignPrivateIpAddressesRequest, runtime: $Util.RuntimeOptions): Promise<AssignPrivateIpAddressesResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<AssignPrivateIpAddressesResponse>(await this.doRPCRequest("AssignPrivateIpAddresses", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new AssignPrivateIpAddressesResponse({}));
  }

  async assignPrivateIpAddresses(request: AssignPrivateIpAddressesRequest): Promise<AssignPrivateIpAddressesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.assignPrivateIpAddressesWithOptions(request, runtime);
  }

  async associateEipAddressWithOptions(request: AssociateEipAddressRequest, runtime: $Util.RuntimeOptions): Promise<AssociateEipAddressResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<AssociateEipAddressResponse>(await this.doRPCRequest("AssociateEipAddress", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new AssociateEipAddressResponse({}));
  }

  async associateEipAddress(request: AssociateEipAddressRequest): Promise<AssociateEipAddressResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.associateEipAddressWithOptions(request, runtime);
  }

  async associateHaVipWithOptions(request: AssociateHaVipRequest, runtime: $Util.RuntimeOptions): Promise<AssociateHaVipResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<AssociateHaVipResponse>(await this.doRPCRequest("AssociateHaVip", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new AssociateHaVipResponse({}));
  }

  async associateHaVip(request: AssociateHaVipRequest): Promise<AssociateHaVipResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.associateHaVipWithOptions(request, runtime);
  }

  async attachClassicLinkVpcWithOptions(request: AttachClassicLinkVpcRequest, runtime: $Util.RuntimeOptions): Promise<AttachClassicLinkVpcResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<AttachClassicLinkVpcResponse>(await this.doRPCRequest("AttachClassicLinkVpc", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new AttachClassicLinkVpcResponse({}));
  }

  async attachClassicLinkVpc(request: AttachClassicLinkVpcRequest): Promise<AttachClassicLinkVpcResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.attachClassicLinkVpcWithOptions(request, runtime);
  }

  async attachDiskWithOptions(request: AttachDiskRequest, runtime: $Util.RuntimeOptions): Promise<AttachDiskResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<AttachDiskResponse>(await this.doRPCRequest("AttachDisk", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new AttachDiskResponse({}));
  }

  async attachDisk(request: AttachDiskRequest): Promise<AttachDiskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.attachDiskWithOptions(request, runtime);
  }

  async attachInstanceRamRoleWithOptions(request: AttachInstanceRamRoleRequest, runtime: $Util.RuntimeOptions): Promise<AttachInstanceRamRoleResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<AttachInstanceRamRoleResponse>(await this.doRPCRequest("AttachInstanceRamRole", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new AttachInstanceRamRoleResponse({}));
  }

  async attachInstanceRamRole(request: AttachInstanceRamRoleRequest): Promise<AttachInstanceRamRoleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.attachInstanceRamRoleWithOptions(request, runtime);
  }

  async attachKeyPairWithOptions(request: AttachKeyPairRequest, runtime: $Util.RuntimeOptions): Promise<AttachKeyPairResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<AttachKeyPairResponse>(await this.doRPCRequest("AttachKeyPair", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new AttachKeyPairResponse({}));
  }

  async attachKeyPair(request: AttachKeyPairRequest): Promise<AttachKeyPairResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.attachKeyPairWithOptions(request, runtime);
  }

  async attachNetworkInterfaceWithOptions(request: AttachNetworkInterfaceRequest, runtime: $Util.RuntimeOptions): Promise<AttachNetworkInterfaceResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<AttachNetworkInterfaceResponse>(await this.doRPCRequest("AttachNetworkInterface", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new AttachNetworkInterfaceResponse({}));
  }

  async attachNetworkInterface(request: AttachNetworkInterfaceRequest): Promise<AttachNetworkInterfaceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.attachNetworkInterfaceWithOptions(request, runtime);
  }

  async authorizeSecurityGroupWithOptions(request: AuthorizeSecurityGroupRequest, runtime: $Util.RuntimeOptions): Promise<AuthorizeSecurityGroupResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<AuthorizeSecurityGroupResponse>(await this.doRPCRequest("AuthorizeSecurityGroup", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new AuthorizeSecurityGroupResponse({}));
  }

  async authorizeSecurityGroup(request: AuthorizeSecurityGroupRequest): Promise<AuthorizeSecurityGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.authorizeSecurityGroupWithOptions(request, runtime);
  }

  async authorizeSecurityGroupEgressWithOptions(request: AuthorizeSecurityGroupEgressRequest, runtime: $Util.RuntimeOptions): Promise<AuthorizeSecurityGroupEgressResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<AuthorizeSecurityGroupEgressResponse>(await this.doRPCRequest("AuthorizeSecurityGroupEgress", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new AuthorizeSecurityGroupEgressResponse({}));
  }

  async authorizeSecurityGroupEgress(request: AuthorizeSecurityGroupEgressRequest): Promise<AuthorizeSecurityGroupEgressResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.authorizeSecurityGroupEgressWithOptions(request, runtime);
  }

  async cancelAutoSnapshotPolicyWithOptions(request: CancelAutoSnapshotPolicyRequest, runtime: $Util.RuntimeOptions): Promise<CancelAutoSnapshotPolicyResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<CancelAutoSnapshotPolicyResponse>(await this.doRPCRequest("CancelAutoSnapshotPolicy", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new CancelAutoSnapshotPolicyResponse({}));
  }

  async cancelAutoSnapshotPolicy(request: CancelAutoSnapshotPolicyRequest): Promise<CancelAutoSnapshotPolicyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.cancelAutoSnapshotPolicyWithOptions(request, runtime);
  }

  async cancelCopyImageWithOptions(request: CancelCopyImageRequest, runtime: $Util.RuntimeOptions): Promise<CancelCopyImageResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<CancelCopyImageResponse>(await this.doRPCRequest("CancelCopyImage", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new CancelCopyImageResponse({}));
  }

  async cancelCopyImage(request: CancelCopyImageRequest): Promise<CancelCopyImageResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.cancelCopyImageWithOptions(request, runtime);
  }

  async cancelPhysicalConnectionWithOptions(request: CancelPhysicalConnectionRequest, runtime: $Util.RuntimeOptions): Promise<CancelPhysicalConnectionResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<CancelPhysicalConnectionResponse>(await this.doRPCRequest("CancelPhysicalConnection", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new CancelPhysicalConnectionResponse({}));
  }

  async cancelPhysicalConnection(request: CancelPhysicalConnectionRequest): Promise<CancelPhysicalConnectionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.cancelPhysicalConnectionWithOptions(request, runtime);
  }

  async cancelSimulatedSystemEventsWithOptions(request: CancelSimulatedSystemEventsRequest, runtime: $Util.RuntimeOptions): Promise<CancelSimulatedSystemEventsResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<CancelSimulatedSystemEventsResponse>(await this.doRPCRequest("CancelSimulatedSystemEvents", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new CancelSimulatedSystemEventsResponse({}));
  }

  async cancelSimulatedSystemEvents(request: CancelSimulatedSystemEventsRequest): Promise<CancelSimulatedSystemEventsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.cancelSimulatedSystemEventsWithOptions(request, runtime);
  }

  async cancelTaskWithOptions(request: CancelTaskRequest, runtime: $Util.RuntimeOptions): Promise<CancelTaskResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<CancelTaskResponse>(await this.doRPCRequest("CancelTask", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new CancelTaskResponse({}));
  }

  async cancelTask(request: CancelTaskRequest): Promise<CancelTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.cancelTaskWithOptions(request, runtime);
  }

  async connectRouterInterfaceWithOptions(request: ConnectRouterInterfaceRequest, runtime: $Util.RuntimeOptions): Promise<ConnectRouterInterfaceResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ConnectRouterInterfaceResponse>(await this.doRPCRequest("ConnectRouterInterface", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new ConnectRouterInterfaceResponse({}));
  }

  async connectRouterInterface(request: ConnectRouterInterfaceRequest): Promise<ConnectRouterInterfaceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.connectRouterInterfaceWithOptions(request, runtime);
  }

  async convertNatPublicIpToEipWithOptions(request: ConvertNatPublicIpToEipRequest, runtime: $Util.RuntimeOptions): Promise<ConvertNatPublicIpToEipResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ConvertNatPublicIpToEipResponse>(await this.doRPCRequest("ConvertNatPublicIpToEip", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new ConvertNatPublicIpToEipResponse({}));
  }

  async convertNatPublicIpToEip(request: ConvertNatPublicIpToEipRequest): Promise<ConvertNatPublicIpToEipResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.convertNatPublicIpToEipWithOptions(request, runtime);
  }

  async copyImageWithOptions(request: CopyImageRequest, runtime: $Util.RuntimeOptions): Promise<CopyImageResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<CopyImageResponse>(await this.doRPCRequest("CopyImage", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new CopyImageResponse({}));
  }

  async copyImage(request: CopyImageRequest): Promise<CopyImageResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.copyImageWithOptions(request, runtime);
  }

  async copySnapshotWithOptions(request: CopySnapshotRequest, runtime: $Util.RuntimeOptions): Promise<CopySnapshotResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<CopySnapshotResponse>(await this.doRPCRequest("CopySnapshot", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new CopySnapshotResponse({}));
  }

  async copySnapshot(request: CopySnapshotRequest): Promise<CopySnapshotResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.copySnapshotWithOptions(request, runtime);
  }

  async createAutoProvisioningGroupWithOptions(request: CreateAutoProvisioningGroupRequest, runtime: $Util.RuntimeOptions): Promise<CreateAutoProvisioningGroupResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<CreateAutoProvisioningGroupResponse>(await this.doRPCRequest("CreateAutoProvisioningGroup", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new CreateAutoProvisioningGroupResponse({}));
  }

  async createAutoProvisioningGroup(request: CreateAutoProvisioningGroupRequest): Promise<CreateAutoProvisioningGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createAutoProvisioningGroupWithOptions(request, runtime);
  }

  async createAutoSnapshotPolicyWithOptions(request: CreateAutoSnapshotPolicyRequest, runtime: $Util.RuntimeOptions): Promise<CreateAutoSnapshotPolicyResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<CreateAutoSnapshotPolicyResponse>(await this.doRPCRequest("CreateAutoSnapshotPolicy", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new CreateAutoSnapshotPolicyResponse({}));
  }

  async createAutoSnapshotPolicy(request: CreateAutoSnapshotPolicyRequest): Promise<CreateAutoSnapshotPolicyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createAutoSnapshotPolicyWithOptions(request, runtime);
  }

  async createCapacityReservationWithOptions(request: CreateCapacityReservationRequest, runtime: $Util.RuntimeOptions): Promise<CreateCapacityReservationResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<CreateCapacityReservationResponse>(await this.doRPCRequest("CreateCapacityReservation", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new CreateCapacityReservationResponse({}));
  }

  async createCapacityReservation(request: CreateCapacityReservationRequest): Promise<CreateCapacityReservationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createCapacityReservationWithOptions(request, runtime);
  }

  async createCommandWithOptions(request: CreateCommandRequest, runtime: $Util.RuntimeOptions): Promise<CreateCommandResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<CreateCommandResponse>(await this.doRPCRequest("CreateCommand", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new CreateCommandResponse({}));
  }

  async createCommand(request: CreateCommandRequest): Promise<CreateCommandResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createCommandWithOptions(request, runtime);
  }

  async createDedicatedHostClusterWithOptions(request: CreateDedicatedHostClusterRequest, runtime: $Util.RuntimeOptions): Promise<CreateDedicatedHostClusterResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<CreateDedicatedHostClusterResponse>(await this.doRPCRequest("CreateDedicatedHostCluster", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new CreateDedicatedHostClusterResponse({}));
  }

  async createDedicatedHostCluster(request: CreateDedicatedHostClusterRequest): Promise<CreateDedicatedHostClusterResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createDedicatedHostClusterWithOptions(request, runtime);
  }

  async createDemandWithOptions(request: CreateDemandRequest, runtime: $Util.RuntimeOptions): Promise<CreateDemandResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<CreateDemandResponse>(await this.doRPCRequest("CreateDemand", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new CreateDemandResponse({}));
  }

  async createDemand(request: CreateDemandRequest): Promise<CreateDemandResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createDemandWithOptions(request, runtime);
  }

  async createDeploymentSetWithOptions(request: CreateDeploymentSetRequest, runtime: $Util.RuntimeOptions): Promise<CreateDeploymentSetResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<CreateDeploymentSetResponse>(await this.doRPCRequest("CreateDeploymentSet", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new CreateDeploymentSetResponse({}));
  }

  async createDeploymentSet(request: CreateDeploymentSetRequest): Promise<CreateDeploymentSetResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createDeploymentSetWithOptions(request, runtime);
  }

  async createDiskWithOptions(request: CreateDiskRequest, runtime: $Util.RuntimeOptions): Promise<CreateDiskResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<CreateDiskResponse>(await this.doRPCRequest("CreateDisk", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new CreateDiskResponse({}));
  }

  async createDisk(request: CreateDiskRequest): Promise<CreateDiskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createDiskWithOptions(request, runtime);
  }

  async createElasticityAssuranceWithOptions(request: CreateElasticityAssuranceRequest, runtime: $Util.RuntimeOptions): Promise<CreateElasticityAssuranceResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<CreateElasticityAssuranceResponse>(await this.doRPCRequest("CreateElasticityAssurance", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new CreateElasticityAssuranceResponse({}));
  }

  async createElasticityAssurance(request: CreateElasticityAssuranceRequest): Promise<CreateElasticityAssuranceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createElasticityAssuranceWithOptions(request, runtime);
  }

  async createForwardEntryWithOptions(request: CreateForwardEntryRequest, runtime: $Util.RuntimeOptions): Promise<CreateForwardEntryResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<CreateForwardEntryResponse>(await this.doRPCRequest("CreateForwardEntry", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new CreateForwardEntryResponse({}));
  }

  async createForwardEntry(request: CreateForwardEntryRequest): Promise<CreateForwardEntryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createForwardEntryWithOptions(request, runtime);
  }

  async createHaVipWithOptions(request: CreateHaVipRequest, runtime: $Util.RuntimeOptions): Promise<CreateHaVipResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<CreateHaVipResponse>(await this.doRPCRequest("CreateHaVip", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new CreateHaVipResponse({}));
  }

  async createHaVip(request: CreateHaVipRequest): Promise<CreateHaVipResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createHaVipWithOptions(request, runtime);
  }

  async createHpcClusterWithOptions(request: CreateHpcClusterRequest, runtime: $Util.RuntimeOptions): Promise<CreateHpcClusterResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<CreateHpcClusterResponse>(await this.doRPCRequest("CreateHpcCluster", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new CreateHpcClusterResponse({}));
  }

  async createHpcCluster(request: CreateHpcClusterRequest): Promise<CreateHpcClusterResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createHpcClusterWithOptions(request, runtime);
  }

  async createImageWithOptions(request: CreateImageRequest, runtime: $Util.RuntimeOptions): Promise<CreateImageResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<CreateImageResponse>(await this.doRPCRequest("CreateImage", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new CreateImageResponse({}));
  }

  async createImage(request: CreateImageRequest): Promise<CreateImageResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createImageWithOptions(request, runtime);
  }

  async createInstanceWithOptions(request: CreateInstanceRequest, runtime: $Util.RuntimeOptions): Promise<CreateInstanceResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<CreateInstanceResponse>(await this.doRPCRequest("CreateInstance", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new CreateInstanceResponse({}));
  }

  async createInstance(request: CreateInstanceRequest): Promise<CreateInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createInstanceWithOptions(request, runtime);
  }

  async createKeyPairWithOptions(request: CreateKeyPairRequest, runtime: $Util.RuntimeOptions): Promise<CreateKeyPairResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<CreateKeyPairResponse>(await this.doRPCRequest("CreateKeyPair", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new CreateKeyPairResponse({}));
  }

  async createKeyPair(request: CreateKeyPairRequest): Promise<CreateKeyPairResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createKeyPairWithOptions(request, runtime);
  }

  async createLaunchTemplateWithOptions(request: CreateLaunchTemplateRequest, runtime: $Util.RuntimeOptions): Promise<CreateLaunchTemplateResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<CreateLaunchTemplateResponse>(await this.doRPCRequest("CreateLaunchTemplate", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new CreateLaunchTemplateResponse({}));
  }

  async createLaunchTemplate(request: CreateLaunchTemplateRequest): Promise<CreateLaunchTemplateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createLaunchTemplateWithOptions(request, runtime);
  }

  async createLaunchTemplateVersionWithOptions(request: CreateLaunchTemplateVersionRequest, runtime: $Util.RuntimeOptions): Promise<CreateLaunchTemplateVersionResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<CreateLaunchTemplateVersionResponse>(await this.doRPCRequest("CreateLaunchTemplateVersion", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new CreateLaunchTemplateVersionResponse({}));
  }

  async createLaunchTemplateVersion(request: CreateLaunchTemplateVersionRequest): Promise<CreateLaunchTemplateVersionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createLaunchTemplateVersionWithOptions(request, runtime);
  }

  async createNatGatewayWithOptions(request: CreateNatGatewayRequest, runtime: $Util.RuntimeOptions): Promise<CreateNatGatewayResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<CreateNatGatewayResponse>(await this.doRPCRequest("CreateNatGateway", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new CreateNatGatewayResponse({}));
  }

  async createNatGateway(request: CreateNatGatewayRequest): Promise<CreateNatGatewayResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createNatGatewayWithOptions(request, runtime);
  }

  async createNetworkInterfaceWithOptions(request: CreateNetworkInterfaceRequest, runtime: $Util.RuntimeOptions): Promise<CreateNetworkInterfaceResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<CreateNetworkInterfaceResponse>(await this.doRPCRequest("CreateNetworkInterface", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new CreateNetworkInterfaceResponse({}));
  }

  async createNetworkInterface(request: CreateNetworkInterfaceRequest): Promise<CreateNetworkInterfaceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createNetworkInterfaceWithOptions(request, runtime);
  }

  async createNetworkInterfacePermissionWithOptions(request: CreateNetworkInterfacePermissionRequest, runtime: $Util.RuntimeOptions): Promise<CreateNetworkInterfacePermissionResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<CreateNetworkInterfacePermissionResponse>(await this.doRPCRequest("CreateNetworkInterfacePermission", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new CreateNetworkInterfacePermissionResponse({}));
  }

  async createNetworkInterfacePermission(request: CreateNetworkInterfacePermissionRequest): Promise<CreateNetworkInterfacePermissionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createNetworkInterfacePermissionWithOptions(request, runtime);
  }

  async createPhysicalConnectionWithOptions(request: CreatePhysicalConnectionRequest, runtime: $Util.RuntimeOptions): Promise<CreatePhysicalConnectionResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<CreatePhysicalConnectionResponse>(await this.doRPCRequest("CreatePhysicalConnection", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new CreatePhysicalConnectionResponse({}));
  }

  async createPhysicalConnection(request: CreatePhysicalConnectionRequest): Promise<CreatePhysicalConnectionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createPhysicalConnectionWithOptions(request, runtime);
  }

  async createResource02WithOptions(request: CreateResource02Request, runtime: $Util.RuntimeOptions): Promise<CreateResource02Response> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<CreateResource02Response>(await this.doRPCRequest("CreateResource02", "2014-05-26", "HTTPS", "PUT", "AK", "json", req, runtime), new CreateResource02Response({}));
  }

  async createResource02(request: CreateResource02Request): Promise<CreateResource02Response> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createResource02WithOptions(request, runtime);
  }

  async createRouteEntryWithOptions(request: CreateRouteEntryRequest, runtime: $Util.RuntimeOptions): Promise<CreateRouteEntryResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<CreateRouteEntryResponse>(await this.doRPCRequest("CreateRouteEntry", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new CreateRouteEntryResponse({}));
  }

  async createRouteEntry(request: CreateRouteEntryRequest): Promise<CreateRouteEntryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createRouteEntryWithOptions(request, runtime);
  }

  async createRouterInterfaceWithOptions(request: CreateRouterInterfaceRequest, runtime: $Util.RuntimeOptions): Promise<CreateRouterInterfaceResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<CreateRouterInterfaceResponse>(await this.doRPCRequest("CreateRouterInterface", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new CreateRouterInterfaceResponse({}));
  }

  async createRouterInterface(request: CreateRouterInterfaceRequest): Promise<CreateRouterInterfaceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createRouterInterfaceWithOptions(request, runtime);
  }

  async createSecurityGroupWithOptions(request: CreateSecurityGroupRequest, runtime: $Util.RuntimeOptions): Promise<CreateSecurityGroupResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<CreateSecurityGroupResponse>(await this.doRPCRequest("CreateSecurityGroup", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new CreateSecurityGroupResponse({}));
  }

  async createSecurityGroup(request: CreateSecurityGroupRequest): Promise<CreateSecurityGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createSecurityGroupWithOptions(request, runtime);
  }

  async createSimulatedSystemEventsWithOptions(request: CreateSimulatedSystemEventsRequest, runtime: $Util.RuntimeOptions): Promise<CreateSimulatedSystemEventsResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<CreateSimulatedSystemEventsResponse>(await this.doRPCRequest("CreateSimulatedSystemEvents", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new CreateSimulatedSystemEventsResponse({}));
  }

  async createSimulatedSystemEvents(request: CreateSimulatedSystemEventsRequest): Promise<CreateSimulatedSystemEventsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createSimulatedSystemEventsWithOptions(request, runtime);
  }

  async createSnapshotWithOptions(request: CreateSnapshotRequest, runtime: $Util.RuntimeOptions): Promise<CreateSnapshotResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<CreateSnapshotResponse>(await this.doRPCRequest("CreateSnapshot", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new CreateSnapshotResponse({}));
  }

  async createSnapshot(request: CreateSnapshotRequest): Promise<CreateSnapshotResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createSnapshotWithOptions(request, runtime);
  }

  async createStorageSetWithOptions(request: CreateStorageSetRequest, runtime: $Util.RuntimeOptions): Promise<CreateStorageSetResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<CreateStorageSetResponse>(await this.doRPCRequest("CreateStorageSet", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new CreateStorageSetResponse({}));
  }

  async createStorageSet(request: CreateStorageSetRequest): Promise<CreateStorageSetResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createStorageSetWithOptions(request, runtime);
  }

  async createVirtualBorderRouterWithOptions(request: CreateVirtualBorderRouterRequest, runtime: $Util.RuntimeOptions): Promise<CreateVirtualBorderRouterResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<CreateVirtualBorderRouterResponse>(await this.doRPCRequest("CreateVirtualBorderRouter", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new CreateVirtualBorderRouterResponse({}));
  }

  async createVirtualBorderRouter(request: CreateVirtualBorderRouterRequest): Promise<CreateVirtualBorderRouterResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createVirtualBorderRouterWithOptions(request, runtime);
  }

  async createVpcWithOptions(request: CreateVpcRequest, runtime: $Util.RuntimeOptions): Promise<CreateVpcResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<CreateVpcResponse>(await this.doRPCRequest("CreateVpc", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new CreateVpcResponse({}));
  }

  async createVpc(request: CreateVpcRequest): Promise<CreateVpcResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createVpcWithOptions(request, runtime);
  }

  async createVSwitchWithOptions(request: CreateVSwitchRequest, runtime: $Util.RuntimeOptions): Promise<CreateVSwitchResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<CreateVSwitchResponse>(await this.doRPCRequest("CreateVSwitch", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new CreateVSwitchResponse({}));
  }

  async createVSwitch(request: CreateVSwitchRequest): Promise<CreateVSwitchResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createVSwitchWithOptions(request, runtime);
  }

  async deactivateRouterInterfaceWithOptions(request: DeactivateRouterInterfaceRequest, runtime: $Util.RuntimeOptions): Promise<DeactivateRouterInterfaceResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DeactivateRouterInterfaceResponse>(await this.doRPCRequest("DeactivateRouterInterface", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DeactivateRouterInterfaceResponse({}));
  }

  async deactivateRouterInterface(request: DeactivateRouterInterfaceRequest): Promise<DeactivateRouterInterfaceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deactivateRouterInterfaceWithOptions(request, runtime);
  }

  async deleteAutoProvisioningGroupWithOptions(request: DeleteAutoProvisioningGroupRequest, runtime: $Util.RuntimeOptions): Promise<DeleteAutoProvisioningGroupResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DeleteAutoProvisioningGroupResponse>(await this.doRPCRequest("DeleteAutoProvisioningGroup", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DeleteAutoProvisioningGroupResponse({}));
  }

  async deleteAutoProvisioningGroup(request: DeleteAutoProvisioningGroupRequest): Promise<DeleteAutoProvisioningGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteAutoProvisioningGroupWithOptions(request, runtime);
  }

  async deleteAutoSnapshotPolicyWithOptions(request: DeleteAutoSnapshotPolicyRequest, runtime: $Util.RuntimeOptions): Promise<DeleteAutoSnapshotPolicyResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DeleteAutoSnapshotPolicyResponse>(await this.doRPCRequest("DeleteAutoSnapshotPolicy", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DeleteAutoSnapshotPolicyResponse({}));
  }

  async deleteAutoSnapshotPolicy(request: DeleteAutoSnapshotPolicyRequest): Promise<DeleteAutoSnapshotPolicyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteAutoSnapshotPolicyWithOptions(request, runtime);
  }

  async deleteBandwidthPackageWithOptions(request: DeleteBandwidthPackageRequest, runtime: $Util.RuntimeOptions): Promise<DeleteBandwidthPackageResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DeleteBandwidthPackageResponse>(await this.doRPCRequest("DeleteBandwidthPackage", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DeleteBandwidthPackageResponse({}));
  }

  async deleteBandwidthPackage(request: DeleteBandwidthPackageRequest): Promise<DeleteBandwidthPackageResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteBandwidthPackageWithOptions(request, runtime);
  }

  async deleteCommandWithOptions(request: DeleteCommandRequest, runtime: $Util.RuntimeOptions): Promise<DeleteCommandResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DeleteCommandResponse>(await this.doRPCRequest("DeleteCommand", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DeleteCommandResponse({}));
  }

  async deleteCommand(request: DeleteCommandRequest): Promise<DeleteCommandResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteCommandWithOptions(request, runtime);
  }

  async deleteDedicatedHostClusterWithOptions(request: DeleteDedicatedHostClusterRequest, runtime: $Util.RuntimeOptions): Promise<DeleteDedicatedHostClusterResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DeleteDedicatedHostClusterResponse>(await this.doRPCRequest("DeleteDedicatedHostCluster", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DeleteDedicatedHostClusterResponse({}));
  }

  async deleteDedicatedHostCluster(request: DeleteDedicatedHostClusterRequest): Promise<DeleteDedicatedHostClusterResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteDedicatedHostClusterWithOptions(request, runtime);
  }

  async deleteDemandWithOptions(request: DeleteDemandRequest, runtime: $Util.RuntimeOptions): Promise<DeleteDemandResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DeleteDemandResponse>(await this.doRPCRequest("DeleteDemand", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DeleteDemandResponse({}));
  }

  async deleteDemand(request: DeleteDemandRequest): Promise<DeleteDemandResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteDemandWithOptions(request, runtime);
  }

  async deleteDeploymentSetWithOptions(request: DeleteDeploymentSetRequest, runtime: $Util.RuntimeOptions): Promise<DeleteDeploymentSetResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DeleteDeploymentSetResponse>(await this.doRPCRequest("DeleteDeploymentSet", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DeleteDeploymentSetResponse({}));
  }

  async deleteDeploymentSet(request: DeleteDeploymentSetRequest): Promise<DeleteDeploymentSetResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteDeploymentSetWithOptions(request, runtime);
  }

  async deleteDiskWithOptions(request: DeleteDiskRequest, runtime: $Util.RuntimeOptions): Promise<DeleteDiskResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DeleteDiskResponse>(await this.doRPCRequest("DeleteDisk", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DeleteDiskResponse({}));
  }

  async deleteDisk(request: DeleteDiskRequest): Promise<DeleteDiskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteDiskWithOptions(request, runtime);
  }

  async deleteForwardEntryWithOptions(request: DeleteForwardEntryRequest, runtime: $Util.RuntimeOptions): Promise<DeleteForwardEntryResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DeleteForwardEntryResponse>(await this.doRPCRequest("DeleteForwardEntry", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DeleteForwardEntryResponse({}));
  }

  async deleteForwardEntry(request: DeleteForwardEntryRequest): Promise<DeleteForwardEntryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteForwardEntryWithOptions(request, runtime);
  }

  async deleteHaVipWithOptions(request: DeleteHaVipRequest, runtime: $Util.RuntimeOptions): Promise<DeleteHaVipResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DeleteHaVipResponse>(await this.doRPCRequest("DeleteHaVip", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DeleteHaVipResponse({}));
  }

  async deleteHaVip(request: DeleteHaVipRequest): Promise<DeleteHaVipResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteHaVipWithOptions(request, runtime);
  }

  async deleteHpcClusterWithOptions(request: DeleteHpcClusterRequest, runtime: $Util.RuntimeOptions): Promise<DeleteHpcClusterResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DeleteHpcClusterResponse>(await this.doRPCRequest("DeleteHpcCluster", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DeleteHpcClusterResponse({}));
  }

  async deleteHpcCluster(request: DeleteHpcClusterRequest): Promise<DeleteHpcClusterResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteHpcClusterWithOptions(request, runtime);
  }

  async deleteImageWithOptions(request: DeleteImageRequest, runtime: $Util.RuntimeOptions): Promise<DeleteImageResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DeleteImageResponse>(await this.doRPCRequest("DeleteImage", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DeleteImageResponse({}));
  }

  async deleteImage(request: DeleteImageRequest): Promise<DeleteImageResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteImageWithOptions(request, runtime);
  }

  async deleteInstanceWithOptions(request: DeleteInstanceRequest, runtime: $Util.RuntimeOptions): Promise<DeleteInstanceResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DeleteInstanceResponse>(await this.doRPCRequest("DeleteInstance", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DeleteInstanceResponse({}));
  }

  async deleteInstance(request: DeleteInstanceRequest): Promise<DeleteInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteInstanceWithOptions(request, runtime);
  }

  async deleteInstancesWithOptions(request: DeleteInstancesRequest, runtime: $Util.RuntimeOptions): Promise<DeleteInstancesResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DeleteInstancesResponse>(await this.doRPCRequest("DeleteInstances", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DeleteInstancesResponse({}));
  }

  async deleteInstances(request: DeleteInstancesRequest): Promise<DeleteInstancesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteInstancesWithOptions(request, runtime);
  }

  async deleteKeyPairsWithOptions(request: DeleteKeyPairsRequest, runtime: $Util.RuntimeOptions): Promise<DeleteKeyPairsResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DeleteKeyPairsResponse>(await this.doRPCRequest("DeleteKeyPairs", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DeleteKeyPairsResponse({}));
  }

  async deleteKeyPairs(request: DeleteKeyPairsRequest): Promise<DeleteKeyPairsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteKeyPairsWithOptions(request, runtime);
  }

  async deleteLaunchTemplateWithOptions(request: DeleteLaunchTemplateRequest, runtime: $Util.RuntimeOptions): Promise<DeleteLaunchTemplateResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DeleteLaunchTemplateResponse>(await this.doRPCRequest("DeleteLaunchTemplate", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DeleteLaunchTemplateResponse({}));
  }

  async deleteLaunchTemplate(request: DeleteLaunchTemplateRequest): Promise<DeleteLaunchTemplateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteLaunchTemplateWithOptions(request, runtime);
  }

  async deleteLaunchTemplateVersionWithOptions(request: DeleteLaunchTemplateVersionRequest, runtime: $Util.RuntimeOptions): Promise<DeleteLaunchTemplateVersionResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DeleteLaunchTemplateVersionResponse>(await this.doRPCRequest("DeleteLaunchTemplateVersion", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DeleteLaunchTemplateVersionResponse({}));
  }

  async deleteLaunchTemplateVersion(request: DeleteLaunchTemplateVersionRequest): Promise<DeleteLaunchTemplateVersionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteLaunchTemplateVersionWithOptions(request, runtime);
  }

  async deleteNatGatewayWithOptions(request: DeleteNatGatewayRequest, runtime: $Util.RuntimeOptions): Promise<DeleteNatGatewayResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DeleteNatGatewayResponse>(await this.doRPCRequest("DeleteNatGateway", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DeleteNatGatewayResponse({}));
  }

  async deleteNatGateway(request: DeleteNatGatewayRequest): Promise<DeleteNatGatewayResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteNatGatewayWithOptions(request, runtime);
  }

  async deleteNetworkInterfaceWithOptions(request: DeleteNetworkInterfaceRequest, runtime: $Util.RuntimeOptions): Promise<DeleteNetworkInterfaceResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DeleteNetworkInterfaceResponse>(await this.doRPCRequest("DeleteNetworkInterface", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DeleteNetworkInterfaceResponse({}));
  }

  async deleteNetworkInterface(request: DeleteNetworkInterfaceRequest): Promise<DeleteNetworkInterfaceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteNetworkInterfaceWithOptions(request, runtime);
  }

  async deleteNetworkInterfacePermissionWithOptions(request: DeleteNetworkInterfacePermissionRequest, runtime: $Util.RuntimeOptions): Promise<DeleteNetworkInterfacePermissionResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DeleteNetworkInterfacePermissionResponse>(await this.doRPCRequest("DeleteNetworkInterfacePermission", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DeleteNetworkInterfacePermissionResponse({}));
  }

  async deleteNetworkInterfacePermission(request: DeleteNetworkInterfacePermissionRequest): Promise<DeleteNetworkInterfacePermissionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteNetworkInterfacePermissionWithOptions(request, runtime);
  }

  async deletePhysicalConnectionWithOptions(request: DeletePhysicalConnectionRequest, runtime: $Util.RuntimeOptions): Promise<DeletePhysicalConnectionResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DeletePhysicalConnectionResponse>(await this.doRPCRequest("DeletePhysicalConnection", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DeletePhysicalConnectionResponse({}));
  }

  async deletePhysicalConnection(request: DeletePhysicalConnectionRequest): Promise<DeletePhysicalConnectionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deletePhysicalConnectionWithOptions(request, runtime);
  }

  async deleteRouteEntryWithOptions(request: DeleteRouteEntryRequest, runtime: $Util.RuntimeOptions): Promise<DeleteRouteEntryResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DeleteRouteEntryResponse>(await this.doRPCRequest("DeleteRouteEntry", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DeleteRouteEntryResponse({}));
  }

  async deleteRouteEntry(request: DeleteRouteEntryRequest): Promise<DeleteRouteEntryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteRouteEntryWithOptions(request, runtime);
  }

  async deleteRouterInterfaceWithOptions(request: DeleteRouterInterfaceRequest, runtime: $Util.RuntimeOptions): Promise<DeleteRouterInterfaceResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DeleteRouterInterfaceResponse>(await this.doRPCRequest("DeleteRouterInterface", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DeleteRouterInterfaceResponse({}));
  }

  async deleteRouterInterface(request: DeleteRouterInterfaceRequest): Promise<DeleteRouterInterfaceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteRouterInterfaceWithOptions(request, runtime);
  }

  async deleteSecurityGroupWithOptions(request: DeleteSecurityGroupRequest, runtime: $Util.RuntimeOptions): Promise<DeleteSecurityGroupResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DeleteSecurityGroupResponse>(await this.doRPCRequest("DeleteSecurityGroup", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DeleteSecurityGroupResponse({}));
  }

  async deleteSecurityGroup(request: DeleteSecurityGroupRequest): Promise<DeleteSecurityGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteSecurityGroupWithOptions(request, runtime);
  }

  async deleteSnapshotWithOptions(request: DeleteSnapshotRequest, runtime: $Util.RuntimeOptions): Promise<DeleteSnapshotResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DeleteSnapshotResponse>(await this.doRPCRequest("DeleteSnapshot", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DeleteSnapshotResponse({}));
  }

  async deleteSnapshot(request: DeleteSnapshotRequest): Promise<DeleteSnapshotResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteSnapshotWithOptions(request, runtime);
  }

  async deleteStorageSetWithOptions(request: DeleteStorageSetRequest, runtime: $Util.RuntimeOptions): Promise<DeleteStorageSetResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DeleteStorageSetResponse>(await this.doRPCRequest("DeleteStorageSet", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DeleteStorageSetResponse({}));
  }

  async deleteStorageSet(request: DeleteStorageSetRequest): Promise<DeleteStorageSetResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteStorageSetWithOptions(request, runtime);
  }

  async deleteVirtualBorderRouterWithOptions(request: DeleteVirtualBorderRouterRequest, runtime: $Util.RuntimeOptions): Promise<DeleteVirtualBorderRouterResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DeleteVirtualBorderRouterResponse>(await this.doRPCRequest("DeleteVirtualBorderRouter", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DeleteVirtualBorderRouterResponse({}));
  }

  async deleteVirtualBorderRouter(request: DeleteVirtualBorderRouterRequest): Promise<DeleteVirtualBorderRouterResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteVirtualBorderRouterWithOptions(request, runtime);
  }

  async deleteVpcWithOptions(request: DeleteVpcRequest, runtime: $Util.RuntimeOptions): Promise<DeleteVpcResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DeleteVpcResponse>(await this.doRPCRequest("DeleteVpc", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DeleteVpcResponse({}));
  }

  async deleteVpc(request: DeleteVpcRequest): Promise<DeleteVpcResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteVpcWithOptions(request, runtime);
  }

  async deleteVSwitchWithOptions(request: DeleteVSwitchRequest, runtime: $Util.RuntimeOptions): Promise<DeleteVSwitchResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DeleteVSwitchResponse>(await this.doRPCRequest("DeleteVSwitch", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DeleteVSwitchResponse({}));
  }

  async deleteVSwitch(request: DeleteVSwitchRequest): Promise<DeleteVSwitchResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteVSwitchWithOptions(request, runtime);
  }

  async describeAccessPointsWithOptions(request: DescribeAccessPointsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAccessPointsResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeAccessPointsResponse>(await this.doRPCRequest("DescribeAccessPoints", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeAccessPointsResponse({}));
  }

  async describeAccessPoints(request: DescribeAccessPointsRequest): Promise<DescribeAccessPointsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAccessPointsWithOptions(request, runtime);
  }

  async describeAccountAttributesWithOptions(request: DescribeAccountAttributesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAccountAttributesResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeAccountAttributesResponse>(await this.doRPCRequest("DescribeAccountAttributes", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeAccountAttributesResponse({}));
  }

  async describeAccountAttributes(request: DescribeAccountAttributesRequest): Promise<DescribeAccountAttributesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAccountAttributesWithOptions(request, runtime);
  }

  async describeAutoProvisioningGroupHistoryWithOptions(request: DescribeAutoProvisioningGroupHistoryRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAutoProvisioningGroupHistoryResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeAutoProvisioningGroupHistoryResponse>(await this.doRPCRequest("DescribeAutoProvisioningGroupHistory", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeAutoProvisioningGroupHistoryResponse({}));
  }

  async describeAutoProvisioningGroupHistory(request: DescribeAutoProvisioningGroupHistoryRequest): Promise<DescribeAutoProvisioningGroupHistoryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAutoProvisioningGroupHistoryWithOptions(request, runtime);
  }

  async describeAutoProvisioningGroupInstancesWithOptions(request: DescribeAutoProvisioningGroupInstancesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAutoProvisioningGroupInstancesResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeAutoProvisioningGroupInstancesResponse>(await this.doRPCRequest("DescribeAutoProvisioningGroupInstances", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeAutoProvisioningGroupInstancesResponse({}));
  }

  async describeAutoProvisioningGroupInstances(request: DescribeAutoProvisioningGroupInstancesRequest): Promise<DescribeAutoProvisioningGroupInstancesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAutoProvisioningGroupInstancesWithOptions(request, runtime);
  }

  async describeAutoProvisioningGroupsWithOptions(request: DescribeAutoProvisioningGroupsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAutoProvisioningGroupsResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeAutoProvisioningGroupsResponse>(await this.doRPCRequest("DescribeAutoProvisioningGroups", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeAutoProvisioningGroupsResponse({}));
  }

  async describeAutoProvisioningGroups(request: DescribeAutoProvisioningGroupsRequest): Promise<DescribeAutoProvisioningGroupsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAutoProvisioningGroupsWithOptions(request, runtime);
  }

  async describeAutoSnapshotPolicyExWithOptions(request: DescribeAutoSnapshotPolicyExRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAutoSnapshotPolicyExResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeAutoSnapshotPolicyExResponse>(await this.doRPCRequest("DescribeAutoSnapshotPolicyEx", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeAutoSnapshotPolicyExResponse({}));
  }

  async describeAutoSnapshotPolicyEx(request: DescribeAutoSnapshotPolicyExRequest): Promise<DescribeAutoSnapshotPolicyExResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAutoSnapshotPolicyExWithOptions(request, runtime);
  }

  async describeAvailableResourceWithOptions(request: DescribeAvailableResourceRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAvailableResourceResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeAvailableResourceResponse>(await this.doRPCRequest("DescribeAvailableResource", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeAvailableResourceResponse({}));
  }

  async describeAvailableResource(request: DescribeAvailableResourceRequest): Promise<DescribeAvailableResourceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAvailableResourceWithOptions(request, runtime);
  }

  async describeBandwidthLimitationWithOptions(request: DescribeBandwidthLimitationRequest, runtime: $Util.RuntimeOptions): Promise<DescribeBandwidthLimitationResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeBandwidthLimitationResponse>(await this.doRPCRequest("DescribeBandwidthLimitation", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeBandwidthLimitationResponse({}));
  }

  async describeBandwidthLimitation(request: DescribeBandwidthLimitationRequest): Promise<DescribeBandwidthLimitationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeBandwidthLimitationWithOptions(request, runtime);
  }

  async describeBandwidthPackagesWithOptions(request: DescribeBandwidthPackagesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeBandwidthPackagesResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeBandwidthPackagesResponse>(await this.doRPCRequest("DescribeBandwidthPackages", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeBandwidthPackagesResponse({}));
  }

  async describeBandwidthPackages(request: DescribeBandwidthPackagesRequest): Promise<DescribeBandwidthPackagesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeBandwidthPackagesWithOptions(request, runtime);
  }

  async describeCapacityReservationInstancesWithOptions(request: DescribeCapacityReservationInstancesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeCapacityReservationInstancesResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeCapacityReservationInstancesResponse>(await this.doRPCRequest("DescribeCapacityReservationInstances", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeCapacityReservationInstancesResponse({}));
  }

  async describeCapacityReservationInstances(request: DescribeCapacityReservationInstancesRequest): Promise<DescribeCapacityReservationInstancesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeCapacityReservationInstancesWithOptions(request, runtime);
  }

  async describeCapacityReservationsWithOptions(request: DescribeCapacityReservationsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeCapacityReservationsResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeCapacityReservationsResponse>(await this.doRPCRequest("DescribeCapacityReservations", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeCapacityReservationsResponse({}));
  }

  async describeCapacityReservations(request: DescribeCapacityReservationsRequest): Promise<DescribeCapacityReservationsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeCapacityReservationsWithOptions(request, runtime);
  }

  async describeClassicLinkInstancesWithOptions(request: DescribeClassicLinkInstancesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeClassicLinkInstancesResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeClassicLinkInstancesResponse>(await this.doRPCRequest("DescribeClassicLinkInstances", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeClassicLinkInstancesResponse({}));
  }

  async describeClassicLinkInstances(request: DescribeClassicLinkInstancesRequest): Promise<DescribeClassicLinkInstancesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeClassicLinkInstancesWithOptions(request, runtime);
  }

  async describeCloudAssistantStatusWithOptions(request: DescribeCloudAssistantStatusRequest, runtime: $Util.RuntimeOptions): Promise<DescribeCloudAssistantStatusResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeCloudAssistantStatusResponse>(await this.doRPCRequest("DescribeCloudAssistantStatus", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeCloudAssistantStatusResponse({}));
  }

  async describeCloudAssistantStatus(request: DescribeCloudAssistantStatusRequest): Promise<DescribeCloudAssistantStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeCloudAssistantStatusWithOptions(request, runtime);
  }

  async describeClustersWithOptions(request: DescribeClustersRequest, runtime: $Util.RuntimeOptions): Promise<DescribeClustersResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeClustersResponse>(await this.doRPCRequest("DescribeClusters", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeClustersResponse({}));
  }

  async describeClusters(request: DescribeClustersRequest): Promise<DescribeClustersResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeClustersWithOptions(request, runtime);
  }

  async describeCommandsWithOptions(request: DescribeCommandsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeCommandsResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeCommandsResponse>(await this.doRPCRequest("DescribeCommands", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeCommandsResponse({}));
  }

  async describeCommands(request: DescribeCommandsRequest): Promise<DescribeCommandsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeCommandsWithOptions(request, runtime);
  }

  async describeDedicatedHostAutoRenewWithOptions(request: DescribeDedicatedHostAutoRenewRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDedicatedHostAutoRenewResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeDedicatedHostAutoRenewResponse>(await this.doRPCRequest("DescribeDedicatedHostAutoRenew", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeDedicatedHostAutoRenewResponse({}));
  }

  async describeDedicatedHostAutoRenew(request: DescribeDedicatedHostAutoRenewRequest): Promise<DescribeDedicatedHostAutoRenewResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDedicatedHostAutoRenewWithOptions(request, runtime);
  }

  async describeDedicatedHostClustersWithOptions(request: DescribeDedicatedHostClustersRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDedicatedHostClustersResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeDedicatedHostClustersResponse>(await this.doRPCRequest("DescribeDedicatedHostClusters", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeDedicatedHostClustersResponse({}));
  }

  async describeDedicatedHostClusters(request: DescribeDedicatedHostClustersRequest): Promise<DescribeDedicatedHostClustersResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDedicatedHostClustersWithOptions(request, runtime);
  }

  async describeDedicatedHostsWithOptions(request: DescribeDedicatedHostsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDedicatedHostsResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeDedicatedHostsResponse>(await this.doRPCRequest("DescribeDedicatedHosts", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeDedicatedHostsResponse({}));
  }

  async describeDedicatedHosts(request: DescribeDedicatedHostsRequest): Promise<DescribeDedicatedHostsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDedicatedHostsWithOptions(request, runtime);
  }

  async describeDedicatedHostTypesWithOptions(request: DescribeDedicatedHostTypesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDedicatedHostTypesResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeDedicatedHostTypesResponse>(await this.doRPCRequest("DescribeDedicatedHostTypes", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeDedicatedHostTypesResponse({}));
  }

  async describeDedicatedHostTypes(request: DescribeDedicatedHostTypesRequest): Promise<DescribeDedicatedHostTypesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDedicatedHostTypesWithOptions(request, runtime);
  }

  async describeDemandsWithOptions(request: DescribeDemandsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDemandsResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeDemandsResponse>(await this.doRPCRequest("DescribeDemands", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeDemandsResponse({}));
  }

  async describeDemands(request: DescribeDemandsRequest): Promise<DescribeDemandsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDemandsWithOptions(request, runtime);
  }

  async describeDeploymentSetsWithOptions(request: DescribeDeploymentSetsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDeploymentSetsResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeDeploymentSetsResponse>(await this.doRPCRequest("DescribeDeploymentSets", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeDeploymentSetsResponse({}));
  }

  async describeDeploymentSets(request: DescribeDeploymentSetsRequest): Promise<DescribeDeploymentSetsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDeploymentSetsWithOptions(request, runtime);
  }

  async describeDeploymentSetSupportedInstanceTypeFamilyWithOptions(request: DescribeDeploymentSetSupportedInstanceTypeFamilyRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDeploymentSetSupportedInstanceTypeFamilyResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeDeploymentSetSupportedInstanceTypeFamilyResponse>(await this.doRPCRequest("DescribeDeploymentSetSupportedInstanceTypeFamily", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeDeploymentSetSupportedInstanceTypeFamilyResponse({}));
  }

  async describeDeploymentSetSupportedInstanceTypeFamily(request: DescribeDeploymentSetSupportedInstanceTypeFamilyRequest): Promise<DescribeDeploymentSetSupportedInstanceTypeFamilyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDeploymentSetSupportedInstanceTypeFamilyWithOptions(request, runtime);
  }

  async describeDiskMonitorDataWithOptions(request: DescribeDiskMonitorDataRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDiskMonitorDataResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeDiskMonitorDataResponse>(await this.doRPCRequest("DescribeDiskMonitorData", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeDiskMonitorDataResponse({}));
  }

  async describeDiskMonitorData(request: DescribeDiskMonitorDataRequest): Promise<DescribeDiskMonitorDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDiskMonitorDataWithOptions(request, runtime);
  }

  async describeDisksWithOptions(request: DescribeDisksRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDisksResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeDisksResponse>(await this.doRPCRequest("DescribeDisks", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeDisksResponse({}));
  }

  async describeDisks(request: DescribeDisksRequest): Promise<DescribeDisksResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDisksWithOptions(request, runtime);
  }

  async describeDisksFullStatusWithOptions(request: DescribeDisksFullStatusRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDisksFullStatusResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeDisksFullStatusResponse>(await this.doRPCRequest("DescribeDisksFullStatus", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeDisksFullStatusResponse({}));
  }

  async describeDisksFullStatus(request: DescribeDisksFullStatusRequest): Promise<DescribeDisksFullStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDisksFullStatusWithOptions(request, runtime);
  }

  async describeEipAddressesWithOptions(request: DescribeEipAddressesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeEipAddressesResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeEipAddressesResponse>(await this.doRPCRequest("DescribeEipAddresses", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeEipAddressesResponse({}));
  }

  async describeEipAddresses(request: DescribeEipAddressesRequest): Promise<DescribeEipAddressesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeEipAddressesWithOptions(request, runtime);
  }

  async describeEipMonitorDataWithOptions(request: DescribeEipMonitorDataRequest, runtime: $Util.RuntimeOptions): Promise<DescribeEipMonitorDataResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeEipMonitorDataResponse>(await this.doRPCRequest("DescribeEipMonitorData", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeEipMonitorDataResponse({}));
  }

  async describeEipMonitorData(request: DescribeEipMonitorDataRequest): Promise<DescribeEipMonitorDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeEipMonitorDataWithOptions(request, runtime);
  }

  async describeElasticityAssuranceInstancesWithOptions(request: DescribeElasticityAssuranceInstancesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeElasticityAssuranceInstancesResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeElasticityAssuranceInstancesResponse>(await this.doRPCRequest("DescribeElasticityAssuranceInstances", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeElasticityAssuranceInstancesResponse({}));
  }

  async describeElasticityAssuranceInstances(request: DescribeElasticityAssuranceInstancesRequest): Promise<DescribeElasticityAssuranceInstancesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeElasticityAssuranceInstancesWithOptions(request, runtime);
  }

  async describeElasticityAssurancesWithOptions(request: DescribeElasticityAssurancesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeElasticityAssurancesResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeElasticityAssurancesResponse>(await this.doRPCRequest("DescribeElasticityAssurances", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeElasticityAssurancesResponse({}));
  }

  async describeElasticityAssurances(request: DescribeElasticityAssurancesRequest): Promise<DescribeElasticityAssurancesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeElasticityAssurancesWithOptions(request, runtime);
  }

  async describeEniMonitorDataWithOptions(request: DescribeEniMonitorDataRequest, runtime: $Util.RuntimeOptions): Promise<DescribeEniMonitorDataResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeEniMonitorDataResponse>(await this.doRPCRequest("DescribeEniMonitorData", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeEniMonitorDataResponse({}));
  }

  async describeEniMonitorData(request: DescribeEniMonitorDataRequest): Promise<DescribeEniMonitorDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeEniMonitorDataWithOptions(request, runtime);
  }

  async describeForwardTableEntriesWithOptions(request: DescribeForwardTableEntriesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeForwardTableEntriesResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeForwardTableEntriesResponse>(await this.doRPCRequest("DescribeForwardTableEntries", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeForwardTableEntriesResponse({}));
  }

  async describeForwardTableEntries(request: DescribeForwardTableEntriesRequest): Promise<DescribeForwardTableEntriesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeForwardTableEntriesWithOptions(request, runtime);
  }

  async describeHaVipsWithOptions(request: DescribeHaVipsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeHaVipsResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeHaVipsResponse>(await this.doRPCRequest("DescribeHaVips", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeHaVipsResponse({}));
  }

  async describeHaVips(request: DescribeHaVipsRequest): Promise<DescribeHaVipsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeHaVipsWithOptions(request, runtime);
  }

  async describeHpcClustersWithOptions(request: DescribeHpcClustersRequest, runtime: $Util.RuntimeOptions): Promise<DescribeHpcClustersResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeHpcClustersResponse>(await this.doRPCRequest("DescribeHpcClusters", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeHpcClustersResponse({}));
  }

  async describeHpcClusters(request: DescribeHpcClustersRequest): Promise<DescribeHpcClustersResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeHpcClustersWithOptions(request, runtime);
  }

  async describeImageFromFamilyWithOptions(request: DescribeImageFromFamilyRequest, runtime: $Util.RuntimeOptions): Promise<DescribeImageFromFamilyResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeImageFromFamilyResponse>(await this.doRPCRequest("DescribeImageFromFamily", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeImageFromFamilyResponse({}));
  }

  async describeImageFromFamily(request: DescribeImageFromFamilyRequest): Promise<DescribeImageFromFamilyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeImageFromFamilyWithOptions(request, runtime);
  }

  async describeImagesWithOptions(request: DescribeImagesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeImagesResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeImagesResponse>(await this.doRPCRequest("DescribeImages", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeImagesResponse({}));
  }

  async describeImages(request: DescribeImagesRequest): Promise<DescribeImagesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeImagesWithOptions(request, runtime);
  }

  async describeImageSharePermissionWithOptions(request: DescribeImageSharePermissionRequest, runtime: $Util.RuntimeOptions): Promise<DescribeImageSharePermissionResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeImageSharePermissionResponse>(await this.doRPCRequest("DescribeImageSharePermission", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeImageSharePermissionResponse({}));
  }

  async describeImageSharePermission(request: DescribeImageSharePermissionRequest): Promise<DescribeImageSharePermissionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeImageSharePermissionWithOptions(request, runtime);
  }

  async describeImageSupportInstanceTypesWithOptions(request: DescribeImageSupportInstanceTypesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeImageSupportInstanceTypesResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeImageSupportInstanceTypesResponse>(await this.doRPCRequest("DescribeImageSupportInstanceTypes", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeImageSupportInstanceTypesResponse({}));
  }

  async describeImageSupportInstanceTypes(request: DescribeImageSupportInstanceTypesRequest): Promise<DescribeImageSupportInstanceTypesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeImageSupportInstanceTypesWithOptions(request, runtime);
  }

  async describeInstanceAttachmentAttributesWithOptions(request: DescribeInstanceAttachmentAttributesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeInstanceAttachmentAttributesResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeInstanceAttachmentAttributesResponse>(await this.doRPCRequest("DescribeInstanceAttachmentAttributes", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeInstanceAttachmentAttributesResponse({}));
  }

  async describeInstanceAttachmentAttributes(request: DescribeInstanceAttachmentAttributesRequest): Promise<DescribeInstanceAttachmentAttributesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeInstanceAttachmentAttributesWithOptions(request, runtime);
  }

  async describeInstanceAttributeWithOptions(request: DescribeInstanceAttributeRequest, runtime: $Util.RuntimeOptions): Promise<DescribeInstanceAttributeResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeInstanceAttributeResponse>(await this.doRPCRequest("DescribeInstanceAttribute", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeInstanceAttributeResponse({}));
  }

  async describeInstanceAttribute(request: DescribeInstanceAttributeRequest): Promise<DescribeInstanceAttributeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeInstanceAttributeWithOptions(request, runtime);
  }

  async describeInstanceAutoRenewAttributeWithOptions(request: DescribeInstanceAutoRenewAttributeRequest, runtime: $Util.RuntimeOptions): Promise<DescribeInstanceAutoRenewAttributeResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeInstanceAutoRenewAttributeResponse>(await this.doRPCRequest("DescribeInstanceAutoRenewAttribute", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeInstanceAutoRenewAttributeResponse({}));
  }

  async describeInstanceAutoRenewAttribute(request: DescribeInstanceAutoRenewAttributeRequest): Promise<DescribeInstanceAutoRenewAttributeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeInstanceAutoRenewAttributeWithOptions(request, runtime);
  }

  async describeInstanceHistoryEventsWithOptions(request: DescribeInstanceHistoryEventsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeInstanceHistoryEventsResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeInstanceHistoryEventsResponse>(await this.doRPCRequest("DescribeInstanceHistoryEvents", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeInstanceHistoryEventsResponse({}));
  }

  async describeInstanceHistoryEvents(request: DescribeInstanceHistoryEventsRequest): Promise<DescribeInstanceHistoryEventsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeInstanceHistoryEventsWithOptions(request, runtime);
  }

  async describeInstanceMaintenanceAttributesWithOptions(request: DescribeInstanceMaintenanceAttributesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeInstanceMaintenanceAttributesResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeInstanceMaintenanceAttributesResponse>(await this.doRPCRequest("DescribeInstanceMaintenanceAttributes", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeInstanceMaintenanceAttributesResponse({}));
  }

  async describeInstanceMaintenanceAttributes(request: DescribeInstanceMaintenanceAttributesRequest): Promise<DescribeInstanceMaintenanceAttributesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeInstanceMaintenanceAttributesWithOptions(request, runtime);
  }

  async describeInstanceMonitorDataWithOptions(request: DescribeInstanceMonitorDataRequest, runtime: $Util.RuntimeOptions): Promise<DescribeInstanceMonitorDataResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeInstanceMonitorDataResponse>(await this.doRPCRequest("DescribeInstanceMonitorData", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeInstanceMonitorDataResponse({}));
  }

  async describeInstanceMonitorData(request: DescribeInstanceMonitorDataRequest): Promise<DescribeInstanceMonitorDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeInstanceMonitorDataWithOptions(request, runtime);
  }

  async describeInstanceRamRoleWithOptions(request: DescribeInstanceRamRoleRequest, runtime: $Util.RuntimeOptions): Promise<DescribeInstanceRamRoleResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeInstanceRamRoleResponse>(await this.doRPCRequest("DescribeInstanceRamRole", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeInstanceRamRoleResponse({}));
  }

  async describeInstanceRamRole(request: DescribeInstanceRamRoleRequest): Promise<DescribeInstanceRamRoleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeInstanceRamRoleWithOptions(request, runtime);
  }

  async describeInstancesWithOptions(request: DescribeInstancesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeInstancesResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeInstancesResponse>(await this.doRPCRequest("DescribeInstances", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeInstancesResponse({}));
  }

  async describeInstances(request: DescribeInstancesRequest): Promise<DescribeInstancesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeInstancesWithOptions(request, runtime);
  }

  async describeInstancesFullStatusWithOptions(request: DescribeInstancesFullStatusRequest, runtime: $Util.RuntimeOptions): Promise<DescribeInstancesFullStatusResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeInstancesFullStatusResponse>(await this.doRPCRequest("DescribeInstancesFullStatus", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeInstancesFullStatusResponse({}));
  }

  async describeInstancesFullStatus(request: DescribeInstancesFullStatusRequest): Promise<DescribeInstancesFullStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeInstancesFullStatusWithOptions(request, runtime);
  }

  async describeInstanceStatusWithOptions(request: DescribeInstanceStatusRequest, runtime: $Util.RuntimeOptions): Promise<DescribeInstanceStatusResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeInstanceStatusResponse>(await this.doRPCRequest("DescribeInstanceStatus", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeInstanceStatusResponse({}));
  }

  async describeInstanceStatus(request: DescribeInstanceStatusRequest): Promise<DescribeInstanceStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeInstanceStatusWithOptions(request, runtime);
  }

  async describeInstanceTopologyWithOptions(request: DescribeInstanceTopologyRequest, runtime: $Util.RuntimeOptions): Promise<DescribeInstanceTopologyResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeInstanceTopologyResponse>(await this.doRPCRequest("DescribeInstanceTopology", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeInstanceTopologyResponse({}));
  }

  async describeInstanceTopology(request: DescribeInstanceTopologyRequest): Promise<DescribeInstanceTopologyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeInstanceTopologyWithOptions(request, runtime);
  }

  async describeInstanceTypeFamiliesWithOptions(request: DescribeInstanceTypeFamiliesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeInstanceTypeFamiliesResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeInstanceTypeFamiliesResponse>(await this.doRPCRequest("DescribeInstanceTypeFamilies", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeInstanceTypeFamiliesResponse({}));
  }

  async describeInstanceTypeFamilies(request: DescribeInstanceTypeFamiliesRequest): Promise<DescribeInstanceTypeFamiliesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeInstanceTypeFamiliesWithOptions(request, runtime);
  }

  async describeInstanceTypesWithOptions(request: DescribeInstanceTypesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeInstanceTypesResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeInstanceTypesResponse>(await this.doRPCRequest("DescribeInstanceTypes", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeInstanceTypesResponse({}));
  }

  async describeInstanceTypes(request: DescribeInstanceTypesRequest): Promise<DescribeInstanceTypesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeInstanceTypesWithOptions(request, runtime);
  }

  async describeInstanceVncPasswdWithOptions(request: DescribeInstanceVncPasswdRequest, runtime: $Util.RuntimeOptions): Promise<DescribeInstanceVncPasswdResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeInstanceVncPasswdResponse>(await this.doRPCRequest("DescribeInstanceVncPasswd", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeInstanceVncPasswdResponse({}));
  }

  async describeInstanceVncPasswd(request: DescribeInstanceVncPasswdRequest): Promise<DescribeInstanceVncPasswdResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeInstanceVncPasswdWithOptions(request, runtime);
  }

  async describeInstanceVncUrlWithOptions(request: DescribeInstanceVncUrlRequest, runtime: $Util.RuntimeOptions): Promise<DescribeInstanceVncUrlResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeInstanceVncUrlResponse>(await this.doRPCRequest("DescribeInstanceVncUrl", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeInstanceVncUrlResponse({}));
  }

  async describeInstanceVncUrl(request: DescribeInstanceVncUrlRequest): Promise<DescribeInstanceVncUrlResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeInstanceVncUrlWithOptions(request, runtime);
  }

  async describeInvocationResultsWithOptions(request: DescribeInvocationResultsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeInvocationResultsResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeInvocationResultsResponse>(await this.doRPCRequest("DescribeInvocationResults", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeInvocationResultsResponse({}));
  }

  async describeInvocationResults(request: DescribeInvocationResultsRequest): Promise<DescribeInvocationResultsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeInvocationResultsWithOptions(request, runtime);
  }

  async describeInvocationsWithOptions(request: DescribeInvocationsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeInvocationsResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeInvocationsResponse>(await this.doRPCRequest("DescribeInvocations", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeInvocationsResponse({}));
  }

  async describeInvocations(request: DescribeInvocationsRequest): Promise<DescribeInvocationsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeInvocationsWithOptions(request, runtime);
  }

  async describeKeyPairsWithOptions(request: DescribeKeyPairsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeKeyPairsResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeKeyPairsResponse>(await this.doRPCRequest("DescribeKeyPairs", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeKeyPairsResponse({}));
  }

  async describeKeyPairs(request: DescribeKeyPairsRequest): Promise<DescribeKeyPairsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeKeyPairsWithOptions(request, runtime);
  }

  async describeLaunchTemplatesWithOptions(request: DescribeLaunchTemplatesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLaunchTemplatesResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeLaunchTemplatesResponse>(await this.doRPCRequest("DescribeLaunchTemplates", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeLaunchTemplatesResponse({}));
  }

  async describeLaunchTemplates(request: DescribeLaunchTemplatesRequest): Promise<DescribeLaunchTemplatesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLaunchTemplatesWithOptions(request, runtime);
  }

  async describeLaunchTemplateVersionsWithOptions(request: DescribeLaunchTemplateVersionsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLaunchTemplateVersionsResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeLaunchTemplateVersionsResponse>(await this.doRPCRequest("DescribeLaunchTemplateVersions", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeLaunchTemplateVersionsResponse({}));
  }

  async describeLaunchTemplateVersions(request: DescribeLaunchTemplateVersionsRequest): Promise<DescribeLaunchTemplateVersionsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLaunchTemplateVersionsWithOptions(request, runtime);
  }

  async describeLimitationWithOptions(request: DescribeLimitationRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLimitationResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeLimitationResponse>(await this.doRPCRequest("DescribeLimitation", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeLimitationResponse({}));
  }

  async describeLimitation(request: DescribeLimitationRequest): Promise<DescribeLimitationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLimitationWithOptions(request, runtime);
  }

  async describeNatGatewaysWithOptions(request: DescribeNatGatewaysRequest, runtime: $Util.RuntimeOptions): Promise<DescribeNatGatewaysResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeNatGatewaysResponse>(await this.doRPCRequest("DescribeNatGateways", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeNatGatewaysResponse({}));
  }

  async describeNatGateways(request: DescribeNatGatewaysRequest): Promise<DescribeNatGatewaysResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeNatGatewaysWithOptions(request, runtime);
  }

  async describeNetworkInterfaceAttributeWithOptions(request: DescribeNetworkInterfaceAttributeRequest, runtime: $Util.RuntimeOptions): Promise<DescribeNetworkInterfaceAttributeResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeNetworkInterfaceAttributeResponse>(await this.doRPCRequest("DescribeNetworkInterfaceAttribute", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeNetworkInterfaceAttributeResponse({}));
  }

  async describeNetworkInterfaceAttribute(request: DescribeNetworkInterfaceAttributeRequest): Promise<DescribeNetworkInterfaceAttributeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeNetworkInterfaceAttributeWithOptions(request, runtime);
  }

  async describeNetworkInterfacePermissionsWithOptions(request: DescribeNetworkInterfacePermissionsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeNetworkInterfacePermissionsResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeNetworkInterfacePermissionsResponse>(await this.doRPCRequest("DescribeNetworkInterfacePermissions", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeNetworkInterfacePermissionsResponse({}));
  }

  async describeNetworkInterfacePermissions(request: DescribeNetworkInterfacePermissionsRequest): Promise<DescribeNetworkInterfacePermissionsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeNetworkInterfacePermissionsWithOptions(request, runtime);
  }

  async describeNetworkInterfacesWithOptions(request: DescribeNetworkInterfacesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeNetworkInterfacesResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeNetworkInterfacesResponse>(await this.doRPCRequest("DescribeNetworkInterfaces", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeNetworkInterfacesResponse({}));
  }

  async describeNetworkInterfaces(request: DescribeNetworkInterfacesRequest): Promise<DescribeNetworkInterfacesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeNetworkInterfacesWithOptions(request, runtime);
  }

  async describeNewProjectEipMonitorDataWithOptions(request: DescribeNewProjectEipMonitorDataRequest, runtime: $Util.RuntimeOptions): Promise<DescribeNewProjectEipMonitorDataResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeNewProjectEipMonitorDataResponse>(await this.doRPCRequest("DescribeNewProjectEipMonitorData", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeNewProjectEipMonitorDataResponse({}));
  }

  async describeNewProjectEipMonitorData(request: DescribeNewProjectEipMonitorDataRequest): Promise<DescribeNewProjectEipMonitorDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeNewProjectEipMonitorDataWithOptions(request, runtime);
  }

  async describePhysicalConnectionsWithOptions(request: DescribePhysicalConnectionsRequest, runtime: $Util.RuntimeOptions): Promise<DescribePhysicalConnectionsResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribePhysicalConnectionsResponse>(await this.doRPCRequest("DescribePhysicalConnections", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribePhysicalConnectionsResponse({}));
  }

  async describePhysicalConnections(request: DescribePhysicalConnectionsRequest): Promise<DescribePhysicalConnectionsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describePhysicalConnectionsWithOptions(request, runtime);
  }

  async describePriceWithOptions(request: DescribePriceRequest, runtime: $Util.RuntimeOptions): Promise<DescribePriceResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribePriceResponse>(await this.doRPCRequest("DescribePrice", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribePriceResponse({}));
  }

  async describePrice(request: DescribePriceRequest): Promise<DescribePriceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describePriceWithOptions(request, runtime);
  }

  async describeRecommendInstanceTypeWithOptions(request: DescribeRecommendInstanceTypeRequest, runtime: $Util.RuntimeOptions): Promise<DescribeRecommendInstanceTypeResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeRecommendInstanceTypeResponse>(await this.doRPCRequest("DescribeRecommendInstanceType", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeRecommendInstanceTypeResponse({}));
  }

  async describeRecommendInstanceType(request: DescribeRecommendInstanceTypeRequest): Promise<DescribeRecommendInstanceTypeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeRecommendInstanceTypeWithOptions(request, runtime);
  }

  async describeRegionsWithOptions(request: DescribeRegionsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeRegionsResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeRegionsResponse>(await this.doRPCRequest("DescribeRegions", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeRegionsResponse({}));
  }

  async describeRegions(request: DescribeRegionsRequest): Promise<DescribeRegionsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeRegionsWithOptions(request, runtime);
  }

  async describeRenewalPriceWithOptions(request: DescribeRenewalPriceRequest, runtime: $Util.RuntimeOptions): Promise<DescribeRenewalPriceResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeRenewalPriceResponse>(await this.doRPCRequest("DescribeRenewalPrice", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeRenewalPriceResponse({}));
  }

  async describeRenewalPrice(request: DescribeRenewalPriceRequest): Promise<DescribeRenewalPriceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeRenewalPriceWithOptions(request, runtime);
  }

  async describeReservedInstancesWithOptions(request: DescribeReservedInstancesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeReservedInstancesResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeReservedInstancesResponse>(await this.doRPCRequest("DescribeReservedInstances", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeReservedInstancesResponse({}));
  }

  async describeReservedInstances(request: DescribeReservedInstancesRequest): Promise<DescribeReservedInstancesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeReservedInstancesWithOptions(request, runtime);
  }

  async describeResourceByTagsWithOptions(request: DescribeResourceByTagsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeResourceByTagsResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeResourceByTagsResponse>(await this.doRPCRequest("DescribeResourceByTags", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeResourceByTagsResponse({}));
  }

  async describeResourceByTags(request: DescribeResourceByTagsRequest): Promise<DescribeResourceByTagsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeResourceByTagsWithOptions(request, runtime);
  }

  async describeResourcesModificationWithOptions(request: DescribeResourcesModificationRequest, runtime: $Util.RuntimeOptions): Promise<DescribeResourcesModificationResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeResourcesModificationResponse>(await this.doRPCRequest("DescribeResourcesModification", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeResourcesModificationResponse({}));
  }

  async describeResourcesModification(request: DescribeResourcesModificationRequest): Promise<DescribeResourcesModificationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeResourcesModificationWithOptions(request, runtime);
  }

  async describeRouterInterfacesWithOptions(request: DescribeRouterInterfacesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeRouterInterfacesResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeRouterInterfacesResponse>(await this.doRPCRequest("DescribeRouterInterfaces", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeRouterInterfacesResponse({}));
  }

  async describeRouterInterfaces(request: DescribeRouterInterfacesRequest): Promise<DescribeRouterInterfacesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeRouterInterfacesWithOptions(request, runtime);
  }

  async describeRouteTablesWithOptions(request: DescribeRouteTablesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeRouteTablesResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeRouteTablesResponse>(await this.doRPCRequest("DescribeRouteTables", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeRouteTablesResponse({}));
  }

  async describeRouteTables(request: DescribeRouteTablesRequest): Promise<DescribeRouteTablesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeRouteTablesWithOptions(request, runtime);
  }

  async describeSecurityGroupAttributeWithOptions(request: DescribeSecurityGroupAttributeRequest, runtime: $Util.RuntimeOptions): Promise<DescribeSecurityGroupAttributeResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeSecurityGroupAttributeResponse>(await this.doRPCRequest("DescribeSecurityGroupAttribute", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeSecurityGroupAttributeResponse({}));
  }

  async describeSecurityGroupAttribute(request: DescribeSecurityGroupAttributeRequest): Promise<DescribeSecurityGroupAttributeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeSecurityGroupAttributeWithOptions(request, runtime);
  }

  async describeSecurityGroupReferencesWithOptions(request: DescribeSecurityGroupReferencesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeSecurityGroupReferencesResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeSecurityGroupReferencesResponse>(await this.doRPCRequest("DescribeSecurityGroupReferences", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeSecurityGroupReferencesResponse({}));
  }

  async describeSecurityGroupReferences(request: DescribeSecurityGroupReferencesRequest): Promise<DescribeSecurityGroupReferencesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeSecurityGroupReferencesWithOptions(request, runtime);
  }

  async describeSecurityGroupsWithOptions(request: DescribeSecurityGroupsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeSecurityGroupsResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeSecurityGroupsResponse>(await this.doRPCRequest("DescribeSecurityGroups", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeSecurityGroupsResponse({}));
  }

  async describeSecurityGroups(request: DescribeSecurityGroupsRequest): Promise<DescribeSecurityGroupsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeSecurityGroupsWithOptions(request, runtime);
  }

  async describeSendFileResultsWithOptions(request: DescribeSendFileResultsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeSendFileResultsResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeSendFileResultsResponse>(await this.doRPCRequest("DescribeSendFileResults", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeSendFileResultsResponse({}));
  }

  async describeSendFileResults(request: DescribeSendFileResultsRequest): Promise<DescribeSendFileResultsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeSendFileResultsWithOptions(request, runtime);
  }

  async describeSnapshotLinksWithOptions(request: DescribeSnapshotLinksRequest, runtime: $Util.RuntimeOptions): Promise<DescribeSnapshotLinksResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeSnapshotLinksResponse>(await this.doRPCRequest("DescribeSnapshotLinks", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeSnapshotLinksResponse({}));
  }

  async describeSnapshotLinks(request: DescribeSnapshotLinksRequest): Promise<DescribeSnapshotLinksResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeSnapshotLinksWithOptions(request, runtime);
  }

  async describeSnapshotMonitorDataWithOptions(request: DescribeSnapshotMonitorDataRequest, runtime: $Util.RuntimeOptions): Promise<DescribeSnapshotMonitorDataResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeSnapshotMonitorDataResponse>(await this.doRPCRequest("DescribeSnapshotMonitorData", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeSnapshotMonitorDataResponse({}));
  }

  async describeSnapshotMonitorData(request: DescribeSnapshotMonitorDataRequest): Promise<DescribeSnapshotMonitorDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeSnapshotMonitorDataWithOptions(request, runtime);
  }

  async describeSnapshotPackageWithOptions(request: DescribeSnapshotPackageRequest, runtime: $Util.RuntimeOptions): Promise<DescribeSnapshotPackageResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeSnapshotPackageResponse>(await this.doRPCRequest("DescribeSnapshotPackage", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeSnapshotPackageResponse({}));
  }

  async describeSnapshotPackage(request: DescribeSnapshotPackageRequest): Promise<DescribeSnapshotPackageResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeSnapshotPackageWithOptions(request, runtime);
  }

  async describeSnapshotsWithOptions(request: DescribeSnapshotsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeSnapshotsResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeSnapshotsResponse>(await this.doRPCRequest("DescribeSnapshots", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeSnapshotsResponse({}));
  }

  async describeSnapshots(request: DescribeSnapshotsRequest): Promise<DescribeSnapshotsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeSnapshotsWithOptions(request, runtime);
  }

  async describeSnapshotsUsageWithOptions(request: DescribeSnapshotsUsageRequest, runtime: $Util.RuntimeOptions): Promise<DescribeSnapshotsUsageResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeSnapshotsUsageResponse>(await this.doRPCRequest("DescribeSnapshotsUsage", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeSnapshotsUsageResponse({}));
  }

  async describeSnapshotsUsage(request: DescribeSnapshotsUsageRequest): Promise<DescribeSnapshotsUsageResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeSnapshotsUsageWithOptions(request, runtime);
  }

  async describeSpotAdviceWithOptions(request: DescribeSpotAdviceRequest, runtime: $Util.RuntimeOptions): Promise<DescribeSpotAdviceResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeSpotAdviceResponse>(await this.doRPCRequest("DescribeSpotAdvice", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeSpotAdviceResponse({}));
  }

  async describeSpotAdvice(request: DescribeSpotAdviceRequest): Promise<DescribeSpotAdviceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeSpotAdviceWithOptions(request, runtime);
  }

  async describeSpotPriceHistoryWithOptions(request: DescribeSpotPriceHistoryRequest, runtime: $Util.RuntimeOptions): Promise<DescribeSpotPriceHistoryResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeSpotPriceHistoryResponse>(await this.doRPCRequest("DescribeSpotPriceHistory", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeSpotPriceHistoryResponse({}));
  }

  async describeSpotPriceHistory(request: DescribeSpotPriceHistoryRequest): Promise<DescribeSpotPriceHistoryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeSpotPriceHistoryWithOptions(request, runtime);
  }

  async describeStorageCapacityUnitsWithOptions(request: DescribeStorageCapacityUnitsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeStorageCapacityUnitsResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeStorageCapacityUnitsResponse>(await this.doRPCRequest("DescribeStorageCapacityUnits", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeStorageCapacityUnitsResponse({}));
  }

  async describeStorageCapacityUnits(request: DescribeStorageCapacityUnitsRequest): Promise<DescribeStorageCapacityUnitsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeStorageCapacityUnitsWithOptions(request, runtime);
  }

  async describeStorageSetDetailsWithOptions(request: DescribeStorageSetDetailsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeStorageSetDetailsResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeStorageSetDetailsResponse>(await this.doRPCRequest("DescribeStorageSetDetails", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeStorageSetDetailsResponse({}));
  }

  async describeStorageSetDetails(request: DescribeStorageSetDetailsRequest): Promise<DescribeStorageSetDetailsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeStorageSetDetailsWithOptions(request, runtime);
  }

  async describeStorageSetsWithOptions(request: DescribeStorageSetsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeStorageSetsResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeStorageSetsResponse>(await this.doRPCRequest("DescribeStorageSets", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeStorageSetsResponse({}));
  }

  async describeStorageSets(request: DescribeStorageSetsRequest): Promise<DescribeStorageSetsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeStorageSetsWithOptions(request, runtime);
  }

  async describeTagsWithOptions(request: DescribeTagsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeTagsResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeTagsResponse>(await this.doRPCRequest("DescribeTags", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeTagsResponse({}));
  }

  async describeTags(request: DescribeTagsRequest): Promise<DescribeTagsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeTagsWithOptions(request, runtime);
  }

  async describeTaskAttributeWithOptions(request: DescribeTaskAttributeRequest, runtime: $Util.RuntimeOptions): Promise<DescribeTaskAttributeResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeTaskAttributeResponse>(await this.doRPCRequest("DescribeTaskAttribute", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeTaskAttributeResponse({}));
  }

  async describeTaskAttribute(request: DescribeTaskAttributeRequest): Promise<DescribeTaskAttributeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeTaskAttributeWithOptions(request, runtime);
  }

  async describeTasksWithOptions(request: DescribeTasksRequest, runtime: $Util.RuntimeOptions): Promise<DescribeTasksResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeTasksResponse>(await this.doRPCRequest("DescribeTasks", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeTasksResponse({}));
  }

  async describeTasks(request: DescribeTasksRequest): Promise<DescribeTasksResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeTasksWithOptions(request, runtime);
  }

  async describeUserBusinessBehaviorWithOptions(request: DescribeUserBusinessBehaviorRequest, runtime: $Util.RuntimeOptions): Promise<DescribeUserBusinessBehaviorResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeUserBusinessBehaviorResponse>(await this.doRPCRequest("DescribeUserBusinessBehavior", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeUserBusinessBehaviorResponse({}));
  }

  async describeUserBusinessBehavior(request: DescribeUserBusinessBehaviorRequest): Promise<DescribeUserBusinessBehaviorResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeUserBusinessBehaviorWithOptions(request, runtime);
  }

  async describeUserDataWithOptions(request: DescribeUserDataRequest, runtime: $Util.RuntimeOptions): Promise<DescribeUserDataResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeUserDataResponse>(await this.doRPCRequest("DescribeUserData", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeUserDataResponse({}));
  }

  async describeUserData(request: DescribeUserDataRequest): Promise<DescribeUserDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeUserDataWithOptions(request, runtime);
  }

  async describeVirtualBorderRoutersWithOptions(request: DescribeVirtualBorderRoutersRequest, runtime: $Util.RuntimeOptions): Promise<DescribeVirtualBorderRoutersResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeVirtualBorderRoutersResponse>(await this.doRPCRequest("DescribeVirtualBorderRouters", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeVirtualBorderRoutersResponse({}));
  }

  async describeVirtualBorderRouters(request: DescribeVirtualBorderRoutersRequest): Promise<DescribeVirtualBorderRoutersResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeVirtualBorderRoutersWithOptions(request, runtime);
  }

  async describeVirtualBorderRoutersForPhysicalConnectionWithOptions(request: DescribeVirtualBorderRoutersForPhysicalConnectionRequest, runtime: $Util.RuntimeOptions): Promise<DescribeVirtualBorderRoutersForPhysicalConnectionResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeVirtualBorderRoutersForPhysicalConnectionResponse>(await this.doRPCRequest("DescribeVirtualBorderRoutersForPhysicalConnection", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeVirtualBorderRoutersForPhysicalConnectionResponse({}));
  }

  async describeVirtualBorderRoutersForPhysicalConnection(request: DescribeVirtualBorderRoutersForPhysicalConnectionRequest): Promise<DescribeVirtualBorderRoutersForPhysicalConnectionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeVirtualBorderRoutersForPhysicalConnectionWithOptions(request, runtime);
  }

  async describeVpcsWithOptions(request: DescribeVpcsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeVpcsResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeVpcsResponse>(await this.doRPCRequest("DescribeVpcs", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeVpcsResponse({}));
  }

  async describeVpcs(request: DescribeVpcsRequest): Promise<DescribeVpcsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeVpcsWithOptions(request, runtime);
  }

  async describeVRoutersWithOptions(request: DescribeVRoutersRequest, runtime: $Util.RuntimeOptions): Promise<DescribeVRoutersResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeVRoutersResponse>(await this.doRPCRequest("DescribeVRouters", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeVRoutersResponse({}));
  }

  async describeVRouters(request: DescribeVRoutersRequest): Promise<DescribeVRoutersResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeVRoutersWithOptions(request, runtime);
  }

  async describeVSwitchesWithOptions(request: DescribeVSwitchesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeVSwitchesResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeVSwitchesResponse>(await this.doRPCRequest("DescribeVSwitches", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeVSwitchesResponse({}));
  }

  async describeVSwitches(request: DescribeVSwitchesRequest): Promise<DescribeVSwitchesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeVSwitchesWithOptions(request, runtime);
  }

  async describeZonesWithOptions(request: DescribeZonesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeZonesResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DescribeZonesResponse>(await this.doRPCRequest("DescribeZones", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DescribeZonesResponse({}));
  }

  async describeZones(request: DescribeZonesRequest): Promise<DescribeZonesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeZonesWithOptions(request, runtime);
  }

  async detachClassicLinkVpcWithOptions(request: DetachClassicLinkVpcRequest, runtime: $Util.RuntimeOptions): Promise<DetachClassicLinkVpcResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DetachClassicLinkVpcResponse>(await this.doRPCRequest("DetachClassicLinkVpc", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DetachClassicLinkVpcResponse({}));
  }

  async detachClassicLinkVpc(request: DetachClassicLinkVpcRequest): Promise<DetachClassicLinkVpcResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.detachClassicLinkVpcWithOptions(request, runtime);
  }

  async detachDiskWithOptions(request: DetachDiskRequest, runtime: $Util.RuntimeOptions): Promise<DetachDiskResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DetachDiskResponse>(await this.doRPCRequest("DetachDisk", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DetachDiskResponse({}));
  }

  async detachDisk(request: DetachDiskRequest): Promise<DetachDiskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.detachDiskWithOptions(request, runtime);
  }

  async detachInstanceRamRoleWithOptions(request: DetachInstanceRamRoleRequest, runtime: $Util.RuntimeOptions): Promise<DetachInstanceRamRoleResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DetachInstanceRamRoleResponse>(await this.doRPCRequest("DetachInstanceRamRole", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DetachInstanceRamRoleResponse({}));
  }

  async detachInstanceRamRole(request: DetachInstanceRamRoleRequest): Promise<DetachInstanceRamRoleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.detachInstanceRamRoleWithOptions(request, runtime);
  }

  async detachKeyPairWithOptions(request: DetachKeyPairRequest, runtime: $Util.RuntimeOptions): Promise<DetachKeyPairResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DetachKeyPairResponse>(await this.doRPCRequest("DetachKeyPair", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DetachKeyPairResponse({}));
  }

  async detachKeyPair(request: DetachKeyPairRequest): Promise<DetachKeyPairResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.detachKeyPairWithOptions(request, runtime);
  }

  async detachNetworkInterfaceWithOptions(request: DetachNetworkInterfaceRequest, runtime: $Util.RuntimeOptions): Promise<DetachNetworkInterfaceResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<DetachNetworkInterfaceResponse>(await this.doRPCRequest("DetachNetworkInterface", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new DetachNetworkInterfaceResponse({}));
  }

  async detachNetworkInterface(request: DetachNetworkInterfaceRequest): Promise<DetachNetworkInterfaceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.detachNetworkInterfaceWithOptions(request, runtime);
  }

  async eipFillParamsWithOptions(request: EipFillParamsRequest, runtime: $Util.RuntimeOptions): Promise<EipFillParamsResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<EipFillParamsResponse>(await this.doRPCRequest("EipFillParams", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new EipFillParamsResponse({}));
  }

  async eipFillParams(request: EipFillParamsRequest): Promise<EipFillParamsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.eipFillParamsWithOptions(request, runtime);
  }

  async eipFillProductWithOptions(request: EipFillProductRequest, runtime: $Util.RuntimeOptions): Promise<EipFillProductResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<EipFillProductResponse>(await this.doRPCRequest("EipFillProduct", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new EipFillProductResponse({}));
  }

  async eipFillProduct(request: EipFillProductRequest): Promise<EipFillProductResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.eipFillProductWithOptions(request, runtime);
  }

  async eipNotifyPaidWithOptions(request: EipNotifyPaidRequest, runtime: $Util.RuntimeOptions): Promise<EipNotifyPaidResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<EipNotifyPaidResponse>(await this.doRPCRequest("EipNotifyPaid", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new EipNotifyPaidResponse({}));
  }

  async eipNotifyPaid(request: EipNotifyPaidRequest): Promise<EipNotifyPaidResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.eipNotifyPaidWithOptions(request, runtime);
  }

  async enablePhysicalConnectionWithOptions(request: EnablePhysicalConnectionRequest, runtime: $Util.RuntimeOptions): Promise<EnablePhysicalConnectionResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<EnablePhysicalConnectionResponse>(await this.doRPCRequest("EnablePhysicalConnection", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new EnablePhysicalConnectionResponse({}));
  }

  async enablePhysicalConnection(request: EnablePhysicalConnectionRequest): Promise<EnablePhysicalConnectionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.enablePhysicalConnectionWithOptions(request, runtime);
  }

  async exportImageWithOptions(request: ExportImageRequest, runtime: $Util.RuntimeOptions): Promise<ExportImageResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ExportImageResponse>(await this.doRPCRequest("ExportImage", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new ExportImageResponse({}));
  }

  async exportImage(request: ExportImageRequest): Promise<ExportImageResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.exportImageWithOptions(request, runtime);
  }

  async exportSnapshotWithOptions(request: ExportSnapshotRequest, runtime: $Util.RuntimeOptions): Promise<ExportSnapshotResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ExportSnapshotResponse>(await this.doRPCRequest("ExportSnapshot", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new ExportSnapshotResponse({}));
  }

  async exportSnapshot(request: ExportSnapshotRequest): Promise<ExportSnapshotResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.exportSnapshotWithOptions(request, runtime);
  }

  async getInstanceConsoleOutputWithOptions(request: GetInstanceConsoleOutputRequest, runtime: $Util.RuntimeOptions): Promise<GetInstanceConsoleOutputResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<GetInstanceConsoleOutputResponse>(await this.doRPCRequest("GetInstanceConsoleOutput", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new GetInstanceConsoleOutputResponse({}));
  }

  async getInstanceConsoleOutput(request: GetInstanceConsoleOutputRequest): Promise<GetInstanceConsoleOutputResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getInstanceConsoleOutputWithOptions(request, runtime);
  }

  async getInstanceScreenshotWithOptions(request: GetInstanceScreenshotRequest, runtime: $Util.RuntimeOptions): Promise<GetInstanceScreenshotResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<GetInstanceScreenshotResponse>(await this.doRPCRequest("GetInstanceScreenshot", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new GetInstanceScreenshotResponse({}));
  }

  async getInstanceScreenshot(request: GetInstanceScreenshotRequest): Promise<GetInstanceScreenshotResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getInstanceScreenshotWithOptions(request, runtime);
  }

  async importImageWithOptions(request: ImportImageRequest, runtime: $Util.RuntimeOptions): Promise<ImportImageResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ImportImageResponse>(await this.doRPCRequest("ImportImage", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new ImportImageResponse({}));
  }

  async importImage(request: ImportImageRequest): Promise<ImportImageResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.importImageWithOptions(request, runtime);
  }

  async importKeyPairWithOptions(request: ImportKeyPairRequest, runtime: $Util.RuntimeOptions): Promise<ImportKeyPairResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ImportKeyPairResponse>(await this.doRPCRequest("ImportKeyPair", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new ImportKeyPairResponse({}));
  }

  async importKeyPair(request: ImportKeyPairRequest): Promise<ImportKeyPairResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.importKeyPairWithOptions(request, runtime);
  }

  async importSnapshotWithOptions(request: ImportSnapshotRequest, runtime: $Util.RuntimeOptions): Promise<ImportSnapshotResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ImportSnapshotResponse>(await this.doRPCRequest("ImportSnapshot", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new ImportSnapshotResponse({}));
  }

  async importSnapshot(request: ImportSnapshotRequest): Promise<ImportSnapshotResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.importSnapshotWithOptions(request, runtime);
  }

  async installCloudAssistantWithOptions(request: InstallCloudAssistantRequest, runtime: $Util.RuntimeOptions): Promise<InstallCloudAssistantResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<InstallCloudAssistantResponse>(await this.doRPCRequest("InstallCloudAssistant", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new InstallCloudAssistantResponse({}));
  }

  async installCloudAssistant(request: InstallCloudAssistantRequest): Promise<InstallCloudAssistantResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.installCloudAssistantWithOptions(request, runtime);
  }

  async invokeCommandWithOptions(tmpReq: InvokeCommandRequest, runtime: $Util.RuntimeOptions): Promise<InvokeCommandResponse> {
    Util.validateModel(tmpReq);
    let request = new InvokeCommandShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.parameters)) {
      request.parametersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.parameters, "Parameters", "json");
    }

    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<InvokeCommandResponse>(await this.doRPCRequest("InvokeCommand", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new InvokeCommandResponse({}));
  }

  async invokeCommand(request: InvokeCommandRequest): Promise<InvokeCommandResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.invokeCommandWithOptions(request, runtime);
  }

  async joinResourceGroupWithOptions(request: JoinResourceGroupRequest, runtime: $Util.RuntimeOptions): Promise<JoinResourceGroupResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<JoinResourceGroupResponse>(await this.doRPCRequest("JoinResourceGroup", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new JoinResourceGroupResponse({}));
  }

  async joinResourceGroup(request: JoinResourceGroupRequest): Promise<JoinResourceGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.joinResourceGroupWithOptions(request, runtime);
  }

  async joinSecurityGroupWithOptions(request: JoinSecurityGroupRequest, runtime: $Util.RuntimeOptions): Promise<JoinSecurityGroupResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<JoinSecurityGroupResponse>(await this.doRPCRequest("JoinSecurityGroup", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new JoinSecurityGroupResponse({}));
  }

  async joinSecurityGroup(request: JoinSecurityGroupRequest): Promise<JoinSecurityGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.joinSecurityGroupWithOptions(request, runtime);
  }

  async leaveSecurityGroupWithOptions(request: LeaveSecurityGroupRequest, runtime: $Util.RuntimeOptions): Promise<LeaveSecurityGroupResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<LeaveSecurityGroupResponse>(await this.doRPCRequest("LeaveSecurityGroup", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new LeaveSecurityGroupResponse({}));
  }

  async leaveSecurityGroup(request: LeaveSecurityGroupRequest): Promise<LeaveSecurityGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.leaveSecurityGroupWithOptions(request, runtime);
  }

  async listTagResourcesWithOptions(request: ListTagResourcesRequest, runtime: $Util.RuntimeOptions): Promise<ListTagResourcesResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ListTagResourcesResponse>(await this.doRPCRequest("ListTagResources", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new ListTagResourcesResponse({}));
  }

  async listTagResources(request: ListTagResourcesRequest): Promise<ListTagResourcesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listTagResourcesWithOptions(request, runtime);
  }

  async modifyAutoProvisioningGroupWithOptions(request: ModifyAutoProvisioningGroupRequest, runtime: $Util.RuntimeOptions): Promise<ModifyAutoProvisioningGroupResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ModifyAutoProvisioningGroupResponse>(await this.doRPCRequest("ModifyAutoProvisioningGroup", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new ModifyAutoProvisioningGroupResponse({}));
  }

  async modifyAutoProvisioningGroup(request: ModifyAutoProvisioningGroupRequest): Promise<ModifyAutoProvisioningGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyAutoProvisioningGroupWithOptions(request, runtime);
  }

  async modifyAutoSnapshotPolicyWithOptions(request: ModifyAutoSnapshotPolicyRequest, runtime: $Util.RuntimeOptions): Promise<ModifyAutoSnapshotPolicyResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ModifyAutoSnapshotPolicyResponse>(await this.doRPCRequest("ModifyAutoSnapshotPolicy", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new ModifyAutoSnapshotPolicyResponse({}));
  }

  async modifyAutoSnapshotPolicy(request: ModifyAutoSnapshotPolicyRequest): Promise<ModifyAutoSnapshotPolicyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyAutoSnapshotPolicyWithOptions(request, runtime);
  }

  async modifyAutoSnapshotPolicyExWithOptions(request: ModifyAutoSnapshotPolicyExRequest, runtime: $Util.RuntimeOptions): Promise<ModifyAutoSnapshotPolicyExResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ModifyAutoSnapshotPolicyExResponse>(await this.doRPCRequest("ModifyAutoSnapshotPolicyEx", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new ModifyAutoSnapshotPolicyExResponse({}));
  }

  async modifyAutoSnapshotPolicyEx(request: ModifyAutoSnapshotPolicyExRequest): Promise<ModifyAutoSnapshotPolicyExResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyAutoSnapshotPolicyExWithOptions(request, runtime);
  }

  async modifyBandwidthPackageSpecWithOptions(request: ModifyBandwidthPackageSpecRequest, runtime: $Util.RuntimeOptions): Promise<ModifyBandwidthPackageSpecResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ModifyBandwidthPackageSpecResponse>(await this.doRPCRequest("ModifyBandwidthPackageSpec", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new ModifyBandwidthPackageSpecResponse({}));
  }

  async modifyBandwidthPackageSpec(request: ModifyBandwidthPackageSpecRequest): Promise<ModifyBandwidthPackageSpecResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyBandwidthPackageSpecWithOptions(request, runtime);
  }

  async modifyCommandWithOptions(request: ModifyCommandRequest, runtime: $Util.RuntimeOptions): Promise<ModifyCommandResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ModifyCommandResponse>(await this.doRPCRequest("ModifyCommand", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new ModifyCommandResponse({}));
  }

  async modifyCommand(request: ModifyCommandRequest): Promise<ModifyCommandResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyCommandWithOptions(request, runtime);
  }

  async modifyDedicatedHostAttributeWithOptions(request: ModifyDedicatedHostAttributeRequest, runtime: $Util.RuntimeOptions): Promise<ModifyDedicatedHostAttributeResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ModifyDedicatedHostAttributeResponse>(await this.doRPCRequest("ModifyDedicatedHostAttribute", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new ModifyDedicatedHostAttributeResponse({}));
  }

  async modifyDedicatedHostAttribute(request: ModifyDedicatedHostAttributeRequest): Promise<ModifyDedicatedHostAttributeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyDedicatedHostAttributeWithOptions(request, runtime);
  }

  async modifyDedicatedHostAutoReleaseTimeWithOptions(request: ModifyDedicatedHostAutoReleaseTimeRequest, runtime: $Util.RuntimeOptions): Promise<ModifyDedicatedHostAutoReleaseTimeResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ModifyDedicatedHostAutoReleaseTimeResponse>(await this.doRPCRequest("ModifyDedicatedHostAutoReleaseTime", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new ModifyDedicatedHostAutoReleaseTimeResponse({}));
  }

  async modifyDedicatedHostAutoReleaseTime(request: ModifyDedicatedHostAutoReleaseTimeRequest): Promise<ModifyDedicatedHostAutoReleaseTimeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyDedicatedHostAutoReleaseTimeWithOptions(request, runtime);
  }

  async modifyDedicatedHostAutoRenewAttributeWithOptions(request: ModifyDedicatedHostAutoRenewAttributeRequest, runtime: $Util.RuntimeOptions): Promise<ModifyDedicatedHostAutoRenewAttributeResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ModifyDedicatedHostAutoRenewAttributeResponse>(await this.doRPCRequest("ModifyDedicatedHostAutoRenewAttribute", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new ModifyDedicatedHostAutoRenewAttributeResponse({}));
  }

  async modifyDedicatedHostAutoRenewAttribute(request: ModifyDedicatedHostAutoRenewAttributeRequest): Promise<ModifyDedicatedHostAutoRenewAttributeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyDedicatedHostAutoRenewAttributeWithOptions(request, runtime);
  }

  async modifyDedicatedHostClusterAttributeWithOptions(request: ModifyDedicatedHostClusterAttributeRequest, runtime: $Util.RuntimeOptions): Promise<ModifyDedicatedHostClusterAttributeResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ModifyDedicatedHostClusterAttributeResponse>(await this.doRPCRequest("ModifyDedicatedHostClusterAttribute", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new ModifyDedicatedHostClusterAttributeResponse({}));
  }

  async modifyDedicatedHostClusterAttribute(request: ModifyDedicatedHostClusterAttributeRequest): Promise<ModifyDedicatedHostClusterAttributeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyDedicatedHostClusterAttributeWithOptions(request, runtime);
  }

  async modifyDedicatedHostsChargeTypeWithOptions(request: ModifyDedicatedHostsChargeTypeRequest, runtime: $Util.RuntimeOptions): Promise<ModifyDedicatedHostsChargeTypeResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ModifyDedicatedHostsChargeTypeResponse>(await this.doRPCRequest("ModifyDedicatedHostsChargeType", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new ModifyDedicatedHostsChargeTypeResponse({}));
  }

  async modifyDedicatedHostsChargeType(request: ModifyDedicatedHostsChargeTypeRequest): Promise<ModifyDedicatedHostsChargeTypeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyDedicatedHostsChargeTypeWithOptions(request, runtime);
  }

  async modifyDemandWithOptions(request: ModifyDemandRequest, runtime: $Util.RuntimeOptions): Promise<ModifyDemandResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ModifyDemandResponse>(await this.doRPCRequest("ModifyDemand", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new ModifyDemandResponse({}));
  }

  async modifyDemand(request: ModifyDemandRequest): Promise<ModifyDemandResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyDemandWithOptions(request, runtime);
  }

  async modifyDeploymentSetAttributeWithOptions(request: ModifyDeploymentSetAttributeRequest, runtime: $Util.RuntimeOptions): Promise<ModifyDeploymentSetAttributeResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ModifyDeploymentSetAttributeResponse>(await this.doRPCRequest("ModifyDeploymentSetAttribute", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new ModifyDeploymentSetAttributeResponse({}));
  }

  async modifyDeploymentSetAttribute(request: ModifyDeploymentSetAttributeRequest): Promise<ModifyDeploymentSetAttributeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyDeploymentSetAttributeWithOptions(request, runtime);
  }

  async modifyDiskAttributeWithOptions(request: ModifyDiskAttributeRequest, runtime: $Util.RuntimeOptions): Promise<ModifyDiskAttributeResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ModifyDiskAttributeResponse>(await this.doRPCRequest("ModifyDiskAttribute", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new ModifyDiskAttributeResponse({}));
  }

  async modifyDiskAttribute(request: ModifyDiskAttributeRequest): Promise<ModifyDiskAttributeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyDiskAttributeWithOptions(request, runtime);
  }

  async modifyDiskChargeTypeWithOptions(request: ModifyDiskChargeTypeRequest, runtime: $Util.RuntimeOptions): Promise<ModifyDiskChargeTypeResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ModifyDiskChargeTypeResponse>(await this.doRPCRequest("ModifyDiskChargeType", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new ModifyDiskChargeTypeResponse({}));
  }

  async modifyDiskChargeType(request: ModifyDiskChargeTypeRequest): Promise<ModifyDiskChargeTypeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyDiskChargeTypeWithOptions(request, runtime);
  }

  async modifyDiskSpecWithOptions(request: ModifyDiskSpecRequest, runtime: $Util.RuntimeOptions): Promise<ModifyDiskSpecResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ModifyDiskSpecResponse>(await this.doRPCRequest("ModifyDiskSpec", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new ModifyDiskSpecResponse({}));
  }

  async modifyDiskSpec(request: ModifyDiskSpecRequest): Promise<ModifyDiskSpecResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyDiskSpecWithOptions(request, runtime);
  }

  async modifyEipAddressAttributeWithOptions(request: ModifyEipAddressAttributeRequest, runtime: $Util.RuntimeOptions): Promise<ModifyEipAddressAttributeResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ModifyEipAddressAttributeResponse>(await this.doRPCRequest("ModifyEipAddressAttribute", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new ModifyEipAddressAttributeResponse({}));
  }

  async modifyEipAddressAttribute(request: ModifyEipAddressAttributeRequest): Promise<ModifyEipAddressAttributeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyEipAddressAttributeWithOptions(request, runtime);
  }

  async modifyForwardEntryWithOptions(request: ModifyForwardEntryRequest, runtime: $Util.RuntimeOptions): Promise<ModifyForwardEntryResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ModifyForwardEntryResponse>(await this.doRPCRequest("ModifyForwardEntry", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new ModifyForwardEntryResponse({}));
  }

  async modifyForwardEntry(request: ModifyForwardEntryRequest): Promise<ModifyForwardEntryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyForwardEntryWithOptions(request, runtime);
  }

  async modifyHaVipAttributeWithOptions(request: ModifyHaVipAttributeRequest, runtime: $Util.RuntimeOptions): Promise<ModifyHaVipAttributeResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ModifyHaVipAttributeResponse>(await this.doRPCRequest("ModifyHaVipAttribute", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new ModifyHaVipAttributeResponse({}));
  }

  async modifyHaVipAttribute(request: ModifyHaVipAttributeRequest): Promise<ModifyHaVipAttributeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyHaVipAttributeWithOptions(request, runtime);
  }

  async modifyHpcClusterAttributeWithOptions(request: ModifyHpcClusterAttributeRequest, runtime: $Util.RuntimeOptions): Promise<ModifyHpcClusterAttributeResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ModifyHpcClusterAttributeResponse>(await this.doRPCRequest("ModifyHpcClusterAttribute", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new ModifyHpcClusterAttributeResponse({}));
  }

  async modifyHpcClusterAttribute(request: ModifyHpcClusterAttributeRequest): Promise<ModifyHpcClusterAttributeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyHpcClusterAttributeWithOptions(request, runtime);
  }

  async modifyImageAttributeWithOptions(request: ModifyImageAttributeRequest, runtime: $Util.RuntimeOptions): Promise<ModifyImageAttributeResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ModifyImageAttributeResponse>(await this.doRPCRequest("ModifyImageAttribute", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new ModifyImageAttributeResponse({}));
  }

  async modifyImageAttribute(request: ModifyImageAttributeRequest): Promise<ModifyImageAttributeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyImageAttributeWithOptions(request, runtime);
  }

  async modifyImageShareGroupPermissionWithOptions(request: ModifyImageShareGroupPermissionRequest, runtime: $Util.RuntimeOptions): Promise<ModifyImageShareGroupPermissionResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ModifyImageShareGroupPermissionResponse>(await this.doRPCRequest("ModifyImageShareGroupPermission", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new ModifyImageShareGroupPermissionResponse({}));
  }

  async modifyImageShareGroupPermission(request: ModifyImageShareGroupPermissionRequest): Promise<ModifyImageShareGroupPermissionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyImageShareGroupPermissionWithOptions(request, runtime);
  }

  async modifyImageSharePermissionWithOptions(request: ModifyImageSharePermissionRequest, runtime: $Util.RuntimeOptions): Promise<ModifyImageSharePermissionResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ModifyImageSharePermissionResponse>(await this.doRPCRequest("ModifyImageSharePermission", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new ModifyImageSharePermissionResponse({}));
  }

  async modifyImageSharePermission(request: ModifyImageSharePermissionRequest): Promise<ModifyImageSharePermissionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyImageSharePermissionWithOptions(request, runtime);
  }

  async modifyInstanceAttachmentAttributesWithOptions(request: ModifyInstanceAttachmentAttributesRequest, runtime: $Util.RuntimeOptions): Promise<ModifyInstanceAttachmentAttributesResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ModifyInstanceAttachmentAttributesResponse>(await this.doRPCRequest("ModifyInstanceAttachmentAttributes", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new ModifyInstanceAttachmentAttributesResponse({}));
  }

  async modifyInstanceAttachmentAttributes(request: ModifyInstanceAttachmentAttributesRequest): Promise<ModifyInstanceAttachmentAttributesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyInstanceAttachmentAttributesWithOptions(request, runtime);
  }

  async modifyInstanceAttributeWithOptions(request: ModifyInstanceAttributeRequest, runtime: $Util.RuntimeOptions): Promise<ModifyInstanceAttributeResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ModifyInstanceAttributeResponse>(await this.doRPCRequest("ModifyInstanceAttribute", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new ModifyInstanceAttributeResponse({}));
  }

  async modifyInstanceAttribute(request: ModifyInstanceAttributeRequest): Promise<ModifyInstanceAttributeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyInstanceAttributeWithOptions(request, runtime);
  }

  async modifyInstanceAutoReleaseTimeWithOptions(request: ModifyInstanceAutoReleaseTimeRequest, runtime: $Util.RuntimeOptions): Promise<ModifyInstanceAutoReleaseTimeResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ModifyInstanceAutoReleaseTimeResponse>(await this.doRPCRequest("ModifyInstanceAutoReleaseTime", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new ModifyInstanceAutoReleaseTimeResponse({}));
  }

  async modifyInstanceAutoReleaseTime(request: ModifyInstanceAutoReleaseTimeRequest): Promise<ModifyInstanceAutoReleaseTimeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyInstanceAutoReleaseTimeWithOptions(request, runtime);
  }

  async modifyInstanceAutoRenewAttributeWithOptions(request: ModifyInstanceAutoRenewAttributeRequest, runtime: $Util.RuntimeOptions): Promise<ModifyInstanceAutoRenewAttributeResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ModifyInstanceAutoRenewAttributeResponse>(await this.doRPCRequest("ModifyInstanceAutoRenewAttribute", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new ModifyInstanceAutoRenewAttributeResponse({}));
  }

  async modifyInstanceAutoRenewAttribute(request: ModifyInstanceAutoRenewAttributeRequest): Promise<ModifyInstanceAutoRenewAttributeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyInstanceAutoRenewAttributeWithOptions(request, runtime);
  }

  async modifyInstanceChargeTypeWithOptions(request: ModifyInstanceChargeTypeRequest, runtime: $Util.RuntimeOptions): Promise<ModifyInstanceChargeTypeResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ModifyInstanceChargeTypeResponse>(await this.doRPCRequest("ModifyInstanceChargeType", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new ModifyInstanceChargeTypeResponse({}));
  }

  async modifyInstanceChargeType(request: ModifyInstanceChargeTypeRequest): Promise<ModifyInstanceChargeTypeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyInstanceChargeTypeWithOptions(request, runtime);
  }

  async modifyInstanceDeploymentWithOptions(request: ModifyInstanceDeploymentRequest, runtime: $Util.RuntimeOptions): Promise<ModifyInstanceDeploymentResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ModifyInstanceDeploymentResponse>(await this.doRPCRequest("ModifyInstanceDeployment", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new ModifyInstanceDeploymentResponse({}));
  }

  async modifyInstanceDeployment(request: ModifyInstanceDeploymentRequest): Promise<ModifyInstanceDeploymentResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyInstanceDeploymentWithOptions(request, runtime);
  }

  async modifyInstanceMaintenanceAttributesWithOptions(request: ModifyInstanceMaintenanceAttributesRequest, runtime: $Util.RuntimeOptions): Promise<ModifyInstanceMaintenanceAttributesResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ModifyInstanceMaintenanceAttributesResponse>(await this.doRPCRequest("ModifyInstanceMaintenanceAttributes", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new ModifyInstanceMaintenanceAttributesResponse({}));
  }

  async modifyInstanceMaintenanceAttributes(request: ModifyInstanceMaintenanceAttributesRequest): Promise<ModifyInstanceMaintenanceAttributesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyInstanceMaintenanceAttributesWithOptions(request, runtime);
  }

  async modifyInstanceMetadataOptionsWithOptions(request: ModifyInstanceMetadataOptionsRequest, runtime: $Util.RuntimeOptions): Promise<ModifyInstanceMetadataOptionsResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ModifyInstanceMetadataOptionsResponse>(await this.doRPCRequest("ModifyInstanceMetadataOptions", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new ModifyInstanceMetadataOptionsResponse({}));
  }

  async modifyInstanceMetadataOptions(request: ModifyInstanceMetadataOptionsRequest): Promise<ModifyInstanceMetadataOptionsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyInstanceMetadataOptionsWithOptions(request, runtime);
  }

  async modifyInstanceNetworkSpecWithOptions(request: ModifyInstanceNetworkSpecRequest, runtime: $Util.RuntimeOptions): Promise<ModifyInstanceNetworkSpecResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ModifyInstanceNetworkSpecResponse>(await this.doRPCRequest("ModifyInstanceNetworkSpec", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new ModifyInstanceNetworkSpecResponse({}));
  }

  async modifyInstanceNetworkSpec(request: ModifyInstanceNetworkSpecRequest): Promise<ModifyInstanceNetworkSpecResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyInstanceNetworkSpecWithOptions(request, runtime);
  }

  async modifyInstanceSpecWithOptions(request: ModifyInstanceSpecRequest, runtime: $Util.RuntimeOptions): Promise<ModifyInstanceSpecResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ModifyInstanceSpecResponse>(await this.doRPCRequest("ModifyInstanceSpec", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new ModifyInstanceSpecResponse({}));
  }

  async modifyInstanceSpec(request: ModifyInstanceSpecRequest): Promise<ModifyInstanceSpecResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyInstanceSpecWithOptions(request, runtime);
  }

  async modifyInstanceVncPasswdWithOptions(request: ModifyInstanceVncPasswdRequest, runtime: $Util.RuntimeOptions): Promise<ModifyInstanceVncPasswdResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ModifyInstanceVncPasswdResponse>(await this.doRPCRequest("ModifyInstanceVncPasswd", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new ModifyInstanceVncPasswdResponse({}));
  }

  async modifyInstanceVncPasswd(request: ModifyInstanceVncPasswdRequest): Promise<ModifyInstanceVncPasswdResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyInstanceVncPasswdWithOptions(request, runtime);
  }

  async modifyInstanceVpcAttributeWithOptions(request: ModifyInstanceVpcAttributeRequest, runtime: $Util.RuntimeOptions): Promise<ModifyInstanceVpcAttributeResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ModifyInstanceVpcAttributeResponse>(await this.doRPCRequest("ModifyInstanceVpcAttribute", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new ModifyInstanceVpcAttributeResponse({}));
  }

  async modifyInstanceVpcAttribute(request: ModifyInstanceVpcAttributeRequest): Promise<ModifyInstanceVpcAttributeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyInstanceVpcAttributeWithOptions(request, runtime);
  }

  async modifyLaunchTemplateDefaultVersionWithOptions(request: ModifyLaunchTemplateDefaultVersionRequest, runtime: $Util.RuntimeOptions): Promise<ModifyLaunchTemplateDefaultVersionResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ModifyLaunchTemplateDefaultVersionResponse>(await this.doRPCRequest("ModifyLaunchTemplateDefaultVersion", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new ModifyLaunchTemplateDefaultVersionResponse({}));
  }

  async modifyLaunchTemplateDefaultVersion(request: ModifyLaunchTemplateDefaultVersionRequest): Promise<ModifyLaunchTemplateDefaultVersionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyLaunchTemplateDefaultVersionWithOptions(request, runtime);
  }

  async modifyNetworkInterfaceAttributeWithOptions(request: ModifyNetworkInterfaceAttributeRequest, runtime: $Util.RuntimeOptions): Promise<ModifyNetworkInterfaceAttributeResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ModifyNetworkInterfaceAttributeResponse>(await this.doRPCRequest("ModifyNetworkInterfaceAttribute", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new ModifyNetworkInterfaceAttributeResponse({}));
  }

  async modifyNetworkInterfaceAttribute(request: ModifyNetworkInterfaceAttributeRequest): Promise<ModifyNetworkInterfaceAttributeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyNetworkInterfaceAttributeWithOptions(request, runtime);
  }

  async modifyPrepayInstanceSpecWithOptions(request: ModifyPrepayInstanceSpecRequest, runtime: $Util.RuntimeOptions): Promise<ModifyPrepayInstanceSpecResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ModifyPrepayInstanceSpecResponse>(await this.doRPCRequest("ModifyPrepayInstanceSpec", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new ModifyPrepayInstanceSpecResponse({}));
  }

  async modifyPrepayInstanceSpec(request: ModifyPrepayInstanceSpecRequest): Promise<ModifyPrepayInstanceSpecResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyPrepayInstanceSpecWithOptions(request, runtime);
  }

  async modifyReservedInstanceAttributeWithOptions(request: ModifyReservedInstanceAttributeRequest, runtime: $Util.RuntimeOptions): Promise<ModifyReservedInstanceAttributeResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ModifyReservedInstanceAttributeResponse>(await this.doRPCRequest("ModifyReservedInstanceAttribute", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new ModifyReservedInstanceAttributeResponse({}));
  }

  async modifyReservedInstanceAttribute(request: ModifyReservedInstanceAttributeRequest): Promise<ModifyReservedInstanceAttributeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyReservedInstanceAttributeWithOptions(request, runtime);
  }

  async modifyReservedInstancesWithOptions(request: ModifyReservedInstancesRequest, runtime: $Util.RuntimeOptions): Promise<ModifyReservedInstancesResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ModifyReservedInstancesResponse>(await this.doRPCRequest("ModifyReservedInstances", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new ModifyReservedInstancesResponse({}));
  }

  async modifyReservedInstances(request: ModifyReservedInstancesRequest): Promise<ModifyReservedInstancesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyReservedInstancesWithOptions(request, runtime);
  }

  async modifyRouterInterfaceAttributeWithOptions(request: ModifyRouterInterfaceAttributeRequest, runtime: $Util.RuntimeOptions): Promise<ModifyRouterInterfaceAttributeResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ModifyRouterInterfaceAttributeResponse>(await this.doRPCRequest("ModifyRouterInterfaceAttribute", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new ModifyRouterInterfaceAttributeResponse({}));
  }

  async modifyRouterInterfaceAttribute(request: ModifyRouterInterfaceAttributeRequest): Promise<ModifyRouterInterfaceAttributeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyRouterInterfaceAttributeWithOptions(request, runtime);
  }

  async modifyRouterInterfaceSpecWithOptions(request: ModifyRouterInterfaceSpecRequest, runtime: $Util.RuntimeOptions): Promise<ModifyRouterInterfaceSpecResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ModifyRouterInterfaceSpecResponse>(await this.doRPCRequest("ModifyRouterInterfaceSpec", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new ModifyRouterInterfaceSpecResponse({}));
  }

  async modifyRouterInterfaceSpec(request: ModifyRouterInterfaceSpecRequest): Promise<ModifyRouterInterfaceSpecResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyRouterInterfaceSpecWithOptions(request, runtime);
  }

  async modifySecurityGroupAttributeWithOptions(request: ModifySecurityGroupAttributeRequest, runtime: $Util.RuntimeOptions): Promise<ModifySecurityGroupAttributeResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ModifySecurityGroupAttributeResponse>(await this.doRPCRequest("ModifySecurityGroupAttribute", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new ModifySecurityGroupAttributeResponse({}));
  }

  async modifySecurityGroupAttribute(request: ModifySecurityGroupAttributeRequest): Promise<ModifySecurityGroupAttributeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifySecurityGroupAttributeWithOptions(request, runtime);
  }

  async modifySecurityGroupEgressRuleWithOptions(request: ModifySecurityGroupEgressRuleRequest, runtime: $Util.RuntimeOptions): Promise<ModifySecurityGroupEgressRuleResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ModifySecurityGroupEgressRuleResponse>(await this.doRPCRequest("ModifySecurityGroupEgressRule", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new ModifySecurityGroupEgressRuleResponse({}));
  }

  async modifySecurityGroupEgressRule(request: ModifySecurityGroupEgressRuleRequest): Promise<ModifySecurityGroupEgressRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifySecurityGroupEgressRuleWithOptions(request, runtime);
  }

  async modifySecurityGroupPolicyWithOptions(request: ModifySecurityGroupPolicyRequest, runtime: $Util.RuntimeOptions): Promise<ModifySecurityGroupPolicyResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ModifySecurityGroupPolicyResponse>(await this.doRPCRequest("ModifySecurityGroupPolicy", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new ModifySecurityGroupPolicyResponse({}));
  }

  async modifySecurityGroupPolicy(request: ModifySecurityGroupPolicyRequest): Promise<ModifySecurityGroupPolicyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifySecurityGroupPolicyWithOptions(request, runtime);
  }

  async modifySecurityGroupRuleWithOptions(request: ModifySecurityGroupRuleRequest, runtime: $Util.RuntimeOptions): Promise<ModifySecurityGroupRuleResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ModifySecurityGroupRuleResponse>(await this.doRPCRequest("ModifySecurityGroupRule", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new ModifySecurityGroupRuleResponse({}));
  }

  async modifySecurityGroupRule(request: ModifySecurityGroupRuleRequest): Promise<ModifySecurityGroupRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifySecurityGroupRuleWithOptions(request, runtime);
  }

  async modifySnapshotAttributeWithOptions(request: ModifySnapshotAttributeRequest, runtime: $Util.RuntimeOptions): Promise<ModifySnapshotAttributeResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ModifySnapshotAttributeResponse>(await this.doRPCRequest("ModifySnapshotAttribute", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new ModifySnapshotAttributeResponse({}));
  }

  async modifySnapshotAttribute(request: ModifySnapshotAttributeRequest): Promise<ModifySnapshotAttributeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifySnapshotAttributeWithOptions(request, runtime);
  }

  async modifyStorageCapacityUnitAttributeWithOptions(request: ModifyStorageCapacityUnitAttributeRequest, runtime: $Util.RuntimeOptions): Promise<ModifyStorageCapacityUnitAttributeResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ModifyStorageCapacityUnitAttributeResponse>(await this.doRPCRequest("ModifyStorageCapacityUnitAttribute", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new ModifyStorageCapacityUnitAttributeResponse({}));
  }

  async modifyStorageCapacityUnitAttribute(request: ModifyStorageCapacityUnitAttributeRequest): Promise<ModifyStorageCapacityUnitAttributeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyStorageCapacityUnitAttributeWithOptions(request, runtime);
  }

  async modifyStorageSetAttributeWithOptions(request: ModifyStorageSetAttributeRequest, runtime: $Util.RuntimeOptions): Promise<ModifyStorageSetAttributeResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ModifyStorageSetAttributeResponse>(await this.doRPCRequest("ModifyStorageSetAttribute", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new ModifyStorageSetAttributeResponse({}));
  }

  async modifyStorageSetAttribute(request: ModifyStorageSetAttributeRequest): Promise<ModifyStorageSetAttributeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyStorageSetAttributeWithOptions(request, runtime);
  }

  async modifyUserBusinessBehaviorWithOptions(request: ModifyUserBusinessBehaviorRequest, runtime: $Util.RuntimeOptions): Promise<ModifyUserBusinessBehaviorResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ModifyUserBusinessBehaviorResponse>(await this.doRPCRequest("ModifyUserBusinessBehavior", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new ModifyUserBusinessBehaviorResponse({}));
  }

  async modifyUserBusinessBehavior(request: ModifyUserBusinessBehaviorRequest): Promise<ModifyUserBusinessBehaviorResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyUserBusinessBehaviorWithOptions(request, runtime);
  }

  async modifyVirtualBorderRouterAttributeWithOptions(request: ModifyVirtualBorderRouterAttributeRequest, runtime: $Util.RuntimeOptions): Promise<ModifyVirtualBorderRouterAttributeResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ModifyVirtualBorderRouterAttributeResponse>(await this.doRPCRequest("ModifyVirtualBorderRouterAttribute", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new ModifyVirtualBorderRouterAttributeResponse({}));
  }

  async modifyVirtualBorderRouterAttribute(request: ModifyVirtualBorderRouterAttributeRequest): Promise<ModifyVirtualBorderRouterAttributeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyVirtualBorderRouterAttributeWithOptions(request, runtime);
  }

  async modifyVpcAttributeWithOptions(request: ModifyVpcAttributeRequest, runtime: $Util.RuntimeOptions): Promise<ModifyVpcAttributeResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ModifyVpcAttributeResponse>(await this.doRPCRequest("ModifyVpcAttribute", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new ModifyVpcAttributeResponse({}));
  }

  async modifyVpcAttribute(request: ModifyVpcAttributeRequest): Promise<ModifyVpcAttributeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyVpcAttributeWithOptions(request, runtime);
  }

  async modifyVRouterAttributeWithOptions(request: ModifyVRouterAttributeRequest, runtime: $Util.RuntimeOptions): Promise<ModifyVRouterAttributeResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ModifyVRouterAttributeResponse>(await this.doRPCRequest("ModifyVRouterAttribute", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new ModifyVRouterAttributeResponse({}));
  }

  async modifyVRouterAttribute(request: ModifyVRouterAttributeRequest): Promise<ModifyVRouterAttributeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyVRouterAttributeWithOptions(request, runtime);
  }

  async modifyVSwitchAttributeWithOptions(request: ModifyVSwitchAttributeRequest, runtime: $Util.RuntimeOptions): Promise<ModifyVSwitchAttributeResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ModifyVSwitchAttributeResponse>(await this.doRPCRequest("ModifyVSwitchAttribute", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new ModifyVSwitchAttributeResponse({}));
  }

  async modifyVSwitchAttribute(request: ModifyVSwitchAttributeRequest): Promise<ModifyVSwitchAttributeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyVSwitchAttributeWithOptions(request, runtime);
  }

  async purchaseReservedInstancesOfferingWithOptions(request: PurchaseReservedInstancesOfferingRequest, runtime: $Util.RuntimeOptions): Promise<PurchaseReservedInstancesOfferingResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<PurchaseReservedInstancesOfferingResponse>(await this.doRPCRequest("PurchaseReservedInstancesOffering", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new PurchaseReservedInstancesOfferingResponse({}));
  }

  async purchaseReservedInstancesOffering(request: PurchaseReservedInstancesOfferingRequest): Promise<PurchaseReservedInstancesOfferingResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.purchaseReservedInstancesOfferingWithOptions(request, runtime);
  }

  async purchaseStorageCapacityUnitWithOptions(request: PurchaseStorageCapacityUnitRequest, runtime: $Util.RuntimeOptions): Promise<PurchaseStorageCapacityUnitResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<PurchaseStorageCapacityUnitResponse>(await this.doRPCRequest("PurchaseStorageCapacityUnit", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new PurchaseStorageCapacityUnitResponse({}));
  }

  async purchaseStorageCapacityUnit(request: PurchaseStorageCapacityUnitRequest): Promise<PurchaseStorageCapacityUnitResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.purchaseStorageCapacityUnitWithOptions(request, runtime);
  }

  async reActivateInstancesWithOptions(request: ReActivateInstancesRequest, runtime: $Util.RuntimeOptions): Promise<ReActivateInstancesResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ReActivateInstancesResponse>(await this.doRPCRequest("ReActivateInstances", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new ReActivateInstancesResponse({}));
  }

  async reActivateInstances(request: ReActivateInstancesRequest): Promise<ReActivateInstancesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.reActivateInstancesWithOptions(request, runtime);
  }

  async rebootInstanceWithOptions(request: RebootInstanceRequest, runtime: $Util.RuntimeOptions): Promise<RebootInstanceResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<RebootInstanceResponse>(await this.doRPCRequest("RebootInstance", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new RebootInstanceResponse({}));
  }

  async rebootInstance(request: RebootInstanceRequest): Promise<RebootInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.rebootInstanceWithOptions(request, runtime);
  }

  async rebootInstancesWithOptions(request: RebootInstancesRequest, runtime: $Util.RuntimeOptions): Promise<RebootInstancesResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<RebootInstancesResponse>(await this.doRPCRequest("RebootInstances", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new RebootInstancesResponse({}));
  }

  async rebootInstances(request: RebootInstancesRequest): Promise<RebootInstancesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.rebootInstancesWithOptions(request, runtime);
  }

  async recoverVirtualBorderRouterWithOptions(request: RecoverVirtualBorderRouterRequest, runtime: $Util.RuntimeOptions): Promise<RecoverVirtualBorderRouterResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<RecoverVirtualBorderRouterResponse>(await this.doRPCRequest("RecoverVirtualBorderRouter", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new RecoverVirtualBorderRouterResponse({}));
  }

  async recoverVirtualBorderRouter(request: RecoverVirtualBorderRouterRequest): Promise<RecoverVirtualBorderRouterResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.recoverVirtualBorderRouterWithOptions(request, runtime);
  }

  async redeployDedicatedHostWithOptions(request: RedeployDedicatedHostRequest, runtime: $Util.RuntimeOptions): Promise<RedeployDedicatedHostResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<RedeployDedicatedHostResponse>(await this.doRPCRequest("RedeployDedicatedHost", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new RedeployDedicatedHostResponse({}));
  }

  async redeployDedicatedHost(request: RedeployDedicatedHostRequest): Promise<RedeployDedicatedHostResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.redeployDedicatedHostWithOptions(request, runtime);
  }

  async redeployInstanceWithOptions(request: RedeployInstanceRequest, runtime: $Util.RuntimeOptions): Promise<RedeployInstanceResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<RedeployInstanceResponse>(await this.doRPCRequest("RedeployInstance", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new RedeployInstanceResponse({}));
  }

  async redeployInstance(request: RedeployInstanceRequest): Promise<RedeployInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.redeployInstanceWithOptions(request, runtime);
  }

  async reInitDiskWithOptions(request: ReInitDiskRequest, runtime: $Util.RuntimeOptions): Promise<ReInitDiskResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ReInitDiskResponse>(await this.doRPCRequest("ReInitDisk", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new ReInitDiskResponse({}));
  }

  async reInitDisk(request: ReInitDiskRequest): Promise<ReInitDiskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.reInitDiskWithOptions(request, runtime);
  }

  async releaseCapacityReservationWithOptions(request: ReleaseCapacityReservationRequest, runtime: $Util.RuntimeOptions): Promise<ReleaseCapacityReservationResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ReleaseCapacityReservationResponse>(await this.doRPCRequest("ReleaseCapacityReservation", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new ReleaseCapacityReservationResponse({}));
  }

  async releaseCapacityReservation(request: ReleaseCapacityReservationRequest): Promise<ReleaseCapacityReservationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.releaseCapacityReservationWithOptions(request, runtime);
  }

  async releaseDedicatedHostWithOptions(request: ReleaseDedicatedHostRequest, runtime: $Util.RuntimeOptions): Promise<ReleaseDedicatedHostResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ReleaseDedicatedHostResponse>(await this.doRPCRequest("ReleaseDedicatedHost", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new ReleaseDedicatedHostResponse({}));
  }

  async releaseDedicatedHost(request: ReleaseDedicatedHostRequest): Promise<ReleaseDedicatedHostResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.releaseDedicatedHostWithOptions(request, runtime);
  }

  async releaseEipAddressWithOptions(request: ReleaseEipAddressRequest, runtime: $Util.RuntimeOptions): Promise<ReleaseEipAddressResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ReleaseEipAddressResponse>(await this.doRPCRequest("ReleaseEipAddress", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new ReleaseEipAddressResponse({}));
  }

  async releaseEipAddress(request: ReleaseEipAddressRequest): Promise<ReleaseEipAddressResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.releaseEipAddressWithOptions(request, runtime);
  }

  async releasePublicIpAddressWithOptions(request: ReleasePublicIpAddressRequest, runtime: $Util.RuntimeOptions): Promise<ReleasePublicIpAddressResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ReleasePublicIpAddressResponse>(await this.doRPCRequest("ReleasePublicIpAddress", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new ReleasePublicIpAddressResponse({}));
  }

  async releasePublicIpAddress(request: ReleasePublicIpAddressRequest): Promise<ReleasePublicIpAddressResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.releasePublicIpAddressWithOptions(request, runtime);
  }

  async removeBandwidthPackageIpsWithOptions(request: RemoveBandwidthPackageIpsRequest, runtime: $Util.RuntimeOptions): Promise<RemoveBandwidthPackageIpsResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<RemoveBandwidthPackageIpsResponse>(await this.doRPCRequest("RemoveBandwidthPackageIps", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new RemoveBandwidthPackageIpsResponse({}));
  }

  async removeBandwidthPackageIps(request: RemoveBandwidthPackageIpsRequest): Promise<RemoveBandwidthPackageIpsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.removeBandwidthPackageIpsWithOptions(request, runtime);
  }

  async removeTagsWithOptions(request: RemoveTagsRequest, runtime: $Util.RuntimeOptions): Promise<RemoveTagsResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<RemoveTagsResponse>(await this.doRPCRequest("RemoveTags", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new RemoveTagsResponse({}));
  }

  async removeTags(request: RemoveTagsRequest): Promise<RemoveTagsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.removeTagsWithOptions(request, runtime);
  }

  async renewDedicatedHostsWithOptions(request: RenewDedicatedHostsRequest, runtime: $Util.RuntimeOptions): Promise<RenewDedicatedHostsResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<RenewDedicatedHostsResponse>(await this.doRPCRequest("RenewDedicatedHosts", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new RenewDedicatedHostsResponse({}));
  }

  async renewDedicatedHosts(request: RenewDedicatedHostsRequest): Promise<RenewDedicatedHostsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.renewDedicatedHostsWithOptions(request, runtime);
  }

  async renewInstanceWithOptions(request: RenewInstanceRequest, runtime: $Util.RuntimeOptions): Promise<RenewInstanceResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<RenewInstanceResponse>(await this.doRPCRequest("RenewInstance", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new RenewInstanceResponse({}));
  }

  async renewInstance(request: RenewInstanceRequest): Promise<RenewInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.renewInstanceWithOptions(request, runtime);
  }

  async replaceSystemDiskWithOptions(request: ReplaceSystemDiskRequest, runtime: $Util.RuntimeOptions): Promise<ReplaceSystemDiskResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ReplaceSystemDiskResponse>(await this.doRPCRequest("ReplaceSystemDisk", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new ReplaceSystemDiskResponse({}));
  }

  async replaceSystemDisk(request: ReplaceSystemDiskRequest): Promise<ReplaceSystemDiskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.replaceSystemDiskWithOptions(request, runtime);
  }

  async reportInstancesStatusWithOptions(request: ReportInstancesStatusRequest, runtime: $Util.RuntimeOptions): Promise<ReportInstancesStatusResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ReportInstancesStatusResponse>(await this.doRPCRequest("ReportInstancesStatus", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new ReportInstancesStatusResponse({}));
  }

  async reportInstancesStatus(request: ReportInstancesStatusRequest): Promise<ReportInstancesStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.reportInstancesStatusWithOptions(request, runtime);
  }

  async resetDiskWithOptions(request: ResetDiskRequest, runtime: $Util.RuntimeOptions): Promise<ResetDiskResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ResetDiskResponse>(await this.doRPCRequest("ResetDisk", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new ResetDiskResponse({}));
  }

  async resetDisk(request: ResetDiskRequest): Promise<ResetDiskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.resetDiskWithOptions(request, runtime);
  }

  async resizeDiskWithOptions(request: ResizeDiskRequest, runtime: $Util.RuntimeOptions): Promise<ResizeDiskResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<ResizeDiskResponse>(await this.doRPCRequest("ResizeDisk", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new ResizeDiskResponse({}));
  }

  async resizeDisk(request: ResizeDiskRequest): Promise<ResizeDiskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.resizeDiskWithOptions(request, runtime);
  }

  async revokeSecurityGroupWithOptions(request: RevokeSecurityGroupRequest, runtime: $Util.RuntimeOptions): Promise<RevokeSecurityGroupResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<RevokeSecurityGroupResponse>(await this.doRPCRequest("RevokeSecurityGroup", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new RevokeSecurityGroupResponse({}));
  }

  async revokeSecurityGroup(request: RevokeSecurityGroupRequest): Promise<RevokeSecurityGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.revokeSecurityGroupWithOptions(request, runtime);
  }

  async revokeSecurityGroupEgressWithOptions(request: RevokeSecurityGroupEgressRequest, runtime: $Util.RuntimeOptions): Promise<RevokeSecurityGroupEgressResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<RevokeSecurityGroupEgressResponse>(await this.doRPCRequest("RevokeSecurityGroupEgress", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new RevokeSecurityGroupEgressResponse({}));
  }

  async revokeSecurityGroupEgress(request: RevokeSecurityGroupEgressRequest): Promise<RevokeSecurityGroupEgressResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.revokeSecurityGroupEgressWithOptions(request, runtime);
  }

  async runCommandWithOptions(tmpReq: RunCommandRequest, runtime: $Util.RuntimeOptions): Promise<RunCommandResponse> {
    Util.validateModel(tmpReq);
    let request = new RunCommandShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.parameters)) {
      request.parametersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.parameters, "Parameters", "json");
    }

    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<RunCommandResponse>(await this.doRPCRequest("RunCommand", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new RunCommandResponse({}));
  }

  async runCommand(request: RunCommandRequest): Promise<RunCommandResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.runCommandWithOptions(request, runtime);
  }

  async sendFileWithOptions(request: SendFileRequest, runtime: $Util.RuntimeOptions): Promise<SendFileResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<SendFileResponse>(await this.doRPCRequest("SendFile", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new SendFileResponse({}));
  }

  async sendFile(request: SendFileRequest): Promise<SendFileResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.sendFileWithOptions(request, runtime);
  }

  async startElasticityAssuranceWithOptions(request: StartElasticityAssuranceRequest, runtime: $Util.RuntimeOptions): Promise<StartElasticityAssuranceResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<StartElasticityAssuranceResponse>(await this.doRPCRequest("StartElasticityAssurance", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new StartElasticityAssuranceResponse({}));
  }

  async startElasticityAssurance(request: StartElasticityAssuranceRequest): Promise<StartElasticityAssuranceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.startElasticityAssuranceWithOptions(request, runtime);
  }

  async startInstanceWithOptions(request: StartInstanceRequest, runtime: $Util.RuntimeOptions): Promise<StartInstanceResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<StartInstanceResponse>(await this.doRPCRequest("StartInstance", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new StartInstanceResponse({}));
  }

  async startInstance(request: StartInstanceRequest): Promise<StartInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.startInstanceWithOptions(request, runtime);
  }

  async startInstancesWithOptions(request: StartInstancesRequest, runtime: $Util.RuntimeOptions): Promise<StartInstancesResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<StartInstancesResponse>(await this.doRPCRequest("StartInstances", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new StartInstancesResponse({}));
  }

  async startInstances(request: StartInstancesRequest): Promise<StartInstancesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.startInstancesWithOptions(request, runtime);
  }

  async stopInstanceWithOptions(request: StopInstanceRequest, runtime: $Util.RuntimeOptions): Promise<StopInstanceResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<StopInstanceResponse>(await this.doRPCRequest("StopInstance", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new StopInstanceResponse({}));
  }

  async stopInstance(request: StopInstanceRequest): Promise<StopInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.stopInstanceWithOptions(request, runtime);
  }

  async stopInstancesWithOptions(request: StopInstancesRequest, runtime: $Util.RuntimeOptions): Promise<StopInstancesResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<StopInstancesResponse>(await this.doRPCRequest("StopInstances", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new StopInstancesResponse({}));
  }

  async stopInstances(request: StopInstancesRequest): Promise<StopInstancesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.stopInstancesWithOptions(request, runtime);
  }

  async stopInvocationWithOptions(request: StopInvocationRequest, runtime: $Util.RuntimeOptions): Promise<StopInvocationResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<StopInvocationResponse>(await this.doRPCRequest("StopInvocation", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new StopInvocationResponse({}));
  }

  async stopInvocation(request: StopInvocationRequest): Promise<StopInvocationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.stopInvocationWithOptions(request, runtime);
  }

  async tagResourcesWithOptions(request: TagResourcesRequest, runtime: $Util.RuntimeOptions): Promise<TagResourcesResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<TagResourcesResponse>(await this.doRPCRequest("TagResources", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new TagResourcesResponse({}));
  }

  async tagResources(request: TagResourcesRequest): Promise<TagResourcesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.tagResourcesWithOptions(request, runtime);
  }

  async terminatePhysicalConnectionWithOptions(request: TerminatePhysicalConnectionRequest, runtime: $Util.RuntimeOptions): Promise<TerminatePhysicalConnectionResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<TerminatePhysicalConnectionResponse>(await this.doRPCRequest("TerminatePhysicalConnection", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new TerminatePhysicalConnectionResponse({}));
  }

  async terminatePhysicalConnection(request: TerminatePhysicalConnectionRequest): Promise<TerminatePhysicalConnectionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.terminatePhysicalConnectionWithOptions(request, runtime);
  }

  async terminateVirtualBorderRouterWithOptions(request: TerminateVirtualBorderRouterRequest, runtime: $Util.RuntimeOptions): Promise<TerminateVirtualBorderRouterResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<TerminateVirtualBorderRouterResponse>(await this.doRPCRequest("TerminateVirtualBorderRouter", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new TerminateVirtualBorderRouterResponse({}));
  }

  async terminateVirtualBorderRouter(request: TerminateVirtualBorderRouterRequest): Promise<TerminateVirtualBorderRouterResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.terminateVirtualBorderRouterWithOptions(request, runtime);
  }

  async unassignIpv6AddressesWithOptions(request: UnassignIpv6AddressesRequest, runtime: $Util.RuntimeOptions): Promise<UnassignIpv6AddressesResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<UnassignIpv6AddressesResponse>(await this.doRPCRequest("UnassignIpv6Addresses", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new UnassignIpv6AddressesResponse({}));
  }

  async unassignIpv6Addresses(request: UnassignIpv6AddressesRequest): Promise<UnassignIpv6AddressesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.unassignIpv6AddressesWithOptions(request, runtime);
  }

  async unassignPrivateIpAddressesWithOptions(request: UnassignPrivateIpAddressesRequest, runtime: $Util.RuntimeOptions): Promise<UnassignPrivateIpAddressesResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<UnassignPrivateIpAddressesResponse>(await this.doRPCRequest("UnassignPrivateIpAddresses", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new UnassignPrivateIpAddressesResponse({}));
  }

  async unassignPrivateIpAddresses(request: UnassignPrivateIpAddressesRequest): Promise<UnassignPrivateIpAddressesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.unassignPrivateIpAddressesWithOptions(request, runtime);
  }

  async unassociateEipAddressWithOptions(request: UnassociateEipAddressRequest, runtime: $Util.RuntimeOptions): Promise<UnassociateEipAddressResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<UnassociateEipAddressResponse>(await this.doRPCRequest("UnassociateEipAddress", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new UnassociateEipAddressResponse({}));
  }

  async unassociateEipAddress(request: UnassociateEipAddressRequest): Promise<UnassociateEipAddressResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.unassociateEipAddressWithOptions(request, runtime);
  }

  async unassociateHaVipWithOptions(request: UnassociateHaVipRequest, runtime: $Util.RuntimeOptions): Promise<UnassociateHaVipResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<UnassociateHaVipResponse>(await this.doRPCRequest("UnassociateHaVip", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new UnassociateHaVipResponse({}));
  }

  async unassociateHaVip(request: UnassociateHaVipRequest): Promise<UnassociateHaVipResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.unassociateHaVipWithOptions(request, runtime);
  }

  async untagResourcesWithOptions(request: UntagResourcesRequest, runtime: $Util.RuntimeOptions): Promise<UntagResourcesResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toMap(request),
    });
    return $tea.cast<UntagResourcesResponse>(await this.doRPCRequest("UntagResources", "2014-05-26", "HTTPS", "POST", "AK", "json", req, runtime), new UntagResourcesResponse({}));
  }

  async untagResources(request: UntagResourcesRequest): Promise<UntagResourcesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.untagResourcesWithOptions(request, runtime);
  }

}
