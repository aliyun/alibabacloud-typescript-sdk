// This file is auto-generated, don't edit it
/**
 *
 */
import Util, * as $Util from '@alicloud/tea-util';
import OpenApi, * as $OpenApi from '@alicloud/openapi-client';
import OpenApiUtil from '@alicloud/openapi-util';
import EndpointUtil from '@alicloud/endpoint-util';
import * as $tea from '@alicloud/tea-typescript';

export class DentriesAppPropertiesValue extends $tea.Model {
  name?: string;
  value?: string;
  visibility?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      value: 'Value',
      visibility: 'Visibility',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      value: 'string',
      visibility: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddAttendeeHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: AddAttendeeHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: AddAttendeeHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddAttendeeShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddAttendeeRequest extends $tea.Model {
  attendeesToAdd?: AddAttendeeRequestAttendeesToAdd[];
  calendarId?: string;
  eventId?: string;
  chatNotification?: boolean;
  pushNotification?: boolean;
  static names(): { [key: string]: string } {
    return {
      attendeesToAdd: 'AttendeesToAdd',
      calendarId: 'CalendarId',
      eventId: 'EventId',
      chatNotification: 'chatNotification',
      pushNotification: 'pushNotification',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attendeesToAdd: { 'type': 'array', 'itemType': AddAttendeeRequestAttendeesToAdd },
      calendarId: 'string',
      eventId: 'string',
      chatNotification: 'boolean',
      pushNotification: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddAttendeeShrinkRequest extends $tea.Model {
  attendeesToAddShrink?: string;
  calendarId?: string;
  eventId?: string;
  chatNotification?: boolean;
  pushNotification?: boolean;
  static names(): { [key: string]: string } {
    return {
      attendeesToAddShrink: 'AttendeesToAdd',
      calendarId: 'CalendarId',
      eventId: 'EventId',
      chatNotification: 'chatNotification',
      pushNotification: 'pushNotification',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attendeesToAddShrink: 'string',
      calendarId: 'string',
      eventId: 'string',
      chatNotification: 'boolean',
      pushNotification: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddAttendeeResponseBody extends $tea.Model {
  content?: AddAttendeeResponseBodyContent;
  errorCode?: string;
  errorCtx?: { [key: string]: any };
  errorMsg?: string;
  httpStatusCode?: number;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      errorCode: 'ErrorCode',
      errorCtx: 'ErrorCtx',
      errorMsg: 'ErrorMsg',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: AddAttendeeResponseBodyContent,
      errorCode: 'string',
      errorCtx: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      errorMsg: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddAttendeeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddAttendeeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddAttendeeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddMeetingRoomsHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: AddMeetingRoomsHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: AddMeetingRoomsHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddMeetingRoomsShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddMeetingRoomsRequest extends $tea.Model {
  calendarId?: string;
  eventId?: string;
  meetingRoomsToAdd?: AddMeetingRoomsRequestMeetingRoomsToAdd[];
  static names(): { [key: string]: string } {
    return {
      calendarId: 'CalendarId',
      eventId: 'EventId',
      meetingRoomsToAdd: 'MeetingRoomsToAdd',
    };
  }

  static types(): { [key: string]: any } {
    return {
      calendarId: 'string',
      eventId: 'string',
      meetingRoomsToAdd: { 'type': 'array', 'itemType': AddMeetingRoomsRequestMeetingRoomsToAdd },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddMeetingRoomsShrinkRequest extends $tea.Model {
  calendarId?: string;
  eventId?: string;
  meetingRoomsToAddShrink?: string;
  static names(): { [key: string]: string } {
    return {
      calendarId: 'CalendarId',
      eventId: 'EventId',
      meetingRoomsToAddShrink: 'MeetingRoomsToAdd',
    };
  }

  static types(): { [key: string]: any } {
    return {
      calendarId: 'string',
      eventId: 'string',
      meetingRoomsToAddShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddMeetingRoomsResponseBody extends $tea.Model {
  requestId?: string;
  result?: boolean;
  static names(): { [key: string]: string } {
    return {
      requestId: 'requestId',
      result: 'result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddMeetingRoomsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddMeetingRoomsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddMeetingRoomsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddScenegroupMemberHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: AddScenegroupMemberHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: AddScenegroupMemberHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddScenegroupMemberShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddScenegroupMemberRequest extends $tea.Model {
  openConversationId?: string;
  userIds?: string;
  static names(): { [key: string]: string } {
    return {
      openConversationId: 'OpenConversationId',
      userIds: 'UserIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      openConversationId: 'string',
      userIds: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddScenegroupMemberResponseBody extends $tea.Model {
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddScenegroupMemberResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddScenegroupMemberResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddScenegroupMemberResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddWorkspaceHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: AddWorkspaceHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: AddWorkspaceHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddWorkspaceShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddWorkspaceRequest extends $tea.Model {
  name?: string;
  option?: AddWorkspaceRequestOption;
  tenantContext?: AddWorkspaceRequestTenantContext;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      option: 'Option',
      tenantContext: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      option: AddWorkspaceRequestOption,
      tenantContext: AddWorkspaceRequestTenantContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddWorkspaceShrinkRequest extends $tea.Model {
  name?: string;
  optionShrink?: string;
  tenantContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      optionShrink: 'Option',
      tenantContextShrink: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      optionShrink: 'string',
      tenantContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddWorkspaceResponseBody extends $tea.Model {
  requestId?: string;
  workspace?: AddWorkspaceResponseBodyWorkspace;
  static names(): { [key: string]: string } {
    return {
      requestId: 'requestId',
      workspace: 'workspace',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      workspace: AddWorkspaceResponseBodyWorkspace,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddWorkspaceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddWorkspaceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddWorkspaceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddWorkspaceDocMembersHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: AddWorkspaceDocMembersHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: AddWorkspaceDocMembersHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddWorkspaceDocMembersShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddWorkspaceDocMembersRequest extends $tea.Model {
  members?: AddWorkspaceDocMembersRequestMembers[];
  nodeId?: string;
  tenantContext?: AddWorkspaceDocMembersRequestTenantContext;
  workspaceId?: string;
  static names(): { [key: string]: string } {
    return {
      members: 'Members',
      nodeId: 'NodeId',
      tenantContext: 'TenantContext',
      workspaceId: 'WorkspaceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      members: { 'type': 'array', 'itemType': AddWorkspaceDocMembersRequestMembers },
      nodeId: 'string',
      tenantContext: AddWorkspaceDocMembersRequestTenantContext,
      workspaceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddWorkspaceDocMembersShrinkRequest extends $tea.Model {
  membersShrink?: string;
  nodeId?: string;
  tenantContextShrink?: string;
  workspaceId?: string;
  static names(): { [key: string]: string } {
    return {
      membersShrink: 'Members',
      nodeId: 'NodeId',
      tenantContextShrink: 'TenantContext',
      workspaceId: 'WorkspaceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      membersShrink: 'string',
      nodeId: 'string',
      tenantContextShrink: 'string',
      workspaceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddWorkspaceDocMembersResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'requestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddWorkspaceDocMembersResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddWorkspaceDocMembersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddWorkspaceDocMembersResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddWorkspaceMembersHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: AddWorkspaceMembersHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: AddWorkspaceMembersHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddWorkspaceMembersShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddWorkspaceMembersRequest extends $tea.Model {
  members?: AddWorkspaceMembersRequestMembers[];
  tenantContext?: AddWorkspaceMembersRequestTenantContext;
  workspaceId?: string;
  static names(): { [key: string]: string } {
    return {
      members: 'Members',
      tenantContext: 'TenantContext',
      workspaceId: 'WorkspaceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      members: { 'type': 'array', 'itemType': AddWorkspaceMembersRequestMembers },
      tenantContext: AddWorkspaceMembersRequestTenantContext,
      workspaceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddWorkspaceMembersShrinkRequest extends $tea.Model {
  membersShrink?: string;
  tenantContextShrink?: string;
  workspaceId?: string;
  static names(): { [key: string]: string } {
    return {
      membersShrink: 'Members',
      tenantContextShrink: 'TenantContext',
      workspaceId: 'WorkspaceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      membersShrink: 'string',
      tenantContextShrink: 'string',
      workspaceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddWorkspaceMembersResponseBody extends $tea.Model {
  notInOrgList?: string[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      notInOrgList: 'NotInOrgList',
      requestId: 'requestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      notInOrgList: { 'type': 'array', 'itemType': 'string' },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddWorkspaceMembersResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddWorkspaceMembersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddWorkspaceMembersResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetFormDataByIdListHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: BatchGetFormDataByIdListHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: BatchGetFormDataByIdListHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetFormDataByIdListShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetFormDataByIdListRequest extends $tea.Model {
  appType?: string;
  formInstanceIdList?: string[];
  formUuid?: string;
  needFormInstanceValue?: boolean;
  systemToken?: string;
  static names(): { [key: string]: string } {
    return {
      appType: 'AppType',
      formInstanceIdList: 'FormInstanceIdList',
      formUuid: 'FormUuid',
      needFormInstanceValue: 'NeedFormInstanceValue',
      systemToken: 'SystemToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appType: 'string',
      formInstanceIdList: { 'type': 'array', 'itemType': 'string' },
      formUuid: 'string',
      needFormInstanceValue: 'boolean',
      systemToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetFormDataByIdListShrinkRequest extends $tea.Model {
  appType?: string;
  formInstanceIdListShrink?: string;
  formUuid?: string;
  needFormInstanceValue?: boolean;
  systemToken?: string;
  static names(): { [key: string]: string } {
    return {
      appType: 'AppType',
      formInstanceIdListShrink: 'FormInstanceIdList',
      formUuid: 'FormUuid',
      needFormInstanceValue: 'NeedFormInstanceValue',
      systemToken: 'SystemToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appType: 'string',
      formInstanceIdListShrink: 'string',
      formUuid: 'string',
      needFormInstanceValue: 'boolean',
      systemToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetFormDataByIdListResponseBody extends $tea.Model {
  requestId?: string;
  result?: BatchGetFormDataByIdListResponseBodyResult[];
  vendorRequestId?: string;
  vendorType?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'requestId',
      result: 'result',
      vendorRequestId: 'vendorRequestId',
      vendorType: 'vendorType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: { 'type': 'array', 'itemType': BatchGetFormDataByIdListResponseBodyResult },
      vendorRequestId: 'string',
      vendorType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetFormDataByIdListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: BatchGetFormDataByIdListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchGetFormDataByIdListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchRemovalByFormInstanceIdListHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: BatchRemovalByFormInstanceIdListHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: BatchRemovalByFormInstanceIdListHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchRemovalByFormInstanceIdListShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchRemovalByFormInstanceIdListRequest extends $tea.Model {
  appType?: string;
  asynchronousExecution?: boolean;
  executeExpression?: boolean;
  formInstanceIdList?: string[];
  formUuid?: string;
  systemToken?: string;
  static names(): { [key: string]: string } {
    return {
      appType: 'AppType',
      asynchronousExecution: 'AsynchronousExecution',
      executeExpression: 'ExecuteExpression',
      formInstanceIdList: 'FormInstanceIdList',
      formUuid: 'FormUuid',
      systemToken: 'SystemToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appType: 'string',
      asynchronousExecution: 'boolean',
      executeExpression: 'boolean',
      formInstanceIdList: { 'type': 'array', 'itemType': 'string' },
      formUuid: 'string',
      systemToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchRemovalByFormInstanceIdListShrinkRequest extends $tea.Model {
  appType?: string;
  asynchronousExecution?: boolean;
  executeExpression?: boolean;
  formInstanceIdListShrink?: string;
  formUuid?: string;
  systemToken?: string;
  static names(): { [key: string]: string } {
    return {
      appType: 'AppType',
      asynchronousExecution: 'AsynchronousExecution',
      executeExpression: 'ExecuteExpression',
      formInstanceIdListShrink: 'FormInstanceIdList',
      formUuid: 'FormUuid',
      systemToken: 'SystemToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appType: 'string',
      asynchronousExecution: 'boolean',
      executeExpression: 'boolean',
      formInstanceIdListShrink: 'string',
      formUuid: 'string',
      systemToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchRemovalByFormInstanceIdListResponseBody extends $tea.Model {
  requestId?: string;
  vendorRequestId?: string;
  vendorType?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'requestId',
      vendorRequestId: 'vendorRequestId',
      vendorType: 'vendorType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      vendorRequestId: 'string',
      vendorType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchRemovalByFormInstanceIdListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: BatchRemovalByFormInstanceIdListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchRemovalByFormInstanceIdListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchSaveFormDataHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: BatchSaveFormDataHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: BatchSaveFormDataHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchSaveFormDataShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchSaveFormDataRequest extends $tea.Model {
  appType?: string;
  asynchronousExecution?: boolean;
  formDataJsonList?: string[];
  formUuid?: string;
  keepRunningAfterException?: boolean;
  noExecuteExpression?: boolean;
  systemToken?: string;
  static names(): { [key: string]: string } {
    return {
      appType: 'AppType',
      asynchronousExecution: 'AsynchronousExecution',
      formDataJsonList: 'FormDataJsonList',
      formUuid: 'FormUuid',
      keepRunningAfterException: 'KeepRunningAfterException',
      noExecuteExpression: 'NoExecuteExpression',
      systemToken: 'SystemToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appType: 'string',
      asynchronousExecution: 'boolean',
      formDataJsonList: { 'type': 'array', 'itemType': 'string' },
      formUuid: 'string',
      keepRunningAfterException: 'boolean',
      noExecuteExpression: 'boolean',
      systemToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchSaveFormDataShrinkRequest extends $tea.Model {
  appType?: string;
  asynchronousExecution?: boolean;
  formDataJsonListShrink?: string;
  formUuid?: string;
  keepRunningAfterException?: boolean;
  noExecuteExpression?: boolean;
  systemToken?: string;
  static names(): { [key: string]: string } {
    return {
      appType: 'AppType',
      asynchronousExecution: 'AsynchronousExecution',
      formDataJsonListShrink: 'FormDataJsonList',
      formUuid: 'FormUuid',
      keepRunningAfterException: 'KeepRunningAfterException',
      noExecuteExpression: 'NoExecuteExpression',
      systemToken: 'SystemToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appType: 'string',
      asynchronousExecution: 'boolean',
      formDataJsonListShrink: 'string',
      formUuid: 'string',
      keepRunningAfterException: 'boolean',
      noExecuteExpression: 'boolean',
      systemToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchSaveFormDataResponseBody extends $tea.Model {
  requestId?: string;
  result?: string[];
  vendorRequestId?: string;
  vendorType?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'requestId',
      result: 'result',
      vendorRequestId: 'vendorRequestId',
      vendorType: 'vendorType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: { 'type': 'array', 'itemType': 'string' },
      vendorRequestId: 'string',
      vendorType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchSaveFormDataResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: BatchSaveFormDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchSaveFormDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchUpdateFormDataByInstanceIdHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: BatchUpdateFormDataByInstanceIdHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: BatchUpdateFormDataByInstanceIdHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchUpdateFormDataByInstanceIdShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchUpdateFormDataByInstanceIdRequest extends $tea.Model {
  appType?: string;
  asynchronousExecution?: boolean;
  formInstanceIdList?: string[];
  formUuid?: string;
  ignoreEmpty?: boolean;
  noExecuteExpression?: boolean;
  systemToken?: string;
  updateFormDataJson?: string;
  useLatestFormSchemaVersion?: boolean;
  static names(): { [key: string]: string } {
    return {
      appType: 'AppType',
      asynchronousExecution: 'AsynchronousExecution',
      formInstanceIdList: 'FormInstanceIdList',
      formUuid: 'FormUuid',
      ignoreEmpty: 'IgnoreEmpty',
      noExecuteExpression: 'NoExecuteExpression',
      systemToken: 'SystemToken',
      updateFormDataJson: 'UpdateFormDataJson',
      useLatestFormSchemaVersion: 'UseLatestFormSchemaVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appType: 'string',
      asynchronousExecution: 'boolean',
      formInstanceIdList: { 'type': 'array', 'itemType': 'string' },
      formUuid: 'string',
      ignoreEmpty: 'boolean',
      noExecuteExpression: 'boolean',
      systemToken: 'string',
      updateFormDataJson: 'string',
      useLatestFormSchemaVersion: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchUpdateFormDataByInstanceIdShrinkRequest extends $tea.Model {
  appType?: string;
  asynchronousExecution?: boolean;
  formInstanceIdListShrink?: string;
  formUuid?: string;
  ignoreEmpty?: boolean;
  noExecuteExpression?: boolean;
  systemToken?: string;
  updateFormDataJson?: string;
  useLatestFormSchemaVersion?: boolean;
  static names(): { [key: string]: string } {
    return {
      appType: 'AppType',
      asynchronousExecution: 'AsynchronousExecution',
      formInstanceIdListShrink: 'FormInstanceIdList',
      formUuid: 'FormUuid',
      ignoreEmpty: 'IgnoreEmpty',
      noExecuteExpression: 'NoExecuteExpression',
      systemToken: 'SystemToken',
      updateFormDataJson: 'UpdateFormDataJson',
      useLatestFormSchemaVersion: 'UseLatestFormSchemaVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appType: 'string',
      asynchronousExecution: 'boolean',
      formInstanceIdListShrink: 'string',
      formUuid: 'string',
      ignoreEmpty: 'boolean',
      noExecuteExpression: 'boolean',
      systemToken: 'string',
      updateFormDataJson: 'string',
      useLatestFormSchemaVersion: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchUpdateFormDataByInstanceIdResponseBody extends $tea.Model {
  requestId?: string;
  result?: string[];
  vendorRequestId?: string;
  vendorType?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'requestId',
      result: 'result',
      vendorRequestId: 'vendorRequestId',
      vendorType: 'vendorType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: { 'type': 'array', 'itemType': 'string' },
      vendorRequestId: 'string',
      vendorType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchUpdateFormDataByInstanceIdResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: BatchUpdateFormDataByInstanceIdResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchUpdateFormDataByInstanceIdResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchUpdateFormDataByInstanceMapHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: BatchUpdateFormDataByInstanceMapHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: BatchUpdateFormDataByInstanceMapHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchUpdateFormDataByInstanceMapShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchUpdateFormDataByInstanceMapRequest extends $tea.Model {
  appType?: string;
  asynchronousExecution?: boolean;
  formUuid?: string;
  ignoreEmpty?: boolean;
  noExecuteExpression?: boolean;
  systemToken?: string;
  updateFormDataJsonMap?: { [key: string]: any };
  useLatestFormSchemaVersion?: boolean;
  static names(): { [key: string]: string } {
    return {
      appType: 'AppType',
      asynchronousExecution: 'AsynchronousExecution',
      formUuid: 'FormUuid',
      ignoreEmpty: 'IgnoreEmpty',
      noExecuteExpression: 'NoExecuteExpression',
      systemToken: 'SystemToken',
      updateFormDataJsonMap: 'UpdateFormDataJsonMap',
      useLatestFormSchemaVersion: 'UseLatestFormSchemaVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appType: 'string',
      asynchronousExecution: 'boolean',
      formUuid: 'string',
      ignoreEmpty: 'boolean',
      noExecuteExpression: 'boolean',
      systemToken: 'string',
      updateFormDataJsonMap: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      useLatestFormSchemaVersion: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchUpdateFormDataByInstanceMapShrinkRequest extends $tea.Model {
  appType?: string;
  asynchronousExecution?: boolean;
  formUuid?: string;
  ignoreEmpty?: boolean;
  noExecuteExpression?: boolean;
  systemToken?: string;
  updateFormDataJsonMapShrink?: string;
  useLatestFormSchemaVersion?: boolean;
  static names(): { [key: string]: string } {
    return {
      appType: 'AppType',
      asynchronousExecution: 'AsynchronousExecution',
      formUuid: 'FormUuid',
      ignoreEmpty: 'IgnoreEmpty',
      noExecuteExpression: 'NoExecuteExpression',
      systemToken: 'SystemToken',
      updateFormDataJsonMapShrink: 'UpdateFormDataJsonMap',
      useLatestFormSchemaVersion: 'UseLatestFormSchemaVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appType: 'string',
      asynchronousExecution: 'boolean',
      formUuid: 'string',
      ignoreEmpty: 'boolean',
      noExecuteExpression: 'boolean',
      systemToken: 'string',
      updateFormDataJsonMapShrink: 'string',
      useLatestFormSchemaVersion: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchUpdateFormDataByInstanceMapResponseBody extends $tea.Model {
  requestId?: string;
  result?: string[];
  vendorRequestId?: string;
  vendorType?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'requestId',
      result: 'result',
      vendorRequestId: 'vendorRequestId',
      vendorType: 'vendorType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: { 'type': 'array', 'itemType': 'string' },
      vendorRequestId: 'string',
      vendorType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchUpdateFormDataByInstanceMapResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: BatchUpdateFormDataByInstanceMapResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchUpdateFormDataByInstanceMapResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelScheduleConferenceHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: CancelScheduleConferenceHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: CancelScheduleConferenceHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelScheduleConferenceShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelScheduleConferenceRequest extends $tea.Model {
  scheduleConferenceId?: string;
  tenantContext?: CancelScheduleConferenceRequestTenantContext;
  static names(): { [key: string]: string } {
    return {
      scheduleConferenceId: 'ScheduleConferenceId',
      tenantContext: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      scheduleConferenceId: 'string',
      tenantContext: CancelScheduleConferenceRequestTenantContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelScheduleConferenceShrinkRequest extends $tea.Model {
  scheduleConferenceId?: string;
  tenantContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      scheduleConferenceId: 'ScheduleConferenceId',
      tenantContextShrink: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      scheduleConferenceId: 'string',
      tenantContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelScheduleConferenceResponseBody extends $tea.Model {
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelScheduleConferenceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CancelScheduleConferenceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CancelScheduleConferenceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CheckUserIsGroupMemberHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: CheckUserIsGroupMemberHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: CheckUserIsGroupMemberHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CheckUserIsGroupMemberShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CheckUserIsGroupMemberRequest extends $tea.Model {
  openConversationId?: string;
  static names(): { [key: string]: string } {
    return {
      openConversationId: 'OpenConversationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      openConversationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CheckUserIsGroupMemberResponseBody extends $tea.Model {
  requestId?: string;
  result?: boolean;
  vendorRequestId?: string;
  vendorType?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'requestId',
      result: 'result',
      vendorRequestId: 'vendorRequestId',
      vendorType: 'vendorType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: 'boolean',
      vendorRequestId: 'string',
      vendorType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CheckUserIsGroupMemberResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CheckUserIsGroupMemberResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CheckUserIsGroupMemberResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ClearHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: ClearHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: ClearHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ClearShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ClearRequest extends $tea.Model {
  rangeAddress?: string;
  sheetId?: string;
  tenantContext?: ClearRequestTenantContext;
  workbookId?: string;
  static names(): { [key: string]: string } {
    return {
      rangeAddress: 'RangeAddress',
      sheetId: 'SheetId',
      tenantContext: 'TenantContext',
      workbookId: 'WorkbookId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      rangeAddress: 'string',
      sheetId: 'string',
      tenantContext: ClearRequestTenantContext,
      workbookId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ClearShrinkRequest extends $tea.Model {
  rangeAddress?: string;
  sheetId?: string;
  tenantContextShrink?: string;
  workbookId?: string;
  static names(): { [key: string]: string } {
    return {
      rangeAddress: 'RangeAddress',
      sheetId: 'SheetId',
      tenantContextShrink: 'TenantContext',
      workbookId: 'WorkbookId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      rangeAddress: 'string',
      sheetId: 'string',
      tenantContextShrink: 'string',
      workbookId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ClearResponseBody extends $tea.Model {
  a1Notation?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      a1Notation: 'a1Notation',
      requestId: 'requestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      a1Notation: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ClearResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ClearResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ClearResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ClearDataHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: ClearDataHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: ClearDataHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ClearDataShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ClearDataRequest extends $tea.Model {
  rangeAddress?: string;
  sheetId?: string;
  tenantContext?: ClearDataRequestTenantContext;
  workbookId?: string;
  static names(): { [key: string]: string } {
    return {
      rangeAddress: 'RangeAddress',
      sheetId: 'SheetId',
      tenantContext: 'TenantContext',
      workbookId: 'WorkbookId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      rangeAddress: 'string',
      sheetId: 'string',
      tenantContext: ClearDataRequestTenantContext,
      workbookId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ClearDataShrinkRequest extends $tea.Model {
  rangeAddress?: string;
  sheetId?: string;
  tenantContextShrink?: string;
  workbookId?: string;
  static names(): { [key: string]: string } {
    return {
      rangeAddress: 'RangeAddress',
      sheetId: 'SheetId',
      tenantContextShrink: 'TenantContext',
      workbookId: 'WorkbookId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      rangeAddress: 'string',
      sheetId: 'string',
      tenantContextShrink: 'string',
      workbookId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ClearDataResponseBody extends $tea.Model {
  a1Notation?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      a1Notation: 'a1Notation',
      requestId: 'requestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      a1Notation: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ClearDataResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ClearDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ClearDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CommentListReportHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: CommentListReportHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: CommentListReportHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CommentListReportShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CommentListReportRequest extends $tea.Model {
  offset?: number;
  reportId?: string;
  size?: number;
  tenantContext?: CommentListReportRequestTenantContext;
  static names(): { [key: string]: string } {
    return {
      offset: 'Offset',
      reportId: 'ReportId',
      size: 'Size',
      tenantContext: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      offset: 'number',
      reportId: 'string',
      size: 'number',
      tenantContext: CommentListReportRequestTenantContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CommentListReportShrinkRequest extends $tea.Model {
  offset?: number;
  reportId?: string;
  size?: number;
  tenantContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      offset: 'Offset',
      reportId: 'ReportId',
      size: 'Size',
      tenantContextShrink: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      offset: 'number',
      reportId: 'string',
      size: 'number',
      tenantContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CommentListReportResponseBody extends $tea.Model {
  comments?: CommentListReportResponseBodyComments[];
  hasMore?: boolean;
  nextCursor?: number;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      comments: 'comments',
      hasMore: 'hasMore',
      nextCursor: 'nextCursor',
      requestId: 'requestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comments: { 'type': 'array', 'itemType': CommentListReportResponseBodyComments },
      hasMore: 'boolean',
      nextCursor: 'number',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CommentListReportResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CommentListReportResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CommentListReportResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDeliveryPlanHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: CreateDeliveryPlanHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: CreateDeliveryPlanHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDeliveryPlanShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDeliveryPlanRequest extends $tea.Model {
  content?: { [key: string]: any };
  endTime?: number;
  resId?: string;
  startTime?: number;
  tenantContext?: CreateDeliveryPlanRequestTenantContext;
  userIdList?: string[];
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      endTime: 'EndTime',
      resId: 'ResId',
      startTime: 'StartTime',
      tenantContext: 'TenantContext',
      userIdList: 'UserIdList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      endTime: 'number',
      resId: 'string',
      startTime: 'number',
      tenantContext: CreateDeliveryPlanRequestTenantContext,
      userIdList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDeliveryPlanShrinkRequest extends $tea.Model {
  contentShrink?: string;
  endTime?: number;
  resId?: string;
  startTime?: number;
  tenantContextShrink?: string;
  userIdListShrink?: string;
  static names(): { [key: string]: string } {
    return {
      contentShrink: 'Content',
      endTime: 'EndTime',
      resId: 'ResId',
      startTime: 'StartTime',
      tenantContextShrink: 'TenantContext',
      userIdListShrink: 'UserIdList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contentShrink: 'string',
      endTime: 'number',
      resId: 'string',
      startTime: 'number',
      tenantContextShrink: 'string',
      userIdListShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDeliveryPlanResponseBody extends $tea.Model {
  arguments?: any[];
  requestId?: string;
  success?: boolean;
  vendorRequestId?: string;
  vendorType?: string;
  static names(): { [key: string]: string } {
    return {
      arguments: 'arguments',
      requestId: 'requestId',
      success: 'success',
      vendorRequestId: 'vendorRequestId',
      vendorType: 'vendorType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      arguments: { 'type': 'array', 'itemType': 'any' },
      requestId: 'string',
      success: 'boolean',
      vendorRequestId: 'string',
      vendorType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDeliveryPlanResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateDeliveryPlanResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateDeliveryPlanResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEventHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: CreateEventHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: CreateEventHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEventShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEventRequest extends $tea.Model {
  attendees?: CreateEventRequestAttendees[];
  description?: string;
  end?: CreateEventRequestEnd;
  extra?: { [key: string]: string };
  isAllDay?: boolean;
  location?: CreateEventRequestLocation;
  onlineMeetingInfo?: CreateEventRequestOnlineMeetingInfo;
  recurrence?: CreateEventRequestRecurrence;
  reminders?: CreateEventRequestReminders[];
  richTextDescription?: CreateEventRequestRichTextDescription;
  summary?: string;
  uiConfigs?: CreateEventRequestUiConfigs[];
  calendarId?: string;
  start?: CreateEventRequestStart;
  static names(): { [key: string]: string } {
    return {
      attendees: 'Attendees',
      description: 'Description',
      end: 'End',
      extra: 'Extra',
      isAllDay: 'IsAllDay',
      location: 'Location',
      onlineMeetingInfo: 'OnlineMeetingInfo',
      recurrence: 'Recurrence',
      reminders: 'Reminders',
      richTextDescription: 'RichTextDescription',
      summary: 'Summary',
      uiConfigs: 'UiConfigs',
      calendarId: 'calendarId',
      start: 'start',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attendees: { 'type': 'array', 'itemType': CreateEventRequestAttendees },
      description: 'string',
      end: CreateEventRequestEnd,
      extra: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      isAllDay: 'boolean',
      location: CreateEventRequestLocation,
      onlineMeetingInfo: CreateEventRequestOnlineMeetingInfo,
      recurrence: CreateEventRequestRecurrence,
      reminders: { 'type': 'array', 'itemType': CreateEventRequestReminders },
      richTextDescription: CreateEventRequestRichTextDescription,
      summary: 'string',
      uiConfigs: { 'type': 'array', 'itemType': CreateEventRequestUiConfigs },
      calendarId: 'string',
      start: CreateEventRequestStart,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEventShrinkRequest extends $tea.Model {
  attendeesShrink?: string;
  description?: string;
  endShrink?: string;
  extraShrink?: string;
  isAllDay?: boolean;
  locationShrink?: string;
  onlineMeetingInfoShrink?: string;
  recurrenceShrink?: string;
  remindersShrink?: string;
  richTextDescriptionShrink?: string;
  summary?: string;
  uiConfigsShrink?: string;
  calendarId?: string;
  startShrink?: string;
  static names(): { [key: string]: string } {
    return {
      attendeesShrink: 'Attendees',
      description: 'Description',
      endShrink: 'End',
      extraShrink: 'Extra',
      isAllDay: 'IsAllDay',
      locationShrink: 'Location',
      onlineMeetingInfoShrink: 'OnlineMeetingInfo',
      recurrenceShrink: 'Recurrence',
      remindersShrink: 'Reminders',
      richTextDescriptionShrink: 'RichTextDescription',
      summary: 'Summary',
      uiConfigsShrink: 'UiConfigs',
      calendarId: 'calendarId',
      startShrink: 'start',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attendeesShrink: 'string',
      description: 'string',
      endShrink: 'string',
      extraShrink: 'string',
      isAllDay: 'boolean',
      locationShrink: 'string',
      onlineMeetingInfoShrink: 'string',
      recurrenceShrink: 'string',
      remindersShrink: 'string',
      richTextDescriptionShrink: 'string',
      summary: 'string',
      uiConfigsShrink: 'string',
      calendarId: 'string',
      startShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEventResponseBody extends $tea.Model {
  attendees?: CreateEventResponseBodyAttendees[];
  createTime?: string;
  description?: string;
  end?: CreateEventResponseBodyEnd;
  id?: string;
  isAllDay?: boolean;
  location?: CreateEventResponseBodyLocation;
  onlineMeetingInfo?: CreateEventResponseBodyOnlineMeetingInfo;
  organizer?: CreateEventResponseBodyOrganizer;
  recurrence?: CreateEventResponseBodyRecurrence;
  reminders?: CreateEventResponseBodyReminders[];
  requestId?: string;
  richTextDescription?: CreateEventResponseBodyRichTextDescription;
  start?: CreateEventResponseBodyStart;
  summary?: string;
  uiConfigs?: CreateEventResponseBodyUiConfigs[];
  updateTime?: string;
  static names(): { [key: string]: string } {
    return {
      attendees: 'attendees',
      createTime: 'createTime',
      description: 'description',
      end: 'end',
      id: 'id',
      isAllDay: 'isAllDay',
      location: 'location',
      onlineMeetingInfo: 'onlineMeetingInfo',
      organizer: 'organizer',
      recurrence: 'recurrence',
      reminders: 'reminders',
      requestId: 'requestId',
      richTextDescription: 'richTextDescription',
      start: 'start',
      summary: 'summary',
      uiConfigs: 'uiConfigs',
      updateTime: 'updateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attendees: { 'type': 'array', 'itemType': CreateEventResponseBodyAttendees },
      createTime: 'string',
      description: 'string',
      end: CreateEventResponseBodyEnd,
      id: 'string',
      isAllDay: 'boolean',
      location: CreateEventResponseBodyLocation,
      onlineMeetingInfo: CreateEventResponseBodyOnlineMeetingInfo,
      organizer: CreateEventResponseBodyOrganizer,
      recurrence: CreateEventResponseBodyRecurrence,
      reminders: { 'type': 'array', 'itemType': CreateEventResponseBodyReminders },
      requestId: 'string',
      richTextDescription: CreateEventResponseBodyRichTextDescription,
      start: CreateEventResponseBodyStart,
      summary: 'string',
      uiConfigs: { 'type': 'array', 'itemType': CreateEventResponseBodyUiConfigs },
      updateTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEventResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateEventResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateEventResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLiveHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: CreateLiveHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: CreateLiveHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLiveShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLiveRequest extends $tea.Model {
  coverUrl?: string;
  introduction?: string;
  preEndTime?: number;
  preStartTime?: number;
  publicType?: number;
  tenantContext?: CreateLiveRequestTenantContext;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      coverUrl: 'CoverUrl',
      introduction: 'Introduction',
      preEndTime: 'PreEndTime',
      preStartTime: 'PreStartTime',
      publicType: 'PublicType',
      tenantContext: 'TenantContext',
      title: 'Title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      coverUrl: 'string',
      introduction: 'string',
      preEndTime: 'number',
      preStartTime: 'number',
      publicType: 'number',
      tenantContext: CreateLiveRequestTenantContext,
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLiveShrinkRequest extends $tea.Model {
  coverUrl?: string;
  introduction?: string;
  preEndTime?: number;
  preStartTime?: number;
  publicType?: number;
  tenantContextShrink?: string;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      coverUrl: 'CoverUrl',
      introduction: 'Introduction',
      preEndTime: 'PreEndTime',
      preStartTime: 'PreStartTime',
      publicType: 'PublicType',
      tenantContextShrink: 'TenantContext',
      title: 'Title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      coverUrl: 'string',
      introduction: 'string',
      preEndTime: 'number',
      preStartTime: 'number',
      publicType: 'number',
      tenantContextShrink: 'string',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLiveResponseBody extends $tea.Model {
  liveId?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      liveId: 'liveId',
      requestId: 'requestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      liveId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLiveResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateLiveResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateLiveResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMeetingRoomHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: CreateMeetingRoomHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: CreateMeetingRoomHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMeetingRoomShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMeetingRoomRequest extends $tea.Model {
  enableCycleReservation?: boolean;
  groupId?: number;
  isvRoomId?: string;
  reservationAuthority?: CreateMeetingRoomRequestReservationAuthority;
  roomCapacity?: number;
  roomLabelIds?: number[];
  roomLocation?: CreateMeetingRoomRequestRoomLocation;
  roomName?: string;
  roomPicture?: string;
  roomStatus?: number;
  tenantContext?: CreateMeetingRoomRequestTenantContext;
  static names(): { [key: string]: string } {
    return {
      enableCycleReservation: 'EnableCycleReservation',
      groupId: 'GroupId',
      isvRoomId: 'IsvRoomId',
      reservationAuthority: 'ReservationAuthority',
      roomCapacity: 'RoomCapacity',
      roomLabelIds: 'RoomLabelIds',
      roomLocation: 'RoomLocation',
      roomName: 'RoomName',
      roomPicture: 'RoomPicture',
      roomStatus: 'RoomStatus',
      tenantContext: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enableCycleReservation: 'boolean',
      groupId: 'number',
      isvRoomId: 'string',
      reservationAuthority: CreateMeetingRoomRequestReservationAuthority,
      roomCapacity: 'number',
      roomLabelIds: { 'type': 'array', 'itemType': 'number' },
      roomLocation: CreateMeetingRoomRequestRoomLocation,
      roomName: 'string',
      roomPicture: 'string',
      roomStatus: 'number',
      tenantContext: CreateMeetingRoomRequestTenantContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMeetingRoomShrinkRequest extends $tea.Model {
  enableCycleReservation?: boolean;
  groupId?: number;
  isvRoomId?: string;
  reservationAuthorityShrink?: string;
  roomCapacity?: number;
  roomLabelIdsShrink?: string;
  roomLocationShrink?: string;
  roomName?: string;
  roomPicture?: string;
  roomStatus?: number;
  tenantContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      enableCycleReservation: 'EnableCycleReservation',
      groupId: 'GroupId',
      isvRoomId: 'IsvRoomId',
      reservationAuthorityShrink: 'ReservationAuthority',
      roomCapacity: 'RoomCapacity',
      roomLabelIdsShrink: 'RoomLabelIds',
      roomLocationShrink: 'RoomLocation',
      roomName: 'RoomName',
      roomPicture: 'RoomPicture',
      roomStatus: 'RoomStatus',
      tenantContextShrink: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enableCycleReservation: 'boolean',
      groupId: 'number',
      isvRoomId: 'string',
      reservationAuthorityShrink: 'string',
      roomCapacity: 'number',
      roomLabelIdsShrink: 'string',
      roomLocationShrink: 'string',
      roomName: 'string',
      roomPicture: 'string',
      roomStatus: 'number',
      tenantContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMeetingRoomResponseBody extends $tea.Model {
  requestId?: string;
  result?: string;
  vendorRequestId?: string;
  vendorType?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'requestId',
      result: 'result',
      vendorRequestId: 'vendorRequestId',
      vendorType: 'vendorType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: 'string',
      vendorRequestId: 'string',
      vendorType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMeetingRoomResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateMeetingRoomResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateMeetingRoomResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMeetingRoomGroupHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: CreateMeetingRoomGroupHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: CreateMeetingRoomGroupHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMeetingRoomGroupShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMeetingRoomGroupRequest extends $tea.Model {
  groupName?: string;
  parentGroupId?: number;
  tenantContext?: CreateMeetingRoomGroupRequestTenantContext;
  static names(): { [key: string]: string } {
    return {
      groupName: 'GroupName',
      parentGroupId: 'ParentGroupId',
      tenantContext: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupName: 'string',
      parentGroupId: 'number',
      tenantContext: CreateMeetingRoomGroupRequestTenantContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMeetingRoomGroupShrinkRequest extends $tea.Model {
  groupName?: string;
  parentGroupId?: number;
  tenantContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      groupName: 'GroupName',
      parentGroupId: 'ParentGroupId',
      tenantContextShrink: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupName: 'string',
      parentGroupId: 'number',
      tenantContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMeetingRoomGroupResponseBody extends $tea.Model {
  requestId?: string;
  result?: number;
  static names(): { [key: string]: string } {
    return {
      requestId: 'requestId',
      result: 'result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMeetingRoomGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateMeetingRoomGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateMeetingRoomGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateFormDataHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: CreateOrUpdateFormDataHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: CreateOrUpdateFormDataHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateFormDataShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateFormDataRequest extends $tea.Model {
  appType?: string;
  formDataJson?: string;
  formUuid?: string;
  noExecuteExpression?: boolean;
  searchCondition?: string;
  systemToken?: string;
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      appType: 'AppType',
      formDataJson: 'FormDataJson',
      formUuid: 'FormUuid',
      noExecuteExpression: 'NoExecuteExpression',
      searchCondition: 'SearchCondition',
      systemToken: 'SystemToken',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appType: 'string',
      formDataJson: 'string',
      formUuid: 'string',
      noExecuteExpression: 'boolean',
      searchCondition: 'string',
      systemToken: 'string',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateFormDataResponseBody extends $tea.Model {
  requestId?: string;
  result?: string[];
  vendorRequestId?: string;
  vendorType?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'requestId',
      result: 'result',
      vendorRequestId: 'vendorRequestId',
      vendorType: 'vendorType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: { 'type': 'array', 'itemType': 'string' },
      vendorRequestId: 'string',
      vendorType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateFormDataResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateOrUpdateFormDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateOrUpdateFormDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrgHonorTemplateHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: CreateOrgHonorTemplateHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: CreateOrgHonorTemplateHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrgHonorTemplateShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrgHonorTemplateRequest extends $tea.Model {
  tenantContext?: CreateOrgHonorTemplateRequestTenantContext;
  avatarFrameMediaId?: string;
  defaultBgColor?: string;
  medalDesc?: string;
  medalMediaId?: string;
  medalName?: string;
  orgId?: number;
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantContext: 'TenantContext',
      avatarFrameMediaId: 'avatarFrameMediaId',
      defaultBgColor: 'defaultBgColor',
      medalDesc: 'medalDesc',
      medalMediaId: 'medalMediaId',
      medalName: 'medalName',
      orgId: 'orgId',
      userId: 'userId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantContext: CreateOrgHonorTemplateRequestTenantContext,
      avatarFrameMediaId: 'string',
      defaultBgColor: 'string',
      medalDesc: 'string',
      medalMediaId: 'string',
      medalName: 'string',
      orgId: 'number',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrgHonorTemplateShrinkRequest extends $tea.Model {
  tenantContextShrink?: string;
  avatarFrameMediaId?: string;
  defaultBgColor?: string;
  medalDesc?: string;
  medalMediaId?: string;
  medalName?: string;
  orgId?: number;
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantContextShrink: 'TenantContext',
      avatarFrameMediaId: 'avatarFrameMediaId',
      defaultBgColor: 'defaultBgColor',
      medalDesc: 'medalDesc',
      medalMediaId: 'medalMediaId',
      medalName: 'medalName',
      orgId: 'orgId',
      userId: 'userId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantContextShrink: 'string',
      avatarFrameMediaId: 'string',
      defaultBgColor: 'string',
      medalDesc: 'string',
      medalMediaId: 'string',
      medalName: 'string',
      orgId: 'number',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrgHonorTemplateResponseBody extends $tea.Model {
  honorId?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      honorId: 'honorId',
      requestId: 'requestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      honorId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrgHonorTemplateResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateOrgHonorTemplateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateOrgHonorTemplateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePersonalTodoTaskHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: CreatePersonalTodoTaskHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: CreatePersonalTodoTaskHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePersonalTodoTaskShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePersonalTodoTaskRequest extends $tea.Model {
  description?: string;
  dueTime?: number;
  executorIds?: string[];
  notifyConfigs?: CreatePersonalTodoTaskRequestNotifyConfigs;
  participantIds?: string[];
  subject?: string;
  tenantContext?: CreatePersonalTodoTaskRequestTenantContext;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      dueTime: 'DueTime',
      executorIds: 'ExecutorIds',
      notifyConfigs: 'NotifyConfigs',
      participantIds: 'ParticipantIds',
      subject: 'Subject',
      tenantContext: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      dueTime: 'number',
      executorIds: { 'type': 'array', 'itemType': 'string' },
      notifyConfigs: CreatePersonalTodoTaskRequestNotifyConfigs,
      participantIds: { 'type': 'array', 'itemType': 'string' },
      subject: 'string',
      tenantContext: CreatePersonalTodoTaskRequestTenantContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePersonalTodoTaskShrinkRequest extends $tea.Model {
  description?: string;
  dueTime?: number;
  executorIdsShrink?: string;
  notifyConfigsShrink?: string;
  participantIdsShrink?: string;
  subject?: string;
  tenantContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      dueTime: 'DueTime',
      executorIdsShrink: 'ExecutorIds',
      notifyConfigsShrink: 'NotifyConfigs',
      participantIdsShrink: 'ParticipantIds',
      subject: 'Subject',
      tenantContextShrink: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      dueTime: 'number',
      executorIdsShrink: 'string',
      notifyConfigsShrink: 'string',
      participantIdsShrink: 'string',
      subject: 'string',
      tenantContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePersonalTodoTaskResponseBody extends $tea.Model {
  createdTime?: number;
  requestId?: string;
  taskId?: string;
  vendorRequestId?: string;
  vendorType?: string;
  static names(): { [key: string]: string } {
    return {
      createdTime: 'createdTime',
      requestId: 'requestId',
      taskId: 'taskId',
      vendorRequestId: 'vendorRequestId',
      vendorType: 'vendorType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createdTime: 'number',
      requestId: 'string',
      taskId: 'string',
      vendorRequestId: 'string',
      vendorType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePersonalTodoTaskResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreatePersonalTodoTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreatePersonalTodoTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateReportHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: CreateReportHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: CreateReportHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateReportShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateReportRequest extends $tea.Model {
  contents?: CreateReportRequestContents[];
  ddFrom?: string;
  templateId?: string;
  tenantContext?: CreateReportRequestTenantContext;
  toChat?: boolean;
  toCids?: string[];
  toUserids?: string[];
  static names(): { [key: string]: string } {
    return {
      contents: 'Contents',
      ddFrom: 'DdFrom',
      templateId: 'TemplateId',
      tenantContext: 'TenantContext',
      toChat: 'ToChat',
      toCids: 'ToCids',
      toUserids: 'ToUserids',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contents: { 'type': 'array', 'itemType': CreateReportRequestContents },
      ddFrom: 'string',
      templateId: 'string',
      tenantContext: CreateReportRequestTenantContext,
      toChat: 'boolean',
      toCids: { 'type': 'array', 'itemType': 'string' },
      toUserids: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateReportShrinkRequest extends $tea.Model {
  contentsShrink?: string;
  ddFrom?: string;
  templateId?: string;
  tenantContextShrink?: string;
  toChat?: boolean;
  toCidsShrink?: string;
  toUseridsShrink?: string;
  static names(): { [key: string]: string } {
    return {
      contentsShrink: 'Contents',
      ddFrom: 'DdFrom',
      templateId: 'TemplateId',
      tenantContextShrink: 'TenantContext',
      toChat: 'ToChat',
      toCidsShrink: 'ToCids',
      toUseridsShrink: 'ToUserids',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contentsShrink: 'string',
      ddFrom: 'string',
      templateId: 'string',
      tenantContextShrink: 'string',
      toChat: 'boolean',
      toCidsShrink: 'string',
      toUseridsShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateReportResponseBody extends $tea.Model {
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateReportResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateReportResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateReportResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateScenegroupHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: CreateScenegroupHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: CreateScenegroupHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateScenegroupShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateScenegroupRequest extends $tea.Model {
  addFriendForbidden?: number;
  allMembersCanCreateCalendar?: number;
  allMembersCanCreateMcsConf?: number;
  chatBannedType?: number;
  groupEmailDisabled?: number;
  groupLiveSwitch?: number;
  icon?: string;
  managementType?: number;
  membersToAdminChat?: number;
  mentionAllAuthority?: number;
  onlyAdminCanDing?: number;
  onlyAdminCanSetMsgTop?: number;
  searchable?: number;
  showHistoryType?: number;
  subadminIds?: string;
  templateId?: string;
  title?: string;
  userIds?: string;
  uuid?: string;
  validationType?: number;
  static names(): { [key: string]: string } {
    return {
      addFriendForbidden: 'AddFriendForbidden',
      allMembersCanCreateCalendar: 'AllMembersCanCreateCalendar',
      allMembersCanCreateMcsConf: 'AllMembersCanCreateMcsConf',
      chatBannedType: 'ChatBannedType',
      groupEmailDisabled: 'GroupEmailDisabled',
      groupLiveSwitch: 'GroupLiveSwitch',
      icon: 'Icon',
      managementType: 'ManagementType',
      membersToAdminChat: 'MembersToAdminChat',
      mentionAllAuthority: 'MentionAllAuthority',
      onlyAdminCanDing: 'OnlyAdminCanDing',
      onlyAdminCanSetMsgTop: 'OnlyAdminCanSetMsgTop',
      searchable: 'Searchable',
      showHistoryType: 'ShowHistoryType',
      subadminIds: 'SubadminIds',
      templateId: 'TemplateId',
      title: 'Title',
      userIds: 'UserIds',
      uuid: 'Uuid',
      validationType: 'ValidationType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addFriendForbidden: 'number',
      allMembersCanCreateCalendar: 'number',
      allMembersCanCreateMcsConf: 'number',
      chatBannedType: 'number',
      groupEmailDisabled: 'number',
      groupLiveSwitch: 'number',
      icon: 'string',
      managementType: 'number',
      membersToAdminChat: 'number',
      mentionAllAuthority: 'number',
      onlyAdminCanDing: 'number',
      onlyAdminCanSetMsgTop: 'number',
      searchable: 'number',
      showHistoryType: 'number',
      subadminIds: 'string',
      templateId: 'string',
      title: 'string',
      userIds: 'string',
      uuid: 'string',
      validationType: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateScenegroupResponseBody extends $tea.Model {
  openConversationId?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      openConversationId: 'openConversationId',
      requestId: 'requestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      openConversationId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateScenegroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateScenegroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateScenegroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateScheduleConferenceHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: CreateScheduleConferenceHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: CreateScheduleConferenceHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateScheduleConferenceShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateScheduleConferenceRequest extends $tea.Model {
  endTime?: number;
  startTime?: number;
  tenantContext?: CreateScheduleConferenceRequestTenantContext;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      startTime: 'StartTime',
      tenantContext: 'TenantContext',
      title: 'Title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'number',
      startTime: 'number',
      tenantContext: CreateScheduleConferenceRequestTenantContext,
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateScheduleConferenceShrinkRequest extends $tea.Model {
  endTime?: number;
  startTime?: number;
  tenantContextShrink?: string;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      startTime: 'StartTime',
      tenantContextShrink: 'TenantContext',
      title: 'Title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'number',
      startTime: 'number',
      tenantContextShrink: 'string',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateScheduleConferenceResponseBody extends $tea.Model {
  phones?: string[];
  requestId?: string;
  roomCode?: string;
  scheduleConferenceId?: string;
  url?: string;
  static names(): { [key: string]: string } {
    return {
      phones: 'phones',
      requestId: 'requestId',
      roomCode: 'roomCode',
      scheduleConferenceId: 'scheduleConferenceId',
      url: 'url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      phones: { 'type': 'array', 'itemType': 'string' },
      requestId: 'string',
      roomCode: 'string',
      scheduleConferenceId: 'string',
      url: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateScheduleConferenceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateScheduleConferenceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateScheduleConferenceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSearchDomeHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: CreateSearchDomeHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: CreateSearchDomeHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSearchDomeShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSearchDomeRequest extends $tea.Model {
  content?: string;
  endTime?: number;
  resId?: string;
  startTime?: number;
  tenantContext?: CreateSearchDomeRequestTenantContext;
  userIdList?: string[];
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      endTime: 'EndTime',
      resId: 'ResId',
      startTime: 'StartTime',
      tenantContext: 'TenantContext',
      userIdList: 'UserIdList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      endTime: 'number',
      resId: 'string',
      startTime: 'number',
      tenantContext: CreateSearchDomeRequestTenantContext,
      userIdList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSearchDomeShrinkRequest extends $tea.Model {
  content?: string;
  endTime?: number;
  resId?: string;
  startTime?: number;
  tenantContextShrink?: string;
  userIdListShrink?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      endTime: 'EndTime',
      resId: 'ResId',
      startTime: 'StartTime',
      tenantContextShrink: 'TenantContext',
      userIdListShrink: 'UserIdList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      endTime: 'number',
      resId: 'string',
      startTime: 'number',
      tenantContextShrink: 'string',
      userIdListShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSearchDomeResponseBody extends $tea.Model {
  arguments?: any[];
  requestId?: string;
  success?: boolean;
  vendorRequestId?: string;
  vendorType?: string;
  static names(): { [key: string]: string } {
    return {
      arguments: 'arguments',
      requestId: 'requestId',
      success: 'success',
      vendorRequestId: 'vendorRequestId',
      vendorType: 'vendorType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      arguments: { 'type': 'array', 'itemType': 'any' },
      requestId: 'string',
      success: 'boolean',
      vendorRequestId: 'string',
      vendorType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSearchDomeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateSearchDomeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateSearchDomeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSearchKeywordHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: CreateSearchKeywordHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: CreateSearchKeywordHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSearchKeywordShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSearchKeywordRequest extends $tea.Model {
  content?: string;
  endTime?: number;
  resId?: string;
  startTime?: number;
  tenantContext?: CreateSearchKeywordRequestTenantContext;
  userIdList?: string[];
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      endTime: 'EndTime',
      resId: 'ResId',
      startTime: 'StartTime',
      tenantContext: 'TenantContext',
      userIdList: 'UserIdList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      endTime: 'number',
      resId: 'string',
      startTime: 'number',
      tenantContext: CreateSearchKeywordRequestTenantContext,
      userIdList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSearchKeywordShrinkRequest extends $tea.Model {
  content?: string;
  endTime?: number;
  resId?: string;
  startTime?: number;
  tenantContextShrink?: string;
  userIdListShrink?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      endTime: 'EndTime',
      resId: 'ResId',
      startTime: 'StartTime',
      tenantContextShrink: 'TenantContext',
      userIdListShrink: 'UserIdList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      endTime: 'number',
      resId: 'string',
      startTime: 'number',
      tenantContextShrink: 'string',
      userIdListShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSearchKeywordResponseBody extends $tea.Model {
  arguments?: any[];
  requestId?: string;
  success?: boolean;
  vendorRequestId?: string;
  vendorType?: string;
  static names(): { [key: string]: string } {
    return {
      arguments: 'arguments',
      requestId: 'requestId',
      success: 'success',
      vendorRequestId: 'vendorRequestId',
      vendorType: 'vendorType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      arguments: { 'type': 'array', 'itemType': 'any' },
      requestId: 'string',
      success: 'boolean',
      vendorRequestId: 'string',
      vendorType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSearchKeywordResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateSearchKeywordResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateSearchKeywordResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSheetHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: CreateSheetHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: CreateSheetHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSheetShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSheetRequest extends $tea.Model {
  name?: string;
  tenantContext?: CreateSheetRequestTenantContext;
  workbookId?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      tenantContext: 'TenantContext',
      workbookId: 'WorkbookId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      tenantContext: CreateSheetRequestTenantContext,
      workbookId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSheetShrinkRequest extends $tea.Model {
  name?: string;
  tenantContextShrink?: string;
  workbookId?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      tenantContextShrink: 'TenantContext',
      workbookId: 'WorkbookId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      tenantContextShrink: 'string',
      workbookId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSheetResponseBody extends $tea.Model {
  id?: string;
  name?: string;
  requestId?: string;
  visibility?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'id',
      name: 'name',
      requestId: 'requestId',
      visibility: 'visibility',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      name: 'string',
      requestId: 'string',
      visibility: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSheetResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateSheetResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateSheetResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSubscribedCalendarHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: CreateSubscribedCalendarHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: CreateSubscribedCalendarHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSubscribedCalendarShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSubscribedCalendarRequest extends $tea.Model {
  description?: string;
  managers?: string[];
  name?: string;
  subscribeScope?: CreateSubscribedCalendarRequestSubscribeScope;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      managers: 'Managers',
      name: 'Name',
      subscribeScope: 'SubscribeScope',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      managers: { 'type': 'array', 'itemType': 'string' },
      name: 'string',
      subscribeScope: CreateSubscribedCalendarRequestSubscribeScope,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSubscribedCalendarShrinkRequest extends $tea.Model {
  description?: string;
  managersShrink?: string;
  name?: string;
  subscribeScopeShrink?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      managersShrink: 'Managers',
      name: 'Name',
      subscribeScopeShrink: 'SubscribeScope',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      managersShrink: 'string',
      name: 'string',
      subscribeScopeShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSubscribedCalendarResponseBody extends $tea.Model {
  calendarId?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      calendarId: 'calendarId',
      requestId: 'requestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      calendarId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSubscribedCalendarResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateSubscribedCalendarResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateSubscribedCalendarResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTodoTaskHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: CreateTodoTaskHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: CreateTodoTaskHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTodoTaskShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTodoTaskRequest extends $tea.Model {
  tenantContext?: CreateTodoTaskRequestTenantContext;
  contentFieldList?: CreateTodoTaskRequestContentFieldList[];
  creatorId?: string;
  description?: string;
  detailUrl?: CreateTodoTaskRequestDetailUrl;
  dueTime?: number;
  executorIds?: string[];
  isOnlyShowExecutor?: boolean;
  notifyConfigs?: CreateTodoTaskRequestNotifyConfigs;
  operatorId?: string;
  participantIds?: string[];
  priority?: number;
  sourceId?: string;
  subject?: string;
  static names(): { [key: string]: string } {
    return {
      tenantContext: 'TenantContext',
      contentFieldList: 'contentFieldList',
      creatorId: 'creatorId',
      description: 'description',
      detailUrl: 'detailUrl',
      dueTime: 'dueTime',
      executorIds: 'executorIds',
      isOnlyShowExecutor: 'isOnlyShowExecutor',
      notifyConfigs: 'notifyConfigs',
      operatorId: 'operatorId',
      participantIds: 'participantIds',
      priority: 'priority',
      sourceId: 'sourceId',
      subject: 'subject',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantContext: CreateTodoTaskRequestTenantContext,
      contentFieldList: { 'type': 'array', 'itemType': CreateTodoTaskRequestContentFieldList },
      creatorId: 'string',
      description: 'string',
      detailUrl: CreateTodoTaskRequestDetailUrl,
      dueTime: 'number',
      executorIds: { 'type': 'array', 'itemType': 'string' },
      isOnlyShowExecutor: 'boolean',
      notifyConfigs: CreateTodoTaskRequestNotifyConfigs,
      operatorId: 'string',
      participantIds: { 'type': 'array', 'itemType': 'string' },
      priority: 'number',
      sourceId: 'string',
      subject: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTodoTaskShrinkRequest extends $tea.Model {
  tenantContextShrink?: string;
  contentFieldListShrink?: string;
  creatorId?: string;
  description?: string;
  detailUrlShrink?: string;
  dueTime?: number;
  executorIdsShrink?: string;
  isOnlyShowExecutor?: boolean;
  notifyConfigsShrink?: string;
  operatorId?: string;
  participantIdsShrink?: string;
  priority?: number;
  sourceId?: string;
  subject?: string;
  static names(): { [key: string]: string } {
    return {
      tenantContextShrink: 'TenantContext',
      contentFieldListShrink: 'contentFieldList',
      creatorId: 'creatorId',
      description: 'description',
      detailUrlShrink: 'detailUrl',
      dueTime: 'dueTime',
      executorIdsShrink: 'executorIds',
      isOnlyShowExecutor: 'isOnlyShowExecutor',
      notifyConfigsShrink: 'notifyConfigs',
      operatorId: 'operatorId',
      participantIdsShrink: 'participantIds',
      priority: 'priority',
      sourceId: 'sourceId',
      subject: 'subject',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantContextShrink: 'string',
      contentFieldListShrink: 'string',
      creatorId: 'string',
      description: 'string',
      detailUrlShrink: 'string',
      dueTime: 'number',
      executorIdsShrink: 'string',
      isOnlyShowExecutor: 'boolean',
      notifyConfigsShrink: 'string',
      operatorId: 'string',
      participantIdsShrink: 'string',
      priority: 'number',
      sourceId: 'string',
      subject: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTodoTaskResponseBody extends $tea.Model {
  bizTag?: string;
  contentFieldList?: CreateTodoTaskResponseBodyContentFieldList[];
  createdTime?: number;
  creatorId?: string;
  description?: string;
  detailUrl?: CreateTodoTaskResponseBodyDetailUrl;
  done?: boolean;
  dueTime?: number;
  executorIds?: string[];
  finishTime?: number;
  id?: string;
  isOnlyShowExecutor?: boolean;
  modifiedTime?: number;
  modifierId?: string;
  notifyConfigs?: CreateTodoTaskResponseBodyNotifyConfigs;
  participantIds?: string[];
  priority?: number;
  requestId?: string;
  source?: string;
  sourceId?: string;
  startTime?: number;
  subject?: string;
  static names(): { [key: string]: string } {
    return {
      bizTag: 'bizTag',
      contentFieldList: 'contentFieldList',
      createdTime: 'createdTime',
      creatorId: 'creatorId',
      description: 'description',
      detailUrl: 'detailUrl',
      done: 'done',
      dueTime: 'dueTime',
      executorIds: 'executorIds',
      finishTime: 'finishTime',
      id: 'id',
      isOnlyShowExecutor: 'isOnlyShowExecutor',
      modifiedTime: 'modifiedTime',
      modifierId: 'modifierId',
      notifyConfigs: 'notifyConfigs',
      participantIds: 'participantIds',
      priority: 'priority',
      requestId: 'requestId',
      source: 'source',
      sourceId: 'sourceId',
      startTime: 'startTime',
      subject: 'subject',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizTag: 'string',
      contentFieldList: { 'type': 'array', 'itemType': CreateTodoTaskResponseBodyContentFieldList },
      createdTime: 'number',
      creatorId: 'string',
      description: 'string',
      detailUrl: CreateTodoTaskResponseBodyDetailUrl,
      done: 'boolean',
      dueTime: 'number',
      executorIds: { 'type': 'array', 'itemType': 'string' },
      finishTime: 'number',
      id: 'string',
      isOnlyShowExecutor: 'boolean',
      modifiedTime: 'number',
      modifierId: 'string',
      notifyConfigs: CreateTodoTaskResponseBodyNotifyConfigs,
      participantIds: { 'type': 'array', 'itemType': 'string' },
      priority: 'number',
      requestId: 'string',
      source: 'string',
      sourceId: 'string',
      startTime: 'number',
      subject: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTodoTaskResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateTodoTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateTodoTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateVideoConferenceHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: CreateVideoConferenceHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: CreateVideoConferenceHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateVideoConferenceShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateVideoConferenceRequest extends $tea.Model {
  confTitle?: string;
  inviteCaller?: boolean;
  inviteUserIds?: string[];
  static names(): { [key: string]: string } {
    return {
      confTitle: 'ConfTitle',
      inviteCaller: 'InviteCaller',
      inviteUserIds: 'InviteUserIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      confTitle: 'string',
      inviteCaller: 'boolean',
      inviteUserIds: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateVideoConferenceShrinkRequest extends $tea.Model {
  confTitle?: string;
  inviteCaller?: boolean;
  inviteUserIdsShrink?: string;
  static names(): { [key: string]: string } {
    return {
      confTitle: 'ConfTitle',
      inviteCaller: 'InviteCaller',
      inviteUserIdsShrink: 'InviteUserIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      confTitle: 'string',
      inviteCaller: 'boolean',
      inviteUserIdsShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateVideoConferenceResponseBody extends $tea.Model {
  conferenceId?: string;
  conferencePassword?: string;
  externalLinkUrl?: string;
  hostPassword?: string;
  phoneNumbers?: string[];
  requestId?: string;
  roomCode?: string;
  static names(): { [key: string]: string } {
    return {
      conferenceId: 'conferenceId',
      conferencePassword: 'conferencePassword',
      externalLinkUrl: 'externalLinkUrl',
      hostPassword: 'hostPassword',
      phoneNumbers: 'phoneNumbers',
      requestId: 'requestId',
      roomCode: 'roomCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      conferenceId: 'string',
      conferencePassword: 'string',
      externalLinkUrl: 'string',
      hostPassword: 'string',
      phoneNumbers: { 'type': 'array', 'itemType': 'string' },
      requestId: 'string',
      roomCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateVideoConferenceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateVideoConferenceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateVideoConferenceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWorkspaceHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: CreateWorkspaceHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: CreateWorkspaceHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWorkspaceShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWorkspaceRequest extends $tea.Model {
  description?: string;
  name?: string;
  tenantContext?: CreateWorkspaceRequestTenantContext;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      tenantContext: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      tenantContext: CreateWorkspaceRequestTenantContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWorkspaceShrinkRequest extends $tea.Model {
  description?: string;
  name?: string;
  tenantContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      tenantContextShrink: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      tenantContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWorkspaceResponseBody extends $tea.Model {
  description?: string;
  name?: string;
  requestId?: string;
  url?: string;
  workspaceId?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'description',
      name: 'name',
      requestId: 'requestId',
      url: 'url',
      workspaceId: 'workspaceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      requestId: 'string',
      url: 'string',
      workspaceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWorkspaceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateWorkspaceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateWorkspaceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWorkspaceDocHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: CreateWorkspaceDocHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: CreateWorkspaceDocHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWorkspaceDocShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWorkspaceDocRequest extends $tea.Model {
  docType?: string;
  name?: string;
  parentNodeId?: string;
  templateId?: string;
  templateType?: string;
  tenantContext?: CreateWorkspaceDocRequestTenantContext;
  workspaceId?: string;
  static names(): { [key: string]: string } {
    return {
      docType: 'DocType',
      name: 'Name',
      parentNodeId: 'ParentNodeId',
      templateId: 'TemplateId',
      templateType: 'TemplateType',
      tenantContext: 'TenantContext',
      workspaceId: 'WorkspaceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      docType: 'string',
      name: 'string',
      parentNodeId: 'string',
      templateId: 'string',
      templateType: 'string',
      tenantContext: CreateWorkspaceDocRequestTenantContext,
      workspaceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWorkspaceDocShrinkRequest extends $tea.Model {
  docType?: string;
  name?: string;
  parentNodeId?: string;
  templateId?: string;
  templateType?: string;
  tenantContextShrink?: string;
  workspaceId?: string;
  static names(): { [key: string]: string } {
    return {
      docType: 'DocType',
      name: 'Name',
      parentNodeId: 'ParentNodeId',
      templateId: 'TemplateId',
      templateType: 'TemplateType',
      tenantContextShrink: 'TenantContext',
      workspaceId: 'WorkspaceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      docType: 'string',
      name: 'string',
      parentNodeId: 'string',
      templateId: 'string',
      templateType: 'string',
      tenantContextShrink: 'string',
      workspaceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWorkspaceDocResponseBody extends $tea.Model {
  docKey?: string;
  nodeId?: string;
  requestId?: string;
  url?: string;
  workspaceId?: string;
  static names(): { [key: string]: string } {
    return {
      docKey: 'docKey',
      nodeId: 'nodeId',
      requestId: 'requestId',
      url: 'url',
      workspaceId: 'workspaceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      docKey: 'string',
      nodeId: 'string',
      requestId: 'string',
      url: 'string',
      workspaceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWorkspaceDocResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateWorkspaceDocResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateWorkspaceDocResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteColumnsHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: DeleteColumnsHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: DeleteColumnsHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteColumnsShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteColumnsRequest extends $tea.Model {
  column?: number;
  columnCount?: number;
  sheetId?: string;
  tenantContext?: DeleteColumnsRequestTenantContext;
  workbookId?: string;
  static names(): { [key: string]: string } {
    return {
      column: 'Column',
      columnCount: 'ColumnCount',
      sheetId: 'SheetId',
      tenantContext: 'TenantContext',
      workbookId: 'WorkbookId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      column: 'number',
      columnCount: 'number',
      sheetId: 'string',
      tenantContext: DeleteColumnsRequestTenantContext,
      workbookId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteColumnsShrinkRequest extends $tea.Model {
  column?: number;
  columnCount?: number;
  sheetId?: string;
  tenantContextShrink?: string;
  workbookId?: string;
  static names(): { [key: string]: string } {
    return {
      column: 'Column',
      columnCount: 'ColumnCount',
      sheetId: 'SheetId',
      tenantContextShrink: 'TenantContext',
      workbookId: 'WorkbookId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      column: 'number',
      columnCount: 'number',
      sheetId: 'string',
      tenantContextShrink: 'string',
      workbookId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteColumnsResponseBody extends $tea.Model {
  id?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'id',
      requestId: 'requestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteColumnsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteColumnsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteColumnsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEventHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: DeleteEventHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: DeleteEventHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEventShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEventRequest extends $tea.Model {
  calendarId?: string;
  eventId?: string;
  pushNotification?: boolean;
  static names(): { [key: string]: string } {
    return {
      calendarId: 'CalendarId',
      eventId: 'EventId',
      pushNotification: 'pushNotification',
    };
  }

  static types(): { [key: string]: any } {
    return {
      calendarId: 'string',
      eventId: 'string',
      pushNotification: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEventResponseBody extends $tea.Model {
  content?: DeleteEventResponseBodyContent;
  errorCode?: string;
  errorCtx?: { [key: string]: any };
  errorMsg?: string;
  httpStatusCode?: number;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      content: 'content',
      errorCode: 'errorCode',
      errorCtx: 'errorCtx',
      errorMsg: 'errorMsg',
      httpStatusCode: 'httpStatusCode',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: DeleteEventResponseBodyContent,
      errorCode: 'string',
      errorCtx: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      errorMsg: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEventResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteEventResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteEventResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteFormDataHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: DeleteFormDataHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: DeleteFormDataHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteFormDataShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteFormDataRequest extends $tea.Model {
  appType?: string;
  formInstanceId?: string;
  language?: string;
  systemToken?: string;
  static names(): { [key: string]: string } {
    return {
      appType: 'AppType',
      formInstanceId: 'FormInstanceId',
      language: 'Language',
      systemToken: 'SystemToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appType: 'string',
      formInstanceId: 'string',
      language: 'string',
      systemToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteFormDataResponseBody extends $tea.Model {
  requestId?: string;
  vendorRequestId?: string;
  vendorType?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'requestId',
      vendorRequestId: 'vendorRequestId',
      vendorType: 'vendorType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      vendorRequestId: 'string',
      vendorType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteFormDataResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteFormDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteFormDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteInstanceHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: DeleteInstanceHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: DeleteInstanceHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteInstanceShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteInstanceRequest extends $tea.Model {
  appType?: string;
  language?: string;
  processInstanceId?: string;
  systemToken?: string;
  static names(): { [key: string]: string } {
    return {
      appType: 'AppType',
      language: 'Language',
      processInstanceId: 'ProcessInstanceId',
      systemToken: 'SystemToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appType: 'string',
      language: 'string',
      processInstanceId: 'string',
      systemToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteInstanceResponseBody extends $tea.Model {
  requestId?: string;
  vendorRequestId?: string;
  vendorType?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'requestId',
      vendorRequestId: 'vendorRequestId',
      vendorType: 'vendorType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      vendorRequestId: 'string',
      vendorType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteInstanceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: DeleteLiveHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: DeleteLiveHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveRequest extends $tea.Model {
  liveId?: string;
  tenantContext?: DeleteLiveRequestTenantContext;
  static names(): { [key: string]: string } {
    return {
      liveId: 'LiveId',
      tenantContext: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      liveId: 'string',
      tenantContext: DeleteLiveRequestTenantContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveShrinkRequest extends $tea.Model {
  liveId?: string;
  tenantContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      liveId: 'LiveId',
      tenantContextShrink: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      liveId: 'string',
      tenantContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveResponseBody extends $tea.Model {
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteLiveResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteLiveResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMeetingRoomHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: DeleteMeetingRoomHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: DeleteMeetingRoomHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMeetingRoomShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMeetingRoomRequest extends $tea.Model {
  roomId?: string;
  tenantContext?: DeleteMeetingRoomRequestTenantContext;
  static names(): { [key: string]: string } {
    return {
      roomId: 'RoomId',
      tenantContext: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      roomId: 'string',
      tenantContext: DeleteMeetingRoomRequestTenantContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMeetingRoomShrinkRequest extends $tea.Model {
  roomId?: string;
  tenantContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      roomId: 'RoomId',
      tenantContextShrink: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      roomId: 'string',
      tenantContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMeetingRoomResponseBody extends $tea.Model {
  requestId?: string;
  result?: boolean;
  static names(): { [key: string]: string } {
    return {
      requestId: 'requestId',
      result: 'result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMeetingRoomResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteMeetingRoomResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteMeetingRoomResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMeetingRoomGroupHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: DeleteMeetingRoomGroupHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: DeleteMeetingRoomGroupHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMeetingRoomGroupShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMeetingRoomGroupRequest extends $tea.Model {
  groupId?: string;
  tenantContext?: DeleteMeetingRoomGroupRequestTenantContext;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      tenantContext: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      tenantContext: DeleteMeetingRoomGroupRequestTenantContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMeetingRoomGroupShrinkRequest extends $tea.Model {
  groupId?: string;
  tenantContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      tenantContextShrink: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      tenantContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMeetingRoomGroupResponseBody extends $tea.Model {
  requestId?: string;
  result?: boolean;
  static names(): { [key: string]: string } {
    return {
      requestId: 'requestId',
      result: 'result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMeetingRoomGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteMeetingRoomGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteMeetingRoomGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRowsHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: DeleteRowsHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: DeleteRowsHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRowsShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRowsRequest extends $tea.Model {
  row?: number;
  rowCount?: number;
  sheetId?: string;
  tenantContext?: DeleteRowsRequestTenantContext;
  workbookId?: string;
  static names(): { [key: string]: string } {
    return {
      row: 'Row',
      rowCount: 'RowCount',
      sheetId: 'SheetId',
      tenantContext: 'TenantContext',
      workbookId: 'WorkbookId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      row: 'number',
      rowCount: 'number',
      sheetId: 'string',
      tenantContext: DeleteRowsRequestTenantContext,
      workbookId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRowsShrinkRequest extends $tea.Model {
  row?: number;
  rowCount?: number;
  sheetId?: string;
  tenantContextShrink?: string;
  workbookId?: string;
  static names(): { [key: string]: string } {
    return {
      row: 'Row',
      rowCount: 'RowCount',
      sheetId: 'SheetId',
      tenantContextShrink: 'TenantContext',
      workbookId: 'WorkbookId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      row: 'number',
      rowCount: 'number',
      sheetId: 'string',
      tenantContextShrink: 'string',
      workbookId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRowsResponseBody extends $tea.Model {
  id?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'id',
      requestId: 'requestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRowsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteRowsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteRowsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteScenegroupMemberHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: DeleteScenegroupMemberHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: DeleteScenegroupMemberHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteScenegroupMemberShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteScenegroupMemberRequest extends $tea.Model {
  openConversationId?: string;
  userIds?: string;
  static names(): { [key: string]: string } {
    return {
      openConversationId: 'OpenConversationId',
      userIds: 'UserIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      openConversationId: 'string',
      userIds: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteScenegroupMemberResponseBody extends $tea.Model {
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteScenegroupMemberResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteScenegroupMemberResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteScenegroupMemberResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSheetHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: DeleteSheetHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: DeleteSheetHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSheetShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSheetRequest extends $tea.Model {
  sheetId?: string;
  tenantContext?: DeleteSheetRequestTenantContext;
  workbookId?: string;
  static names(): { [key: string]: string } {
    return {
      sheetId: 'SheetId',
      tenantContext: 'TenantContext',
      workbookId: 'WorkbookId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      sheetId: 'string',
      tenantContext: DeleteSheetRequestTenantContext,
      workbookId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSheetShrinkRequest extends $tea.Model {
  sheetId?: string;
  tenantContextShrink?: string;
  workbookId?: string;
  static names(): { [key: string]: string } {
    return {
      sheetId: 'SheetId',
      tenantContextShrink: 'TenantContext',
      workbookId: 'WorkbookId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      sheetId: 'string',
      tenantContextShrink: 'string',
      workbookId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSheetResponseBody extends $tea.Model {
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSheetResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteSheetResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteSheetResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSubscribedCalendarHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: DeleteSubscribedCalendarHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: DeleteSubscribedCalendarHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSubscribedCalendarShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSubscribedCalendarRequest extends $tea.Model {
  calendarId?: string;
  static names(): { [key: string]: string } {
    return {
      calendarId: 'CalendarId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      calendarId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSubscribedCalendarResponseBody extends $tea.Model {
  result?: boolean;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      result: 'Result',
      requestId: 'requestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      result: 'boolean',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSubscribedCalendarResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteSubscribedCalendarResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteSubscribedCalendarResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTodoTaskHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: DeleteTodoTaskHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: DeleteTodoTaskHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTodoTaskShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTodoTaskRequest extends $tea.Model {
  tenantContext?: DeleteTodoTaskRequestTenantContext;
  operatorId?: string;
  taskId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantContext: 'TenantContext',
      operatorId: 'operatorId',
      taskId: 'taskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantContext: DeleteTodoTaskRequestTenantContext,
      operatorId: 'string',
      taskId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTodoTaskShrinkRequest extends $tea.Model {
  tenantContextShrink?: string;
  operatorId?: string;
  taskId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantContextShrink: 'TenantContext',
      operatorId: 'operatorId',
      taskId: 'taskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantContextShrink: 'string',
      operatorId: 'string',
      taskId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTodoTaskResponseBody extends $tea.Model {
  requestId?: string;
  result?: boolean;
  static names(): { [key: string]: string } {
    return {
      requestId: 'requestId',
      result: 'result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTodoTaskResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteTodoTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteTodoTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWorkspaceDocMembersHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: DeleteWorkspaceDocMembersHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: DeleteWorkspaceDocMembersHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWorkspaceDocMembersShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWorkspaceDocMembersRequest extends $tea.Model {
  members?: DeleteWorkspaceDocMembersRequestMembers[];
  nodeId?: string;
  tenantContext?: DeleteWorkspaceDocMembersRequestTenantContext;
  workspaceId?: string;
  static names(): { [key: string]: string } {
    return {
      members: 'Members',
      nodeId: 'NodeId',
      tenantContext: 'TenantContext',
      workspaceId: 'WorkspaceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      members: { 'type': 'array', 'itemType': DeleteWorkspaceDocMembersRequestMembers },
      nodeId: 'string',
      tenantContext: DeleteWorkspaceDocMembersRequestTenantContext,
      workspaceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWorkspaceDocMembersShrinkRequest extends $tea.Model {
  membersShrink?: string;
  nodeId?: string;
  tenantContextShrink?: string;
  workspaceId?: string;
  static names(): { [key: string]: string } {
    return {
      membersShrink: 'Members',
      nodeId: 'NodeId',
      tenantContextShrink: 'TenantContext',
      workspaceId: 'WorkspaceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      membersShrink: 'string',
      nodeId: 'string',
      tenantContextShrink: 'string',
      workspaceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWorkspaceDocMembersResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'requestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWorkspaceDocMembersResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteWorkspaceDocMembersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteWorkspaceDocMembersResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWorkspaceMembersHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: DeleteWorkspaceMembersHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: DeleteWorkspaceMembersHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWorkspaceMembersShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWorkspaceMembersRequest extends $tea.Model {
  members?: DeleteWorkspaceMembersRequestMembers[];
  tenantContext?: DeleteWorkspaceMembersRequestTenantContext;
  workspaceId?: string;
  static names(): { [key: string]: string } {
    return {
      members: 'Members',
      tenantContext: 'TenantContext',
      workspaceId: 'WorkspaceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      members: { 'type': 'array', 'itemType': DeleteWorkspaceMembersRequestMembers },
      tenantContext: DeleteWorkspaceMembersRequestTenantContext,
      workspaceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWorkspaceMembersShrinkRequest extends $tea.Model {
  membersShrink?: string;
  tenantContextShrink?: string;
  workspaceId?: string;
  static names(): { [key: string]: string } {
    return {
      membersShrink: 'Members',
      tenantContextShrink: 'TenantContext',
      workspaceId: 'WorkspaceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      membersShrink: 'string',
      tenantContextShrink: 'string',
      workspaceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWorkspaceMembersResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'requestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWorkspaceMembersResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteWorkspaceMembersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteWorkspaceMembersResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExecuteBatchTaskHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: ExecuteBatchTaskHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: ExecuteBatchTaskHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExecuteBatchTaskShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExecuteBatchTaskRequest extends $tea.Model {
  appType?: string;
  outResult?: string;
  remark?: string;
  systemToken?: string;
  taskInformationList?: string;
  static names(): { [key: string]: string } {
    return {
      appType: 'AppType',
      outResult: 'OutResult',
      remark: 'Remark',
      systemToken: 'SystemToken',
      taskInformationList: 'TaskInformationList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appType: 'string',
      outResult: 'string',
      remark: 'string',
      systemToken: 'string',
      taskInformationList: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExecuteBatchTaskResponseBody extends $tea.Model {
  failNumber?: number;
  requestId?: string;
  successNumber?: number;
  total?: number;
  vendorRequestId?: string;
  vendorType?: string;
  static names(): { [key: string]: string } {
    return {
      failNumber: 'failNumber',
      requestId: 'requestId',
      successNumber: 'successNumber',
      total: 'total',
      vendorRequestId: 'vendorRequestId',
      vendorType: 'vendorType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failNumber: 'number',
      requestId: 'string',
      successNumber: 'number',
      total: 'number',
      vendorRequestId: 'string',
      vendorType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExecuteBatchTaskResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ExecuteBatchTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ExecuteBatchTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExecutePlatformTaskHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: ExecutePlatformTaskHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: ExecutePlatformTaskHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExecutePlatformTaskShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExecutePlatformTaskRequest extends $tea.Model {
  appType?: string;
  formDataJson?: string;
  language?: string;
  noExecuteExpressions?: string;
  outResult?: string;
  processInstanceId?: string;
  remark?: string;
  systemToken?: string;
  static names(): { [key: string]: string } {
    return {
      appType: 'AppType',
      formDataJson: 'FormDataJson',
      language: 'Language',
      noExecuteExpressions: 'NoExecuteExpressions',
      outResult: 'OutResult',
      processInstanceId: 'ProcessInstanceId',
      remark: 'Remark',
      systemToken: 'SystemToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appType: 'string',
      formDataJson: 'string',
      language: 'string',
      noExecuteExpressions: 'string',
      outResult: 'string',
      processInstanceId: 'string',
      remark: 'string',
      systemToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExecutePlatformTaskResponseBody extends $tea.Model {
  requestId?: string;
  vendorRequestId?: string;
  vendorType?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'requestId',
      vendorRequestId: 'vendorRequestId',
      vendorType: 'vendorType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      vendorRequestId: 'string',
      vendorType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExecutePlatformTaskResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ExecutePlatformTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ExecutePlatformTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExecuteTaskHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: ExecuteTaskHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: ExecuteTaskHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExecuteTaskShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExecuteTaskRequest extends $tea.Model {
  appType?: string;
  digitalSignUrl?: string;
  formDataJson?: string;
  language?: string;
  noExecuteExpressions?: string;
  outResult?: string;
  processInstanceId?: string;
  remark?: string;
  systemToken?: string;
  taskId?: number;
  static names(): { [key: string]: string } {
    return {
      appType: 'AppType',
      digitalSignUrl: 'DigitalSignUrl',
      formDataJson: 'FormDataJson',
      language: 'Language',
      noExecuteExpressions: 'NoExecuteExpressions',
      outResult: 'OutResult',
      processInstanceId: 'ProcessInstanceId',
      remark: 'Remark',
      systemToken: 'SystemToken',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appType: 'string',
      digitalSignUrl: 'string',
      formDataJson: 'string',
      language: 'string',
      noExecuteExpressions: 'string',
      outResult: 'string',
      processInstanceId: 'string',
      remark: 'string',
      systemToken: 'string',
      taskId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExecuteTaskResponseBody extends $tea.Model {
  requestId?: string;
  vendorRequestId?: string;
  vendorType?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'requestId',
      vendorRequestId: 'vendorRequestId',
      vendorType: 'vendorType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      vendorRequestId: 'string',
      vendorType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExecuteTaskResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ExecuteTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ExecuteTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExpandGroupCapacityHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: ExpandGroupCapacityHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: ExpandGroupCapacityHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExpandGroupCapacityShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExpandGroupCapacityRequest extends $tea.Model {
  openConversationId?: string;
  tenantContext?: ExpandGroupCapacityRequestTenantContext;
  static names(): { [key: string]: string } {
    return {
      openConversationId: 'OpenConversationId',
      tenantContext: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      openConversationId: 'string',
      tenantContext: ExpandGroupCapacityRequestTenantContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExpandGroupCapacityShrinkRequest extends $tea.Model {
  openConversationId?: string;
  tenantContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      openConversationId: 'OpenConversationId',
      tenantContextShrink: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      openConversationId: 'string',
      tenantContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExpandGroupCapacityResponseBody extends $tea.Model {
  requestId?: string;
  success?: boolean;
  vendorRequestId?: string;
  vendorType?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'requestId',
      success: 'success',
      vendorRequestId: 'vendorRequestId',
      vendorType: 'vendorType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      success: 'boolean',
      vendorRequestId: 'string',
      vendorType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExpandGroupCapacityResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ExpandGroupCapacityResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ExpandGroupCapacityResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetActivityListHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: GetActivityListHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: GetActivityListHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetActivityListShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetActivityListRequest extends $tea.Model {
  appType?: string;
  language?: string;
  processCode?: string;
  systemToken?: string;
  static names(): { [key: string]: string } {
    return {
      appType: 'AppType',
      language: 'Language',
      processCode: 'ProcessCode',
      systemToken: 'SystemToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appType: 'string',
      language: 'string',
      processCode: 'string',
      systemToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetActivityListResponseBody extends $tea.Model {
  requestId?: string;
  result?: GetActivityListResponseBodyResult[];
  vendorRequestId?: string;
  vendorType?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'requestId',
      result: 'result',
      vendorRequestId: 'vendorRequestId',
      vendorType: 'vendorType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: { 'type': 'array', 'itemType': GetActivityListResponseBodyResult },
      vendorRequestId: 'string',
      vendorType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetActivityListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetActivityListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetActivityListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAllSheetsHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: GetAllSheetsHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: GetAllSheetsHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAllSheetsShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAllSheetsRequest extends $tea.Model {
  tenantContext?: GetAllSheetsRequestTenantContext;
  workbookId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantContext: 'TenantContext',
      workbookId: 'WorkbookId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantContext: GetAllSheetsRequestTenantContext,
      workbookId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAllSheetsShrinkRequest extends $tea.Model {
  tenantContextShrink?: string;
  workbookId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantContextShrink: 'TenantContext',
      workbookId: 'WorkbookId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantContextShrink: 'string',
      workbookId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAllSheetsResponseBody extends $tea.Model {
  requestId?: string;
  value?: GetAllSheetsResponseBodyValue[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'requestId',
      value: 'value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      value: { 'type': 'array', 'itemType': GetAllSheetsResponseBodyValue },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAllSheetsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetAllSheetsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetAllSheetsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetConversaionSpaceHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: GetConversaionSpaceHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: GetConversaionSpaceHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetConversaionSpaceShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetConversaionSpaceRequest extends $tea.Model {
  openConversationId?: string;
  tenantContext?: GetConversaionSpaceRequestTenantContext;
  static names(): { [key: string]: string } {
    return {
      openConversationId: 'OpenConversationId',
      tenantContext: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      openConversationId: 'string',
      tenantContext: GetConversaionSpaceRequestTenantContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetConversaionSpaceShrinkRequest extends $tea.Model {
  openConversationId?: string;
  tenantContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      openConversationId: 'OpenConversationId',
      tenantContextShrink: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      openConversationId: 'string',
      tenantContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetConversaionSpaceResponseBody extends $tea.Model {
  requestId?: string;
  space?: GetConversaionSpaceResponseBodySpace;
  vendorRequestId?: string;
  vendorType?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'requestId',
      space: 'space',
      vendorRequestId: 'vendorRequestId',
      vendorType: 'vendorType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      space: GetConversaionSpaceResponseBodySpace,
      vendorRequestId: 'string',
      vendorType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetConversaionSpaceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetConversaionSpaceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetConversaionSpaceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCorpAccomplishmentTasksHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: GetCorpAccomplishmentTasksHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: GetCorpAccomplishmentTasksHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCorpAccomplishmentTasksShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCorpAccomplishmentTasksRequest extends $tea.Model {
  appTypes?: string;
  corpId?: string;
  createFromTimeGMT?: number;
  createToTimeGMT?: number;
  keyword?: string;
  language?: string;
  pageNumber?: number;
  pageSize?: number;
  processCodes?: string;
  token?: string;
  static names(): { [key: string]: string } {
    return {
      appTypes: 'AppTypes',
      corpId: 'CorpId',
      createFromTimeGMT: 'CreateFromTimeGMT',
      createToTimeGMT: 'CreateToTimeGMT',
      keyword: 'Keyword',
      language: 'Language',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      processCodes: 'ProcessCodes',
      token: 'Token',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appTypes: 'string',
      corpId: 'string',
      createFromTimeGMT: 'number',
      createToTimeGMT: 'number',
      keyword: 'string',
      language: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      processCodes: 'string',
      token: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCorpAccomplishmentTasksResponseBody extends $tea.Model {
  data?: GetCorpAccomplishmentTasksResponseBodyData[];
  pageNumber?: number;
  requestId?: string;
  totalCount?: number;
  vendorRequestId?: string;
  vendorType?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'data',
      pageNumber: 'pageNumber',
      requestId: 'requestId',
      totalCount: 'totalCount',
      vendorRequestId: 'vendorRequestId',
      vendorType: 'vendorType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': GetCorpAccomplishmentTasksResponseBodyData },
      pageNumber: 'number',
      requestId: 'string',
      totalCount: 'number',
      vendorRequestId: 'string',
      vendorType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCorpAccomplishmentTasksResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetCorpAccomplishmentTasksResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetCorpAccomplishmentTasksResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCorpTasksHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: GetCorpTasksHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: GetCorpTasksHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCorpTasksShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCorpTasksRequest extends $tea.Model {
  appTypes?: string;
  corpId?: string;
  createFromTimeGMT?: number;
  createToTimeGMT?: number;
  keyword?: string;
  language?: string;
  pageNumber?: number;
  pageSize?: number;
  processCodes?: string;
  token?: string;
  static names(): { [key: string]: string } {
    return {
      appTypes: 'AppTypes',
      corpId: 'CorpId',
      createFromTimeGMT: 'CreateFromTimeGMT',
      createToTimeGMT: 'CreateToTimeGMT',
      keyword: 'Keyword',
      language: 'Language',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      processCodes: 'ProcessCodes',
      token: 'Token',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appTypes: 'string',
      corpId: 'string',
      createFromTimeGMT: 'number',
      createToTimeGMT: 'number',
      keyword: 'string',
      language: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      processCodes: 'string',
      token: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCorpTasksResponseBody extends $tea.Model {
  data?: GetCorpTasksResponseBodyData[];
  pageNumber?: number;
  requestId?: string;
  totalCount?: number;
  vendorRequestId?: string;
  vendorType?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'data',
      pageNumber: 'pageNumber',
      requestId: 'requestId',
      totalCount: 'totalCount',
      vendorRequestId: 'vendorRequestId',
      vendorType: 'vendorType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': GetCorpTasksResponseBodyData },
      pageNumber: 'number',
      requestId: 'string',
      totalCount: 'number',
      vendorRequestId: 'string',
      vendorType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCorpTasksResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetCorpTasksResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetCorpTasksResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDocContentHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: GetDocContentHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: GetDocContentHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDocContentShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDocContentRequest extends $tea.Model {
  dentryUuid?: string;
  targetFormat?: string;
  tenantContext?: GetDocContentRequestTenantContext;
  userToken?: string;
  static names(): { [key: string]: string } {
    return {
      dentryUuid: 'DentryUuid',
      targetFormat: 'TargetFormat',
      tenantContext: 'TenantContext',
      userToken: 'userToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dentryUuid: 'string',
      targetFormat: 'string',
      tenantContext: GetDocContentRequestTenantContext,
      userToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDocContentShrinkRequest extends $tea.Model {
  dentryUuid?: string;
  targetFormat?: string;
  tenantContextShrink?: string;
  userToken?: string;
  static names(): { [key: string]: string } {
    return {
      dentryUuid: 'DentryUuid',
      targetFormat: 'TargetFormat',
      tenantContextShrink: 'TenantContext',
      userToken: 'userToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dentryUuid: 'string',
      targetFormat: 'string',
      tenantContextShrink: 'string',
      userToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDocContentResponseBody extends $tea.Model {
  requestId?: string;
  taskId?: number;
  vendorRequestId?: string;
  vendorType?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'requestId',
      taskId: 'taskId',
      vendorRequestId: 'vendorRequestId',
      vendorType: 'vendorType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      taskId: 'number',
      vendorRequestId: 'string',
      vendorType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDocContentResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetDocContentResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDocContentResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEventHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: GetEventHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: GetEventHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEventShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEventRequest extends $tea.Model {
  calendarId?: string;
  eventId?: string;
  maxAttendees?: number;
  static names(): { [key: string]: string } {
    return {
      calendarId: 'CalendarId',
      eventId: 'EventId',
      maxAttendees: 'MaxAttendees',
    };
  }

  static types(): { [key: string]: any } {
    return {
      calendarId: 'string',
      eventId: 'string',
      maxAttendees: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEventResponseBody extends $tea.Model {
  attendees?: GetEventResponseBodyAttendees[];
  categories?: GetEventResponseBodyCategories[];
  createTime?: string;
  description?: string;
  end?: GetEventResponseBodyEnd;
  extendedProperties?: GetEventResponseBodyExtendedProperties;
  id?: string;
  isAllDay?: boolean;
  location?: GetEventResponseBodyLocation;
  meetingRooms?: GetEventResponseBodyMeetingRooms[];
  onlineMeetingInfo?: GetEventResponseBodyOnlineMeetingInfo;
  organizer?: GetEventResponseBodyOrganizer;
  originStart?: GetEventResponseBodyOriginStart;
  recurrence?: GetEventResponseBodyRecurrence;
  reminders?: GetEventResponseBodyReminders[];
  requestId?: string;
  richTextDescription?: GetEventResponseBodyRichTextDescription;
  seriesMasterId?: string;
  start?: GetEventResponseBodyStart;
  status?: string;
  summary?: string;
  updateTime?: string;
  static names(): { [key: string]: string } {
    return {
      attendees: 'attendees',
      categories: 'categories',
      createTime: 'createTime',
      description: 'description',
      end: 'end',
      extendedProperties: 'extendedProperties',
      id: 'id',
      isAllDay: 'isAllDay',
      location: 'location',
      meetingRooms: 'meetingRooms',
      onlineMeetingInfo: 'onlineMeetingInfo',
      organizer: 'organizer',
      originStart: 'originStart',
      recurrence: 'recurrence',
      reminders: 'reminders',
      requestId: 'requestId',
      richTextDescription: 'richTextDescription',
      seriesMasterId: 'seriesMasterId',
      start: 'start',
      status: 'status',
      summary: 'summary',
      updateTime: 'updateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attendees: { 'type': 'array', 'itemType': GetEventResponseBodyAttendees },
      categories: { 'type': 'array', 'itemType': GetEventResponseBodyCategories },
      createTime: 'string',
      description: 'string',
      end: GetEventResponseBodyEnd,
      extendedProperties: GetEventResponseBodyExtendedProperties,
      id: 'string',
      isAllDay: 'boolean',
      location: GetEventResponseBodyLocation,
      meetingRooms: { 'type': 'array', 'itemType': GetEventResponseBodyMeetingRooms },
      onlineMeetingInfo: GetEventResponseBodyOnlineMeetingInfo,
      organizer: GetEventResponseBodyOrganizer,
      originStart: GetEventResponseBodyOriginStart,
      recurrence: GetEventResponseBodyRecurrence,
      reminders: { 'type': 'array', 'itemType': GetEventResponseBodyReminders },
      requestId: 'string',
      richTextDescription: GetEventResponseBodyRichTextDescription,
      seriesMasterId: 'string',
      start: GetEventResponseBodyStart,
      status: 'string',
      summary: 'string',
      updateTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEventResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetEventResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetEventResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFieldDefByUuidHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: GetFieldDefByUuidHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: GetFieldDefByUuidHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFieldDefByUuidShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFieldDefByUuidRequest extends $tea.Model {
  appType?: string;
  formUuid?: string;
  systemToken?: string;
  static names(): { [key: string]: string } {
    return {
      appType: 'AppType',
      formUuid: 'FormUuid',
      systemToken: 'SystemToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appType: 'string',
      formUuid: 'string',
      systemToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFieldDefByUuidResponseBody extends $tea.Model {
  requestId?: string;
  result?: GetFieldDefByUuidResponseBodyResult[];
  success?: boolean;
  vendorRequestId?: string;
  vendorType?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'requestId',
      result: 'result',
      success: 'success',
      vendorRequestId: 'vendorRequestId',
      vendorType: 'vendorType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: { 'type': 'array', 'itemType': GetFieldDefByUuidResponseBodyResult },
      success: 'boolean',
      vendorRequestId: 'string',
      vendorType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFieldDefByUuidResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetFieldDefByUuidResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetFieldDefByUuidResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFileDownloadInfoHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: GetFileDownloadInfoHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: GetFileDownloadInfoHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFileDownloadInfoShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFileDownloadInfoRequest extends $tea.Model {
  dentryId?: string;
  option?: GetFileDownloadInfoRequestOption;
  spaceId?: string;
  tenantContext?: GetFileDownloadInfoRequestTenantContext;
  static names(): { [key: string]: string } {
    return {
      dentryId: 'DentryId',
      option: 'Option',
      spaceId: 'SpaceId',
      tenantContext: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dentryId: 'string',
      option: GetFileDownloadInfoRequestOption,
      spaceId: 'string',
      tenantContext: GetFileDownloadInfoRequestTenantContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFileDownloadInfoShrinkRequest extends $tea.Model {
  dentryId?: string;
  optionShrink?: string;
  spaceId?: string;
  tenantContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      dentryId: 'DentryId',
      optionShrink: 'Option',
      spaceId: 'SpaceId',
      tenantContextShrink: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dentryId: 'string',
      optionShrink: 'string',
      spaceId: 'string',
      tenantContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFileDownloadInfoResponseBody extends $tea.Model {
  headerSignatureInfo?: GetFileDownloadInfoResponseBodyHeaderSignatureInfo;
  protocol?: string;
  requestId?: string;
  vendorRequestId?: string;
  vendorType?: string;
  static names(): { [key: string]: string } {
    return {
      headerSignatureInfo: 'headerSignatureInfo',
      protocol: 'protocol',
      requestId: 'requestId',
      vendorRequestId: 'vendorRequestId',
      vendorType: 'vendorType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headerSignatureInfo: GetFileDownloadInfoResponseBodyHeaderSignatureInfo,
      protocol: 'string',
      requestId: 'string',
      vendorRequestId: 'string',
      vendorType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFileDownloadInfoResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetFileDownloadInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetFileDownloadInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFormComponentDefinitionListHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: GetFormComponentDefinitionListHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: GetFormComponentDefinitionListHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFormComponentDefinitionListShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFormComponentDefinitionListRequest extends $tea.Model {
  appType?: string;
  formUuid?: string;
  language?: string;
  systemToken?: string;
  static names(): { [key: string]: string } {
    return {
      appType: 'AppType',
      formUuid: 'FormUuid',
      language: 'Language',
      systemToken: 'SystemToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appType: 'string',
      formUuid: 'string',
      language: 'string',
      systemToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFormComponentDefinitionListResponseBody extends $tea.Model {
  result?: GetFormComponentDefinitionListResponseBodyResult[];
  requestId?: string;
  vendorRequestId?: string;
  vendorType?: string;
  static names(): { [key: string]: string } {
    return {
      result: 'Result',
      requestId: 'requestId',
      vendorRequestId: 'vendorRequestId',
      vendorType: 'vendorType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      result: { 'type': 'array', 'itemType': GetFormComponentDefinitionListResponseBodyResult },
      requestId: 'string',
      vendorRequestId: 'string',
      vendorType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFormComponentDefinitionListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetFormComponentDefinitionListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetFormComponentDefinitionListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFormDataByIDHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: GetFormDataByIDHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: GetFormDataByIDHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFormDataByIDShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFormDataByIDRequest extends $tea.Model {
  appType?: string;
  id?: string;
  language?: string;
  systemToken?: string;
  static names(): { [key: string]: string } {
    return {
      appType: 'AppType',
      id: 'Id',
      language: 'Language',
      systemToken: 'SystemToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appType: 'string',
      id: 'string',
      language: 'string',
      systemToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFormDataByIDResponseBody extends $tea.Model {
  formData?: { [key: string]: any };
  formInstId?: string;
  modifiedTimeGMT?: string;
  originator?: GetFormDataByIDResponseBodyOriginator;
  requestId?: string;
  vendorRequestId?: string;
  vendorType?: string;
  static names(): { [key: string]: string } {
    return {
      formData: 'formData',
      formInstId: 'formInstId',
      modifiedTimeGMT: 'modifiedTimeGMT',
      originator: 'originator',
      requestId: 'requestId',
      vendorRequestId: 'vendorRequestId',
      vendorType: 'vendorType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      formData: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      formInstId: 'string',
      modifiedTimeGMT: 'string',
      originator: GetFormDataByIDResponseBodyOriginator,
      requestId: 'string',
      vendorRequestId: 'string',
      vendorType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFormDataByIDResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetFormDataByIDResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetFormDataByIDResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFormListInAppHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: GetFormListInAppHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: GetFormListInAppHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFormListInAppShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFormListInAppRequest extends $tea.Model {
  appType?: string;
  formTypes?: string;
  pageNumber?: number;
  pageSize?: number;
  systemToken?: string;
  static names(): { [key: string]: string } {
    return {
      appType: 'AppType',
      formTypes: 'FormTypes',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      systemToken: 'SystemToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appType: 'string',
      formTypes: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      systemToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFormListInAppResponseBody extends $tea.Model {
  currentPage?: number;
  data?: GetFormListInAppResponseBodyData[];
  requestId?: string;
  success?: boolean;
  totalCount?: number;
  vendorRequestId?: string;
  vendorType?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'currentPage',
      data: 'data',
      requestId: 'requestId',
      success: 'success',
      totalCount: 'totalCount',
      vendorRequestId: 'vendorRequestId',
      vendorType: 'vendorType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      data: { 'type': 'array', 'itemType': GetFormListInAppResponseBodyData },
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
      vendorRequestId: 'string',
      vendorType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFormListInAppResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetFormListInAppResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetFormListInAppResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInnerGroupMembersHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: GetInnerGroupMembersHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: GetInnerGroupMembersHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInnerGroupMembersShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInnerGroupMembersRequest extends $tea.Model {
  maxResults?: number;
  nextToken?: string;
  openConversationId?: string;
  static names(): { [key: string]: string } {
    return {
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      openConversationId: 'OpenConversationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxResults: 'number',
      nextToken: 'string',
      openConversationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInnerGroupMembersResponseBody extends $tea.Model {
  hasMore?: boolean;
  nextToken?: string;
  requestId?: string;
  userIds?: string[];
  vendorRequestId?: string;
  vendorType?: string;
  static names(): { [key: string]: string } {
    return {
      hasMore: 'hasMore',
      nextToken: 'nextToken',
      requestId: 'requestId',
      userIds: 'userIds',
      vendorRequestId: 'vendorRequestId',
      vendorType: 'vendorType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      hasMore: 'boolean',
      nextToken: 'string',
      requestId: 'string',
      userIds: { 'type': 'array', 'itemType': 'string' },
      vendorRequestId: 'string',
      vendorType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInnerGroupMembersResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetInnerGroupMembersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetInnerGroupMembersResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstanceByIdHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: GetInstanceByIdHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: GetInstanceByIdHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstanceByIdShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstanceByIdRequest extends $tea.Model {
  appType?: string;
  id?: string;
  language?: string;
  systemToken?: string;
  static names(): { [key: string]: string } {
    return {
      appType: 'AppType',
      id: 'Id',
      language: 'Language',
      systemToken: 'SystemToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appType: 'string',
      id: 'string',
      language: 'string',
      systemToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstanceByIdResponseBody extends $tea.Model {
  actionExecutor?: GetInstanceByIdResponseBodyActionExecutor[];
  approvedResult?: string;
  createTimeGMT?: string;
  data?: { [key: string]: any };
  formUuid?: string;
  instanceStatus?: string;
  modifiedTimeGMT?: string;
  originator?: GetInstanceByIdResponseBodyOriginator;
  processCode?: string;
  processInstanceId?: string;
  requestId?: string;
  title?: string;
  vendorRequestId?: string;
  vendorType?: string;
  version?: number;
  static names(): { [key: string]: string } {
    return {
      actionExecutor: 'actionExecutor',
      approvedResult: 'approvedResult',
      createTimeGMT: 'createTimeGMT',
      data: 'data',
      formUuid: 'formUuid',
      instanceStatus: 'instanceStatus',
      modifiedTimeGMT: 'modifiedTimeGMT',
      originator: 'originator',
      processCode: 'processCode',
      processInstanceId: 'processInstanceId',
      requestId: 'requestId',
      title: 'title',
      vendorRequestId: 'vendorRequestId',
      vendorType: 'vendorType',
      version: 'version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actionExecutor: { 'type': 'array', 'itemType': GetInstanceByIdResponseBodyActionExecutor },
      approvedResult: 'string',
      createTimeGMT: 'string',
      data: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      formUuid: 'string',
      instanceStatus: 'string',
      modifiedTimeGMT: 'string',
      originator: GetInstanceByIdResponseBodyOriginator,
      processCode: 'string',
      processInstanceId: 'string',
      requestId: 'string',
      title: 'string',
      vendorRequestId: 'string',
      vendorType: 'string',
      version: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstanceByIdResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetInstanceByIdResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetInstanceByIdResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstanceIdListHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: GetInstanceIdListHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: GetInstanceIdListHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstanceIdListShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstanceIdListRequest extends $tea.Model {
  appType?: string;
  approvedResult?: string;
  createFromTimeGMT?: string;
  createToTimeGMT?: string;
  formUuid?: string;
  instanceStatus?: string;
  language?: string;
  modifiedFromTimeGMT?: string;
  modifiedToTimeGMT?: string;
  originatorId?: string;
  pageNumber?: number;
  pageSize?: number;
  searchFieldJson?: string;
  systemToken?: string;
  taskId?: string;
  static names(): { [key: string]: string } {
    return {
      appType: 'AppType',
      approvedResult: 'ApprovedResult',
      createFromTimeGMT: 'CreateFromTimeGMT',
      createToTimeGMT: 'CreateToTimeGMT',
      formUuid: 'FormUuid',
      instanceStatus: 'InstanceStatus',
      language: 'Language',
      modifiedFromTimeGMT: 'ModifiedFromTimeGMT',
      modifiedToTimeGMT: 'ModifiedToTimeGMT',
      originatorId: 'OriginatorId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      searchFieldJson: 'SearchFieldJson',
      systemToken: 'SystemToken',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appType: 'string',
      approvedResult: 'string',
      createFromTimeGMT: 'string',
      createToTimeGMT: 'string',
      formUuid: 'string',
      instanceStatus: 'string',
      language: 'string',
      modifiedFromTimeGMT: 'string',
      modifiedToTimeGMT: 'string',
      originatorId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      searchFieldJson: 'string',
      systemToken: 'string',
      taskId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstanceIdListResponseBody extends $tea.Model {
  data?: string[];
  pageNumber?: number;
  requestId?: string;
  totalCount?: number;
  vendorRequestId?: string;
  vendorType?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'data',
      pageNumber: 'pageNumber',
      requestId: 'requestId',
      totalCount: 'totalCount',
      vendorRequestId: 'vendorRequestId',
      vendorType: 'vendorType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': 'string' },
      pageNumber: 'number',
      requestId: 'string',
      totalCount: 'number',
      vendorRequestId: 'string',
      vendorType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstanceIdListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetInstanceIdListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetInstanceIdListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstancesHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: GetInstancesHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: GetInstancesHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstancesShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstancesRequest extends $tea.Model {
  appType?: string;
  approvedResult?: string;
  createFromTimeGMT?: string;
  createToTimeGMT?: string;
  formUuid?: string;
  instanceStatus?: string;
  language?: string;
  modifiedFromTimeGMT?: string;
  modifiedToTimeGMT?: string;
  orderConfigJson?: string;
  originatorId?: string;
  pageNumber?: number;
  pageSize?: number;
  searchFieldJson?: string;
  systemToken?: string;
  taskId?: string;
  static names(): { [key: string]: string } {
    return {
      appType: 'AppType',
      approvedResult: 'ApprovedResult',
      createFromTimeGMT: 'CreateFromTimeGMT',
      createToTimeGMT: 'CreateToTimeGMT',
      formUuid: 'FormUuid',
      instanceStatus: 'InstanceStatus',
      language: 'Language',
      modifiedFromTimeGMT: 'ModifiedFromTimeGMT',
      modifiedToTimeGMT: 'ModifiedToTimeGMT',
      orderConfigJson: 'OrderConfigJson',
      originatorId: 'OriginatorId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      searchFieldJson: 'SearchFieldJson',
      systemToken: 'SystemToken',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appType: 'string',
      approvedResult: 'string',
      createFromTimeGMT: 'string',
      createToTimeGMT: 'string',
      formUuid: 'string',
      instanceStatus: 'string',
      language: 'string',
      modifiedFromTimeGMT: 'string',
      modifiedToTimeGMT: 'string',
      orderConfigJson: 'string',
      originatorId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      searchFieldJson: 'string',
      systemToken: 'string',
      taskId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstancesResponseBody extends $tea.Model {
  data?: GetInstancesResponseBodyData[];
  pageNumber?: number;
  requestId?: string;
  totalCount?: number;
  vendorRequestId?: string;
  vendorType?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'data',
      pageNumber: 'pageNumber',
      requestId: 'requestId',
      totalCount: 'totalCount',
      vendorRequestId: 'vendorRequestId',
      vendorType: 'vendorType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': GetInstancesResponseBodyData },
      pageNumber: 'number',
      requestId: 'string',
      totalCount: 'number',
      vendorRequestId: 'string',
      vendorType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstancesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetInstancesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetInstancesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstancesByIdListHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: GetInstancesByIdListHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: GetInstancesByIdListHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstancesByIdListShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstancesByIdListRequest extends $tea.Model {
  appType?: string;
  language?: string;
  processInstanceIds?: string;
  systemToken?: string;
  static names(): { [key: string]: string } {
    return {
      appType: 'AppType',
      language: 'Language',
      processInstanceIds: 'ProcessInstanceIds',
      systemToken: 'SystemToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appType: 'string',
      language: 'string',
      processInstanceIds: 'string',
      systemToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstancesByIdListResponseBody extends $tea.Model {
  requestId?: string;
  result?: GetInstancesByIdListResponseBodyResult[];
  vendorRequestId?: string;
  vendorType?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'requestId',
      result: 'result',
      vendorRequestId: 'vendorRequestId',
      vendorType: 'vendorType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: { 'type': 'array', 'itemType': GetInstancesByIdListResponseBodyResult },
      vendorRequestId: 'string',
      vendorType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstancesByIdListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetInstancesByIdListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetInstancesByIdListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetLiveReplayUrlHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: GetLiveReplayUrlHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: GetLiveReplayUrlHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetLiveReplayUrlShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetLiveReplayUrlRequest extends $tea.Model {
  liveId?: string;
  tenantContext?: GetLiveReplayUrlRequestTenantContext;
  static names(): { [key: string]: string } {
    return {
      liveId: 'LiveId',
      tenantContext: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      liveId: 'string',
      tenantContext: GetLiveReplayUrlRequestTenantContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetLiveReplayUrlShrinkRequest extends $tea.Model {
  liveId?: string;
  tenantContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      liveId: 'LiveId',
      tenantContextShrink: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      liveId: 'string',
      tenantContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetLiveReplayUrlResponseBody extends $tea.Model {
  replayUrl?: string;
  requestId?: string;
  vendorRequestId?: string;
  vendorType?: string;
  static names(): { [key: string]: string } {
    return {
      replayUrl: 'replayUrl',
      requestId: 'requestId',
      vendorRequestId: 'vendorRequestId',
      vendorType: 'vendorType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      replayUrl: 'string',
      requestId: 'string',
      vendorRequestId: 'string',
      vendorType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetLiveReplayUrlResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetLiveReplayUrlResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetLiveReplayUrlResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMeCorpSubmissionHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: GetMeCorpSubmissionHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: GetMeCorpSubmissionHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMeCorpSubmissionShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMeCorpSubmissionRequest extends $tea.Model {
  appTypes?: string;
  corpId?: string;
  createFromTimeGMT?: number;
  createToTimeGMT?: number;
  keyword?: string;
  language?: string;
  pageNumber?: number;
  pageSize?: number;
  processCodes?: string;
  token?: string;
  static names(): { [key: string]: string } {
    return {
      appTypes: 'AppTypes',
      corpId: 'CorpId',
      createFromTimeGMT: 'CreateFromTimeGMT',
      createToTimeGMT: 'CreateToTimeGMT',
      keyword: 'Keyword',
      language: 'Language',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      processCodes: 'ProcessCodes',
      token: 'Token',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appTypes: 'string',
      corpId: 'string',
      createFromTimeGMT: 'number',
      createToTimeGMT: 'number',
      keyword: 'string',
      language: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      processCodes: 'string',
      token: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMeCorpSubmissionResponseBody extends $tea.Model {
  data?: GetMeCorpSubmissionResponseBodyData[];
  pageNumber?: number;
  requestId?: string;
  totalCount?: number;
  vendorRequestId?: string;
  vendorType?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'data',
      pageNumber: 'pageNumber',
      requestId: 'requestId',
      totalCount: 'totalCount',
      vendorRequestId: 'vendorRequestId',
      vendorType: 'vendorType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': GetMeCorpSubmissionResponseBodyData },
      pageNumber: 'number',
      requestId: 'string',
      totalCount: 'number',
      vendorRequestId: 'string',
      vendorType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMeCorpSubmissionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetMeCorpSubmissionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetMeCorpSubmissionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMeetingRoomsScheduleHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: GetMeetingRoomsScheduleHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: GetMeetingRoomsScheduleHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMeetingRoomsScheduleShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMeetingRoomsScheduleRequest extends $tea.Model {
  endTime?: string;
  roomIds?: string[];
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      roomIds: 'RoomIds',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      roomIds: { 'type': 'array', 'itemType': 'string' },
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMeetingRoomsScheduleShrinkRequest extends $tea.Model {
  endTime?: string;
  roomIdsShrink?: string;
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      roomIdsShrink: 'RoomIds',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      roomIdsShrink: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMeetingRoomsScheduleResponseBody extends $tea.Model {
  requestId?: string;
  scheduleInformation?: GetMeetingRoomsScheduleResponseBodyScheduleInformation[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'requestId',
      scheduleInformation: 'scheduleInformation',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      scheduleInformation: { 'type': 'array', 'itemType': GetMeetingRoomsScheduleResponseBodyScheduleInformation },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMeetingRoomsScheduleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetMeetingRoomsScheduleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetMeetingRoomsScheduleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMineWorkspaceHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: GetMineWorkspaceHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: GetMineWorkspaceHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMineWorkspaceShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMineWorkspaceRequest extends $tea.Model {
  request?: { [key: string]: any };
  tenantContext?: GetMineWorkspaceRequestTenantContext;
  static names(): { [key: string]: string } {
    return {
      request: 'Request',
      tenantContext: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      request: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      tenantContext: GetMineWorkspaceRequestTenantContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMineWorkspaceShrinkRequest extends $tea.Model {
  requestShrink?: string;
  tenantContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      requestShrink: 'Request',
      tenantContextShrink: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestShrink: 'string',
      tenantContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMineWorkspaceResponseBody extends $tea.Model {
  requestId?: string;
  workspace?: GetMineWorkspaceResponseBodyWorkspace;
  static names(): { [key: string]: string } {
    return {
      requestId: 'requestId',
      workspace: 'workspace',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      workspace: GetMineWorkspaceResponseBodyWorkspace,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMineWorkspaceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetMineWorkspaceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetMineWorkspaceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNewestInnerGroupsHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: GetNewestInnerGroupsHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: GetNewestInnerGroupsHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNewestInnerGroupsShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNewestInnerGroupsRequest extends $tea.Model {
  request?: { [key: string]: any };
  static names(): { [key: string]: string } {
    return {
      request: 'Request',
    };
  }

  static types(): { [key: string]: any } {
    return {
      request: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNewestInnerGroupsShrinkRequest extends $tea.Model {
  requestShrink?: string;
  static names(): { [key: string]: string } {
    return {
      requestShrink: 'Request',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNewestInnerGroupsResponseBody extends $tea.Model {
  groupInfos?: GetNewestInnerGroupsResponseBodyGroupInfos[];
  requestId?: string;
  vendorRequestId?: string;
  vendorType?: string;
  static names(): { [key: string]: string } {
    return {
      groupInfos: 'groupInfos',
      requestId: 'requestId',
      vendorRequestId: 'vendorRequestId',
      vendorType: 'vendorType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupInfos: { 'type': 'array', 'itemType': GetNewestInnerGroupsResponseBodyGroupInfos },
      requestId: 'string',
      vendorRequestId: 'string',
      vendorType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNewestInnerGroupsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetNewestInnerGroupsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetNewestInnerGroupsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNodeHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: GetNodeHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: GetNodeHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNodeShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNodeRequest extends $tea.Model {
  nodeId?: string;
  tenantContext?: GetNodeRequestTenantContext;
  withPermissionRole?: boolean;
  withStatisticalInfo?: boolean;
  static names(): { [key: string]: string } {
    return {
      nodeId: 'NodeId',
      tenantContext: 'TenantContext',
      withPermissionRole: 'WithPermissionRole',
      withStatisticalInfo: 'WithStatisticalInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodeId: 'string',
      tenantContext: GetNodeRequestTenantContext,
      withPermissionRole: 'boolean',
      withStatisticalInfo: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNodeShrinkRequest extends $tea.Model {
  nodeId?: string;
  tenantContextShrink?: string;
  withPermissionRole?: boolean;
  withStatisticalInfo?: boolean;
  static names(): { [key: string]: string } {
    return {
      nodeId: 'NodeId',
      tenantContextShrink: 'TenantContext',
      withPermissionRole: 'WithPermissionRole',
      withStatisticalInfo: 'WithStatisticalInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodeId: 'string',
      tenantContextShrink: 'string',
      withPermissionRole: 'boolean',
      withStatisticalInfo: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNodeResponseBody extends $tea.Model {
  node?: GetNodeResponseBodyNode;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      node: 'node',
      requestId: 'requestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      node: GetNodeResponseBodyNode,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNodeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetNodeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetNodeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNodeByUrlHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: GetNodeByUrlHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: GetNodeByUrlHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNodeByUrlShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNodeByUrlRequest extends $tea.Model {
  option?: GetNodeByUrlRequestOption;
  tenantContext?: GetNodeByUrlRequestTenantContext;
  url?: string;
  static names(): { [key: string]: string } {
    return {
      option: 'Option',
      tenantContext: 'TenantContext',
      url: 'Url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      option: GetNodeByUrlRequestOption,
      tenantContext: GetNodeByUrlRequestTenantContext,
      url: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNodeByUrlShrinkRequest extends $tea.Model {
  optionShrink?: string;
  tenantContextShrink?: string;
  url?: string;
  static names(): { [key: string]: string } {
    return {
      optionShrink: 'Option',
      tenantContextShrink: 'TenantContext',
      url: 'Url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      optionShrink: 'string',
      tenantContextShrink: 'string',
      url: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNodeByUrlResponseBody extends $tea.Model {
  node?: GetNodeByUrlResponseBodyNode;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      node: 'node',
      requestId: 'requestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      node: GetNodeByUrlResponseBodyNode,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNodeByUrlResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetNodeByUrlResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetNodeByUrlResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNodesHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: GetNodesHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: GetNodesHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNodesShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNodesRequest extends $tea.Model {
  nodeIds?: string[];
  option?: GetNodesRequestOption;
  tenantContext?: GetNodesRequestTenantContext;
  static names(): { [key: string]: string } {
    return {
      nodeIds: 'NodeIds',
      option: 'Option',
      tenantContext: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodeIds: { 'type': 'array', 'itemType': 'string' },
      option: GetNodesRequestOption,
      tenantContext: GetNodesRequestTenantContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNodesShrinkRequest extends $tea.Model {
  nodeIdsShrink?: string;
  optionShrink?: string;
  tenantContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      nodeIdsShrink: 'NodeIds',
      optionShrink: 'Option',
      tenantContextShrink: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodeIdsShrink: 'string',
      optionShrink: 'string',
      tenantContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNodesResponseBody extends $tea.Model {
  nodes?: GetNodesResponseBodyNodes[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      nodes: 'nodes',
      requestId: 'requestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodes: { 'type': 'array', 'itemType': GetNodesResponseBodyNodes },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNodesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetNodesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetNodesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNotifyMeHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: GetNotifyMeHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: GetNotifyMeHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNotifyMeShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNotifyMeRequest extends $tea.Model {
  appTypes?: string;
  corpId?: string;
  createFromTimeGMT?: number;
  createToTimeGMT?: number;
  instanceCreateFromTimeGMT?: number;
  instanceCreateToTimeGMT?: number;
  keyword?: string;
  language?: string;
  pageNumber?: number;
  pageSize?: number;
  processCodes?: string;
  token?: string;
  static names(): { [key: string]: string } {
    return {
      appTypes: 'AppTypes',
      corpId: 'CorpId',
      createFromTimeGMT: 'CreateFromTimeGMT',
      createToTimeGMT: 'CreateToTimeGMT',
      instanceCreateFromTimeGMT: 'InstanceCreateFromTimeGMT',
      instanceCreateToTimeGMT: 'InstanceCreateToTimeGMT',
      keyword: 'Keyword',
      language: 'Language',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      processCodes: 'ProcessCodes',
      token: 'Token',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appTypes: 'string',
      corpId: 'string',
      createFromTimeGMT: 'number',
      createToTimeGMT: 'number',
      instanceCreateFromTimeGMT: 'number',
      instanceCreateToTimeGMT: 'number',
      keyword: 'string',
      language: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      processCodes: 'string',
      token: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNotifyMeResponseBody extends $tea.Model {
  data?: GetNotifyMeResponseBodyData[];
  pageNumber?: number;
  requestId?: string;
  totalCount?: number;
  vendorRequestId?: string;
  vendorType?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'data',
      pageNumber: 'pageNumber',
      requestId: 'requestId',
      totalCount: 'totalCount',
      vendorRequestId: 'vendorRequestId',
      vendorType: 'vendorType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': GetNotifyMeResponseBodyData },
      pageNumber: 'number',
      requestId: 'string',
      totalCount: 'number',
      vendorRequestId: 'string',
      vendorType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNotifyMeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetNotifyMeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetNotifyMeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOpenUrlHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: GetOpenUrlHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: GetOpenUrlHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOpenUrlShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOpenUrlRequest extends $tea.Model {
  appType?: string;
  fileUrl?: string;
  language?: string;
  systemToken?: string;
  timeout?: number;
  static names(): { [key: string]: string } {
    return {
      appType: 'AppType',
      fileUrl: 'FileUrl',
      language: 'Language',
      systemToken: 'SystemToken',
      timeout: 'Timeout',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appType: 'string',
      fileUrl: 'string',
      language: 'string',
      systemToken: 'string',
      timeout: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOpenUrlResponseBody extends $tea.Model {
  requestId?: string;
  result?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'requestId',
      result: 'result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOpenUrlResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetOpenUrlResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetOpenUrlResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOperationRecordsHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: GetOperationRecordsHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: GetOperationRecordsHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOperationRecordsShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOperationRecordsRequest extends $tea.Model {
  appType?: string;
  language?: string;
  processInstanceId?: string;
  systemToken?: string;
  static names(): { [key: string]: string } {
    return {
      appType: 'AppType',
      language: 'Language',
      processInstanceId: 'ProcessInstanceId',
      systemToken: 'SystemToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appType: 'string',
      language: 'string',
      processInstanceId: 'string',
      systemToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOperationRecordsResponseBody extends $tea.Model {
  requestId?: string;
  result?: GetOperationRecordsResponseBodyResult[];
  vendorRequestId?: string;
  vendorType?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'requestId',
      result: 'result',
      vendorRequestId: 'vendorRequestId',
      vendorType: 'vendorType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: { 'type': 'array', 'itemType': GetOperationRecordsResponseBodyResult },
      vendorRequestId: 'string',
      vendorType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOperationRecordsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetOperationRecordsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetOperationRecordsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetProcessDefinitionHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: GetProcessDefinitionHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: GetProcessDefinitionHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetProcessDefinitionShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetProcessDefinitionRequest extends $tea.Model {
  appType?: string;
  corpId?: string;
  groupId?: string;
  language?: string;
  nameSpace?: string;
  orderNumber?: string;
  processInstanceId?: string;
  systemToken?: string;
  systemType?: string;
  static names(): { [key: string]: string } {
    return {
      appType: 'AppType',
      corpId: 'CorpId',
      groupId: 'GroupId',
      language: 'Language',
      nameSpace: 'NameSpace',
      orderNumber: 'OrderNumber',
      processInstanceId: 'ProcessInstanceId',
      systemToken: 'SystemToken',
      systemType: 'SystemType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appType: 'string',
      corpId: 'string',
      groupId: 'string',
      language: 'string',
      nameSpace: 'string',
      orderNumber: 'string',
      processInstanceId: 'string',
      systemToken: 'string',
      systemType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetProcessDefinitionResponseBody extends $tea.Model {
  formUuid?: string;
  originator?: GetProcessDefinitionResponseBodyOriginator;
  outResult?: string;
  owners?: GetProcessDefinitionResponseBodyOwners[];
  processId?: string;
  processInstanceId?: string;
  requestId?: string;
  status?: string;
  tasks?: GetProcessDefinitionResponseBodyTasks[];
  title?: string;
  variables?: { [key: string]: any };
  vendorRequestId?: string;
  vendorType?: string;
  static names(): { [key: string]: string } {
    return {
      formUuid: 'formUuid',
      originator: 'originator',
      outResult: 'outResult',
      owners: 'owners',
      processId: 'processId',
      processInstanceId: 'processInstanceId',
      requestId: 'requestId',
      status: 'status',
      tasks: 'tasks',
      title: 'title',
      variables: 'variables',
      vendorRequestId: 'vendorRequestId',
      vendorType: 'vendorType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      formUuid: 'string',
      originator: GetProcessDefinitionResponseBodyOriginator,
      outResult: 'string',
      owners: { 'type': 'array', 'itemType': GetProcessDefinitionResponseBodyOwners },
      processId: 'string',
      processInstanceId: 'string',
      requestId: 'string',
      status: 'string',
      tasks: { 'type': 'array', 'itemType': GetProcessDefinitionResponseBodyTasks },
      title: 'string',
      variables: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      vendorRequestId: 'string',
      vendorType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetProcessDefinitionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetProcessDefinitionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetProcessDefinitionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRangeHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: GetRangeHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: GetRangeHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRangeShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRangeRequest extends $tea.Model {
  rangeAddress?: string;
  select?: string;
  sheetId?: string;
  tenantContext?: GetRangeRequestTenantContext;
  workbookId?: string;
  static names(): { [key: string]: string } {
    return {
      rangeAddress: 'RangeAddress',
      select: 'Select',
      sheetId: 'SheetId',
      tenantContext: 'TenantContext',
      workbookId: 'WorkbookId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      rangeAddress: 'string',
      select: 'string',
      sheetId: 'string',
      tenantContext: GetRangeRequestTenantContext,
      workbookId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRangeShrinkRequest extends $tea.Model {
  rangeAddress?: string;
  select?: string;
  sheetId?: string;
  tenantContextShrink?: string;
  workbookId?: string;
  static names(): { [key: string]: string } {
    return {
      rangeAddress: 'RangeAddress',
      select: 'Select',
      sheetId: 'SheetId',
      tenantContextShrink: 'TenantContext',
      workbookId: 'WorkbookId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      rangeAddress: 'string',
      select: 'string',
      sheetId: 'string',
      tenantContextShrink: 'string',
      workbookId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRangeResponseBody extends $tea.Model {
  backgroundColors?: GetRangeResponseBodyBackgroundColors[][];
  displayValues?: string[][];
  formulas?: string[][];
  requestId?: string;
  values?: any[][];
  static names(): { [key: string]: string } {
    return {
      backgroundColors: 'backgroundColors',
      displayValues: 'displayValues',
      formulas: 'formulas',
      requestId: 'requestId',
      values: 'values',
    };
  }

  static types(): { [key: string]: any } {
    return {
      backgroundColors: { 'type': 'array', 'itemType': { 'type': 'array', 'itemType': GetRangeResponseBodyBackgroundColors } },
      displayValues: { 'type': 'array', 'itemType': { 'type': 'array', 'itemType': 'string' } },
      formulas: { 'type': 'array', 'itemType': { 'type': 'array', 'itemType': 'string' } },
      requestId: 'string',
      values: { 'type': 'array', 'itemType': { 'type': 'array', 'itemType': 'any' } },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRangeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetRangeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetRangeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRelatedWorkspacesHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: GetRelatedWorkspacesHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: GetRelatedWorkspacesHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRelatedWorkspacesShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRelatedWorkspacesRequest extends $tea.Model {
  includeRecent?: boolean;
  tenantContext?: GetRelatedWorkspacesRequestTenantContext;
  static names(): { [key: string]: string } {
    return {
      includeRecent: 'IncludeRecent',
      tenantContext: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      includeRecent: 'boolean',
      tenantContext: GetRelatedWorkspacesRequestTenantContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRelatedWorkspacesShrinkRequest extends $tea.Model {
  includeRecent?: boolean;
  tenantContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      includeRecent: 'IncludeRecent',
      tenantContextShrink: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      includeRecent: 'boolean',
      tenantContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRelatedWorkspacesResponseBody extends $tea.Model {
  requestId?: string;
  vendorRequestId?: string;
  vendorType?: string;
  workspaces?: GetRelatedWorkspacesResponseBodyWorkspaces[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'requestId',
      vendorRequestId: 'vendorRequestId',
      vendorType: 'vendorType',
      workspaces: 'workspaces',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      vendorRequestId: 'string',
      vendorType: 'string',
      workspaces: { 'type': 'array', 'itemType': GetRelatedWorkspacesResponseBodyWorkspaces },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRelatedWorkspacesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetRelatedWorkspacesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetRelatedWorkspacesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetReportTemplateByNameHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: GetReportTemplateByNameHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: GetReportTemplateByNameHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetReportTemplateByNameShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetReportTemplateByNameRequest extends $tea.Model {
  templateName?: string;
  tenantContext?: GetReportTemplateByNameRequestTenantContext;
  static names(): { [key: string]: string } {
    return {
      templateName: 'TemplateName',
      tenantContext: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      templateName: 'string',
      tenantContext: GetReportTemplateByNameRequestTenantContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetReportTemplateByNameShrinkRequest extends $tea.Model {
  templateName?: string;
  tenantContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      templateName: 'TemplateName',
      tenantContextShrink: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      templateName: 'string',
      tenantContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetReportTemplateByNameResponseBody extends $tea.Model {
  defaultReceivedConvs?: GetReportTemplateByNameResponseBodyDefaultReceivedConvs[];
  defaultReceivers?: GetReportTemplateByNameResponseBodyDefaultReceivers[];
  fields?: GetReportTemplateByNameResponseBodyFields[];
  id?: string;
  name?: string;
  requestId?: string;
  userName?: string;
  userid?: string;
  static names(): { [key: string]: string } {
    return {
      defaultReceivedConvs: 'defaultReceivedConvs',
      defaultReceivers: 'defaultReceivers',
      fields: 'fields',
      id: 'id',
      name: 'name',
      requestId: 'requestId',
      userName: 'userName',
      userid: 'userid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      defaultReceivedConvs: { 'type': 'array', 'itemType': GetReportTemplateByNameResponseBodyDefaultReceivedConvs },
      defaultReceivers: { 'type': 'array', 'itemType': GetReportTemplateByNameResponseBodyDefaultReceivers },
      fields: { 'type': 'array', 'itemType': GetReportTemplateByNameResponseBodyFields },
      id: 'string',
      name: 'string',
      requestId: 'string',
      userName: 'string',
      userid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetReportTemplateByNameResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetReportTemplateByNameResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetReportTemplateByNameResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetReportUnReadCountHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: GetReportUnReadCountHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: GetReportUnReadCountHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetReportUnReadCountShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetReportUnReadCountRequest extends $tea.Model {
  request?: { [key: string]: any };
  tenantContext?: GetReportUnReadCountRequestTenantContext;
  static names(): { [key: string]: string } {
    return {
      request: 'Request',
      tenantContext: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      request: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      tenantContext: GetReportUnReadCountRequestTenantContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetReportUnReadCountShrinkRequest extends $tea.Model {
  requestShrink?: string;
  tenantContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      requestShrink: 'Request',
      tenantContextShrink: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestShrink: 'string',
      tenantContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetReportUnReadCountResponseBody extends $tea.Model {
  count?: number;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      count: 'count',
      requestId: 'requestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetReportUnReadCountResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetReportUnReadCountResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetReportUnReadCountResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRunningTasksHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: GetRunningTasksHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: GetRunningTasksHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRunningTasksShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRunningTasksRequest extends $tea.Model {
  appType?: string;
  language?: string;
  processCodes?: string;
  processInstanceId?: string;
  systemToken?: string;
  static names(): { [key: string]: string } {
    return {
      appType: 'AppType',
      language: 'Language',
      processCodes: 'ProcessCodes',
      processInstanceId: 'ProcessInstanceId',
      systemToken: 'SystemToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appType: 'string',
      language: 'string',
      processCodes: 'string',
      processInstanceId: 'string',
      systemToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRunningTasksResponseBody extends $tea.Model {
  requestId?: string;
  result?: GetRunningTasksResponseBodyResult[];
  vendorRequestId?: string;
  vendorType?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'requestId',
      result: 'result',
      vendorRequestId: 'vendorRequestId',
      vendorType: 'vendorType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: { 'type': 'array', 'itemType': GetRunningTasksResponseBodyResult },
      vendorRequestId: 'string',
      vendorType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRunningTasksResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetRunningTasksResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetRunningTasksResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSheetHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: GetSheetHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: GetSheetHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSheetShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSheetRequest extends $tea.Model {
  sheetId?: string;
  tenantContext?: GetSheetRequestTenantContext;
  workbookId?: string;
  static names(): { [key: string]: string } {
    return {
      sheetId: 'SheetId',
      tenantContext: 'TenantContext',
      workbookId: 'WorkbookId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      sheetId: 'string',
      tenantContext: GetSheetRequestTenantContext,
      workbookId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSheetShrinkRequest extends $tea.Model {
  sheetId?: string;
  tenantContextShrink?: string;
  workbookId?: string;
  static names(): { [key: string]: string } {
    return {
      sheetId: 'SheetId',
      tenantContextShrink: 'TenantContext',
      workbookId: 'WorkbookId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      sheetId: 'string',
      tenantContextShrink: 'string',
      workbookId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSheetResponseBody extends $tea.Model {
  columnCount?: number;
  id?: string;
  lastNonEmptyColumn?: number;
  lastNonEmptyRow?: number;
  name?: string;
  requestId?: string;
  rowCount?: number;
  visibility?: string;
  static names(): { [key: string]: string } {
    return {
      columnCount: 'columnCount',
      id: 'id',
      lastNonEmptyColumn: 'lastNonEmptyColumn',
      lastNonEmptyRow: 'lastNonEmptyRow',
      name: 'name',
      requestId: 'requestId',
      rowCount: 'rowCount',
      visibility: 'visibility',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnCount: 'number',
      id: 'string',
      lastNonEmptyColumn: 'number',
      lastNonEmptyRow: 'number',
      name: 'string',
      requestId: 'string',
      rowCount: 'number',
      visibility: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSheetResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetSheetResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetSheetResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSpaceDirectoriesHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: GetSpaceDirectoriesHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: GetSpaceDirectoriesHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSpaceDirectoriesShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSpaceDirectoriesRequest extends $tea.Model {
  dentryId?: string;
  maxResults?: number;
  nextToken?: string;
  spaceId?: string;
  tenantContext?: GetSpaceDirectoriesRequestTenantContext;
  static names(): { [key: string]: string } {
    return {
      dentryId: 'DentryId',
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      spaceId: 'SpaceId',
      tenantContext: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dentryId: 'string',
      maxResults: 'number',
      nextToken: 'string',
      spaceId: 'string',
      tenantContext: GetSpaceDirectoriesRequestTenantContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSpaceDirectoriesShrinkRequest extends $tea.Model {
  dentryId?: string;
  maxResults?: number;
  nextToken?: string;
  spaceId?: string;
  tenantContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      dentryId: 'DentryId',
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      spaceId: 'SpaceId',
      tenantContextShrink: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dentryId: 'string',
      maxResults: 'number',
      nextToken: 'string',
      spaceId: 'string',
      tenantContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSpaceDirectoriesResponseBody extends $tea.Model {
  children?: GetSpaceDirectoriesResponseBodyChildren[];
  hasMore?: boolean;
  nextToken?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      children: 'children',
      hasMore: 'hasMore',
      nextToken: 'nextToken',
      requestId: 'requestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      children: { 'type': 'array', 'itemType': GetSpaceDirectoriesResponseBodyChildren },
      hasMore: 'boolean',
      nextToken: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSpaceDirectoriesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetSpaceDirectoriesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetSpaceDirectoriesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSubscribedCalendarHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: GetSubscribedCalendarHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: GetSubscribedCalendarHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSubscribedCalendarShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSubscribedCalendarRequest extends $tea.Model {
  calendarId?: string;
  static names(): { [key: string]: string } {
    return {
      calendarId: 'CalendarId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      calendarId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSubscribedCalendarResponseBody extends $tea.Model {
  author?: string;
  calendarId?: string;
  description?: string;
  managers?: string[];
  name?: string;
  requestId?: string;
  subscribeScope?: GetSubscribedCalendarResponseBodySubscribeScope;
  static names(): { [key: string]: string } {
    return {
      author: 'author',
      calendarId: 'calendarId',
      description: 'description',
      managers: 'managers',
      name: 'name',
      requestId: 'requestId',
      subscribeScope: 'subscribeScope',
    };
  }

  static types(): { [key: string]: any } {
    return {
      author: 'string',
      calendarId: 'string',
      description: 'string',
      managers: { 'type': 'array', 'itemType': 'string' },
      name: 'string',
      requestId: 'string',
      subscribeScope: GetSubscribedCalendarResponseBodySubscribeScope,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSubscribedCalendarResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetSubscribedCalendarResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetSubscribedCalendarResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTaskCopiesHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: GetTaskCopiesHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: GetTaskCopiesHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTaskCopiesShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTaskCopiesRequest extends $tea.Model {
  appType?: string;
  createFromTimeGMT?: number;
  createToTimeGMT?: number;
  keyword?: string;
  language?: string;
  pageNumber?: number;
  pageSize?: number;
  processCodes?: string;
  systemToken?: string;
  static names(): { [key: string]: string } {
    return {
      appType: 'AppType',
      createFromTimeGMT: 'CreateFromTimeGMT',
      createToTimeGMT: 'CreateToTimeGMT',
      keyword: 'Keyword',
      language: 'Language',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      processCodes: 'ProcessCodes',
      systemToken: 'SystemToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appType: 'string',
      createFromTimeGMT: 'number',
      createToTimeGMT: 'number',
      keyword: 'string',
      language: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      processCodes: 'string',
      systemToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTaskCopiesResponseBody extends $tea.Model {
  data?: GetTaskCopiesResponseBodyData[];
  pageNumber?: number;
  requestId?: string;
  totalCount?: number;
  vendorRequestId?: string;
  vendorType?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'data',
      pageNumber: 'pageNumber',
      requestId: 'requestId',
      totalCount: 'totalCount',
      vendorRequestId: 'vendorRequestId',
      vendorType: 'vendorType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': GetTaskCopiesResponseBodyData },
      pageNumber: 'number',
      requestId: 'string',
      totalCount: 'number',
      vendorRequestId: 'string',
      vendorType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTaskCopiesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetTaskCopiesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetTaskCopiesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTemplateListByUserIdHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: GetTemplateListByUserIdHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: GetTemplateListByUserIdHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTemplateListByUserIdShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTemplateListByUserIdRequest extends $tea.Model {
  offset?: number;
  size?: number;
  tenantContext?: GetTemplateListByUserIdRequestTenantContext;
  static names(): { [key: string]: string } {
    return {
      offset: 'Offset',
      size: 'Size',
      tenantContext: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      offset: 'number',
      size: 'number',
      tenantContext: GetTemplateListByUserIdRequestTenantContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTemplateListByUserIdShrinkRequest extends $tea.Model {
  offset?: number;
  size?: number;
  tenantContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      offset: 'Offset',
      size: 'Size',
      tenantContextShrink: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      offset: 'number',
      size: 'number',
      tenantContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTemplateListByUserIdResponseBody extends $tea.Model {
  nextCursor?: number;
  requestId?: string;
  templateList?: GetTemplateListByUserIdResponseBodyTemplateList[];
  static names(): { [key: string]: string } {
    return {
      nextCursor: 'nextCursor',
      requestId: 'requestId',
      templateList: 'templateList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nextCursor: 'number',
      requestId: 'string',
      templateList: { 'type': 'array', 'itemType': GetTemplateListByUserIdResponseBodyTemplateList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTemplateListByUserIdResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetTemplateListByUserIdResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetTemplateListByUserIdResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: GetUserHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: GetUserHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserRequest extends $tea.Model {
  tenantContext?: GetUserRequestTenantContext;
  language?: string;
  static names(): { [key: string]: string } {
    return {
      tenantContext: 'TenantContext',
      language: 'language',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantContext: GetUserRequestTenantContext,
      language: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserShrinkRequest extends $tea.Model {
  tenantContextShrink?: string;
  language?: string;
  static names(): { [key: string]: string } {
    return {
      tenantContextShrink: 'TenantContext',
      language: 'language',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantContextShrink: 'string',
      language: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserResponseBody extends $tea.Model {
  active?: boolean;
  admin?: boolean;
  avatar?: string;
  boss?: boolean;
  deptIdList?: number[];
  deptOrderList?: GetUserResponseBodyDeptOrderList[];
  email?: string;
  exclusiveAccount?: boolean;
  exclusiveAccountCorpId?: string;
  exclusiveAccountCorpName?: string;
  exclusiveAccountType?: string;
  extension?: string;
  hideMobile?: boolean;
  hiredDate?: number;
  jobNumber?: string;
  leaderInDept?: GetUserResponseBodyLeaderInDept[];
  loginId?: string;
  managerUserid?: string;
  mobile?: string;
  name?: string;
  nickname?: string;
  orgEmail?: string;
  realAuthed?: boolean;
  remark?: string;
  requestId?: string;
  roleList?: GetUserResponseBodyRoleList[];
  senior?: boolean;
  stateCode?: string;
  telephone?: string;
  title?: string;
  unionEmpExt?: GetUserResponseBodyUnionEmpExt;
  userid?: string;
  workPlace?: string;
  static names(): { [key: string]: string } {
    return {
      active: 'active',
      admin: 'admin',
      avatar: 'avatar',
      boss: 'boss',
      deptIdList: 'deptIdList',
      deptOrderList: 'deptOrderList',
      email: 'email',
      exclusiveAccount: 'exclusiveAccount',
      exclusiveAccountCorpId: 'exclusiveAccountCorpId',
      exclusiveAccountCorpName: 'exclusiveAccountCorpName',
      exclusiveAccountType: 'exclusiveAccountType',
      extension: 'extension',
      hideMobile: 'hideMobile',
      hiredDate: 'hiredDate',
      jobNumber: 'jobNumber',
      leaderInDept: 'leaderInDept',
      loginId: 'loginId',
      managerUserid: 'managerUserid',
      mobile: 'mobile',
      name: 'name',
      nickname: 'nickname',
      orgEmail: 'orgEmail',
      realAuthed: 'realAuthed',
      remark: 'remark',
      requestId: 'requestId',
      roleList: 'roleList',
      senior: 'senior',
      stateCode: 'stateCode',
      telephone: 'telephone',
      title: 'title',
      unionEmpExt: 'unionEmpExt',
      userid: 'userid',
      workPlace: 'workPlace',
    };
  }

  static types(): { [key: string]: any } {
    return {
      active: 'boolean',
      admin: 'boolean',
      avatar: 'string',
      boss: 'boolean',
      deptIdList: { 'type': 'array', 'itemType': 'number' },
      deptOrderList: { 'type': 'array', 'itemType': GetUserResponseBodyDeptOrderList },
      email: 'string',
      exclusiveAccount: 'boolean',
      exclusiveAccountCorpId: 'string',
      exclusiveAccountCorpName: 'string',
      exclusiveAccountType: 'string',
      extension: 'string',
      hideMobile: 'boolean',
      hiredDate: 'number',
      jobNumber: 'string',
      leaderInDept: { 'type': 'array', 'itemType': GetUserResponseBodyLeaderInDept },
      loginId: 'string',
      managerUserid: 'string',
      mobile: 'string',
      name: 'string',
      nickname: 'string',
      orgEmail: 'string',
      realAuthed: 'boolean',
      remark: 'string',
      requestId: 'string',
      roleList: { 'type': 'array', 'itemType': GetUserResponseBodyRoleList },
      senior: 'boolean',
      stateCode: 'string',
      telephone: 'string',
      title: 'string',
      unionEmpExt: GetUserResponseBodyUnionEmpExt,
      userid: 'string',
      workPlace: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetUserResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetUserResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserLatestPlanHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: GetUserLatestPlanHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: GetUserLatestPlanHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserLatestPlanShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserLatestPlanRequest extends $tea.Model {
  tenantContext?: GetUserLatestPlanRequestTenantContext;
  static names(): { [key: string]: string } {
    return {
      tenantContext: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantContext: GetUserLatestPlanRequestTenantContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserLatestPlanShrinkRequest extends $tea.Model {
  tenantContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      tenantContextShrink: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserLatestPlanResponseBody extends $tea.Model {
  accountHandleStatus?: number;
  accountHandleTime?: string;
  accountType?: number;
  agreementFirstSignTime?: string;
  agreementLastSignTime?: string;
  agreementStatus?: number;
  dataHandleEndTime?: string;
  dataHandleStartTime?: string;
  dataHandleStatus?: number;
  exclusivePlan?: number;
  newAccountUid?: number;
  requestId?: string;
  status?: number;
  vendorRequestId?: string;
  vendorType?: string;
  static names(): { [key: string]: string } {
    return {
      accountHandleStatus: 'accountHandleStatus',
      accountHandleTime: 'accountHandleTime',
      accountType: 'accountType',
      agreementFirstSignTime: 'agreementFirstSignTime',
      agreementLastSignTime: 'agreementLastSignTime',
      agreementStatus: 'agreementStatus',
      dataHandleEndTime: 'dataHandleEndTime',
      dataHandleStartTime: 'dataHandleStartTime',
      dataHandleStatus: 'dataHandleStatus',
      exclusivePlan: 'exclusivePlan',
      newAccountUid: 'newAccountUid',
      requestId: 'requestId',
      status: 'status',
      vendorRequestId: 'vendorRequestId',
      vendorType: 'vendorType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountHandleStatus: 'number',
      accountHandleTime: 'string',
      accountType: 'number',
      agreementFirstSignTime: 'string',
      agreementLastSignTime: 'string',
      agreementStatus: 'number',
      dataHandleEndTime: 'string',
      dataHandleStartTime: 'string',
      dataHandleStatus: 'number',
      exclusivePlan: 'number',
      newAccountUid: 'number',
      requestId: 'string',
      status: 'number',
      vendorRequestId: 'string',
      vendorType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserLatestPlanResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetUserLatestPlanResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetUserLatestPlanResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkspaceHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: GetWorkspaceHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: GetWorkspaceHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkspaceShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkspaceRequest extends $tea.Model {
  tenantContext?: GetWorkspaceRequestTenantContext;
  withPermissionRole?: boolean;
  workspaceId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantContext: 'TenantContext',
      withPermissionRole: 'WithPermissionRole',
      workspaceId: 'WorkspaceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantContext: GetWorkspaceRequestTenantContext,
      withPermissionRole: 'boolean',
      workspaceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkspaceShrinkRequest extends $tea.Model {
  tenantContextShrink?: string;
  withPermissionRole?: boolean;
  workspaceId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantContextShrink: 'TenantContext',
      withPermissionRole: 'WithPermissionRole',
      workspaceId: 'WorkspaceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantContextShrink: 'string',
      withPermissionRole: 'boolean',
      workspaceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkspaceResponseBody extends $tea.Model {
  requestId?: string;
  workspace?: GetWorkspaceResponseBodyWorkspace;
  static names(): { [key: string]: string } {
    return {
      requestId: 'requestId',
      workspace: 'workspace',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      workspace: GetWorkspaceResponseBodyWorkspace,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkspaceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetWorkspaceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetWorkspaceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkspacesHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: GetWorkspacesHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: GetWorkspacesHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkspacesShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkspacesRequest extends $tea.Model {
  option?: GetWorkspacesRequestOption;
  tenantContext?: GetWorkspacesRequestTenantContext;
  workspaceIds?: string[];
  static names(): { [key: string]: string } {
    return {
      option: 'Option',
      tenantContext: 'TenantContext',
      workspaceIds: 'WorkspaceIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      option: GetWorkspacesRequestOption,
      tenantContext: GetWorkspacesRequestTenantContext,
      workspaceIds: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkspacesShrinkRequest extends $tea.Model {
  optionShrink?: string;
  tenantContextShrink?: string;
  workspaceIdsShrink?: string;
  static names(): { [key: string]: string } {
    return {
      optionShrink: 'Option',
      tenantContextShrink: 'TenantContext',
      workspaceIdsShrink: 'WorkspaceIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      optionShrink: 'string',
      tenantContextShrink: 'string',
      workspaceIdsShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkspacesResponseBody extends $tea.Model {
  requestId?: string;
  workspace?: GetWorkspacesResponseBodyWorkspace[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'requestId',
      workspace: 'workspace',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      workspace: { 'type': 'array', 'itemType': GetWorkspacesResponseBodyWorkspace },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkspacesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetWorkspacesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetWorkspacesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GrantHonorHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: GrantHonorHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: GrantHonorHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GrantHonorShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GrantHonorRequest extends $tea.Model {
  tenantContext?: GrantHonorRequestTenantContext;
  expirationTime?: number;
  grantReason?: string;
  granterName?: string;
  honorId?: string;
  noticeAnnouncer?: boolean;
  noticeSingle?: boolean;
  openConversationIds?: string[];
  orgId?: number;
  receiverUserIds?: string[];
  senderUserId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantContext: 'TenantContext',
      expirationTime: 'expirationTime',
      grantReason: 'grantReason',
      granterName: 'granterName',
      honorId: 'honorId',
      noticeAnnouncer: 'noticeAnnouncer',
      noticeSingle: 'noticeSingle',
      openConversationIds: 'openConversationIds',
      orgId: 'orgId',
      receiverUserIds: 'receiverUserIds',
      senderUserId: 'senderUserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantContext: GrantHonorRequestTenantContext,
      expirationTime: 'number',
      grantReason: 'string',
      granterName: 'string',
      honorId: 'string',
      noticeAnnouncer: 'boolean',
      noticeSingle: 'boolean',
      openConversationIds: { 'type': 'array', 'itemType': 'string' },
      orgId: 'number',
      receiverUserIds: { 'type': 'array', 'itemType': 'string' },
      senderUserId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GrantHonorShrinkRequest extends $tea.Model {
  tenantContextShrink?: string;
  expirationTime?: number;
  grantReason?: string;
  granterName?: string;
  honorId?: string;
  noticeAnnouncer?: boolean;
  noticeSingle?: boolean;
  openConversationIdsShrink?: string;
  orgId?: number;
  receiverUserIdsShrink?: string;
  senderUserId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantContextShrink: 'TenantContext',
      expirationTime: 'expirationTime',
      grantReason: 'grantReason',
      granterName: 'granterName',
      honorId: 'honorId',
      noticeAnnouncer: 'noticeAnnouncer',
      noticeSingle: 'noticeSingle',
      openConversationIdsShrink: 'openConversationIds',
      orgId: 'orgId',
      receiverUserIdsShrink: 'receiverUserIds',
      senderUserId: 'senderUserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantContextShrink: 'string',
      expirationTime: 'number',
      grantReason: 'string',
      granterName: 'string',
      honorId: 'string',
      noticeAnnouncer: 'boolean',
      noticeSingle: 'boolean',
      openConversationIdsShrink: 'string',
      orgId: 'number',
      receiverUserIdsShrink: 'string',
      senderUserId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GrantHonorResponseBody extends $tea.Model {
  failedUserIds?: string[];
  requestId?: string;
  successUserIds?: string[];
  static names(): { [key: string]: string } {
    return {
      failedUserIds: 'failedUserIds',
      requestId: 'requestId',
      successUserIds: 'successUserIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failedUserIds: { 'type': 'array', 'itemType': 'string' },
      requestId: 'string',
      successUserIds: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GrantHonorResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GrantHonorResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GrantHonorResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InsertColumnsBeforeHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: InsertColumnsBeforeHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: InsertColumnsBeforeHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InsertColumnsBeforeShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InsertColumnsBeforeRequest extends $tea.Model {
  column?: number;
  columnCount?: number;
  sheetId?: string;
  tenantContext?: InsertColumnsBeforeRequestTenantContext;
  workbookId?: string;
  static names(): { [key: string]: string } {
    return {
      column: 'Column',
      columnCount: 'ColumnCount',
      sheetId: 'SheetId',
      tenantContext: 'TenantContext',
      workbookId: 'WorkbookId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      column: 'number',
      columnCount: 'number',
      sheetId: 'string',
      tenantContext: InsertColumnsBeforeRequestTenantContext,
      workbookId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InsertColumnsBeforeShrinkRequest extends $tea.Model {
  column?: number;
  columnCount?: number;
  sheetId?: string;
  tenantContextShrink?: string;
  workbookId?: string;
  static names(): { [key: string]: string } {
    return {
      column: 'Column',
      columnCount: 'ColumnCount',
      sheetId: 'SheetId',
      tenantContextShrink: 'TenantContext',
      workbookId: 'WorkbookId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      column: 'number',
      columnCount: 'number',
      sheetId: 'string',
      tenantContextShrink: 'string',
      workbookId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InsertColumnsBeforeResponseBody extends $tea.Model {
  id?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'id',
      requestId: 'requestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InsertColumnsBeforeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: InsertColumnsBeforeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: InsertColumnsBeforeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InsertRowsBeforeHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: InsertRowsBeforeHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: InsertRowsBeforeHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InsertRowsBeforeShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InsertRowsBeforeRequest extends $tea.Model {
  row?: number;
  rowCount?: number;
  sheetId?: string;
  tenantContext?: InsertRowsBeforeRequestTenantContext;
  workbookId?: string;
  static names(): { [key: string]: string } {
    return {
      row: 'Row',
      rowCount: 'RowCount',
      sheetId: 'SheetId',
      tenantContext: 'TenantContext',
      workbookId: 'WorkbookId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      row: 'number',
      rowCount: 'number',
      sheetId: 'string',
      tenantContext: InsertRowsBeforeRequestTenantContext,
      workbookId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InsertRowsBeforeShrinkRequest extends $tea.Model {
  row?: number;
  rowCount?: number;
  sheetId?: string;
  tenantContextShrink?: string;
  workbookId?: string;
  static names(): { [key: string]: string } {
    return {
      row: 'Row',
      rowCount: 'RowCount',
      sheetId: 'SheetId',
      tenantContextShrink: 'TenantContext',
      workbookId: 'WorkbookId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      row: 'number',
      rowCount: 'number',
      sheetId: 'string',
      tenantContextShrink: 'string',
      workbookId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InsertRowsBeforeResponseBody extends $tea.Model {
  id?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'id',
      requestId: 'requestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InsertRowsBeforeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: InsertRowsBeforeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: InsertRowsBeforeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InviteUsersHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: InviteUsersHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: InviteUsersHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InviteUsersShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InviteUsersRequest extends $tea.Model {
  inviteeList?: InviteUsersRequestInviteeList[];
  tenantContext?: InviteUsersRequestTenantContext;
  conferenceId?: string;
  phoneInviteeList?: InviteUsersRequestPhoneInviteeList[];
  static names(): { [key: string]: string } {
    return {
      inviteeList: 'InviteeList',
      tenantContext: 'TenantContext',
      conferenceId: 'conferenceId',
      phoneInviteeList: 'phoneInviteeList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      inviteeList: { 'type': 'array', 'itemType': InviteUsersRequestInviteeList },
      tenantContext: InviteUsersRequestTenantContext,
      conferenceId: 'string',
      phoneInviteeList: { 'type': 'array', 'itemType': InviteUsersRequestPhoneInviteeList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InviteUsersShrinkRequest extends $tea.Model {
  inviteeListShrink?: string;
  tenantContextShrink?: string;
  conferenceId?: string;
  phoneInviteeListShrink?: string;
  static names(): { [key: string]: string } {
    return {
      inviteeListShrink: 'InviteeList',
      tenantContextShrink: 'TenantContext',
      conferenceId: 'conferenceId',
      phoneInviteeListShrink: 'phoneInviteeList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      inviteeListShrink: 'string',
      tenantContextShrink: 'string',
      conferenceId: 'string',
      phoneInviteeListShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InviteUsersResponseBody extends $tea.Model {
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InviteUsersResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: InviteUsersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: InviteUsersResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListApplicationHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: ListApplicationHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: ListApplicationHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListApplicationShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListApplicationRequest extends $tea.Model {
  appFilter?: string;
  appNameSearchKeyword?: string;
  corpId?: string;
  pageNumber?: number;
  pageSize?: number;
  token?: string;
  static names(): { [key: string]: string } {
    return {
      appFilter: 'AppFilter',
      appNameSearchKeyword: 'AppNameSearchKeyword',
      corpId: 'CorpId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      token: 'Token',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appFilter: 'string',
      appNameSearchKeyword: 'string',
      corpId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      token: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListApplicationResponseBody extends $tea.Model {
  data?: ListApplicationResponseBodyData[];
  pageNumber?: number;
  requestId?: string;
  totalCount?: number;
  vendorRequestId?: string;
  vendorType?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'data',
      pageNumber: 'pageNumber',
      requestId: 'requestId',
      totalCount: 'totalCount',
      vendorRequestId: 'vendorRequestId',
      vendorType: 'vendorType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': ListApplicationResponseBodyData },
      pageNumber: 'number',
      requestId: 'string',
      totalCount: 'number',
      vendorRequestId: 'string',
      vendorType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListApplicationResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListApplicationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListApplicationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCalendarsHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: ListCalendarsHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: ListCalendarsHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCalendarsShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCalendarsRequest extends $tea.Model {
  request?: { [key: string]: any };
  static names(): { [key: string]: string } {
    return {
      request: 'Request',
    };
  }

  static types(): { [key: string]: any } {
    return {
      request: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCalendarsShrinkRequest extends $tea.Model {
  requestShrink?: string;
  static names(): { [key: string]: string } {
    return {
      requestShrink: 'Request',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCalendarsResponseBody extends $tea.Model {
  requestId?: string;
  response?: ListCalendarsResponseBodyResponse;
  static names(): { [key: string]: string } {
    return {
      requestId: 'requestId',
      response: 'response',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      response: ListCalendarsResponseBodyResponse,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCalendarsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListCalendarsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListCalendarsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDentriesHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: ListDentriesHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: ListDentriesHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDentriesShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDentriesRequest extends $tea.Model {
  maxResults?: number;
  nextToken?: string;
  order?: string;
  orderBy?: string;
  parentId?: string;
  spaceId?: string;
  tenantContext?: ListDentriesRequestTenantContext;
  withThumbnail?: boolean;
  static names(): { [key: string]: string } {
    return {
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      order: 'Order',
      orderBy: 'OrderBy',
      parentId: 'ParentId',
      spaceId: 'SpaceId',
      tenantContext: 'TenantContext',
      withThumbnail: 'WithThumbnail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxResults: 'number',
      nextToken: 'string',
      order: 'string',
      orderBy: 'string',
      parentId: 'string',
      spaceId: 'string',
      tenantContext: ListDentriesRequestTenantContext,
      withThumbnail: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDentriesShrinkRequest extends $tea.Model {
  maxResults?: number;
  nextToken?: string;
  order?: string;
  orderBy?: string;
  parentId?: string;
  spaceId?: string;
  tenantContextShrink?: string;
  withThumbnail?: boolean;
  static names(): { [key: string]: string } {
    return {
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      order: 'Order',
      orderBy: 'OrderBy',
      parentId: 'ParentId',
      spaceId: 'SpaceId',
      tenantContextShrink: 'TenantContext',
      withThumbnail: 'WithThumbnail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxResults: 'number',
      nextToken: 'string',
      order: 'string',
      orderBy: 'string',
      parentId: 'string',
      spaceId: 'string',
      tenantContextShrink: 'string',
      withThumbnail: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDentriesResponseBody extends $tea.Model {
  dentries?: ListDentriesResponseBodyDentries[];
  nextToken?: string;
  requestId?: string;
  vendorRequestId?: string;
  vendorType?: string;
  static names(): { [key: string]: string } {
    return {
      dentries: 'dentries',
      nextToken: 'nextToken',
      requestId: 'requestId',
      vendorRequestId: 'vendorRequestId',
      vendorType: 'vendorType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dentries: { 'type': 'array', 'itemType': ListDentriesResponseBodyDentries },
      nextToken: 'string',
      requestId: 'string',
      vendorRequestId: 'string',
      vendorType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDentriesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListDentriesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListDentriesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEventsHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: ListEventsHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: ListEventsHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEventsShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEventsRequest extends $tea.Model {
  calendarId?: string;
  maxAttendees?: number;
  maxResults?: number;
  nextToken?: string;
  seriesMasterId?: string;
  showDeleted?: boolean;
  syncToken?: string;
  timeMax?: string;
  timeMin?: string;
  static names(): { [key: string]: string } {
    return {
      calendarId: 'CalendarId',
      maxAttendees: 'MaxAttendees',
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      seriesMasterId: 'SeriesMasterId',
      showDeleted: 'ShowDeleted',
      syncToken: 'SyncToken',
      timeMax: 'TimeMax',
      timeMin: 'TimeMin',
    };
  }

  static types(): { [key: string]: any } {
    return {
      calendarId: 'string',
      maxAttendees: 'number',
      maxResults: 'number',
      nextToken: 'string',
      seriesMasterId: 'string',
      showDeleted: 'boolean',
      syncToken: 'string',
      timeMax: 'string',
      timeMin: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEventsResponseBody extends $tea.Model {
  events?: ListEventsResponseBodyEvents[];
  nextToken?: string;
  requestId?: string;
  syncToken?: string;
  vendorRequestId?: string;
  vendorType?: string;
  static names(): { [key: string]: string } {
    return {
      events: 'events',
      nextToken: 'nextToken',
      requestId: 'requestId',
      syncToken: 'syncToken',
      vendorRequestId: 'vendorRequestId',
      vendorType: 'vendorType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      events: { 'type': 'array', 'itemType': ListEventsResponseBodyEvents },
      nextToken: 'string',
      requestId: 'string',
      syncToken: 'string',
      vendorRequestId: 'string',
      vendorType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEventsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListEventsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListEventsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEventsViewHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: ListEventsViewHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: ListEventsViewHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEventsViewShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEventsViewRequest extends $tea.Model {
  calendarId?: string;
  maxAttendees?: number;
  maxResults?: number;
  nextToken?: string;
  timeMax?: string;
  timeMin?: string;
  static names(): { [key: string]: string } {
    return {
      calendarId: 'CalendarId',
      maxAttendees: 'MaxAttendees',
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      timeMax: 'TimeMax',
      timeMin: 'TimeMin',
    };
  }

  static types(): { [key: string]: any } {
    return {
      calendarId: 'string',
      maxAttendees: 'number',
      maxResults: 'number',
      nextToken: 'string',
      timeMax: 'string',
      timeMin: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEventsViewResponseBody extends $tea.Model {
  events?: ListEventsViewResponseBodyEvents[];
  nextToken?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      events: 'events',
      nextToken: 'nextToken',
      requestId: 'requestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      events: { 'type': 'array', 'itemType': ListEventsViewResponseBodyEvents },
      nextToken: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEventsViewResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListEventsViewResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListEventsViewResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFormRemarksHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: ListFormRemarksHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: ListFormRemarksHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFormRemarksShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFormRemarksRequest extends $tea.Model {
  appType?: string;
  formInstanceIdList?: string[];
  formUuid?: string;
  systemToken?: string;
  static names(): { [key: string]: string } {
    return {
      appType: 'AppType',
      formInstanceIdList: 'FormInstanceIdList',
      formUuid: 'FormUuid',
      systemToken: 'SystemToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appType: 'string',
      formInstanceIdList: { 'type': 'array', 'itemType': 'string' },
      formUuid: 'string',
      systemToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFormRemarksShrinkRequest extends $tea.Model {
  appType?: string;
  formInstanceIdListShrink?: string;
  formUuid?: string;
  systemToken?: string;
  static names(): { [key: string]: string } {
    return {
      appType: 'AppType',
      formInstanceIdListShrink: 'FormInstanceIdList',
      formUuid: 'FormUuid',
      systemToken: 'SystemToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appType: 'string',
      formInstanceIdListShrink: 'string',
      formUuid: 'string',
      systemToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFormRemarksResponseBody extends $tea.Model {
  formRemarkVoMap?: { [key: string]: any };
  requestId?: string;
  vendorRequestId?: string;
  vendorType?: string;
  static names(): { [key: string]: string } {
    return {
      formRemarkVoMap: 'formRemarkVoMap',
      requestId: 'requestId',
      vendorRequestId: 'vendorRequestId',
      vendorType: 'vendorType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      formRemarkVoMap: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      requestId: 'string',
      vendorRequestId: 'string',
      vendorType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFormRemarksResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListFormRemarksResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListFormRemarksResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListNavigationByFormTypeHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: ListNavigationByFormTypeHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: ListNavigationByFormTypeHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListNavigationByFormTypeShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListNavigationByFormTypeRequest extends $tea.Model {
  appType?: string;
  formType?: string;
  language?: string;
  systemToken?: string;
  static names(): { [key: string]: string } {
    return {
      appType: 'AppType',
      formType: 'FormType',
      language: 'Language',
      systemToken: 'SystemToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appType: 'string',
      formType: 'string',
      language: 'string',
      systemToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListNavigationByFormTypeResponseBody extends $tea.Model {
  requestId?: string;
  result?: ListNavigationByFormTypeResponseBodyResult[];
  vendorRequestId?: string;
  vendorType?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'requestId',
      result: 'result',
      vendorRequestId: 'vendorRequestId',
      vendorType: 'vendorType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: { 'type': 'array', 'itemType': ListNavigationByFormTypeResponseBodyResult },
      vendorRequestId: 'string',
      vendorType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListNavigationByFormTypeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListNavigationByFormTypeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListNavigationByFormTypeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListNodesHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: ListNodesHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: ListNodesHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListNodesShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListNodesRequest extends $tea.Model {
  maxResults?: number;
  nextToken?: string;
  parentNodeId?: string;
  tenantContext?: ListNodesRequestTenantContext;
  withPermissionRole?: boolean;
  static names(): { [key: string]: string } {
    return {
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      parentNodeId: 'ParentNodeId',
      tenantContext: 'TenantContext',
      withPermissionRole: 'WithPermissionRole',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxResults: 'number',
      nextToken: 'string',
      parentNodeId: 'string',
      tenantContext: ListNodesRequestTenantContext,
      withPermissionRole: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListNodesShrinkRequest extends $tea.Model {
  maxResults?: number;
  nextToken?: string;
  parentNodeId?: string;
  tenantContextShrink?: string;
  withPermissionRole?: boolean;
  static names(): { [key: string]: string } {
    return {
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      parentNodeId: 'ParentNodeId',
      tenantContextShrink: 'TenantContext',
      withPermissionRole: 'WithPermissionRole',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxResults: 'number',
      nextToken: 'string',
      parentNodeId: 'string',
      tenantContextShrink: 'string',
      withPermissionRole: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListNodesResponseBody extends $tea.Model {
  nextToken?: string;
  nodes?: ListNodesResponseBodyNodes[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      nextToken: 'nextToken',
      nodes: 'nodes',
      requestId: 'requestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nextToken: 'string',
      nodes: { 'type': 'array', 'itemType': ListNodesResponseBodyNodes },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListNodesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListNodesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListNodesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListReportHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: ListReportHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: ListReportHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListReportShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListReportRequest extends $tea.Model {
  cursor?: number;
  endTime?: number;
  modifiedEndTime?: number;
  modifiedStartTime?: number;
  size?: number;
  startTime?: number;
  templateName?: string;
  tenantContext?: ListReportRequestTenantContext;
  static names(): { [key: string]: string } {
    return {
      cursor: 'Cursor',
      endTime: 'EndTime',
      modifiedEndTime: 'ModifiedEndTime',
      modifiedStartTime: 'ModifiedStartTime',
      size: 'Size',
      startTime: 'StartTime',
      templateName: 'TemplateName',
      tenantContext: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cursor: 'number',
      endTime: 'number',
      modifiedEndTime: 'number',
      modifiedStartTime: 'number',
      size: 'number',
      startTime: 'number',
      templateName: 'string',
      tenantContext: ListReportRequestTenantContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListReportShrinkRequest extends $tea.Model {
  cursor?: number;
  endTime?: number;
  modifiedEndTime?: number;
  modifiedStartTime?: number;
  size?: number;
  startTime?: number;
  templateName?: string;
  tenantContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      cursor: 'Cursor',
      endTime: 'EndTime',
      modifiedEndTime: 'ModifiedEndTime',
      modifiedStartTime: 'ModifiedStartTime',
      size: 'Size',
      startTime: 'StartTime',
      templateName: 'TemplateName',
      tenantContextShrink: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cursor: 'number',
      endTime: 'number',
      modifiedEndTime: 'number',
      modifiedStartTime: 'number',
      size: 'number',
      startTime: 'number',
      templateName: 'string',
      tenantContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListReportResponseBody extends $tea.Model {
  dataList?: ListReportResponseBodyDataList[];
  hasMore?: boolean;
  nextCursor?: number;
  requestId?: string;
  size?: number;
  static names(): { [key: string]: string } {
    return {
      dataList: 'dataList',
      hasMore: 'hasMore',
      nextCursor: 'nextCursor',
      requestId: 'requestId',
      size: 'size',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataList: { 'type': 'array', 'itemType': ListReportResponseBodyDataList },
      hasMore: 'boolean',
      nextCursor: 'number',
      requestId: 'string',
      size: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListReportResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListReportResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListReportResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTableDataByFormInstanceIdTableIdHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: ListTableDataByFormInstanceIdTableIdHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: ListTableDataByFormInstanceIdTableIdHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTableDataByFormInstanceIdTableIdShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTableDataByFormInstanceIdTableIdRequest extends $tea.Model {
  appType?: string;
  formInstanceId?: string;
  formUuid?: string;
  pageNumber?: number;
  pageSize?: number;
  systemToken?: string;
  tableFieldId?: string;
  static names(): { [key: string]: string } {
    return {
      appType: 'AppType',
      formInstanceId: 'FormInstanceId',
      formUuid: 'FormUuid',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      systemToken: 'SystemToken',
      tableFieldId: 'TableFieldId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appType: 'string',
      formInstanceId: 'string',
      formUuid: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      systemToken: 'string',
      tableFieldId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTableDataByFormInstanceIdTableIdResponseBody extends $tea.Model {
  data?: string[];
  pageNumber?: number;
  requestId?: string;
  totalCount?: number;
  vendorRequestId?: string;
  vendorType?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'data',
      pageNumber: 'pageNumber',
      requestId: 'requestId',
      totalCount: 'totalCount',
      vendorRequestId: 'vendorRequestId',
      vendorType: 'vendorType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': 'string' },
      pageNumber: 'number',
      requestId: 'string',
      totalCount: 'number',
      vendorRequestId: 'string',
      vendorType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTableDataByFormInstanceIdTableIdResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListTableDataByFormInstanceIdTableIdResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListTableDataByFormInstanceIdTableIdResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTeamsHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: ListTeamsHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: ListTeamsHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTeamsShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTeamsRequest extends $tea.Model {
  maxResults?: number;
  nextToken?: string;
  tenantContext?: ListTeamsRequestTenantContext;
  static names(): { [key: string]: string } {
    return {
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      tenantContext: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxResults: 'number',
      nextToken: 'string',
      tenantContext: ListTeamsRequestTenantContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTeamsShrinkRequest extends $tea.Model {
  maxResults?: number;
  nextToken?: string;
  tenantContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      tenantContextShrink: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxResults: 'number',
      nextToken: 'string',
      tenantContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTeamsResponseBody extends $tea.Model {
  nextToken?: string;
  requestId?: string;
  teams?: ListTeamsResponseBodyTeams[];
  vendorRequestId?: string;
  vendorType?: string;
  static names(): { [key: string]: string } {
    return {
      nextToken: 'nextToken',
      requestId: 'requestId',
      teams: 'teams',
      vendorRequestId: 'vendorRequestId',
      vendorType: 'vendorType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nextToken: 'string',
      requestId: 'string',
      teams: { 'type': 'array', 'itemType': ListTeamsResponseBodyTeams },
      vendorRequestId: 'string',
      vendorType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTeamsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListTeamsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListTeamsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkspacesHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: ListWorkspacesHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: ListWorkspacesHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkspacesShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkspacesRequest extends $tea.Model {
  maxResults?: number;
  nextToken?: string;
  orderBy?: string;
  teamId?: string;
  tenantContext?: ListWorkspacesRequestTenantContext;
  withPermissionRole?: boolean;
  static names(): { [key: string]: string } {
    return {
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      orderBy: 'OrderBy',
      teamId: 'TeamId',
      tenantContext: 'TenantContext',
      withPermissionRole: 'WithPermissionRole',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxResults: 'number',
      nextToken: 'string',
      orderBy: 'string',
      teamId: 'string',
      tenantContext: ListWorkspacesRequestTenantContext,
      withPermissionRole: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkspacesShrinkRequest extends $tea.Model {
  maxResults?: number;
  nextToken?: string;
  orderBy?: string;
  teamId?: string;
  tenantContextShrink?: string;
  withPermissionRole?: boolean;
  static names(): { [key: string]: string } {
    return {
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      orderBy: 'OrderBy',
      teamId: 'TeamId',
      tenantContextShrink: 'TenantContext',
      withPermissionRole: 'WithPermissionRole',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxResults: 'number',
      nextToken: 'string',
      orderBy: 'string',
      teamId: 'string',
      tenantContextShrink: 'string',
      withPermissionRole: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkspacesResponseBody extends $tea.Model {
  nextToken?: string;
  requestId?: string;
  workspaces?: ListWorkspacesResponseBodyWorkspaces[];
  static names(): { [key: string]: string } {
    return {
      nextToken: 'nextToken',
      requestId: 'requestId',
      workspaces: 'workspaces',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nextToken: 'string',
      requestId: 'string',
      workspaces: { 'type': 'array', 'itemType': ListWorkspacesResponseBodyWorkspaces },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkspacesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListWorkspacesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListWorkspacesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PatchEventHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: PatchEventHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: PatchEventHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PatchEventShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PatchEventRequest extends $tea.Model {
  attendees?: PatchEventRequestAttendees[];
  calendarId?: string;
  description?: string;
  end?: PatchEventRequestEnd;
  eventId?: string;
  extra?: { [key: string]: string };
  isAllDay?: boolean;
  location?: PatchEventRequestLocation;
  recurrence?: PatchEventRequestRecurrence;
  reminders?: PatchEventRequestReminders[];
  start?: PatchEventRequestStart;
  summary?: string;
  static names(): { [key: string]: string } {
    return {
      attendees: 'Attendees',
      calendarId: 'CalendarId',
      description: 'Description',
      end: 'End',
      eventId: 'EventId',
      extra: 'Extra',
      isAllDay: 'IsAllDay',
      location: 'Location',
      recurrence: 'Recurrence',
      reminders: 'Reminders',
      start: 'Start',
      summary: 'Summary',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attendees: { 'type': 'array', 'itemType': PatchEventRequestAttendees },
      calendarId: 'string',
      description: 'string',
      end: PatchEventRequestEnd,
      eventId: 'string',
      extra: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      isAllDay: 'boolean',
      location: PatchEventRequestLocation,
      recurrence: PatchEventRequestRecurrence,
      reminders: { 'type': 'array', 'itemType': PatchEventRequestReminders },
      start: PatchEventRequestStart,
      summary: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PatchEventShrinkRequest extends $tea.Model {
  attendeesShrink?: string;
  calendarId?: string;
  description?: string;
  endShrink?: string;
  eventId?: string;
  extraShrink?: string;
  isAllDay?: boolean;
  locationShrink?: string;
  recurrenceShrink?: string;
  remindersShrink?: string;
  startShrink?: string;
  summary?: string;
  static names(): { [key: string]: string } {
    return {
      attendeesShrink: 'Attendees',
      calendarId: 'CalendarId',
      description: 'Description',
      endShrink: 'End',
      eventId: 'EventId',
      extraShrink: 'Extra',
      isAllDay: 'IsAllDay',
      locationShrink: 'Location',
      recurrenceShrink: 'Recurrence',
      remindersShrink: 'Reminders',
      startShrink: 'Start',
      summary: 'Summary',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attendeesShrink: 'string',
      calendarId: 'string',
      description: 'string',
      endShrink: 'string',
      eventId: 'string',
      extraShrink: 'string',
      isAllDay: 'boolean',
      locationShrink: 'string',
      recurrenceShrink: 'string',
      remindersShrink: 'string',
      startShrink: 'string',
      summary: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PatchEventResponseBody extends $tea.Model {
  attendees?: PatchEventResponseBodyAttendees[];
  createTime?: string;
  description?: string;
  end?: PatchEventResponseBodyEnd;
  id?: string;
  isAllDay?: boolean;
  location?: PatchEventResponseBodyLocation;
  organizer?: PatchEventResponseBodyOrganizer;
  recurrence?: PatchEventResponseBodyRecurrence;
  reminders?: PatchEventResponseBodyReminders[];
  requestId?: string;
  start?: PatchEventResponseBodyStart;
  summary?: string;
  updateTime?: string;
  static names(): { [key: string]: string } {
    return {
      attendees: 'attendees',
      createTime: 'createTime',
      description: 'description',
      end: 'end',
      id: 'id',
      isAllDay: 'isAllDay',
      location: 'location',
      organizer: 'organizer',
      recurrence: 'recurrence',
      reminders: 'reminders',
      requestId: 'requestId',
      start: 'start',
      summary: 'summary',
      updateTime: 'updateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attendees: { 'type': 'array', 'itemType': PatchEventResponseBodyAttendees },
      createTime: 'string',
      description: 'string',
      end: PatchEventResponseBodyEnd,
      id: 'string',
      isAllDay: 'boolean',
      location: PatchEventResponseBodyLocation,
      organizer: PatchEventResponseBodyOrganizer,
      recurrence: PatchEventResponseBodyRecurrence,
      reminders: { 'type': 'array', 'itemType': PatchEventResponseBodyReminders },
      requestId: 'string',
      start: PatchEventResponseBodyStart,
      summary: 'string',
      updateTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PatchEventResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: PatchEventResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: PatchEventResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCloudRecordTextHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: QueryCloudRecordTextHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: QueryCloudRecordTextHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCloudRecordTextShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCloudRecordTextRequest extends $tea.Model {
  direction?: string;
  maxResults?: number;
  nextToken?: number;
  startTime?: number;
  tenantContext?: QueryCloudRecordTextRequestTenantContext;
  conferenceId?: string;
  static names(): { [key: string]: string } {
    return {
      direction: 'Direction',
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      startTime: 'StartTime',
      tenantContext: 'TenantContext',
      conferenceId: 'conferenceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      direction: 'string',
      maxResults: 'number',
      nextToken: 'number',
      startTime: 'number',
      tenantContext: QueryCloudRecordTextRequestTenantContext,
      conferenceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCloudRecordTextShrinkRequest extends $tea.Model {
  direction?: string;
  maxResults?: number;
  nextToken?: number;
  startTime?: number;
  tenantContextShrink?: string;
  conferenceId?: string;
  static names(): { [key: string]: string } {
    return {
      direction: 'Direction',
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      startTime: 'StartTime',
      tenantContextShrink: 'TenantContext',
      conferenceId: 'conferenceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      direction: 'string',
      maxResults: 'number',
      nextToken: 'number',
      startTime: 'number',
      tenantContextShrink: 'string',
      conferenceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCloudRecordTextResponseBody extends $tea.Model {
  hasMore?: boolean;
  paragraphList?: QueryCloudRecordTextResponseBodyParagraphList[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      hasMore: 'hasMore',
      paragraphList: 'paragraphList',
      requestId: 'requestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      hasMore: 'boolean',
      paragraphList: { 'type': 'array', 'itemType': QueryCloudRecordTextResponseBodyParagraphList },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCloudRecordTextResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: QueryCloudRecordTextResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryCloudRecordTextResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCloudRecordVideoHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: QueryCloudRecordVideoHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: QueryCloudRecordVideoHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCloudRecordVideoShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCloudRecordVideoRequest extends $tea.Model {
  tenantContext?: QueryCloudRecordVideoRequestTenantContext;
  conferenceId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantContext: 'TenantContext',
      conferenceId: 'conferenceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantContext: QueryCloudRecordVideoRequestTenantContext,
      conferenceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCloudRecordVideoShrinkRequest extends $tea.Model {
  tenantContextShrink?: string;
  conferenceId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantContextShrink: 'TenantContext',
      conferenceId: 'conferenceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantContextShrink: 'string',
      conferenceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCloudRecordVideoResponseBody extends $tea.Model {
  requestId?: string;
  videoList?: QueryCloudRecordVideoResponseBodyVideoList[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'requestId',
      videoList: 'videoList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      videoList: { 'type': 'array', 'itemType': QueryCloudRecordVideoResponseBodyVideoList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCloudRecordVideoResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: QueryCloudRecordVideoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryCloudRecordVideoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCloudRecordVideoPlayInfoHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: QueryCloudRecordVideoPlayInfoHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: QueryCloudRecordVideoPlayInfoHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCloudRecordVideoPlayInfoShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCloudRecordVideoPlayInfoRequest extends $tea.Model {
  conferenceId?: string;
  mediaId?: string;
  regionId?: string;
  tenantContext?: QueryCloudRecordVideoPlayInfoRequestTenantContext;
  static names(): { [key: string]: string } {
    return {
      conferenceId: 'ConferenceId',
      mediaId: 'MediaId',
      regionId: 'RegionId',
      tenantContext: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      conferenceId: 'string',
      mediaId: 'string',
      regionId: 'string',
      tenantContext: QueryCloudRecordVideoPlayInfoRequestTenantContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCloudRecordVideoPlayInfoShrinkRequest extends $tea.Model {
  conferenceId?: string;
  mediaId?: string;
  regionId?: string;
  tenantContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      conferenceId: 'ConferenceId',
      mediaId: 'MediaId',
      regionId: 'RegionId',
      tenantContextShrink: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      conferenceId: 'string',
      mediaId: 'string',
      regionId: 'string',
      tenantContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCloudRecordVideoPlayInfoResponseBody extends $tea.Model {
  duration?: number;
  fileSize?: number;
  mp4FileUrl?: string;
  playUrl?: string;
  requestId?: string;
  status?: number;
  static names(): { [key: string]: string } {
    return {
      duration: 'duration',
      fileSize: 'fileSize',
      mp4FileUrl: 'mp4FileUrl',
      playUrl: 'playUrl',
      requestId: 'requestId',
      status: 'status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      duration: 'number',
      fileSize: 'number',
      mp4FileUrl: 'string',
      playUrl: 'string',
      requestId: 'string',
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCloudRecordVideoPlayInfoResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: QueryCloudRecordVideoPlayInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryCloudRecordVideoPlayInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryConferenceInfoHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: QueryConferenceInfoHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: QueryConferenceInfoHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryConferenceInfoShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryConferenceInfoRequest extends $tea.Model {
  conferenceId?: string;
  static names(): { [key: string]: string } {
    return {
      conferenceId: 'conferenceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      conferenceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryConferenceInfoResponseBody extends $tea.Model {
  confInfo?: QueryConferenceInfoResponseBodyConfInfo;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      confInfo: 'confInfo',
      requestId: 'requestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      confInfo: QueryConferenceInfoResponseBodyConfInfo,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryConferenceInfoResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: QueryConferenceInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryConferenceInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryConferenceMembersHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: QueryConferenceMembersHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: QueryConferenceMembersHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryConferenceMembersShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryConferenceMembersRequest extends $tea.Model {
  maxResults?: number;
  nextToken?: string;
  tenantContext?: QueryConferenceMembersRequestTenantContext;
  conferenceId?: string;
  static names(): { [key: string]: string } {
    return {
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      tenantContext: 'TenantContext',
      conferenceId: 'conferenceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxResults: 'number',
      nextToken: 'string',
      tenantContext: QueryConferenceMembersRequestTenantContext,
      conferenceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryConferenceMembersShrinkRequest extends $tea.Model {
  maxResults?: number;
  nextToken?: string;
  tenantContextShrink?: string;
  conferenceId?: string;
  static names(): { [key: string]: string } {
    return {
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      tenantContextShrink: 'TenantContext',
      conferenceId: 'conferenceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxResults: 'number',
      nextToken: 'string',
      tenantContextShrink: 'string',
      conferenceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryConferenceMembersResponseBody extends $tea.Model {
  memberModels?: QueryConferenceMembersResponseBodyMemberModels[];
  nextToken?: string;
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      memberModels: 'memberModels',
      nextToken: 'nextToken',
      requestId: 'requestId',
      totalCount: 'totalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      memberModels: { 'type': 'array', 'itemType': QueryConferenceMembersResponseBodyMemberModels },
      nextToken: 'string',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryConferenceMembersResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: QueryConferenceMembersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryConferenceMembersResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDentryHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: QueryDentryHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: QueryDentryHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDentryShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDentryRequest extends $tea.Model {
  dentryId?: string;
  includeSpace?: boolean;
  spaceId?: string;
  tenantContext?: QueryDentryRequestTenantContext;
  static names(): { [key: string]: string } {
    return {
      dentryId: 'DentryId',
      includeSpace: 'IncludeSpace',
      spaceId: 'SpaceId',
      tenantContext: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dentryId: 'string',
      includeSpace: 'boolean',
      spaceId: 'string',
      tenantContext: QueryDentryRequestTenantContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDentryShrinkRequest extends $tea.Model {
  dentryId?: string;
  includeSpace?: boolean;
  spaceId?: string;
  tenantContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      dentryId: 'DentryId',
      includeSpace: 'IncludeSpace',
      spaceId: 'SpaceId',
      tenantContextShrink: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dentryId: 'string',
      includeSpace: 'boolean',
      spaceId: 'string',
      tenantContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDentryResponseBody extends $tea.Model {
  contentType?: string;
  createdTime?: number;
  creator?: QueryDentryResponseBodyCreator;
  dentryId?: string;
  dentryType?: string;
  dentryUuid?: string;
  docKey?: string;
  extension?: string;
  hasChildren?: boolean;
  linkSourceInfo?: QueryDentryResponseBodyLinkSourceInfo;
  name?: string;
  path?: string;
  requestId?: string;
  space?: QueryDentryResponseBodySpace;
  spaceId?: string;
  updatedTime?: number;
  updater?: QueryDentryResponseBodyUpdater;
  url?: string;
  visitorInfo?: QueryDentryResponseBodyVisitorInfo;
  static names(): { [key: string]: string } {
    return {
      contentType: 'contentType',
      createdTime: 'createdTime',
      creator: 'creator',
      dentryId: 'dentryId',
      dentryType: 'dentryType',
      dentryUuid: 'dentryUuid',
      docKey: 'docKey',
      extension: 'extension',
      hasChildren: 'hasChildren',
      linkSourceInfo: 'linkSourceInfo',
      name: 'name',
      path: 'path',
      requestId: 'requestId',
      space: 'space',
      spaceId: 'spaceId',
      updatedTime: 'updatedTime',
      updater: 'updater',
      url: 'url',
      visitorInfo: 'visitorInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contentType: 'string',
      createdTime: 'number',
      creator: QueryDentryResponseBodyCreator,
      dentryId: 'string',
      dentryType: 'string',
      dentryUuid: 'string',
      docKey: 'string',
      extension: 'string',
      hasChildren: 'boolean',
      linkSourceInfo: QueryDentryResponseBodyLinkSourceInfo,
      name: 'string',
      path: 'string',
      requestId: 'string',
      space: QueryDentryResponseBodySpace,
      spaceId: 'string',
      updatedTime: 'number',
      updater: QueryDentryResponseBodyUpdater,
      url: 'string',
      visitorInfo: QueryDentryResponseBodyVisitorInfo,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDentryResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: QueryDentryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryDentryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryLiveInfoHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: QueryLiveInfoHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: QueryLiveInfoHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryLiveInfoShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryLiveInfoRequest extends $tea.Model {
  liveId?: string;
  tenantContext?: QueryLiveInfoRequestTenantContext;
  static names(): { [key: string]: string } {
    return {
      liveId: 'LiveId',
      tenantContext: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      liveId: 'string',
      tenantContext: QueryLiveInfoRequestTenantContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryLiveInfoShrinkRequest extends $tea.Model {
  liveId?: string;
  tenantContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      liveId: 'LiveId',
      tenantContextShrink: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      liveId: 'string',
      tenantContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryLiveInfoResponseBody extends $tea.Model {
  coverUrl?: string;
  duration?: number;
  endTime?: number;
  introduction?: string;
  liveId?: string;
  livePlayUrl?: string;
  liveStatus?: number;
  playbackDuration?: number;
  requestId?: string;
  startTime?: number;
  subscribeCount?: number;
  title?: string;
  uv?: number;
  static names(): { [key: string]: string } {
    return {
      coverUrl: 'coverUrl',
      duration: 'duration',
      endTime: 'endTime',
      introduction: 'introduction',
      liveId: 'liveId',
      livePlayUrl: 'livePlayUrl',
      liveStatus: 'liveStatus',
      playbackDuration: 'playbackDuration',
      requestId: 'requestId',
      startTime: 'startTime',
      subscribeCount: 'subscribeCount',
      title: 'title',
      uv: 'uv',
    };
  }

  static types(): { [key: string]: any } {
    return {
      coverUrl: 'string',
      duration: 'number',
      endTime: 'number',
      introduction: 'string',
      liveId: 'string',
      livePlayUrl: 'string',
      liveStatus: 'number',
      playbackDuration: 'number',
      requestId: 'string',
      startTime: 'number',
      subscribeCount: 'number',
      title: 'string',
      uv: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryLiveInfoResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: QueryLiveInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryLiveInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryLiveWatchDetailHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: QueryLiveWatchDetailHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: QueryLiveWatchDetailHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryLiveWatchDetailShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryLiveWatchDetailRequest extends $tea.Model {
  liveId?: string;
  tenantContext?: QueryLiveWatchDetailRequestTenantContext;
  static names(): { [key: string]: string } {
    return {
      liveId: 'LiveId',
      tenantContext: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      liveId: 'string',
      tenantContext: QueryLiveWatchDetailRequestTenantContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryLiveWatchDetailShrinkRequest extends $tea.Model {
  liveId?: string;
  tenantContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      liveId: 'LiveId',
      tenantContextShrink: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      liveId: 'string',
      tenantContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryLiveWatchDetailResponseBody extends $tea.Model {
  avgWatchTime?: number;
  liveUv?: number;
  msgCount?: number;
  playbackUv?: number;
  praiseCount?: number;
  pv?: number;
  requestId?: string;
  totalWatchTime?: number;
  uv?: number;
  static names(): { [key: string]: string } {
    return {
      avgWatchTime: 'avgWatchTime',
      liveUv: 'liveUv',
      msgCount: 'msgCount',
      playbackUv: 'playbackUv',
      praiseCount: 'praiseCount',
      pv: 'pv',
      requestId: 'requestId',
      totalWatchTime: 'totalWatchTime',
      uv: 'uv',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avgWatchTime: 'number',
      liveUv: 'number',
      msgCount: 'number',
      playbackUv: 'number',
      praiseCount: 'number',
      pv: 'number',
      requestId: 'string',
      totalWatchTime: 'number',
      uv: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryLiveWatchDetailResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: QueryLiveWatchDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryLiveWatchDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryLiveWatchUserListHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: QueryLiveWatchUserListHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: QueryLiveWatchUserListHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryLiveWatchUserListShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryLiveWatchUserListRequest extends $tea.Model {
  liveId?: string;
  pageNumber?: number;
  pageSize?: number;
  tenantContext?: QueryLiveWatchUserListRequestTenantContext;
  static names(): { [key: string]: string } {
    return {
      liveId: 'LiveId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      tenantContext: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      liveId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      tenantContext: QueryLiveWatchUserListRequestTenantContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryLiveWatchUserListShrinkRequest extends $tea.Model {
  liveId?: string;
  pageNumber?: number;
  pageSize?: number;
  tenantContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      liveId: 'LiveId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      tenantContextShrink: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      liveId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      tenantContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryLiveWatchUserListResponseBody extends $tea.Model {
  orgUsesList?: QueryLiveWatchUserListResponseBodyOrgUsesList[];
  outOrgUserList?: QueryLiveWatchUserListResponseBodyOutOrgUserList[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      orgUsesList: 'orgUsesList',
      outOrgUserList: 'outOrgUserList',
      requestId: 'requestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orgUsesList: { 'type': 'array', 'itemType': QueryLiveWatchUserListResponseBodyOrgUsesList },
      outOrgUserList: { 'type': 'array', 'itemType': QueryLiveWatchUserListResponseBodyOutOrgUserList },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryLiveWatchUserListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: QueryLiveWatchUserListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryLiveWatchUserListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMeetingRoomHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: QueryMeetingRoomHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: QueryMeetingRoomHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMeetingRoomShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMeetingRoomRequest extends $tea.Model {
  roomId?: string;
  tenantContext?: QueryMeetingRoomRequestTenantContext;
  static names(): { [key: string]: string } {
    return {
      roomId: 'RoomId',
      tenantContext: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      roomId: 'string',
      tenantContext: QueryMeetingRoomRequestTenantContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMeetingRoomShrinkRequest extends $tea.Model {
  roomId?: string;
  tenantContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      roomId: 'RoomId',
      tenantContextShrink: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      roomId: 'string',
      tenantContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMeetingRoomResponseBody extends $tea.Model {
  requestId?: string;
  result?: QueryMeetingRoomResponseBodyResult;
  vendorRequestId?: string;
  vendorType?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'requestId',
      result: 'result',
      vendorRequestId: 'vendorRequestId',
      vendorType: 'vendorType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: QueryMeetingRoomResponseBodyResult,
      vendorRequestId: 'string',
      vendorType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMeetingRoomResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: QueryMeetingRoomResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryMeetingRoomResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMeetingRoomGroupHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: QueryMeetingRoomGroupHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: QueryMeetingRoomGroupHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMeetingRoomGroupShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMeetingRoomGroupRequest extends $tea.Model {
  groupId?: string;
  tenantContext?: QueryMeetingRoomGroupRequestTenantContext;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      tenantContext: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      tenantContext: QueryMeetingRoomGroupRequestTenantContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMeetingRoomGroupShrinkRequest extends $tea.Model {
  groupId?: string;
  tenantContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      tenantContextShrink: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      tenantContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMeetingRoomGroupResponseBody extends $tea.Model {
  groupId?: number;
  groupName?: string;
  parentId?: number;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'groupId',
      groupName: 'groupName',
      parentId: 'parentId',
      requestId: 'requestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'number',
      groupName: 'string',
      parentId: 'number',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMeetingRoomGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: QueryMeetingRoomGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryMeetingRoomGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMeetingRoomGroupListHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: QueryMeetingRoomGroupListHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: QueryMeetingRoomGroupListHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMeetingRoomGroupListShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMeetingRoomGroupListRequest extends $tea.Model {
  request?: { [key: string]: any };
  tenantContext?: QueryMeetingRoomGroupListRequestTenantContext;
  static names(): { [key: string]: string } {
    return {
      request: 'Request',
      tenantContext: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      request: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      tenantContext: QueryMeetingRoomGroupListRequestTenantContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMeetingRoomGroupListShrinkRequest extends $tea.Model {
  requestShrink?: string;
  tenantContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      requestShrink: 'Request',
      tenantContextShrink: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestShrink: 'string',
      tenantContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMeetingRoomGroupListResponseBody extends $tea.Model {
  requestId?: string;
  result?: QueryMeetingRoomGroupListResponseBodyResult[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'requestId',
      result: 'result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: { 'type': 'array', 'itemType': QueryMeetingRoomGroupListResponseBodyResult },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMeetingRoomGroupListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: QueryMeetingRoomGroupListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryMeetingRoomGroupListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMeetingRoomListHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: QueryMeetingRoomListHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: QueryMeetingRoomListHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMeetingRoomListShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMeetingRoomListRequest extends $tea.Model {
  maxResults?: number;
  nextToken?: number;
  tenantContext?: QueryMeetingRoomListRequestTenantContext;
  static names(): { [key: string]: string } {
    return {
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      tenantContext: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxResults: 'number',
      nextToken: 'number',
      tenantContext: QueryMeetingRoomListRequestTenantContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMeetingRoomListShrinkRequest extends $tea.Model {
  maxResults?: number;
  nextToken?: number;
  tenantContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      tenantContextShrink: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxResults: 'number',
      nextToken: 'number',
      tenantContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMeetingRoomListResponseBody extends $tea.Model {
  hasMore?: boolean;
  nextToken?: number;
  requestId?: string;
  result?: QueryMeetingRoomListResponseBodyResult[];
  static names(): { [key: string]: string } {
    return {
      hasMore: 'hasMore',
      nextToken: 'nextToken',
      requestId: 'requestId',
      result: 'result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      hasMore: 'boolean',
      nextToken: 'number',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': QueryMeetingRoomListResponseBodyResult },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMeetingRoomListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: QueryMeetingRoomListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryMeetingRoomListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryOrgHonorsHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: QueryOrgHonorsHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: QueryOrgHonorsHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryOrgHonorsShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryOrgHonorsRequest extends $tea.Model {
  tenantContext?: QueryOrgHonorsRequestTenantContext;
  maxResults?: number;
  nextToken?: string;
  orgId?: number;
  static names(): { [key: string]: string } {
    return {
      tenantContext: 'TenantContext',
      maxResults: 'maxResults',
      nextToken: 'nextToken',
      orgId: 'orgId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantContext: QueryOrgHonorsRequestTenantContext,
      maxResults: 'number',
      nextToken: 'string',
      orgId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryOrgHonorsShrinkRequest extends $tea.Model {
  tenantContextShrink?: string;
  maxResults?: number;
  nextToken?: string;
  orgId?: number;
  static names(): { [key: string]: string } {
    return {
      tenantContextShrink: 'TenantContext',
      maxResults: 'maxResults',
      nextToken: 'nextToken',
      orgId: 'orgId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantContextShrink: 'string',
      maxResults: 'number',
      nextToken: 'string',
      orgId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryOrgHonorsResponseBody extends $tea.Model {
  nextToken?: string;
  openHonors?: QueryOrgHonorsResponseBodyOpenHonors[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      nextToken: 'nextToken',
      openHonors: 'openHonors',
      requestId: 'requestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nextToken: 'string',
      openHonors: { 'type': 'array', 'itemType': QueryOrgHonorsResponseBodyOpenHonors },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryOrgHonorsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: QueryOrgHonorsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryOrgHonorsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryOrgTodoTasksHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: QueryOrgTodoTasksHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: QueryOrgTodoTasksHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryOrgTodoTasksShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryOrgTodoTasksRequest extends $tea.Model {
  tenantContext?: QueryOrgTodoTasksRequestTenantContext;
  isDone?: boolean;
  nextToken?: string;
  static names(): { [key: string]: string } {
    return {
      tenantContext: 'TenantContext',
      isDone: 'isDone',
      nextToken: 'nextToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantContext: QueryOrgTodoTasksRequestTenantContext,
      isDone: 'boolean',
      nextToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryOrgTodoTasksShrinkRequest extends $tea.Model {
  tenantContextShrink?: string;
  isDone?: boolean;
  nextToken?: string;
  static names(): { [key: string]: string } {
    return {
      tenantContextShrink: 'TenantContext',
      isDone: 'isDone',
      nextToken: 'nextToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantContextShrink: 'string',
      isDone: 'boolean',
      nextToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryOrgTodoTasksResponseBody extends $tea.Model {
  nextToken?: string;
  requestId?: string;
  todoCards?: QueryOrgTodoTasksResponseBodyTodoCards[];
  static names(): { [key: string]: string } {
    return {
      nextToken: 'nextToken',
      requestId: 'requestId',
      todoCards: 'todoCards',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nextToken: 'string',
      requestId: 'string',
      todoCards: { 'type': 'array', 'itemType': QueryOrgTodoTasksResponseBodyTodoCards },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryOrgTodoTasksResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: QueryOrgTodoTasksResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryOrgTodoTasksResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryScheduleConferenceHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: QueryScheduleConferenceHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: QueryScheduleConferenceHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryScheduleConferenceShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryScheduleConferenceRequest extends $tea.Model {
  tenantContext?: QueryScheduleConferenceRequestTenantContext;
  scheduleConferenceId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantContext: 'TenantContext',
      scheduleConferenceId: 'scheduleConferenceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantContext: QueryScheduleConferenceRequestTenantContext,
      scheduleConferenceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryScheduleConferenceShrinkRequest extends $tea.Model {
  tenantContextShrink?: string;
  scheduleConferenceId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantContextShrink: 'TenantContext',
      scheduleConferenceId: 'scheduleConferenceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantContextShrink: 'string',
      scheduleConferenceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryScheduleConferenceResponseBody extends $tea.Model {
  endTime?: number;
  phones?: string[];
  requestId?: string;
  roomCode?: string;
  scheduleConferenceId?: string;
  startTime?: number;
  title?: string;
  url?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'endTime',
      phones: 'phones',
      requestId: 'requestId',
      roomCode: 'roomCode',
      scheduleConferenceId: 'scheduleConferenceId',
      startTime: 'startTime',
      title: 'title',
      url: 'url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'number',
      phones: { 'type': 'array', 'itemType': 'string' },
      requestId: 'string',
      roomCode: 'string',
      scheduleConferenceId: 'string',
      startTime: 'number',
      title: 'string',
      url: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryScheduleConferenceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: QueryScheduleConferenceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryScheduleConferenceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryUserHonorsHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: QueryUserHonorsHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: QueryUserHonorsHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryUserHonorsShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryUserHonorsRequest extends $tea.Model {
  tenantContext?: QueryUserHonorsRequestTenantContext;
  maxResults?: number;
  nextToken?: string;
  orgId?: number;
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantContext: 'TenantContext',
      maxResults: 'maxResults',
      nextToken: 'nextToken',
      orgId: 'orgId',
      userId: 'userId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantContext: QueryUserHonorsRequestTenantContext,
      maxResults: 'number',
      nextToken: 'string',
      orgId: 'number',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryUserHonorsShrinkRequest extends $tea.Model {
  tenantContextShrink?: string;
  maxResults?: number;
  nextToken?: string;
  orgId?: number;
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantContextShrink: 'TenantContext',
      maxResults: 'maxResults',
      nextToken: 'nextToken',
      orgId: 'orgId',
      userId: 'userId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantContextShrink: 'string',
      maxResults: 'number',
      nextToken: 'string',
      orgId: 'number',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryUserHonorsResponseBody extends $tea.Model {
  honors?: QueryUserHonorsResponseBodyHonors[];
  nextToken?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      honors: 'honors',
      nextToken: 'nextToken',
      requestId: 'requestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      honors: { 'type': 'array', 'itemType': QueryUserHonorsResponseBodyHonors },
      nextToken: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryUserHonorsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: QueryUserHonorsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryUserHonorsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RecallHonorHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: RecallHonorHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: RecallHonorHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RecallHonorShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RecallHonorRequest extends $tea.Model {
  tenantContext?: RecallHonorRequestTenantContext;
  honorId?: string;
  orgId?: number;
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantContext: 'TenantContext',
      honorId: 'honorId',
      orgId: 'orgId',
      userId: 'userId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantContext: RecallHonorRequestTenantContext,
      honorId: 'string',
      orgId: 'number',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RecallHonorShrinkRequest extends $tea.Model {
  tenantContextShrink?: string;
  honorId?: string;
  orgId?: number;
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantContextShrink: 'TenantContext',
      honorId: 'honorId',
      orgId: 'orgId',
      userId: 'userId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantContextShrink: 'string',
      honorId: 'string',
      orgId: 'number',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RecallHonorResponseBody extends $tea.Model {
  content?: RecallHonorResponseBodyContent;
  errorCode?: string;
  errorCtx?: { [key: string]: any };
  errorMsg?: string;
  httpStatusCode?: number;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      content: 'content',
      errorCode: 'errorCode',
      errorCtx: 'errorCtx',
      errorMsg: 'errorMsg',
      httpStatusCode: 'httpStatusCode',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: RecallHonorResponseBodyContent,
      errorCode: 'string',
      errorCtx: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      errorMsg: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RecallHonorResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: RecallHonorResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RecallHonorResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReceiverListReportHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: ReceiverListReportHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: ReceiverListReportHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReceiverListReportShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReceiverListReportRequest extends $tea.Model {
  offset?: number;
  reportId?: string;
  size?: number;
  tenantContext?: ReceiverListReportRequestTenantContext;
  static names(): { [key: string]: string } {
    return {
      offset: 'Offset',
      reportId: 'ReportId',
      size: 'Size',
      tenantContext: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      offset: 'number',
      reportId: 'string',
      size: 'number',
      tenantContext: ReceiverListReportRequestTenantContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReceiverListReportShrinkRequest extends $tea.Model {
  offset?: number;
  reportId?: string;
  size?: number;
  tenantContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      offset: 'Offset',
      reportId: 'ReportId',
      size: 'Size',
      tenantContextShrink: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      offset: 'number',
      reportId: 'string',
      size: 'number',
      tenantContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReceiverListReportResponseBody extends $tea.Model {
  hasMore?: boolean;
  nextCursor?: number;
  requestId?: string;
  useridList?: string[];
  static names(): { [key: string]: string } {
    return {
      hasMore: 'hasMore',
      nextCursor: 'nextCursor',
      requestId: 'requestId',
      useridList: 'useridList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      hasMore: 'boolean',
      nextCursor: 'number',
      requestId: 'string',
      useridList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReceiverListReportResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ReceiverListReportResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ReceiverListReportResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RedirectTaskHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: RedirectTaskHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: RedirectTaskHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RedirectTaskShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RedirectTaskRequest extends $tea.Model {
  appType?: string;
  byManager?: string;
  language?: string;
  nowActionExecutorId?: string;
  processInstanceId?: string;
  remark?: string;
  systemToken?: string;
  taskId?: number;
  static names(): { [key: string]: string } {
    return {
      appType: 'AppType',
      byManager: 'ByManager',
      language: 'Language',
      nowActionExecutorId: 'NowActionExecutorId',
      processInstanceId: 'ProcessInstanceId',
      remark: 'Remark',
      systemToken: 'SystemToken',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appType: 'string',
      byManager: 'string',
      language: 'string',
      nowActionExecutorId: 'string',
      processInstanceId: 'string',
      remark: 'string',
      systemToken: 'string',
      taskId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RedirectTaskResponseBody extends $tea.Model {
  requestId?: string;
  vendorRequestId?: string;
  vendorType?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'requestId',
      vendorRequestId: 'vendorRequestId',
      vendorType: 'vendorType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      vendorRequestId: 'string',
      vendorType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RedirectTaskResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: RedirectTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RedirectTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveAttendeeHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: RemoveAttendeeHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: RemoveAttendeeHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveAttendeeShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveAttendeeRequest extends $tea.Model {
  attendeesToRemove?: string[];
  calendarId?: string;
  eventId?: string;
  static names(): { [key: string]: string } {
    return {
      attendeesToRemove: 'AttendeesToRemove',
      calendarId: 'CalendarId',
      eventId: 'EventId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attendeesToRemove: { 'type': 'array', 'itemType': 'string' },
      calendarId: 'string',
      eventId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveAttendeeShrinkRequest extends $tea.Model {
  attendeesToRemoveShrink?: string;
  calendarId?: string;
  eventId?: string;
  static names(): { [key: string]: string } {
    return {
      attendeesToRemoveShrink: 'AttendeesToRemove',
      calendarId: 'CalendarId',
      eventId: 'EventId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attendeesToRemoveShrink: 'string',
      calendarId: 'string',
      eventId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveAttendeeResponseBody extends $tea.Model {
  content?: RemoveAttendeeResponseBodyContent;
  errorCode?: string;
  errorCtx?: { [key: string]: any };
  errorMsg?: string;
  httpStatusCode?: number;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      errorCode: 'ErrorCode',
      errorCtx: 'ErrorCtx',
      errorMsg: 'ErrorMsg',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: RemoveAttendeeResponseBodyContent,
      errorCode: 'string',
      errorCtx: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      errorMsg: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveAttendeeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: RemoveAttendeeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RemoveAttendeeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveMeetingRoomsHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: RemoveMeetingRoomsHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: RemoveMeetingRoomsHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveMeetingRoomsShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveMeetingRoomsRequest extends $tea.Model {
  calendarId?: string;
  eventId?: string;
  meetingRoomsToRemove?: RemoveMeetingRoomsRequestMeetingRoomsToRemove[];
  static names(): { [key: string]: string } {
    return {
      calendarId: 'CalendarId',
      eventId: 'EventId',
      meetingRoomsToRemove: 'MeetingRoomsToRemove',
    };
  }

  static types(): { [key: string]: any } {
    return {
      calendarId: 'string',
      eventId: 'string',
      meetingRoomsToRemove: { 'type': 'array', 'itemType': RemoveMeetingRoomsRequestMeetingRoomsToRemove },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveMeetingRoomsShrinkRequest extends $tea.Model {
  calendarId?: string;
  eventId?: string;
  meetingRoomsToRemoveShrink?: string;
  static names(): { [key: string]: string } {
    return {
      calendarId: 'CalendarId',
      eventId: 'EventId',
      meetingRoomsToRemoveShrink: 'MeetingRoomsToRemove',
    };
  }

  static types(): { [key: string]: any } {
    return {
      calendarId: 'string',
      eventId: 'string',
      meetingRoomsToRemoveShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveMeetingRoomsResponseBody extends $tea.Model {
  requestId?: string;
  result?: boolean;
  static names(): { [key: string]: string } {
    return {
      requestId: 'requestId',
      result: 'result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveMeetingRoomsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: RemoveMeetingRoomsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RemoveMeetingRoomsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SaveContentHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: SaveContentHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: SaveContentHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SaveContentShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SaveContentRequest extends $tea.Model {
  contents?: SaveContentRequestContents[];
  ddFrom?: string;
  templateId?: string;
  tenantContext?: SaveContentRequestTenantContext;
  static names(): { [key: string]: string } {
    return {
      contents: 'Contents',
      ddFrom: 'DdFrom',
      templateId: 'TemplateId',
      tenantContext: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contents: { 'type': 'array', 'itemType': SaveContentRequestContents },
      ddFrom: 'string',
      templateId: 'string',
      tenantContext: SaveContentRequestTenantContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SaveContentShrinkRequest extends $tea.Model {
  contentsShrink?: string;
  ddFrom?: string;
  templateId?: string;
  tenantContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      contentsShrink: 'Contents',
      ddFrom: 'DdFrom',
      templateId: 'TemplateId',
      tenantContextShrink: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contentsShrink: 'string',
      ddFrom: 'string',
      templateId: 'string',
      tenantContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SaveContentResponseBody extends $tea.Model {
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SaveContentResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SaveContentResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SaveContentResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SaveFormDataHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: SaveFormDataHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: SaveFormDataHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SaveFormDataShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SaveFormDataRequest extends $tea.Model {
  appType?: string;
  formDataJson?: string;
  formUuid?: string;
  language?: string;
  systemToken?: string;
  static names(): { [key: string]: string } {
    return {
      appType: 'AppType',
      formDataJson: 'FormDataJson',
      formUuid: 'FormUuid',
      language: 'Language',
      systemToken: 'SystemToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appType: 'string',
      formDataJson: 'string',
      formUuid: 'string',
      language: 'string',
      systemToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SaveFormDataResponseBody extends $tea.Model {
  requestId?: string;
  result?: string;
  vendorRequestId?: string;
  vendorType?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'requestId',
      result: 'result',
      vendorRequestId: 'vendorRequestId',
      vendorType: 'vendorType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: 'string',
      vendorRequestId: 'string',
      vendorType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SaveFormDataResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SaveFormDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SaveFormDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SaveFormRemarkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: SaveFormRemarkHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: SaveFormRemarkHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SaveFormRemarkShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SaveFormRemarkRequest extends $tea.Model {
  appType?: string;
  atUserId?: string;
  content?: string;
  formInstanceId?: string;
  language?: string;
  replyId?: number;
  systemToken?: string;
  static names(): { [key: string]: string } {
    return {
      appType: 'AppType',
      atUserId: 'AtUserId',
      content: 'Content',
      formInstanceId: 'FormInstanceId',
      language: 'Language',
      replyId: 'ReplyId',
      systemToken: 'SystemToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appType: 'string',
      atUserId: 'string',
      content: 'string',
      formInstanceId: 'string',
      language: 'string',
      replyId: 'number',
      systemToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SaveFormRemarkResponseBody extends $tea.Model {
  requestId?: string;
  result?: number;
  vendorRequestId?: string;
  vendorType?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'requestId',
      result: 'result',
      vendorRequestId: 'vendorRequestId',
      vendorType: 'vendorType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: 'number',
      vendorRequestId: 'string',
      vendorType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SaveFormRemarkResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SaveFormRemarkResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SaveFormRemarkResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchEmployeeFieldValuesHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: SearchEmployeeFieldValuesHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: SearchEmployeeFieldValuesHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchEmployeeFieldValuesShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchEmployeeFieldValuesRequest extends $tea.Model {
  appType?: string;
  createFromTimeGMT?: string;
  createToTimeGMT?: string;
  formUuid?: string;
  language?: string;
  modifiedFromTimeGMT?: string;
  modifiedToTimeGMT?: string;
  originatorId?: string;
  searchFieldJson?: string;
  systemToken?: string;
  targetFieldJson?: string;
  static names(): { [key: string]: string } {
    return {
      appType: 'AppType',
      createFromTimeGMT: 'CreateFromTimeGMT',
      createToTimeGMT: 'CreateToTimeGMT',
      formUuid: 'FormUuid',
      language: 'Language',
      modifiedFromTimeGMT: 'ModifiedFromTimeGMT',
      modifiedToTimeGMT: 'ModifiedToTimeGMT',
      originatorId: 'OriginatorId',
      searchFieldJson: 'SearchFieldJson',
      systemToken: 'SystemToken',
      targetFieldJson: 'TargetFieldJson',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appType: 'string',
      createFromTimeGMT: 'string',
      createToTimeGMT: 'string',
      formUuid: 'string',
      language: 'string',
      modifiedFromTimeGMT: 'string',
      modifiedToTimeGMT: 'string',
      originatorId: 'string',
      searchFieldJson: 'string',
      systemToken: 'string',
      targetFieldJson: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchEmployeeFieldValuesResponseBody extends $tea.Model {
  requestId?: string;
  result?: string;
  vendorRequestId?: string;
  vendorType?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'requestId',
      result: 'result',
      vendorRequestId: 'vendorRequestId',
      vendorType: 'vendorType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: 'string',
      vendorRequestId: 'string',
      vendorType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchEmployeeFieldValuesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SearchEmployeeFieldValuesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SearchEmployeeFieldValuesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchFormDataIdListHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: SearchFormDataIdListHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: SearchFormDataIdListHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchFormDataIdListShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchFormDataIdListRequest extends $tea.Model {
  appType?: string;
  createFromTimeGMT?: string;
  createToTimeGMT?: string;
  formUuid?: string;
  language?: string;
  modifiedFromTimeGMT?: string;
  modifiedToTimeGMT?: string;
  originatorId?: string;
  pageNumber?: number;
  pageSize?: number;
  searchFieldJson?: string;
  systemToken?: string;
  static names(): { [key: string]: string } {
    return {
      appType: 'AppType',
      createFromTimeGMT: 'CreateFromTimeGMT',
      createToTimeGMT: 'CreateToTimeGMT',
      formUuid: 'FormUuid',
      language: 'Language',
      modifiedFromTimeGMT: 'ModifiedFromTimeGMT',
      modifiedToTimeGMT: 'ModifiedToTimeGMT',
      originatorId: 'OriginatorId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      searchFieldJson: 'SearchFieldJson',
      systemToken: 'SystemToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appType: 'string',
      createFromTimeGMT: 'string',
      createToTimeGMT: 'string',
      formUuid: 'string',
      language: 'string',
      modifiedFromTimeGMT: 'string',
      modifiedToTimeGMT: 'string',
      originatorId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      searchFieldJson: 'string',
      systemToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchFormDataIdListResponseBody extends $tea.Model {
  data?: string[];
  pageNumber?: number;
  requestId?: string;
  totalCount?: number;
  vendorRequestId?: string;
  vendorType?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'data',
      pageNumber: 'pageNumber',
      requestId: 'requestId',
      totalCount: 'totalCount',
      vendorRequestId: 'vendorRequestId',
      vendorType: 'vendorType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': 'string' },
      pageNumber: 'number',
      requestId: 'string',
      totalCount: 'number',
      vendorRequestId: 'string',
      vendorType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchFormDataIdListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SearchFormDataIdListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SearchFormDataIdListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchFormDataSecondGenerationHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: SearchFormDataSecondGenerationHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: SearchFormDataSecondGenerationHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchFormDataSecondGenerationShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchFormDataSecondGenerationRequest extends $tea.Model {
  appType?: string;
  createFromTimeGMT?: string;
  createToTimeGMT?: string;
  formUuid?: string;
  modifiedFromTimeGMT?: string;
  modifiedToTimeGMT?: string;
  orderConfigJson?: string;
  originatorId?: string;
  pageNumber?: number;
  pageSize?: number;
  searchCondition?: string;
  systemToken?: string;
  static names(): { [key: string]: string } {
    return {
      appType: 'AppType',
      createFromTimeGMT: 'CreateFromTimeGMT',
      createToTimeGMT: 'CreateToTimeGMT',
      formUuid: 'FormUuid',
      modifiedFromTimeGMT: 'ModifiedFromTimeGMT',
      modifiedToTimeGMT: 'ModifiedToTimeGMT',
      orderConfigJson: 'OrderConfigJson',
      originatorId: 'OriginatorId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      searchCondition: 'SearchCondition',
      systemToken: 'SystemToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appType: 'string',
      createFromTimeGMT: 'string',
      createToTimeGMT: 'string',
      formUuid: 'string',
      modifiedFromTimeGMT: 'string',
      modifiedToTimeGMT: 'string',
      orderConfigJson: 'string',
      originatorId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      searchCondition: 'string',
      systemToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchFormDataSecondGenerationResponseBody extends $tea.Model {
  data?: SearchFormDataSecondGenerationResponseBodyData[];
  pageNumber?: number;
  requestId?: string;
  totalCount?: number;
  vendorRequestId?: string;
  vendorType?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'data',
      pageNumber: 'pageNumber',
      requestId: 'requestId',
      totalCount: 'totalCount',
      vendorRequestId: 'vendorRequestId',
      vendorType: 'vendorType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': SearchFormDataSecondGenerationResponseBodyData },
      pageNumber: 'number',
      requestId: 'string',
      totalCount: 'number',
      vendorRequestId: 'string',
      vendorType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchFormDataSecondGenerationResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SearchFormDataSecondGenerationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SearchFormDataSecondGenerationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchFormDataSecondGenerationNoTableFieldHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: SearchFormDataSecondGenerationNoTableFieldHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: SearchFormDataSecondGenerationNoTableFieldHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchFormDataSecondGenerationNoTableFieldShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchFormDataSecondGenerationNoTableFieldRequest extends $tea.Model {
  appType?: string;
  createFromTimeGMT?: string;
  createToTimeGMT?: string;
  formUuid?: string;
  modifiedFromTimeGMT?: string;
  modifiedToTimeGMT?: string;
  orderConfigJson?: string;
  originatorId?: string;
  pageNumber?: number;
  pageSize?: number;
  searchCondition?: string;
  systemToken?: string;
  static names(): { [key: string]: string } {
    return {
      appType: 'AppType',
      createFromTimeGMT: 'CreateFromTimeGMT',
      createToTimeGMT: 'CreateToTimeGMT',
      formUuid: 'FormUuid',
      modifiedFromTimeGMT: 'ModifiedFromTimeGMT',
      modifiedToTimeGMT: 'ModifiedToTimeGMT',
      orderConfigJson: 'OrderConfigJson',
      originatorId: 'OriginatorId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      searchCondition: 'SearchCondition',
      systemToken: 'SystemToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appType: 'string',
      createFromTimeGMT: 'string',
      createToTimeGMT: 'string',
      formUuid: 'string',
      modifiedFromTimeGMT: 'string',
      modifiedToTimeGMT: 'string',
      orderConfigJson: 'string',
      originatorId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      searchCondition: 'string',
      systemToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchFormDataSecondGenerationNoTableFieldResponseBody extends $tea.Model {
  data?: SearchFormDataSecondGenerationNoTableFieldResponseBodyData[];
  pageNumber?: number;
  requestId?: string;
  totalCount?: number;
  vendorRequestId?: string;
  vendorType?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'data',
      pageNumber: 'pageNumber',
      requestId: 'requestId',
      totalCount: 'totalCount',
      vendorRequestId: 'vendorRequestId',
      vendorType: 'vendorType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': SearchFormDataSecondGenerationNoTableFieldResponseBodyData },
      pageNumber: 'number',
      requestId: 'string',
      totalCount: 'number',
      vendorRequestId: 'string',
      vendorType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchFormDataSecondGenerationNoTableFieldResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SearchFormDataSecondGenerationNoTableFieldResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SearchFormDataSecondGenerationNoTableFieldResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchFormDatasHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: SearchFormDatasHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: SearchFormDatasHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchFormDatasShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchFormDatasRequest extends $tea.Model {
  appType?: string;
  createFromTimeGMT?: string;
  createToTimeGMT?: string;
  currentPage?: number;
  dynamicOrder?: string;
  formUuid?: string;
  language?: string;
  modifiedFromTimeGMT?: string;
  modifiedToTimeGMT?: string;
  originatorId?: string;
  pageSize?: number;
  searchFieldJson?: string;
  systemToken?: string;
  static names(): { [key: string]: string } {
    return {
      appType: 'AppType',
      createFromTimeGMT: 'CreateFromTimeGMT',
      createToTimeGMT: 'CreateToTimeGMT',
      currentPage: 'CurrentPage',
      dynamicOrder: 'DynamicOrder',
      formUuid: 'FormUuid',
      language: 'Language',
      modifiedFromTimeGMT: 'ModifiedFromTimeGMT',
      modifiedToTimeGMT: 'ModifiedToTimeGMT',
      originatorId: 'OriginatorId',
      pageSize: 'PageSize',
      searchFieldJson: 'SearchFieldJson',
      systemToken: 'SystemToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appType: 'string',
      createFromTimeGMT: 'string',
      createToTimeGMT: 'string',
      currentPage: 'number',
      dynamicOrder: 'string',
      formUuid: 'string',
      language: 'string',
      modifiedFromTimeGMT: 'string',
      modifiedToTimeGMT: 'string',
      originatorId: 'string',
      pageSize: 'number',
      searchFieldJson: 'string',
      systemToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchFormDatasResponseBody extends $tea.Model {
  currentPage?: number;
  data?: SearchFormDatasResponseBodyData[];
  requestId?: string;
  totalCount?: number;
  vendorRequestId?: string;
  vendorType?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'currentPage',
      data: 'data',
      requestId: 'requestId',
      totalCount: 'totalCount',
      vendorRequestId: 'vendorRequestId',
      vendorType: 'vendorType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      data: { 'type': 'array', 'itemType': SearchFormDatasResponseBodyData },
      requestId: 'string',
      totalCount: 'number',
      vendorRequestId: 'string',
      vendorType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchFormDatasResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SearchFormDatasResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SearchFormDatasResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchInnerGroupsHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: SearchInnerGroupsHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: SearchInnerGroupsHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchInnerGroupsShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchInnerGroupsRequest extends $tea.Model {
  maxResults?: number;
  searchKey?: string;
  static names(): { [key: string]: string } {
    return {
      maxResults: 'MaxResults',
      searchKey: 'SearchKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxResults: 'number',
      searchKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchInnerGroupsResponseBody extends $tea.Model {
  groupInfos?: SearchInnerGroupsResponseBodyGroupInfos[];
  requestId?: string;
  vendorRequestId?: string;
  vendorType?: string;
  static names(): { [key: string]: string } {
    return {
      groupInfos: 'groupInfos',
      requestId: 'requestId',
      vendorRequestId: 'vendorRequestId',
      vendorType: 'vendorType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupInfos: { 'type': 'array', 'itemType': SearchInnerGroupsResponseBodyGroupInfos },
      requestId: 'string',
      vendorRequestId: 'string',
      vendorType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchInnerGroupsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SearchInnerGroupsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SearchInnerGroupsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SendBannerHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: SendBannerHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: SendBannerHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SendBannerShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SendBannerRequest extends $tea.Model {
  content?: { [key: string]: any };
  endTime?: number;
  startTime?: number;
  tenantContext?: SendBannerRequestTenantContext;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      endTime: 'EndTime',
      startTime: 'StartTime',
      tenantContext: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      endTime: 'number',
      startTime: 'number',
      tenantContext: SendBannerRequestTenantContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SendBannerShrinkRequest extends $tea.Model {
  contentShrink?: string;
  endTime?: number;
  startTime?: number;
  tenantContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      contentShrink: 'Content',
      endTime: 'EndTime',
      startTime: 'StartTime',
      tenantContextShrink: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contentShrink: 'string',
      endTime: 'number',
      startTime: 'number',
      tenantContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SendBannerResponseBody extends $tea.Model {
  arguments?: any[];
  requestId?: string;
  success?: boolean;
  vendorRequestId?: string;
  vendorType?: string;
  static names(): { [key: string]: string } {
    return {
      arguments: 'arguments',
      requestId: 'requestId',
      success: 'success',
      vendorRequestId: 'vendorRequestId',
      vendorType: 'vendorType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      arguments: { 'type': 'array', 'itemType': 'any' },
      requestId: 'string',
      success: 'boolean',
      vendorRequestId: 'string',
      vendorType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SendBannerResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SendBannerResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SendBannerResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SendPopupHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: SendPopupHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: SendPopupHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SendPopupShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SendPopupRequest extends $tea.Model {
  content?: { [key: string]: any };
  endTime?: number;
  startTime?: number;
  tenantContext?: SendPopupRequestTenantContext;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      endTime: 'EndTime',
      startTime: 'StartTime',
      tenantContext: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      endTime: 'number',
      startTime: 'number',
      tenantContext: SendPopupRequestTenantContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SendPopupShrinkRequest extends $tea.Model {
  contentShrink?: string;
  endTime?: number;
  startTime?: number;
  tenantContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      contentShrink: 'Content',
      endTime: 'EndTime',
      startTime: 'StartTime',
      tenantContextShrink: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contentShrink: 'string',
      endTime: 'number',
      startTime: 'number',
      tenantContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SendPopupResponseBody extends $tea.Model {
  arguments?: any[];
  requestId?: string;
  success?: boolean;
  vendorRequestId?: string;
  vendorType?: string;
  static names(): { [key: string]: string } {
    return {
      arguments: 'arguments',
      requestId: 'requestId',
      success: 'success',
      vendorRequestId: 'vendorRequestId',
      vendorType: 'vendorType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      arguments: { 'type': 'array', 'itemType': 'any' },
      requestId: 'string',
      success: 'boolean',
      vendorRequestId: 'string',
      vendorType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SendPopupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SendPopupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SendPopupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SendSearchShadeHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: SendSearchShadeHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: SendSearchShadeHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SendSearchShadeShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SendSearchShadeRequest extends $tea.Model {
  content?: { [key: string]: any };
  endTime?: number;
  startTime?: number;
  tenantContext?: SendSearchShadeRequestTenantContext;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      endTime: 'EndTime',
      startTime: 'StartTime',
      tenantContext: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      endTime: 'number',
      startTime: 'number',
      tenantContext: SendSearchShadeRequestTenantContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SendSearchShadeShrinkRequest extends $tea.Model {
  contentShrink?: string;
  endTime?: number;
  startTime?: number;
  tenantContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      contentShrink: 'Content',
      endTime: 'EndTime',
      startTime: 'StartTime',
      tenantContextShrink: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contentShrink: 'string',
      endTime: 'number',
      startTime: 'number',
      tenantContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SendSearchShadeResponseBody extends $tea.Model {
  arguments?: any[];
  requestId?: string;
  success?: boolean;
  vendorRequestId?: string;
  vendorType?: string;
  static names(): { [key: string]: string } {
    return {
      arguments: 'arguments',
      requestId: 'requestId',
      success: 'success',
      vendorRequestId: 'vendorRequestId',
      vendorType: 'vendorType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      arguments: { 'type': 'array', 'itemType': 'any' },
      requestId: 'string',
      success: 'boolean',
      vendorRequestId: 'string',
      vendorType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SendSearchShadeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SendSearchShadeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SendSearchShadeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetColumnsVisibilityHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: SetColumnsVisibilityHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: SetColumnsVisibilityHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetColumnsVisibilityShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetColumnsVisibilityRequest extends $tea.Model {
  column?: number;
  columnCount?: number;
  sheetId?: string;
  tenantContext?: SetColumnsVisibilityRequestTenantContext;
  visibility?: string;
  workbookId?: string;
  static names(): { [key: string]: string } {
    return {
      column: 'Column',
      columnCount: 'ColumnCount',
      sheetId: 'SheetId',
      tenantContext: 'TenantContext',
      visibility: 'Visibility',
      workbookId: 'WorkbookId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      column: 'number',
      columnCount: 'number',
      sheetId: 'string',
      tenantContext: SetColumnsVisibilityRequestTenantContext,
      visibility: 'string',
      workbookId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetColumnsVisibilityShrinkRequest extends $tea.Model {
  column?: number;
  columnCount?: number;
  sheetId?: string;
  tenantContextShrink?: string;
  visibility?: string;
  workbookId?: string;
  static names(): { [key: string]: string } {
    return {
      column: 'Column',
      columnCount: 'ColumnCount',
      sheetId: 'SheetId',
      tenantContextShrink: 'TenantContext',
      visibility: 'Visibility',
      workbookId: 'WorkbookId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      column: 'number',
      columnCount: 'number',
      sheetId: 'string',
      tenantContextShrink: 'string',
      visibility: 'string',
      workbookId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetColumnsVisibilityResponseBody extends $tea.Model {
  id?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'id',
      requestId: 'requestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetColumnsVisibilityResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SetColumnsVisibilityResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SetColumnsVisibilityResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetRowsVisibilityHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: SetRowsVisibilityHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: SetRowsVisibilityHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetRowsVisibilityShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetRowsVisibilityRequest extends $tea.Model {
  row?: number;
  rowCount?: number;
  sheetId?: string;
  tenantContext?: SetRowsVisibilityRequestTenantContext;
  visibility?: string;
  workbookId?: string;
  static names(): { [key: string]: string } {
    return {
      row: 'Row',
      rowCount: 'RowCount',
      sheetId: 'SheetId',
      tenantContext: 'TenantContext',
      visibility: 'Visibility',
      workbookId: 'WorkbookId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      row: 'number',
      rowCount: 'number',
      sheetId: 'string',
      tenantContext: SetRowsVisibilityRequestTenantContext,
      visibility: 'string',
      workbookId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetRowsVisibilityShrinkRequest extends $tea.Model {
  row?: number;
  rowCount?: number;
  sheetId?: string;
  tenantContextShrink?: string;
  visibility?: string;
  workbookId?: string;
  static names(): { [key: string]: string } {
    return {
      row: 'Row',
      rowCount: 'RowCount',
      sheetId: 'SheetId',
      tenantContextShrink: 'TenantContext',
      visibility: 'Visibility',
      workbookId: 'WorkbookId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      row: 'number',
      rowCount: 'number',
      sheetId: 'string',
      tenantContextShrink: 'string',
      visibility: 'string',
      workbookId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetRowsVisibilityResponseBody extends $tea.Model {
  id?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'id',
      requestId: 'requestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetRowsVisibilityResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SetRowsVisibilityResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SetRowsVisibilityResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SimpleListReportHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: SimpleListReportHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: SimpleListReportHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SimpleListReportShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SimpleListReportRequest extends $tea.Model {
  cursor?: number;
  endTime?: number;
  size?: number;
  startTime?: number;
  templateName?: string;
  tenantContext?: SimpleListReportRequestTenantContext;
  static names(): { [key: string]: string } {
    return {
      cursor: 'Cursor',
      endTime: 'EndTime',
      size: 'Size',
      startTime: 'StartTime',
      templateName: 'TemplateName',
      tenantContext: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cursor: 'number',
      endTime: 'number',
      size: 'number',
      startTime: 'number',
      templateName: 'string',
      tenantContext: SimpleListReportRequestTenantContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SimpleListReportShrinkRequest extends $tea.Model {
  cursor?: number;
  endTime?: number;
  size?: number;
  startTime?: number;
  templateName?: string;
  tenantContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      cursor: 'Cursor',
      endTime: 'EndTime',
      size: 'Size',
      startTime: 'StartTime',
      templateName: 'TemplateName',
      tenantContextShrink: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cursor: 'number',
      endTime: 'number',
      size: 'number',
      startTime: 'number',
      templateName: 'string',
      tenantContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SimpleListReportResponseBody extends $tea.Model {
  dataList?: SimpleListReportResponseBodyDataList[];
  hasMore?: boolean;
  nextCursor?: number;
  requestId?: string;
  size?: number;
  static names(): { [key: string]: string } {
    return {
      dataList: 'dataList',
      hasMore: 'hasMore',
      nextCursor: 'nextCursor',
      requestId: 'requestId',
      size: 'size',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataList: { 'type': 'array', 'itemType': SimpleListReportResponseBodyDataList },
      hasMore: 'boolean',
      nextCursor: 'number',
      requestId: 'string',
      size: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SimpleListReportResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SimpleListReportResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SimpleListReportResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartCloudRecordHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: StartCloudRecordHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: StartCloudRecordHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartCloudRecordShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartCloudRecordRequest extends $tea.Model {
  mode?: string;
  smallWindowPosition?: string;
  tenantContext?: StartCloudRecordRequestTenantContext;
  conferenceId?: string;
  static names(): { [key: string]: string } {
    return {
      mode: 'Mode',
      smallWindowPosition: 'SmallWindowPosition',
      tenantContext: 'TenantContext',
      conferenceId: 'conferenceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      mode: 'string',
      smallWindowPosition: 'string',
      tenantContext: StartCloudRecordRequestTenantContext,
      conferenceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartCloudRecordShrinkRequest extends $tea.Model {
  mode?: string;
  smallWindowPosition?: string;
  tenantContextShrink?: string;
  conferenceId?: string;
  static names(): { [key: string]: string } {
    return {
      mode: 'Mode',
      smallWindowPosition: 'SmallWindowPosition',
      tenantContextShrink: 'TenantContext',
      conferenceId: 'conferenceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      mode: 'string',
      smallWindowPosition: 'string',
      tenantContextShrink: 'string',
      conferenceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartCloudRecordResponseBody extends $tea.Model {
  code?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'code',
      requestId: 'requestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartCloudRecordResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: StartCloudRecordResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: StartCloudRecordResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartInstanceHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: StartInstanceHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: StartInstanceHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartInstanceShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartInstanceRequest extends $tea.Model {
  appType?: string;
  departmentId?: string;
  formDataJson?: string;
  formUuid?: string;
  language?: string;
  processCode?: string;
  processData?: string;
  systemToken?: string;
  static names(): { [key: string]: string } {
    return {
      appType: 'AppType',
      departmentId: 'DepartmentId',
      formDataJson: 'FormDataJson',
      formUuid: 'FormUuid',
      language: 'Language',
      processCode: 'ProcessCode',
      processData: 'ProcessData',
      systemToken: 'SystemToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appType: 'string',
      departmentId: 'string',
      formDataJson: 'string',
      formUuid: 'string',
      language: 'string',
      processCode: 'string',
      processData: 'string',
      systemToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartInstanceResponseBody extends $tea.Model {
  requestId?: string;
  result?: string;
  vendorRequestId?: string;
  vendorType?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'requestId',
      result: 'result',
      vendorRequestId: 'vendorRequestId',
      vendorType: 'vendorType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: 'string',
      vendorRequestId: 'string',
      vendorType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartInstanceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: StartInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: StartInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StatisticsListByTypeReportHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: StatisticsListByTypeReportHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: StatisticsListByTypeReportHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StatisticsListByTypeReportShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StatisticsListByTypeReportRequest extends $tea.Model {
  offset?: number;
  reportId?: string;
  size?: number;
  tenantContext?: StatisticsListByTypeReportRequestTenantContext;
  type?: number;
  static names(): { [key: string]: string } {
    return {
      offset: 'Offset',
      reportId: 'ReportId',
      size: 'Size',
      tenantContext: 'TenantContext',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      offset: 'number',
      reportId: 'string',
      size: 'number',
      tenantContext: StatisticsListByTypeReportRequestTenantContext,
      type: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StatisticsListByTypeReportShrinkRequest extends $tea.Model {
  offset?: number;
  reportId?: string;
  size?: number;
  tenantContextShrink?: string;
  type?: number;
  static names(): { [key: string]: string } {
    return {
      offset: 'Offset',
      reportId: 'ReportId',
      size: 'Size',
      tenantContextShrink: 'TenantContext',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      offset: 'number',
      reportId: 'string',
      size: 'number',
      tenantContextShrink: 'string',
      type: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StatisticsListByTypeReportResponseBody extends $tea.Model {
  hasMore?: boolean;
  nextCursor?: number;
  requestId?: string;
  useridList?: string[];
  static names(): { [key: string]: string } {
    return {
      hasMore: 'hasMore',
      nextCursor: 'nextCursor',
      requestId: 'requestId',
      useridList: 'useridList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      hasMore: 'boolean',
      nextCursor: 'number',
      requestId: 'string',
      useridList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StatisticsListByTypeReportResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: StatisticsListByTypeReportResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: StatisticsListByTypeReportResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StatisticsReportHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: StatisticsReportHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: StatisticsReportHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StatisticsReportShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StatisticsReportRequest extends $tea.Model {
  reportId?: string;
  tenantContext?: StatisticsReportRequestTenantContext;
  static names(): { [key: string]: string } {
    return {
      reportId: 'ReportId',
      tenantContext: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      reportId: 'string',
      tenantContext: StatisticsReportRequestTenantContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StatisticsReportShrinkRequest extends $tea.Model {
  reportId?: string;
  tenantContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      reportId: 'ReportId',
      tenantContextShrink: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      reportId: 'string',
      tenantContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StatisticsReportResponseBody extends $tea.Model {
  commentNum?: number;
  commentUserNum?: number;
  likeNum?: number;
  readNum?: number;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      commentNum: 'commentNum',
      commentUserNum: 'commentUserNum',
      likeNum: 'likeNum',
      readNum: 'readNum',
      requestId: 'requestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commentNum: 'number',
      commentUserNum: 'number',
      likeNum: 'number',
      readNum: 'number',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StatisticsReportResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: StatisticsReportResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: StatisticsReportResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopCloudRecordHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: StopCloudRecordHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: StopCloudRecordHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopCloudRecordShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopCloudRecordRequest extends $tea.Model {
  tenantContext?: StopCloudRecordRequestTenantContext;
  conferenceId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantContext: 'TenantContext',
      conferenceId: 'conferenceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantContext: StopCloudRecordRequestTenantContext,
      conferenceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopCloudRecordShrinkRequest extends $tea.Model {
  tenantContextShrink?: string;
  conferenceId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantContextShrink: 'TenantContext',
      conferenceId: 'conferenceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantContextShrink: 'string',
      conferenceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopCloudRecordResponseBody extends $tea.Model {
  code?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'code',
      requestId: 'requestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopCloudRecordResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: StopCloudRecordResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: StopCloudRecordResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubscribeCalendarHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: SubscribeCalendarHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: SubscribeCalendarHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubscribeCalendarShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubscribeCalendarRequest extends $tea.Model {
  calendarId?: string;
  static names(): { [key: string]: string } {
    return {
      calendarId: 'CalendarId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      calendarId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubscribeCalendarResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'requestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubscribeCalendarResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SubscribeCalendarResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SubscribeCalendarResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SyncDingTypeHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: SyncDingTypeHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: SyncDingTypeHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SyncDingTypeShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SyncDingTypeRequest extends $tea.Model {
  dingType?: string;
  isDimission?: string;
  source?: string;
  tenantContext?: SyncDingTypeRequestTenantContext;
  workNo?: string;
  static names(): { [key: string]: string } {
    return {
      dingType: 'DingType',
      isDimission: 'IsDimission',
      source: 'Source',
      tenantContext: 'TenantContext',
      workNo: 'WorkNo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dingType: 'string',
      isDimission: 'string',
      source: 'string',
      tenantContext: SyncDingTypeRequestTenantContext,
      workNo: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SyncDingTypeShrinkRequest extends $tea.Model {
  dingType?: string;
  isDimission?: string;
  source?: string;
  tenantContextShrink?: string;
  workNo?: string;
  static names(): { [key: string]: string } {
    return {
      dingType: 'DingType',
      isDimission: 'IsDimission',
      source: 'Source',
      tenantContextShrink: 'TenantContext',
      workNo: 'WorkNo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dingType: 'string',
      isDimission: 'string',
      source: 'string',
      tenantContextShrink: 'string',
      workNo: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SyncDingTypeResponseBody extends $tea.Model {
  requestId?: string;
  success?: boolean;
  vendorRequestId?: string;
  vendorType?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'requestId',
      success: 'success',
      vendorRequestId: 'vendorRequestId',
      vendorType: 'vendorType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      success: 'boolean',
      vendorRequestId: 'string',
      vendorType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SyncDingTypeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SyncDingTypeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SyncDingTypeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TerminateInstanceHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: TerminateInstanceHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: TerminateInstanceHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TerminateInstanceShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TerminateInstanceRequest extends $tea.Model {
  appType?: string;
  language?: string;
  processInstanceId?: string;
  systemToken?: string;
  static names(): { [key: string]: string } {
    return {
      appType: 'AppType',
      language: 'Language',
      processInstanceId: 'ProcessInstanceId',
      systemToken: 'SystemToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appType: 'string',
      language: 'string',
      processInstanceId: 'string',
      systemToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TerminateInstanceResponseBody extends $tea.Model {
  requestId?: string;
  vendorRequestId?: string;
  vendorType?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'requestId',
      vendorRequestId: 'vendorRequestId',
      vendorType: 'vendorType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      vendorRequestId: 'string',
      vendorType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TerminateInstanceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: TerminateInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: TerminateInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnsubscribeCalendarHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: UnsubscribeCalendarHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: UnsubscribeCalendarHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnsubscribeCalendarShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnsubscribeCalendarRequest extends $tea.Model {
  calendarId?: string;
  static names(): { [key: string]: string } {
    return {
      calendarId: 'CalendarId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      calendarId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnsubscribeCalendarResponseBody extends $tea.Model {
  requestId?: string;
  result?: boolean;
  static names(): { [key: string]: string } {
    return {
      requestId: 'requestId',
      result: 'result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnsubscribeCalendarResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UnsubscribeCalendarResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UnsubscribeCalendarResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateFormDataHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: UpdateFormDataHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: UpdateFormDataHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateFormDataShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateFormDataRequest extends $tea.Model {
  appType?: string;
  formInstanceId?: string;
  language?: string;
  systemToken?: string;
  updateFormDataJson?: string;
  useLatestVersion?: boolean;
  static names(): { [key: string]: string } {
    return {
      appType: 'AppType',
      formInstanceId: 'FormInstanceId',
      language: 'Language',
      systemToken: 'SystemToken',
      updateFormDataJson: 'UpdateFormDataJson',
      useLatestVersion: 'UseLatestVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appType: 'string',
      formInstanceId: 'string',
      language: 'string',
      systemToken: 'string',
      updateFormDataJson: 'string',
      useLatestVersion: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateFormDataResponseBody extends $tea.Model {
  requestId?: string;
  vendorRequestId?: string;
  vendorType?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'requestId',
      vendorRequestId: 'vendorRequestId',
      vendorType: 'vendorType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      vendorRequestId: 'string',
      vendorType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateFormDataResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateFormDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateFormDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateInstanceHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: UpdateInstanceHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: UpdateInstanceHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateInstanceShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateInstanceRequest extends $tea.Model {
  appType?: string;
  language?: string;
  processInstanceId?: string;
  systemToken?: string;
  updateFormDataJson?: string;
  static names(): { [key: string]: string } {
    return {
      appType: 'AppType',
      language: 'Language',
      processInstanceId: 'ProcessInstanceId',
      systemToken: 'SystemToken',
      updateFormDataJson: 'UpdateFormDataJson',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appType: 'string',
      language: 'string',
      processInstanceId: 'string',
      systemToken: 'string',
      updateFormDataJson: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateInstanceResponseBody extends $tea.Model {
  requestId?: string;
  vendorRequestId?: string;
  vendorType?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'requestId',
      vendorRequestId: 'vendorRequestId',
      vendorType: 'vendorType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      vendorRequestId: 'string',
      vendorType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateInstanceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateLiveHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: UpdateLiveHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: UpdateLiveHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateLiveShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateLiveRequest extends $tea.Model {
  coverUrl?: string;
  introduction?: string;
  liveId?: string;
  preEndTime?: number;
  preStartTime?: number;
  tenantContext?: UpdateLiveRequestTenantContext;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      coverUrl: 'CoverUrl',
      introduction: 'Introduction',
      liveId: 'LiveId',
      preEndTime: 'PreEndTime',
      preStartTime: 'PreStartTime',
      tenantContext: 'TenantContext',
      title: 'Title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      coverUrl: 'string',
      introduction: 'string',
      liveId: 'string',
      preEndTime: 'number',
      preStartTime: 'number',
      tenantContext: UpdateLiveRequestTenantContext,
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateLiveShrinkRequest extends $tea.Model {
  coverUrl?: string;
  introduction?: string;
  liveId?: string;
  preEndTime?: number;
  preStartTime?: number;
  tenantContextShrink?: string;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      coverUrl: 'CoverUrl',
      introduction: 'Introduction',
      liveId: 'LiveId',
      preEndTime: 'PreEndTime',
      preStartTime: 'PreStartTime',
      tenantContextShrink: 'TenantContext',
      title: 'Title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      coverUrl: 'string',
      introduction: 'string',
      liveId: 'string',
      preEndTime: 'number',
      preStartTime: 'number',
      tenantContextShrink: 'string',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateLiveResponseBody extends $tea.Model {
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateLiveResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateLiveResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateLiveResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMeetingRoomHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: UpdateMeetingRoomHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: UpdateMeetingRoomHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMeetingRoomShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMeetingRoomRequest extends $tea.Model {
  enableCycleReservation?: boolean;
  groupId?: number;
  isvRoomId?: string;
  reservationAuthority?: UpdateMeetingRoomRequestReservationAuthority;
  roomCapacity?: number;
  roomId?: string;
  roomLabelIds?: number[];
  roomLocation?: UpdateMeetingRoomRequestRoomLocation;
  roomName?: string;
  roomPicture?: string;
  roomStatus?: number;
  tenantContext?: UpdateMeetingRoomRequestTenantContext;
  static names(): { [key: string]: string } {
    return {
      enableCycleReservation: 'EnableCycleReservation',
      groupId: 'GroupId',
      isvRoomId: 'IsvRoomId',
      reservationAuthority: 'ReservationAuthority',
      roomCapacity: 'RoomCapacity',
      roomId: 'RoomId',
      roomLabelIds: 'RoomLabelIds',
      roomLocation: 'RoomLocation',
      roomName: 'RoomName',
      roomPicture: 'RoomPicture',
      roomStatus: 'RoomStatus',
      tenantContext: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enableCycleReservation: 'boolean',
      groupId: 'number',
      isvRoomId: 'string',
      reservationAuthority: UpdateMeetingRoomRequestReservationAuthority,
      roomCapacity: 'number',
      roomId: 'string',
      roomLabelIds: { 'type': 'array', 'itemType': 'number' },
      roomLocation: UpdateMeetingRoomRequestRoomLocation,
      roomName: 'string',
      roomPicture: 'string',
      roomStatus: 'number',
      tenantContext: UpdateMeetingRoomRequestTenantContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMeetingRoomShrinkRequest extends $tea.Model {
  enableCycleReservation?: boolean;
  groupId?: number;
  isvRoomId?: string;
  reservationAuthorityShrink?: string;
  roomCapacity?: number;
  roomId?: string;
  roomLabelIdsShrink?: string;
  roomLocationShrink?: string;
  roomName?: string;
  roomPicture?: string;
  roomStatus?: number;
  tenantContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      enableCycleReservation: 'EnableCycleReservation',
      groupId: 'GroupId',
      isvRoomId: 'IsvRoomId',
      reservationAuthorityShrink: 'ReservationAuthority',
      roomCapacity: 'RoomCapacity',
      roomId: 'RoomId',
      roomLabelIdsShrink: 'RoomLabelIds',
      roomLocationShrink: 'RoomLocation',
      roomName: 'RoomName',
      roomPicture: 'RoomPicture',
      roomStatus: 'RoomStatus',
      tenantContextShrink: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enableCycleReservation: 'boolean',
      groupId: 'number',
      isvRoomId: 'string',
      reservationAuthorityShrink: 'string',
      roomCapacity: 'number',
      roomId: 'string',
      roomLabelIdsShrink: 'string',
      roomLocationShrink: 'string',
      roomName: 'string',
      roomPicture: 'string',
      roomStatus: 'number',
      tenantContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMeetingRoomResponseBody extends $tea.Model {
  result?: boolean;
  requestId?: string;
  vendorRequestId?: string;
  vendorType?: string;
  static names(): { [key: string]: string } {
    return {
      result: 'Result',
      requestId: 'requestId',
      vendorRequestId: 'vendorRequestId',
      vendorType: 'vendorType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      result: 'boolean',
      requestId: 'string',
      vendorRequestId: 'string',
      vendorType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMeetingRoomResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateMeetingRoomResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateMeetingRoomResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMeetingRoomGroupHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: UpdateMeetingRoomGroupHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: UpdateMeetingRoomGroupHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMeetingRoomGroupShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMeetingRoomGroupRequest extends $tea.Model {
  groupId?: string;
  groupName?: string;
  tenantContext?: UpdateMeetingRoomGroupRequestTenantContext;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      groupName: 'GroupName',
      tenantContext: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      groupName: 'string',
      tenantContext: UpdateMeetingRoomGroupRequestTenantContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMeetingRoomGroupShrinkRequest extends $tea.Model {
  groupId?: string;
  groupName?: string;
  tenantContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      groupName: 'GroupName',
      tenantContextShrink: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      groupName: 'string',
      tenantContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMeetingRoomGroupResponseBody extends $tea.Model {
  requestId?: string;
  result?: boolean;
  static names(): { [key: string]: string } {
    return {
      requestId: 'requestId',
      result: 'result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMeetingRoomGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateMeetingRoomGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateMeetingRoomGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRangeHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: UpdateRangeHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: UpdateRangeHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRangeShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRangeRequest extends $tea.Model {
  backgroundColors?: string[][];
  hyperlinks?: UpdateRangeRequestHyperlinks[][];
  numberFormat?: string;
  rangeAddress?: string;
  sheetId?: string;
  tenantContext?: UpdateRangeRequestTenantContext;
  values?: string[][];
  workbookId?: string;
  static names(): { [key: string]: string } {
    return {
      backgroundColors: 'BackgroundColors',
      hyperlinks: 'Hyperlinks',
      numberFormat: 'NumberFormat',
      rangeAddress: 'RangeAddress',
      sheetId: 'SheetId',
      tenantContext: 'TenantContext',
      values: 'Values',
      workbookId: 'WorkbookId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      backgroundColors: { 'type': 'array', 'itemType': { 'type': 'array', 'itemType': 'string' } },
      hyperlinks: { 'type': 'array', 'itemType': { 'type': 'array', 'itemType': UpdateRangeRequestHyperlinks } },
      numberFormat: 'string',
      rangeAddress: 'string',
      sheetId: 'string',
      tenantContext: UpdateRangeRequestTenantContext,
      values: { 'type': 'array', 'itemType': { 'type': 'array', 'itemType': 'string' } },
      workbookId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRangeShrinkRequest extends $tea.Model {
  backgroundColorsShrink?: string;
  hyperlinksShrink?: string;
  numberFormat?: string;
  rangeAddress?: string;
  sheetId?: string;
  tenantContextShrink?: string;
  valuesShrink?: string;
  workbookId?: string;
  static names(): { [key: string]: string } {
    return {
      backgroundColorsShrink: 'BackgroundColors',
      hyperlinksShrink: 'Hyperlinks',
      numberFormat: 'NumberFormat',
      rangeAddress: 'RangeAddress',
      sheetId: 'SheetId',
      tenantContextShrink: 'TenantContext',
      valuesShrink: 'Values',
      workbookId: 'WorkbookId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      backgroundColorsShrink: 'string',
      hyperlinksShrink: 'string',
      numberFormat: 'string',
      rangeAddress: 'string',
      sheetId: 'string',
      tenantContextShrink: 'string',
      valuesShrink: 'string',
      workbookId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRangeResponseBody extends $tea.Model {
  a1Notation?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      a1Notation: 'a1Notation',
      requestId: 'requestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      a1Notation: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRangeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateRangeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateRangeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateScheduleConfSettingsHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: UpdateScheduleConfSettingsHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: UpdateScheduleConfSettingsHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateScheduleConfSettingsShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateScheduleConfSettingsRequest extends $tea.Model {
  scheduleConfSettingModel?: UpdateScheduleConfSettingsRequestScheduleConfSettingModel;
  scheduleConferenceId?: string;
  tenantContext?: UpdateScheduleConfSettingsRequestTenantContext;
  static names(): { [key: string]: string } {
    return {
      scheduleConfSettingModel: 'ScheduleConfSettingModel',
      scheduleConferenceId: 'ScheduleConferenceId',
      tenantContext: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      scheduleConfSettingModel: UpdateScheduleConfSettingsRequestScheduleConfSettingModel,
      scheduleConferenceId: 'string',
      tenantContext: UpdateScheduleConfSettingsRequestTenantContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateScheduleConfSettingsShrinkRequest extends $tea.Model {
  scheduleConfSettingModelShrink?: string;
  scheduleConferenceId?: string;
  tenantContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      scheduleConfSettingModelShrink: 'ScheduleConfSettingModel',
      scheduleConferenceId: 'ScheduleConferenceId',
      tenantContextShrink: 'TenantContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      scheduleConfSettingModelShrink: 'string',
      scheduleConferenceId: 'string',
      tenantContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateScheduleConfSettingsResponseBody extends $tea.Model {
  requestId?: string;
  success?: boolean;
  vendorRequestId?: string;
  vendorType?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'requestId',
      success: 'success',
      vendorRequestId: 'vendorRequestId',
      vendorType: 'vendorType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      success: 'boolean',
      vendorRequestId: 'string',
      vendorType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateScheduleConfSettingsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateScheduleConfSettingsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateScheduleConfSettingsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateScheduleConferenceHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: UpdateScheduleConferenceHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: UpdateScheduleConferenceHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateScheduleConferenceShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateScheduleConferenceRequest extends $tea.Model {
  endTime?: number;
  scheduleConferenceId?: string;
  startTime?: number;
  tenantContext?: UpdateScheduleConferenceRequestTenantContext;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      scheduleConferenceId: 'ScheduleConferenceId',
      startTime: 'StartTime',
      tenantContext: 'TenantContext',
      title: 'Title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'number',
      scheduleConferenceId: 'string',
      startTime: 'number',
      tenantContext: UpdateScheduleConferenceRequestTenantContext,
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateScheduleConferenceShrinkRequest extends $tea.Model {
  endTime?: number;
  scheduleConferenceId?: string;
  startTime?: number;
  tenantContextShrink?: string;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      scheduleConferenceId: 'ScheduleConferenceId',
      startTime: 'StartTime',
      tenantContextShrink: 'TenantContext',
      title: 'Title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'number',
      scheduleConferenceId: 'string',
      startTime: 'number',
      tenantContextShrink: 'string',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateScheduleConferenceResponseBody extends $tea.Model {
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateScheduleConferenceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateScheduleConferenceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateScheduleConferenceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateStatusHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: UpdateStatusHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: UpdateStatusHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateStatusShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateStatusRequest extends $tea.Model {
  appType?: string;
  errorLines?: number[];
  importSequence?: string;
  language?: string;
  status?: string;
  systemToken?: string;
  static names(): { [key: string]: string } {
    return {
      appType: 'AppType',
      errorLines: 'ErrorLines',
      importSequence: 'ImportSequence',
      language: 'Language',
      status: 'Status',
      systemToken: 'SystemToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appType: 'string',
      errorLines: { 'type': 'array', 'itemType': 'number' },
      importSequence: 'string',
      language: 'string',
      status: 'string',
      systemToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateStatusShrinkRequest extends $tea.Model {
  appType?: string;
  errorLinesShrink?: string;
  importSequence?: string;
  language?: string;
  status?: string;
  systemToken?: string;
  static names(): { [key: string]: string } {
    return {
      appType: 'AppType',
      errorLinesShrink: 'ErrorLines',
      importSequence: 'ImportSequence',
      language: 'Language',
      status: 'Status',
      systemToken: 'SystemToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appType: 'string',
      errorLinesShrink: 'string',
      importSequence: 'string',
      language: 'string',
      status: 'string',
      systemToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateStatusResponseBody extends $tea.Model {
  requestId?: string;
  vendorRequestId?: string;
  vendorType?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'requestId',
      vendorRequestId: 'vendorRequestId',
      vendorType: 'vendorType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      vendorRequestId: 'string',
      vendorType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateStatusResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSubscribedCalendarsHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: UpdateSubscribedCalendarsHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: UpdateSubscribedCalendarsHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSubscribedCalendarsShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSubscribedCalendarsRequest extends $tea.Model {
  calendarId?: string;
  description?: string;
  managers?: string[];
  name?: string;
  subscribeScope?: UpdateSubscribedCalendarsRequestSubscribeScope;
  static names(): { [key: string]: string } {
    return {
      calendarId: 'CalendarId',
      description: 'Description',
      managers: 'Managers',
      name: 'Name',
      subscribeScope: 'SubscribeScope',
    };
  }

  static types(): { [key: string]: any } {
    return {
      calendarId: 'string',
      description: 'string',
      managers: { 'type': 'array', 'itemType': 'string' },
      name: 'string',
      subscribeScope: UpdateSubscribedCalendarsRequestSubscribeScope,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSubscribedCalendarsShrinkRequest extends $tea.Model {
  calendarId?: string;
  description?: string;
  managersShrink?: string;
  name?: string;
  subscribeScopeShrink?: string;
  static names(): { [key: string]: string } {
    return {
      calendarId: 'CalendarId',
      description: 'Description',
      managersShrink: 'Managers',
      name: 'Name',
      subscribeScopeShrink: 'SubscribeScope',
    };
  }

  static types(): { [key: string]: any } {
    return {
      calendarId: 'string',
      description: 'string',
      managersShrink: 'string',
      name: 'string',
      subscribeScopeShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSubscribedCalendarsResponseBody extends $tea.Model {
  requestId?: string;
  result?: boolean;
  static names(): { [key: string]: string } {
    return {
      requestId: 'requestId',
      result: 'result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSubscribedCalendarsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateSubscribedCalendarsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateSubscribedCalendarsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTodoTaskHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: UpdateTodoTaskHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: UpdateTodoTaskHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTodoTaskShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTodoTaskRequest extends $tea.Model {
  tenantContext?: UpdateTodoTaskRequestTenantContext;
  description?: string;
  done?: boolean;
  dueTime?: number;
  executorIds?: string[];
  participantIds?: string[];
  subject?: string;
  taskId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantContext: 'TenantContext',
      description: 'description',
      done: 'done',
      dueTime: 'dueTime',
      executorIds: 'executorIds',
      participantIds: 'participantIds',
      subject: 'subject',
      taskId: 'taskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantContext: UpdateTodoTaskRequestTenantContext,
      description: 'string',
      done: 'boolean',
      dueTime: 'number',
      executorIds: { 'type': 'array', 'itemType': 'string' },
      participantIds: { 'type': 'array', 'itemType': 'string' },
      subject: 'string',
      taskId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTodoTaskShrinkRequest extends $tea.Model {
  tenantContextShrink?: string;
  description?: string;
  done?: boolean;
  dueTime?: number;
  executorIdsShrink?: string;
  participantIdsShrink?: string;
  subject?: string;
  taskId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantContextShrink: 'TenantContext',
      description: 'description',
      done: 'done',
      dueTime: 'dueTime',
      executorIdsShrink: 'executorIds',
      participantIdsShrink: 'participantIds',
      subject: 'subject',
      taskId: 'taskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantContextShrink: 'string',
      description: 'string',
      done: 'boolean',
      dueTime: 'number',
      executorIdsShrink: 'string',
      participantIdsShrink: 'string',
      subject: 'string',
      taskId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTodoTaskResponseBody extends $tea.Model {
  requestId?: string;
  result?: boolean;
  static names(): { [key: string]: string } {
    return {
      requestId: 'requestId',
      result: 'result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTodoTaskResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateTodoTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateTodoTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTodoTaskExecutorStatusHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: UpdateTodoTaskExecutorStatusHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: UpdateTodoTaskExecutorStatusHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTodoTaskExecutorStatusShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTodoTaskExecutorStatusRequest extends $tea.Model {
  tenantContext?: UpdateTodoTaskExecutorStatusRequestTenantContext;
  executorStatusList?: UpdateTodoTaskExecutorStatusRequestExecutorStatusList[];
  operatorId?: string;
  taskId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantContext: 'TenantContext',
      executorStatusList: 'executorStatusList',
      operatorId: 'operatorId',
      taskId: 'taskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantContext: UpdateTodoTaskExecutorStatusRequestTenantContext,
      executorStatusList: { 'type': 'array', 'itemType': UpdateTodoTaskExecutorStatusRequestExecutorStatusList },
      operatorId: 'string',
      taskId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTodoTaskExecutorStatusShrinkRequest extends $tea.Model {
  tenantContextShrink?: string;
  executorStatusListShrink?: string;
  operatorId?: string;
  taskId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantContextShrink: 'TenantContext',
      executorStatusListShrink: 'executorStatusList',
      operatorId: 'operatorId',
      taskId: 'taskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantContextShrink: 'string',
      executorStatusListShrink: 'string',
      operatorId: 'string',
      taskId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTodoTaskExecutorStatusResponseBody extends $tea.Model {
  requestId?: string;
  result?: boolean;
  static names(): { [key: string]: string } {
    return {
      requestId: 'requestId',
      result: 'result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTodoTaskExecutorStatusResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateTodoTaskExecutorStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateTodoTaskExecutorStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateUserAvatarHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: UpdateUserAvatarHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: UpdateUserAvatarHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateUserAvatarShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateUserAvatarRequest extends $tea.Model {
  avatarMediaId?: string;
  static names(): { [key: string]: string } {
    return {
      avatarMediaId: 'AvatarMediaId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avatarMediaId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateUserAvatarResponseBody extends $tea.Model {
  errcode?: string;
  errmsg?: string;
  requestId?: string;
  vendorRequestId?: string;
  vendorType?: string;
  static names(): { [key: string]: string } {
    return {
      errcode: 'errcode',
      errmsg: 'errmsg',
      requestId: 'requestId',
      vendorRequestId: 'vendorRequestId',
      vendorType: 'vendorType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errcode: 'string',
      errmsg: 'string',
      requestId: 'string',
      vendorRequestId: 'string',
      vendorType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateUserAvatarResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateUserAvatarResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateUserAvatarResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWorkspaceDocMembersHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: UpdateWorkspaceDocMembersHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: UpdateWorkspaceDocMembersHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWorkspaceDocMembersShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWorkspaceDocMembersRequest extends $tea.Model {
  members?: UpdateWorkspaceDocMembersRequestMembers[];
  nodeId?: string;
  tenantContext?: UpdateWorkspaceDocMembersRequestTenantContext;
  workspaceId?: string;
  static names(): { [key: string]: string } {
    return {
      members: 'Members',
      nodeId: 'NodeId',
      tenantContext: 'TenantContext',
      workspaceId: 'WorkspaceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      members: { 'type': 'array', 'itemType': UpdateWorkspaceDocMembersRequestMembers },
      nodeId: 'string',
      tenantContext: UpdateWorkspaceDocMembersRequestTenantContext,
      workspaceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWorkspaceDocMembersShrinkRequest extends $tea.Model {
  membersShrink?: string;
  nodeId?: string;
  tenantContextShrink?: string;
  workspaceId?: string;
  static names(): { [key: string]: string } {
    return {
      membersShrink: 'Members',
      nodeId: 'NodeId',
      tenantContextShrink: 'TenantContext',
      workspaceId: 'WorkspaceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      membersShrink: 'string',
      nodeId: 'string',
      tenantContextShrink: 'string',
      workspaceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWorkspaceDocMembersResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'requestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWorkspaceDocMembersResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateWorkspaceDocMembersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateWorkspaceDocMembersResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWorkspaceMembersHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: UpdateWorkspaceMembersHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: UpdateWorkspaceMembersHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWorkspaceMembersShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWorkspaceMembersRequest extends $tea.Model {
  members?: UpdateWorkspaceMembersRequestMembers[];
  tenantContext?: UpdateWorkspaceMembersRequestTenantContext;
  workspaceId?: string;
  static names(): { [key: string]: string } {
    return {
      members: 'Members',
      tenantContext: 'TenantContext',
      workspaceId: 'WorkspaceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      members: { 'type': 'array', 'itemType': UpdateWorkspaceMembersRequestMembers },
      tenantContext: UpdateWorkspaceMembersRequestTenantContext,
      workspaceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWorkspaceMembersShrinkRequest extends $tea.Model {
  membersShrink?: string;
  tenantContextShrink?: string;
  workspaceId?: string;
  static names(): { [key: string]: string } {
    return {
      membersShrink: 'Members',
      tenantContextShrink: 'TenantContext',
      workspaceId: 'WorkspaceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      membersShrink: 'string',
      tenantContextShrink: 'string',
      workspaceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWorkspaceMembersResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'requestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWorkspaceMembersResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateWorkspaceMembersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateWorkspaceMembersResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UploadMediaHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: UploadMediaHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: UploadMediaHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UploadMediaShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UploadMediaRequest extends $tea.Model {
  tenantContext?: UploadMediaRequestTenantContext;
  mediaName?: string;
  mediaType?: string;
  orgId?: number;
  url?: string;
  static names(): { [key: string]: string } {
    return {
      tenantContext: 'TenantContext',
      mediaName: 'mediaName',
      mediaType: 'mediaType',
      orgId: 'orgId',
      url: 'url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantContext: UploadMediaRequestTenantContext,
      mediaName: 'string',
      mediaType: 'string',
      orgId: 'number',
      url: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UploadMediaShrinkRequest extends $tea.Model {
  tenantContextShrink?: string;
  mediaName?: string;
  mediaType?: string;
  orgId?: number;
  url?: string;
  static names(): { [key: string]: string } {
    return {
      tenantContextShrink: 'TenantContext',
      mediaName: 'mediaName',
      mediaType: 'mediaType',
      orgId: 'orgId',
      url: 'url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantContextShrink: 'string',
      mediaName: 'string',
      mediaType: 'string',
      orgId: 'number',
      url: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UploadMediaResponseBody extends $tea.Model {
  mediaId?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      mediaId: 'mediaId',
      requestId: 'requestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      mediaId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UploadMediaResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UploadMediaResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UploadMediaResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WearOrgHonorHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContext?: WearOrgHonorHeadersAccountContext;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContext: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContext: WearOrgHonorHeadersAccountContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WearOrgHonorShrinkHeaders extends $tea.Model {
  commonHeaders?: { [key: string]: string };
  accountContextShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonHeaders: 'commonHeaders',
      accountContextShrink: 'AccountContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      accountContextShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WearOrgHonorRequest extends $tea.Model {
  tenantContext?: WearOrgHonorRequestTenantContext;
  honorId?: string;
  orgId?: number;
  userId?: string;
  wear?: boolean;
  static names(): { [key: string]: string } {
    return {
      tenantContext: 'TenantContext',
      honorId: 'honorId',
      orgId: 'orgId',
      userId: 'userId',
      wear: 'wear',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantContext: WearOrgHonorRequestTenantContext,
      honorId: 'string',
      orgId: 'number',
      userId: 'string',
      wear: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WearOrgHonorShrinkRequest extends $tea.Model {
  tenantContextShrink?: string;
  honorId?: string;
  orgId?: number;
  userId?: string;
  wear?: boolean;
  static names(): { [key: string]: string } {
    return {
      tenantContextShrink: 'TenantContext',
      honorId: 'honorId',
      orgId: 'orgId',
      userId: 'userId',
      wear: 'wear',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantContextShrink: 'string',
      honorId: 'string',
      orgId: 'number',
      userId: 'string',
      wear: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WearOrgHonorResponseBody extends $tea.Model {
  content?: WearOrgHonorResponseBodyContent;
  errorCode?: string;
  errorCtx?: { [key: string]: any };
  errorMsg?: string;
  httpStatusCode?: number;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      content: 'content',
      errorCode: 'errorCode',
      errorCtx: 'errorCtx',
      errorMsg: 'errorMsg',
      httpStatusCode: 'httpStatusCode',
      requestId: 'requestId',
      success: 'success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: WearOrgHonorResponseBodyContent,
      errorCode: 'string',
      errorCtx: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      errorMsg: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WearOrgHonorResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: WearOrgHonorResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: WearOrgHonorResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddAttendeeHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddAttendeeRequestAttendeesToAdd extends $tea.Model {
  id?: string;
  isOptional?: boolean;
  static names(): { [key: string]: string } {
    return {
      id: 'id',
      isOptional: 'isOptional',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      isOptional: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddAttendeeResponseBodyContent extends $tea.Model {
  data?: any;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'any',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddMeetingRoomsHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddMeetingRoomsRequestMeetingRoomsToAdd extends $tea.Model {
  roomId?: string;
  static names(): { [key: string]: string } {
    return {
      roomId: 'RoomId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      roomId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddScenegroupMemberHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddWorkspaceHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddWorkspaceRequestOption extends $tea.Model {
  description?: string;
  teamId?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      teamId: 'TeamId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      teamId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddWorkspaceRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddWorkspaceResponseBodyWorkspaceIcon extends $tea.Model {
  type?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      type: 'Type',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      type: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddWorkspaceResponseBodyWorkspace extends $tea.Model {
  corpId?: string;
  cover?: string;
  createTime?: string;
  creatorId?: string;
  description?: string;
  icon?: AddWorkspaceResponseBodyWorkspaceIcon;
  modifiedTime?: string;
  modifierId?: string;
  name?: string;
  permissionRole?: string;
  rootNodeId?: string;
  teamId?: string;
  type?: string;
  url?: string;
  workspaceId?: string;
  static names(): { [key: string]: string } {
    return {
      corpId: 'CorpId',
      cover: 'Cover',
      createTime: 'CreateTime',
      creatorId: 'CreatorId',
      description: 'Description',
      icon: 'Icon',
      modifiedTime: 'ModifiedTime',
      modifierId: 'ModifierId',
      name: 'Name',
      permissionRole: 'PermissionRole',
      rootNodeId: 'RootNodeId',
      teamId: 'TeamId',
      type: 'Type',
      url: 'Url',
      workspaceId: 'WorkspaceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      corpId: 'string',
      cover: 'string',
      createTime: 'string',
      creatorId: 'string',
      description: 'string',
      icon: AddWorkspaceResponseBodyWorkspaceIcon,
      modifiedTime: 'string',
      modifierId: 'string',
      name: 'string',
      permissionRole: 'string',
      rootNodeId: 'string',
      teamId: 'string',
      type: 'string',
      url: 'string',
      workspaceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddWorkspaceDocMembersHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddWorkspaceDocMembersRequestMembers extends $tea.Model {
  memberId?: string;
  memberType?: string;
  roleType?: string;
  static names(): { [key: string]: string } {
    return {
      memberId: 'MemberId',
      memberType: 'MemberType',
      roleType: 'RoleType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      memberId: 'string',
      memberType: 'string',
      roleType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddWorkspaceDocMembersRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddWorkspaceMembersHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddWorkspaceMembersRequestMembers extends $tea.Model {
  memberId?: string;
  memberType?: string;
  roleType?: string;
  static names(): { [key: string]: string } {
    return {
      memberId: 'MemberId',
      memberType: 'MemberType',
      roleType: 'RoleType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      memberId: 'string',
      memberType: 'string',
      roleType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddWorkspaceMembersRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetFormDataByIdListHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetFormDataByIdListResponseBodyResultModifyUserName extends $tea.Model {
  nameInChinese?: string;
  nameInEnglish?: string;
  static names(): { [key: string]: string } {
    return {
      nameInChinese: 'NameInChinese',
      nameInEnglish: 'NameInEnglish',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nameInChinese: 'string',
      nameInEnglish: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetFormDataByIdListResponseBodyResultModifyUser extends $tea.Model {
  name?: BatchGetFormDataByIdListResponseBodyResultModifyUserName;
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: BatchGetFormDataByIdListResponseBodyResultModifyUserName,
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetFormDataByIdListResponseBodyResultOriginatorName extends $tea.Model {
  nameInChinese?: string;
  nameInEnglish?: string;
  static names(): { [key: string]: string } {
    return {
      nameInChinese: 'NameInChinese',
      nameInEnglish: 'NameInEnglish',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nameInChinese: 'string',
      nameInEnglish: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetFormDataByIdListResponseBodyResultOriginator extends $tea.Model {
  name?: BatchGetFormDataByIdListResponseBodyResultOriginatorName;
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: BatchGetFormDataByIdListResponseBodyResultOriginatorName,
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetFormDataByIdListResponseBodyResult extends $tea.Model {
  createTimeGMT?: string;
  creatorUserId?: string;
  formData?: { [key: string]: any };
  formInstanceId?: string;
  formUuid?: string;
  id?: number;
  instanceValue?: string;
  modifiedTimeGMT?: string;
  modifier?: string;
  modifyUser?: BatchGetFormDataByIdListResponseBodyResultModifyUser;
  originator?: BatchGetFormDataByIdListResponseBodyResultOriginator;
  sequence?: string;
  serialNumber?: string;
  title?: string;
  version?: number;
  static names(): { [key: string]: string } {
    return {
      createTimeGMT: 'CreateTimeGMT',
      creatorUserId: 'CreatorUserId',
      formData: 'FormData',
      formInstanceId: 'FormInstanceId',
      formUuid: 'FormUuid',
      id: 'Id',
      instanceValue: 'InstanceValue',
      modifiedTimeGMT: 'ModifiedTimeGMT',
      modifier: 'Modifier',
      modifyUser: 'ModifyUser',
      originator: 'Originator',
      sequence: 'Sequence',
      serialNumber: 'SerialNumber',
      title: 'Title',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTimeGMT: 'string',
      creatorUserId: 'string',
      formData: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      formInstanceId: 'string',
      formUuid: 'string',
      id: 'number',
      instanceValue: 'string',
      modifiedTimeGMT: 'string',
      modifier: 'string',
      modifyUser: BatchGetFormDataByIdListResponseBodyResultModifyUser,
      originator: BatchGetFormDataByIdListResponseBodyResultOriginator,
      sequence: 'string',
      serialNumber: 'string',
      title: 'string',
      version: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchRemovalByFormInstanceIdListHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchSaveFormDataHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchUpdateFormDataByInstanceIdHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchUpdateFormDataByInstanceMapHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelScheduleConferenceHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelScheduleConferenceRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CheckUserIsGroupMemberHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ClearHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ClearRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ClearDataHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ClearDataRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CommentListReportHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CommentListReportRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CommentListReportResponseBodyComments extends $tea.Model {
  content?: string;
  createTime?: string;
  userid?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      createTime: 'CreateTime',
      userid: 'Userid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      createTime: 'string',
      userid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDeliveryPlanHeadersAccountContext extends $tea.Model {
  userToken?: string;
  static names(): { [key: string]: string } {
    return {
      userToken: 'userToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      userToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDeliveryPlanRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEventHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEventRequestAttendees extends $tea.Model {
  id?: string;
  isOptional?: boolean;
  static names(): { [key: string]: string } {
    return {
      id: 'id',
      isOptional: 'isOptional',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      isOptional: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEventRequestEnd extends $tea.Model {
  date?: string;
  dateTime?: string;
  timeZone?: string;
  static names(): { [key: string]: string } {
    return {
      date: 'date',
      dateTime: 'dateTime',
      timeZone: 'timeZone',
    };
  }

  static types(): { [key: string]: any } {
    return {
      date: 'string',
      dateTime: 'string',
      timeZone: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEventRequestLocation extends $tea.Model {
  displayName?: string;
  static names(): { [key: string]: string } {
    return {
      displayName: 'displayName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      displayName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEventRequestOnlineMeetingInfo extends $tea.Model {
  type?: string;
  static names(): { [key: string]: string } {
    return {
      type: 'type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEventRequestRecurrencePattern extends $tea.Model {
  dayOfMonth?: number;
  daysOfWeek?: string;
  index?: string;
  interval?: number;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      dayOfMonth: 'dayOfMonth',
      daysOfWeek: 'daysOfWeek',
      index: 'index',
      interval: 'interval',
      type: 'type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dayOfMonth: 'number',
      daysOfWeek: 'string',
      index: 'string',
      interval: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEventRequestRecurrenceRange extends $tea.Model {
  endDate?: string;
  numberOfOccurrences?: number;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      endDate: 'endDate',
      numberOfOccurrences: 'numberOfOccurrences',
      type: 'type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endDate: 'string',
      numberOfOccurrences: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEventRequestRecurrence extends $tea.Model {
  pattern?: CreateEventRequestRecurrencePattern;
  range?: CreateEventRequestRecurrenceRange;
  static names(): { [key: string]: string } {
    return {
      pattern: 'pattern',
      range: 'range',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pattern: CreateEventRequestRecurrencePattern,
      range: CreateEventRequestRecurrenceRange,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEventRequestReminders extends $tea.Model {
  method?: string;
  minutes?: number;
  static names(): { [key: string]: string } {
    return {
      method: 'method',
      minutes: 'minutes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      method: 'string',
      minutes: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEventRequestRichTextDescription extends $tea.Model {
  text?: string;
  static names(): { [key: string]: string } {
    return {
      text: 'text',
    };
  }

  static types(): { [key: string]: any } {
    return {
      text: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEventRequestUiConfigs extends $tea.Model {
  uiName?: string;
  uiStatus?: string;
  static names(): { [key: string]: string } {
    return {
      uiName: 'uiName',
      uiStatus: 'uiStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      uiName: 'string',
      uiStatus: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEventRequestStart extends $tea.Model {
  date?: string;
  dateTime?: string;
  timeZone?: string;
  static names(): { [key: string]: string } {
    return {
      date: 'date',
      dateTime: 'dateTime',
      timeZone: 'timeZone',
    };
  }

  static types(): { [key: string]: any } {
    return {
      date: 'string',
      dateTime: 'string',
      timeZone: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEventResponseBodyAttendees extends $tea.Model {
  displayName?: string;
  isOptional?: boolean;
  responseStatus?: string;
  self?: boolean;
  static names(): { [key: string]: string } {
    return {
      displayName: 'DisplayName',
      isOptional: 'IsOptional',
      responseStatus: 'ResponseStatus',
      self: 'Self',
    };
  }

  static types(): { [key: string]: any } {
    return {
      displayName: 'string',
      isOptional: 'boolean',
      responseStatus: 'string',
      self: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEventResponseBodyEnd extends $tea.Model {
  date?: string;
  dateTime?: string;
  timeZone?: string;
  static names(): { [key: string]: string } {
    return {
      date: 'Date',
      dateTime: 'DateTime',
      timeZone: 'TimeZone',
    };
  }

  static types(): { [key: string]: any } {
    return {
      date: 'string',
      dateTime: 'string',
      timeZone: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEventResponseBodyLocation extends $tea.Model {
  displayName?: string;
  static names(): { [key: string]: string } {
    return {
      displayName: 'DisplayName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      displayName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEventResponseBodyOnlineMeetingInfo extends $tea.Model {
  conferenceId?: string;
  extraInfo?: { [key: string]: any };
  type?: string;
  url?: string;
  static names(): { [key: string]: string } {
    return {
      conferenceId: 'ConferenceId',
      extraInfo: 'ExtraInfo',
      type: 'Type',
      url: 'Url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      conferenceId: 'string',
      extraInfo: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      type: 'string',
      url: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEventResponseBodyOrganizer extends $tea.Model {
  displayName?: string;
  id?: string;
  responseStatus?: string;
  self?: boolean;
  static names(): { [key: string]: string } {
    return {
      displayName: 'DisplayName',
      id: 'Id',
      responseStatus: 'ResponseStatus',
      self: 'Self',
    };
  }

  static types(): { [key: string]: any } {
    return {
      displayName: 'string',
      id: 'string',
      responseStatus: 'string',
      self: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEventResponseBodyRecurrencePattern extends $tea.Model {
  dayOfMonth?: number;
  daysOfWeek?: string;
  index?: string;
  interval?: number;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      dayOfMonth: 'DayOfMonth',
      daysOfWeek: 'DaysOfWeek',
      index: 'Index',
      interval: 'Interval',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dayOfMonth: 'number',
      daysOfWeek: 'string',
      index: 'string',
      interval: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEventResponseBodyRecurrenceRange extends $tea.Model {
  endDate?: string;
  numberOfOccurrences?: number;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      endDate: 'EndDate',
      numberOfOccurrences: 'NumberOfOccurrences',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endDate: 'string',
      numberOfOccurrences: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEventResponseBodyRecurrence extends $tea.Model {
  pattern?: CreateEventResponseBodyRecurrencePattern;
  range?: CreateEventResponseBodyRecurrenceRange;
  static names(): { [key: string]: string } {
    return {
      pattern: 'Pattern',
      range: 'Range',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pattern: CreateEventResponseBodyRecurrencePattern,
      range: CreateEventResponseBodyRecurrenceRange,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEventResponseBodyReminders extends $tea.Model {
  method?: string;
  minutes?: string;
  static names(): { [key: string]: string } {
    return {
      method: 'Method',
      minutes: 'Minutes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      method: 'string',
      minutes: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEventResponseBodyRichTextDescription extends $tea.Model {
  text?: string;
  static names(): { [key: string]: string } {
    return {
      text: 'text',
    };
  }

  static types(): { [key: string]: any } {
    return {
      text: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEventResponseBodyStart extends $tea.Model {
  date?: string;
  dateTime?: string;
  timeZone?: string;
  static names(): { [key: string]: string } {
    return {
      date: 'Date',
      dateTime: 'DateTime',
      timeZone: 'TimeZone',
    };
  }

  static types(): { [key: string]: any } {
    return {
      date: 'string',
      dateTime: 'string',
      timeZone: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEventResponseBodyUiConfigs extends $tea.Model {
  uiName?: string;
  uiStatus?: string;
  static names(): { [key: string]: string } {
    return {
      uiName: 'UiName',
      uiStatus: 'UiStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      uiName: 'string',
      uiStatus: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLiveHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLiveRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMeetingRoomHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMeetingRoomRequestReservationAuthorityAuthorizedMembers extends $tea.Model {
  memberId?: string;
  memberName?: string;
  memberType?: string;
  static names(): { [key: string]: string } {
    return {
      memberId: 'MemberId',
      memberName: 'MemberName',
      memberType: 'MemberType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      memberId: 'string',
      memberName: 'string',
      memberType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMeetingRoomRequestReservationAuthority extends $tea.Model {
  authorizedMembers?: CreateMeetingRoomRequestReservationAuthorityAuthorizedMembers[];
  static names(): { [key: string]: string } {
    return {
      authorizedMembers: 'AuthorizedMembers',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authorizedMembers: { 'type': 'array', 'itemType': CreateMeetingRoomRequestReservationAuthorityAuthorizedMembers },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMeetingRoomRequestRoomLocation extends $tea.Model {
  desc?: string;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      desc: 'Desc',
      title: 'Title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      desc: 'string',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMeetingRoomRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMeetingRoomGroupHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMeetingRoomGroupRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateFormDataHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrgHonorTemplateHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrgHonorTemplateRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePersonalTodoTaskHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePersonalTodoTaskRequestNotifyConfigs extends $tea.Model {
  dingNotify?: string;
  static names(): { [key: string]: string } {
    return {
      dingNotify: 'DingNotify',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dingNotify: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePersonalTodoTaskRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateReportHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateReportRequestContents extends $tea.Model {
  content?: string;
  contentType?: string;
  key?: string;
  sort?: number;
  type?: number;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      contentType: 'ContentType',
      key: 'Key',
      sort: 'Sort',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      contentType: 'string',
      key: 'string',
      sort: 'number',
      type: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateReportRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateScenegroupHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateScheduleConferenceHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateScheduleConferenceRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSearchDomeHeadersAccountContext extends $tea.Model {
  userToken?: string;
  static names(): { [key: string]: string } {
    return {
      userToken: 'userToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      userToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSearchDomeRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSearchKeywordHeadersAccountContext extends $tea.Model {
  userToken?: string;
  static names(): { [key: string]: string } {
    return {
      userToken: 'userToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      userToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSearchKeywordRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSheetHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSheetRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSubscribedCalendarHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSubscribedCalendarRequestSubscribeScope extends $tea.Model {
  userIds?: string[];
  static names(): { [key: string]: string } {
    return {
      userIds: 'UserIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      userIds: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTodoTaskHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTodoTaskRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTodoTaskRequestContentFieldList extends $tea.Model {
  fieldKey?: string;
  fieldValue?: string;
  static names(): { [key: string]: string } {
    return {
      fieldKey: 'fieldKey',
      fieldValue: 'fieldValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fieldKey: 'string',
      fieldValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTodoTaskRequestDetailUrl extends $tea.Model {
  appUrl?: string;
  pcUrl?: string;
  static names(): { [key: string]: string } {
    return {
      appUrl: 'appUrl',
      pcUrl: 'pcUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appUrl: 'string',
      pcUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTodoTaskRequestNotifyConfigs extends $tea.Model {
  dingNotify?: string;
  static names(): { [key: string]: string } {
    return {
      dingNotify: 'dingNotify',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dingNotify: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTodoTaskResponseBodyContentFieldList extends $tea.Model {
  fieldKey?: string;
  fieldValue?: string;
  static names(): { [key: string]: string } {
    return {
      fieldKey: 'fieldKey',
      fieldValue: 'fieldValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fieldKey: 'string',
      fieldValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTodoTaskResponseBodyDetailUrl extends $tea.Model {
  appUrl?: string;
  pcUrl?: string;
  static names(): { [key: string]: string } {
    return {
      appUrl: 'appUrl',
      pcUrl: 'pcUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appUrl: 'string',
      pcUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTodoTaskResponseBodyNotifyConfigs extends $tea.Model {
  dingNotify?: string;
  static names(): { [key: string]: string } {
    return {
      dingNotify: 'dingNotify',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dingNotify: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateVideoConferenceHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWorkspaceHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWorkspaceRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWorkspaceDocHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWorkspaceDocRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteColumnsHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteColumnsRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEventHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEventResponseBodyContent extends $tea.Model {
  data?: any;
  static names(): { [key: string]: string } {
    return {
      data: 'data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'any',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteFormDataHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteInstanceHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLiveRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMeetingRoomHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMeetingRoomRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMeetingRoomGroupHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMeetingRoomGroupRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRowsHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRowsRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteScenegroupMemberHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSheetHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSheetRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSubscribedCalendarHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTodoTaskHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTodoTaskRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWorkspaceDocMembersHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWorkspaceDocMembersRequestMembers extends $tea.Model {
  memberId?: string;
  memberType?: string;
  static names(): { [key: string]: string } {
    return {
      memberId: 'MemberId',
      memberType: 'MemberType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      memberId: 'string',
      memberType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWorkspaceDocMembersRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWorkspaceMembersHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWorkspaceMembersRequestMembers extends $tea.Model {
  memberId?: string;
  memberType?: string;
  static names(): { [key: string]: string } {
    return {
      memberId: 'MemberId',
      memberType: 'MemberType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      memberId: 'string',
      memberType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWorkspaceMembersRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExecuteBatchTaskHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExecutePlatformTaskHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExecuteTaskHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExpandGroupCapacityHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExpandGroupCapacityRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetActivityListHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetActivityListResponseBodyResult extends $tea.Model {
  activityId?: string;
  activityName?: string;
  activityNameInEnglish?: string;
  static names(): { [key: string]: string } {
    return {
      activityId: 'ActivityId',
      activityName: 'ActivityName',
      activityNameInEnglish: 'ActivityNameInEnglish',
    };
  }

  static types(): { [key: string]: any } {
    return {
      activityId: 'string',
      activityName: 'string',
      activityNameInEnglish: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAllSheetsHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAllSheetsRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAllSheetsResponseBodyValue extends $tea.Model {
  id?: string;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetConversaionSpaceHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetConversaionSpaceRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetConversaionSpaceResponseBodySpace extends $tea.Model {
  corpId?: string;
  createTime?: string;
  modifiedTime?: string;
  spaceId?: string;
  static names(): { [key: string]: string } {
    return {
      corpId: 'CorpId',
      createTime: 'CreateTime',
      modifiedTime: 'ModifiedTime',
      spaceId: 'SpaceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      corpId: 'string',
      createTime: 'string',
      modifiedTime: 'string',
      spaceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCorpAccomplishmentTasksHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCorpAccomplishmentTasksResponseBodyData extends $tea.Model {
  activeTimeGMT?: string;
  actualActionerId?: string;
  appType?: string;
  createTimeGMT?: string;
  finishTimeGMT?: string;
  originatorEmail?: string;
  originatorId?: string;
  originatorName?: string;
  originatorNameInEnglish?: string;
  originatorNickName?: string;
  originatorNickNameInEnglish?: string;
  originatorPhoto?: string;
  outResult?: string;
  outResultName?: string;
  processInstanceId?: string;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      activeTimeGMT: 'ActiveTimeGMT',
      actualActionerId: 'ActualActionerId',
      appType: 'AppType',
      createTimeGMT: 'CreateTimeGMT',
      finishTimeGMT: 'FinishTimeGMT',
      originatorEmail: 'OriginatorEmail',
      originatorId: 'OriginatorId',
      originatorName: 'OriginatorName',
      originatorNameInEnglish: 'OriginatorNameInEnglish',
      originatorNickName: 'OriginatorNickName',
      originatorNickNameInEnglish: 'OriginatorNickNameInEnglish',
      originatorPhoto: 'OriginatorPhoto',
      outResult: 'OutResult',
      outResultName: 'OutResultName',
      processInstanceId: 'ProcessInstanceId',
      title: 'Title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      activeTimeGMT: 'string',
      actualActionerId: 'string',
      appType: 'string',
      createTimeGMT: 'string',
      finishTimeGMT: 'string',
      originatorEmail: 'string',
      originatorId: 'string',
      originatorName: 'string',
      originatorNameInEnglish: 'string',
      originatorNickName: 'string',
      originatorNickNameInEnglish: 'string',
      originatorPhoto: 'string',
      outResult: 'string',
      outResultName: 'string',
      processInstanceId: 'string',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCorpTasksHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCorpTasksResponseBodyData extends $tea.Model {
  activeTimeGMT?: string;
  actualActionerId?: string;
  appType?: string;
  createTimeGMT?: string;
  finishTimeGMT?: string;
  originatorEmail?: string;
  originatorId?: string;
  originatorName?: string;
  originatorNameInEnglish?: string;
  originatorNickName?: string;
  originatorNickNameEn?: string;
  originatorNickNameInEnglish?: string;
  originatorPhoto?: string;
  outResult?: string;
  outResultName?: string;
  processInstanceId?: string;
  status?: string;
  taskId?: string;
  taskType?: string;
  title?: string;
  titleInEnglish?: string;
  static names(): { [key: string]: string } {
    return {
      activeTimeGMT: 'ActiveTimeGMT',
      actualActionerId: 'ActualActionerId',
      appType: 'AppType',
      createTimeGMT: 'CreateTimeGMT',
      finishTimeGMT: 'FinishTimeGMT',
      originatorEmail: 'OriginatorEmail',
      originatorId: 'OriginatorId',
      originatorName: 'OriginatorName',
      originatorNameInEnglish: 'OriginatorNameInEnglish',
      originatorNickName: 'OriginatorNickName',
      originatorNickNameEn: 'OriginatorNickNameEn',
      originatorNickNameInEnglish: 'OriginatorNickNameInEnglish',
      originatorPhoto: 'OriginatorPhoto',
      outResult: 'OutResult',
      outResultName: 'OutResultName',
      processInstanceId: 'ProcessInstanceId',
      status: 'Status',
      taskId: 'TaskId',
      taskType: 'TaskType',
      title: 'Title',
      titleInEnglish: 'TitleInEnglish',
    };
  }

  static types(): { [key: string]: any } {
    return {
      activeTimeGMT: 'string',
      actualActionerId: 'string',
      appType: 'string',
      createTimeGMT: 'string',
      finishTimeGMT: 'string',
      originatorEmail: 'string',
      originatorId: 'string',
      originatorName: 'string',
      originatorNameInEnglish: 'string',
      originatorNickName: 'string',
      originatorNickNameEn: 'string',
      originatorNickNameInEnglish: 'string',
      originatorPhoto: 'string',
      outResult: 'string',
      outResultName: 'string',
      processInstanceId: 'string',
      status: 'string',
      taskId: 'string',
      taskType: 'string',
      title: 'string',
      titleInEnglish: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDocContentHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDocContentRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEventHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEventResponseBodyAttendees extends $tea.Model {
  displayName?: string;
  id?: string;
  isOptional?: boolean;
  responseStatus?: string;
  self?: boolean;
  static names(): { [key: string]: string } {
    return {
      displayName: 'DisplayName',
      id: 'Id',
      isOptional: 'IsOptional',
      responseStatus: 'ResponseStatus',
      self: 'Self',
    };
  }

  static types(): { [key: string]: any } {
    return {
      displayName: 'string',
      id: 'string',
      isOptional: 'boolean',
      responseStatus: 'string',
      self: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEventResponseBodyCategories extends $tea.Model {
  displayName?: string;
  static names(): { [key: string]: string } {
    return {
      displayName: 'DisplayName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      displayName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEventResponseBodyEnd extends $tea.Model {
  date?: string;
  dateTime?: string;
  timeZone?: string;
  static names(): { [key: string]: string } {
    return {
      date: 'Date',
      dateTime: 'DateTime',
      timeZone: 'TimeZone',
    };
  }

  static types(): { [key: string]: any } {
    return {
      date: 'string',
      dateTime: 'string',
      timeZone: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEventResponseBodyExtendedPropertiesSharedProperties extends $tea.Model {
  belongCorpId?: string;
  sourceOpenCid?: string;
  static names(): { [key: string]: string } {
    return {
      belongCorpId: 'BelongCorpId',
      sourceOpenCid: 'SourceOpenCid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      belongCorpId: 'string',
      sourceOpenCid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEventResponseBodyExtendedProperties extends $tea.Model {
  sharedProperties?: GetEventResponseBodyExtendedPropertiesSharedProperties;
  static names(): { [key: string]: string } {
    return {
      sharedProperties: 'SharedProperties',
    };
  }

  static types(): { [key: string]: any } {
    return {
      sharedProperties: GetEventResponseBodyExtendedPropertiesSharedProperties,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEventResponseBodyLocation extends $tea.Model {
  displayName?: string;
  meetingRooms?: string[];
  static names(): { [key: string]: string } {
    return {
      displayName: 'DisplayName',
      meetingRooms: 'MeetingRooms',
    };
  }

  static types(): { [key: string]: any } {
    return {
      displayName: 'string',
      meetingRooms: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEventResponseBodyMeetingRooms extends $tea.Model {
  displayName?: string;
  responseStatus?: string;
  roomId?: string;
  static names(): { [key: string]: string } {
    return {
      displayName: 'DisplayName',
      responseStatus: 'ResponseStatus',
      roomId: 'RoomId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      displayName: 'string',
      responseStatus: 'string',
      roomId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEventResponseBodyOnlineMeetingInfo extends $tea.Model {
  conferenceId?: string;
  extraInfo?: { [key: string]: any };
  type?: string;
  url?: string;
  static names(): { [key: string]: string } {
    return {
      conferenceId: 'ConferenceId',
      extraInfo: 'ExtraInfo',
      type: 'Type',
      url: 'Url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      conferenceId: 'string',
      extraInfo: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      type: 'string',
      url: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEventResponseBodyOrganizer extends $tea.Model {
  displayName?: string;
  id?: string;
  responseStatus?: string;
  self?: boolean;
  static names(): { [key: string]: string } {
    return {
      displayName: 'DisplayName',
      id: 'Id',
      responseStatus: 'ResponseStatus',
      self: 'Self',
    };
  }

  static types(): { [key: string]: any } {
    return {
      displayName: 'string',
      id: 'string',
      responseStatus: 'string',
      self: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEventResponseBodyOriginStart extends $tea.Model {
  dateTime?: string;
  static names(): { [key: string]: string } {
    return {
      dateTime: 'DateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dateTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEventResponseBodyRecurrencePattern extends $tea.Model {
  dayOfMonth?: number;
  daysOfWeek?: string;
  index?: string;
  interval?: number;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      dayOfMonth: 'DayOfMonth',
      daysOfWeek: 'DaysOfWeek',
      index: 'Index',
      interval: 'Interval',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dayOfMonth: 'number',
      daysOfWeek: 'string',
      index: 'string',
      interval: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEventResponseBodyRecurrenceRange extends $tea.Model {
  endDate?: string;
  numberOfOccurrences?: number;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      endDate: 'EndDate',
      numberOfOccurrences: 'NumberOfOccurrences',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endDate: 'string',
      numberOfOccurrences: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEventResponseBodyRecurrence extends $tea.Model {
  pattern?: GetEventResponseBodyRecurrencePattern;
  range?: GetEventResponseBodyRecurrenceRange;
  static names(): { [key: string]: string } {
    return {
      pattern: 'Pattern',
      range: 'Range',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pattern: GetEventResponseBodyRecurrencePattern,
      range: GetEventResponseBodyRecurrenceRange,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEventResponseBodyReminders extends $tea.Model {
  method?: string;
  minutes?: string;
  static names(): { [key: string]: string } {
    return {
      method: 'Method',
      minutes: 'Minutes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      method: 'string',
      minutes: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEventResponseBodyRichTextDescription extends $tea.Model {
  text?: string;
  static names(): { [key: string]: string } {
    return {
      text: 'Text',
    };
  }

  static types(): { [key: string]: any } {
    return {
      text: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEventResponseBodyStart extends $tea.Model {
  date?: string;
  dateTime?: string;
  timeZone?: string;
  static names(): { [key: string]: string } {
    return {
      date: 'Date',
      dateTime: 'DateTime',
      timeZone: 'TimeZone',
    };
  }

  static types(): { [key: string]: any } {
    return {
      date: 'string',
      dateTime: 'string',
      timeZone: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFieldDefByUuidHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFieldDefByUuidResponseBodyResult extends $tea.Model {
  behavior?: string;
  children?: string;
  componentName?: string;
  fieldId?: string;
  label?: any;
  props?: any;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      behavior: 'Behavior',
      children: 'Children',
      componentName: 'ComponentName',
      fieldId: 'FieldId',
      label: 'Label',
      props: 'Props',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      behavior: 'string',
      children: 'string',
      componentName: 'string',
      fieldId: 'string',
      label: 'any',
      props: 'any',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFileDownloadInfoHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFileDownloadInfoRequestOption extends $tea.Model {
  preferIntranet?: boolean;
  version?: number;
  static names(): { [key: string]: string } {
    return {
      preferIntranet: 'PreferIntranet',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      preferIntranet: 'boolean',
      version: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFileDownloadInfoRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFileDownloadInfoResponseBodyHeaderSignatureInfo extends $tea.Model {
  expirationSeconds?: number;
  headers?: { [key: string]: string };
  internalResourceUrls?: string[];
  region?: string;
  resourceUrls?: string[];
  static names(): { [key: string]: string } {
    return {
      expirationSeconds: 'ExpirationSeconds',
      headers: 'Headers',
      internalResourceUrls: 'InternalResourceUrls',
      region: 'Region',
      resourceUrls: 'ResourceUrls',
    };
  }

  static types(): { [key: string]: any } {
    return {
      expirationSeconds: 'number',
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      internalResourceUrls: { 'type': 'array', 'itemType': 'string' },
      region: 'string',
      resourceUrls: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFormComponentDefinitionListHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFormComponentDefinitionListResponseBodyResult extends $tea.Model {
  componentName?: string;
  fieldId?: string;
  label?: string;
  parentId?: string;
  static names(): { [key: string]: string } {
    return {
      componentName: 'ComponentName',
      fieldId: 'FieldId',
      label: 'Label',
      parentId: 'ParentId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      componentName: 'string',
      fieldId: 'string',
      label: 'string',
      parentId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFormDataByIDHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFormDataByIDResponseBodyOriginatorName extends $tea.Model {
  nameInChinese?: string;
  nameInEnglish?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      nameInChinese: 'NameInChinese',
      nameInEnglish: 'NameInEnglish',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nameInChinese: 'string',
      nameInEnglish: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFormDataByIDResponseBodyOriginator extends $tea.Model {
  departmentName?: string;
  email?: string;
  name?: GetFormDataByIDResponseBodyOriginatorName;
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      departmentName: 'DepartmentName',
      email: 'Email',
      name: 'Name',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      departmentName: 'string',
      email: 'string',
      name: GetFormDataByIDResponseBodyOriginatorName,
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFormListInAppHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFormListInAppResponseBodyDataTitle extends $tea.Model {
  enUS?: string;
  zhCN?: string;
  static names(): { [key: string]: string } {
    return {
      enUS: 'EnUS',
      zhCN: 'ZhCN',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enUS: 'string',
      zhCN: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFormListInAppResponseBodyData extends $tea.Model {
  creator?: string;
  formType?: string;
  formUuid?: string;
  gmtCreate?: string;
  title?: GetFormListInAppResponseBodyDataTitle;
  static names(): { [key: string]: string } {
    return {
      creator: 'Creator',
      formType: 'FormType',
      formUuid: 'FormUuid',
      gmtCreate: 'GmtCreate',
      title: 'Title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creator: 'string',
      formType: 'string',
      formUuid: 'string',
      gmtCreate: 'string',
      title: GetFormListInAppResponseBodyDataTitle,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInnerGroupMembersHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstanceByIdHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstanceByIdResponseBodyActionExecutorName extends $tea.Model {
  nameInChinese?: string;
  nameInEnglish?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      nameInChinese: 'NameInChinese',
      nameInEnglish: 'NameInEnglish',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nameInChinese: 'string',
      nameInEnglish: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstanceByIdResponseBodyActionExecutor extends $tea.Model {
  deptName?: string;
  email?: string;
  name?: GetInstanceByIdResponseBodyActionExecutorName;
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      deptName: 'DeptName',
      email: 'Email',
      name: 'Name',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deptName: 'string',
      email: 'string',
      name: GetInstanceByIdResponseBodyActionExecutorName,
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstanceByIdResponseBodyOriginatorName extends $tea.Model {
  nameInChinese?: string;
  nameInEnglish?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      nameInChinese: 'NameInChinese',
      nameInEnglish: 'NameInEnglish',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nameInChinese: 'string',
      nameInEnglish: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstanceByIdResponseBodyOriginator extends $tea.Model {
  deptName?: string;
  email?: string;
  name?: GetInstanceByIdResponseBodyOriginatorName;
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      deptName: 'DeptName',
      email: 'Email',
      name: 'Name',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deptName: 'string',
      email: 'string',
      name: GetInstanceByIdResponseBodyOriginatorName,
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstanceIdListHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstancesHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstancesResponseBodyDataActionExecutorName extends $tea.Model {
  nameInChinese?: string;
  nameInEnglish?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      nameInChinese: 'NameInChinese',
      nameInEnglish: 'NameInEnglish',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nameInChinese: 'string',
      nameInEnglish: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstancesResponseBodyDataActionExecutor extends $tea.Model {
  deptName?: string;
  email?: string;
  name?: GetInstancesResponseBodyDataActionExecutorName;
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      deptName: 'DeptName',
      email: 'Email',
      name: 'Name',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deptName: 'string',
      email: 'string',
      name: GetInstancesResponseBodyDataActionExecutorName,
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstancesResponseBodyDataOriginatorName extends $tea.Model {
  nameInChinese?: string;
  nameInEnglish?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      nameInChinese: 'NameInChinese',
      nameInEnglish: 'NameInEnglish',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nameInChinese: 'string',
      nameInEnglish: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstancesResponseBodyDataOriginator extends $tea.Model {
  deptName?: string;
  email?: string;
  name?: GetInstancesResponseBodyDataOriginatorName;
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      deptName: 'DeptName',
      email: 'Email',
      name: 'Name',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deptName: 'string',
      email: 'string',
      name: GetInstancesResponseBodyDataOriginatorName,
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstancesResponseBodyData extends $tea.Model {
  actionExecutor?: GetInstancesResponseBodyDataActionExecutor[];
  approvedResult?: string;
  createTimeGMT?: string;
  data?: { [key: string]: any };
  formUuid?: string;
  instanceStatus?: string;
  modifiedTimeGMT?: string;
  originator?: GetInstancesResponseBodyDataOriginator;
  processCode?: string;
  processInstanceId?: string;
  title?: string;
  version?: number;
  static names(): { [key: string]: string } {
    return {
      actionExecutor: 'ActionExecutor',
      approvedResult: 'ApprovedResult',
      createTimeGMT: 'CreateTimeGMT',
      data: 'Data',
      formUuid: 'FormUuid',
      instanceStatus: 'InstanceStatus',
      modifiedTimeGMT: 'ModifiedTimeGMT',
      originator: 'Originator',
      processCode: 'ProcessCode',
      processInstanceId: 'ProcessInstanceId',
      title: 'Title',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actionExecutor: { 'type': 'array', 'itemType': GetInstancesResponseBodyDataActionExecutor },
      approvedResult: 'string',
      createTimeGMT: 'string',
      data: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      formUuid: 'string',
      instanceStatus: 'string',
      modifiedTimeGMT: 'string',
      originator: GetInstancesResponseBodyDataOriginator,
      processCode: 'string',
      processInstanceId: 'string',
      title: 'string',
      version: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstancesByIdListHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstancesByIdListResponseBodyResultActionExecutorName extends $tea.Model {
  nameInChinese?: string;
  nameInEnglish?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      nameInChinese: 'NameInChinese',
      nameInEnglish: 'NameInEnglish',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nameInChinese: 'string',
      nameInEnglish: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstancesByIdListResponseBodyResultActionExecutor extends $tea.Model {
  departmentName?: string;
  email?: string;
  name?: GetInstancesByIdListResponseBodyResultActionExecutorName;
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      departmentName: 'DepartmentName',
      email: 'Email',
      name: 'Name',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      departmentName: 'string',
      email: 'string',
      name: GetInstancesByIdListResponseBodyResultActionExecutorName,
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstancesByIdListResponseBodyResultOriginatorName extends $tea.Model {
  nameInChinese?: string;
  nameInEnglish?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      nameInChinese: 'NameInChinese',
      nameInEnglish: 'NameInEnglish',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nameInChinese: 'string',
      nameInEnglish: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstancesByIdListResponseBodyResultOriginator extends $tea.Model {
  departmentName?: string;
  email?: string;
  name?: GetInstancesByIdListResponseBodyResultOriginatorName;
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      departmentName: 'DepartmentName',
      email: 'Email',
      name: 'Name',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      departmentName: 'string',
      email: 'string',
      name: GetInstancesByIdListResponseBodyResultOriginatorName,
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstancesByIdListResponseBodyResult extends $tea.Model {
  actionExecutor?: GetInstancesByIdListResponseBodyResultActionExecutor[];
  approvedResult?: string;
  data?: { [key: string]: any };
  formUuid?: string;
  instanceStatus?: string;
  originator?: GetInstancesByIdListResponseBodyResultOriginator;
  processCode?: string;
  processInstanceId?: string;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      actionExecutor: 'ActionExecutor',
      approvedResult: 'ApprovedResult',
      data: 'Data',
      formUuid: 'FormUuid',
      instanceStatus: 'InstanceStatus',
      originator: 'Originator',
      processCode: 'ProcessCode',
      processInstanceId: 'ProcessInstanceId',
      title: 'Title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actionExecutor: { 'type': 'array', 'itemType': GetInstancesByIdListResponseBodyResultActionExecutor },
      approvedResult: 'string',
      data: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      formUuid: 'string',
      instanceStatus: 'string',
      originator: GetInstancesByIdListResponseBodyResultOriginator,
      processCode: 'string',
      processInstanceId: 'string',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetLiveReplayUrlHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetLiveReplayUrlRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMeCorpSubmissionHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMeCorpSubmissionResponseBodyDataActioner extends $tea.Model {
  buName?: string;
  email?: string;
  employeeType?: string;
  employeeTypeInformation?: string;
  humanResourceGroupWorkNumber?: string;
  isSystemAdmin?: boolean;
  level?: string;
  name?: string;
  nickName?: string;
  orderNumber?: string;
  personalPhoto?: string;
  personalPhotoUrl?: string;
  pinyinNameAll?: string;
  pinyinNickName?: string;
  state?: string;
  superUserId?: string;
  tbWang?: string;
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      buName: 'BuName',
      email: 'Email',
      employeeType: 'EmployeeType',
      employeeTypeInformation: 'EmployeeTypeInformation',
      humanResourceGroupWorkNumber: 'HumanResourceGroupWorkNumber',
      isSystemAdmin: 'IsSystemAdmin',
      level: 'Level',
      name: 'Name',
      nickName: 'NickName',
      orderNumber: 'OrderNumber',
      personalPhoto: 'PersonalPhoto',
      personalPhotoUrl: 'PersonalPhotoUrl',
      pinyinNameAll: 'PinyinNameAll',
      pinyinNickName: 'PinyinNickName',
      state: 'State',
      superUserId: 'SuperUserId',
      tbWang: 'TbWang',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      buName: 'string',
      email: 'string',
      employeeType: 'string',
      employeeTypeInformation: 'string',
      humanResourceGroupWorkNumber: 'string',
      isSystemAdmin: 'boolean',
      level: 'string',
      name: 'string',
      nickName: 'string',
      orderNumber: 'string',
      personalPhoto: 'string',
      personalPhotoUrl: 'string',
      pinyinNameAll: 'string',
      pinyinNickName: 'string',
      state: 'string',
      superUserId: 'string',
      tbWang: 'string',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMeCorpSubmissionResponseBodyDataCurrentActivityInstances extends $tea.Model {
  activityId?: string;
  activityInstanceStatus?: string;
  activityName?: string;
  activityNameEn?: string;
  id?: number;
  static names(): { [key: string]: string } {
    return {
      activityId: 'ActivityId',
      activityInstanceStatus: 'ActivityInstanceStatus',
      activityName: 'ActivityName',
      activityNameEn: 'ActivityNameEn',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      activityId: 'string',
      activityInstanceStatus: 'string',
      activityName: 'string',
      activityNameEn: 'string',
      id: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMeCorpSubmissionResponseBodyData extends $tea.Model {
  actioner?: GetMeCorpSubmissionResponseBodyDataActioner[];
  actionerId?: string[];
  actionerName?: string[];
  appType?: string;
  createTimeGMT?: string;
  currentActivityInstances?: GetMeCorpSubmissionResponseBodyDataCurrentActivityInstances[];
  dataMap?: { [key: string]: any };
  dataType?: string;
  finishTimeGMT?: string;
  formInstanceId?: string;
  formUuid?: string;
  instanceValue?: string;
  modifiedTimeGMT?: string;
  originatorAvatar?: string;
  originatorDisplayName?: string;
  originatorId?: string;
  processApprovedResult?: string;
  processApprovedResultText?: string;
  processCode?: string;
  processId?: number;
  processInstanceId?: string;
  processInstanceStatus?: string;
  processInstanceStatusText?: string;
  processName?: string;
  title?: string;
  version?: number;
  static names(): { [key: string]: string } {
    return {
      actioner: 'Actioner',
      actionerId: 'ActionerId',
      actionerName: 'ActionerName',
      appType: 'AppType',
      createTimeGMT: 'CreateTimeGMT',
      currentActivityInstances: 'CurrentActivityInstances',
      dataMap: 'DataMap',
      dataType: 'DataType',
      finishTimeGMT: 'FinishTimeGMT',
      formInstanceId: 'FormInstanceId',
      formUuid: 'FormUuid',
      instanceValue: 'InstanceValue',
      modifiedTimeGMT: 'ModifiedTimeGMT',
      originatorAvatar: 'OriginatorAvatar',
      originatorDisplayName: 'OriginatorDisplayName',
      originatorId: 'OriginatorId',
      processApprovedResult: 'ProcessApprovedResult',
      processApprovedResultText: 'ProcessApprovedResultText',
      processCode: 'ProcessCode',
      processId: 'ProcessId',
      processInstanceId: 'ProcessInstanceId',
      processInstanceStatus: 'ProcessInstanceStatus',
      processInstanceStatusText: 'ProcessInstanceStatusText',
      processName: 'ProcessName',
      title: 'Title',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actioner: { 'type': 'array', 'itemType': GetMeCorpSubmissionResponseBodyDataActioner },
      actionerId: { 'type': 'array', 'itemType': 'string' },
      actionerName: { 'type': 'array', 'itemType': 'string' },
      appType: 'string',
      createTimeGMT: 'string',
      currentActivityInstances: { 'type': 'array', 'itemType': GetMeCorpSubmissionResponseBodyDataCurrentActivityInstances },
      dataMap: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      dataType: 'string',
      finishTimeGMT: 'string',
      formInstanceId: 'string',
      formUuid: 'string',
      instanceValue: 'string',
      modifiedTimeGMT: 'string',
      originatorAvatar: 'string',
      originatorDisplayName: 'string',
      originatorId: 'string',
      processApprovedResult: 'string',
      processApprovedResultText: 'string',
      processCode: 'string',
      processId: 'number',
      processInstanceId: 'string',
      processInstanceStatus: 'string',
      processInstanceStatusText: 'string',
      processName: 'string',
      title: 'string',
      version: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMeetingRoomsScheduleHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMeetingRoomsScheduleResponseBodyScheduleInformationScheduleItemsEnd extends $tea.Model {
  dateTime?: string;
  timeZone?: string;
  static names(): { [key: string]: string } {
    return {
      dateTime: 'DateTime',
      timeZone: 'TimeZone',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dateTime: 'string',
      timeZone: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMeetingRoomsScheduleResponseBodyScheduleInformationScheduleItemsOrganizer extends $tea.Model {
  id?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMeetingRoomsScheduleResponseBodyScheduleInformationScheduleItemsStart extends $tea.Model {
  dateTime?: string;
  timeZone?: string;
  static names(): { [key: string]: string } {
    return {
      dateTime: 'DateTime',
      timeZone: 'TimeZone',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dateTime: 'string',
      timeZone: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMeetingRoomsScheduleResponseBodyScheduleInformationScheduleItems extends $tea.Model {
  end?: GetMeetingRoomsScheduleResponseBodyScheduleInformationScheduleItemsEnd;
  eventId?: string;
  organizer?: GetMeetingRoomsScheduleResponseBodyScheduleInformationScheduleItemsOrganizer;
  start?: GetMeetingRoomsScheduleResponseBodyScheduleInformationScheduleItemsStart;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      end: 'End',
      eventId: 'EventId',
      organizer: 'Organizer',
      start: 'Start',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      end: GetMeetingRoomsScheduleResponseBodyScheduleInformationScheduleItemsEnd,
      eventId: 'string',
      organizer: GetMeetingRoomsScheduleResponseBodyScheduleInformationScheduleItemsOrganizer,
      start: GetMeetingRoomsScheduleResponseBodyScheduleInformationScheduleItemsStart,
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMeetingRoomsScheduleResponseBodyScheduleInformation extends $tea.Model {
  error?: string;
  roomId?: string;
  scheduleItems?: GetMeetingRoomsScheduleResponseBodyScheduleInformationScheduleItems[];
  static names(): { [key: string]: string } {
    return {
      error: 'Error',
      roomId: 'RoomId',
      scheduleItems: 'ScheduleItems',
    };
  }

  static types(): { [key: string]: any } {
    return {
      error: 'string',
      roomId: 'string',
      scheduleItems: { 'type': 'array', 'itemType': GetMeetingRoomsScheduleResponseBodyScheduleInformationScheduleItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMineWorkspaceHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMineWorkspaceRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMineWorkspaceResponseBodyWorkspaceIcon extends $tea.Model {
  type?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      type: 'Type',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      type: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMineWorkspaceResponseBodyWorkspace extends $tea.Model {
  corpId?: string;
  cover?: string;
  createTime?: string;
  creatorId?: string;
  description?: string;
  icon?: GetMineWorkspaceResponseBodyWorkspaceIcon;
  modifiedTime?: string;
  modifierId?: string;
  name?: string;
  permissionRole?: string;
  rootNodeId?: string;
  teamId?: string;
  type?: string;
  url?: string;
  workspaceId?: string;
  static names(): { [key: string]: string } {
    return {
      corpId: 'CorpId',
      cover: 'Cover',
      createTime: 'CreateTime',
      creatorId: 'CreatorId',
      description: 'Description',
      icon: 'Icon',
      modifiedTime: 'ModifiedTime',
      modifierId: 'ModifierId',
      name: 'Name',
      permissionRole: 'PermissionRole',
      rootNodeId: 'RootNodeId',
      teamId: 'TeamId',
      type: 'Type',
      url: 'Url',
      workspaceId: 'WorkspaceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      corpId: 'string',
      cover: 'string',
      createTime: 'string',
      creatorId: 'string',
      description: 'string',
      icon: GetMineWorkspaceResponseBodyWorkspaceIcon,
      modifiedTime: 'string',
      modifierId: 'string',
      name: 'string',
      permissionRole: 'string',
      rootNodeId: 'string',
      teamId: 'string',
      type: 'string',
      url: 'string',
      workspaceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNewestInnerGroupsHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNewestInnerGroupsResponseBodyGroupInfos extends $tea.Model {
  icon?: string;
  memberAmount?: string;
  openConversationId?: string;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      icon: 'Icon',
      memberAmount: 'MemberAmount',
      openConversationId: 'OpenConversationId',
      title: 'Title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      icon: 'string',
      memberAmount: 'string',
      openConversationId: 'string',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNodeHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNodeRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNodeResponseBodyNodeStatisticalInfo extends $tea.Model {
  wordCount?: number;
  static names(): { [key: string]: string } {
    return {
      wordCount: 'WordCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      wordCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNodeResponseBodyNode extends $tea.Model {
  category?: string;
  createTime?: string;
  creatorId?: string;
  extension?: string;
  hasChildren?: boolean;
  modifiedTime?: string;
  modifierId?: string;
  name?: string;
  nodeId?: string;
  permissionRole?: string;
  size?: number;
  statisticalInfo?: GetNodeResponseBodyNodeStatisticalInfo;
  type?: string;
  url?: string;
  workspaceId?: string;
  static names(): { [key: string]: string } {
    return {
      category: 'Category',
      createTime: 'CreateTime',
      creatorId: 'CreatorId',
      extension: 'Extension',
      hasChildren: 'HasChildren',
      modifiedTime: 'ModifiedTime',
      modifierId: 'ModifierId',
      name: 'Name',
      nodeId: 'NodeId',
      permissionRole: 'PermissionRole',
      size: 'Size',
      statisticalInfo: 'StatisticalInfo',
      type: 'Type',
      url: 'Url',
      workspaceId: 'WorkspaceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
      createTime: 'string',
      creatorId: 'string',
      extension: 'string',
      hasChildren: 'boolean',
      modifiedTime: 'string',
      modifierId: 'string',
      name: 'string',
      nodeId: 'string',
      permissionRole: 'string',
      size: 'number',
      statisticalInfo: GetNodeResponseBodyNodeStatisticalInfo,
      type: 'string',
      url: 'string',
      workspaceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNodeByUrlHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNodeByUrlRequestOption extends $tea.Model {
  withPermissionRole?: boolean;
  withStatisticalInfo?: boolean;
  static names(): { [key: string]: string } {
    return {
      withPermissionRole: 'WithPermissionRole',
      withStatisticalInfo: 'WithStatisticalInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      withPermissionRole: 'boolean',
      withStatisticalInfo: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNodeByUrlRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNodeByUrlResponseBodyNodeStatisticalInfo extends $tea.Model {
  wordCount?: number;
  static names(): { [key: string]: string } {
    return {
      wordCount: 'WordCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      wordCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNodeByUrlResponseBodyNode extends $tea.Model {
  category?: string;
  createTime?: string;
  creatorId?: string;
  extension?: string;
  hasChildren?: boolean;
  modifiedTime?: string;
  modifierId?: string;
  name?: string;
  nodeId?: string;
  permissionRole?: string;
  size?: number;
  statisticalInfo?: GetNodeByUrlResponseBodyNodeStatisticalInfo;
  type?: string;
  url?: string;
  workspaceId?: string;
  static names(): { [key: string]: string } {
    return {
      category: 'Category',
      createTime: 'CreateTime',
      creatorId: 'CreatorId',
      extension: 'Extension',
      hasChildren: 'HasChildren',
      modifiedTime: 'ModifiedTime',
      modifierId: 'ModifierId',
      name: 'Name',
      nodeId: 'NodeId',
      permissionRole: 'PermissionRole',
      size: 'Size',
      statisticalInfo: 'StatisticalInfo',
      type: 'Type',
      url: 'Url',
      workspaceId: 'WorkspaceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
      createTime: 'string',
      creatorId: 'string',
      extension: 'string',
      hasChildren: 'boolean',
      modifiedTime: 'string',
      modifierId: 'string',
      name: 'string',
      nodeId: 'string',
      permissionRole: 'string',
      size: 'number',
      statisticalInfo: GetNodeByUrlResponseBodyNodeStatisticalInfo,
      type: 'string',
      url: 'string',
      workspaceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNodesHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNodesRequestOption extends $tea.Model {
  withPermissionRole?: boolean;
  withStatisticalInfo?: boolean;
  static names(): { [key: string]: string } {
    return {
      withPermissionRole: 'WithPermissionRole',
      withStatisticalInfo: 'WithStatisticalInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      withPermissionRole: 'boolean',
      withStatisticalInfo: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNodesRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNodesResponseBodyNodesStatisticalInfo extends $tea.Model {
  wordCount?: number;
  static names(): { [key: string]: string } {
    return {
      wordCount: 'WordCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      wordCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNodesResponseBodyNodes extends $tea.Model {
  category?: string;
  createTime?: string;
  creatorId?: string;
  extension?: string;
  hasChildren?: boolean;
  modifiedTime?: string;
  modifierId?: string;
  name?: string;
  nodeId?: string;
  permissionRole?: string;
  size?: number;
  statisticalInfo?: GetNodesResponseBodyNodesStatisticalInfo;
  type?: string;
  url?: string;
  workspaceId?: string;
  static names(): { [key: string]: string } {
    return {
      category: 'Category',
      createTime: 'CreateTime',
      creatorId: 'CreatorId',
      extension: 'Extension',
      hasChildren: 'HasChildren',
      modifiedTime: 'ModifiedTime',
      modifierId: 'ModifierId',
      name: 'Name',
      nodeId: 'NodeId',
      permissionRole: 'PermissionRole',
      size: 'Size',
      statisticalInfo: 'StatisticalInfo',
      type: 'Type',
      url: 'Url',
      workspaceId: 'WorkspaceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
      createTime: 'string',
      creatorId: 'string',
      extension: 'string',
      hasChildren: 'boolean',
      modifiedTime: 'string',
      modifierId: 'string',
      name: 'string',
      nodeId: 'string',
      permissionRole: 'string',
      size: 'number',
      statisticalInfo: GetNodesResponseBodyNodesStatisticalInfo,
      type: 'string',
      url: 'string',
      workspaceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNotifyMeHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNotifyMeResponseBodyData extends $tea.Model {
  activityId?: string;
  appType?: string;
  corpId?: string;
  createTimeGMT?: string;
  creatorUserId?: string;
  formInstanceId?: string;
  instStatus?: string;
  mobileUrl?: string;
  modifiedTimeGMT?: string;
  static names(): { [key: string]: string } {
    return {
      activityId: 'ActivityId',
      appType: 'AppType',
      corpId: 'CorpId',
      createTimeGMT: 'CreateTimeGMT',
      creatorUserId: 'CreatorUserId',
      formInstanceId: 'FormInstanceId',
      instStatus: 'InstStatus',
      mobileUrl: 'MobileUrl',
      modifiedTimeGMT: 'ModifiedTimeGMT',
    };
  }

  static types(): { [key: string]: any } {
    return {
      activityId: 'string',
      appType: 'string',
      corpId: 'string',
      createTimeGMT: 'string',
      creatorUserId: 'string',
      formInstanceId: 'string',
      instStatus: 'string',
      mobileUrl: 'string',
      modifiedTimeGMT: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOpenUrlHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOperationRecordsHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOperationRecordsResponseBodyResult extends $tea.Model {
  action?: string;
  actionExit?: string;
  activeTimeGMT?: string;
  activityId?: string;
  dataId?: number;
  digitalSign?: string;
  files?: string;
  operateTimeGMT?: string;
  operateType?: string;
  operatorDisplayName?: string;
  operatorName?: string;
  operatorNickName?: string;
  operatorPhotoUrl?: string;
  operatorStatus?: string;
  operatorUserId?: string;
  processInstanceId?: string;
  remark?: string;
  showName?: string;
  size?: number;
  taskExecuteType?: string;
  taskHoldTimeGMT?: number;
  taskId?: string;
  taskType?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      action: 'Action',
      actionExit: 'ActionExit',
      activeTimeGMT: 'ActiveTimeGMT',
      activityId: 'ActivityId',
      dataId: 'DataId',
      digitalSign: 'DigitalSign',
      files: 'Files',
      operateTimeGMT: 'OperateTimeGMT',
      operateType: 'OperateType',
      operatorDisplayName: 'OperatorDisplayName',
      operatorName: 'OperatorName',
      operatorNickName: 'OperatorNickName',
      operatorPhotoUrl: 'OperatorPhotoUrl',
      operatorStatus: 'OperatorStatus',
      operatorUserId: 'OperatorUserId',
      processInstanceId: 'ProcessInstanceId',
      remark: 'Remark',
      showName: 'ShowName',
      size: 'Size',
      taskExecuteType: 'TaskExecuteType',
      taskHoldTimeGMT: 'TaskHoldTimeGMT',
      taskId: 'TaskId',
      taskType: 'TaskType',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      action: 'string',
      actionExit: 'string',
      activeTimeGMT: 'string',
      activityId: 'string',
      dataId: 'number',
      digitalSign: 'string',
      files: 'string',
      operateTimeGMT: 'string',
      operateType: 'string',
      operatorDisplayName: 'string',
      operatorName: 'string',
      operatorNickName: 'string',
      operatorPhotoUrl: 'string',
      operatorStatus: 'string',
      operatorUserId: 'string',
      processInstanceId: 'string',
      remark: 'string',
      showName: 'string',
      size: 'number',
      taskExecuteType: 'string',
      taskHoldTimeGMT: 'number',
      taskId: 'string',
      taskType: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetProcessDefinitionHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetProcessDefinitionResponseBodyOriginatorMasterDataDepartments extends $tea.Model {
  deptName?: string;
  deptNameInEnglish?: string;
  deptNo?: string;
  deptPath?: string;
  humanSourceGroupOrderNumber?: string;
  humanSourceGroupWorkNo?: string;
  id?: number;
  masterWorkNo?: string;
  static names(): { [key: string]: string } {
    return {
      deptName: 'DeptName',
      deptNameInEnglish: 'DeptNameInEnglish',
      deptNo: 'DeptNo',
      deptPath: 'DeptPath',
      humanSourceGroupOrderNumber: 'HumanSourceGroupOrderNumber',
      humanSourceGroupWorkNo: 'HumanSourceGroupWorkNo',
      id: 'Id',
      masterWorkNo: 'MasterWorkNo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deptName: 'string',
      deptNameInEnglish: 'string',
      deptNo: 'string',
      deptPath: 'string',
      humanSourceGroupOrderNumber: 'string',
      humanSourceGroupWorkNo: 'string',
      id: 'number',
      masterWorkNo: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetProcessDefinitionResponseBodyOriginator extends $tea.Model {
  departmentDescription?: string;
  displayEnName?: string;
  displayName?: string;
  masterDataDepartments?: GetProcessDefinitionResponseBodyOriginatorMasterDataDepartments[];
  orderNumber?: string;
  personalPhoto?: string;
  status?: string;
  tbWang?: string;
  userId?: string;
  userInfo?: string;
  static names(): { [key: string]: string } {
    return {
      departmentDescription: 'DepartmentDescription',
      displayEnName: 'DisplayEnName',
      displayName: 'DisplayName',
      masterDataDepartments: 'MasterDataDepartments',
      orderNumber: 'OrderNumber',
      personalPhoto: 'PersonalPhoto',
      status: 'Status',
      tbWang: 'TbWang',
      userId: 'UserId',
      userInfo: 'UserInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      departmentDescription: 'string',
      displayEnName: 'string',
      displayName: 'string',
      masterDataDepartments: { 'type': 'array', 'itemType': GetProcessDefinitionResponseBodyOriginatorMasterDataDepartments },
      orderNumber: 'string',
      personalPhoto: 'string',
      status: 'string',
      tbWang: 'string',
      userId: 'string',
      userInfo: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetProcessDefinitionResponseBodyOwnersMasterDataDepartments extends $tea.Model {
  deptName?: string;
  deptNameInEnglish?: string;
  deptNo?: string;
  deptPath?: string;
  humanSourceGroupOrderNumber?: string;
  humanSourceGroupWorkNo?: string;
  id?: number;
  masterWorkNo?: string;
  static names(): { [key: string]: string } {
    return {
      deptName: 'DeptName',
      deptNameInEnglish: 'DeptNameInEnglish',
      deptNo: 'DeptNo',
      deptPath: 'DeptPath',
      humanSourceGroupOrderNumber: 'HumanSourceGroupOrderNumber',
      humanSourceGroupWorkNo: 'HumanSourceGroupWorkNo',
      id: 'Id',
      masterWorkNo: 'MasterWorkNo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deptName: 'string',
      deptNameInEnglish: 'string',
      deptNo: 'string',
      deptPath: 'string',
      humanSourceGroupOrderNumber: 'string',
      humanSourceGroupWorkNo: 'string',
      id: 'number',
      masterWorkNo: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetProcessDefinitionResponseBodyOwners extends $tea.Model {
  departmentDescription?: string;
  displayEnName?: string;
  displayName?: string;
  masterDataDepartments?: GetProcessDefinitionResponseBodyOwnersMasterDataDepartments[];
  orderNumber?: string;
  personalPhoto?: string;
  status?: string;
  tbWang?: string;
  userId?: string;
  userInfo?: string;
  static names(): { [key: string]: string } {
    return {
      departmentDescription: 'DepartmentDescription',
      displayEnName: 'DisplayEnName',
      displayName: 'DisplayName',
      masterDataDepartments: 'MasterDataDepartments',
      orderNumber: 'OrderNumber',
      personalPhoto: 'PersonalPhoto',
      status: 'Status',
      tbWang: 'TbWang',
      userId: 'UserId',
      userInfo: 'UserInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      departmentDescription: 'string',
      displayEnName: 'string',
      displayName: 'string',
      masterDataDepartments: { 'type': 'array', 'itemType': GetProcessDefinitionResponseBodyOwnersMasterDataDepartments },
      orderNumber: 'string',
      personalPhoto: 'string',
      status: 'string',
      tbWang: 'string',
      userId: 'string',
      userInfo: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetProcessDefinitionResponseBodyTasksActivity extends $tea.Model {
  activityId?: string;
  activityInstanceStatus?: string;
  activityName?: string;
  activityNameInEnglish?: string;
  id?: number;
  static names(): { [key: string]: string } {
    return {
      activityId: 'ActivityId',
      activityInstanceStatus: 'ActivityInstanceStatus',
      activityName: 'ActivityName',
      activityNameInEnglish: 'ActivityNameInEnglish',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      activityId: 'string',
      activityInstanceStatus: 'string',
      activityName: 'string',
      activityNameInEnglish: 'string',
      id: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetProcessDefinitionResponseBodyTasks extends $tea.Model {
  actionerId?: string;
  activity?: GetProcessDefinitionResponseBodyTasksActivity;
  status?: string;
  taskId?: number;
  static names(): { [key: string]: string } {
    return {
      actionerId: 'ActionerId',
      activity: 'Activity',
      status: 'Status',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actionerId: 'string',
      activity: GetProcessDefinitionResponseBodyTasksActivity,
      status: 'string',
      taskId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRangeHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRangeRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRangeResponseBodyBackgroundColors extends $tea.Model {
  red?: number;
  green?: number;
  blue?: number;
  hexString?: string;
  static names(): { [key: string]: string } {
    return {
      red: 'Red',
      green: 'Green',
      blue: 'Blue',
      hexString: 'HexString',
    };
  }

  static types(): { [key: string]: any } {
    return {
      red: 'number',
      green: 'number',
      blue: 'number',
      hexString: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRelatedWorkspacesHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRelatedWorkspacesRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRelatedWorkspacesResponseBodyWorkspacesRecentList extends $tea.Model {
  lastEditTime?: number;
  name?: string;
  nodeId?: string;
  url?: string;
  static names(): { [key: string]: string } {
    return {
      lastEditTime: 'LastEditTime',
      name: 'Name',
      nodeId: 'NodeId',
      url: 'Url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lastEditTime: 'number',
      name: 'string',
      nodeId: 'string',
      url: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRelatedWorkspacesResponseBodyWorkspaces extends $tea.Model {
  createTime?: number;
  deleted?: boolean;
  name?: string;
  owner?: string;
  recentList?: GetRelatedWorkspacesResponseBodyWorkspacesRecentList[];
  role?: string;
  url?: string;
  workspaceId?: string;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      deleted: 'Deleted',
      name: 'Name',
      owner: 'Owner',
      recentList: 'RecentList',
      role: 'Role',
      url: 'Url',
      workspaceId: 'WorkspaceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'number',
      deleted: 'boolean',
      name: 'string',
      owner: 'string',
      recentList: { 'type': 'array', 'itemType': GetRelatedWorkspacesResponseBodyWorkspacesRecentList },
      role: 'string',
      url: 'string',
      workspaceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetReportTemplateByNameHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetReportTemplateByNameRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetReportTemplateByNameResponseBodyDefaultReceivedConvs extends $tea.Model {
  conversationId?: string;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      conversationId: 'ConversationId',
      title: 'Title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      conversationId: 'string',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetReportTemplateByNameResponseBodyDefaultReceivers extends $tea.Model {
  userName?: string;
  userid?: string;
  static names(): { [key: string]: string } {
    return {
      userName: 'UserName',
      userid: 'Userid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      userName: 'string',
      userid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetReportTemplateByNameResponseBodyFields extends $tea.Model {
  fieldName?: string;
  sort?: number;
  type?: number;
  static names(): { [key: string]: string } {
    return {
      fieldName: 'FieldName',
      sort: 'Sort',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fieldName: 'string',
      sort: 'number',
      type: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetReportUnReadCountHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetReportUnReadCountRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRunningTasksHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRunningTasksResponseBodyResult extends $tea.Model {
  activeTimeGMT?: string;
  activityId?: string;
  actualActionerId?: string;
  createTimeGMT?: string;
  finishTimeGMT?: string;
  originatorId?: string;
  processInstanceId?: string;
  status?: string;
  taskId?: string;
  taskType?: string;
  title?: string;
  titleInEnglish?: string;
  static names(): { [key: string]: string } {
    return {
      activeTimeGMT: 'ActiveTimeGMT',
      activityId: 'ActivityId',
      actualActionerId: 'ActualActionerId',
      createTimeGMT: 'CreateTimeGMT',
      finishTimeGMT: 'FinishTimeGMT',
      originatorId: 'OriginatorId',
      processInstanceId: 'ProcessInstanceId',
      status: 'Status',
      taskId: 'TaskId',
      taskType: 'TaskType',
      title: 'Title',
      titleInEnglish: 'TitleInEnglish',
    };
  }

  static types(): { [key: string]: any } {
    return {
      activeTimeGMT: 'string',
      activityId: 'string',
      actualActionerId: 'string',
      createTimeGMT: 'string',
      finishTimeGMT: 'string',
      originatorId: 'string',
      processInstanceId: 'string',
      status: 'string',
      taskId: 'string',
      taskType: 'string',
      title: 'string',
      titleInEnglish: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSheetHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSheetRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSpaceDirectoriesHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSpaceDirectoriesRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSpaceDirectoriesResponseBodyChildrenCreator extends $tea.Model {
  name?: string;
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSpaceDirectoriesResponseBodyChildrenLinkSourceInfoIconUrl extends $tea.Model {
  line?: string;
  small?: string;
  static names(): { [key: string]: string } {
    return {
      line: 'Line',
      small: 'Small',
    };
  }

  static types(): { [key: string]: any } {
    return {
      line: 'string',
      small: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSpaceDirectoriesResponseBodyChildrenLinkSourceInfo extends $tea.Model {
  extension?: string;
  iconUrl?: GetSpaceDirectoriesResponseBodyChildrenLinkSourceInfoIconUrl;
  id?: string;
  linkType?: number;
  spaceId?: string;
  static names(): { [key: string]: string } {
    return {
      extension: 'Extension',
      iconUrl: 'IconUrl',
      id: 'Id',
      linkType: 'LinkType',
      spaceId: 'SpaceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      extension: 'string',
      iconUrl: GetSpaceDirectoriesResponseBodyChildrenLinkSourceInfoIconUrl,
      id: 'string',
      linkType: 'number',
      spaceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSpaceDirectoriesResponseBodyChildrenSpaceHdIconVO extends $tea.Model {
  icon?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      icon: 'Icon',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      icon: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSpaceDirectoriesResponseBodyChildrenSpaceIconVO extends $tea.Model {
  icon?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      icon: 'Icon',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      icon: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSpaceDirectoriesResponseBodyChildrenSpaceOwner extends $tea.Model {
  name?: string;
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSpaceDirectoriesResponseBodyChildrenSpaceVisitorInfo extends $tea.Model {
  dentryActions?: string[];
  roleCode?: string;
  spaceActions?: string[];
  static names(): { [key: string]: string } {
    return {
      dentryActions: 'DentryActions',
      roleCode: 'RoleCode',
      spaceActions: 'SpaceActions',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dentryActions: { 'type': 'array', 'itemType': 'string' },
      roleCode: 'string',
      spaceActions: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSpaceDirectoriesResponseBodyChildrenSpace extends $tea.Model {
  cover?: string;
  description?: string;
  hdIconVO?: GetSpaceDirectoriesResponseBodyChildrenSpaceHdIconVO;
  iconVO?: GetSpaceDirectoriesResponseBodyChildrenSpaceIconVO;
  id?: string;
  name?: string;
  owner?: GetSpaceDirectoriesResponseBodyChildrenSpaceOwner;
  recentList?: any[];
  type?: number;
  url?: string;
  visitorInfo?: GetSpaceDirectoriesResponseBodyChildrenSpaceVisitorInfo;
  static names(): { [key: string]: string } {
    return {
      cover: 'Cover',
      description: 'Description',
      hdIconVO: 'HdIconVO',
      iconVO: 'IconVO',
      id: 'Id',
      name: 'Name',
      owner: 'Owner',
      recentList: 'RecentList',
      type: 'Type',
      url: 'Url',
      visitorInfo: 'VisitorInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cover: 'string',
      description: 'string',
      hdIconVO: GetSpaceDirectoriesResponseBodyChildrenSpaceHdIconVO,
      iconVO: GetSpaceDirectoriesResponseBodyChildrenSpaceIconVO,
      id: 'string',
      name: 'string',
      owner: GetSpaceDirectoriesResponseBodyChildrenSpaceOwner,
      recentList: { 'type': 'array', 'itemType': 'any' },
      type: 'number',
      url: 'string',
      visitorInfo: GetSpaceDirectoriesResponseBodyChildrenSpaceVisitorInfo,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSpaceDirectoriesResponseBodyChildrenStatisticalInfo extends $tea.Model {
  wordCount?: number;
  static names(): { [key: string]: string } {
    return {
      wordCount: 'WordCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      wordCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSpaceDirectoriesResponseBodyChildrenUpdater extends $tea.Model {
  name?: string;
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSpaceDirectoriesResponseBodyChildrenVisitorInfo extends $tea.Model {
  dentryActions?: string[];
  roleCode?: string;
  spaceActions?: string[];
  static names(): { [key: string]: string } {
    return {
      dentryActions: 'DentryActions',
      roleCode: 'RoleCode',
      spaceActions: 'SpaceActions',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dentryActions: { 'type': 'array', 'itemType': 'string' },
      roleCode: 'string',
      spaceActions: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSpaceDirectoriesResponseBodyChildren extends $tea.Model {
  contentType?: string;
  createdTime?: number;
  creator?: GetSpaceDirectoriesResponseBodyChildrenCreator;
  dentryId?: string;
  dentryType?: string;
  dentryUuid?: string;
  docKey?: string;
  extension?: string;
  hasChildren?: boolean;
  linkSourceInfo?: GetSpaceDirectoriesResponseBodyChildrenLinkSourceInfo;
  name?: string;
  path?: string;
  space?: GetSpaceDirectoriesResponseBodyChildrenSpace;
  spaceId?: string;
  statisticalInfo?: GetSpaceDirectoriesResponseBodyChildrenStatisticalInfo;
  updatedTime?: number;
  updater?: GetSpaceDirectoriesResponseBodyChildrenUpdater;
  url?: string;
  visitorInfo?: GetSpaceDirectoriesResponseBodyChildrenVisitorInfo;
  static names(): { [key: string]: string } {
    return {
      contentType: 'ContentType',
      createdTime: 'CreatedTime',
      creator: 'Creator',
      dentryId: 'DentryId',
      dentryType: 'DentryType',
      dentryUuid: 'DentryUuid',
      docKey: 'DocKey',
      extension: 'Extension',
      hasChildren: 'HasChildren',
      linkSourceInfo: 'LinkSourceInfo',
      name: 'Name',
      path: 'Path',
      space: 'Space',
      spaceId: 'SpaceId',
      statisticalInfo: 'StatisticalInfo',
      updatedTime: 'UpdatedTime',
      updater: 'Updater',
      url: 'Url',
      visitorInfo: 'VisitorInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contentType: 'string',
      createdTime: 'number',
      creator: GetSpaceDirectoriesResponseBodyChildrenCreator,
      dentryId: 'string',
      dentryType: 'string',
      dentryUuid: 'string',
      docKey: 'string',
      extension: 'string',
      hasChildren: 'boolean',
      linkSourceInfo: GetSpaceDirectoriesResponseBodyChildrenLinkSourceInfo,
      name: 'string',
      path: 'string',
      space: GetSpaceDirectoriesResponseBodyChildrenSpace,
      spaceId: 'string',
      statisticalInfo: GetSpaceDirectoriesResponseBodyChildrenStatisticalInfo,
      updatedTime: 'number',
      updater: GetSpaceDirectoriesResponseBodyChildrenUpdater,
      url: 'string',
      visitorInfo: GetSpaceDirectoriesResponseBodyChildrenVisitorInfo,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSubscribedCalendarHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSubscribedCalendarResponseBodySubscribeScope extends $tea.Model {
  corpIds?: string[];
  openConversationIds?: string[];
  userIds?: string[];
  static names(): { [key: string]: string } {
    return {
      corpIds: 'CorpIds',
      openConversationIds: 'OpenConversationIds',
      userIds: 'UserIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      corpIds: { 'type': 'array', 'itemType': 'string' },
      openConversationIds: { 'type': 'array', 'itemType': 'string' },
      userIds: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTaskCopiesHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTaskCopiesResponseBodyDataCurrentActivityInstances extends $tea.Model {
  activityId?: string;
  activityInstanceStatus?: string;
  activityName?: string;
  activityNameInEnglish?: string;
  id?: number;
  static names(): { [key: string]: string } {
    return {
      activityId: 'ActivityId',
      activityInstanceStatus: 'ActivityInstanceStatus',
      activityName: 'ActivityName',
      activityNameInEnglish: 'ActivityNameInEnglish',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      activityId: 'string',
      activityInstanceStatus: 'string',
      activityName: 'string',
      activityNameInEnglish: 'string',
      id: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTaskCopiesResponseBodyData extends $tea.Model {
  actionExecutorId?: string[];
  actionExecutorName?: string[];
  appType?: string;
  carbonActivityId?: string;
  createTimeGMT?: string;
  currentActivityInstances?: GetTaskCopiesResponseBodyDataCurrentActivityInstances[];
  dataMap?: { [key: string]: any };
  dataType?: string;
  finishTimeGMT?: string;
  formInstanceId?: string;
  formUuid?: string;
  instanceValue?: string;
  modifiedTimeGMT?: string;
  originatorAvatar?: string;
  originatorDisplayName?: string;
  originatorId?: string;
  processApprovedResult?: string;
  processApprovedResultText?: string;
  processCode?: string;
  processId?: number;
  processInstanceId?: string;
  processInstanceStatus?: string;
  processInstanceStatusText?: string;
  processName?: string;
  serialNumber?: string;
  title?: string;
  version?: number;
  static names(): { [key: string]: string } {
    return {
      actionExecutorId: 'ActionExecutorId',
      actionExecutorName: 'ActionExecutorName',
      appType: 'AppType',
      carbonActivityId: 'CarbonActivityId',
      createTimeGMT: 'CreateTimeGMT',
      currentActivityInstances: 'CurrentActivityInstances',
      dataMap: 'DataMap',
      dataType: 'DataType',
      finishTimeGMT: 'FinishTimeGMT',
      formInstanceId: 'FormInstanceId',
      formUuid: 'FormUuid',
      instanceValue: 'InstanceValue',
      modifiedTimeGMT: 'ModifiedTimeGMT',
      originatorAvatar: 'OriginatorAvatar',
      originatorDisplayName: 'OriginatorDisplayName',
      originatorId: 'OriginatorId',
      processApprovedResult: 'ProcessApprovedResult',
      processApprovedResultText: 'ProcessApprovedResultText',
      processCode: 'ProcessCode',
      processId: 'ProcessId',
      processInstanceId: 'ProcessInstanceId',
      processInstanceStatus: 'ProcessInstanceStatus',
      processInstanceStatusText: 'ProcessInstanceStatusText',
      processName: 'ProcessName',
      serialNumber: 'SerialNumber',
      title: 'Title',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actionExecutorId: { 'type': 'array', 'itemType': 'string' },
      actionExecutorName: { 'type': 'array', 'itemType': 'string' },
      appType: 'string',
      carbonActivityId: 'string',
      createTimeGMT: 'string',
      currentActivityInstances: { 'type': 'array', 'itemType': GetTaskCopiesResponseBodyDataCurrentActivityInstances },
      dataMap: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      dataType: 'string',
      finishTimeGMT: 'string',
      formInstanceId: 'string',
      formUuid: 'string',
      instanceValue: 'string',
      modifiedTimeGMT: 'string',
      originatorAvatar: 'string',
      originatorDisplayName: 'string',
      originatorId: 'string',
      processApprovedResult: 'string',
      processApprovedResultText: 'string',
      processCode: 'string',
      processId: 'number',
      processInstanceId: 'string',
      processInstanceStatus: 'string',
      processInstanceStatusText: 'string',
      processName: 'string',
      serialNumber: 'string',
      title: 'string',
      version: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTemplateListByUserIdHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTemplateListByUserIdRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTemplateListByUserIdResponseBodyTemplateList extends $tea.Model {
  iconUrl?: string;
  name?: string;
  reportCode?: string;
  url?: string;
  static names(): { [key: string]: string } {
    return {
      iconUrl: 'IconUrl',
      name: 'Name',
      reportCode: 'ReportCode',
      url: 'Url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iconUrl: 'string',
      name: 'string',
      reportCode: 'string',
      url: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserResponseBodyDeptOrderList extends $tea.Model {
  deptId?: number;
  order?: number;
  static names(): { [key: string]: string } {
    return {
      deptId: 'deptId',
      order: 'order',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deptId: 'number',
      order: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserResponseBodyLeaderInDept extends $tea.Model {
  deptId?: number;
  leader?: boolean;
  static names(): { [key: string]: string } {
    return {
      deptId: 'deptId',
      leader: 'leader',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deptId: 'number',
      leader: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserResponseBodyRoleList extends $tea.Model {
  groupName?: string;
  id?: number;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      groupName: 'groupName',
      id: 'id',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupName: 'string',
      id: 'number',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserResponseBodyUnionEmpExtUnionEmpMapList extends $tea.Model {
  cropId?: string;
  userid?: string;
  static names(): { [key: string]: string } {
    return {
      cropId: 'cropId',
      userid: 'userid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cropId: 'string',
      userid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserResponseBodyUnionEmpExt extends $tea.Model {
  corpId?: string;
  unionEmpMapList?: GetUserResponseBodyUnionEmpExtUnionEmpMapList[];
  userid?: string;
  static names(): { [key: string]: string } {
    return {
      corpId: 'corpId',
      unionEmpMapList: 'unionEmpMapList',
      userid: 'userid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      corpId: 'string',
      unionEmpMapList: { 'type': 'array', 'itemType': GetUserResponseBodyUnionEmpExtUnionEmpMapList },
      userid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserLatestPlanHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserLatestPlanRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkspaceHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkspaceRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkspaceResponseBodyWorkspaceIcon extends $tea.Model {
  type?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      type: 'Type',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      type: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkspaceResponseBodyWorkspace extends $tea.Model {
  corpId?: string;
  cover?: string;
  createTime?: string;
  creatorId?: string;
  description?: string;
  icon?: GetWorkspaceResponseBodyWorkspaceIcon;
  modifiedTime?: string;
  modifierId?: string;
  name?: string;
  permissionRole?: string;
  rootNodeId?: string;
  teamId?: string;
  type?: string;
  url?: string;
  workspaceId?: string;
  static names(): { [key: string]: string } {
    return {
      corpId: 'CorpId',
      cover: 'Cover',
      createTime: 'CreateTime',
      creatorId: 'CreatorId',
      description: 'Description',
      icon: 'Icon',
      modifiedTime: 'ModifiedTime',
      modifierId: 'ModifierId',
      name: 'Name',
      permissionRole: 'PermissionRole',
      rootNodeId: 'RootNodeId',
      teamId: 'TeamId',
      type: 'Type',
      url: 'Url',
      workspaceId: 'WorkspaceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      corpId: 'string',
      cover: 'string',
      createTime: 'string',
      creatorId: 'string',
      description: 'string',
      icon: GetWorkspaceResponseBodyWorkspaceIcon,
      modifiedTime: 'string',
      modifierId: 'string',
      name: 'string',
      permissionRole: 'string',
      rootNodeId: 'string',
      teamId: 'string',
      type: 'string',
      url: 'string',
      workspaceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkspacesHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkspacesRequestOption extends $tea.Model {
  withPermissionRole?: boolean;
  static names(): { [key: string]: string } {
    return {
      withPermissionRole: 'WithPermissionRole',
    };
  }

  static types(): { [key: string]: any } {
    return {
      withPermissionRole: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkspacesRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkspacesResponseBodyWorkspaceIcon extends $tea.Model {
  type?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      type: 'Type',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      type: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWorkspacesResponseBodyWorkspace extends $tea.Model {
  corpId?: string;
  cover?: string;
  createTime?: string;
  creatorId?: string;
  description?: string;
  icon?: GetWorkspacesResponseBodyWorkspaceIcon;
  modifiedTime?: string;
  modifierId?: string;
  name?: string;
  permissionRole?: string;
  rootNodeId?: string;
  teamId?: string;
  type?: string;
  url?: string;
  workspaceId?: string;
  static names(): { [key: string]: string } {
    return {
      corpId: 'CorpId',
      cover: 'Cover',
      createTime: 'CreateTime',
      creatorId: 'CreatorId',
      description: 'Description',
      icon: 'Icon',
      modifiedTime: 'ModifiedTime',
      modifierId: 'ModifierId',
      name: 'Name',
      permissionRole: 'PermissionRole',
      rootNodeId: 'RootNodeId',
      teamId: 'TeamId',
      type: 'Type',
      url: 'Url',
      workspaceId: 'WorkspaceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      corpId: 'string',
      cover: 'string',
      createTime: 'string',
      creatorId: 'string',
      description: 'string',
      icon: GetWorkspacesResponseBodyWorkspaceIcon,
      modifiedTime: 'string',
      modifierId: 'string',
      name: 'string',
      permissionRole: 'string',
      rootNodeId: 'string',
      teamId: 'string',
      type: 'string',
      url: 'string',
      workspaceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GrantHonorHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GrantHonorRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InsertColumnsBeforeHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InsertColumnsBeforeRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InsertRowsBeforeHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InsertRowsBeforeRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InviteUsersHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InviteUsersRequestInviteeList extends $tea.Model {
  nick?: string;
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      nick: 'Nick',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nick: 'string',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InviteUsersRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InviteUsersRequestPhoneInviteeList extends $tea.Model {
  nick?: string;
  phoneNumber?: string;
  static names(): { [key: string]: string } {
    return {
      nick: 'Nick',
      phoneNumber: 'PhoneNumber',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nick: 'string',
      phoneNumber: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListApplicationHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListApplicationResponseBodyData extends $tea.Model {
  appConfig?: string;
  appType?: string;
  applicationStatus?: string;
  corpId?: string;
  creatorUserId?: string;
  description?: string;
  icon?: string;
  inexistence?: string;
  name?: string;
  subCorpId?: string;
  static names(): { [key: string]: string } {
    return {
      appConfig: 'AppConfig',
      appType: 'AppType',
      applicationStatus: 'ApplicationStatus',
      corpId: 'CorpId',
      creatorUserId: 'CreatorUserId',
      description: 'Description',
      icon: 'Icon',
      inexistence: 'Inexistence',
      name: 'Name',
      subCorpId: 'SubCorpId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appConfig: 'string',
      appType: 'string',
      applicationStatus: 'string',
      corpId: 'string',
      creatorUserId: 'string',
      description: 'string',
      icon: 'string',
      inexistence: 'string',
      name: 'string',
      subCorpId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCalendarsHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCalendarsResponseBodyResponseCalendars extends $tea.Model {
  description?: string;
  ETag?: string;
  id?: string;
  privilege?: string;
  summary?: string;
  timeZone?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      ETag: 'ETag',
      id: 'Id',
      privilege: 'Privilege',
      summary: 'Summary',
      timeZone: 'TimeZone',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      ETag: 'string',
      id: 'string',
      privilege: 'string',
      summary: 'string',
      timeZone: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCalendarsResponseBodyResponse extends $tea.Model {
  calendars?: ListCalendarsResponseBodyResponseCalendars[];
  static names(): { [key: string]: string } {
    return {
      calendars: 'Calendars',
    };
  }

  static types(): { [key: string]: any } {
    return {
      calendars: { 'type': 'array', 'itemType': ListCalendarsResponseBodyResponseCalendars },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDentriesHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDentriesRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDentriesResponseBodyDentriesProperties extends $tea.Model {
  readOnly?: boolean;
  static names(): { [key: string]: string } {
    return {
      readOnly: 'ReadOnly',
    };
  }

  static types(): { [key: string]: any } {
    return {
      readOnly: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDentriesResponseBodyDentriesThumbnail extends $tea.Model {
  height?: number;
  url?: string;
  width?: number;
  static names(): { [key: string]: string } {
    return {
      height: 'Height',
      url: 'Url',
      width: 'Width',
    };
  }

  static types(): { [key: string]: any } {
    return {
      height: 'number',
      url: 'string',
      width: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDentriesResponseBodyDentries extends $tea.Model {
  appProperties?: { [key: string]: DentriesAppPropertiesValue[] };
  createTime?: string;
  creatorId?: string;
  extension?: string;
  id?: string;
  modifiedTime?: string;
  modifierId?: string;
  name?: string;
  parentId?: string;
  partitionType?: string;
  path?: string;
  properties?: ListDentriesResponseBodyDentriesProperties;
  size?: number;
  spaceId?: string;
  status?: string;
  storageDriver?: string;
  thumbnail?: ListDentriesResponseBodyDentriesThumbnail;
  type?: string;
  uuid?: string;
  version?: number;
  static names(): { [key: string]: string } {
    return {
      appProperties: 'AppProperties',
      createTime: 'CreateTime',
      creatorId: 'CreatorId',
      extension: 'Extension',
      id: 'Id',
      modifiedTime: 'ModifiedTime',
      modifierId: 'ModifierId',
      name: 'Name',
      parentId: 'ParentId',
      partitionType: 'PartitionType',
      path: 'Path',
      properties: 'Properties',
      size: 'Size',
      spaceId: 'SpaceId',
      status: 'Status',
      storageDriver: 'StorageDriver',
      thumbnail: 'Thumbnail',
      type: 'Type',
      uuid: 'Uuid',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appProperties: { 'type': 'map', 'keyType': 'string', 'valueType': { 'type': 'array', 'itemType': DentriesAppPropertiesValue } },
      createTime: 'string',
      creatorId: 'string',
      extension: 'string',
      id: 'string',
      modifiedTime: 'string',
      modifierId: 'string',
      name: 'string',
      parentId: 'string',
      partitionType: 'string',
      path: 'string',
      properties: ListDentriesResponseBodyDentriesProperties,
      size: 'number',
      spaceId: 'string',
      status: 'string',
      storageDriver: 'string',
      thumbnail: ListDentriesResponseBodyDentriesThumbnail,
      type: 'string',
      uuid: 'string',
      version: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEventsHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEventsResponseBodyEventsAttendees extends $tea.Model {
  displayName?: string;
  isOptional?: boolean;
  responseStatus?: string;
  self?: boolean;
  static names(): { [key: string]: string } {
    return {
      displayName: 'DisplayName',
      isOptional: 'IsOptional',
      responseStatus: 'ResponseStatus',
      self: 'Self',
    };
  }

  static types(): { [key: string]: any } {
    return {
      displayName: 'string',
      isOptional: 'boolean',
      responseStatus: 'string',
      self: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEventsResponseBodyEventsCategories extends $tea.Model {
  displayName?: string;
  static names(): { [key: string]: string } {
    return {
      displayName: 'DisplayName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      displayName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEventsResponseBodyEventsEnd extends $tea.Model {
  date?: string;
  dateTime?: string;
  timeZone?: string;
  static names(): { [key: string]: string } {
    return {
      date: 'Date',
      dateTime: 'DateTime',
      timeZone: 'TimeZone',
    };
  }

  static types(): { [key: string]: any } {
    return {
      date: 'string',
      dateTime: 'string',
      timeZone: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEventsResponseBodyEventsExtendedPropertiesSharedProperties extends $tea.Model {
  belongCorpId?: string;
  sourceOpenCid?: string;
  static names(): { [key: string]: string } {
    return {
      belongCorpId: 'BelongCorpId',
      sourceOpenCid: 'SourceOpenCid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      belongCorpId: 'string',
      sourceOpenCid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEventsResponseBodyEventsExtendedProperties extends $tea.Model {
  sharedProperties?: ListEventsResponseBodyEventsExtendedPropertiesSharedProperties;
  static names(): { [key: string]: string } {
    return {
      sharedProperties: 'SharedProperties',
    };
  }

  static types(): { [key: string]: any } {
    return {
      sharedProperties: ListEventsResponseBodyEventsExtendedPropertiesSharedProperties,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEventsResponseBodyEventsLocation extends $tea.Model {
  displayName?: string;
  meetingRooms?: string[];
  static names(): { [key: string]: string } {
    return {
      displayName: 'DisplayName',
      meetingRooms: 'MeetingRooms',
    };
  }

  static types(): { [key: string]: any } {
    return {
      displayName: 'string',
      meetingRooms: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEventsResponseBodyEventsMeetingRooms extends $tea.Model {
  displayName?: string;
  responseStatus?: string;
  roomId?: string;
  static names(): { [key: string]: string } {
    return {
      displayName: 'DisplayName',
      responseStatus: 'ResponseStatus',
      roomId: 'RoomId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      displayName: 'string',
      responseStatus: 'string',
      roomId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEventsResponseBodyEventsOnlineMeetingInfo extends $tea.Model {
  conferenceId?: string;
  extraInfo?: { [key: string]: any };
  type?: string;
  url?: string;
  static names(): { [key: string]: string } {
    return {
      conferenceId: 'ConferenceId',
      extraInfo: 'ExtraInfo',
      type: 'Type',
      url: 'Url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      conferenceId: 'string',
      extraInfo: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      type: 'string',
      url: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEventsResponseBodyEventsOrganizer extends $tea.Model {
  displayName?: string;
  responseStatus?: string;
  self?: boolean;
  static names(): { [key: string]: string } {
    return {
      displayName: 'DisplayName',
      responseStatus: 'ResponseStatus',
      self: 'Self',
    };
  }

  static types(): { [key: string]: any } {
    return {
      displayName: 'string',
      responseStatus: 'string',
      self: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEventsResponseBodyEventsOriginStart extends $tea.Model {
  dateTime?: string;
  static names(): { [key: string]: string } {
    return {
      dateTime: 'DateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dateTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEventsResponseBodyEventsRecurrencePattern extends $tea.Model {
  dayOfMonth?: number;
  daysOfWeek?: string;
  index?: string;
  interval?: number;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      dayOfMonth: 'DayOfMonth',
      daysOfWeek: 'DaysOfWeek',
      index: 'Index',
      interval: 'Interval',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dayOfMonth: 'number',
      daysOfWeek: 'string',
      index: 'string',
      interval: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEventsResponseBodyEventsRecurrenceRange extends $tea.Model {
  endDate?: string;
  numberOfOccurrences?: number;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      endDate: 'EndDate',
      numberOfOccurrences: 'NumberOfOccurrences',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endDate: 'string',
      numberOfOccurrences: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEventsResponseBodyEventsRecurrence extends $tea.Model {
  pattern?: ListEventsResponseBodyEventsRecurrencePattern;
  range?: ListEventsResponseBodyEventsRecurrenceRange;
  static names(): { [key: string]: string } {
    return {
      pattern: 'Pattern',
      range: 'Range',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pattern: ListEventsResponseBodyEventsRecurrencePattern,
      range: ListEventsResponseBodyEventsRecurrenceRange,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEventsResponseBodyEventsReminders extends $tea.Model {
  method?: string;
  minutes?: string;
  static names(): { [key: string]: string } {
    return {
      method: 'Method',
      minutes: 'Minutes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      method: 'string',
      minutes: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEventsResponseBodyEventsRichTextDescription extends $tea.Model {
  text?: string;
  static names(): { [key: string]: string } {
    return {
      text: 'Text',
    };
  }

  static types(): { [key: string]: any } {
    return {
      text: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEventsResponseBodyEventsStart extends $tea.Model {
  date?: string;
  dateTime?: string;
  timeZone?: string;
  static names(): { [key: string]: string } {
    return {
      date: 'Date',
      dateTime: 'DateTime',
      timeZone: 'TimeZone',
    };
  }

  static types(): { [key: string]: any } {
    return {
      date: 'string',
      dateTime: 'string',
      timeZone: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEventsResponseBodyEvents extends $tea.Model {
  attendees?: ListEventsResponseBodyEventsAttendees[];
  categories?: ListEventsResponseBodyEventsCategories[];
  createTime?: string;
  description?: string;
  end?: ListEventsResponseBodyEventsEnd;
  extendedProperties?: ListEventsResponseBodyEventsExtendedProperties;
  id?: string;
  isAllDay?: boolean;
  location?: ListEventsResponseBodyEventsLocation;
  meetingRooms?: ListEventsResponseBodyEventsMeetingRooms[];
  onlineMeetingInfo?: ListEventsResponseBodyEventsOnlineMeetingInfo;
  organizer?: ListEventsResponseBodyEventsOrganizer;
  originStart?: ListEventsResponseBodyEventsOriginStart;
  recurrence?: ListEventsResponseBodyEventsRecurrence;
  reminders?: ListEventsResponseBodyEventsReminders[];
  richTextDescription?: ListEventsResponseBodyEventsRichTextDescription;
  seriesMasterId?: string;
  start?: ListEventsResponseBodyEventsStart;
  status?: string;
  summary?: string;
  updateTime?: string;
  static names(): { [key: string]: string } {
    return {
      attendees: 'Attendees',
      categories: 'Categories',
      createTime: 'CreateTime',
      description: 'Description',
      end: 'End',
      extendedProperties: 'ExtendedProperties',
      id: 'Id',
      isAllDay: 'IsAllDay',
      location: 'Location',
      meetingRooms: 'MeetingRooms',
      onlineMeetingInfo: 'OnlineMeetingInfo',
      organizer: 'Organizer',
      originStart: 'OriginStart',
      recurrence: 'Recurrence',
      reminders: 'Reminders',
      richTextDescription: 'RichTextDescription',
      seriesMasterId: 'SeriesMasterId',
      start: 'Start',
      status: 'Status',
      summary: 'Summary',
      updateTime: 'UpdateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attendees: { 'type': 'array', 'itemType': ListEventsResponseBodyEventsAttendees },
      categories: { 'type': 'array', 'itemType': ListEventsResponseBodyEventsCategories },
      createTime: 'string',
      description: 'string',
      end: ListEventsResponseBodyEventsEnd,
      extendedProperties: ListEventsResponseBodyEventsExtendedProperties,
      id: 'string',
      isAllDay: 'boolean',
      location: ListEventsResponseBodyEventsLocation,
      meetingRooms: { 'type': 'array', 'itemType': ListEventsResponseBodyEventsMeetingRooms },
      onlineMeetingInfo: ListEventsResponseBodyEventsOnlineMeetingInfo,
      organizer: ListEventsResponseBodyEventsOrganizer,
      originStart: ListEventsResponseBodyEventsOriginStart,
      recurrence: ListEventsResponseBodyEventsRecurrence,
      reminders: { 'type': 'array', 'itemType': ListEventsResponseBodyEventsReminders },
      richTextDescription: ListEventsResponseBodyEventsRichTextDescription,
      seriesMasterId: 'string',
      start: ListEventsResponseBodyEventsStart,
      status: 'string',
      summary: 'string',
      updateTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEventsViewHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEventsViewResponseBodyEventsAttendees extends $tea.Model {
  displayName?: string;
  id?: string;
  isOptional?: boolean;
  responseStatus?: string;
  self?: boolean;
  static names(): { [key: string]: string } {
    return {
      displayName: 'DisplayName',
      id: 'Id',
      isOptional: 'IsOptional',
      responseStatus: 'ResponseStatus',
      self: 'Self',
    };
  }

  static types(): { [key: string]: any } {
    return {
      displayName: 'string',
      id: 'string',
      isOptional: 'boolean',
      responseStatus: 'string',
      self: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEventsViewResponseBodyEventsCategories extends $tea.Model {
  displayName?: string;
  static names(): { [key: string]: string } {
    return {
      displayName: 'DisplayName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      displayName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEventsViewResponseBodyEventsEnd extends $tea.Model {
  date?: string;
  dateTime?: string;
  timeZone?: string;
  static names(): { [key: string]: string } {
    return {
      date: 'Date',
      dateTime: 'DateTime',
      timeZone: 'TimeZone',
    };
  }

  static types(): { [key: string]: any } {
    return {
      date: 'string',
      dateTime: 'string',
      timeZone: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEventsViewResponseBodyEventsExtendedPropertiesSharedProperties extends $tea.Model {
  belongCorpId?: string;
  sourceOpenCid?: string;
  static names(): { [key: string]: string } {
    return {
      belongCorpId: 'BelongCorpId',
      sourceOpenCid: 'SourceOpenCid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      belongCorpId: 'string',
      sourceOpenCid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEventsViewResponseBodyEventsExtendedProperties extends $tea.Model {
  sharedProperties?: ListEventsViewResponseBodyEventsExtendedPropertiesSharedProperties;
  static names(): { [key: string]: string } {
    return {
      sharedProperties: 'SharedProperties',
    };
  }

  static types(): { [key: string]: any } {
    return {
      sharedProperties: ListEventsViewResponseBodyEventsExtendedPropertiesSharedProperties,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEventsViewResponseBodyEventsLocation extends $tea.Model {
  displayName?: string;
  meetingRooms?: string[];
  static names(): { [key: string]: string } {
    return {
      displayName: 'DisplayName',
      meetingRooms: 'MeetingRooms',
    };
  }

  static types(): { [key: string]: any } {
    return {
      displayName: 'string',
      meetingRooms: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEventsViewResponseBodyEventsMeetingRooms extends $tea.Model {
  displayName?: string;
  responseStatus?: string;
  roomId?: string;
  static names(): { [key: string]: string } {
    return {
      displayName: 'DisplayName',
      responseStatus: 'ResponseStatus',
      roomId: 'RoomId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      displayName: 'string',
      responseStatus: 'string',
      roomId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEventsViewResponseBodyEventsOnlineMeetingInfo extends $tea.Model {
  conferenceId?: string;
  extraInfo?: { [key: string]: any };
  type?: string;
  url?: string;
  static names(): { [key: string]: string } {
    return {
      conferenceId: 'ConferenceId',
      extraInfo: 'ExtraInfo',
      type: 'Type',
      url: 'Url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      conferenceId: 'string',
      extraInfo: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      type: 'string',
      url: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEventsViewResponseBodyEventsOrganizer extends $tea.Model {
  displayName?: string;
  id?: string;
  responseStatus?: string;
  self?: boolean;
  static names(): { [key: string]: string } {
    return {
      displayName: 'DisplayName',
      id: 'Id',
      responseStatus: 'ResponseStatus',
      self: 'Self',
    };
  }

  static types(): { [key: string]: any } {
    return {
      displayName: 'string',
      id: 'string',
      responseStatus: 'string',
      self: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEventsViewResponseBodyEventsOriginStart extends $tea.Model {
  dateTime?: string;
  static names(): { [key: string]: string } {
    return {
      dateTime: 'DateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dateTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEventsViewResponseBodyEventsRecurrencePattern extends $tea.Model {
  dayOfMonth?: number;
  daysOfWeek?: string;
  index?: string;
  interval?: number;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      dayOfMonth: 'DayOfMonth',
      daysOfWeek: 'DaysOfWeek',
      index: 'Index',
      interval: 'Interval',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dayOfMonth: 'number',
      daysOfWeek: 'string',
      index: 'string',
      interval: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEventsViewResponseBodyEventsRecurrenceRange extends $tea.Model {
  endDate?: string;
  numberOfOccurrences?: number;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      endDate: 'EndDate',
      numberOfOccurrences: 'NumberOfOccurrences',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endDate: 'string',
      numberOfOccurrences: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEventsViewResponseBodyEventsRecurrence extends $tea.Model {
  pattern?: ListEventsViewResponseBodyEventsRecurrencePattern;
  range?: ListEventsViewResponseBodyEventsRecurrenceRange;
  static names(): { [key: string]: string } {
    return {
      pattern: 'Pattern',
      range: 'Range',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pattern: ListEventsViewResponseBodyEventsRecurrencePattern,
      range: ListEventsViewResponseBodyEventsRecurrenceRange,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEventsViewResponseBodyEventsRichTextDescription extends $tea.Model {
  text?: string;
  static names(): { [key: string]: string } {
    return {
      text: 'Text',
    };
  }

  static types(): { [key: string]: any } {
    return {
      text: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEventsViewResponseBodyEventsStart extends $tea.Model {
  date?: string;
  dateTime?: string;
  timeZone?: string;
  static names(): { [key: string]: string } {
    return {
      date: 'Date',
      dateTime: 'DateTime',
      timeZone: 'TimeZone',
    };
  }

  static types(): { [key: string]: any } {
    return {
      date: 'string',
      dateTime: 'string',
      timeZone: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEventsViewResponseBodyEvents extends $tea.Model {
  attendees?: ListEventsViewResponseBodyEventsAttendees[];
  categories?: ListEventsViewResponseBodyEventsCategories[];
  createTime?: string;
  description?: string;
  end?: ListEventsViewResponseBodyEventsEnd;
  extendedProperties?: ListEventsViewResponseBodyEventsExtendedProperties;
  id?: string;
  isAllDay?: boolean;
  location?: ListEventsViewResponseBodyEventsLocation;
  meetingRooms?: ListEventsViewResponseBodyEventsMeetingRooms[];
  onlineMeetingInfo?: ListEventsViewResponseBodyEventsOnlineMeetingInfo;
  organizer?: ListEventsViewResponseBodyEventsOrganizer;
  originStart?: ListEventsViewResponseBodyEventsOriginStart;
  recurrence?: ListEventsViewResponseBodyEventsRecurrence;
  richTextDescription?: ListEventsViewResponseBodyEventsRichTextDescription;
  seriesMasterId?: string;
  start?: ListEventsViewResponseBodyEventsStart;
  status?: string;
  summary?: string;
  updateTime?: string;
  static names(): { [key: string]: string } {
    return {
      attendees: 'Attendees',
      categories: 'Categories',
      createTime: 'CreateTime',
      description: 'Description',
      end: 'End',
      extendedProperties: 'ExtendedProperties',
      id: 'Id',
      isAllDay: 'IsAllDay',
      location: 'Location',
      meetingRooms: 'MeetingRooms',
      onlineMeetingInfo: 'OnlineMeetingInfo',
      organizer: 'Organizer',
      originStart: 'OriginStart',
      recurrence: 'Recurrence',
      richTextDescription: 'RichTextDescription',
      seriesMasterId: 'SeriesMasterId',
      start: 'Start',
      status: 'Status',
      summary: 'Summary',
      updateTime: 'UpdateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attendees: { 'type': 'array', 'itemType': ListEventsViewResponseBodyEventsAttendees },
      categories: { 'type': 'array', 'itemType': ListEventsViewResponseBodyEventsCategories },
      createTime: 'string',
      description: 'string',
      end: ListEventsViewResponseBodyEventsEnd,
      extendedProperties: ListEventsViewResponseBodyEventsExtendedProperties,
      id: 'string',
      isAllDay: 'boolean',
      location: ListEventsViewResponseBodyEventsLocation,
      meetingRooms: { 'type': 'array', 'itemType': ListEventsViewResponseBodyEventsMeetingRooms },
      onlineMeetingInfo: ListEventsViewResponseBodyEventsOnlineMeetingInfo,
      organizer: ListEventsViewResponseBodyEventsOrganizer,
      originStart: ListEventsViewResponseBodyEventsOriginStart,
      recurrence: ListEventsViewResponseBodyEventsRecurrence,
      richTextDescription: ListEventsViewResponseBodyEventsRichTextDescription,
      seriesMasterId: 'string',
      start: ListEventsViewResponseBodyEventsStart,
      status: 'string',
      summary: 'string',
      updateTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFormRemarksHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListNavigationByFormTypeHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListNavigationByFormTypeResponseBodyResultTitle extends $tea.Model {
  nameInChinese?: string;
  nameInEnglish?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      nameInChinese: 'NameInChinese',
      nameInEnglish: 'NameInEnglish',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nameInChinese: 'string',
      nameInEnglish: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListNavigationByFormTypeResponseBodyResult extends $tea.Model {
  formUuid?: string;
  processCode?: string;
  title?: ListNavigationByFormTypeResponseBodyResultTitle;
  static names(): { [key: string]: string } {
    return {
      formUuid: 'FormUuid',
      processCode: 'ProcessCode',
      title: 'Title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      formUuid: 'string',
      processCode: 'string',
      title: ListNavigationByFormTypeResponseBodyResultTitle,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListNodesHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListNodesRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListNodesResponseBodyNodesStatisticalInfo extends $tea.Model {
  wordCount?: number;
  static names(): { [key: string]: string } {
    return {
      wordCount: 'WordCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      wordCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListNodesResponseBodyNodes extends $tea.Model {
  category?: string;
  createTime?: string;
  creatorId?: string;
  extension?: string;
  hasChildren?: boolean;
  modifiedTime?: string;
  modifierId?: string;
  name?: string;
  nodeId?: string;
  permissionRole?: string;
  size?: number;
  statisticalInfo?: ListNodesResponseBodyNodesStatisticalInfo;
  type?: string;
  url?: string;
  workspaceId?: string;
  static names(): { [key: string]: string } {
    return {
      category: 'Category',
      createTime: 'CreateTime',
      creatorId: 'CreatorId',
      extension: 'Extension',
      hasChildren: 'HasChildren',
      modifiedTime: 'ModifiedTime',
      modifierId: 'ModifierId',
      name: 'Name',
      nodeId: 'NodeId',
      permissionRole: 'PermissionRole',
      size: 'Size',
      statisticalInfo: 'StatisticalInfo',
      type: 'Type',
      url: 'Url',
      workspaceId: 'WorkspaceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
      createTime: 'string',
      creatorId: 'string',
      extension: 'string',
      hasChildren: 'boolean',
      modifiedTime: 'string',
      modifierId: 'string',
      name: 'string',
      nodeId: 'string',
      permissionRole: 'string',
      size: 'number',
      statisticalInfo: ListNodesResponseBodyNodesStatisticalInfo,
      type: 'string',
      url: 'string',
      workspaceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListReportHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListReportRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListReportResponseBodyDataListContents extends $tea.Model {
  key?: string;
  sort?: string;
  type?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      sort: 'Sort',
      type: 'Type',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      sort: 'string',
      type: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListReportResponseBodyDataList extends $tea.Model {
  contents?: ListReportResponseBodyDataListContents[];
  createTime?: number;
  creatorId?: string;
  creatorName?: string;
  deptName?: string;
  images?: string[];
  latitude?: string;
  longitude?: string;
  modifiedTime?: number;
  remark?: string;
  reportId?: string;
  templateName?: string;
  static names(): { [key: string]: string } {
    return {
      contents: 'Contents',
      createTime: 'CreateTime',
      creatorId: 'CreatorId',
      creatorName: 'CreatorName',
      deptName: 'DeptName',
      images: 'Images',
      latitude: 'Latitude',
      longitude: 'Longitude',
      modifiedTime: 'ModifiedTime',
      remark: 'Remark',
      reportId: 'ReportId',
      templateName: 'TemplateName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contents: { 'type': 'array', 'itemType': ListReportResponseBodyDataListContents },
      createTime: 'number',
      creatorId: 'string',
      creatorName: 'string',
      deptName: 'string',
      images: { 'type': 'array', 'itemType': 'string' },
      latitude: 'string',
      longitude: 'string',
      modifiedTime: 'number',
      remark: 'string',
      reportId: 'string',
      templateName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTableDataByFormInstanceIdTableIdHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTeamsHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTeamsRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTeamsResponseBodyTeamsIcon extends $tea.Model {
  type?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      type: 'Type',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      type: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTeamsResponseBodyTeams extends $tea.Model {
  corpId?: string;
  cover?: string;
  createTime?: string;
  creatorId?: string;
  description?: string;
  icon?: ListTeamsResponseBodyTeamsIcon;
  modifiedTime?: string;
  modifierId?: string;
  name?: string;
  teamId?: string;
  static names(): { [key: string]: string } {
    return {
      corpId: 'CorpId',
      cover: 'Cover',
      createTime: 'CreateTime',
      creatorId: 'CreatorId',
      description: 'Description',
      icon: 'Icon',
      modifiedTime: 'ModifiedTime',
      modifierId: 'ModifierId',
      name: 'Name',
      teamId: 'TeamId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      corpId: 'string',
      cover: 'string',
      createTime: 'string',
      creatorId: 'string',
      description: 'string',
      icon: ListTeamsResponseBodyTeamsIcon,
      modifiedTime: 'string',
      modifierId: 'string',
      name: 'string',
      teamId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkspacesHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkspacesRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkspacesResponseBodyWorkspacesIcon extends $tea.Model {
  type?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      type: 'Type',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      type: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkspacesResponseBodyWorkspaces extends $tea.Model {
  corpId?: string;
  cover?: string;
  createTime?: string;
  creatorId?: string;
  description?: string;
  icon?: ListWorkspacesResponseBodyWorkspacesIcon;
  modifiedTime?: string;
  modifierId?: string;
  name?: string;
  permissionRole?: string;
  rootNodeId?: string;
  teamId?: string;
  type?: string;
  url?: string;
  workspaceId?: string;
  static names(): { [key: string]: string } {
    return {
      corpId: 'CorpId',
      cover: 'Cover',
      createTime: 'CreateTime',
      creatorId: 'CreatorId',
      description: 'Description',
      icon: 'Icon',
      modifiedTime: 'ModifiedTime',
      modifierId: 'ModifierId',
      name: 'Name',
      permissionRole: 'PermissionRole',
      rootNodeId: 'RootNodeId',
      teamId: 'TeamId',
      type: 'Type',
      url: 'Url',
      workspaceId: 'WorkspaceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      corpId: 'string',
      cover: 'string',
      createTime: 'string',
      creatorId: 'string',
      description: 'string',
      icon: ListWorkspacesResponseBodyWorkspacesIcon,
      modifiedTime: 'string',
      modifierId: 'string',
      name: 'string',
      permissionRole: 'string',
      rootNodeId: 'string',
      teamId: 'string',
      type: 'string',
      url: 'string',
      workspaceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PatchEventHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PatchEventRequestAttendees extends $tea.Model {
  id?: string;
  isOptional?: boolean;
  static names(): { [key: string]: string } {
    return {
      id: 'id',
      isOptional: 'isOptional',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      isOptional: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PatchEventRequestEnd extends $tea.Model {
  date?: string;
  dateTime?: string;
  timeZone?: string;
  static names(): { [key: string]: string } {
    return {
      date: 'date',
      dateTime: 'dateTime',
      timeZone: 'timeZone',
    };
  }

  static types(): { [key: string]: any } {
    return {
      date: 'string',
      dateTime: 'string',
      timeZone: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PatchEventRequestLocation extends $tea.Model {
  displayName?: string;
  static names(): { [key: string]: string } {
    return {
      displayName: 'displayName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      displayName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PatchEventRequestRecurrencePattern extends $tea.Model {
  dayOfMonth?: number;
  daysOfWeek?: string;
  index?: string;
  interval?: number;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      dayOfMonth: 'dayOfMonth',
      daysOfWeek: 'daysOfWeek',
      index: 'index',
      interval: 'interval',
      type: 'type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dayOfMonth: 'number',
      daysOfWeek: 'string',
      index: 'string',
      interval: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PatchEventRequestRecurrenceRange extends $tea.Model {
  endDate?: string;
  numberOfOccurrences?: number;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      endDate: 'endDate',
      numberOfOccurrences: 'numberOfOccurrences',
      type: 'type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endDate: 'string',
      numberOfOccurrences: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PatchEventRequestRecurrence extends $tea.Model {
  pattern?: PatchEventRequestRecurrencePattern;
  range?: PatchEventRequestRecurrenceRange;
  static names(): { [key: string]: string } {
    return {
      pattern: 'pattern',
      range: 'range',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pattern: PatchEventRequestRecurrencePattern,
      range: PatchEventRequestRecurrenceRange,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PatchEventRequestReminders extends $tea.Model {
  method?: string;
  minutes?: number;
  static names(): { [key: string]: string } {
    return {
      method: 'method',
      minutes: 'minutes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      method: 'string',
      minutes: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PatchEventRequestStart extends $tea.Model {
  date?: string;
  dateTime?: string;
  timeZone?: string;
  static names(): { [key: string]: string } {
    return {
      date: 'date',
      dateTime: 'dateTime',
      timeZone: 'timeZone',
    };
  }

  static types(): { [key: string]: any } {
    return {
      date: 'string',
      dateTime: 'string',
      timeZone: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PatchEventResponseBodyAttendees extends $tea.Model {
  displayName?: string;
  id?: string;
  isOptional?: boolean;
  responseStatus?: string;
  self?: boolean;
  static names(): { [key: string]: string } {
    return {
      displayName: 'DisplayName',
      id: 'Id',
      isOptional: 'IsOptional',
      responseStatus: 'ResponseStatus',
      self: 'Self',
    };
  }

  static types(): { [key: string]: any } {
    return {
      displayName: 'string',
      id: 'string',
      isOptional: 'boolean',
      responseStatus: 'string',
      self: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PatchEventResponseBodyEnd extends $tea.Model {
  date?: string;
  dateTime?: string;
  timeZone?: string;
  static names(): { [key: string]: string } {
    return {
      date: 'Date',
      dateTime: 'DateTime',
      timeZone: 'TimeZone',
    };
  }

  static types(): { [key: string]: any } {
    return {
      date: 'string',
      dateTime: 'string',
      timeZone: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PatchEventResponseBodyLocation extends $tea.Model {
  displayName?: string;
  meetingRooms?: string[];
  static names(): { [key: string]: string } {
    return {
      displayName: 'DisplayName',
      meetingRooms: 'MeetingRooms',
    };
  }

  static types(): { [key: string]: any } {
    return {
      displayName: 'string',
      meetingRooms: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PatchEventResponseBodyOrganizer extends $tea.Model {
  displayName?: string;
  id?: string;
  responseStatus?: string;
  self?: boolean;
  static names(): { [key: string]: string } {
    return {
      displayName: 'DisplayName',
      id: 'Id',
      responseStatus: 'ResponseStatus',
      self: 'Self',
    };
  }

  static types(): { [key: string]: any } {
    return {
      displayName: 'string',
      id: 'string',
      responseStatus: 'string',
      self: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PatchEventResponseBodyRecurrencePattern extends $tea.Model {
  dayOfMonth?: number;
  daysOfWeek?: string;
  index?: string;
  interval?: number;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      dayOfMonth: 'DayOfMonth',
      daysOfWeek: 'DaysOfWeek',
      index: 'Index',
      interval: 'Interval',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dayOfMonth: 'number',
      daysOfWeek: 'string',
      index: 'string',
      interval: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PatchEventResponseBodyRecurrenceRange extends $tea.Model {
  endDate?: string;
  numberOfOccurrences?: number;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      endDate: 'EndDate',
      numberOfOccurrences: 'NumberOfOccurrences',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endDate: 'string',
      numberOfOccurrences: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PatchEventResponseBodyRecurrence extends $tea.Model {
  pattern?: PatchEventResponseBodyRecurrencePattern;
  range?: PatchEventResponseBodyRecurrenceRange;
  static names(): { [key: string]: string } {
    return {
      pattern: 'Pattern',
      range: 'Range',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pattern: PatchEventResponseBodyRecurrencePattern,
      range: PatchEventResponseBodyRecurrenceRange,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PatchEventResponseBodyReminders extends $tea.Model {
  method?: string;
  minutes?: string;
  static names(): { [key: string]: string } {
    return {
      method: 'Method',
      minutes: 'Minutes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      method: 'string',
      minutes: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PatchEventResponseBodyStart extends $tea.Model {
  date?: string;
  dateTime?: string;
  timeZone?: string;
  static names(): { [key: string]: string } {
    return {
      date: 'Date',
      dateTime: 'DateTime',
      timeZone: 'TimeZone',
    };
  }

  static types(): { [key: string]: any } {
    return {
      date: 'string',
      dateTime: 'string',
      timeZone: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCloudRecordTextHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCloudRecordTextRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCloudRecordTextResponseBodyParagraphListSentenceListWordList extends $tea.Model {
  endTime?: number;
  startTime?: number;
  word?: string;
  wordId?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      startTime: 'StartTime',
      word: 'Word',
      wordId: 'WordId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'number',
      startTime: 'number',
      word: 'string',
      wordId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCloudRecordTextResponseBodyParagraphListSentenceList extends $tea.Model {
  endTime?: number;
  sentence?: string;
  startTime?: number;
  userId?: string;
  wordList?: QueryCloudRecordTextResponseBodyParagraphListSentenceListWordList[];
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      sentence: 'Sentence',
      startTime: 'StartTime',
      userId: 'UserId',
      wordList: 'WordList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'number',
      sentence: 'string',
      startTime: 'number',
      userId: 'string',
      wordList: { 'type': 'array', 'itemType': QueryCloudRecordTextResponseBodyParagraphListSentenceListWordList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCloudRecordTextResponseBodyParagraphList extends $tea.Model {
  endTime?: number;
  nextTtoken?: number;
  nickName?: string;
  paragraph?: string;
  recordId?: number;
  sentenceList?: QueryCloudRecordTextResponseBodyParagraphListSentenceList[];
  startTime?: number;
  status?: number;
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      nextTtoken: 'NextTtoken',
      nickName: 'NickName',
      paragraph: 'Paragraph',
      recordId: 'RecordId',
      sentenceList: 'SentenceList',
      startTime: 'StartTime',
      status: 'Status',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'number',
      nextTtoken: 'number',
      nickName: 'string',
      paragraph: 'string',
      recordId: 'number',
      sentenceList: { 'type': 'array', 'itemType': QueryCloudRecordTextResponseBodyParagraphListSentenceList },
      startTime: 'number',
      status: 'number',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCloudRecordVideoHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCloudRecordVideoRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCloudRecordVideoResponseBodyVideoList extends $tea.Model {
  duration?: number;
  endTime?: number;
  fileSize?: number;
  mediaId?: string;
  recordId?: string;
  recordType?: number;
  regionId?: string;
  startTime?: number;
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      duration: 'Duration',
      endTime: 'EndTime',
      fileSize: 'FileSize',
      mediaId: 'MediaId',
      recordId: 'RecordId',
      recordType: 'RecordType',
      regionId: 'RegionId',
      startTime: 'StartTime',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      duration: 'number',
      endTime: 'number',
      fileSize: 'number',
      mediaId: 'string',
      recordId: 'string',
      recordType: 'number',
      regionId: 'string',
      startTime: 'number',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCloudRecordVideoPlayInfoHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCloudRecordVideoPlayInfoRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryConferenceInfoHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryConferenceInfoResponseBodyConfInfo extends $tea.Model {
  activeNum?: number;
  attendNum?: number;
  confDuration?: number;
  conferenceId?: string;
  creatorId?: string;
  creatorNick?: string;
  endTime?: number;
  externalLinkUrl?: string;
  invitedNum?: number;
  roomCode?: string;
  startTime?: number;
  status?: number;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      activeNum: 'ActiveNum',
      attendNum: 'AttendNum',
      confDuration: 'ConfDuration',
      conferenceId: 'ConferenceId',
      creatorId: 'CreatorId',
      creatorNick: 'CreatorNick',
      endTime: 'EndTime',
      externalLinkUrl: 'ExternalLinkUrl',
      invitedNum: 'InvitedNum',
      roomCode: 'RoomCode',
      startTime: 'StartTime',
      status: 'Status',
      title: 'Title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      activeNum: 'number',
      attendNum: 'number',
      confDuration: 'number',
      conferenceId: 'string',
      creatorId: 'string',
      creatorNick: 'string',
      endTime: 'number',
      externalLinkUrl: 'string',
      invitedNum: 'number',
      roomCode: 'string',
      startTime: 'number',
      status: 'number',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryConferenceMembersHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryConferenceMembersRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryConferenceMembersResponseBodyMemberModels extends $tea.Model {
  attendStatus?: number;
  coHost?: boolean;
  conferenceId?: string;
  duration?: number;
  host?: boolean;
  joinTime?: number;
  leaveTime?: number;
  outerOrgMember?: boolean;
  pstnJoin?: boolean;
  userId?: string;
  userNick?: string;
  static names(): { [key: string]: string } {
    return {
      attendStatus: 'AttendStatus',
      coHost: 'CoHost',
      conferenceId: 'ConferenceId',
      duration: 'Duration',
      host: 'Host',
      joinTime: 'JoinTime',
      leaveTime: 'LeaveTime',
      outerOrgMember: 'OuterOrgMember',
      pstnJoin: 'PstnJoin',
      userId: 'UserId',
      userNick: 'UserNick',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attendStatus: 'number',
      coHost: 'boolean',
      conferenceId: 'string',
      duration: 'number',
      host: 'boolean',
      joinTime: 'number',
      leaveTime: 'number',
      outerOrgMember: 'boolean',
      pstnJoin: 'boolean',
      userId: 'string',
      userNick: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDentryHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDentryRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDentryResponseBodyCreator extends $tea.Model {
  name?: string;
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDentryResponseBodyLinkSourceInfoIconUrl extends $tea.Model {
  line?: string;
  small?: string;
  static names(): { [key: string]: string } {
    return {
      line: 'Line',
      small: 'Small',
    };
  }

  static types(): { [key: string]: any } {
    return {
      line: 'string',
      small: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDentryResponseBodyLinkSourceInfo extends $tea.Model {
  extension?: string;
  iconUrl?: QueryDentryResponseBodyLinkSourceInfoIconUrl;
  id?: string;
  linkType?: number;
  spaceId?: string;
  static names(): { [key: string]: string } {
    return {
      extension: 'Extension',
      iconUrl: 'IconUrl',
      id: 'Id',
      linkType: 'LinkType',
      spaceId: 'SpaceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      extension: 'string',
      iconUrl: QueryDentryResponseBodyLinkSourceInfoIconUrl,
      id: 'string',
      linkType: 'number',
      spaceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDentryResponseBodySpaceHdIconVO extends $tea.Model {
  icon?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      icon: 'Icon',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      icon: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDentryResponseBodySpaceIconVO extends $tea.Model {
  icon?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      icon: 'Icon',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      icon: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDentryResponseBodySpaceOwner extends $tea.Model {
  name?: string;
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDentryResponseBodySpaceRecentListCreator extends $tea.Model {
  name?: string;
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDentryResponseBodySpaceRecentListLinkSourceInfoIconUrl extends $tea.Model {
  line?: string;
  small?: string;
  static names(): { [key: string]: string } {
    return {
      line: 'Line',
      small: 'Small',
    };
  }

  static types(): { [key: string]: any } {
    return {
      line: 'string',
      small: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDentryResponseBodySpaceRecentListLinkSourceInfo extends $tea.Model {
  extension?: string;
  iconUrl?: QueryDentryResponseBodySpaceRecentListLinkSourceInfoIconUrl;
  id?: string;
  linkType?: number;
  spaceId?: string;
  static names(): { [key: string]: string } {
    return {
      extension: 'Extension',
      iconUrl: 'IconUrl',
      id: 'Id',
      linkType: 'LinkType',
      spaceId: 'SpaceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      extension: 'string',
      iconUrl: QueryDentryResponseBodySpaceRecentListLinkSourceInfoIconUrl,
      id: 'string',
      linkType: 'number',
      spaceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDentryResponseBodySpaceRecentListStatisticalInfo extends $tea.Model {
  wordCount?: number;
  static names(): { [key: string]: string } {
    return {
      wordCount: 'WordCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      wordCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDentryResponseBodySpaceRecentListUpdater extends $tea.Model {
  name?: string;
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDentryResponseBodySpaceRecentListVisitorInfo extends $tea.Model {
  dentryActions?: string[];
  roleCode?: string;
  spaceActions?: string[];
  static names(): { [key: string]: string } {
    return {
      dentryActions: 'DentryActions',
      roleCode: 'RoleCode',
      spaceActions: 'SpaceActions',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dentryActions: { 'type': 'array', 'itemType': 'string' },
      roleCode: 'string',
      spaceActions: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDentryResponseBodySpaceRecentList extends $tea.Model {
  contentType?: string;
  createdTime?: number;
  creator?: QueryDentryResponseBodySpaceRecentListCreator;
  dentryId?: string;
  dentryType?: string;
  dentryUuid?: string;
  docKey?: string;
  extension?: string;
  hasChildren?: boolean;
  linkSourceInfo?: QueryDentryResponseBodySpaceRecentListLinkSourceInfo;
  name?: string;
  path?: string;
  space?: any;
  spaceId?: string;
  statisticalInfo?: QueryDentryResponseBodySpaceRecentListStatisticalInfo;
  updatedTime?: number;
  updater?: QueryDentryResponseBodySpaceRecentListUpdater;
  url?: string;
  visitorInfo?: QueryDentryResponseBodySpaceRecentListVisitorInfo;
  static names(): { [key: string]: string } {
    return {
      contentType: 'ContentType',
      createdTime: 'CreatedTime',
      creator: 'Creator',
      dentryId: 'DentryId',
      dentryType: 'DentryType',
      dentryUuid: 'DentryUuid',
      docKey: 'DocKey',
      extension: 'Extension',
      hasChildren: 'HasChildren',
      linkSourceInfo: 'LinkSourceInfo',
      name: 'Name',
      path: 'Path',
      space: 'Space',
      spaceId: 'SpaceId',
      statisticalInfo: 'StatisticalInfo',
      updatedTime: 'UpdatedTime',
      updater: 'Updater',
      url: 'Url',
      visitorInfo: 'VisitorInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contentType: 'string',
      createdTime: 'number',
      creator: QueryDentryResponseBodySpaceRecentListCreator,
      dentryId: 'string',
      dentryType: 'string',
      dentryUuid: 'string',
      docKey: 'string',
      extension: 'string',
      hasChildren: 'boolean',
      linkSourceInfo: QueryDentryResponseBodySpaceRecentListLinkSourceInfo,
      name: 'string',
      path: 'string',
      space: 'any',
      spaceId: 'string',
      statisticalInfo: QueryDentryResponseBodySpaceRecentListStatisticalInfo,
      updatedTime: 'number',
      updater: QueryDentryResponseBodySpaceRecentListUpdater,
      url: 'string',
      visitorInfo: QueryDentryResponseBodySpaceRecentListVisitorInfo,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDentryResponseBodySpaceVisitorInfo extends $tea.Model {
  dentryActions?: string[];
  roleCode?: string;
  spaceActions?: string[];
  static names(): { [key: string]: string } {
    return {
      dentryActions: 'DentryActions',
      roleCode: 'RoleCode',
      spaceActions: 'SpaceActions',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dentryActions: { 'type': 'array', 'itemType': 'string' },
      roleCode: 'string',
      spaceActions: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDentryResponseBodySpace extends $tea.Model {
  cover?: string;
  description?: string;
  hdIconVO?: QueryDentryResponseBodySpaceHdIconVO;
  iconVO?: QueryDentryResponseBodySpaceIconVO;
  id?: string;
  name?: string;
  owner?: QueryDentryResponseBodySpaceOwner;
  recentList?: QueryDentryResponseBodySpaceRecentList[];
  type?: number;
  url?: string;
  visitorInfo?: QueryDentryResponseBodySpaceVisitorInfo;
  static names(): { [key: string]: string } {
    return {
      cover: 'Cover',
      description: 'Description',
      hdIconVO: 'HdIconVO',
      iconVO: 'IconVO',
      id: 'Id',
      name: 'Name',
      owner: 'Owner',
      recentList: 'RecentList',
      type: 'Type',
      url: 'Url',
      visitorInfo: 'VisitorInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cover: 'string',
      description: 'string',
      hdIconVO: QueryDentryResponseBodySpaceHdIconVO,
      iconVO: QueryDentryResponseBodySpaceIconVO,
      id: 'string',
      name: 'string',
      owner: QueryDentryResponseBodySpaceOwner,
      recentList: { 'type': 'array', 'itemType': QueryDentryResponseBodySpaceRecentList },
      type: 'number',
      url: 'string',
      visitorInfo: QueryDentryResponseBodySpaceVisitorInfo,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDentryResponseBodyUpdater extends $tea.Model {
  name?: string;
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDentryResponseBodyVisitorInfo extends $tea.Model {
  dentryActions?: string[];
  roleCode?: string;
  spaceActions?: string[];
  static names(): { [key: string]: string } {
    return {
      dentryActions: 'DentryActions',
      roleCode: 'RoleCode',
      spaceActions: 'SpaceActions',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dentryActions: { 'type': 'array', 'itemType': 'string' },
      roleCode: 'string',
      spaceActions: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryLiveInfoHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryLiveInfoRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryLiveWatchDetailHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryLiveWatchDetailRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryLiveWatchUserListHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryLiveWatchUserListRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryLiveWatchUserListResponseBodyOrgUsesList extends $tea.Model {
  deptName?: string;
  name?: string;
  userId?: string;
  watchLiveTime?: number;
  watchPlaybackTime?: number;
  watchProgressMs?: number;
  static names(): { [key: string]: string } {
    return {
      deptName: 'DeptName',
      name: 'Name',
      userId: 'UserId',
      watchLiveTime: 'WatchLiveTime',
      watchPlaybackTime: 'WatchPlaybackTime',
      watchProgressMs: 'WatchProgressMs',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deptName: 'string',
      name: 'string',
      userId: 'string',
      watchLiveTime: 'number',
      watchPlaybackTime: 'number',
      watchProgressMs: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryLiveWatchUserListResponseBodyOutOrgUserList extends $tea.Model {
  name?: string;
  watchLiveTime?: number;
  watchPlaybackTime?: number;
  watchProgressMs?: number;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      watchLiveTime: 'WatchLiveTime',
      watchPlaybackTime: 'WatchPlaybackTime',
      watchProgressMs: 'WatchProgressMs',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      watchLiveTime: 'number',
      watchPlaybackTime: 'number',
      watchProgressMs: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMeetingRoomHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMeetingRoomRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMeetingRoomResponseBodyResultReservationAuthorityAuthorizedMembers extends $tea.Model {
  memberId?: string;
  memberName?: string;
  memberType?: string;
  static names(): { [key: string]: string } {
    return {
      memberId: 'MemberId',
      memberName: 'MemberName',
      memberType: 'MemberType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      memberId: 'string',
      memberName: 'string',
      memberType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMeetingRoomResponseBodyResultReservationAuthority extends $tea.Model {
  authorizedMembers?: QueryMeetingRoomResponseBodyResultReservationAuthorityAuthorizedMembers[];
  static names(): { [key: string]: string } {
    return {
      authorizedMembers: 'AuthorizedMembers',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authorizedMembers: { 'type': 'array', 'itemType': QueryMeetingRoomResponseBodyResultReservationAuthorityAuthorizedMembers },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMeetingRoomResponseBodyResultRoomGroup extends $tea.Model {
  groupId?: number;
  groupName?: string;
  parentId?: number;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      groupName: 'GroupName',
      parentId: 'ParentId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'number',
      groupName: 'string',
      parentId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMeetingRoomResponseBodyResultRoomLabels extends $tea.Model {
  labelId?: number;
  labelName?: string;
  static names(): { [key: string]: string } {
    return {
      labelId: 'LabelId',
      labelName: 'LabelName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      labelId: 'number',
      labelName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMeetingRoomResponseBodyResultRoomLocation extends $tea.Model {
  desc?: string;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      desc: 'Desc',
      title: 'Title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      desc: 'string',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMeetingRoomResponseBodyResult extends $tea.Model {
  corpId?: string;
  deviceUnionIds?: string[];
  enableCycleReservation?: boolean;
  isvRoomId?: string;
  reservationAuthority?: QueryMeetingRoomResponseBodyResultReservationAuthority;
  roomCapacity?: number;
  roomGroup?: QueryMeetingRoomResponseBodyResultRoomGroup;
  roomId?: string;
  roomLabels?: QueryMeetingRoomResponseBodyResultRoomLabels[];
  roomLocation?: QueryMeetingRoomResponseBodyResultRoomLocation;
  roomName?: string;
  roomPicture?: string;
  roomStaffId?: string;
  roomStatus?: number;
  static names(): { [key: string]: string } {
    return {
      corpId: 'CorpId',
      deviceUnionIds: 'DeviceUnionIds',
      enableCycleReservation: 'EnableCycleReservation',
      isvRoomId: 'IsvRoomId',
      reservationAuthority: 'ReservationAuthority',
      roomCapacity: 'RoomCapacity',
      roomGroup: 'RoomGroup',
      roomId: 'RoomId',
      roomLabels: 'RoomLabels',
      roomLocation: 'RoomLocation',
      roomName: 'RoomName',
      roomPicture: 'RoomPicture',
      roomStaffId: 'RoomStaffId',
      roomStatus: 'RoomStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      corpId: 'string',
      deviceUnionIds: { 'type': 'array', 'itemType': 'string' },
      enableCycleReservation: 'boolean',
      isvRoomId: 'string',
      reservationAuthority: QueryMeetingRoomResponseBodyResultReservationAuthority,
      roomCapacity: 'number',
      roomGroup: QueryMeetingRoomResponseBodyResultRoomGroup,
      roomId: 'string',
      roomLabels: { 'type': 'array', 'itemType': QueryMeetingRoomResponseBodyResultRoomLabels },
      roomLocation: QueryMeetingRoomResponseBodyResultRoomLocation,
      roomName: 'string',
      roomPicture: 'string',
      roomStaffId: 'string',
      roomStatus: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMeetingRoomGroupHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMeetingRoomGroupRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMeetingRoomGroupListHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMeetingRoomGroupListRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMeetingRoomGroupListResponseBodyResult extends $tea.Model {
  groupId?: number;
  groupName?: string;
  parentId?: number;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      groupName: 'GroupName',
      parentId: 'ParentId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'number',
      groupName: 'string',
      parentId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMeetingRoomListHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMeetingRoomListRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMeetingRoomListResponseBodyResultRoomGroup extends $tea.Model {
  groupId?: number;
  groupName?: string;
  parentId?: number;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      groupName: 'GroupName',
      parentId: 'ParentId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'number',
      groupName: 'string',
      parentId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMeetingRoomListResponseBodyResultRoomLabels extends $tea.Model {
  labelId?: number;
  labelName?: string;
  static names(): { [key: string]: string } {
    return {
      labelId: 'LabelId',
      labelName: 'LabelName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      labelId: 'number',
      labelName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMeetingRoomListResponseBodyResultRoomLocation extends $tea.Model {
  desc?: string;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      desc: 'Desc',
      title: 'Title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      desc: 'string',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMeetingRoomListResponseBodyResult extends $tea.Model {
  corpId?: string;
  isvRoomId?: string;
  roomCapacity?: number;
  roomGroup?: QueryMeetingRoomListResponseBodyResultRoomGroup;
  roomId?: string;
  roomLabels?: QueryMeetingRoomListResponseBodyResultRoomLabels[];
  roomLocation?: QueryMeetingRoomListResponseBodyResultRoomLocation;
  roomName?: string;
  roomPicture?: string;
  roomStaffId?: string;
  roomStatus?: number;
  static names(): { [key: string]: string } {
    return {
      corpId: 'CorpId',
      isvRoomId: 'IsvRoomId',
      roomCapacity: 'RoomCapacity',
      roomGroup: 'RoomGroup',
      roomId: 'RoomId',
      roomLabels: 'RoomLabels',
      roomLocation: 'RoomLocation',
      roomName: 'RoomName',
      roomPicture: 'RoomPicture',
      roomStaffId: 'RoomStaffId',
      roomStatus: 'RoomStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      corpId: 'string',
      isvRoomId: 'string',
      roomCapacity: 'number',
      roomGroup: QueryMeetingRoomListResponseBodyResultRoomGroup,
      roomId: 'string',
      roomLabels: { 'type': 'array', 'itemType': QueryMeetingRoomListResponseBodyResultRoomLabels },
      roomLocation: QueryMeetingRoomListResponseBodyResultRoomLocation,
      roomName: 'string',
      roomPicture: 'string',
      roomStaffId: 'string',
      roomStatus: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryOrgHonorsHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryOrgHonorsRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryOrgHonorsResponseBodyOpenHonors extends $tea.Model {
  honorDesc?: string;
  honorId?: number;
  honorImgUrl?: string;
  honorName?: string;
  honorPendantImgUrl?: string;
  static names(): { [key: string]: string } {
    return {
      honorDesc: 'honorDesc',
      honorId: 'honorId',
      honorImgUrl: 'honorImgUrl',
      honorName: 'honorName',
      honorPendantImgUrl: 'honorPendantImgUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      honorDesc: 'string',
      honorId: 'number',
      honorImgUrl: 'string',
      honorName: 'string',
      honorPendantImgUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryOrgTodoTasksHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryOrgTodoTasksRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryOrgTodoTasksResponseBodyTodoCardsDetailUrl extends $tea.Model {
  appUrl?: string;
  pcUrl?: string;
  static names(): { [key: string]: string } {
    return {
      appUrl: 'appUrl',
      pcUrl: 'pcUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appUrl: 'string',
      pcUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryOrgTodoTasksResponseBodyTodoCards extends $tea.Model {
  bizTag?: string;
  createdTime?: number;
  creatorId?: string;
  detailUrl?: QueryOrgTodoTasksResponseBodyTodoCardsDetailUrl;
  dueTime?: number;
  isDone?: boolean;
  modifiedTime?: number;
  priority?: number;
  sourceId?: string;
  subject?: string;
  taskId?: string;
  static names(): { [key: string]: string } {
    return {
      bizTag: 'bizTag',
      createdTime: 'createdTime',
      creatorId: 'creatorId',
      detailUrl: 'detailUrl',
      dueTime: 'dueTime',
      isDone: 'isDone',
      modifiedTime: 'modifiedTime',
      priority: 'priority',
      sourceId: 'sourceId',
      subject: 'subject',
      taskId: 'taskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizTag: 'string',
      createdTime: 'number',
      creatorId: 'string',
      detailUrl: QueryOrgTodoTasksResponseBodyTodoCardsDetailUrl,
      dueTime: 'number',
      isDone: 'boolean',
      modifiedTime: 'number',
      priority: 'number',
      sourceId: 'string',
      subject: 'string',
      taskId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryScheduleConferenceHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryScheduleConferenceRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryUserHonorsHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryUserHonorsRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryUserHonorsResponseBodyHonorsGrantHistory extends $tea.Model {
  grantTime?: number;
  senderUserid?: string;
  static names(): { [key: string]: string } {
    return {
      grantTime: 'grantTime',
      senderUserid: 'senderUserid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      grantTime: 'number',
      senderUserid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryUserHonorsResponseBodyHonors extends $tea.Model {
  expirationTime?: number;
  grantHistory?: QueryUserHonorsResponseBodyHonorsGrantHistory[];
  honorDesc?: string;
  honorId?: string;
  honorName?: string;
  static names(): { [key: string]: string } {
    return {
      expirationTime: 'expirationTime',
      grantHistory: 'grantHistory',
      honorDesc: 'honorDesc',
      honorId: 'honorId',
      honorName: 'honorName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      expirationTime: 'number',
      grantHistory: { 'type': 'array', 'itemType': QueryUserHonorsResponseBodyHonorsGrantHistory },
      honorDesc: 'string',
      honorId: 'string',
      honorName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RecallHonorHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RecallHonorRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RecallHonorResponseBodyContent extends $tea.Model {
  data?: any;
  static names(): { [key: string]: string } {
    return {
      data: 'data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'any',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReceiverListReportHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReceiverListReportRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RedirectTaskHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveAttendeeHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveAttendeeResponseBodyContent extends $tea.Model {
  data?: any;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'any',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveMeetingRoomsHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveMeetingRoomsRequestMeetingRoomsToRemove extends $tea.Model {
  roomId?: string;
  static names(): { [key: string]: string } {
    return {
      roomId: 'RoomId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      roomId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SaveContentHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SaveContentRequestContents extends $tea.Model {
  content?: string;
  contentType?: string;
  key?: string;
  sort?: number;
  type?: number;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      contentType: 'ContentType',
      key: 'Key',
      sort: 'Sort',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      contentType: 'string',
      key: 'string',
      sort: 'number',
      type: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SaveContentRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SaveFormDataHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SaveFormRemarkHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchEmployeeFieldValuesHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchFormDataIdListHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchFormDataSecondGenerationHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchFormDataSecondGenerationResponseBodyDataModifyUserName extends $tea.Model {
  nameInChinese?: string;
  nameInEnglish?: string;
  static names(): { [key: string]: string } {
    return {
      nameInChinese: 'NameInChinese',
      nameInEnglish: 'NameInEnglish',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nameInChinese: 'string',
      nameInEnglish: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchFormDataSecondGenerationResponseBodyDataModifyUser extends $tea.Model {
  name?: SearchFormDataSecondGenerationResponseBodyDataModifyUserName;
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: SearchFormDataSecondGenerationResponseBodyDataModifyUserName,
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchFormDataSecondGenerationResponseBodyDataOriginatorName extends $tea.Model {
  nameInChinese?: string;
  nameInEnglish?: string;
  static names(): { [key: string]: string } {
    return {
      nameInChinese: 'NameInChinese',
      nameInEnglish: 'NameInEnglish',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nameInChinese: 'string',
      nameInEnglish: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchFormDataSecondGenerationResponseBodyDataOriginator extends $tea.Model {
  name?: SearchFormDataSecondGenerationResponseBodyDataOriginatorName;
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: SearchFormDataSecondGenerationResponseBodyDataOriginatorName,
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchFormDataSecondGenerationResponseBodyData extends $tea.Model {
  createTimeGMT?: string;
  creatorUserId?: string;
  formData?: { [key: string]: any };
  formInstanceId?: string;
  formUuid?: string;
  id?: number;
  instanceValue?: string;
  modifiedTimeGMT?: string;
  modifier?: string;
  modifyUser?: SearchFormDataSecondGenerationResponseBodyDataModifyUser;
  originator?: SearchFormDataSecondGenerationResponseBodyDataOriginator;
  sequence?: string;
  serialNumber?: string;
  title?: string;
  version?: number;
  static names(): { [key: string]: string } {
    return {
      createTimeGMT: 'CreateTimeGMT',
      creatorUserId: 'CreatorUserId',
      formData: 'FormData',
      formInstanceId: 'FormInstanceId',
      formUuid: 'FormUuid',
      id: 'Id',
      instanceValue: 'InstanceValue',
      modifiedTimeGMT: 'ModifiedTimeGMT',
      modifier: 'Modifier',
      modifyUser: 'ModifyUser',
      originator: 'Originator',
      sequence: 'Sequence',
      serialNumber: 'SerialNumber',
      title: 'Title',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTimeGMT: 'string',
      creatorUserId: 'string',
      formData: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      formInstanceId: 'string',
      formUuid: 'string',
      id: 'number',
      instanceValue: 'string',
      modifiedTimeGMT: 'string',
      modifier: 'string',
      modifyUser: SearchFormDataSecondGenerationResponseBodyDataModifyUser,
      originator: SearchFormDataSecondGenerationResponseBodyDataOriginator,
      sequence: 'string',
      serialNumber: 'string',
      title: 'string',
      version: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchFormDataSecondGenerationNoTableFieldHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchFormDataSecondGenerationNoTableFieldResponseBodyDataModifyUserName extends $tea.Model {
  nameInChinese?: string;
  nameInEnglish?: string;
  static names(): { [key: string]: string } {
    return {
      nameInChinese: 'NameInChinese',
      nameInEnglish: 'NameInEnglish',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nameInChinese: 'string',
      nameInEnglish: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchFormDataSecondGenerationNoTableFieldResponseBodyDataModifyUser extends $tea.Model {
  name?: SearchFormDataSecondGenerationNoTableFieldResponseBodyDataModifyUserName;
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: SearchFormDataSecondGenerationNoTableFieldResponseBodyDataModifyUserName,
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchFormDataSecondGenerationNoTableFieldResponseBodyDataOriginatorName extends $tea.Model {
  nameInChinese?: string;
  nameInEnglish?: string;
  static names(): { [key: string]: string } {
    return {
      nameInChinese: 'NameInChinese',
      nameInEnglish: 'NameInEnglish',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nameInChinese: 'string',
      nameInEnglish: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchFormDataSecondGenerationNoTableFieldResponseBodyDataOriginator extends $tea.Model {
  name?: SearchFormDataSecondGenerationNoTableFieldResponseBodyDataOriginatorName;
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: SearchFormDataSecondGenerationNoTableFieldResponseBodyDataOriginatorName,
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchFormDataSecondGenerationNoTableFieldResponseBodyData extends $tea.Model {
  createTimeGMT?: string;
  creatorUserId?: string;
  formData?: { [key: string]: any };
  formInstanceId?: string;
  formUuid?: string;
  id?: number;
  instanceValue?: string;
  modifiedTimeGMT?: string;
  modifier?: string;
  modifyUser?: SearchFormDataSecondGenerationNoTableFieldResponseBodyDataModifyUser;
  originator?: SearchFormDataSecondGenerationNoTableFieldResponseBodyDataOriginator;
  sequence?: string;
  serialNumber?: string;
  title?: string;
  version?: number;
  static names(): { [key: string]: string } {
    return {
      createTimeGMT: 'CreateTimeGMT',
      creatorUserId: 'CreatorUserId',
      formData: 'FormData',
      formInstanceId: 'FormInstanceId',
      formUuid: 'FormUuid',
      id: 'Id',
      instanceValue: 'InstanceValue',
      modifiedTimeGMT: 'ModifiedTimeGMT',
      modifier: 'Modifier',
      modifyUser: 'ModifyUser',
      originator: 'Originator',
      sequence: 'Sequence',
      serialNumber: 'SerialNumber',
      title: 'Title',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTimeGMT: 'string',
      creatorUserId: 'string',
      formData: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      formInstanceId: 'string',
      formUuid: 'string',
      id: 'number',
      instanceValue: 'string',
      modifiedTimeGMT: 'string',
      modifier: 'string',
      modifyUser: SearchFormDataSecondGenerationNoTableFieldResponseBodyDataModifyUser,
      originator: SearchFormDataSecondGenerationNoTableFieldResponseBodyDataOriginator,
      sequence: 'string',
      serialNumber: 'string',
      title: 'string',
      version: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchFormDatasHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchFormDatasResponseBodyDataModifyUserUserName extends $tea.Model {
  nameInChinese?: string;
  nameInEnglish?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      nameInChinese: 'NameInChinese',
      nameInEnglish: 'NameInEnglish',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nameInChinese: 'string',
      nameInEnglish: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchFormDatasResponseBodyDataModifyUser extends $tea.Model {
  userId?: string;
  userName?: SearchFormDatasResponseBodyDataModifyUserUserName;
  static names(): { [key: string]: string } {
    return {
      userId: 'UserId',
      userName: 'UserName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      userId: 'string',
      userName: SearchFormDatasResponseBodyDataModifyUserUserName,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchFormDatasResponseBodyDataOriginatorUserName extends $tea.Model {
  nameInChinese?: string;
  nameInEnglish?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      nameInChinese: 'NameInChinese',
      nameInEnglish: 'NameInEnglish',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nameInChinese: 'string',
      nameInEnglish: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchFormDatasResponseBodyDataOriginator extends $tea.Model {
  userId?: string;
  userName?: SearchFormDatasResponseBodyDataOriginatorUserName;
  static names(): { [key: string]: string } {
    return {
      userId: 'UserId',
      userName: 'UserName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      userId: 'string',
      userName: SearchFormDatasResponseBodyDataOriginatorUserName,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchFormDatasResponseBodyData extends $tea.Model {
  createdTimeGMT?: string;
  creatorUserId?: string;
  dataId?: number;
  formData?: { [key: string]: any };
  formInstanceId?: string;
  formUuid?: string;
  instanceValue?: string;
  modelUuid?: string;
  modifiedTimeGMT?: string;
  modifierUserId?: string;
  modifyUser?: SearchFormDatasResponseBodyDataModifyUser;
  originator?: SearchFormDatasResponseBodyDataOriginator;
  sequence?: string;
  serialNo?: string;
  title?: string;
  version?: number;
  static names(): { [key: string]: string } {
    return {
      createdTimeGMT: 'CreatedTimeGMT',
      creatorUserId: 'CreatorUserId',
      dataId: 'DataId',
      formData: 'FormData',
      formInstanceId: 'FormInstanceId',
      formUuid: 'FormUuid',
      instanceValue: 'InstanceValue',
      modelUuid: 'ModelUuid',
      modifiedTimeGMT: 'ModifiedTimeGMT',
      modifierUserId: 'ModifierUserId',
      modifyUser: 'ModifyUser',
      originator: 'Originator',
      sequence: 'Sequence',
      serialNo: 'SerialNo',
      title: 'Title',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createdTimeGMT: 'string',
      creatorUserId: 'string',
      dataId: 'number',
      formData: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      formInstanceId: 'string',
      formUuid: 'string',
      instanceValue: 'string',
      modelUuid: 'string',
      modifiedTimeGMT: 'string',
      modifierUserId: 'string',
      modifyUser: SearchFormDatasResponseBodyDataModifyUser,
      originator: SearchFormDatasResponseBodyDataOriginator,
      sequence: 'string',
      serialNo: 'string',
      title: 'string',
      version: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchInnerGroupsHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchInnerGroupsResponseBodyGroupInfos extends $tea.Model {
  icon?: string;
  memberAmount?: string;
  openConversationId?: string;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      icon: 'Icon',
      memberAmount: 'MemberAmount',
      openConversationId: 'OpenConversationId',
      title: 'Title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      icon: 'string',
      memberAmount: 'string',
      openConversationId: 'string',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SendBannerHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SendBannerRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SendPopupHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SendPopupRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SendSearchShadeHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SendSearchShadeRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetColumnsVisibilityHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetColumnsVisibilityRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetRowsVisibilityHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetRowsVisibilityRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SimpleListReportHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SimpleListReportRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SimpleListReportResponseBodyDataList extends $tea.Model {
  createTime?: number;
  creatorId?: string;
  creatorName?: string;
  deptName?: string;
  remark?: string;
  reportId?: string;
  templateName?: string;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      creatorId: 'CreatorId',
      creatorName: 'CreatorName',
      deptName: 'DeptName',
      remark: 'Remark',
      reportId: 'ReportId',
      templateName: 'TemplateName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'number',
      creatorId: 'string',
      creatorName: 'string',
      deptName: 'string',
      remark: 'string',
      reportId: 'string',
      templateName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartCloudRecordHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartCloudRecordRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartInstanceHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StatisticsListByTypeReportHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StatisticsListByTypeReportRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StatisticsReportHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StatisticsReportRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopCloudRecordHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopCloudRecordRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubscribeCalendarHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SyncDingTypeHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SyncDingTypeRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TerminateInstanceHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnsubscribeCalendarHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateFormDataHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateInstanceHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateLiveHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateLiveRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMeetingRoomHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMeetingRoomRequestReservationAuthorityAuthorizedMembers extends $tea.Model {
  memberId?: string;
  memberName?: string;
  memberType?: string;
  static names(): { [key: string]: string } {
    return {
      memberId: 'MemberId',
      memberName: 'MemberName',
      memberType: 'MemberType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      memberId: 'string',
      memberName: 'string',
      memberType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMeetingRoomRequestReservationAuthority extends $tea.Model {
  authorizedMembers?: UpdateMeetingRoomRequestReservationAuthorityAuthorizedMembers[];
  static names(): { [key: string]: string } {
    return {
      authorizedMembers: 'AuthorizedMembers',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authorizedMembers: { 'type': 'array', 'itemType': UpdateMeetingRoomRequestReservationAuthorityAuthorizedMembers },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMeetingRoomRequestRoomLocation extends $tea.Model {
  desc?: string;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      desc: 'Desc',
      title: 'Title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      desc: 'string',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMeetingRoomRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMeetingRoomGroupHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMeetingRoomGroupRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRangeHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRangeRequestHyperlinks extends $tea.Model {
  type?: string;
  link?: string;
  text?: string;
  static names(): { [key: string]: string } {
    return {
      type: 'Type',
      link: 'Link',
      text: 'Text',
    };
  }

  static types(): { [key: string]: any } {
    return {
      type: 'string',
      link: 'string',
      text: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRangeRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateScheduleConfSettingsHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateScheduleConfSettingsRequestScheduleConfSettingModelMoziConfVirtualExtraSetting extends $tea.Model {
  enableChat?: number;
  enableWebAnonymousJoin?: boolean;
  joinBeforeHost?: number;
  lockMediaStatusMicMute?: number;
  lockNick?: number;
  waitingRoom?: number;
  static names(): { [key: string]: string } {
    return {
      enableChat: 'EnableChat',
      enableWebAnonymousJoin: 'EnableWebAnonymousJoin',
      joinBeforeHost: 'JoinBeforeHost',
      lockMediaStatusMicMute: 'LockMediaStatusMicMute',
      lockNick: 'LockNick',
      waitingRoom: 'WaitingRoom',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enableChat: 'number',
      enableWebAnonymousJoin: 'boolean',
      joinBeforeHost: 'number',
      lockMediaStatusMicMute: 'number',
      lockNick: 'number',
      waitingRoom: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateScheduleConfSettingsRequestScheduleConfSettingModel extends $tea.Model {
  cohostUserIds?: string[];
  confAllowedCorpId?: string;
  hostUserId?: string;
  lockRoom?: number;
  moziConfVirtualExtraSetting?: UpdateScheduleConfSettingsRequestScheduleConfSettingModelMoziConfVirtualExtraSetting;
  muteOnJoin?: number;
  screenShareForbidden?: number;
  static names(): { [key: string]: string } {
    return {
      cohostUserIds: 'CohostUserIds',
      confAllowedCorpId: 'ConfAllowedCorpId',
      hostUserId: 'HostUserId',
      lockRoom: 'LockRoom',
      moziConfVirtualExtraSetting: 'MoziConfVirtualExtraSetting',
      muteOnJoin: 'MuteOnJoin',
      screenShareForbidden: 'ScreenShareForbidden',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cohostUserIds: { 'type': 'array', 'itemType': 'string' },
      confAllowedCorpId: 'string',
      hostUserId: 'string',
      lockRoom: 'number',
      moziConfVirtualExtraSetting: UpdateScheduleConfSettingsRequestScheduleConfSettingModelMoziConfVirtualExtraSetting,
      muteOnJoin: 'number',
      screenShareForbidden: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateScheduleConfSettingsRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateScheduleConferenceHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateScheduleConferenceRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateStatusHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSubscribedCalendarsHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSubscribedCalendarsRequestSubscribeScope extends $tea.Model {
  userIds?: string[];
  static names(): { [key: string]: string } {
    return {
      userIds: 'UserIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      userIds: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTodoTaskHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTodoTaskRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTodoTaskExecutorStatusHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTodoTaskExecutorStatusRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTodoTaskExecutorStatusRequestExecutorStatusList extends $tea.Model {
  id?: string;
  isDone?: boolean;
  static names(): { [key: string]: string } {
    return {
      id: 'id',
      isDone: 'isDone',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      isDone: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateUserAvatarHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWorkspaceDocMembersHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWorkspaceDocMembersRequestMembers extends $tea.Model {
  memberId?: string;
  memberType?: string;
  roleType?: string;
  static names(): { [key: string]: string } {
    return {
      memberId: 'MemberId',
      memberType: 'MemberType',
      roleType: 'RoleType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      memberId: 'string',
      memberType: 'string',
      roleType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWorkspaceDocMembersRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWorkspaceMembersHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWorkspaceMembersRequestMembers extends $tea.Model {
  memberId?: string;
  memberType?: string;
  roleType?: string;
  static names(): { [key: string]: string } {
    return {
      memberId: 'MemberId',
      memberType: 'MemberType',
      roleType: 'RoleType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      memberId: 'string',
      memberType: 'string',
      roleType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWorkspaceMembersRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UploadMediaHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UploadMediaRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WearOrgHonorHeadersAccountContext extends $tea.Model {
  accountId?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WearOrgHonorRequestTenantContext extends $tea.Model {
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WearOrgHonorResponseBodyContent extends $tea.Model {
  data?: any;
  static names(): { [key: string]: string } {
    return {
      data: 'data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'any',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}


export default class Client extends OpenApi {

  constructor(config: $OpenApi.Config) {
    super(config);
    this._endpointRule = "";
    this.checkConfig(config);
    this._endpoint = this.getEndpoint("aliding", this._regionId, this._endpointRule, this._network, this._suffix, this._endpointMap, this._endpoint);
  }


  getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: {[key: string ]: string}, endpoint: string): string {
    if (!Util.empty(endpoint)) {
      return endpoint;
    }

    if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
      return endpointMap[regionId];
    }

    return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
  }

  async addAttendeeWithOptions(tmpReq: AddAttendeeRequest, tmpHeader: AddAttendeeHeaders, runtime: $Util.RuntimeOptions): Promise<AddAttendeeResponse> {
    Util.validateModel(tmpReq);
    let request = new AddAttendeeShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new AddAttendeeShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.attendeesToAdd)) {
      request.attendeesToAddShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.attendeesToAdd, "AttendeesToAdd", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.attendeesToAddShrink)) {
      body["AttendeesToAdd"] = request.attendeesToAddShrink;
    }

    if (!Util.isUnset(request.calendarId)) {
      body["CalendarId"] = request.calendarId;
    }

    if (!Util.isUnset(request.eventId)) {
      body["EventId"] = request.eventId;
    }

    if (!Util.isUnset(request.chatNotification)) {
      body["chatNotification"] = request.chatNotification;
    }

    if (!Util.isUnset(request.pushNotification)) {
      body["pushNotification"] = request.pushNotification;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "AddAttendee",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/calendar/addAttendee`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddAttendeeResponse>(await this.callApi(params, req, runtime), new AddAttendeeResponse({}));
  }

  async addAttendee(request: AddAttendeeRequest): Promise<AddAttendeeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new AddAttendeeHeaders({ });
    return await this.addAttendeeWithOptions(request, headers, runtime);
  }

  async addMeetingRoomsWithOptions(tmpReq: AddMeetingRoomsRequest, tmpHeader: AddMeetingRoomsHeaders, runtime: $Util.RuntimeOptions): Promise<AddMeetingRoomsResponse> {
    Util.validateModel(tmpReq);
    let request = new AddMeetingRoomsShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new AddMeetingRoomsShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.meetingRoomsToAdd)) {
      request.meetingRoomsToAddShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.meetingRoomsToAdd, "MeetingRoomsToAdd", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.calendarId)) {
      body["CalendarId"] = request.calendarId;
    }

    if (!Util.isUnset(request.eventId)) {
      body["EventId"] = request.eventId;
    }

    if (!Util.isUnset(request.meetingRoomsToAddShrink)) {
      body["MeetingRoomsToAdd"] = request.meetingRoomsToAddShrink;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "AddMeetingRooms",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/calendar/addMeetingRooms`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddMeetingRoomsResponse>(await this.callApi(params, req, runtime), new AddMeetingRoomsResponse({}));
  }

  async addMeetingRooms(request: AddMeetingRoomsRequest): Promise<AddMeetingRoomsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new AddMeetingRoomsHeaders({ });
    return await this.addMeetingRoomsWithOptions(request, headers, runtime);
  }

  async addScenegroupMemberWithOptions(request: AddScenegroupMemberRequest, tmpHeader: AddScenegroupMemberHeaders, runtime: $Util.RuntimeOptions): Promise<AddScenegroupMemberResponse> {
    Util.validateModel(request);
    let headers = new AddScenegroupMemberShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.openConversationId)) {
      body["OpenConversationId"] = request.openConversationId;
    }

    if (!Util.isUnset(request.userIds)) {
      body["UserIds"] = request.userIds;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "AddScenegroupMember",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/im/addScenegroupMember`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddScenegroupMemberResponse>(await this.callApi(params, req, runtime), new AddScenegroupMemberResponse({}));
  }

  async addScenegroupMember(request: AddScenegroupMemberRequest): Promise<AddScenegroupMemberResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new AddScenegroupMemberHeaders({ });
    return await this.addScenegroupMemberWithOptions(request, headers, runtime);
  }

  async addWorkspaceWithOptions(tmpReq: AddWorkspaceRequest, tmpHeader: AddWorkspaceHeaders, runtime: $Util.RuntimeOptions): Promise<AddWorkspaceResponse> {
    Util.validateModel(tmpReq);
    let request = new AddWorkspaceShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new AddWorkspaceShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.option)) {
      request.optionShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.option, "Option", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.name)) {
      body["Name"] = request.name;
    }

    if (!Util.isUnset(request.optionShrink)) {
      body["Option"] = request.optionShrink;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "AddWorkspace",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v2/documents/addWorkspace`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddWorkspaceResponse>(await this.callApi(params, req, runtime), new AddWorkspaceResponse({}));
  }

  async addWorkspace(request: AddWorkspaceRequest): Promise<AddWorkspaceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new AddWorkspaceHeaders({ });
    return await this.addWorkspaceWithOptions(request, headers, runtime);
  }

  async addWorkspaceDocMembersWithOptions(tmpReq: AddWorkspaceDocMembersRequest, tmpHeader: AddWorkspaceDocMembersHeaders, runtime: $Util.RuntimeOptions): Promise<AddWorkspaceDocMembersResponse> {
    Util.validateModel(tmpReq);
    let request = new AddWorkspaceDocMembersShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new AddWorkspaceDocMembersShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.members)) {
      request.membersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.members, "Members", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.membersShrink)) {
      body["Members"] = request.membersShrink;
    }

    if (!Util.isUnset(request.nodeId)) {
      body["NodeId"] = request.nodeId;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    if (!Util.isUnset(request.workspaceId)) {
      body["WorkspaceId"] = request.workspaceId;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "AddWorkspaceDocMembers",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/documents/addWorkspaceDocMembers`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddWorkspaceDocMembersResponse>(await this.callApi(params, req, runtime), new AddWorkspaceDocMembersResponse({}));
  }

  async addWorkspaceDocMembers(request: AddWorkspaceDocMembersRequest): Promise<AddWorkspaceDocMembersResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new AddWorkspaceDocMembersHeaders({ });
    return await this.addWorkspaceDocMembersWithOptions(request, headers, runtime);
  }

  async addWorkspaceMembersWithOptions(tmpReq: AddWorkspaceMembersRequest, tmpHeader: AddWorkspaceMembersHeaders, runtime: $Util.RuntimeOptions): Promise<AddWorkspaceMembersResponse> {
    Util.validateModel(tmpReq);
    let request = new AddWorkspaceMembersShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new AddWorkspaceMembersShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.members)) {
      request.membersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.members, "Members", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.membersShrink)) {
      body["Members"] = request.membersShrink;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    if (!Util.isUnset(request.workspaceId)) {
      body["WorkspaceId"] = request.workspaceId;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "AddWorkspaceMembers",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/documents/addWorkspaceMembers`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddWorkspaceMembersResponse>(await this.callApi(params, req, runtime), new AddWorkspaceMembersResponse({}));
  }

  async addWorkspaceMembers(request: AddWorkspaceMembersRequest): Promise<AddWorkspaceMembersResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new AddWorkspaceMembersHeaders({ });
    return await this.addWorkspaceMembersWithOptions(request, headers, runtime);
  }

  async batchGetFormDataByIdListWithOptions(tmpReq: BatchGetFormDataByIdListRequest, tmpHeader: BatchGetFormDataByIdListHeaders, runtime: $Util.RuntimeOptions): Promise<BatchGetFormDataByIdListResponse> {
    Util.validateModel(tmpReq);
    let request = new BatchGetFormDataByIdListShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new BatchGetFormDataByIdListShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.formInstanceIdList)) {
      request.formInstanceIdListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.formInstanceIdList, "FormInstanceIdList", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appType)) {
      body["AppType"] = request.appType;
    }

    if (!Util.isUnset(request.formInstanceIdListShrink)) {
      body["FormInstanceIdList"] = request.formInstanceIdListShrink;
    }

    if (!Util.isUnset(request.formUuid)) {
      body["FormUuid"] = request.formUuid;
    }

    if (!Util.isUnset(request.needFormInstanceValue)) {
      body["NeedFormInstanceValue"] = request.needFormInstanceValue;
    }

    if (!Util.isUnset(request.systemToken)) {
      body["SystemToken"] = request.systemToken;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "BatchGetFormDataByIdList",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/yida/batchGetFormDataByIdList`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchGetFormDataByIdListResponse>(await this.callApi(params, req, runtime), new BatchGetFormDataByIdListResponse({}));
  }

  async batchGetFormDataByIdList(request: BatchGetFormDataByIdListRequest): Promise<BatchGetFormDataByIdListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new BatchGetFormDataByIdListHeaders({ });
    return await this.batchGetFormDataByIdListWithOptions(request, headers, runtime);
  }

  async batchRemovalByFormInstanceIdListWithOptions(tmpReq: BatchRemovalByFormInstanceIdListRequest, tmpHeader: BatchRemovalByFormInstanceIdListHeaders, runtime: $Util.RuntimeOptions): Promise<BatchRemovalByFormInstanceIdListResponse> {
    Util.validateModel(tmpReq);
    let request = new BatchRemovalByFormInstanceIdListShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new BatchRemovalByFormInstanceIdListShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.formInstanceIdList)) {
      request.formInstanceIdListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.formInstanceIdList, "FormInstanceIdList", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appType)) {
      body["AppType"] = request.appType;
    }

    if (!Util.isUnset(request.asynchronousExecution)) {
      body["AsynchronousExecution"] = request.asynchronousExecution;
    }

    if (!Util.isUnset(request.executeExpression)) {
      body["ExecuteExpression"] = request.executeExpression;
    }

    if (!Util.isUnset(request.formInstanceIdListShrink)) {
      body["FormInstanceIdList"] = request.formInstanceIdListShrink;
    }

    if (!Util.isUnset(request.formUuid)) {
      body["FormUuid"] = request.formUuid;
    }

    if (!Util.isUnset(request.systemToken)) {
      body["SystemToken"] = request.systemToken;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "BatchRemovalByFormInstanceIdList",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/yida/batchRemovalByFormInstanceIdList`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchRemovalByFormInstanceIdListResponse>(await this.callApi(params, req, runtime), new BatchRemovalByFormInstanceIdListResponse({}));
  }

  async batchRemovalByFormInstanceIdList(request: BatchRemovalByFormInstanceIdListRequest): Promise<BatchRemovalByFormInstanceIdListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new BatchRemovalByFormInstanceIdListHeaders({ });
    return await this.batchRemovalByFormInstanceIdListWithOptions(request, headers, runtime);
  }

  async batchSaveFormDataWithOptions(tmpReq: BatchSaveFormDataRequest, tmpHeader: BatchSaveFormDataHeaders, runtime: $Util.RuntimeOptions): Promise<BatchSaveFormDataResponse> {
    Util.validateModel(tmpReq);
    let request = new BatchSaveFormDataShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new BatchSaveFormDataShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.formDataJsonList)) {
      request.formDataJsonListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.formDataJsonList, "FormDataJsonList", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appType)) {
      body["AppType"] = request.appType;
    }

    if (!Util.isUnset(request.asynchronousExecution)) {
      body["AsynchronousExecution"] = request.asynchronousExecution;
    }

    if (!Util.isUnset(request.formDataJsonListShrink)) {
      body["FormDataJsonList"] = request.formDataJsonListShrink;
    }

    if (!Util.isUnset(request.formUuid)) {
      body["FormUuid"] = request.formUuid;
    }

    if (!Util.isUnset(request.keepRunningAfterException)) {
      body["KeepRunningAfterException"] = request.keepRunningAfterException;
    }

    if (!Util.isUnset(request.noExecuteExpression)) {
      body["NoExecuteExpression"] = request.noExecuteExpression;
    }

    if (!Util.isUnset(request.systemToken)) {
      body["SystemToken"] = request.systemToken;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "BatchSaveFormData",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/yida/batchSaveFormData`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchSaveFormDataResponse>(await this.callApi(params, req, runtime), new BatchSaveFormDataResponse({}));
  }

  async batchSaveFormData(request: BatchSaveFormDataRequest): Promise<BatchSaveFormDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new BatchSaveFormDataHeaders({ });
    return await this.batchSaveFormDataWithOptions(request, headers, runtime);
  }

  async batchUpdateFormDataByInstanceIdWithOptions(tmpReq: BatchUpdateFormDataByInstanceIdRequest, tmpHeader: BatchUpdateFormDataByInstanceIdHeaders, runtime: $Util.RuntimeOptions): Promise<BatchUpdateFormDataByInstanceIdResponse> {
    Util.validateModel(tmpReq);
    let request = new BatchUpdateFormDataByInstanceIdShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new BatchUpdateFormDataByInstanceIdShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.formInstanceIdList)) {
      request.formInstanceIdListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.formInstanceIdList, "FormInstanceIdList", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appType)) {
      body["AppType"] = request.appType;
    }

    if (!Util.isUnset(request.asynchronousExecution)) {
      body["AsynchronousExecution"] = request.asynchronousExecution;
    }

    if (!Util.isUnset(request.formInstanceIdListShrink)) {
      body["FormInstanceIdList"] = request.formInstanceIdListShrink;
    }

    if (!Util.isUnset(request.formUuid)) {
      body["FormUuid"] = request.formUuid;
    }

    if (!Util.isUnset(request.ignoreEmpty)) {
      body["IgnoreEmpty"] = request.ignoreEmpty;
    }

    if (!Util.isUnset(request.noExecuteExpression)) {
      body["NoExecuteExpression"] = request.noExecuteExpression;
    }

    if (!Util.isUnset(request.systemToken)) {
      body["SystemToken"] = request.systemToken;
    }

    if (!Util.isUnset(request.updateFormDataJson)) {
      body["UpdateFormDataJson"] = request.updateFormDataJson;
    }

    if (!Util.isUnset(request.useLatestFormSchemaVersion)) {
      body["UseLatestFormSchemaVersion"] = request.useLatestFormSchemaVersion;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "BatchUpdateFormDataByInstanceId",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/yida/batchUpdateFormDataByInstanceId`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchUpdateFormDataByInstanceIdResponse>(await this.callApi(params, req, runtime), new BatchUpdateFormDataByInstanceIdResponse({}));
  }

  async batchUpdateFormDataByInstanceId(request: BatchUpdateFormDataByInstanceIdRequest): Promise<BatchUpdateFormDataByInstanceIdResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new BatchUpdateFormDataByInstanceIdHeaders({ });
    return await this.batchUpdateFormDataByInstanceIdWithOptions(request, headers, runtime);
  }

  async batchUpdateFormDataByInstanceMapWithOptions(tmpReq: BatchUpdateFormDataByInstanceMapRequest, tmpHeader: BatchUpdateFormDataByInstanceMapHeaders, runtime: $Util.RuntimeOptions): Promise<BatchUpdateFormDataByInstanceMapResponse> {
    Util.validateModel(tmpReq);
    let request = new BatchUpdateFormDataByInstanceMapShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new BatchUpdateFormDataByInstanceMapShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.updateFormDataJsonMap)) {
      request.updateFormDataJsonMapShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.updateFormDataJsonMap, "UpdateFormDataJsonMap", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appType)) {
      body["AppType"] = request.appType;
    }

    if (!Util.isUnset(request.asynchronousExecution)) {
      body["AsynchronousExecution"] = request.asynchronousExecution;
    }

    if (!Util.isUnset(request.formUuid)) {
      body["FormUuid"] = request.formUuid;
    }

    if (!Util.isUnset(request.ignoreEmpty)) {
      body["IgnoreEmpty"] = request.ignoreEmpty;
    }

    if (!Util.isUnset(request.noExecuteExpression)) {
      body["NoExecuteExpression"] = request.noExecuteExpression;
    }

    if (!Util.isUnset(request.systemToken)) {
      body["SystemToken"] = request.systemToken;
    }

    if (!Util.isUnset(request.updateFormDataJsonMapShrink)) {
      body["UpdateFormDataJsonMap"] = request.updateFormDataJsonMapShrink;
    }

    if (!Util.isUnset(request.useLatestFormSchemaVersion)) {
      body["UseLatestFormSchemaVersion"] = request.useLatestFormSchemaVersion;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "BatchUpdateFormDataByInstanceMap",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/yida/batchUpdateFormDataByInstanceMap`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchUpdateFormDataByInstanceMapResponse>(await this.callApi(params, req, runtime), new BatchUpdateFormDataByInstanceMapResponse({}));
  }

  async batchUpdateFormDataByInstanceMap(request: BatchUpdateFormDataByInstanceMapRequest): Promise<BatchUpdateFormDataByInstanceMapResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new BatchUpdateFormDataByInstanceMapHeaders({ });
    return await this.batchUpdateFormDataByInstanceMapWithOptions(request, headers, runtime);
  }

  async cancelScheduleConferenceWithOptions(tmpReq: CancelScheduleConferenceRequest, tmpHeader: CancelScheduleConferenceHeaders, runtime: $Util.RuntimeOptions): Promise<CancelScheduleConferenceResponse> {
    Util.validateModel(tmpReq);
    let request = new CancelScheduleConferenceShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new CancelScheduleConferenceShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.scheduleConferenceId)) {
      body["ScheduleConferenceId"] = request.scheduleConferenceId;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CancelScheduleConference",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/ysp/cancelScheduleConference`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CancelScheduleConferenceResponse>(await this.callApi(params, req, runtime), new CancelScheduleConferenceResponse({}));
  }

  async cancelScheduleConference(request: CancelScheduleConferenceRequest): Promise<CancelScheduleConferenceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new CancelScheduleConferenceHeaders({ });
    return await this.cancelScheduleConferenceWithOptions(request, headers, runtime);
  }

  async checkUserIsGroupMemberWithOptions(request: CheckUserIsGroupMemberRequest, tmpHeader: CheckUserIsGroupMemberHeaders, runtime: $Util.RuntimeOptions): Promise<CheckUserIsGroupMemberResponse> {
    Util.validateModel(request);
    let headers = new CheckUserIsGroupMemberShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.openConversationId)) {
      body["OpenConversationId"] = request.openConversationId;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CheckUserIsGroupMember",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/im/checkUserIsGroupMember`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CheckUserIsGroupMemberResponse>(await this.callApi(params, req, runtime), new CheckUserIsGroupMemberResponse({}));
  }

  async checkUserIsGroupMember(request: CheckUserIsGroupMemberRequest): Promise<CheckUserIsGroupMemberResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new CheckUserIsGroupMemberHeaders({ });
    return await this.checkUserIsGroupMemberWithOptions(request, headers, runtime);
  }

  async clearWithOptions(tmpReq: ClearRequest, tmpHeader: ClearHeaders, runtime: $Util.RuntimeOptions): Promise<ClearResponse> {
    Util.validateModel(tmpReq);
    let request = new ClearShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new ClearShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.rangeAddress)) {
      body["RangeAddress"] = request.rangeAddress;
    }

    if (!Util.isUnset(request.sheetId)) {
      body["SheetId"] = request.sheetId;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    if (!Util.isUnset(request.workbookId)) {
      body["WorkbookId"] = request.workbookId;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "Clear",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/documents/clear`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ClearResponse>(await this.callApi(params, req, runtime), new ClearResponse({}));
  }

  async clear(request: ClearRequest): Promise<ClearResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new ClearHeaders({ });
    return await this.clearWithOptions(request, headers, runtime);
  }

  async clearDataWithOptions(tmpReq: ClearDataRequest, tmpHeader: ClearDataHeaders, runtime: $Util.RuntimeOptions): Promise<ClearDataResponse> {
    Util.validateModel(tmpReq);
    let request = new ClearDataShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new ClearDataShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.rangeAddress)) {
      body["RangeAddress"] = request.rangeAddress;
    }

    if (!Util.isUnset(request.sheetId)) {
      body["SheetId"] = request.sheetId;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    if (!Util.isUnset(request.workbookId)) {
      body["WorkbookId"] = request.workbookId;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ClearData",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/documents/clearData`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ClearDataResponse>(await this.callApi(params, req, runtime), new ClearDataResponse({}));
  }

  async clearData(request: ClearDataRequest): Promise<ClearDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new ClearDataHeaders({ });
    return await this.clearDataWithOptions(request, headers, runtime);
  }

  async commentListReportWithOptions(tmpReq: CommentListReportRequest, tmpHeader: CommentListReportHeaders, runtime: $Util.RuntimeOptions): Promise<CommentListReportResponse> {
    Util.validateModel(tmpReq);
    let request = new CommentListReportShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new CommentListReportShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.offset)) {
      body["Offset"] = request.offset;
    }

    if (!Util.isUnset(request.reportId)) {
      body["ReportId"] = request.reportId;
    }

    if (!Util.isUnset(request.size)) {
      body["Size"] = request.size;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CommentListReport",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/log/commentListReport`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CommentListReportResponse>(await this.callApi(params, req, runtime), new CommentListReportResponse({}));
  }

  async commentListReport(request: CommentListReportRequest): Promise<CommentListReportResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new CommentListReportHeaders({ });
    return await this.commentListReportWithOptions(request, headers, runtime);
  }

  async createDeliveryPlanWithOptions(tmpReq: CreateDeliveryPlanRequest, tmpHeader: CreateDeliveryPlanHeaders, runtime: $Util.RuntimeOptions): Promise<CreateDeliveryPlanResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateDeliveryPlanShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new CreateDeliveryPlanShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.content)) {
      request.contentShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.content, "Content", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    if (!Util.isUnset(tmpReq.userIdList)) {
      request.userIdListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.userIdList, "UserIdList", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.contentShrink)) {
      body["Content"] = request.contentShrink;
    }

    if (!Util.isUnset(request.endTime)) {
      body["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.resId)) {
      body["ResId"] = request.resId;
    }

    if (!Util.isUnset(request.startTime)) {
      body["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    if (!Util.isUnset(request.userIdListShrink)) {
      body["UserIdList"] = request.userIdListShrink;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateDeliveryPlan",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/watt/createDeliveryPlan`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateDeliveryPlanResponse>(await this.callApi(params, req, runtime), new CreateDeliveryPlanResponse({}));
  }

  async createDeliveryPlan(request: CreateDeliveryPlanRequest): Promise<CreateDeliveryPlanResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new CreateDeliveryPlanHeaders({ });
    return await this.createDeliveryPlanWithOptions(request, headers, runtime);
  }

  async createEventWithOptions(tmpReq: CreateEventRequest, tmpHeader: CreateEventHeaders, runtime: $Util.RuntimeOptions): Promise<CreateEventResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateEventShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new CreateEventShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.attendees)) {
      request.attendeesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.attendees, "Attendees", "json");
    }

    if (!Util.isUnset(tmpReq.end)) {
      request.endShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.end, "End", "json");
    }

    if (!Util.isUnset(tmpReq.extra)) {
      request.extraShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.extra, "Extra", "json");
    }

    if (!Util.isUnset(tmpReq.location)) {
      request.locationShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.location, "Location", "json");
    }

    if (!Util.isUnset(tmpReq.onlineMeetingInfo)) {
      request.onlineMeetingInfoShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.onlineMeetingInfo, "OnlineMeetingInfo", "json");
    }

    if (!Util.isUnset(tmpReq.recurrence)) {
      request.recurrenceShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.recurrence, "Recurrence", "json");
    }

    if (!Util.isUnset(tmpReq.reminders)) {
      request.remindersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.reminders, "Reminders", "json");
    }

    if (!Util.isUnset(tmpReq.richTextDescription)) {
      request.richTextDescriptionShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.richTextDescription, "RichTextDescription", "json");
    }

    if (!Util.isUnset(tmpReq.uiConfigs)) {
      request.uiConfigsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.uiConfigs, "UiConfigs", "json");
    }

    if (!Util.isUnset(tmpReq.start)) {
      request.startShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.start, "start", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.attendeesShrink)) {
      body["Attendees"] = request.attendeesShrink;
    }

    if (!Util.isUnset(request.description)) {
      body["Description"] = request.description;
    }

    if (!Util.isUnset(request.endShrink)) {
      body["End"] = request.endShrink;
    }

    if (!Util.isUnset(request.extraShrink)) {
      body["Extra"] = request.extraShrink;
    }

    if (!Util.isUnset(request.isAllDay)) {
      body["IsAllDay"] = request.isAllDay;
    }

    if (!Util.isUnset(request.locationShrink)) {
      body["Location"] = request.locationShrink;
    }

    if (!Util.isUnset(request.onlineMeetingInfoShrink)) {
      body["OnlineMeetingInfo"] = request.onlineMeetingInfoShrink;
    }

    if (!Util.isUnset(request.recurrenceShrink)) {
      body["Recurrence"] = request.recurrenceShrink;
    }

    if (!Util.isUnset(request.remindersShrink)) {
      body["Reminders"] = request.remindersShrink;
    }

    if (!Util.isUnset(request.richTextDescriptionShrink)) {
      body["RichTextDescription"] = request.richTextDescriptionShrink;
    }

    if (!Util.isUnset(request.summary)) {
      body["Summary"] = request.summary;
    }

    if (!Util.isUnset(request.uiConfigsShrink)) {
      body["UiConfigs"] = request.uiConfigsShrink;
    }

    if (!Util.isUnset(request.calendarId)) {
      body["calendarId"] = request.calendarId;
    }

    if (!Util.isUnset(request.startShrink)) {
      body["start"] = request.startShrink;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateEvent",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/calendar/createEvent`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateEventResponse>(await this.callApi(params, req, runtime), new CreateEventResponse({}));
  }

  async createEvent(request: CreateEventRequest): Promise<CreateEventResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new CreateEventHeaders({ });
    return await this.createEventWithOptions(request, headers, runtime);
  }

  async createLiveWithOptions(tmpReq: CreateLiveRequest, tmpHeader: CreateLiveHeaders, runtime: $Util.RuntimeOptions): Promise<CreateLiveResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateLiveShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new CreateLiveShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.coverUrl)) {
      body["CoverUrl"] = request.coverUrl;
    }

    if (!Util.isUnset(request.introduction)) {
      body["Introduction"] = request.introduction;
    }

    if (!Util.isUnset(request.preEndTime)) {
      body["PreEndTime"] = request.preEndTime;
    }

    if (!Util.isUnset(request.preStartTime)) {
      body["PreStartTime"] = request.preStartTime;
    }

    if (!Util.isUnset(request.publicType)) {
      body["PublicType"] = request.publicType;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    if (!Util.isUnset(request.title)) {
      body["Title"] = request.title;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateLive",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/ysp/createLive`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateLiveResponse>(await this.callApi(params, req, runtime), new CreateLiveResponse({}));
  }

  async createLive(request: CreateLiveRequest): Promise<CreateLiveResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new CreateLiveHeaders({ });
    return await this.createLiveWithOptions(request, headers, runtime);
  }

  async createMeetingRoomWithOptions(tmpReq: CreateMeetingRoomRequest, tmpHeader: CreateMeetingRoomHeaders, runtime: $Util.RuntimeOptions): Promise<CreateMeetingRoomResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateMeetingRoomShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new CreateMeetingRoomShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.reservationAuthority)) {
      request.reservationAuthorityShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.reservationAuthority, "ReservationAuthority", "json");
    }

    if (!Util.isUnset(tmpReq.roomLabelIds)) {
      request.roomLabelIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.roomLabelIds, "RoomLabelIds", "json");
    }

    if (!Util.isUnset(tmpReq.roomLocation)) {
      request.roomLocationShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.roomLocation, "RoomLocation", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.enableCycleReservation)) {
      body["EnableCycleReservation"] = request.enableCycleReservation;
    }

    if (!Util.isUnset(request.groupId)) {
      body["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.isvRoomId)) {
      body["IsvRoomId"] = request.isvRoomId;
    }

    if (!Util.isUnset(request.reservationAuthorityShrink)) {
      body["ReservationAuthority"] = request.reservationAuthorityShrink;
    }

    if (!Util.isUnset(request.roomCapacity)) {
      body["RoomCapacity"] = request.roomCapacity;
    }

    if (!Util.isUnset(request.roomLabelIdsShrink)) {
      body["RoomLabelIds"] = request.roomLabelIdsShrink;
    }

    if (!Util.isUnset(request.roomLocationShrink)) {
      body["RoomLocation"] = request.roomLocationShrink;
    }

    if (!Util.isUnset(request.roomName)) {
      body["RoomName"] = request.roomName;
    }

    if (!Util.isUnset(request.roomPicture)) {
      body["RoomPicture"] = request.roomPicture;
    }

    if (!Util.isUnset(request.roomStatus)) {
      body["RoomStatus"] = request.roomStatus;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateMeetingRoom",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/ysp/createMeetingRoom`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateMeetingRoomResponse>(await this.callApi(params, req, runtime), new CreateMeetingRoomResponse({}));
  }

  async createMeetingRoom(request: CreateMeetingRoomRequest): Promise<CreateMeetingRoomResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new CreateMeetingRoomHeaders({ });
    return await this.createMeetingRoomWithOptions(request, headers, runtime);
  }

  async createMeetingRoomGroupWithOptions(tmpReq: CreateMeetingRoomGroupRequest, tmpHeader: CreateMeetingRoomGroupHeaders, runtime: $Util.RuntimeOptions): Promise<CreateMeetingRoomGroupResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateMeetingRoomGroupShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new CreateMeetingRoomGroupShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.groupName)) {
      body["GroupName"] = request.groupName;
    }

    if (!Util.isUnset(request.parentGroupId)) {
      body["ParentGroupId"] = request.parentGroupId;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateMeetingRoomGroup",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/ysp/createMeetingRoomGroup`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateMeetingRoomGroupResponse>(await this.callApi(params, req, runtime), new CreateMeetingRoomGroupResponse({}));
  }

  async createMeetingRoomGroup(request: CreateMeetingRoomGroupRequest): Promise<CreateMeetingRoomGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new CreateMeetingRoomGroupHeaders({ });
    return await this.createMeetingRoomGroupWithOptions(request, headers, runtime);
  }

  async createOrUpdateFormDataWithOptions(request: CreateOrUpdateFormDataRequest, tmpHeader: CreateOrUpdateFormDataHeaders, runtime: $Util.RuntimeOptions): Promise<CreateOrUpdateFormDataResponse> {
    Util.validateModel(request);
    let headers = new CreateOrUpdateFormDataShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appType)) {
      body["AppType"] = request.appType;
    }

    if (!Util.isUnset(request.formDataJson)) {
      body["FormDataJson"] = request.formDataJson;
    }

    if (!Util.isUnset(request.formUuid)) {
      body["FormUuid"] = request.formUuid;
    }

    if (!Util.isUnset(request.noExecuteExpression)) {
      body["NoExecuteExpression"] = request.noExecuteExpression;
    }

    if (!Util.isUnset(request.searchCondition)) {
      body["SearchCondition"] = request.searchCondition;
    }

    if (!Util.isUnset(request.systemToken)) {
      body["SystemToken"] = request.systemToken;
    }

    if (!Util.isUnset(request.userId)) {
      body["UserId"] = request.userId;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateOrUpdateFormData",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/yida/createOrUpdateFormData`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateOrUpdateFormDataResponse>(await this.callApi(params, req, runtime), new CreateOrUpdateFormDataResponse({}));
  }

  async createOrUpdateFormData(request: CreateOrUpdateFormDataRequest): Promise<CreateOrUpdateFormDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new CreateOrUpdateFormDataHeaders({ });
    return await this.createOrUpdateFormDataWithOptions(request, headers, runtime);
  }

  async createOrgHonorTemplateWithOptions(tmpReq: CreateOrgHonorTemplateRequest, tmpHeader: CreateOrgHonorTemplateHeaders, runtime: $Util.RuntimeOptions): Promise<CreateOrgHonorTemplateResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateOrgHonorTemplateShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new CreateOrgHonorTemplateShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    if (!Util.isUnset(request.avatarFrameMediaId)) {
      body["avatarFrameMediaId"] = request.avatarFrameMediaId;
    }

    if (!Util.isUnset(request.defaultBgColor)) {
      body["defaultBgColor"] = request.defaultBgColor;
    }

    if (!Util.isUnset(request.medalDesc)) {
      body["medalDesc"] = request.medalDesc;
    }

    if (!Util.isUnset(request.medalMediaId)) {
      body["medalMediaId"] = request.medalMediaId;
    }

    if (!Util.isUnset(request.medalName)) {
      body["medalName"] = request.medalName;
    }

    if (!Util.isUnset(request.orgId)) {
      body["orgId"] = request.orgId;
    }

    if (!Util.isUnset(request.userId)) {
      body["userId"] = request.userId;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateOrgHonorTemplate",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/aliding/v1/honor/createOrgHonorTemplate`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateOrgHonorTemplateResponse>(await this.callApi(params, req, runtime), new CreateOrgHonorTemplateResponse({}));
  }

  async createOrgHonorTemplate(request: CreateOrgHonorTemplateRequest): Promise<CreateOrgHonorTemplateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new CreateOrgHonorTemplateHeaders({ });
    return await this.createOrgHonorTemplateWithOptions(request, headers, runtime);
  }

  async createPersonalTodoTaskWithOptions(tmpReq: CreatePersonalTodoTaskRequest, tmpHeader: CreatePersonalTodoTaskHeaders, runtime: $Util.RuntimeOptions): Promise<CreatePersonalTodoTaskResponse> {
    Util.validateModel(tmpReq);
    let request = new CreatePersonalTodoTaskShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new CreatePersonalTodoTaskShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.executorIds)) {
      request.executorIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.executorIds, "ExecutorIds", "json");
    }

    if (!Util.isUnset(tmpReq.notifyConfigs)) {
      request.notifyConfigsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.notifyConfigs, "NotifyConfigs", "json");
    }

    if (!Util.isUnset(tmpReq.participantIds)) {
      request.participantIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.participantIds, "ParticipantIds", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.description)) {
      body["Description"] = request.description;
    }

    if (!Util.isUnset(request.dueTime)) {
      body["DueTime"] = request.dueTime;
    }

    if (!Util.isUnset(request.executorIdsShrink)) {
      body["ExecutorIds"] = request.executorIdsShrink;
    }

    if (!Util.isUnset(request.notifyConfigsShrink)) {
      body["NotifyConfigs"] = request.notifyConfigsShrink;
    }

    if (!Util.isUnset(request.participantIdsShrink)) {
      body["ParticipantIds"] = request.participantIdsShrink;
    }

    if (!Util.isUnset(request.subject)) {
      body["Subject"] = request.subject;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreatePersonalTodoTask",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/task/createPersonalTodoTask`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreatePersonalTodoTaskResponse>(await this.callApi(params, req, runtime), new CreatePersonalTodoTaskResponse({}));
  }

  async createPersonalTodoTask(request: CreatePersonalTodoTaskRequest): Promise<CreatePersonalTodoTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new CreatePersonalTodoTaskHeaders({ });
    return await this.createPersonalTodoTaskWithOptions(request, headers, runtime);
  }

  async createReportWithOptions(tmpReq: CreateReportRequest, tmpHeader: CreateReportHeaders, runtime: $Util.RuntimeOptions): Promise<CreateReportResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateReportShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new CreateReportShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.contents)) {
      request.contentsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.contents, "Contents", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    if (!Util.isUnset(tmpReq.toCids)) {
      request.toCidsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.toCids, "ToCids", "json");
    }

    if (!Util.isUnset(tmpReq.toUserids)) {
      request.toUseridsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.toUserids, "ToUserids", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.contentsShrink)) {
      body["Contents"] = request.contentsShrink;
    }

    if (!Util.isUnset(request.ddFrom)) {
      body["DdFrom"] = request.ddFrom;
    }

    if (!Util.isUnset(request.templateId)) {
      body["TemplateId"] = request.templateId;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    if (!Util.isUnset(request.toChat)) {
      body["ToChat"] = request.toChat;
    }

    if (!Util.isUnset(request.toCidsShrink)) {
      body["ToCids"] = request.toCidsShrink;
    }

    if (!Util.isUnset(request.toUseridsShrink)) {
      body["ToUserids"] = request.toUseridsShrink;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateReport",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/log/createReport`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateReportResponse>(await this.callApi(params, req, runtime), new CreateReportResponse({}));
  }

  async createReport(request: CreateReportRequest): Promise<CreateReportResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new CreateReportHeaders({ });
    return await this.createReportWithOptions(request, headers, runtime);
  }

  async createScenegroupWithOptions(request: CreateScenegroupRequest, tmpHeader: CreateScenegroupHeaders, runtime: $Util.RuntimeOptions): Promise<CreateScenegroupResponse> {
    Util.validateModel(request);
    let headers = new CreateScenegroupShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.addFriendForbidden)) {
      body["AddFriendForbidden"] = request.addFriendForbidden;
    }

    if (!Util.isUnset(request.allMembersCanCreateCalendar)) {
      body["AllMembersCanCreateCalendar"] = request.allMembersCanCreateCalendar;
    }

    if (!Util.isUnset(request.allMembersCanCreateMcsConf)) {
      body["AllMembersCanCreateMcsConf"] = request.allMembersCanCreateMcsConf;
    }

    if (!Util.isUnset(request.chatBannedType)) {
      body["ChatBannedType"] = request.chatBannedType;
    }

    if (!Util.isUnset(request.groupEmailDisabled)) {
      body["GroupEmailDisabled"] = request.groupEmailDisabled;
    }

    if (!Util.isUnset(request.groupLiveSwitch)) {
      body["GroupLiveSwitch"] = request.groupLiveSwitch;
    }

    if (!Util.isUnset(request.icon)) {
      body["Icon"] = request.icon;
    }

    if (!Util.isUnset(request.managementType)) {
      body["ManagementType"] = request.managementType;
    }

    if (!Util.isUnset(request.membersToAdminChat)) {
      body["MembersToAdminChat"] = request.membersToAdminChat;
    }

    if (!Util.isUnset(request.mentionAllAuthority)) {
      body["MentionAllAuthority"] = request.mentionAllAuthority;
    }

    if (!Util.isUnset(request.onlyAdminCanDing)) {
      body["OnlyAdminCanDing"] = request.onlyAdminCanDing;
    }

    if (!Util.isUnset(request.onlyAdminCanSetMsgTop)) {
      body["OnlyAdminCanSetMsgTop"] = request.onlyAdminCanSetMsgTop;
    }

    if (!Util.isUnset(request.searchable)) {
      body["Searchable"] = request.searchable;
    }

    if (!Util.isUnset(request.showHistoryType)) {
      body["ShowHistoryType"] = request.showHistoryType;
    }

    if (!Util.isUnset(request.subadminIds)) {
      body["SubadminIds"] = request.subadminIds;
    }

    if (!Util.isUnset(request.templateId)) {
      body["TemplateId"] = request.templateId;
    }

    if (!Util.isUnset(request.title)) {
      body["Title"] = request.title;
    }

    if (!Util.isUnset(request.userIds)) {
      body["UserIds"] = request.userIds;
    }

    if (!Util.isUnset(request.uuid)) {
      body["Uuid"] = request.uuid;
    }

    if (!Util.isUnset(request.validationType)) {
      body["ValidationType"] = request.validationType;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateScenegroup",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/im/createScenegroup`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateScenegroupResponse>(await this.callApi(params, req, runtime), new CreateScenegroupResponse({}));
  }

  async createScenegroup(request: CreateScenegroupRequest): Promise<CreateScenegroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new CreateScenegroupHeaders({ });
    return await this.createScenegroupWithOptions(request, headers, runtime);
  }

  async createScheduleConferenceWithOptions(tmpReq: CreateScheduleConferenceRequest, tmpHeader: CreateScheduleConferenceHeaders, runtime: $Util.RuntimeOptions): Promise<CreateScheduleConferenceResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateScheduleConferenceShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new CreateScheduleConferenceShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.endTime)) {
      body["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.startTime)) {
      body["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    if (!Util.isUnset(request.title)) {
      body["Title"] = request.title;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateScheduleConference",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/ysp/createScheduleConference`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateScheduleConferenceResponse>(await this.callApi(params, req, runtime), new CreateScheduleConferenceResponse({}));
  }

  async createScheduleConference(request: CreateScheduleConferenceRequest): Promise<CreateScheduleConferenceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new CreateScheduleConferenceHeaders({ });
    return await this.createScheduleConferenceWithOptions(request, headers, runtime);
  }

  async createSearchDomeWithOptions(tmpReq: CreateSearchDomeRequest, tmpHeader: CreateSearchDomeHeaders, runtime: $Util.RuntimeOptions): Promise<CreateSearchDomeResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateSearchDomeShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new CreateSearchDomeShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    if (!Util.isUnset(tmpReq.userIdList)) {
      request.userIdListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.userIdList, "UserIdList", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.content)) {
      body["Content"] = request.content;
    }

    if (!Util.isUnset(request.endTime)) {
      body["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.resId)) {
      body["ResId"] = request.resId;
    }

    if (!Util.isUnset(request.startTime)) {
      body["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    if (!Util.isUnset(request.userIdListShrink)) {
      body["UserIdList"] = request.userIdListShrink;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateSearchDome",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/watt/createSearchDome`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateSearchDomeResponse>(await this.callApi(params, req, runtime), new CreateSearchDomeResponse({}));
  }

  async createSearchDome(request: CreateSearchDomeRequest): Promise<CreateSearchDomeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new CreateSearchDomeHeaders({ });
    return await this.createSearchDomeWithOptions(request, headers, runtime);
  }

  async createSearchKeywordWithOptions(tmpReq: CreateSearchKeywordRequest, tmpHeader: CreateSearchKeywordHeaders, runtime: $Util.RuntimeOptions): Promise<CreateSearchKeywordResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateSearchKeywordShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new CreateSearchKeywordShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    if (!Util.isUnset(tmpReq.userIdList)) {
      request.userIdListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.userIdList, "UserIdList", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.content)) {
      body["Content"] = request.content;
    }

    if (!Util.isUnset(request.endTime)) {
      body["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.resId)) {
      body["ResId"] = request.resId;
    }

    if (!Util.isUnset(request.startTime)) {
      body["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    if (!Util.isUnset(request.userIdListShrink)) {
      body["UserIdList"] = request.userIdListShrink;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateSearchKeyword",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/watt/createSearchKeyword`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateSearchKeywordResponse>(await this.callApi(params, req, runtime), new CreateSearchKeywordResponse({}));
  }

  async createSearchKeyword(request: CreateSearchKeywordRequest): Promise<CreateSearchKeywordResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new CreateSearchKeywordHeaders({ });
    return await this.createSearchKeywordWithOptions(request, headers, runtime);
  }

  async createSheetWithOptions(tmpReq: CreateSheetRequest, tmpHeader: CreateSheetHeaders, runtime: $Util.RuntimeOptions): Promise<CreateSheetResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateSheetShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new CreateSheetShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.name)) {
      body["Name"] = request.name;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    if (!Util.isUnset(request.workbookId)) {
      body["WorkbookId"] = request.workbookId;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateSheet",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/documents/createSheet`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateSheetResponse>(await this.callApi(params, req, runtime), new CreateSheetResponse({}));
  }

  async createSheet(request: CreateSheetRequest): Promise<CreateSheetResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new CreateSheetHeaders({ });
    return await this.createSheetWithOptions(request, headers, runtime);
  }

  async createSubscribedCalendarWithOptions(tmpReq: CreateSubscribedCalendarRequest, tmpHeader: CreateSubscribedCalendarHeaders, runtime: $Util.RuntimeOptions): Promise<CreateSubscribedCalendarResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateSubscribedCalendarShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new CreateSubscribedCalendarShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.managers)) {
      request.managersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.managers, "Managers", "json");
    }

    if (!Util.isUnset(tmpReq.subscribeScope)) {
      request.subscribeScopeShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.subscribeScope, "SubscribeScope", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.description)) {
      body["Description"] = request.description;
    }

    if (!Util.isUnset(request.managersShrink)) {
      body["Managers"] = request.managersShrink;
    }

    if (!Util.isUnset(request.name)) {
      body["Name"] = request.name;
    }

    if (!Util.isUnset(request.subscribeScopeShrink)) {
      body["SubscribeScope"] = request.subscribeScopeShrink;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateSubscribedCalendar",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/calendar/createSubscribedCalendar`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateSubscribedCalendarResponse>(await this.callApi(params, req, runtime), new CreateSubscribedCalendarResponse({}));
  }

  async createSubscribedCalendar(request: CreateSubscribedCalendarRequest): Promise<CreateSubscribedCalendarResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new CreateSubscribedCalendarHeaders({ });
    return await this.createSubscribedCalendarWithOptions(request, headers, runtime);
  }

  async createTodoTaskWithOptions(tmpReq: CreateTodoTaskRequest, tmpHeader: CreateTodoTaskHeaders, runtime: $Util.RuntimeOptions): Promise<CreateTodoTaskResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateTodoTaskShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new CreateTodoTaskShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    if (!Util.isUnset(tmpReq.contentFieldList)) {
      request.contentFieldListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.contentFieldList, "contentFieldList", "json");
    }

    if (!Util.isUnset(tmpReq.detailUrl)) {
      request.detailUrlShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.detailUrl, "detailUrl", "json");
    }

    if (!Util.isUnset(tmpReq.executorIds)) {
      request.executorIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.executorIds, "executorIds", "json");
    }

    if (!Util.isUnset(tmpReq.notifyConfigs)) {
      request.notifyConfigsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.notifyConfigs, "notifyConfigs", "json");
    }

    if (!Util.isUnset(tmpReq.participantIds)) {
      request.participantIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.participantIds, "participantIds", "json");
    }

    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.operatorId)) {
      query["operatorId"] = request.operatorId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    if (!Util.isUnset(request.contentFieldListShrink)) {
      body["contentFieldList"] = request.contentFieldListShrink;
    }

    if (!Util.isUnset(request.creatorId)) {
      body["creatorId"] = request.creatorId;
    }

    if (!Util.isUnset(request.description)) {
      body["description"] = request.description;
    }

    if (!Util.isUnset(request.detailUrlShrink)) {
      body["detailUrl"] = request.detailUrlShrink;
    }

    if (!Util.isUnset(request.dueTime)) {
      body["dueTime"] = request.dueTime;
    }

    if (!Util.isUnset(request.executorIdsShrink)) {
      body["executorIds"] = request.executorIdsShrink;
    }

    if (!Util.isUnset(request.isOnlyShowExecutor)) {
      body["isOnlyShowExecutor"] = request.isOnlyShowExecutor;
    }

    if (!Util.isUnset(request.notifyConfigsShrink)) {
      body["notifyConfigs"] = request.notifyConfigsShrink;
    }

    if (!Util.isUnset(request.participantIdsShrink)) {
      body["participantIds"] = request.participantIdsShrink;
    }

    if (!Util.isUnset(request.priority)) {
      body["priority"] = request.priority;
    }

    if (!Util.isUnset(request.sourceId)) {
      body["sourceId"] = request.sourceId;
    }

    if (!Util.isUnset(request.subject)) {
      body["subject"] = request.subject;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateTodoTask",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/task/createTodoTask`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateTodoTaskResponse>(await this.callApi(params, req, runtime), new CreateTodoTaskResponse({}));
  }

  async createTodoTask(request: CreateTodoTaskRequest): Promise<CreateTodoTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new CreateTodoTaskHeaders({ });
    return await this.createTodoTaskWithOptions(request, headers, runtime);
  }

  async createVideoConferenceWithOptions(tmpReq: CreateVideoConferenceRequest, tmpHeader: CreateVideoConferenceHeaders, runtime: $Util.RuntimeOptions): Promise<CreateVideoConferenceResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateVideoConferenceShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new CreateVideoConferenceShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.inviteUserIds)) {
      request.inviteUserIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.inviteUserIds, "InviteUserIds", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.confTitle)) {
      body["ConfTitle"] = request.confTitle;
    }

    if (!Util.isUnset(request.inviteCaller)) {
      body["InviteCaller"] = request.inviteCaller;
    }

    if (!Util.isUnset(request.inviteUserIdsShrink)) {
      body["InviteUserIds"] = request.inviteUserIdsShrink;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateVideoConference",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/ysp/createVideoConference`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateVideoConferenceResponse>(await this.callApi(params, req, runtime), new CreateVideoConferenceResponse({}));
  }

  async createVideoConference(request: CreateVideoConferenceRequest): Promise<CreateVideoConferenceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new CreateVideoConferenceHeaders({ });
    return await this.createVideoConferenceWithOptions(request, headers, runtime);
  }

  async createWorkspaceWithOptions(tmpReq: CreateWorkspaceRequest, tmpHeader: CreateWorkspaceHeaders, runtime: $Util.RuntimeOptions): Promise<CreateWorkspaceResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateWorkspaceShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new CreateWorkspaceShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.description)) {
      body["Description"] = request.description;
    }

    if (!Util.isUnset(request.name)) {
      body["Name"] = request.name;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateWorkspace",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/documents/createWorkspace`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateWorkspaceResponse>(await this.callApi(params, req, runtime), new CreateWorkspaceResponse({}));
  }

  async createWorkspace(request: CreateWorkspaceRequest): Promise<CreateWorkspaceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new CreateWorkspaceHeaders({ });
    return await this.createWorkspaceWithOptions(request, headers, runtime);
  }

  async createWorkspaceDocWithOptions(tmpReq: CreateWorkspaceDocRequest, tmpHeader: CreateWorkspaceDocHeaders, runtime: $Util.RuntimeOptions): Promise<CreateWorkspaceDocResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateWorkspaceDocShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new CreateWorkspaceDocShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.docType)) {
      body["DocType"] = request.docType;
    }

    if (!Util.isUnset(request.name)) {
      body["Name"] = request.name;
    }

    if (!Util.isUnset(request.parentNodeId)) {
      body["ParentNodeId"] = request.parentNodeId;
    }

    if (!Util.isUnset(request.templateId)) {
      body["TemplateId"] = request.templateId;
    }

    if (!Util.isUnset(request.templateType)) {
      body["TemplateType"] = request.templateType;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    if (!Util.isUnset(request.workspaceId)) {
      body["WorkspaceId"] = request.workspaceId;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateWorkspaceDoc",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/documents/createWorkspaceDoc`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateWorkspaceDocResponse>(await this.callApi(params, req, runtime), new CreateWorkspaceDocResponse({}));
  }

  async createWorkspaceDoc(request: CreateWorkspaceDocRequest): Promise<CreateWorkspaceDocResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new CreateWorkspaceDocHeaders({ });
    return await this.createWorkspaceDocWithOptions(request, headers, runtime);
  }

  async deleteColumnsWithOptions(tmpReq: DeleteColumnsRequest, tmpHeader: DeleteColumnsHeaders, runtime: $Util.RuntimeOptions): Promise<DeleteColumnsResponse> {
    Util.validateModel(tmpReq);
    let request = new DeleteColumnsShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new DeleteColumnsShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.column)) {
      body["Column"] = request.column;
    }

    if (!Util.isUnset(request.columnCount)) {
      body["ColumnCount"] = request.columnCount;
    }

    if (!Util.isUnset(request.sheetId)) {
      body["SheetId"] = request.sheetId;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    if (!Util.isUnset(request.workbookId)) {
      body["WorkbookId"] = request.workbookId;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteColumns",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/documents/deleteColumns`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteColumnsResponse>(await this.callApi(params, req, runtime), new DeleteColumnsResponse({}));
  }

  async deleteColumns(request: DeleteColumnsRequest): Promise<DeleteColumnsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new DeleteColumnsHeaders({ });
    return await this.deleteColumnsWithOptions(request, headers, runtime);
  }

  async deleteEventWithOptions(request: DeleteEventRequest, tmpHeader: DeleteEventHeaders, runtime: $Util.RuntimeOptions): Promise<DeleteEventResponse> {
    Util.validateModel(request);
    let headers = new DeleteEventShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.calendarId)) {
      body["CalendarId"] = request.calendarId;
    }

    if (!Util.isUnset(request.eventId)) {
      body["EventId"] = request.eventId;
    }

    if (!Util.isUnset(request.pushNotification)) {
      body["pushNotification"] = request.pushNotification;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteEvent",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/calendar/deleteEvent`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteEventResponse>(await this.callApi(params, req, runtime), new DeleteEventResponse({}));
  }

  async deleteEvent(request: DeleteEventRequest): Promise<DeleteEventResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new DeleteEventHeaders({ });
    return await this.deleteEventWithOptions(request, headers, runtime);
  }

  async deleteFormDataWithOptions(request: DeleteFormDataRequest, tmpHeader: DeleteFormDataHeaders, runtime: $Util.RuntimeOptions): Promise<DeleteFormDataResponse> {
    Util.validateModel(request);
    let headers = new DeleteFormDataShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appType)) {
      body["AppType"] = request.appType;
    }

    if (!Util.isUnset(request.formInstanceId)) {
      body["FormInstanceId"] = request.formInstanceId;
    }

    if (!Util.isUnset(request.language)) {
      body["Language"] = request.language;
    }

    if (!Util.isUnset(request.systemToken)) {
      body["SystemToken"] = request.systemToken;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteFormData",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/yida/deleteFormData`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteFormDataResponse>(await this.callApi(params, req, runtime), new DeleteFormDataResponse({}));
  }

  async deleteFormData(request: DeleteFormDataRequest): Promise<DeleteFormDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new DeleteFormDataHeaders({ });
    return await this.deleteFormDataWithOptions(request, headers, runtime);
  }

  async deleteInstanceWithOptions(request: DeleteInstanceRequest, tmpHeader: DeleteInstanceHeaders, runtime: $Util.RuntimeOptions): Promise<DeleteInstanceResponse> {
    Util.validateModel(request);
    let headers = new DeleteInstanceShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appType)) {
      body["AppType"] = request.appType;
    }

    if (!Util.isUnset(request.language)) {
      body["Language"] = request.language;
    }

    if (!Util.isUnset(request.processInstanceId)) {
      body["ProcessInstanceId"] = request.processInstanceId;
    }

    if (!Util.isUnset(request.systemToken)) {
      body["SystemToken"] = request.systemToken;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteInstance",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/yida/deleteInstance`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteInstanceResponse>(await this.callApi(params, req, runtime), new DeleteInstanceResponse({}));
  }

  async deleteInstance(request: DeleteInstanceRequest): Promise<DeleteInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new DeleteInstanceHeaders({ });
    return await this.deleteInstanceWithOptions(request, headers, runtime);
  }

  async deleteLiveWithOptions(tmpReq: DeleteLiveRequest, tmpHeader: DeleteLiveHeaders, runtime: $Util.RuntimeOptions): Promise<DeleteLiveResponse> {
    Util.validateModel(tmpReq);
    let request = new DeleteLiveShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new DeleteLiveShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.liveId)) {
      body["LiveId"] = request.liveId;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteLive",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/ysp/deleteLive`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteLiveResponse>(await this.callApi(params, req, runtime), new DeleteLiveResponse({}));
  }

  async deleteLive(request: DeleteLiveRequest): Promise<DeleteLiveResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new DeleteLiveHeaders({ });
    return await this.deleteLiveWithOptions(request, headers, runtime);
  }

  async deleteMeetingRoomWithOptions(tmpReq: DeleteMeetingRoomRequest, tmpHeader: DeleteMeetingRoomHeaders, runtime: $Util.RuntimeOptions): Promise<DeleteMeetingRoomResponse> {
    Util.validateModel(tmpReq);
    let request = new DeleteMeetingRoomShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new DeleteMeetingRoomShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.roomId)) {
      body["RoomId"] = request.roomId;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteMeetingRoom",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/ysp/deleteMeetingRoom`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteMeetingRoomResponse>(await this.callApi(params, req, runtime), new DeleteMeetingRoomResponse({}));
  }

  async deleteMeetingRoom(request: DeleteMeetingRoomRequest): Promise<DeleteMeetingRoomResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new DeleteMeetingRoomHeaders({ });
    return await this.deleteMeetingRoomWithOptions(request, headers, runtime);
  }

  async deleteMeetingRoomGroupWithOptions(tmpReq: DeleteMeetingRoomGroupRequest, tmpHeader: DeleteMeetingRoomGroupHeaders, runtime: $Util.RuntimeOptions): Promise<DeleteMeetingRoomGroupResponse> {
    Util.validateModel(tmpReq);
    let request = new DeleteMeetingRoomGroupShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new DeleteMeetingRoomGroupShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.groupId)) {
      body["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteMeetingRoomGroup",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/ysp/deleteMeetingRoomGroup`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteMeetingRoomGroupResponse>(await this.callApi(params, req, runtime), new DeleteMeetingRoomGroupResponse({}));
  }

  async deleteMeetingRoomGroup(request: DeleteMeetingRoomGroupRequest): Promise<DeleteMeetingRoomGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new DeleteMeetingRoomGroupHeaders({ });
    return await this.deleteMeetingRoomGroupWithOptions(request, headers, runtime);
  }

  async deleteRowsWithOptions(tmpReq: DeleteRowsRequest, tmpHeader: DeleteRowsHeaders, runtime: $Util.RuntimeOptions): Promise<DeleteRowsResponse> {
    Util.validateModel(tmpReq);
    let request = new DeleteRowsShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new DeleteRowsShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.row)) {
      body["Row"] = request.row;
    }

    if (!Util.isUnset(request.rowCount)) {
      body["RowCount"] = request.rowCount;
    }

    if (!Util.isUnset(request.sheetId)) {
      body["SheetId"] = request.sheetId;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    if (!Util.isUnset(request.workbookId)) {
      body["WorkbookId"] = request.workbookId;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteRows",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/documents/deleteRows`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteRowsResponse>(await this.callApi(params, req, runtime), new DeleteRowsResponse({}));
  }

  async deleteRows(request: DeleteRowsRequest): Promise<DeleteRowsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new DeleteRowsHeaders({ });
    return await this.deleteRowsWithOptions(request, headers, runtime);
  }

  async deleteScenegroupMemberWithOptions(request: DeleteScenegroupMemberRequest, tmpHeader: DeleteScenegroupMemberHeaders, runtime: $Util.RuntimeOptions): Promise<DeleteScenegroupMemberResponse> {
    Util.validateModel(request);
    let headers = new DeleteScenegroupMemberShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.openConversationId)) {
      body["OpenConversationId"] = request.openConversationId;
    }

    if (!Util.isUnset(request.userIds)) {
      body["UserIds"] = request.userIds;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteScenegroupMember",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/im/deleteScenegroupMember`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteScenegroupMemberResponse>(await this.callApi(params, req, runtime), new DeleteScenegroupMemberResponse({}));
  }

  async deleteScenegroupMember(request: DeleteScenegroupMemberRequest): Promise<DeleteScenegroupMemberResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new DeleteScenegroupMemberHeaders({ });
    return await this.deleteScenegroupMemberWithOptions(request, headers, runtime);
  }

  async deleteSheetWithOptions(tmpReq: DeleteSheetRequest, tmpHeader: DeleteSheetHeaders, runtime: $Util.RuntimeOptions): Promise<DeleteSheetResponse> {
    Util.validateModel(tmpReq);
    let request = new DeleteSheetShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new DeleteSheetShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.sheetId)) {
      body["SheetId"] = request.sheetId;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    if (!Util.isUnset(request.workbookId)) {
      body["WorkbookId"] = request.workbookId;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteSheet",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/documents/deleteSheet`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteSheetResponse>(await this.callApi(params, req, runtime), new DeleteSheetResponse({}));
  }

  async deleteSheet(request: DeleteSheetRequest): Promise<DeleteSheetResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new DeleteSheetHeaders({ });
    return await this.deleteSheetWithOptions(request, headers, runtime);
  }

  async deleteSubscribedCalendarWithOptions(request: DeleteSubscribedCalendarRequest, tmpHeader: DeleteSubscribedCalendarHeaders, runtime: $Util.RuntimeOptions): Promise<DeleteSubscribedCalendarResponse> {
    Util.validateModel(request);
    let headers = new DeleteSubscribedCalendarShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.calendarId)) {
      body["CalendarId"] = request.calendarId;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteSubscribedCalendar",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/calendar/deleteSubscribedCalendar`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteSubscribedCalendarResponse>(await this.callApi(params, req, runtime), new DeleteSubscribedCalendarResponse({}));
  }

  async deleteSubscribedCalendar(request: DeleteSubscribedCalendarRequest): Promise<DeleteSubscribedCalendarResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new DeleteSubscribedCalendarHeaders({ });
    return await this.deleteSubscribedCalendarWithOptions(request, headers, runtime);
  }

  async deleteTodoTaskWithOptions(tmpReq: DeleteTodoTaskRequest, tmpHeader: DeleteTodoTaskHeaders, runtime: $Util.RuntimeOptions): Promise<DeleteTodoTaskResponse> {
    Util.validateModel(tmpReq);
    let request = new DeleteTodoTaskShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new DeleteTodoTaskShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    if (!Util.isUnset(request.operatorId)) {
      body["operatorId"] = request.operatorId;
    }

    if (!Util.isUnset(request.taskId)) {
      body["taskId"] = request.taskId;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteTodoTask",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/task/deleteTodoTask`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteTodoTaskResponse>(await this.callApi(params, req, runtime), new DeleteTodoTaskResponse({}));
  }

  async deleteTodoTask(request: DeleteTodoTaskRequest): Promise<DeleteTodoTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new DeleteTodoTaskHeaders({ });
    return await this.deleteTodoTaskWithOptions(request, headers, runtime);
  }

  async deleteWorkspaceDocMembersWithOptions(tmpReq: DeleteWorkspaceDocMembersRequest, tmpHeader: DeleteWorkspaceDocMembersHeaders, runtime: $Util.RuntimeOptions): Promise<DeleteWorkspaceDocMembersResponse> {
    Util.validateModel(tmpReq);
    let request = new DeleteWorkspaceDocMembersShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new DeleteWorkspaceDocMembersShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.members)) {
      request.membersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.members, "Members", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.membersShrink)) {
      body["Members"] = request.membersShrink;
    }

    if (!Util.isUnset(request.nodeId)) {
      body["NodeId"] = request.nodeId;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    if (!Util.isUnset(request.workspaceId)) {
      body["WorkspaceId"] = request.workspaceId;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteWorkspaceDocMembers",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/documents/deleteWorkspaceDocMembers`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteWorkspaceDocMembersResponse>(await this.callApi(params, req, runtime), new DeleteWorkspaceDocMembersResponse({}));
  }

  async deleteWorkspaceDocMembers(request: DeleteWorkspaceDocMembersRequest): Promise<DeleteWorkspaceDocMembersResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new DeleteWorkspaceDocMembersHeaders({ });
    return await this.deleteWorkspaceDocMembersWithOptions(request, headers, runtime);
  }

  async deleteWorkspaceMembersWithOptions(tmpReq: DeleteWorkspaceMembersRequest, tmpHeader: DeleteWorkspaceMembersHeaders, runtime: $Util.RuntimeOptions): Promise<DeleteWorkspaceMembersResponse> {
    Util.validateModel(tmpReq);
    let request = new DeleteWorkspaceMembersShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new DeleteWorkspaceMembersShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.members)) {
      request.membersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.members, "Members", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.membersShrink)) {
      body["Members"] = request.membersShrink;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    if (!Util.isUnset(request.workspaceId)) {
      body["WorkspaceId"] = request.workspaceId;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteWorkspaceMembers",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/documents/deleteWorkspaceMembers`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteWorkspaceMembersResponse>(await this.callApi(params, req, runtime), new DeleteWorkspaceMembersResponse({}));
  }

  async deleteWorkspaceMembers(request: DeleteWorkspaceMembersRequest): Promise<DeleteWorkspaceMembersResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new DeleteWorkspaceMembersHeaders({ });
    return await this.deleteWorkspaceMembersWithOptions(request, headers, runtime);
  }

  async executeBatchTaskWithOptions(request: ExecuteBatchTaskRequest, tmpHeader: ExecuteBatchTaskHeaders, runtime: $Util.RuntimeOptions): Promise<ExecuteBatchTaskResponse> {
    Util.validateModel(request);
    let headers = new ExecuteBatchTaskShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appType)) {
      body["AppType"] = request.appType;
    }

    if (!Util.isUnset(request.outResult)) {
      body["OutResult"] = request.outResult;
    }

    if (!Util.isUnset(request.remark)) {
      body["Remark"] = request.remark;
    }

    if (!Util.isUnset(request.systemToken)) {
      body["SystemToken"] = request.systemToken;
    }

    if (!Util.isUnset(request.taskInformationList)) {
      body["TaskInformationList"] = request.taskInformationList;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ExecuteBatchTask",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/yida/executeBatchTask`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ExecuteBatchTaskResponse>(await this.callApi(params, req, runtime), new ExecuteBatchTaskResponse({}));
  }

  async executeBatchTask(request: ExecuteBatchTaskRequest): Promise<ExecuteBatchTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new ExecuteBatchTaskHeaders({ });
    return await this.executeBatchTaskWithOptions(request, headers, runtime);
  }

  async executePlatformTaskWithOptions(request: ExecutePlatformTaskRequest, tmpHeader: ExecutePlatformTaskHeaders, runtime: $Util.RuntimeOptions): Promise<ExecutePlatformTaskResponse> {
    Util.validateModel(request);
    let headers = new ExecutePlatformTaskShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appType)) {
      body["AppType"] = request.appType;
    }

    if (!Util.isUnset(request.formDataJson)) {
      body["FormDataJson"] = request.formDataJson;
    }

    if (!Util.isUnset(request.language)) {
      body["Language"] = request.language;
    }

    if (!Util.isUnset(request.noExecuteExpressions)) {
      body["NoExecuteExpressions"] = request.noExecuteExpressions;
    }

    if (!Util.isUnset(request.outResult)) {
      body["OutResult"] = request.outResult;
    }

    if (!Util.isUnset(request.processInstanceId)) {
      body["ProcessInstanceId"] = request.processInstanceId;
    }

    if (!Util.isUnset(request.remark)) {
      body["Remark"] = request.remark;
    }

    if (!Util.isUnset(request.systemToken)) {
      body["SystemToken"] = request.systemToken;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ExecutePlatformTask",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/yida/executePlatformTask`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ExecutePlatformTaskResponse>(await this.callApi(params, req, runtime), new ExecutePlatformTaskResponse({}));
  }

  async executePlatformTask(request: ExecutePlatformTaskRequest): Promise<ExecutePlatformTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new ExecutePlatformTaskHeaders({ });
    return await this.executePlatformTaskWithOptions(request, headers, runtime);
  }

  async executeTaskWithOptions(request: ExecuteTaskRequest, tmpHeader: ExecuteTaskHeaders, runtime: $Util.RuntimeOptions): Promise<ExecuteTaskResponse> {
    Util.validateModel(request);
    let headers = new ExecuteTaskShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appType)) {
      body["AppType"] = request.appType;
    }

    if (!Util.isUnset(request.digitalSignUrl)) {
      body["DigitalSignUrl"] = request.digitalSignUrl;
    }

    if (!Util.isUnset(request.formDataJson)) {
      body["FormDataJson"] = request.formDataJson;
    }

    if (!Util.isUnset(request.language)) {
      body["Language"] = request.language;
    }

    if (!Util.isUnset(request.noExecuteExpressions)) {
      body["NoExecuteExpressions"] = request.noExecuteExpressions;
    }

    if (!Util.isUnset(request.outResult)) {
      body["OutResult"] = request.outResult;
    }

    if (!Util.isUnset(request.processInstanceId)) {
      body["ProcessInstanceId"] = request.processInstanceId;
    }

    if (!Util.isUnset(request.remark)) {
      body["Remark"] = request.remark;
    }

    if (!Util.isUnset(request.systemToken)) {
      body["SystemToken"] = request.systemToken;
    }

    if (!Util.isUnset(request.taskId)) {
      body["TaskId"] = request.taskId;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ExecuteTask",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/yida/executeTask`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ExecuteTaskResponse>(await this.callApi(params, req, runtime), new ExecuteTaskResponse({}));
  }

  async executeTask(request: ExecuteTaskRequest): Promise<ExecuteTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new ExecuteTaskHeaders({ });
    return await this.executeTaskWithOptions(request, headers, runtime);
  }

  async expandGroupCapacityWithOptions(tmpReq: ExpandGroupCapacityRequest, tmpHeader: ExpandGroupCapacityHeaders, runtime: $Util.RuntimeOptions): Promise<ExpandGroupCapacityResponse> {
    Util.validateModel(tmpReq);
    let request = new ExpandGroupCapacityShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new ExpandGroupCapacityShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.openConversationId)) {
      body["OpenConversationId"] = request.openConversationId;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ExpandGroupCapacity",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/aliding/v1/im/expandGroupCapacity`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ExpandGroupCapacityResponse>(await this.callApi(params, req, runtime), new ExpandGroupCapacityResponse({}));
  }

  async expandGroupCapacity(request: ExpandGroupCapacityRequest): Promise<ExpandGroupCapacityResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new ExpandGroupCapacityHeaders({ });
    return await this.expandGroupCapacityWithOptions(request, headers, runtime);
  }

  async getActivityListWithOptions(request: GetActivityListRequest, tmpHeader: GetActivityListHeaders, runtime: $Util.RuntimeOptions): Promise<GetActivityListResponse> {
    Util.validateModel(request);
    let headers = new GetActivityListShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appType)) {
      body["AppType"] = request.appType;
    }

    if (!Util.isUnset(request.language)) {
      body["Language"] = request.language;
    }

    if (!Util.isUnset(request.processCode)) {
      body["ProcessCode"] = request.processCode;
    }

    if (!Util.isUnset(request.systemToken)) {
      body["SystemToken"] = request.systemToken;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetActivityList",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/yida/getActivityList`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetActivityListResponse>(await this.callApi(params, req, runtime), new GetActivityListResponse({}));
  }

  async getActivityList(request: GetActivityListRequest): Promise<GetActivityListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new GetActivityListHeaders({ });
    return await this.getActivityListWithOptions(request, headers, runtime);
  }

  async getAllSheetsWithOptions(tmpReq: GetAllSheetsRequest, tmpHeader: GetAllSheetsHeaders, runtime: $Util.RuntimeOptions): Promise<GetAllSheetsResponse> {
    Util.validateModel(tmpReq);
    let request = new GetAllSheetsShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new GetAllSheetsShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    if (!Util.isUnset(request.workbookId)) {
      body["WorkbookId"] = request.workbookId;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetAllSheets",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/documents/getAllSheets`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetAllSheetsResponse>(await this.callApi(params, req, runtime), new GetAllSheetsResponse({}));
  }

  async getAllSheets(request: GetAllSheetsRequest): Promise<GetAllSheetsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new GetAllSheetsHeaders({ });
    return await this.getAllSheetsWithOptions(request, headers, runtime);
  }

  async getConversaionSpaceWithOptions(tmpReq: GetConversaionSpaceRequest, tmpHeader: GetConversaionSpaceHeaders, runtime: $Util.RuntimeOptions): Promise<GetConversaionSpaceResponse> {
    Util.validateModel(tmpReq);
    let request = new GetConversaionSpaceShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new GetConversaionSpaceShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.openConversationId)) {
      body["OpenConversationId"] = request.openConversationId;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetConversaionSpace",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/documents/getConversaionSpace`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetConversaionSpaceResponse>(await this.callApi(params, req, runtime), new GetConversaionSpaceResponse({}));
  }

  async getConversaionSpace(request: GetConversaionSpaceRequest): Promise<GetConversaionSpaceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new GetConversaionSpaceHeaders({ });
    return await this.getConversaionSpaceWithOptions(request, headers, runtime);
  }

  async getCorpAccomplishmentTasksWithOptions(request: GetCorpAccomplishmentTasksRequest, tmpHeader: GetCorpAccomplishmentTasksHeaders, runtime: $Util.RuntimeOptions): Promise<GetCorpAccomplishmentTasksResponse> {
    Util.validateModel(request);
    let headers = new GetCorpAccomplishmentTasksShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appTypes)) {
      body["AppTypes"] = request.appTypes;
    }

    if (!Util.isUnset(request.corpId)) {
      body["CorpId"] = request.corpId;
    }

    if (!Util.isUnset(request.createFromTimeGMT)) {
      body["CreateFromTimeGMT"] = request.createFromTimeGMT;
    }

    if (!Util.isUnset(request.createToTimeGMT)) {
      body["CreateToTimeGMT"] = request.createToTimeGMT;
    }

    if (!Util.isUnset(request.keyword)) {
      body["Keyword"] = request.keyword;
    }

    if (!Util.isUnset(request.language)) {
      body["Language"] = request.language;
    }

    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.processCodes)) {
      body["ProcessCodes"] = request.processCodes;
    }

    if (!Util.isUnset(request.token)) {
      body["Token"] = request.token;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetCorpAccomplishmentTasks",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/yida/getCorpAccomplishmentTasks`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetCorpAccomplishmentTasksResponse>(await this.callApi(params, req, runtime), new GetCorpAccomplishmentTasksResponse({}));
  }

  async getCorpAccomplishmentTasks(request: GetCorpAccomplishmentTasksRequest): Promise<GetCorpAccomplishmentTasksResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new GetCorpAccomplishmentTasksHeaders({ });
    return await this.getCorpAccomplishmentTasksWithOptions(request, headers, runtime);
  }

  async getCorpTasksWithOptions(request: GetCorpTasksRequest, tmpHeader: GetCorpTasksHeaders, runtime: $Util.RuntimeOptions): Promise<GetCorpTasksResponse> {
    Util.validateModel(request);
    let headers = new GetCorpTasksShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appTypes)) {
      body["AppTypes"] = request.appTypes;
    }

    if (!Util.isUnset(request.corpId)) {
      body["CorpId"] = request.corpId;
    }

    if (!Util.isUnset(request.createFromTimeGMT)) {
      body["CreateFromTimeGMT"] = request.createFromTimeGMT;
    }

    if (!Util.isUnset(request.createToTimeGMT)) {
      body["CreateToTimeGMT"] = request.createToTimeGMT;
    }

    if (!Util.isUnset(request.keyword)) {
      body["Keyword"] = request.keyword;
    }

    if (!Util.isUnset(request.language)) {
      body["Language"] = request.language;
    }

    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.processCodes)) {
      body["ProcessCodes"] = request.processCodes;
    }

    if (!Util.isUnset(request.token)) {
      body["Token"] = request.token;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetCorpTasks",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/yida/getCorpTasks`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetCorpTasksResponse>(await this.callApi(params, req, runtime), new GetCorpTasksResponse({}));
  }

  async getCorpTasks(request: GetCorpTasksRequest): Promise<GetCorpTasksResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new GetCorpTasksHeaders({ });
    return await this.getCorpTasksWithOptions(request, headers, runtime);
  }

  async getDocContentWithOptions(tmpReq: GetDocContentRequest, tmpHeader: GetDocContentHeaders, runtime: $Util.RuntimeOptions): Promise<GetDocContentResponse> {
    Util.validateModel(tmpReq);
    let request = new GetDocContentShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new GetDocContentShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.dentryUuid)) {
      body["DentryUuid"] = request.dentryUuid;
    }

    if (!Util.isUnset(request.targetFormat)) {
      body["TargetFormat"] = request.targetFormat;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    if (!Util.isUnset(request.userToken)) {
      body["userToken"] = request.userToken;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetDocContent",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v2/documents/getDocContent`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDocContentResponse>(await this.callApi(params, req, runtime), new GetDocContentResponse({}));
  }

  async getDocContent(request: GetDocContentRequest): Promise<GetDocContentResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new GetDocContentHeaders({ });
    return await this.getDocContentWithOptions(request, headers, runtime);
  }

  async getEventWithOptions(request: GetEventRequest, tmpHeader: GetEventHeaders, runtime: $Util.RuntimeOptions): Promise<GetEventResponse> {
    Util.validateModel(request);
    let headers = new GetEventShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    let query : {[key: string ]: any} = { };
    if (!Util.isUnset(request.maxAttendees)) {
      query["MaxAttendees"] = request.maxAttendees;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.calendarId)) {
      body["CalendarId"] = request.calendarId;
    }

    if (!Util.isUnset(request.eventId)) {
      body["EventId"] = request.eventId;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetEvent",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/calendar/getEvent`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetEventResponse>(await this.callApi(params, req, runtime), new GetEventResponse({}));
  }

  async getEvent(request: GetEventRequest): Promise<GetEventResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new GetEventHeaders({ });
    return await this.getEventWithOptions(request, headers, runtime);
  }

  async getFieldDefByUuidWithOptions(request: GetFieldDefByUuidRequest, tmpHeader: GetFieldDefByUuidHeaders, runtime: $Util.RuntimeOptions): Promise<GetFieldDefByUuidResponse> {
    Util.validateModel(request);
    let headers = new GetFieldDefByUuidShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appType)) {
      body["AppType"] = request.appType;
    }

    if (!Util.isUnset(request.formUuid)) {
      body["FormUuid"] = request.formUuid;
    }

    if (!Util.isUnset(request.systemToken)) {
      body["SystemToken"] = request.systemToken;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetFieldDefByUuid",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/yida/getFieldDefByUuid`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetFieldDefByUuidResponse>(await this.callApi(params, req, runtime), new GetFieldDefByUuidResponse({}));
  }

  async getFieldDefByUuid(request: GetFieldDefByUuidRequest): Promise<GetFieldDefByUuidResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new GetFieldDefByUuidHeaders({ });
    return await this.getFieldDefByUuidWithOptions(request, headers, runtime);
  }

  async getFileDownloadInfoWithOptions(tmpReq: GetFileDownloadInfoRequest, tmpHeader: GetFileDownloadInfoHeaders, runtime: $Util.RuntimeOptions): Promise<GetFileDownloadInfoResponse> {
    Util.validateModel(tmpReq);
    let request = new GetFileDownloadInfoShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new GetFileDownloadInfoShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.option)) {
      request.optionShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.option, "Option", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.dentryId)) {
      body["DentryId"] = request.dentryId;
    }

    if (!Util.isUnset(request.optionShrink)) {
      body["Option"] = request.optionShrink;
    }

    if (!Util.isUnset(request.spaceId)) {
      body["SpaceId"] = request.spaceId;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetFileDownloadInfo",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/documents/getFileDownloadInfo`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetFileDownloadInfoResponse>(await this.callApi(params, req, runtime), new GetFileDownloadInfoResponse({}));
  }

  async getFileDownloadInfo(request: GetFileDownloadInfoRequest): Promise<GetFileDownloadInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new GetFileDownloadInfoHeaders({ });
    return await this.getFileDownloadInfoWithOptions(request, headers, runtime);
  }

  async getFormComponentDefinitionListWithOptions(request: GetFormComponentDefinitionListRequest, tmpHeader: GetFormComponentDefinitionListHeaders, runtime: $Util.RuntimeOptions): Promise<GetFormComponentDefinitionListResponse> {
    Util.validateModel(request);
    let headers = new GetFormComponentDefinitionListShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appType)) {
      body["AppType"] = request.appType;
    }

    if (!Util.isUnset(request.formUuid)) {
      body["FormUuid"] = request.formUuid;
    }

    if (!Util.isUnset(request.language)) {
      body["Language"] = request.language;
    }

    if (!Util.isUnset(request.systemToken)) {
      body["SystemToken"] = request.systemToken;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetFormComponentDefinitionList",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/yida/getFormComponentDefinitionList`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetFormComponentDefinitionListResponse>(await this.callApi(params, req, runtime), new GetFormComponentDefinitionListResponse({}));
  }

  async getFormComponentDefinitionList(request: GetFormComponentDefinitionListRequest): Promise<GetFormComponentDefinitionListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new GetFormComponentDefinitionListHeaders({ });
    return await this.getFormComponentDefinitionListWithOptions(request, headers, runtime);
  }

  async getFormDataByIDWithOptions(request: GetFormDataByIDRequest, tmpHeader: GetFormDataByIDHeaders, runtime: $Util.RuntimeOptions): Promise<GetFormDataByIDResponse> {
    Util.validateModel(request);
    let headers = new GetFormDataByIDShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appType)) {
      body["AppType"] = request.appType;
    }

    if (!Util.isUnset(request.id)) {
      body["Id"] = request.id;
    }

    if (!Util.isUnset(request.language)) {
      body["Language"] = request.language;
    }

    if (!Util.isUnset(request.systemToken)) {
      body["SystemToken"] = request.systemToken;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetFormDataByID",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/yida/getFormDataByID`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetFormDataByIDResponse>(await this.callApi(params, req, runtime), new GetFormDataByIDResponse({}));
  }

  async getFormDataByID(request: GetFormDataByIDRequest): Promise<GetFormDataByIDResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new GetFormDataByIDHeaders({ });
    return await this.getFormDataByIDWithOptions(request, headers, runtime);
  }

  async getFormListInAppWithOptions(request: GetFormListInAppRequest, tmpHeader: GetFormListInAppHeaders, runtime: $Util.RuntimeOptions): Promise<GetFormListInAppResponse> {
    Util.validateModel(request);
    let headers = new GetFormListInAppShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appType)) {
      body["AppType"] = request.appType;
    }

    if (!Util.isUnset(request.formTypes)) {
      body["FormTypes"] = request.formTypes;
    }

    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.systemToken)) {
      body["SystemToken"] = request.systemToken;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetFormListInApp",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/yida/getFormListInApp`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetFormListInAppResponse>(await this.callApi(params, req, runtime), new GetFormListInAppResponse({}));
  }

  async getFormListInApp(request: GetFormListInAppRequest): Promise<GetFormListInAppResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new GetFormListInAppHeaders({ });
    return await this.getFormListInAppWithOptions(request, headers, runtime);
  }

  async getInnerGroupMembersWithOptions(request: GetInnerGroupMembersRequest, tmpHeader: GetInnerGroupMembersHeaders, runtime: $Util.RuntimeOptions): Promise<GetInnerGroupMembersResponse> {
    Util.validateModel(request);
    let headers = new GetInnerGroupMembersShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.maxResults)) {
      body["MaxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.nextToken)) {
      body["NextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.openConversationId)) {
      body["OpenConversationId"] = request.openConversationId;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetInnerGroupMembers",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/im/getInnerGroupMembers`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetInnerGroupMembersResponse>(await this.callApi(params, req, runtime), new GetInnerGroupMembersResponse({}));
  }

  async getInnerGroupMembers(request: GetInnerGroupMembersRequest): Promise<GetInnerGroupMembersResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new GetInnerGroupMembersHeaders({ });
    return await this.getInnerGroupMembersWithOptions(request, headers, runtime);
  }

  async getInstanceByIdWithOptions(request: GetInstanceByIdRequest, tmpHeader: GetInstanceByIdHeaders, runtime: $Util.RuntimeOptions): Promise<GetInstanceByIdResponse> {
    Util.validateModel(request);
    let headers = new GetInstanceByIdShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appType)) {
      body["AppType"] = request.appType;
    }

    if (!Util.isUnset(request.id)) {
      body["Id"] = request.id;
    }

    if (!Util.isUnset(request.language)) {
      body["Language"] = request.language;
    }

    if (!Util.isUnset(request.systemToken)) {
      body["SystemToken"] = request.systemToken;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetInstanceById",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/yida/getInstanceById`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetInstanceByIdResponse>(await this.callApi(params, req, runtime), new GetInstanceByIdResponse({}));
  }

  async getInstanceById(request: GetInstanceByIdRequest): Promise<GetInstanceByIdResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new GetInstanceByIdHeaders({ });
    return await this.getInstanceByIdWithOptions(request, headers, runtime);
  }

  async getInstanceIdListWithOptions(request: GetInstanceIdListRequest, tmpHeader: GetInstanceIdListHeaders, runtime: $Util.RuntimeOptions): Promise<GetInstanceIdListResponse> {
    Util.validateModel(request);
    let headers = new GetInstanceIdListShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appType)) {
      body["AppType"] = request.appType;
    }

    if (!Util.isUnset(request.approvedResult)) {
      body["ApprovedResult"] = request.approvedResult;
    }

    if (!Util.isUnset(request.createFromTimeGMT)) {
      body["CreateFromTimeGMT"] = request.createFromTimeGMT;
    }

    if (!Util.isUnset(request.createToTimeGMT)) {
      body["CreateToTimeGMT"] = request.createToTimeGMT;
    }

    if (!Util.isUnset(request.formUuid)) {
      body["FormUuid"] = request.formUuid;
    }

    if (!Util.isUnset(request.instanceStatus)) {
      body["InstanceStatus"] = request.instanceStatus;
    }

    if (!Util.isUnset(request.language)) {
      body["Language"] = request.language;
    }

    if (!Util.isUnset(request.modifiedFromTimeGMT)) {
      body["ModifiedFromTimeGMT"] = request.modifiedFromTimeGMT;
    }

    if (!Util.isUnset(request.modifiedToTimeGMT)) {
      body["ModifiedToTimeGMT"] = request.modifiedToTimeGMT;
    }

    if (!Util.isUnset(request.originatorId)) {
      body["OriginatorId"] = request.originatorId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.searchFieldJson)) {
      body["SearchFieldJson"] = request.searchFieldJson;
    }

    if (!Util.isUnset(request.systemToken)) {
      body["SystemToken"] = request.systemToken;
    }

    if (!Util.isUnset(request.taskId)) {
      body["TaskId"] = request.taskId;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetInstanceIdList",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/yida/getInstanceIdList`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetInstanceIdListResponse>(await this.callApi(params, req, runtime), new GetInstanceIdListResponse({}));
  }

  async getInstanceIdList(request: GetInstanceIdListRequest): Promise<GetInstanceIdListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new GetInstanceIdListHeaders({ });
    return await this.getInstanceIdListWithOptions(request, headers, runtime);
  }

  async getInstancesWithOptions(request: GetInstancesRequest, tmpHeader: GetInstancesHeaders, runtime: $Util.RuntimeOptions): Promise<GetInstancesResponse> {
    Util.validateModel(request);
    let headers = new GetInstancesShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appType)) {
      body["AppType"] = request.appType;
    }

    if (!Util.isUnset(request.approvedResult)) {
      body["ApprovedResult"] = request.approvedResult;
    }

    if (!Util.isUnset(request.createFromTimeGMT)) {
      body["CreateFromTimeGMT"] = request.createFromTimeGMT;
    }

    if (!Util.isUnset(request.createToTimeGMT)) {
      body["CreateToTimeGMT"] = request.createToTimeGMT;
    }

    if (!Util.isUnset(request.formUuid)) {
      body["FormUuid"] = request.formUuid;
    }

    if (!Util.isUnset(request.instanceStatus)) {
      body["InstanceStatus"] = request.instanceStatus;
    }

    if (!Util.isUnset(request.language)) {
      body["Language"] = request.language;
    }

    if (!Util.isUnset(request.modifiedFromTimeGMT)) {
      body["ModifiedFromTimeGMT"] = request.modifiedFromTimeGMT;
    }

    if (!Util.isUnset(request.modifiedToTimeGMT)) {
      body["ModifiedToTimeGMT"] = request.modifiedToTimeGMT;
    }

    if (!Util.isUnset(request.orderConfigJson)) {
      body["OrderConfigJson"] = request.orderConfigJson;
    }

    if (!Util.isUnset(request.originatorId)) {
      body["OriginatorId"] = request.originatorId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.searchFieldJson)) {
      body["SearchFieldJson"] = request.searchFieldJson;
    }

    if (!Util.isUnset(request.systemToken)) {
      body["SystemToken"] = request.systemToken;
    }

    if (!Util.isUnset(request.taskId)) {
      body["TaskId"] = request.taskId;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetInstances",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/yida/getInstances`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetInstancesResponse>(await this.callApi(params, req, runtime), new GetInstancesResponse({}));
  }

  async getInstances(request: GetInstancesRequest): Promise<GetInstancesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new GetInstancesHeaders({ });
    return await this.getInstancesWithOptions(request, headers, runtime);
  }

  async getInstancesByIdListWithOptions(request: GetInstancesByIdListRequest, tmpHeader: GetInstancesByIdListHeaders, runtime: $Util.RuntimeOptions): Promise<GetInstancesByIdListResponse> {
    Util.validateModel(request);
    let headers = new GetInstancesByIdListShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appType)) {
      body["AppType"] = request.appType;
    }

    if (!Util.isUnset(request.language)) {
      body["Language"] = request.language;
    }

    if (!Util.isUnset(request.processInstanceIds)) {
      body["ProcessInstanceIds"] = request.processInstanceIds;
    }

    if (!Util.isUnset(request.systemToken)) {
      body["SystemToken"] = request.systemToken;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetInstancesByIdList",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/yida/getInstancesByIdList`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetInstancesByIdListResponse>(await this.callApi(params, req, runtime), new GetInstancesByIdListResponse({}));
  }

  async getInstancesByIdList(request: GetInstancesByIdListRequest): Promise<GetInstancesByIdListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new GetInstancesByIdListHeaders({ });
    return await this.getInstancesByIdListWithOptions(request, headers, runtime);
  }

  async getLiveReplayUrlWithOptions(tmpReq: GetLiveReplayUrlRequest, tmpHeader: GetLiveReplayUrlHeaders, runtime: $Util.RuntimeOptions): Promise<GetLiveReplayUrlResponse> {
    Util.validateModel(tmpReq);
    let request = new GetLiveReplayUrlShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new GetLiveReplayUrlShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.liveId)) {
      body["LiveId"] = request.liveId;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetLiveReplayUrl",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/ysp/getLiveReplayUrl`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetLiveReplayUrlResponse>(await this.callApi(params, req, runtime), new GetLiveReplayUrlResponse({}));
  }

  async getLiveReplayUrl(request: GetLiveReplayUrlRequest): Promise<GetLiveReplayUrlResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new GetLiveReplayUrlHeaders({ });
    return await this.getLiveReplayUrlWithOptions(request, headers, runtime);
  }

  async getMeCorpSubmissionWithOptions(request: GetMeCorpSubmissionRequest, tmpHeader: GetMeCorpSubmissionHeaders, runtime: $Util.RuntimeOptions): Promise<GetMeCorpSubmissionResponse> {
    Util.validateModel(request);
    let headers = new GetMeCorpSubmissionShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appTypes)) {
      body["AppTypes"] = request.appTypes;
    }

    if (!Util.isUnset(request.corpId)) {
      body["CorpId"] = request.corpId;
    }

    if (!Util.isUnset(request.createFromTimeGMT)) {
      body["CreateFromTimeGMT"] = request.createFromTimeGMT;
    }

    if (!Util.isUnset(request.createToTimeGMT)) {
      body["CreateToTimeGMT"] = request.createToTimeGMT;
    }

    if (!Util.isUnset(request.keyword)) {
      body["Keyword"] = request.keyword;
    }

    if (!Util.isUnset(request.language)) {
      body["Language"] = request.language;
    }

    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.processCodes)) {
      body["ProcessCodes"] = request.processCodes;
    }

    if (!Util.isUnset(request.token)) {
      body["Token"] = request.token;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetMeCorpSubmission",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/yida/getMeCorpSubmission`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetMeCorpSubmissionResponse>(await this.callApi(params, req, runtime), new GetMeCorpSubmissionResponse({}));
  }

  async getMeCorpSubmission(request: GetMeCorpSubmissionRequest): Promise<GetMeCorpSubmissionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new GetMeCorpSubmissionHeaders({ });
    return await this.getMeCorpSubmissionWithOptions(request, headers, runtime);
  }

  async getMeetingRoomsScheduleWithOptions(tmpReq: GetMeetingRoomsScheduleRequest, tmpHeader: GetMeetingRoomsScheduleHeaders, runtime: $Util.RuntimeOptions): Promise<GetMeetingRoomsScheduleResponse> {
    Util.validateModel(tmpReq);
    let request = new GetMeetingRoomsScheduleShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new GetMeetingRoomsScheduleShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.roomIds)) {
      request.roomIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.roomIds, "RoomIds", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.endTime)) {
      body["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.roomIdsShrink)) {
      body["RoomIds"] = request.roomIdsShrink;
    }

    if (!Util.isUnset(request.startTime)) {
      body["StartTime"] = request.startTime;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetMeetingRoomsSchedule",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/calendar/getMeetingRoomsSchedule`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetMeetingRoomsScheduleResponse>(await this.callApi(params, req, runtime), new GetMeetingRoomsScheduleResponse({}));
  }

  async getMeetingRoomsSchedule(request: GetMeetingRoomsScheduleRequest): Promise<GetMeetingRoomsScheduleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new GetMeetingRoomsScheduleHeaders({ });
    return await this.getMeetingRoomsScheduleWithOptions(request, headers, runtime);
  }

  async getMineWorkspaceWithOptions(tmpReq: GetMineWorkspaceRequest, tmpHeader: GetMineWorkspaceHeaders, runtime: $Util.RuntimeOptions): Promise<GetMineWorkspaceResponse> {
    Util.validateModel(tmpReq);
    let request = new GetMineWorkspaceShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new GetMineWorkspaceShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.request)) {
      request.requestShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.request, "Request", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.requestShrink)) {
      body["Request"] = request.requestShrink;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetMineWorkspace",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v2/documents/getMineWorkspace`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetMineWorkspaceResponse>(await this.callApi(params, req, runtime), new GetMineWorkspaceResponse({}));
  }

  async getMineWorkspace(request: GetMineWorkspaceRequest): Promise<GetMineWorkspaceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new GetMineWorkspaceHeaders({ });
    return await this.getMineWorkspaceWithOptions(request, headers, runtime);
  }

  async getNewestInnerGroupsWithOptions(tmpReq: GetNewestInnerGroupsRequest, tmpHeader: GetNewestInnerGroupsHeaders, runtime: $Util.RuntimeOptions): Promise<GetNewestInnerGroupsResponse> {
    Util.validateModel(tmpReq);
    let request = new GetNewestInnerGroupsShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new GetNewestInnerGroupsShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.request)) {
      request.requestShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.request, "Request", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.requestShrink)) {
      body["Request"] = request.requestShrink;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetNewestInnerGroups",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/im/getNewestInnerGroups`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetNewestInnerGroupsResponse>(await this.callApi(params, req, runtime), new GetNewestInnerGroupsResponse({}));
  }

  async getNewestInnerGroups(request: GetNewestInnerGroupsRequest): Promise<GetNewestInnerGroupsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new GetNewestInnerGroupsHeaders({ });
    return await this.getNewestInnerGroupsWithOptions(request, headers, runtime);
  }

  async getNodeWithOptions(tmpReq: GetNodeRequest, tmpHeader: GetNodeHeaders, runtime: $Util.RuntimeOptions): Promise<GetNodeResponse> {
    Util.validateModel(tmpReq);
    let request = new GetNodeShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new GetNodeShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.nodeId)) {
      body["NodeId"] = request.nodeId;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    if (!Util.isUnset(request.withPermissionRole)) {
      body["WithPermissionRole"] = request.withPermissionRole;
    }

    if (!Util.isUnset(request.withStatisticalInfo)) {
      body["WithStatisticalInfo"] = request.withStatisticalInfo;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetNode",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v2/documents/getNode`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetNodeResponse>(await this.callApi(params, req, runtime), new GetNodeResponse({}));
  }

  async getNode(request: GetNodeRequest): Promise<GetNodeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new GetNodeHeaders({ });
    return await this.getNodeWithOptions(request, headers, runtime);
  }

  async getNodeByUrlWithOptions(tmpReq: GetNodeByUrlRequest, tmpHeader: GetNodeByUrlHeaders, runtime: $Util.RuntimeOptions): Promise<GetNodeByUrlResponse> {
    Util.validateModel(tmpReq);
    let request = new GetNodeByUrlShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new GetNodeByUrlShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.option)) {
      request.optionShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.option, "Option", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.optionShrink)) {
      body["Option"] = request.optionShrink;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    if (!Util.isUnset(request.url)) {
      body["Url"] = request.url;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetNodeByUrl",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v2/documents/getNodeByUrl`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetNodeByUrlResponse>(await this.callApi(params, req, runtime), new GetNodeByUrlResponse({}));
  }

  async getNodeByUrl(request: GetNodeByUrlRequest): Promise<GetNodeByUrlResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new GetNodeByUrlHeaders({ });
    return await this.getNodeByUrlWithOptions(request, headers, runtime);
  }

  async getNodesWithOptions(tmpReq: GetNodesRequest, tmpHeader: GetNodesHeaders, runtime: $Util.RuntimeOptions): Promise<GetNodesResponse> {
    Util.validateModel(tmpReq);
    let request = new GetNodesShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new GetNodesShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.nodeIds)) {
      request.nodeIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.nodeIds, "NodeIds", "json");
    }

    if (!Util.isUnset(tmpReq.option)) {
      request.optionShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.option, "Option", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.nodeIdsShrink)) {
      body["NodeIds"] = request.nodeIdsShrink;
    }

    if (!Util.isUnset(request.optionShrink)) {
      body["Option"] = request.optionShrink;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetNodes",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v2/documents/getNodes`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetNodesResponse>(await this.callApi(params, req, runtime), new GetNodesResponse({}));
  }

  async getNodes(request: GetNodesRequest): Promise<GetNodesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new GetNodesHeaders({ });
    return await this.getNodesWithOptions(request, headers, runtime);
  }

  async getNotifyMeWithOptions(request: GetNotifyMeRequest, tmpHeader: GetNotifyMeHeaders, runtime: $Util.RuntimeOptions): Promise<GetNotifyMeResponse> {
    Util.validateModel(request);
    let headers = new GetNotifyMeShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appTypes)) {
      body["AppTypes"] = request.appTypes;
    }

    if (!Util.isUnset(request.corpId)) {
      body["CorpId"] = request.corpId;
    }

    if (!Util.isUnset(request.createFromTimeGMT)) {
      body["CreateFromTimeGMT"] = request.createFromTimeGMT;
    }

    if (!Util.isUnset(request.createToTimeGMT)) {
      body["CreateToTimeGMT"] = request.createToTimeGMT;
    }

    if (!Util.isUnset(request.instanceCreateFromTimeGMT)) {
      body["InstanceCreateFromTimeGMT"] = request.instanceCreateFromTimeGMT;
    }

    if (!Util.isUnset(request.instanceCreateToTimeGMT)) {
      body["InstanceCreateToTimeGMT"] = request.instanceCreateToTimeGMT;
    }

    if (!Util.isUnset(request.keyword)) {
      body["Keyword"] = request.keyword;
    }

    if (!Util.isUnset(request.language)) {
      body["Language"] = request.language;
    }

    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.processCodes)) {
      body["ProcessCodes"] = request.processCodes;
    }

    if (!Util.isUnset(request.token)) {
      body["Token"] = request.token;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetNotifyMe",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/yida/getNotifyMe`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetNotifyMeResponse>(await this.callApi(params, req, runtime), new GetNotifyMeResponse({}));
  }

  async getNotifyMe(request: GetNotifyMeRequest): Promise<GetNotifyMeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new GetNotifyMeHeaders({ });
    return await this.getNotifyMeWithOptions(request, headers, runtime);
  }

  async getOpenUrlWithOptions(request: GetOpenUrlRequest, tmpHeader: GetOpenUrlHeaders, runtime: $Util.RuntimeOptions): Promise<GetOpenUrlResponse> {
    Util.validateModel(request);
    let headers = new GetOpenUrlShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appType)) {
      body["AppType"] = request.appType;
    }

    if (!Util.isUnset(request.fileUrl)) {
      body["FileUrl"] = request.fileUrl;
    }

    if (!Util.isUnset(request.language)) {
      body["Language"] = request.language;
    }

    if (!Util.isUnset(request.systemToken)) {
      body["SystemToken"] = request.systemToken;
    }

    if (!Util.isUnset(request.timeout)) {
      body["Timeout"] = request.timeout;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetOpenUrl",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/yida/getOpenUrl`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetOpenUrlResponse>(await this.callApi(params, req, runtime), new GetOpenUrlResponse({}));
  }

  async getOpenUrl(request: GetOpenUrlRequest): Promise<GetOpenUrlResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new GetOpenUrlHeaders({ });
    return await this.getOpenUrlWithOptions(request, headers, runtime);
  }

  async getOperationRecordsWithOptions(request: GetOperationRecordsRequest, tmpHeader: GetOperationRecordsHeaders, runtime: $Util.RuntimeOptions): Promise<GetOperationRecordsResponse> {
    Util.validateModel(request);
    let headers = new GetOperationRecordsShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appType)) {
      body["AppType"] = request.appType;
    }

    if (!Util.isUnset(request.language)) {
      body["Language"] = request.language;
    }

    if (!Util.isUnset(request.processInstanceId)) {
      body["ProcessInstanceId"] = request.processInstanceId;
    }

    if (!Util.isUnset(request.systemToken)) {
      body["SystemToken"] = request.systemToken;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetOperationRecords",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/yida/getOperationRecords`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetOperationRecordsResponse>(await this.callApi(params, req, runtime), new GetOperationRecordsResponse({}));
  }

  async getOperationRecords(request: GetOperationRecordsRequest): Promise<GetOperationRecordsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new GetOperationRecordsHeaders({ });
    return await this.getOperationRecordsWithOptions(request, headers, runtime);
  }

  async getProcessDefinitionWithOptions(request: GetProcessDefinitionRequest, tmpHeader: GetProcessDefinitionHeaders, runtime: $Util.RuntimeOptions): Promise<GetProcessDefinitionResponse> {
    Util.validateModel(request);
    let headers = new GetProcessDefinitionShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appType)) {
      body["AppType"] = request.appType;
    }

    if (!Util.isUnset(request.corpId)) {
      body["CorpId"] = request.corpId;
    }

    if (!Util.isUnset(request.groupId)) {
      body["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.language)) {
      body["Language"] = request.language;
    }

    if (!Util.isUnset(request.nameSpace)) {
      body["NameSpace"] = request.nameSpace;
    }

    if (!Util.isUnset(request.orderNumber)) {
      body["OrderNumber"] = request.orderNumber;
    }

    if (!Util.isUnset(request.processInstanceId)) {
      body["ProcessInstanceId"] = request.processInstanceId;
    }

    if (!Util.isUnset(request.systemToken)) {
      body["SystemToken"] = request.systemToken;
    }

    if (!Util.isUnset(request.systemType)) {
      body["SystemType"] = request.systemType;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetProcessDefinition",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/yida/getProcessDefinition`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetProcessDefinitionResponse>(await this.callApi(params, req, runtime), new GetProcessDefinitionResponse({}));
  }

  async getProcessDefinition(request: GetProcessDefinitionRequest): Promise<GetProcessDefinitionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new GetProcessDefinitionHeaders({ });
    return await this.getProcessDefinitionWithOptions(request, headers, runtime);
  }

  async getRangeWithOptions(tmpReq: GetRangeRequest, tmpHeader: GetRangeHeaders, runtime: $Util.RuntimeOptions): Promise<GetRangeResponse> {
    Util.validateModel(tmpReq);
    let request = new GetRangeShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new GetRangeShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.rangeAddress)) {
      body["RangeAddress"] = request.rangeAddress;
    }

    if (!Util.isUnset(request.select)) {
      body["Select"] = request.select;
    }

    if (!Util.isUnset(request.sheetId)) {
      body["SheetId"] = request.sheetId;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    if (!Util.isUnset(request.workbookId)) {
      body["WorkbookId"] = request.workbookId;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetRange",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/documents/getRange`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetRangeResponse>(await this.callApi(params, req, runtime), new GetRangeResponse({}));
  }

  async getRange(request: GetRangeRequest): Promise<GetRangeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new GetRangeHeaders({ });
    return await this.getRangeWithOptions(request, headers, runtime);
  }

  async getRelatedWorkspacesWithOptions(tmpReq: GetRelatedWorkspacesRequest, tmpHeader: GetRelatedWorkspacesHeaders, runtime: $Util.RuntimeOptions): Promise<GetRelatedWorkspacesResponse> {
    Util.validateModel(tmpReq);
    let request = new GetRelatedWorkspacesShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new GetRelatedWorkspacesShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.includeRecent)) {
      body["IncludeRecent"] = request.includeRecent;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetRelatedWorkspaces",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/documents/getRelatedWorkspaces`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetRelatedWorkspacesResponse>(await this.callApi(params, req, runtime), new GetRelatedWorkspacesResponse({}));
  }

  async getRelatedWorkspaces(request: GetRelatedWorkspacesRequest): Promise<GetRelatedWorkspacesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new GetRelatedWorkspacesHeaders({ });
    return await this.getRelatedWorkspacesWithOptions(request, headers, runtime);
  }

  async getReportTemplateByNameWithOptions(tmpReq: GetReportTemplateByNameRequest, tmpHeader: GetReportTemplateByNameHeaders, runtime: $Util.RuntimeOptions): Promise<GetReportTemplateByNameResponse> {
    Util.validateModel(tmpReq);
    let request = new GetReportTemplateByNameShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new GetReportTemplateByNameShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.templateName)) {
      body["TemplateName"] = request.templateName;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetReportTemplateByName",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/log/getReportTemplateByName`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetReportTemplateByNameResponse>(await this.callApi(params, req, runtime), new GetReportTemplateByNameResponse({}));
  }

  async getReportTemplateByName(request: GetReportTemplateByNameRequest): Promise<GetReportTemplateByNameResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new GetReportTemplateByNameHeaders({ });
    return await this.getReportTemplateByNameWithOptions(request, headers, runtime);
  }

  async getReportUnReadCountWithOptions(tmpReq: GetReportUnReadCountRequest, tmpHeader: GetReportUnReadCountHeaders, runtime: $Util.RuntimeOptions): Promise<GetReportUnReadCountResponse> {
    Util.validateModel(tmpReq);
    let request = new GetReportUnReadCountShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new GetReportUnReadCountShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.request)) {
      request.requestShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.request, "Request", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.requestShrink)) {
      body["Request"] = request.requestShrink;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetReportUnReadCount",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/log/getReportUnReadCount`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetReportUnReadCountResponse>(await this.callApi(params, req, runtime), new GetReportUnReadCountResponse({}));
  }

  async getReportUnReadCount(request: GetReportUnReadCountRequest): Promise<GetReportUnReadCountResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new GetReportUnReadCountHeaders({ });
    return await this.getReportUnReadCountWithOptions(request, headers, runtime);
  }

  async getRunningTasksWithOptions(request: GetRunningTasksRequest, tmpHeader: GetRunningTasksHeaders, runtime: $Util.RuntimeOptions): Promise<GetRunningTasksResponse> {
    Util.validateModel(request);
    let headers = new GetRunningTasksShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appType)) {
      body["AppType"] = request.appType;
    }

    if (!Util.isUnset(request.language)) {
      body["Language"] = request.language;
    }

    if (!Util.isUnset(request.processCodes)) {
      body["ProcessCodes"] = request.processCodes;
    }

    if (!Util.isUnset(request.processInstanceId)) {
      body["ProcessInstanceId"] = request.processInstanceId;
    }

    if (!Util.isUnset(request.systemToken)) {
      body["SystemToken"] = request.systemToken;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetRunningTasks",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/yida/getRunningTasks`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetRunningTasksResponse>(await this.callApi(params, req, runtime), new GetRunningTasksResponse({}));
  }

  async getRunningTasks(request: GetRunningTasksRequest): Promise<GetRunningTasksResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new GetRunningTasksHeaders({ });
    return await this.getRunningTasksWithOptions(request, headers, runtime);
  }

  async getSheetWithOptions(tmpReq: GetSheetRequest, tmpHeader: GetSheetHeaders, runtime: $Util.RuntimeOptions): Promise<GetSheetResponse> {
    Util.validateModel(tmpReq);
    let request = new GetSheetShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new GetSheetShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.sheetId)) {
      body["SheetId"] = request.sheetId;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    if (!Util.isUnset(request.workbookId)) {
      body["WorkbookId"] = request.workbookId;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetSheet",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/documents/getSheet`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetSheetResponse>(await this.callApi(params, req, runtime), new GetSheetResponse({}));
  }

  async getSheet(request: GetSheetRequest): Promise<GetSheetResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new GetSheetHeaders({ });
    return await this.getSheetWithOptions(request, headers, runtime);
  }

  async getSpaceDirectoriesWithOptions(tmpReq: GetSpaceDirectoriesRequest, tmpHeader: GetSpaceDirectoriesHeaders, runtime: $Util.RuntimeOptions): Promise<GetSpaceDirectoriesResponse> {
    Util.validateModel(tmpReq);
    let request = new GetSpaceDirectoriesShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new GetSpaceDirectoriesShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.dentryId)) {
      body["DentryId"] = request.dentryId;
    }

    if (!Util.isUnset(request.maxResults)) {
      body["MaxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.nextToken)) {
      body["NextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.spaceId)) {
      body["SpaceId"] = request.spaceId;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetSpaceDirectories",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v2/documents/getSpaceDirectories`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetSpaceDirectoriesResponse>(await this.callApi(params, req, runtime), new GetSpaceDirectoriesResponse({}));
  }

  async getSpaceDirectories(request: GetSpaceDirectoriesRequest): Promise<GetSpaceDirectoriesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new GetSpaceDirectoriesHeaders({ });
    return await this.getSpaceDirectoriesWithOptions(request, headers, runtime);
  }

  async getSubscribedCalendarWithOptions(request: GetSubscribedCalendarRequest, tmpHeader: GetSubscribedCalendarHeaders, runtime: $Util.RuntimeOptions): Promise<GetSubscribedCalendarResponse> {
    Util.validateModel(request);
    let headers = new GetSubscribedCalendarShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.calendarId)) {
      body["CalendarId"] = request.calendarId;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetSubscribedCalendar",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/calendar/getSubscribedCalendar`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetSubscribedCalendarResponse>(await this.callApi(params, req, runtime), new GetSubscribedCalendarResponse({}));
  }

  async getSubscribedCalendar(request: GetSubscribedCalendarRequest): Promise<GetSubscribedCalendarResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new GetSubscribedCalendarHeaders({ });
    return await this.getSubscribedCalendarWithOptions(request, headers, runtime);
  }

  async getTaskCopiesWithOptions(request: GetTaskCopiesRequest, tmpHeader: GetTaskCopiesHeaders, runtime: $Util.RuntimeOptions): Promise<GetTaskCopiesResponse> {
    Util.validateModel(request);
    let headers = new GetTaskCopiesShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appType)) {
      body["AppType"] = request.appType;
    }

    if (!Util.isUnset(request.createFromTimeGMT)) {
      body["CreateFromTimeGMT"] = request.createFromTimeGMT;
    }

    if (!Util.isUnset(request.createToTimeGMT)) {
      body["CreateToTimeGMT"] = request.createToTimeGMT;
    }

    if (!Util.isUnset(request.keyword)) {
      body["Keyword"] = request.keyword;
    }

    if (!Util.isUnset(request.language)) {
      body["Language"] = request.language;
    }

    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.processCodes)) {
      body["ProcessCodes"] = request.processCodes;
    }

    if (!Util.isUnset(request.systemToken)) {
      body["SystemToken"] = request.systemToken;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetTaskCopies",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/yida/getTaskCopies`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetTaskCopiesResponse>(await this.callApi(params, req, runtime), new GetTaskCopiesResponse({}));
  }

  async getTaskCopies(request: GetTaskCopiesRequest): Promise<GetTaskCopiesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new GetTaskCopiesHeaders({ });
    return await this.getTaskCopiesWithOptions(request, headers, runtime);
  }

  async getTemplateListByUserIdWithOptions(tmpReq: GetTemplateListByUserIdRequest, tmpHeader: GetTemplateListByUserIdHeaders, runtime: $Util.RuntimeOptions): Promise<GetTemplateListByUserIdResponse> {
    Util.validateModel(tmpReq);
    let request = new GetTemplateListByUserIdShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new GetTemplateListByUserIdShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.offset)) {
      body["Offset"] = request.offset;
    }

    if (!Util.isUnset(request.size)) {
      body["Size"] = request.size;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetTemplateListByUserId",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/log/getTemplateListByUserId`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetTemplateListByUserIdResponse>(await this.callApi(params, req, runtime), new GetTemplateListByUserIdResponse({}));
  }

  async getTemplateListByUserId(request: GetTemplateListByUserIdRequest): Promise<GetTemplateListByUserIdResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new GetTemplateListByUserIdHeaders({ });
    return await this.getTemplateListByUserIdWithOptions(request, headers, runtime);
  }

  async getUserWithOptions(tmpReq: GetUserRequest, tmpHeader: GetUserHeaders, runtime: $Util.RuntimeOptions): Promise<GetUserResponse> {
    Util.validateModel(tmpReq);
    let request = new GetUserShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new GetUserShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    if (!Util.isUnset(request.language)) {
      body["language"] = request.language;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetUser",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/im/getUser`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetUserResponse>(await this.callApi(params, req, runtime), new GetUserResponse({}));
  }

  async getUser(request: GetUserRequest): Promise<GetUserResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new GetUserHeaders({ });
    return await this.getUserWithOptions(request, headers, runtime);
  }

  async getUserLatestPlanWithOptions(tmpReq: GetUserLatestPlanRequest, tmpHeader: GetUserLatestPlanHeaders, runtime: $Util.RuntimeOptions): Promise<GetUserLatestPlanResponse> {
    Util.validateModel(tmpReq);
    let request = new GetUserLatestPlanShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new GetUserLatestPlanShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetUserLatestPlan",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/aliding/v1/indepding/getUserLatestPlan`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetUserLatestPlanResponse>(await this.callApi(params, req, runtime), new GetUserLatestPlanResponse({}));
  }

  async getUserLatestPlan(request: GetUserLatestPlanRequest): Promise<GetUserLatestPlanResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new GetUserLatestPlanHeaders({ });
    return await this.getUserLatestPlanWithOptions(request, headers, runtime);
  }

  async getWorkspaceWithOptions(tmpReq: GetWorkspaceRequest, tmpHeader: GetWorkspaceHeaders, runtime: $Util.RuntimeOptions): Promise<GetWorkspaceResponse> {
    Util.validateModel(tmpReq);
    let request = new GetWorkspaceShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new GetWorkspaceShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    if (!Util.isUnset(request.withPermissionRole)) {
      body["WithPermissionRole"] = request.withPermissionRole;
    }

    if (!Util.isUnset(request.workspaceId)) {
      body["WorkspaceId"] = request.workspaceId;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetWorkspace",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v2/documents/getWorkspace`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetWorkspaceResponse>(await this.callApi(params, req, runtime), new GetWorkspaceResponse({}));
  }

  async getWorkspace(request: GetWorkspaceRequest): Promise<GetWorkspaceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new GetWorkspaceHeaders({ });
    return await this.getWorkspaceWithOptions(request, headers, runtime);
  }

  async getWorkspacesWithOptions(tmpReq: GetWorkspacesRequest, tmpHeader: GetWorkspacesHeaders, runtime: $Util.RuntimeOptions): Promise<GetWorkspacesResponse> {
    Util.validateModel(tmpReq);
    let request = new GetWorkspacesShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new GetWorkspacesShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.option)) {
      request.optionShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.option, "Option", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    if (!Util.isUnset(tmpReq.workspaceIds)) {
      request.workspaceIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.workspaceIds, "WorkspaceIds", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.optionShrink)) {
      body["Option"] = request.optionShrink;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    if (!Util.isUnset(request.workspaceIdsShrink)) {
      body["WorkspaceIds"] = request.workspaceIdsShrink;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetWorkspaces",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v2/documents/getWorkspaces`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetWorkspacesResponse>(await this.callApi(params, req, runtime), new GetWorkspacesResponse({}));
  }

  async getWorkspaces(request: GetWorkspacesRequest): Promise<GetWorkspacesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new GetWorkspacesHeaders({ });
    return await this.getWorkspacesWithOptions(request, headers, runtime);
  }

  async grantHonorWithOptions(tmpReq: GrantHonorRequest, tmpHeader: GrantHonorHeaders, runtime: $Util.RuntimeOptions): Promise<GrantHonorResponse> {
    Util.validateModel(tmpReq);
    let request = new GrantHonorShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new GrantHonorShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    if (!Util.isUnset(tmpReq.openConversationIds)) {
      request.openConversationIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.openConversationIds, "openConversationIds", "json");
    }

    if (!Util.isUnset(tmpReq.receiverUserIds)) {
      request.receiverUserIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.receiverUserIds, "receiverUserIds", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    if (!Util.isUnset(request.expirationTime)) {
      body["expirationTime"] = request.expirationTime;
    }

    if (!Util.isUnset(request.grantReason)) {
      body["grantReason"] = request.grantReason;
    }

    if (!Util.isUnset(request.granterName)) {
      body["granterName"] = request.granterName;
    }

    if (!Util.isUnset(request.honorId)) {
      body["honorId"] = request.honorId;
    }

    if (!Util.isUnset(request.noticeAnnouncer)) {
      body["noticeAnnouncer"] = request.noticeAnnouncer;
    }

    if (!Util.isUnset(request.noticeSingle)) {
      body["noticeSingle"] = request.noticeSingle;
    }

    if (!Util.isUnset(request.openConversationIdsShrink)) {
      body["openConversationIds"] = request.openConversationIdsShrink;
    }

    if (!Util.isUnset(request.orgId)) {
      body["orgId"] = request.orgId;
    }

    if (!Util.isUnset(request.receiverUserIdsShrink)) {
      body["receiverUserIds"] = request.receiverUserIdsShrink;
    }

    if (!Util.isUnset(request.senderUserId)) {
      body["senderUserId"] = request.senderUserId;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GrantHonor",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/aliding/v1/honor/grantHonor`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GrantHonorResponse>(await this.callApi(params, req, runtime), new GrantHonorResponse({}));
  }

  async grantHonor(request: GrantHonorRequest): Promise<GrantHonorResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new GrantHonorHeaders({ });
    return await this.grantHonorWithOptions(request, headers, runtime);
  }

  async insertColumnsBeforeWithOptions(tmpReq: InsertColumnsBeforeRequest, tmpHeader: InsertColumnsBeforeHeaders, runtime: $Util.RuntimeOptions): Promise<InsertColumnsBeforeResponse> {
    Util.validateModel(tmpReq);
    let request = new InsertColumnsBeforeShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new InsertColumnsBeforeShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.column)) {
      body["Column"] = request.column;
    }

    if (!Util.isUnset(request.columnCount)) {
      body["ColumnCount"] = request.columnCount;
    }

    if (!Util.isUnset(request.sheetId)) {
      body["SheetId"] = request.sheetId;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    if (!Util.isUnset(request.workbookId)) {
      body["WorkbookId"] = request.workbookId;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "InsertColumnsBefore",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/documents/insertColumnsBefore`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<InsertColumnsBeforeResponse>(await this.callApi(params, req, runtime), new InsertColumnsBeforeResponse({}));
  }

  async insertColumnsBefore(request: InsertColumnsBeforeRequest): Promise<InsertColumnsBeforeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new InsertColumnsBeforeHeaders({ });
    return await this.insertColumnsBeforeWithOptions(request, headers, runtime);
  }

  async insertRowsBeforeWithOptions(tmpReq: InsertRowsBeforeRequest, tmpHeader: InsertRowsBeforeHeaders, runtime: $Util.RuntimeOptions): Promise<InsertRowsBeforeResponse> {
    Util.validateModel(tmpReq);
    let request = new InsertRowsBeforeShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new InsertRowsBeforeShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.row)) {
      body["Row"] = request.row;
    }

    if (!Util.isUnset(request.rowCount)) {
      body["RowCount"] = request.rowCount;
    }

    if (!Util.isUnset(request.sheetId)) {
      body["SheetId"] = request.sheetId;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    if (!Util.isUnset(request.workbookId)) {
      body["WorkbookId"] = request.workbookId;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "InsertRowsBefore",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/documents/insertRowsBefore`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<InsertRowsBeforeResponse>(await this.callApi(params, req, runtime), new InsertRowsBeforeResponse({}));
  }

  async insertRowsBefore(request: InsertRowsBeforeRequest): Promise<InsertRowsBeforeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new InsertRowsBeforeHeaders({ });
    return await this.insertRowsBeforeWithOptions(request, headers, runtime);
  }

  async inviteUsersWithOptions(tmpReq: InviteUsersRequest, tmpHeader: InviteUsersHeaders, runtime: $Util.RuntimeOptions): Promise<InviteUsersResponse> {
    Util.validateModel(tmpReq);
    let request = new InviteUsersShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new InviteUsersShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.inviteeList)) {
      request.inviteeListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.inviteeList, "InviteeList", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    if (!Util.isUnset(tmpReq.phoneInviteeList)) {
      request.phoneInviteeListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.phoneInviteeList, "phoneInviteeList", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.inviteeListShrink)) {
      body["InviteeList"] = request.inviteeListShrink;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    if (!Util.isUnset(request.conferenceId)) {
      body["conferenceId"] = request.conferenceId;
    }

    if (!Util.isUnset(request.phoneInviteeListShrink)) {
      body["phoneInviteeList"] = request.phoneInviteeListShrink;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "InviteUsers",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/ysp/inviteUsers`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<InviteUsersResponse>(await this.callApi(params, req, runtime), new InviteUsersResponse({}));
  }

  async inviteUsers(request: InviteUsersRequest): Promise<InviteUsersResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new InviteUsersHeaders({ });
    return await this.inviteUsersWithOptions(request, headers, runtime);
  }

  async listApplicationWithOptions(request: ListApplicationRequest, tmpHeader: ListApplicationHeaders, runtime: $Util.RuntimeOptions): Promise<ListApplicationResponse> {
    Util.validateModel(request);
    let headers = new ListApplicationShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appFilter)) {
      body["AppFilter"] = request.appFilter;
    }

    if (!Util.isUnset(request.appNameSearchKeyword)) {
      body["AppNameSearchKeyword"] = request.appNameSearchKeyword;
    }

    if (!Util.isUnset(request.corpId)) {
      body["CorpId"] = request.corpId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.token)) {
      body["Token"] = request.token;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ListApplication",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/yida/listApplication`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListApplicationResponse>(await this.callApi(params, req, runtime), new ListApplicationResponse({}));
  }

  async listApplication(request: ListApplicationRequest): Promise<ListApplicationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new ListApplicationHeaders({ });
    return await this.listApplicationWithOptions(request, headers, runtime);
  }

  async listCalendarsWithOptions(tmpReq: ListCalendarsRequest, tmpHeader: ListCalendarsHeaders, runtime: $Util.RuntimeOptions): Promise<ListCalendarsResponse> {
    Util.validateModel(tmpReq);
    let request = new ListCalendarsShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new ListCalendarsShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.request)) {
      request.requestShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.request, "Request", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.requestShrink)) {
      body["Request"] = request.requestShrink;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ListCalendars",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/calendar/listCalendars`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListCalendarsResponse>(await this.callApi(params, req, runtime), new ListCalendarsResponse({}));
  }

  async listCalendars(request: ListCalendarsRequest): Promise<ListCalendarsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new ListCalendarsHeaders({ });
    return await this.listCalendarsWithOptions(request, headers, runtime);
  }

  async listDentriesWithOptions(tmpReq: ListDentriesRequest, tmpHeader: ListDentriesHeaders, runtime: $Util.RuntimeOptions): Promise<ListDentriesResponse> {
    Util.validateModel(tmpReq);
    let request = new ListDentriesShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new ListDentriesShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.maxResults)) {
      body["MaxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.nextToken)) {
      body["NextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.order)) {
      body["Order"] = request.order;
    }

    if (!Util.isUnset(request.orderBy)) {
      body["OrderBy"] = request.orderBy;
    }

    if (!Util.isUnset(request.parentId)) {
      body["ParentId"] = request.parentId;
    }

    if (!Util.isUnset(request.spaceId)) {
      body["SpaceId"] = request.spaceId;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    if (!Util.isUnset(request.withThumbnail)) {
      body["WithThumbnail"] = request.withThumbnail;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ListDentries",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/documents/listDentries`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListDentriesResponse>(await this.callApi(params, req, runtime), new ListDentriesResponse({}));
  }

  async listDentries(request: ListDentriesRequest): Promise<ListDentriesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new ListDentriesHeaders({ });
    return await this.listDentriesWithOptions(request, headers, runtime);
  }

  async listEventsWithOptions(request: ListEventsRequest, tmpHeader: ListEventsHeaders, runtime: $Util.RuntimeOptions): Promise<ListEventsResponse> {
    Util.validateModel(request);
    let headers = new ListEventsShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.calendarId)) {
      body["CalendarId"] = request.calendarId;
    }

    if (!Util.isUnset(request.maxAttendees)) {
      body["MaxAttendees"] = request.maxAttendees;
    }

    if (!Util.isUnset(request.maxResults)) {
      body["MaxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.nextToken)) {
      body["NextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.seriesMasterId)) {
      body["SeriesMasterId"] = request.seriesMasterId;
    }

    if (!Util.isUnset(request.showDeleted)) {
      body["ShowDeleted"] = request.showDeleted;
    }

    if (!Util.isUnset(request.syncToken)) {
      body["SyncToken"] = request.syncToken;
    }

    if (!Util.isUnset(request.timeMax)) {
      body["TimeMax"] = request.timeMax;
    }

    if (!Util.isUnset(request.timeMin)) {
      body["TimeMin"] = request.timeMin;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ListEvents",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/calendar/listEvents`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListEventsResponse>(await this.callApi(params, req, runtime), new ListEventsResponse({}));
  }

  async listEvents(request: ListEventsRequest): Promise<ListEventsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new ListEventsHeaders({ });
    return await this.listEventsWithOptions(request, headers, runtime);
  }

  async listEventsViewWithOptions(request: ListEventsViewRequest, tmpHeader: ListEventsViewHeaders, runtime: $Util.RuntimeOptions): Promise<ListEventsViewResponse> {
    Util.validateModel(request);
    let headers = new ListEventsViewShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.calendarId)) {
      body["CalendarId"] = request.calendarId;
    }

    if (!Util.isUnset(request.maxAttendees)) {
      body["MaxAttendees"] = request.maxAttendees;
    }

    if (!Util.isUnset(request.maxResults)) {
      body["MaxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.nextToken)) {
      body["NextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.timeMax)) {
      body["TimeMax"] = request.timeMax;
    }

    if (!Util.isUnset(request.timeMin)) {
      body["TimeMin"] = request.timeMin;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ListEventsView",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/calendar/listEventsView`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListEventsViewResponse>(await this.callApi(params, req, runtime), new ListEventsViewResponse({}));
  }

  async listEventsView(request: ListEventsViewRequest): Promise<ListEventsViewResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new ListEventsViewHeaders({ });
    return await this.listEventsViewWithOptions(request, headers, runtime);
  }

  async listFormRemarksWithOptions(tmpReq: ListFormRemarksRequest, tmpHeader: ListFormRemarksHeaders, runtime: $Util.RuntimeOptions): Promise<ListFormRemarksResponse> {
    Util.validateModel(tmpReq);
    let request = new ListFormRemarksShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new ListFormRemarksShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.formInstanceIdList)) {
      request.formInstanceIdListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.formInstanceIdList, "FormInstanceIdList", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appType)) {
      body["AppType"] = request.appType;
    }

    if (!Util.isUnset(request.formInstanceIdListShrink)) {
      body["FormInstanceIdList"] = request.formInstanceIdListShrink;
    }

    if (!Util.isUnset(request.formUuid)) {
      body["FormUuid"] = request.formUuid;
    }

    if (!Util.isUnset(request.systemToken)) {
      body["SystemToken"] = request.systemToken;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ListFormRemarks",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/yida/listFormRemarks`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListFormRemarksResponse>(await this.callApi(params, req, runtime), new ListFormRemarksResponse({}));
  }

  async listFormRemarks(request: ListFormRemarksRequest): Promise<ListFormRemarksResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new ListFormRemarksHeaders({ });
    return await this.listFormRemarksWithOptions(request, headers, runtime);
  }

  async listNavigationByFormTypeWithOptions(request: ListNavigationByFormTypeRequest, tmpHeader: ListNavigationByFormTypeHeaders, runtime: $Util.RuntimeOptions): Promise<ListNavigationByFormTypeResponse> {
    Util.validateModel(request);
    let headers = new ListNavigationByFormTypeShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appType)) {
      body["AppType"] = request.appType;
    }

    if (!Util.isUnset(request.formType)) {
      body["FormType"] = request.formType;
    }

    if (!Util.isUnset(request.language)) {
      body["Language"] = request.language;
    }

    if (!Util.isUnset(request.systemToken)) {
      body["SystemToken"] = request.systemToken;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ListNavigationByFormType",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/yida/listNavigationByFormType`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListNavigationByFormTypeResponse>(await this.callApi(params, req, runtime), new ListNavigationByFormTypeResponse({}));
  }

  async listNavigationByFormType(request: ListNavigationByFormTypeRequest): Promise<ListNavigationByFormTypeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new ListNavigationByFormTypeHeaders({ });
    return await this.listNavigationByFormTypeWithOptions(request, headers, runtime);
  }

  async listNodesWithOptions(tmpReq: ListNodesRequest, tmpHeader: ListNodesHeaders, runtime: $Util.RuntimeOptions): Promise<ListNodesResponse> {
    Util.validateModel(tmpReq);
    let request = new ListNodesShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new ListNodesShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.maxResults)) {
      body["MaxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.nextToken)) {
      body["NextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.parentNodeId)) {
      body["ParentNodeId"] = request.parentNodeId;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    if (!Util.isUnset(request.withPermissionRole)) {
      body["WithPermissionRole"] = request.withPermissionRole;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ListNodes",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v2/documents/listNodes`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListNodesResponse>(await this.callApi(params, req, runtime), new ListNodesResponse({}));
  }

  async listNodes(request: ListNodesRequest): Promise<ListNodesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new ListNodesHeaders({ });
    return await this.listNodesWithOptions(request, headers, runtime);
  }

  async listReportWithOptions(tmpReq: ListReportRequest, tmpHeader: ListReportHeaders, runtime: $Util.RuntimeOptions): Promise<ListReportResponse> {
    Util.validateModel(tmpReq);
    let request = new ListReportShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new ListReportShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.cursor)) {
      body["Cursor"] = request.cursor;
    }

    if (!Util.isUnset(request.endTime)) {
      body["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.modifiedEndTime)) {
      body["ModifiedEndTime"] = request.modifiedEndTime;
    }

    if (!Util.isUnset(request.modifiedStartTime)) {
      body["ModifiedStartTime"] = request.modifiedStartTime;
    }

    if (!Util.isUnset(request.size)) {
      body["Size"] = request.size;
    }

    if (!Util.isUnset(request.startTime)) {
      body["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.templateName)) {
      body["TemplateName"] = request.templateName;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ListReport",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/log/listReport`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListReportResponse>(await this.callApi(params, req, runtime), new ListReportResponse({}));
  }

  async listReport(request: ListReportRequest): Promise<ListReportResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new ListReportHeaders({ });
    return await this.listReportWithOptions(request, headers, runtime);
  }

  async listTableDataByFormInstanceIdTableIdWithOptions(request: ListTableDataByFormInstanceIdTableIdRequest, tmpHeader: ListTableDataByFormInstanceIdTableIdHeaders, runtime: $Util.RuntimeOptions): Promise<ListTableDataByFormInstanceIdTableIdResponse> {
    Util.validateModel(request);
    let headers = new ListTableDataByFormInstanceIdTableIdShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appType)) {
      body["AppType"] = request.appType;
    }

    if (!Util.isUnset(request.formInstanceId)) {
      body["FormInstanceId"] = request.formInstanceId;
    }

    if (!Util.isUnset(request.formUuid)) {
      body["FormUuid"] = request.formUuid;
    }

    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.systemToken)) {
      body["SystemToken"] = request.systemToken;
    }

    if (!Util.isUnset(request.tableFieldId)) {
      body["TableFieldId"] = request.tableFieldId;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ListTableDataByFormInstanceIdTableId",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/yida/listTableDataByFormInstanceIdTableId`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListTableDataByFormInstanceIdTableIdResponse>(await this.callApi(params, req, runtime), new ListTableDataByFormInstanceIdTableIdResponse({}));
  }

  async listTableDataByFormInstanceIdTableId(request: ListTableDataByFormInstanceIdTableIdRequest): Promise<ListTableDataByFormInstanceIdTableIdResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new ListTableDataByFormInstanceIdTableIdHeaders({ });
    return await this.listTableDataByFormInstanceIdTableIdWithOptions(request, headers, runtime);
  }

  async listTeamsWithOptions(tmpReq: ListTeamsRequest, tmpHeader: ListTeamsHeaders, runtime: $Util.RuntimeOptions): Promise<ListTeamsResponse> {
    Util.validateModel(tmpReq);
    let request = new ListTeamsShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new ListTeamsShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.maxResults)) {
      body["MaxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.nextToken)) {
      body["NextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ListTeams",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v2/documents/listTeams`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListTeamsResponse>(await this.callApi(params, req, runtime), new ListTeamsResponse({}));
  }

  async listTeams(request: ListTeamsRequest): Promise<ListTeamsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new ListTeamsHeaders({ });
    return await this.listTeamsWithOptions(request, headers, runtime);
  }

  async listWorkspacesWithOptions(tmpReq: ListWorkspacesRequest, tmpHeader: ListWorkspacesHeaders, runtime: $Util.RuntimeOptions): Promise<ListWorkspacesResponse> {
    Util.validateModel(tmpReq);
    let request = new ListWorkspacesShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new ListWorkspacesShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.maxResults)) {
      body["MaxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.nextToken)) {
      body["NextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.orderBy)) {
      body["OrderBy"] = request.orderBy;
    }

    if (!Util.isUnset(request.teamId)) {
      body["TeamId"] = request.teamId;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    if (!Util.isUnset(request.withPermissionRole)) {
      body["WithPermissionRole"] = request.withPermissionRole;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ListWorkspaces",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v2/documents/listWorkspaces`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListWorkspacesResponse>(await this.callApi(params, req, runtime), new ListWorkspacesResponse({}));
  }

  async listWorkspaces(request: ListWorkspacesRequest): Promise<ListWorkspacesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new ListWorkspacesHeaders({ });
    return await this.listWorkspacesWithOptions(request, headers, runtime);
  }

  async patchEventWithOptions(tmpReq: PatchEventRequest, tmpHeader: PatchEventHeaders, runtime: $Util.RuntimeOptions): Promise<PatchEventResponse> {
    Util.validateModel(tmpReq);
    let request = new PatchEventShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new PatchEventShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.attendees)) {
      request.attendeesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.attendees, "Attendees", "json");
    }

    if (!Util.isUnset(tmpReq.end)) {
      request.endShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.end, "End", "json");
    }

    if (!Util.isUnset(tmpReq.extra)) {
      request.extraShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.extra, "Extra", "json");
    }

    if (!Util.isUnset(tmpReq.location)) {
      request.locationShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.location, "Location", "json");
    }

    if (!Util.isUnset(tmpReq.recurrence)) {
      request.recurrenceShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.recurrence, "Recurrence", "json");
    }

    if (!Util.isUnset(tmpReq.reminders)) {
      request.remindersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.reminders, "Reminders", "json");
    }

    if (!Util.isUnset(tmpReq.start)) {
      request.startShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.start, "Start", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.attendeesShrink)) {
      body["Attendees"] = request.attendeesShrink;
    }

    if (!Util.isUnset(request.calendarId)) {
      body["CalendarId"] = request.calendarId;
    }

    if (!Util.isUnset(request.description)) {
      body["Description"] = request.description;
    }

    if (!Util.isUnset(request.endShrink)) {
      body["End"] = request.endShrink;
    }

    if (!Util.isUnset(request.eventId)) {
      body["EventId"] = request.eventId;
    }

    if (!Util.isUnset(request.extraShrink)) {
      body["Extra"] = request.extraShrink;
    }

    if (!Util.isUnset(request.isAllDay)) {
      body["IsAllDay"] = request.isAllDay;
    }

    if (!Util.isUnset(request.locationShrink)) {
      body["Location"] = request.locationShrink;
    }

    if (!Util.isUnset(request.recurrenceShrink)) {
      body["Recurrence"] = request.recurrenceShrink;
    }

    if (!Util.isUnset(request.remindersShrink)) {
      body["Reminders"] = request.remindersShrink;
    }

    if (!Util.isUnset(request.startShrink)) {
      body["Start"] = request.startShrink;
    }

    if (!Util.isUnset(request.summary)) {
      body["Summary"] = request.summary;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "PatchEvent",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/calendar/patchEvent`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<PatchEventResponse>(await this.callApi(params, req, runtime), new PatchEventResponse({}));
  }

  async patchEvent(request: PatchEventRequest): Promise<PatchEventResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new PatchEventHeaders({ });
    return await this.patchEventWithOptions(request, headers, runtime);
  }

  async queryCloudRecordTextWithOptions(tmpReq: QueryCloudRecordTextRequest, tmpHeader: QueryCloudRecordTextHeaders, runtime: $Util.RuntimeOptions): Promise<QueryCloudRecordTextResponse> {
    Util.validateModel(tmpReq);
    let request = new QueryCloudRecordTextShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new QueryCloudRecordTextShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.direction)) {
      body["Direction"] = request.direction;
    }

    if (!Util.isUnset(request.maxResults)) {
      body["MaxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.nextToken)) {
      body["NextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.startTime)) {
      body["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    if (!Util.isUnset(request.conferenceId)) {
      body["conferenceId"] = request.conferenceId;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "QueryCloudRecordText",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/ysp/queryCloudRecordText`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryCloudRecordTextResponse>(await this.callApi(params, req, runtime), new QueryCloudRecordTextResponse({}));
  }

  async queryCloudRecordText(request: QueryCloudRecordTextRequest): Promise<QueryCloudRecordTextResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new QueryCloudRecordTextHeaders({ });
    return await this.queryCloudRecordTextWithOptions(request, headers, runtime);
  }

  async queryCloudRecordVideoWithOptions(tmpReq: QueryCloudRecordVideoRequest, tmpHeader: QueryCloudRecordVideoHeaders, runtime: $Util.RuntimeOptions): Promise<QueryCloudRecordVideoResponse> {
    Util.validateModel(tmpReq);
    let request = new QueryCloudRecordVideoShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new QueryCloudRecordVideoShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    if (!Util.isUnset(request.conferenceId)) {
      body["conferenceId"] = request.conferenceId;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "QueryCloudRecordVideo",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/ysp/queryCloudRecordVideo`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryCloudRecordVideoResponse>(await this.callApi(params, req, runtime), new QueryCloudRecordVideoResponse({}));
  }

  async queryCloudRecordVideo(request: QueryCloudRecordVideoRequest): Promise<QueryCloudRecordVideoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new QueryCloudRecordVideoHeaders({ });
    return await this.queryCloudRecordVideoWithOptions(request, headers, runtime);
  }

  async queryCloudRecordVideoPlayInfoWithOptions(tmpReq: QueryCloudRecordVideoPlayInfoRequest, tmpHeader: QueryCloudRecordVideoPlayInfoHeaders, runtime: $Util.RuntimeOptions): Promise<QueryCloudRecordVideoPlayInfoResponse> {
    Util.validateModel(tmpReq);
    let request = new QueryCloudRecordVideoPlayInfoShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new QueryCloudRecordVideoPlayInfoShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.conferenceId)) {
      body["ConferenceId"] = request.conferenceId;
    }

    if (!Util.isUnset(request.mediaId)) {
      body["MediaId"] = request.mediaId;
    }

    if (!Util.isUnset(request.regionId)) {
      body["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "QueryCloudRecordVideoPlayInfo",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/ysp/queryCloudRecordVideoPlayInfo`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryCloudRecordVideoPlayInfoResponse>(await this.callApi(params, req, runtime), new QueryCloudRecordVideoPlayInfoResponse({}));
  }

  async queryCloudRecordVideoPlayInfo(request: QueryCloudRecordVideoPlayInfoRequest): Promise<QueryCloudRecordVideoPlayInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new QueryCloudRecordVideoPlayInfoHeaders({ });
    return await this.queryCloudRecordVideoPlayInfoWithOptions(request, headers, runtime);
  }

  async queryConferenceInfoWithOptions(request: QueryConferenceInfoRequest, tmpHeader: QueryConferenceInfoHeaders, runtime: $Util.RuntimeOptions): Promise<QueryConferenceInfoResponse> {
    Util.validateModel(request);
    let headers = new QueryConferenceInfoShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.conferenceId)) {
      body["conferenceId"] = request.conferenceId;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "QueryConferenceInfo",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/ysp/queryConferenceInfo`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryConferenceInfoResponse>(await this.callApi(params, req, runtime), new QueryConferenceInfoResponse({}));
  }

  async queryConferenceInfo(request: QueryConferenceInfoRequest): Promise<QueryConferenceInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new QueryConferenceInfoHeaders({ });
    return await this.queryConferenceInfoWithOptions(request, headers, runtime);
  }

  async queryConferenceMembersWithOptions(tmpReq: QueryConferenceMembersRequest, tmpHeader: QueryConferenceMembersHeaders, runtime: $Util.RuntimeOptions): Promise<QueryConferenceMembersResponse> {
    Util.validateModel(tmpReq);
    let request = new QueryConferenceMembersShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new QueryConferenceMembersShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.maxResults)) {
      body["MaxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.nextToken)) {
      body["NextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    if (!Util.isUnset(request.conferenceId)) {
      body["conferenceId"] = request.conferenceId;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "QueryConferenceMembers",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/ysp/queryConferenceMembers`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryConferenceMembersResponse>(await this.callApi(params, req, runtime), new QueryConferenceMembersResponse({}));
  }

  async queryConferenceMembers(request: QueryConferenceMembersRequest): Promise<QueryConferenceMembersResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new QueryConferenceMembersHeaders({ });
    return await this.queryConferenceMembersWithOptions(request, headers, runtime);
  }

  async queryDentryWithOptions(tmpReq: QueryDentryRequest, tmpHeader: QueryDentryHeaders, runtime: $Util.RuntimeOptions): Promise<QueryDentryResponse> {
    Util.validateModel(tmpReq);
    let request = new QueryDentryShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new QueryDentryShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.dentryId)) {
      body["DentryId"] = request.dentryId;
    }

    if (!Util.isUnset(request.includeSpace)) {
      body["IncludeSpace"] = request.includeSpace;
    }

    if (!Util.isUnset(request.spaceId)) {
      body["SpaceId"] = request.spaceId;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "QueryDentry",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v2/documents/queryDentry`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryDentryResponse>(await this.callApi(params, req, runtime), new QueryDentryResponse({}));
  }

  async queryDentry(request: QueryDentryRequest): Promise<QueryDentryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new QueryDentryHeaders({ });
    return await this.queryDentryWithOptions(request, headers, runtime);
  }

  async queryLiveInfoWithOptions(tmpReq: QueryLiveInfoRequest, tmpHeader: QueryLiveInfoHeaders, runtime: $Util.RuntimeOptions): Promise<QueryLiveInfoResponse> {
    Util.validateModel(tmpReq);
    let request = new QueryLiveInfoShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new QueryLiveInfoShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.liveId)) {
      body["LiveId"] = request.liveId;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "QueryLiveInfo",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/ysp/queryLiveInfo`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryLiveInfoResponse>(await this.callApi(params, req, runtime), new QueryLiveInfoResponse({}));
  }

  async queryLiveInfo(request: QueryLiveInfoRequest): Promise<QueryLiveInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new QueryLiveInfoHeaders({ });
    return await this.queryLiveInfoWithOptions(request, headers, runtime);
  }

  async queryLiveWatchDetailWithOptions(tmpReq: QueryLiveWatchDetailRequest, tmpHeader: QueryLiveWatchDetailHeaders, runtime: $Util.RuntimeOptions): Promise<QueryLiveWatchDetailResponse> {
    Util.validateModel(tmpReq);
    let request = new QueryLiveWatchDetailShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new QueryLiveWatchDetailShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.liveId)) {
      body["LiveId"] = request.liveId;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "QueryLiveWatchDetail",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/ysp/queryLiveWatchDetail`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryLiveWatchDetailResponse>(await this.callApi(params, req, runtime), new QueryLiveWatchDetailResponse({}));
  }

  async queryLiveWatchDetail(request: QueryLiveWatchDetailRequest): Promise<QueryLiveWatchDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new QueryLiveWatchDetailHeaders({ });
    return await this.queryLiveWatchDetailWithOptions(request, headers, runtime);
  }

  async queryLiveWatchUserListWithOptions(tmpReq: QueryLiveWatchUserListRequest, tmpHeader: QueryLiveWatchUserListHeaders, runtime: $Util.RuntimeOptions): Promise<QueryLiveWatchUserListResponse> {
    Util.validateModel(tmpReq);
    let request = new QueryLiveWatchUserListShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new QueryLiveWatchUserListShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.liveId)) {
      body["LiveId"] = request.liveId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "QueryLiveWatchUserList",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/ysp/queryLiveWatchUserList`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryLiveWatchUserListResponse>(await this.callApi(params, req, runtime), new QueryLiveWatchUserListResponse({}));
  }

  async queryLiveWatchUserList(request: QueryLiveWatchUserListRequest): Promise<QueryLiveWatchUserListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new QueryLiveWatchUserListHeaders({ });
    return await this.queryLiveWatchUserListWithOptions(request, headers, runtime);
  }

  async queryMeetingRoomWithOptions(tmpReq: QueryMeetingRoomRequest, tmpHeader: QueryMeetingRoomHeaders, runtime: $Util.RuntimeOptions): Promise<QueryMeetingRoomResponse> {
    Util.validateModel(tmpReq);
    let request = new QueryMeetingRoomShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new QueryMeetingRoomShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.roomId)) {
      body["RoomId"] = request.roomId;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "QueryMeetingRoom",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/ysp/queryMeetingRoom`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryMeetingRoomResponse>(await this.callApi(params, req, runtime), new QueryMeetingRoomResponse({}));
  }

  async queryMeetingRoom(request: QueryMeetingRoomRequest): Promise<QueryMeetingRoomResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new QueryMeetingRoomHeaders({ });
    return await this.queryMeetingRoomWithOptions(request, headers, runtime);
  }

  async queryMeetingRoomGroupWithOptions(tmpReq: QueryMeetingRoomGroupRequest, tmpHeader: QueryMeetingRoomGroupHeaders, runtime: $Util.RuntimeOptions): Promise<QueryMeetingRoomGroupResponse> {
    Util.validateModel(tmpReq);
    let request = new QueryMeetingRoomGroupShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new QueryMeetingRoomGroupShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.groupId)) {
      body["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "QueryMeetingRoomGroup",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/ysp/queryMeetingRoomGroup`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryMeetingRoomGroupResponse>(await this.callApi(params, req, runtime), new QueryMeetingRoomGroupResponse({}));
  }

  async queryMeetingRoomGroup(request: QueryMeetingRoomGroupRequest): Promise<QueryMeetingRoomGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new QueryMeetingRoomGroupHeaders({ });
    return await this.queryMeetingRoomGroupWithOptions(request, headers, runtime);
  }

  async queryMeetingRoomGroupListWithOptions(tmpReq: QueryMeetingRoomGroupListRequest, tmpHeader: QueryMeetingRoomGroupListHeaders, runtime: $Util.RuntimeOptions): Promise<QueryMeetingRoomGroupListResponse> {
    Util.validateModel(tmpReq);
    let request = new QueryMeetingRoomGroupListShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new QueryMeetingRoomGroupListShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.request)) {
      request.requestShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.request, "Request", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.requestShrink)) {
      body["Request"] = request.requestShrink;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "QueryMeetingRoomGroupList",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/ysp/queryMeetingRoomGroupList`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryMeetingRoomGroupListResponse>(await this.callApi(params, req, runtime), new QueryMeetingRoomGroupListResponse({}));
  }

  async queryMeetingRoomGroupList(request: QueryMeetingRoomGroupListRequest): Promise<QueryMeetingRoomGroupListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new QueryMeetingRoomGroupListHeaders({ });
    return await this.queryMeetingRoomGroupListWithOptions(request, headers, runtime);
  }

  async queryMeetingRoomListWithOptions(tmpReq: QueryMeetingRoomListRequest, tmpHeader: QueryMeetingRoomListHeaders, runtime: $Util.RuntimeOptions): Promise<QueryMeetingRoomListResponse> {
    Util.validateModel(tmpReq);
    let request = new QueryMeetingRoomListShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new QueryMeetingRoomListShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.maxResults)) {
      body["MaxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.nextToken)) {
      body["NextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "QueryMeetingRoomList",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/ysp/queryMeetingRoomList`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryMeetingRoomListResponse>(await this.callApi(params, req, runtime), new QueryMeetingRoomListResponse({}));
  }

  async queryMeetingRoomList(request: QueryMeetingRoomListRequest): Promise<QueryMeetingRoomListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new QueryMeetingRoomListHeaders({ });
    return await this.queryMeetingRoomListWithOptions(request, headers, runtime);
  }

  async queryOrgHonorsWithOptions(tmpReq: QueryOrgHonorsRequest, tmpHeader: QueryOrgHonorsHeaders, runtime: $Util.RuntimeOptions): Promise<QueryOrgHonorsResponse> {
    Util.validateModel(tmpReq);
    let request = new QueryOrgHonorsShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new QueryOrgHonorsShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    if (!Util.isUnset(request.maxResults)) {
      body["maxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.nextToken)) {
      body["nextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.orgId)) {
      body["orgId"] = request.orgId;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "QueryOrgHonors",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/aliding/v1/honor/queryOrgHonors`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryOrgHonorsResponse>(await this.callApi(params, req, runtime), new QueryOrgHonorsResponse({}));
  }

  async queryOrgHonors(request: QueryOrgHonorsRequest): Promise<QueryOrgHonorsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new QueryOrgHonorsHeaders({ });
    return await this.queryOrgHonorsWithOptions(request, headers, runtime);
  }

  async queryOrgTodoTasksWithOptions(tmpReq: QueryOrgTodoTasksRequest, tmpHeader: QueryOrgTodoTasksHeaders, runtime: $Util.RuntimeOptions): Promise<QueryOrgTodoTasksResponse> {
    Util.validateModel(tmpReq);
    let request = new QueryOrgTodoTasksShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new QueryOrgTodoTasksShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    if (!Util.isUnset(request.isDone)) {
      body["isDone"] = request.isDone;
    }

    if (!Util.isUnset(request.nextToken)) {
      body["nextToken"] = request.nextToken;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "QueryOrgTodoTasks",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/task/queryOrgTodoTasks`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryOrgTodoTasksResponse>(await this.callApi(params, req, runtime), new QueryOrgTodoTasksResponse({}));
  }

  async queryOrgTodoTasks(request: QueryOrgTodoTasksRequest): Promise<QueryOrgTodoTasksResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new QueryOrgTodoTasksHeaders({ });
    return await this.queryOrgTodoTasksWithOptions(request, headers, runtime);
  }

  async queryScheduleConferenceWithOptions(tmpReq: QueryScheduleConferenceRequest, tmpHeader: QueryScheduleConferenceHeaders, runtime: $Util.RuntimeOptions): Promise<QueryScheduleConferenceResponse> {
    Util.validateModel(tmpReq);
    let request = new QueryScheduleConferenceShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new QueryScheduleConferenceShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    if (!Util.isUnset(request.scheduleConferenceId)) {
      body["scheduleConferenceId"] = request.scheduleConferenceId;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "QueryScheduleConference",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/ysp/queryScheduleConference`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryScheduleConferenceResponse>(await this.callApi(params, req, runtime), new QueryScheduleConferenceResponse({}));
  }

  async queryScheduleConference(request: QueryScheduleConferenceRequest): Promise<QueryScheduleConferenceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new QueryScheduleConferenceHeaders({ });
    return await this.queryScheduleConferenceWithOptions(request, headers, runtime);
  }

  async queryUserHonorsWithOptions(tmpReq: QueryUserHonorsRequest, tmpHeader: QueryUserHonorsHeaders, runtime: $Util.RuntimeOptions): Promise<QueryUserHonorsResponse> {
    Util.validateModel(tmpReq);
    let request = new QueryUserHonorsShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new QueryUserHonorsShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    if (!Util.isUnset(request.maxResults)) {
      body["maxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.nextToken)) {
      body["nextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.orgId)) {
      body["orgId"] = request.orgId;
    }

    if (!Util.isUnset(request.userId)) {
      body["userId"] = request.userId;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "QueryUserHonors",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/aliding/v1/honor/queryUserHonors`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryUserHonorsResponse>(await this.callApi(params, req, runtime), new QueryUserHonorsResponse({}));
  }

  async queryUserHonors(request: QueryUserHonorsRequest): Promise<QueryUserHonorsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new QueryUserHonorsHeaders({ });
    return await this.queryUserHonorsWithOptions(request, headers, runtime);
  }

  async recallHonorWithOptions(tmpReq: RecallHonorRequest, tmpHeader: RecallHonorHeaders, runtime: $Util.RuntimeOptions): Promise<RecallHonorResponse> {
    Util.validateModel(tmpReq);
    let request = new RecallHonorShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new RecallHonorShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    if (!Util.isUnset(request.honorId)) {
      body["honorId"] = request.honorId;
    }

    if (!Util.isUnset(request.orgId)) {
      body["orgId"] = request.orgId;
    }

    if (!Util.isUnset(request.userId)) {
      body["userId"] = request.userId;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "RecallHonor",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/aliding/v1/honor/recallHonor`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RecallHonorResponse>(await this.callApi(params, req, runtime), new RecallHonorResponse({}));
  }

  async recallHonor(request: RecallHonorRequest): Promise<RecallHonorResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new RecallHonorHeaders({ });
    return await this.recallHonorWithOptions(request, headers, runtime);
  }

  async receiverListReportWithOptions(tmpReq: ReceiverListReportRequest, tmpHeader: ReceiverListReportHeaders, runtime: $Util.RuntimeOptions): Promise<ReceiverListReportResponse> {
    Util.validateModel(tmpReq);
    let request = new ReceiverListReportShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new ReceiverListReportShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.offset)) {
      body["Offset"] = request.offset;
    }

    if (!Util.isUnset(request.reportId)) {
      body["ReportId"] = request.reportId;
    }

    if (!Util.isUnset(request.size)) {
      body["Size"] = request.size;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ReceiverListReport",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/log/receiverListReport`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ReceiverListReportResponse>(await this.callApi(params, req, runtime), new ReceiverListReportResponse({}));
  }

  async receiverListReport(request: ReceiverListReportRequest): Promise<ReceiverListReportResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new ReceiverListReportHeaders({ });
    return await this.receiverListReportWithOptions(request, headers, runtime);
  }

  async redirectTaskWithOptions(request: RedirectTaskRequest, tmpHeader: RedirectTaskHeaders, runtime: $Util.RuntimeOptions): Promise<RedirectTaskResponse> {
    Util.validateModel(request);
    let headers = new RedirectTaskShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appType)) {
      body["AppType"] = request.appType;
    }

    if (!Util.isUnset(request.byManager)) {
      body["ByManager"] = request.byManager;
    }

    if (!Util.isUnset(request.language)) {
      body["Language"] = request.language;
    }

    if (!Util.isUnset(request.nowActionExecutorId)) {
      body["NowActionExecutorId"] = request.nowActionExecutorId;
    }

    if (!Util.isUnset(request.processInstanceId)) {
      body["ProcessInstanceId"] = request.processInstanceId;
    }

    if (!Util.isUnset(request.remark)) {
      body["Remark"] = request.remark;
    }

    if (!Util.isUnset(request.systemToken)) {
      body["SystemToken"] = request.systemToken;
    }

    if (!Util.isUnset(request.taskId)) {
      body["TaskId"] = request.taskId;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "RedirectTask",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/yida/redirectTask`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RedirectTaskResponse>(await this.callApi(params, req, runtime), new RedirectTaskResponse({}));
  }

  async redirectTask(request: RedirectTaskRequest): Promise<RedirectTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new RedirectTaskHeaders({ });
    return await this.redirectTaskWithOptions(request, headers, runtime);
  }

  async removeAttendeeWithOptions(tmpReq: RemoveAttendeeRequest, tmpHeader: RemoveAttendeeHeaders, runtime: $Util.RuntimeOptions): Promise<RemoveAttendeeResponse> {
    Util.validateModel(tmpReq);
    let request = new RemoveAttendeeShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new RemoveAttendeeShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.attendeesToRemove)) {
      request.attendeesToRemoveShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.attendeesToRemove, "AttendeesToRemove", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.attendeesToRemoveShrink)) {
      body["AttendeesToRemove"] = request.attendeesToRemoveShrink;
    }

    if (!Util.isUnset(request.calendarId)) {
      body["CalendarId"] = request.calendarId;
    }

    if (!Util.isUnset(request.eventId)) {
      body["EventId"] = request.eventId;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "RemoveAttendee",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/calendar/removeAttendee`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RemoveAttendeeResponse>(await this.callApi(params, req, runtime), new RemoveAttendeeResponse({}));
  }

  async removeAttendee(request: RemoveAttendeeRequest): Promise<RemoveAttendeeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new RemoveAttendeeHeaders({ });
    return await this.removeAttendeeWithOptions(request, headers, runtime);
  }

  async removeMeetingRoomsWithOptions(tmpReq: RemoveMeetingRoomsRequest, tmpHeader: RemoveMeetingRoomsHeaders, runtime: $Util.RuntimeOptions): Promise<RemoveMeetingRoomsResponse> {
    Util.validateModel(tmpReq);
    let request = new RemoveMeetingRoomsShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new RemoveMeetingRoomsShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.meetingRoomsToRemove)) {
      request.meetingRoomsToRemoveShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.meetingRoomsToRemove, "MeetingRoomsToRemove", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.calendarId)) {
      body["CalendarId"] = request.calendarId;
    }

    if (!Util.isUnset(request.eventId)) {
      body["EventId"] = request.eventId;
    }

    if (!Util.isUnset(request.meetingRoomsToRemoveShrink)) {
      body["MeetingRoomsToRemove"] = request.meetingRoomsToRemoveShrink;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "RemoveMeetingRooms",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/calendar/removeMeetingRooms`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RemoveMeetingRoomsResponse>(await this.callApi(params, req, runtime), new RemoveMeetingRoomsResponse({}));
  }

  async removeMeetingRooms(request: RemoveMeetingRoomsRequest): Promise<RemoveMeetingRoomsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new RemoveMeetingRoomsHeaders({ });
    return await this.removeMeetingRoomsWithOptions(request, headers, runtime);
  }

  async saveContentWithOptions(tmpReq: SaveContentRequest, tmpHeader: SaveContentHeaders, runtime: $Util.RuntimeOptions): Promise<SaveContentResponse> {
    Util.validateModel(tmpReq);
    let request = new SaveContentShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new SaveContentShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.contents)) {
      request.contentsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.contents, "Contents", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.contentsShrink)) {
      body["Contents"] = request.contentsShrink;
    }

    if (!Util.isUnset(request.ddFrom)) {
      body["DdFrom"] = request.ddFrom;
    }

    if (!Util.isUnset(request.templateId)) {
      body["TemplateId"] = request.templateId;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "SaveContent",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/log/saveContent`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SaveContentResponse>(await this.callApi(params, req, runtime), new SaveContentResponse({}));
  }

  async saveContent(request: SaveContentRequest): Promise<SaveContentResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new SaveContentHeaders({ });
    return await this.saveContentWithOptions(request, headers, runtime);
  }

  async saveFormDataWithOptions(request: SaveFormDataRequest, tmpHeader: SaveFormDataHeaders, runtime: $Util.RuntimeOptions): Promise<SaveFormDataResponse> {
    Util.validateModel(request);
    let headers = new SaveFormDataShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appType)) {
      body["AppType"] = request.appType;
    }

    if (!Util.isUnset(request.formDataJson)) {
      body["FormDataJson"] = request.formDataJson;
    }

    if (!Util.isUnset(request.formUuid)) {
      body["FormUuid"] = request.formUuid;
    }

    if (!Util.isUnset(request.language)) {
      body["Language"] = request.language;
    }

    if (!Util.isUnset(request.systemToken)) {
      body["SystemToken"] = request.systemToken;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "SaveFormData",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/yida/saveFormData`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SaveFormDataResponse>(await this.callApi(params, req, runtime), new SaveFormDataResponse({}));
  }

  async saveFormData(request: SaveFormDataRequest): Promise<SaveFormDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new SaveFormDataHeaders({ });
    return await this.saveFormDataWithOptions(request, headers, runtime);
  }

  async saveFormRemarkWithOptions(request: SaveFormRemarkRequest, tmpHeader: SaveFormRemarkHeaders, runtime: $Util.RuntimeOptions): Promise<SaveFormRemarkResponse> {
    Util.validateModel(request);
    let headers = new SaveFormRemarkShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appType)) {
      body["AppType"] = request.appType;
    }

    if (!Util.isUnset(request.atUserId)) {
      body["AtUserId"] = request.atUserId;
    }

    if (!Util.isUnset(request.content)) {
      body["Content"] = request.content;
    }

    if (!Util.isUnset(request.formInstanceId)) {
      body["FormInstanceId"] = request.formInstanceId;
    }

    if (!Util.isUnset(request.language)) {
      body["Language"] = request.language;
    }

    if (!Util.isUnset(request.replyId)) {
      body["ReplyId"] = request.replyId;
    }

    if (!Util.isUnset(request.systemToken)) {
      body["SystemToken"] = request.systemToken;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "SaveFormRemark",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/yida/saveFormRemark`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SaveFormRemarkResponse>(await this.callApi(params, req, runtime), new SaveFormRemarkResponse({}));
  }

  async saveFormRemark(request: SaveFormRemarkRequest): Promise<SaveFormRemarkResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new SaveFormRemarkHeaders({ });
    return await this.saveFormRemarkWithOptions(request, headers, runtime);
  }

  async searchEmployeeFieldValuesWithOptions(request: SearchEmployeeFieldValuesRequest, tmpHeader: SearchEmployeeFieldValuesHeaders, runtime: $Util.RuntimeOptions): Promise<SearchEmployeeFieldValuesResponse> {
    Util.validateModel(request);
    let headers = new SearchEmployeeFieldValuesShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appType)) {
      body["AppType"] = request.appType;
    }

    if (!Util.isUnset(request.createFromTimeGMT)) {
      body["CreateFromTimeGMT"] = request.createFromTimeGMT;
    }

    if (!Util.isUnset(request.createToTimeGMT)) {
      body["CreateToTimeGMT"] = request.createToTimeGMT;
    }

    if (!Util.isUnset(request.formUuid)) {
      body["FormUuid"] = request.formUuid;
    }

    if (!Util.isUnset(request.language)) {
      body["Language"] = request.language;
    }

    if (!Util.isUnset(request.modifiedFromTimeGMT)) {
      body["ModifiedFromTimeGMT"] = request.modifiedFromTimeGMT;
    }

    if (!Util.isUnset(request.modifiedToTimeGMT)) {
      body["ModifiedToTimeGMT"] = request.modifiedToTimeGMT;
    }

    if (!Util.isUnset(request.originatorId)) {
      body["OriginatorId"] = request.originatorId;
    }

    if (!Util.isUnset(request.searchFieldJson)) {
      body["SearchFieldJson"] = request.searchFieldJson;
    }

    if (!Util.isUnset(request.systemToken)) {
      body["SystemToken"] = request.systemToken;
    }

    if (!Util.isUnset(request.targetFieldJson)) {
      body["TargetFieldJson"] = request.targetFieldJson;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "SearchEmployeeFieldValues",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/yida/searchEmployeeFieldValues`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SearchEmployeeFieldValuesResponse>(await this.callApi(params, req, runtime), new SearchEmployeeFieldValuesResponse({}));
  }

  async searchEmployeeFieldValues(request: SearchEmployeeFieldValuesRequest): Promise<SearchEmployeeFieldValuesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new SearchEmployeeFieldValuesHeaders({ });
    return await this.searchEmployeeFieldValuesWithOptions(request, headers, runtime);
  }

  async searchFormDataIdListWithOptions(request: SearchFormDataIdListRequest, tmpHeader: SearchFormDataIdListHeaders, runtime: $Util.RuntimeOptions): Promise<SearchFormDataIdListResponse> {
    Util.validateModel(request);
    let headers = new SearchFormDataIdListShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appType)) {
      body["AppType"] = request.appType;
    }

    if (!Util.isUnset(request.createFromTimeGMT)) {
      body["CreateFromTimeGMT"] = request.createFromTimeGMT;
    }

    if (!Util.isUnset(request.createToTimeGMT)) {
      body["CreateToTimeGMT"] = request.createToTimeGMT;
    }

    if (!Util.isUnset(request.formUuid)) {
      body["FormUuid"] = request.formUuid;
    }

    if (!Util.isUnset(request.language)) {
      body["Language"] = request.language;
    }

    if (!Util.isUnset(request.modifiedFromTimeGMT)) {
      body["ModifiedFromTimeGMT"] = request.modifiedFromTimeGMT;
    }

    if (!Util.isUnset(request.modifiedToTimeGMT)) {
      body["ModifiedToTimeGMT"] = request.modifiedToTimeGMT;
    }

    if (!Util.isUnset(request.originatorId)) {
      body["OriginatorId"] = request.originatorId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.searchFieldJson)) {
      body["SearchFieldJson"] = request.searchFieldJson;
    }

    if (!Util.isUnset(request.systemToken)) {
      body["SystemToken"] = request.systemToken;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "SearchFormDataIdList",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/yida/searchFormDataIdList`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SearchFormDataIdListResponse>(await this.callApi(params, req, runtime), new SearchFormDataIdListResponse({}));
  }

  async searchFormDataIdList(request: SearchFormDataIdListRequest): Promise<SearchFormDataIdListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new SearchFormDataIdListHeaders({ });
    return await this.searchFormDataIdListWithOptions(request, headers, runtime);
  }

  async searchFormDataSecondGenerationWithOptions(request: SearchFormDataSecondGenerationRequest, tmpHeader: SearchFormDataSecondGenerationHeaders, runtime: $Util.RuntimeOptions): Promise<SearchFormDataSecondGenerationResponse> {
    Util.validateModel(request);
    let headers = new SearchFormDataSecondGenerationShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appType)) {
      body["AppType"] = request.appType;
    }

    if (!Util.isUnset(request.createFromTimeGMT)) {
      body["CreateFromTimeGMT"] = request.createFromTimeGMT;
    }

    if (!Util.isUnset(request.createToTimeGMT)) {
      body["CreateToTimeGMT"] = request.createToTimeGMT;
    }

    if (!Util.isUnset(request.formUuid)) {
      body["FormUuid"] = request.formUuid;
    }

    if (!Util.isUnset(request.modifiedFromTimeGMT)) {
      body["ModifiedFromTimeGMT"] = request.modifiedFromTimeGMT;
    }

    if (!Util.isUnset(request.modifiedToTimeGMT)) {
      body["ModifiedToTimeGMT"] = request.modifiedToTimeGMT;
    }

    if (!Util.isUnset(request.orderConfigJson)) {
      body["OrderConfigJson"] = request.orderConfigJson;
    }

    if (!Util.isUnset(request.originatorId)) {
      body["OriginatorId"] = request.originatorId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.searchCondition)) {
      body["SearchCondition"] = request.searchCondition;
    }

    if (!Util.isUnset(request.systemToken)) {
      body["SystemToken"] = request.systemToken;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "SearchFormDataSecondGeneration",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/yida/searchFormDataSecondGeneration`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SearchFormDataSecondGenerationResponse>(await this.callApi(params, req, runtime), new SearchFormDataSecondGenerationResponse({}));
  }

  async searchFormDataSecondGeneration(request: SearchFormDataSecondGenerationRequest): Promise<SearchFormDataSecondGenerationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new SearchFormDataSecondGenerationHeaders({ });
    return await this.searchFormDataSecondGenerationWithOptions(request, headers, runtime);
  }

  async searchFormDataSecondGenerationNoTableFieldWithOptions(request: SearchFormDataSecondGenerationNoTableFieldRequest, tmpHeader: SearchFormDataSecondGenerationNoTableFieldHeaders, runtime: $Util.RuntimeOptions): Promise<SearchFormDataSecondGenerationNoTableFieldResponse> {
    Util.validateModel(request);
    let headers = new SearchFormDataSecondGenerationNoTableFieldShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appType)) {
      body["AppType"] = request.appType;
    }

    if (!Util.isUnset(request.createFromTimeGMT)) {
      body["CreateFromTimeGMT"] = request.createFromTimeGMT;
    }

    if (!Util.isUnset(request.createToTimeGMT)) {
      body["CreateToTimeGMT"] = request.createToTimeGMT;
    }

    if (!Util.isUnset(request.formUuid)) {
      body["FormUuid"] = request.formUuid;
    }

    if (!Util.isUnset(request.modifiedFromTimeGMT)) {
      body["ModifiedFromTimeGMT"] = request.modifiedFromTimeGMT;
    }

    if (!Util.isUnset(request.modifiedToTimeGMT)) {
      body["ModifiedToTimeGMT"] = request.modifiedToTimeGMT;
    }

    if (!Util.isUnset(request.orderConfigJson)) {
      body["OrderConfigJson"] = request.orderConfigJson;
    }

    if (!Util.isUnset(request.originatorId)) {
      body["OriginatorId"] = request.originatorId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.searchCondition)) {
      body["SearchCondition"] = request.searchCondition;
    }

    if (!Util.isUnset(request.systemToken)) {
      body["SystemToken"] = request.systemToken;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "SearchFormDataSecondGenerationNoTableField",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/yida/searchFormDataSecondGenerationNoTableField`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SearchFormDataSecondGenerationNoTableFieldResponse>(await this.callApi(params, req, runtime), new SearchFormDataSecondGenerationNoTableFieldResponse({}));
  }

  async searchFormDataSecondGenerationNoTableField(request: SearchFormDataSecondGenerationNoTableFieldRequest): Promise<SearchFormDataSecondGenerationNoTableFieldResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new SearchFormDataSecondGenerationNoTableFieldHeaders({ });
    return await this.searchFormDataSecondGenerationNoTableFieldWithOptions(request, headers, runtime);
  }

  async searchFormDatasWithOptions(request: SearchFormDatasRequest, tmpHeader: SearchFormDatasHeaders, runtime: $Util.RuntimeOptions): Promise<SearchFormDatasResponse> {
    Util.validateModel(request);
    let headers = new SearchFormDatasShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appType)) {
      body["AppType"] = request.appType;
    }

    if (!Util.isUnset(request.createFromTimeGMT)) {
      body["CreateFromTimeGMT"] = request.createFromTimeGMT;
    }

    if (!Util.isUnset(request.createToTimeGMT)) {
      body["CreateToTimeGMT"] = request.createToTimeGMT;
    }

    if (!Util.isUnset(request.currentPage)) {
      body["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.dynamicOrder)) {
      body["DynamicOrder"] = request.dynamicOrder;
    }

    if (!Util.isUnset(request.formUuid)) {
      body["FormUuid"] = request.formUuid;
    }

    if (!Util.isUnset(request.language)) {
      body["Language"] = request.language;
    }

    if (!Util.isUnset(request.modifiedFromTimeGMT)) {
      body["ModifiedFromTimeGMT"] = request.modifiedFromTimeGMT;
    }

    if (!Util.isUnset(request.modifiedToTimeGMT)) {
      body["ModifiedToTimeGMT"] = request.modifiedToTimeGMT;
    }

    if (!Util.isUnset(request.originatorId)) {
      body["OriginatorId"] = request.originatorId;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.searchFieldJson)) {
      body["SearchFieldJson"] = request.searchFieldJson;
    }

    if (!Util.isUnset(request.systemToken)) {
      body["SystemToken"] = request.systemToken;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "SearchFormDatas",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/yida/searchFormDatas`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SearchFormDatasResponse>(await this.callApi(params, req, runtime), new SearchFormDatasResponse({}));
  }

  async searchFormDatas(request: SearchFormDatasRequest): Promise<SearchFormDatasResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new SearchFormDatasHeaders({ });
    return await this.searchFormDatasWithOptions(request, headers, runtime);
  }

  async searchInnerGroupsWithOptions(request: SearchInnerGroupsRequest, tmpHeader: SearchInnerGroupsHeaders, runtime: $Util.RuntimeOptions): Promise<SearchInnerGroupsResponse> {
    Util.validateModel(request);
    let headers = new SearchInnerGroupsShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.maxResults)) {
      body["MaxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.searchKey)) {
      body["SearchKey"] = request.searchKey;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "SearchInnerGroups",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/im/searchInnerGroups`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SearchInnerGroupsResponse>(await this.callApi(params, req, runtime), new SearchInnerGroupsResponse({}));
  }

  async searchInnerGroups(request: SearchInnerGroupsRequest): Promise<SearchInnerGroupsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new SearchInnerGroupsHeaders({ });
    return await this.searchInnerGroupsWithOptions(request, headers, runtime);
  }

  async sendBannerWithOptions(tmpReq: SendBannerRequest, tmpHeader: SendBannerHeaders, runtime: $Util.RuntimeOptions): Promise<SendBannerResponse> {
    Util.validateModel(tmpReq);
    let request = new SendBannerShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new SendBannerShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.content)) {
      request.contentShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.content, "Content", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.contentShrink)) {
      body["Content"] = request.contentShrink;
    }

    if (!Util.isUnset(request.endTime)) {
      body["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.startTime)) {
      body["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "SendBanner",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/watt/sendBanner`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SendBannerResponse>(await this.callApi(params, req, runtime), new SendBannerResponse({}));
  }

  async sendBanner(request: SendBannerRequest): Promise<SendBannerResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new SendBannerHeaders({ });
    return await this.sendBannerWithOptions(request, headers, runtime);
  }

  async sendPopupWithOptions(tmpReq: SendPopupRequest, tmpHeader: SendPopupHeaders, runtime: $Util.RuntimeOptions): Promise<SendPopupResponse> {
    Util.validateModel(tmpReq);
    let request = new SendPopupShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new SendPopupShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.content)) {
      request.contentShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.content, "Content", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.contentShrink)) {
      body["Content"] = request.contentShrink;
    }

    if (!Util.isUnset(request.endTime)) {
      body["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.startTime)) {
      body["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "SendPopup",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/watt/sendPopup`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SendPopupResponse>(await this.callApi(params, req, runtime), new SendPopupResponse({}));
  }

  async sendPopup(request: SendPopupRequest): Promise<SendPopupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new SendPopupHeaders({ });
    return await this.sendPopupWithOptions(request, headers, runtime);
  }

  async sendSearchShadeWithOptions(tmpReq: SendSearchShadeRequest, tmpHeader: SendSearchShadeHeaders, runtime: $Util.RuntimeOptions): Promise<SendSearchShadeResponse> {
    Util.validateModel(tmpReq);
    let request = new SendSearchShadeShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new SendSearchShadeShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.content)) {
      request.contentShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.content, "Content", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.contentShrink)) {
      body["Content"] = request.contentShrink;
    }

    if (!Util.isUnset(request.endTime)) {
      body["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.startTime)) {
      body["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "SendSearchShade",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/watt/sendSearchShade`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SendSearchShadeResponse>(await this.callApi(params, req, runtime), new SendSearchShadeResponse({}));
  }

  async sendSearchShade(request: SendSearchShadeRequest): Promise<SendSearchShadeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new SendSearchShadeHeaders({ });
    return await this.sendSearchShadeWithOptions(request, headers, runtime);
  }

  async setColumnsVisibilityWithOptions(tmpReq: SetColumnsVisibilityRequest, tmpHeader: SetColumnsVisibilityHeaders, runtime: $Util.RuntimeOptions): Promise<SetColumnsVisibilityResponse> {
    Util.validateModel(tmpReq);
    let request = new SetColumnsVisibilityShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new SetColumnsVisibilityShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.column)) {
      body["Column"] = request.column;
    }

    if (!Util.isUnset(request.columnCount)) {
      body["ColumnCount"] = request.columnCount;
    }

    if (!Util.isUnset(request.sheetId)) {
      body["SheetId"] = request.sheetId;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    if (!Util.isUnset(request.visibility)) {
      body["Visibility"] = request.visibility;
    }

    if (!Util.isUnset(request.workbookId)) {
      body["WorkbookId"] = request.workbookId;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "SetColumnsVisibility",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/documents/setColumnsVisibility`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SetColumnsVisibilityResponse>(await this.callApi(params, req, runtime), new SetColumnsVisibilityResponse({}));
  }

  async setColumnsVisibility(request: SetColumnsVisibilityRequest): Promise<SetColumnsVisibilityResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new SetColumnsVisibilityHeaders({ });
    return await this.setColumnsVisibilityWithOptions(request, headers, runtime);
  }

  async setRowsVisibilityWithOptions(tmpReq: SetRowsVisibilityRequest, tmpHeader: SetRowsVisibilityHeaders, runtime: $Util.RuntimeOptions): Promise<SetRowsVisibilityResponse> {
    Util.validateModel(tmpReq);
    let request = new SetRowsVisibilityShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new SetRowsVisibilityShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.row)) {
      body["Row"] = request.row;
    }

    if (!Util.isUnset(request.rowCount)) {
      body["RowCount"] = request.rowCount;
    }

    if (!Util.isUnset(request.sheetId)) {
      body["SheetId"] = request.sheetId;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    if (!Util.isUnset(request.visibility)) {
      body["Visibility"] = request.visibility;
    }

    if (!Util.isUnset(request.workbookId)) {
      body["WorkbookId"] = request.workbookId;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "SetRowsVisibility",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/documents/setRowsVisibility`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SetRowsVisibilityResponse>(await this.callApi(params, req, runtime), new SetRowsVisibilityResponse({}));
  }

  async setRowsVisibility(request: SetRowsVisibilityRequest): Promise<SetRowsVisibilityResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new SetRowsVisibilityHeaders({ });
    return await this.setRowsVisibilityWithOptions(request, headers, runtime);
  }

  async simpleListReportWithOptions(tmpReq: SimpleListReportRequest, tmpHeader: SimpleListReportHeaders, runtime: $Util.RuntimeOptions): Promise<SimpleListReportResponse> {
    Util.validateModel(tmpReq);
    let request = new SimpleListReportShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new SimpleListReportShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.cursor)) {
      body["Cursor"] = request.cursor;
    }

    if (!Util.isUnset(request.endTime)) {
      body["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.size)) {
      body["Size"] = request.size;
    }

    if (!Util.isUnset(request.startTime)) {
      body["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.templateName)) {
      body["TemplateName"] = request.templateName;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "SimpleListReport",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/log/simpleListReport`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SimpleListReportResponse>(await this.callApi(params, req, runtime), new SimpleListReportResponse({}));
  }

  async simpleListReport(request: SimpleListReportRequest): Promise<SimpleListReportResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new SimpleListReportHeaders({ });
    return await this.simpleListReportWithOptions(request, headers, runtime);
  }

  async startCloudRecordWithOptions(tmpReq: StartCloudRecordRequest, tmpHeader: StartCloudRecordHeaders, runtime: $Util.RuntimeOptions): Promise<StartCloudRecordResponse> {
    Util.validateModel(tmpReq);
    let request = new StartCloudRecordShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new StartCloudRecordShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.mode)) {
      body["Mode"] = request.mode;
    }

    if (!Util.isUnset(request.smallWindowPosition)) {
      body["SmallWindowPosition"] = request.smallWindowPosition;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    if (!Util.isUnset(request.conferenceId)) {
      body["conferenceId"] = request.conferenceId;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "StartCloudRecord",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/ysp/startCloudRecord`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<StartCloudRecordResponse>(await this.callApi(params, req, runtime), new StartCloudRecordResponse({}));
  }

  async startCloudRecord(request: StartCloudRecordRequest): Promise<StartCloudRecordResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new StartCloudRecordHeaders({ });
    return await this.startCloudRecordWithOptions(request, headers, runtime);
  }

  async startInstanceWithOptions(request: StartInstanceRequest, tmpHeader: StartInstanceHeaders, runtime: $Util.RuntimeOptions): Promise<StartInstanceResponse> {
    Util.validateModel(request);
    let headers = new StartInstanceShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appType)) {
      body["AppType"] = request.appType;
    }

    if (!Util.isUnset(request.departmentId)) {
      body["DepartmentId"] = request.departmentId;
    }

    if (!Util.isUnset(request.formDataJson)) {
      body["FormDataJson"] = request.formDataJson;
    }

    if (!Util.isUnset(request.formUuid)) {
      body["FormUuid"] = request.formUuid;
    }

    if (!Util.isUnset(request.language)) {
      body["Language"] = request.language;
    }

    if (!Util.isUnset(request.processCode)) {
      body["ProcessCode"] = request.processCode;
    }

    if (!Util.isUnset(request.processData)) {
      body["ProcessData"] = request.processData;
    }

    if (!Util.isUnset(request.systemToken)) {
      body["SystemToken"] = request.systemToken;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "StartInstance",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/yida/startInstance`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<StartInstanceResponse>(await this.callApi(params, req, runtime), new StartInstanceResponse({}));
  }

  async startInstance(request: StartInstanceRequest): Promise<StartInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new StartInstanceHeaders({ });
    return await this.startInstanceWithOptions(request, headers, runtime);
  }

  async statisticsListByTypeReportWithOptions(tmpReq: StatisticsListByTypeReportRequest, tmpHeader: StatisticsListByTypeReportHeaders, runtime: $Util.RuntimeOptions): Promise<StatisticsListByTypeReportResponse> {
    Util.validateModel(tmpReq);
    let request = new StatisticsListByTypeReportShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new StatisticsListByTypeReportShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.offset)) {
      body["Offset"] = request.offset;
    }

    if (!Util.isUnset(request.reportId)) {
      body["ReportId"] = request.reportId;
    }

    if (!Util.isUnset(request.size)) {
      body["Size"] = request.size;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    if (!Util.isUnset(request.type)) {
      body["Type"] = request.type;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "StatisticsListByTypeReport",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/log/statisticsListByTypeReport`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<StatisticsListByTypeReportResponse>(await this.callApi(params, req, runtime), new StatisticsListByTypeReportResponse({}));
  }

  async statisticsListByTypeReport(request: StatisticsListByTypeReportRequest): Promise<StatisticsListByTypeReportResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new StatisticsListByTypeReportHeaders({ });
    return await this.statisticsListByTypeReportWithOptions(request, headers, runtime);
  }

  async statisticsReportWithOptions(tmpReq: StatisticsReportRequest, tmpHeader: StatisticsReportHeaders, runtime: $Util.RuntimeOptions): Promise<StatisticsReportResponse> {
    Util.validateModel(tmpReq);
    let request = new StatisticsReportShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new StatisticsReportShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.reportId)) {
      body["ReportId"] = request.reportId;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "StatisticsReport",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/log/statisticsReport`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<StatisticsReportResponse>(await this.callApi(params, req, runtime), new StatisticsReportResponse({}));
  }

  async statisticsReport(request: StatisticsReportRequest): Promise<StatisticsReportResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new StatisticsReportHeaders({ });
    return await this.statisticsReportWithOptions(request, headers, runtime);
  }

  async stopCloudRecordWithOptions(tmpReq: StopCloudRecordRequest, tmpHeader: StopCloudRecordHeaders, runtime: $Util.RuntimeOptions): Promise<StopCloudRecordResponse> {
    Util.validateModel(tmpReq);
    let request = new StopCloudRecordShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new StopCloudRecordShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    if (!Util.isUnset(request.conferenceId)) {
      body["conferenceId"] = request.conferenceId;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "StopCloudRecord",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/ysp/stopCloudRecord`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<StopCloudRecordResponse>(await this.callApi(params, req, runtime), new StopCloudRecordResponse({}));
  }

  async stopCloudRecord(request: StopCloudRecordRequest): Promise<StopCloudRecordResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new StopCloudRecordHeaders({ });
    return await this.stopCloudRecordWithOptions(request, headers, runtime);
  }

  async subscribeCalendarWithOptions(request: SubscribeCalendarRequest, tmpHeader: SubscribeCalendarHeaders, runtime: $Util.RuntimeOptions): Promise<SubscribeCalendarResponse> {
    Util.validateModel(request);
    let headers = new SubscribeCalendarShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.calendarId)) {
      body["CalendarId"] = request.calendarId;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "SubscribeCalendar",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/calendar/subscribeCalendar`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SubscribeCalendarResponse>(await this.callApi(params, req, runtime), new SubscribeCalendarResponse({}));
  }

  async subscribeCalendar(request: SubscribeCalendarRequest): Promise<SubscribeCalendarResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new SubscribeCalendarHeaders({ });
    return await this.subscribeCalendarWithOptions(request, headers, runtime);
  }

  async syncDingTypeWithOptions(tmpReq: SyncDingTypeRequest, tmpHeader: SyncDingTypeHeaders, runtime: $Util.RuntimeOptions): Promise<SyncDingTypeResponse> {
    Util.validateModel(tmpReq);
    let request = new SyncDingTypeShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new SyncDingTypeShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.dingType)) {
      body["DingType"] = request.dingType;
    }

    if (!Util.isUnset(request.isDimission)) {
      body["IsDimission"] = request.isDimission;
    }

    if (!Util.isUnset(request.source)) {
      body["Source"] = request.source;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    if (!Util.isUnset(request.workNo)) {
      body["WorkNo"] = request.workNo;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "SyncDingType",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/aliding/v1/indepding/syncDingType`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SyncDingTypeResponse>(await this.callApi(params, req, runtime), new SyncDingTypeResponse({}));
  }

  async syncDingType(request: SyncDingTypeRequest): Promise<SyncDingTypeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new SyncDingTypeHeaders({ });
    return await this.syncDingTypeWithOptions(request, headers, runtime);
  }

  async terminateInstanceWithOptions(request: TerminateInstanceRequest, tmpHeader: TerminateInstanceHeaders, runtime: $Util.RuntimeOptions): Promise<TerminateInstanceResponse> {
    Util.validateModel(request);
    let headers = new TerminateInstanceShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appType)) {
      body["AppType"] = request.appType;
    }

    if (!Util.isUnset(request.language)) {
      body["Language"] = request.language;
    }

    if (!Util.isUnset(request.processInstanceId)) {
      body["ProcessInstanceId"] = request.processInstanceId;
    }

    if (!Util.isUnset(request.systemToken)) {
      body["SystemToken"] = request.systemToken;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "TerminateInstance",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/yida/terminateInstance`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<TerminateInstanceResponse>(await this.callApi(params, req, runtime), new TerminateInstanceResponse({}));
  }

  async terminateInstance(request: TerminateInstanceRequest): Promise<TerminateInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new TerminateInstanceHeaders({ });
    return await this.terminateInstanceWithOptions(request, headers, runtime);
  }

  async unsubscribeCalendarWithOptions(request: UnsubscribeCalendarRequest, tmpHeader: UnsubscribeCalendarHeaders, runtime: $Util.RuntimeOptions): Promise<UnsubscribeCalendarResponse> {
    Util.validateModel(request);
    let headers = new UnsubscribeCalendarShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.calendarId)) {
      body["CalendarId"] = request.calendarId;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UnsubscribeCalendar",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/calendar/unsubscribeCalendar`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UnsubscribeCalendarResponse>(await this.callApi(params, req, runtime), new UnsubscribeCalendarResponse({}));
  }

  async unsubscribeCalendar(request: UnsubscribeCalendarRequest): Promise<UnsubscribeCalendarResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new UnsubscribeCalendarHeaders({ });
    return await this.unsubscribeCalendarWithOptions(request, headers, runtime);
  }

  async updateFormDataWithOptions(request: UpdateFormDataRequest, tmpHeader: UpdateFormDataHeaders, runtime: $Util.RuntimeOptions): Promise<UpdateFormDataResponse> {
    Util.validateModel(request);
    let headers = new UpdateFormDataShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appType)) {
      body["AppType"] = request.appType;
    }

    if (!Util.isUnset(request.formInstanceId)) {
      body["FormInstanceId"] = request.formInstanceId;
    }

    if (!Util.isUnset(request.language)) {
      body["Language"] = request.language;
    }

    if (!Util.isUnset(request.systemToken)) {
      body["SystemToken"] = request.systemToken;
    }

    if (!Util.isUnset(request.updateFormDataJson)) {
      body["UpdateFormDataJson"] = request.updateFormDataJson;
    }

    if (!Util.isUnset(request.useLatestVersion)) {
      body["UseLatestVersion"] = request.useLatestVersion;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateFormData",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/yida/updateFormData`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateFormDataResponse>(await this.callApi(params, req, runtime), new UpdateFormDataResponse({}));
  }

  async updateFormData(request: UpdateFormDataRequest): Promise<UpdateFormDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new UpdateFormDataHeaders({ });
    return await this.updateFormDataWithOptions(request, headers, runtime);
  }

  async updateInstanceWithOptions(request: UpdateInstanceRequest, tmpHeader: UpdateInstanceHeaders, runtime: $Util.RuntimeOptions): Promise<UpdateInstanceResponse> {
    Util.validateModel(request);
    let headers = new UpdateInstanceShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appType)) {
      body["AppType"] = request.appType;
    }

    if (!Util.isUnset(request.language)) {
      body["Language"] = request.language;
    }

    if (!Util.isUnset(request.processInstanceId)) {
      body["ProcessInstanceId"] = request.processInstanceId;
    }

    if (!Util.isUnset(request.systemToken)) {
      body["SystemToken"] = request.systemToken;
    }

    if (!Util.isUnset(request.updateFormDataJson)) {
      body["UpdateFormDataJson"] = request.updateFormDataJson;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateInstance",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/yida/updateInstance`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateInstanceResponse>(await this.callApi(params, req, runtime), new UpdateInstanceResponse({}));
  }

  async updateInstance(request: UpdateInstanceRequest): Promise<UpdateInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new UpdateInstanceHeaders({ });
    return await this.updateInstanceWithOptions(request, headers, runtime);
  }

  async updateLiveWithOptions(tmpReq: UpdateLiveRequest, tmpHeader: UpdateLiveHeaders, runtime: $Util.RuntimeOptions): Promise<UpdateLiveResponse> {
    Util.validateModel(tmpReq);
    let request = new UpdateLiveShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new UpdateLiveShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.coverUrl)) {
      body["CoverUrl"] = request.coverUrl;
    }

    if (!Util.isUnset(request.introduction)) {
      body["Introduction"] = request.introduction;
    }

    if (!Util.isUnset(request.liveId)) {
      body["LiveId"] = request.liveId;
    }

    if (!Util.isUnset(request.preEndTime)) {
      body["PreEndTime"] = request.preEndTime;
    }

    if (!Util.isUnset(request.preStartTime)) {
      body["PreStartTime"] = request.preStartTime;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    if (!Util.isUnset(request.title)) {
      body["Title"] = request.title;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateLive",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/ysp/updateLive`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateLiveResponse>(await this.callApi(params, req, runtime), new UpdateLiveResponse({}));
  }

  async updateLive(request: UpdateLiveRequest): Promise<UpdateLiveResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new UpdateLiveHeaders({ });
    return await this.updateLiveWithOptions(request, headers, runtime);
  }

  async updateMeetingRoomWithOptions(tmpReq: UpdateMeetingRoomRequest, tmpHeader: UpdateMeetingRoomHeaders, runtime: $Util.RuntimeOptions): Promise<UpdateMeetingRoomResponse> {
    Util.validateModel(tmpReq);
    let request = new UpdateMeetingRoomShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new UpdateMeetingRoomShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.reservationAuthority)) {
      request.reservationAuthorityShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.reservationAuthority, "ReservationAuthority", "json");
    }

    if (!Util.isUnset(tmpReq.roomLabelIds)) {
      request.roomLabelIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.roomLabelIds, "RoomLabelIds", "json");
    }

    if (!Util.isUnset(tmpReq.roomLocation)) {
      request.roomLocationShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.roomLocation, "RoomLocation", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.enableCycleReservation)) {
      body["EnableCycleReservation"] = request.enableCycleReservation;
    }

    if (!Util.isUnset(request.groupId)) {
      body["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.isvRoomId)) {
      body["IsvRoomId"] = request.isvRoomId;
    }

    if (!Util.isUnset(request.reservationAuthorityShrink)) {
      body["ReservationAuthority"] = request.reservationAuthorityShrink;
    }

    if (!Util.isUnset(request.roomCapacity)) {
      body["RoomCapacity"] = request.roomCapacity;
    }

    if (!Util.isUnset(request.roomId)) {
      body["RoomId"] = request.roomId;
    }

    if (!Util.isUnset(request.roomLabelIdsShrink)) {
      body["RoomLabelIds"] = request.roomLabelIdsShrink;
    }

    if (!Util.isUnset(request.roomLocationShrink)) {
      body["RoomLocation"] = request.roomLocationShrink;
    }

    if (!Util.isUnset(request.roomName)) {
      body["RoomName"] = request.roomName;
    }

    if (!Util.isUnset(request.roomPicture)) {
      body["RoomPicture"] = request.roomPicture;
    }

    if (!Util.isUnset(request.roomStatus)) {
      body["RoomStatus"] = request.roomStatus;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateMeetingRoom",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/ysp/updateMeetingRoom`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateMeetingRoomResponse>(await this.callApi(params, req, runtime), new UpdateMeetingRoomResponse({}));
  }

  async updateMeetingRoom(request: UpdateMeetingRoomRequest): Promise<UpdateMeetingRoomResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new UpdateMeetingRoomHeaders({ });
    return await this.updateMeetingRoomWithOptions(request, headers, runtime);
  }

  async updateMeetingRoomGroupWithOptions(tmpReq: UpdateMeetingRoomGroupRequest, tmpHeader: UpdateMeetingRoomGroupHeaders, runtime: $Util.RuntimeOptions): Promise<UpdateMeetingRoomGroupResponse> {
    Util.validateModel(tmpReq);
    let request = new UpdateMeetingRoomGroupShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new UpdateMeetingRoomGroupShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.groupId)) {
      body["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.groupName)) {
      body["GroupName"] = request.groupName;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateMeetingRoomGroup",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/ysp/updateMeetingRoomGroup`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateMeetingRoomGroupResponse>(await this.callApi(params, req, runtime), new UpdateMeetingRoomGroupResponse({}));
  }

  async updateMeetingRoomGroup(request: UpdateMeetingRoomGroupRequest): Promise<UpdateMeetingRoomGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new UpdateMeetingRoomGroupHeaders({ });
    return await this.updateMeetingRoomGroupWithOptions(request, headers, runtime);
  }

  async updateRangeWithOptions(tmpReq: UpdateRangeRequest, tmpHeader: UpdateRangeHeaders, runtime: $Util.RuntimeOptions): Promise<UpdateRangeResponse> {
    Util.validateModel(tmpReq);
    let request = new UpdateRangeShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new UpdateRangeShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.backgroundColors)) {
      request.backgroundColorsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.backgroundColors, "BackgroundColors", "json");
    }

    if (!Util.isUnset(tmpReq.hyperlinks)) {
      request.hyperlinksShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.hyperlinks, "Hyperlinks", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    if (!Util.isUnset(tmpReq.values)) {
      request.valuesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.values, "Values", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.backgroundColorsShrink)) {
      body["BackgroundColors"] = request.backgroundColorsShrink;
    }

    if (!Util.isUnset(request.hyperlinksShrink)) {
      body["Hyperlinks"] = request.hyperlinksShrink;
    }

    if (!Util.isUnset(request.numberFormat)) {
      body["NumberFormat"] = request.numberFormat;
    }

    if (!Util.isUnset(request.rangeAddress)) {
      body["RangeAddress"] = request.rangeAddress;
    }

    if (!Util.isUnset(request.sheetId)) {
      body["SheetId"] = request.sheetId;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    if (!Util.isUnset(request.valuesShrink)) {
      body["Values"] = request.valuesShrink;
    }

    if (!Util.isUnset(request.workbookId)) {
      body["WorkbookId"] = request.workbookId;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateRange",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/documents/updateRange`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateRangeResponse>(await this.callApi(params, req, runtime), new UpdateRangeResponse({}));
  }

  async updateRange(request: UpdateRangeRequest): Promise<UpdateRangeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new UpdateRangeHeaders({ });
    return await this.updateRangeWithOptions(request, headers, runtime);
  }

  async updateScheduleConfSettingsWithOptions(tmpReq: UpdateScheduleConfSettingsRequest, tmpHeader: UpdateScheduleConfSettingsHeaders, runtime: $Util.RuntimeOptions): Promise<UpdateScheduleConfSettingsResponse> {
    Util.validateModel(tmpReq);
    let request = new UpdateScheduleConfSettingsShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new UpdateScheduleConfSettingsShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.scheduleConfSettingModel)) {
      request.scheduleConfSettingModelShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.scheduleConfSettingModel, "ScheduleConfSettingModel", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.scheduleConfSettingModelShrink)) {
      body["ScheduleConfSettingModel"] = request.scheduleConfSettingModelShrink;
    }

    if (!Util.isUnset(request.scheduleConferenceId)) {
      body["ScheduleConferenceId"] = request.scheduleConferenceId;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateScheduleConfSettings",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/ysp/updateScheduleConfSettings`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateScheduleConfSettingsResponse>(await this.callApi(params, req, runtime), new UpdateScheduleConfSettingsResponse({}));
  }

  async updateScheduleConfSettings(request: UpdateScheduleConfSettingsRequest): Promise<UpdateScheduleConfSettingsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new UpdateScheduleConfSettingsHeaders({ });
    return await this.updateScheduleConfSettingsWithOptions(request, headers, runtime);
  }

  async updateScheduleConferenceWithOptions(tmpReq: UpdateScheduleConferenceRequest, tmpHeader: UpdateScheduleConferenceHeaders, runtime: $Util.RuntimeOptions): Promise<UpdateScheduleConferenceResponse> {
    Util.validateModel(tmpReq);
    let request = new UpdateScheduleConferenceShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new UpdateScheduleConferenceShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.endTime)) {
      body["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.scheduleConferenceId)) {
      body["ScheduleConferenceId"] = request.scheduleConferenceId;
    }

    if (!Util.isUnset(request.startTime)) {
      body["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    if (!Util.isUnset(request.title)) {
      body["Title"] = request.title;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateScheduleConference",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/ysp/updateScheduleConference`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateScheduleConferenceResponse>(await this.callApi(params, req, runtime), new UpdateScheduleConferenceResponse({}));
  }

  async updateScheduleConference(request: UpdateScheduleConferenceRequest): Promise<UpdateScheduleConferenceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new UpdateScheduleConferenceHeaders({ });
    return await this.updateScheduleConferenceWithOptions(request, headers, runtime);
  }

  async updateStatusWithOptions(tmpReq: UpdateStatusRequest, tmpHeader: UpdateStatusHeaders, runtime: $Util.RuntimeOptions): Promise<UpdateStatusResponse> {
    Util.validateModel(tmpReq);
    let request = new UpdateStatusShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new UpdateStatusShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.errorLines)) {
      request.errorLinesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.errorLines, "ErrorLines", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appType)) {
      body["AppType"] = request.appType;
    }

    if (!Util.isUnset(request.errorLinesShrink)) {
      body["ErrorLines"] = request.errorLinesShrink;
    }

    if (!Util.isUnset(request.importSequence)) {
      body["ImportSequence"] = request.importSequence;
    }

    if (!Util.isUnset(request.language)) {
      body["Language"] = request.language;
    }

    if (!Util.isUnset(request.status)) {
      body["Status"] = request.status;
    }

    if (!Util.isUnset(request.systemToken)) {
      body["SystemToken"] = request.systemToken;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateStatus",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/yida/updateStatus`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateStatusResponse>(await this.callApi(params, req, runtime), new UpdateStatusResponse({}));
  }

  async updateStatus(request: UpdateStatusRequest): Promise<UpdateStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new UpdateStatusHeaders({ });
    return await this.updateStatusWithOptions(request, headers, runtime);
  }

  async updateSubscribedCalendarsWithOptions(tmpReq: UpdateSubscribedCalendarsRequest, tmpHeader: UpdateSubscribedCalendarsHeaders, runtime: $Util.RuntimeOptions): Promise<UpdateSubscribedCalendarsResponse> {
    Util.validateModel(tmpReq);
    let request = new UpdateSubscribedCalendarsShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new UpdateSubscribedCalendarsShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.managers)) {
      request.managersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.managers, "Managers", "json");
    }

    if (!Util.isUnset(tmpReq.subscribeScope)) {
      request.subscribeScopeShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.subscribeScope, "SubscribeScope", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.calendarId)) {
      body["CalendarId"] = request.calendarId;
    }

    if (!Util.isUnset(request.description)) {
      body["Description"] = request.description;
    }

    if (!Util.isUnset(request.managersShrink)) {
      body["Managers"] = request.managersShrink;
    }

    if (!Util.isUnset(request.name)) {
      body["Name"] = request.name;
    }

    if (!Util.isUnset(request.subscribeScopeShrink)) {
      body["SubscribeScope"] = request.subscribeScopeShrink;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateSubscribedCalendars",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/calendar/updateSubscribedCalendars`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateSubscribedCalendarsResponse>(await this.callApi(params, req, runtime), new UpdateSubscribedCalendarsResponse({}));
  }

  async updateSubscribedCalendars(request: UpdateSubscribedCalendarsRequest): Promise<UpdateSubscribedCalendarsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new UpdateSubscribedCalendarsHeaders({ });
    return await this.updateSubscribedCalendarsWithOptions(request, headers, runtime);
  }

  async updateTodoTaskWithOptions(tmpReq: UpdateTodoTaskRequest, tmpHeader: UpdateTodoTaskHeaders, runtime: $Util.RuntimeOptions): Promise<UpdateTodoTaskResponse> {
    Util.validateModel(tmpReq);
    let request = new UpdateTodoTaskShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new UpdateTodoTaskShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    if (!Util.isUnset(tmpReq.executorIds)) {
      request.executorIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.executorIds, "executorIds", "json");
    }

    if (!Util.isUnset(tmpReq.participantIds)) {
      request.participantIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.participantIds, "participantIds", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    if (!Util.isUnset(request.description)) {
      body["description"] = request.description;
    }

    if (!Util.isUnset(request.done)) {
      body["done"] = request.done;
    }

    if (!Util.isUnset(request.dueTime)) {
      body["dueTime"] = request.dueTime;
    }

    if (!Util.isUnset(request.executorIdsShrink)) {
      body["executorIds"] = request.executorIdsShrink;
    }

    if (!Util.isUnset(request.participantIdsShrink)) {
      body["participantIds"] = request.participantIdsShrink;
    }

    if (!Util.isUnset(request.subject)) {
      body["subject"] = request.subject;
    }

    if (!Util.isUnset(request.taskId)) {
      body["taskId"] = request.taskId;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateTodoTask",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/task/updateTodoTask`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateTodoTaskResponse>(await this.callApi(params, req, runtime), new UpdateTodoTaskResponse({}));
  }

  async updateTodoTask(request: UpdateTodoTaskRequest): Promise<UpdateTodoTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new UpdateTodoTaskHeaders({ });
    return await this.updateTodoTaskWithOptions(request, headers, runtime);
  }

  async updateTodoTaskExecutorStatusWithOptions(tmpReq: UpdateTodoTaskExecutorStatusRequest, tmpHeader: UpdateTodoTaskExecutorStatusHeaders, runtime: $Util.RuntimeOptions): Promise<UpdateTodoTaskExecutorStatusResponse> {
    Util.validateModel(tmpReq);
    let request = new UpdateTodoTaskExecutorStatusShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new UpdateTodoTaskExecutorStatusShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    if (!Util.isUnset(tmpReq.executorStatusList)) {
      request.executorStatusListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.executorStatusList, "executorStatusList", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    if (!Util.isUnset(request.executorStatusListShrink)) {
      body["executorStatusList"] = request.executorStatusListShrink;
    }

    if (!Util.isUnset(request.operatorId)) {
      body["operatorId"] = request.operatorId;
    }

    if (!Util.isUnset(request.taskId)) {
      body["taskId"] = request.taskId;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateTodoTaskExecutorStatus",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/task/updateTodoTaskExecutorStatus`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateTodoTaskExecutorStatusResponse>(await this.callApi(params, req, runtime), new UpdateTodoTaskExecutorStatusResponse({}));
  }

  async updateTodoTaskExecutorStatus(request: UpdateTodoTaskExecutorStatusRequest): Promise<UpdateTodoTaskExecutorStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new UpdateTodoTaskExecutorStatusHeaders({ });
    return await this.updateTodoTaskExecutorStatusWithOptions(request, headers, runtime);
  }

  async updateUserAvatarWithOptions(request: UpdateUserAvatarRequest, tmpHeader: UpdateUserAvatarHeaders, runtime: $Util.RuntimeOptions): Promise<UpdateUserAvatarResponse> {
    Util.validateModel(request);
    let headers = new UpdateUserAvatarShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.avatarMediaId)) {
      body["AvatarMediaId"] = request.avatarMediaId;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateUserAvatar",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/contact/updateUserAvatar`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateUserAvatarResponse>(await this.callApi(params, req, runtime), new UpdateUserAvatarResponse({}));
  }

  async updateUserAvatar(request: UpdateUserAvatarRequest): Promise<UpdateUserAvatarResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new UpdateUserAvatarHeaders({ });
    return await this.updateUserAvatarWithOptions(request, headers, runtime);
  }

  async updateWorkspaceDocMembersWithOptions(tmpReq: UpdateWorkspaceDocMembersRequest, tmpHeader: UpdateWorkspaceDocMembersHeaders, runtime: $Util.RuntimeOptions): Promise<UpdateWorkspaceDocMembersResponse> {
    Util.validateModel(tmpReq);
    let request = new UpdateWorkspaceDocMembersShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new UpdateWorkspaceDocMembersShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.members)) {
      request.membersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.members, "Members", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.membersShrink)) {
      body["Members"] = request.membersShrink;
    }

    if (!Util.isUnset(request.nodeId)) {
      body["NodeId"] = request.nodeId;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    if (!Util.isUnset(request.workspaceId)) {
      body["WorkspaceId"] = request.workspaceId;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateWorkspaceDocMembers",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/documents/updateWorkspaceDocMembers`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateWorkspaceDocMembersResponse>(await this.callApi(params, req, runtime), new UpdateWorkspaceDocMembersResponse({}));
  }

  async updateWorkspaceDocMembers(request: UpdateWorkspaceDocMembersRequest): Promise<UpdateWorkspaceDocMembersResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new UpdateWorkspaceDocMembersHeaders({ });
    return await this.updateWorkspaceDocMembersWithOptions(request, headers, runtime);
  }

  async updateWorkspaceMembersWithOptions(tmpReq: UpdateWorkspaceMembersRequest, tmpHeader: UpdateWorkspaceMembersHeaders, runtime: $Util.RuntimeOptions): Promise<UpdateWorkspaceMembersResponse> {
    Util.validateModel(tmpReq);
    let request = new UpdateWorkspaceMembersShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new UpdateWorkspaceMembersShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.members)) {
      request.membersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.members, "Members", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.membersShrink)) {
      body["Members"] = request.membersShrink;
    }

    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    if (!Util.isUnset(request.workspaceId)) {
      body["WorkspaceId"] = request.workspaceId;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateWorkspaceMembers",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/dingtalk/v1/documents/updateWorkspaceMembers`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateWorkspaceMembersResponse>(await this.callApi(params, req, runtime), new UpdateWorkspaceMembersResponse({}));
  }

  async updateWorkspaceMembers(request: UpdateWorkspaceMembersRequest): Promise<UpdateWorkspaceMembersResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new UpdateWorkspaceMembersHeaders({ });
    return await this.updateWorkspaceMembersWithOptions(request, headers, runtime);
  }

  async uploadMediaWithOptions(tmpReq: UploadMediaRequest, tmpHeader: UploadMediaHeaders, runtime: $Util.RuntimeOptions): Promise<UploadMediaResponse> {
    Util.validateModel(tmpReq);
    let request = new UploadMediaShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new UploadMediaShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    if (!Util.isUnset(request.mediaName)) {
      body["mediaName"] = request.mediaName;
    }

    if (!Util.isUnset(request.mediaType)) {
      body["mediaType"] = request.mediaType;
    }

    if (!Util.isUnset(request.orgId)) {
      body["orgId"] = request.orgId;
    }

    if (!Util.isUnset(request.url)) {
      body["url"] = request.url;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UploadMedia",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/aliding/v1/documents/uploadMedia`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UploadMediaResponse>(await this.callApi(params, req, runtime), new UploadMediaResponse({}));
  }

  async uploadMedia(request: UploadMediaRequest): Promise<UploadMediaResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new UploadMediaHeaders({ });
    return await this.uploadMediaWithOptions(request, headers, runtime);
  }

  async wearOrgHonorWithOptions(tmpReq: WearOrgHonorRequest, tmpHeader: WearOrgHonorHeaders, runtime: $Util.RuntimeOptions): Promise<WearOrgHonorResponse> {
    Util.validateModel(tmpReq);
    let request = new WearOrgHonorShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    let headers = new WearOrgHonorShrinkHeaders({ });
    OpenApiUtil.convert(tmpHeader, headers);
    if (!Util.isUnset(tmpHeader.accountContext)) {
      headers.accountContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpHeader.accountContext, "AccountContext", "json");
    }

    if (!Util.isUnset(tmpReq.tenantContext)) {
      request.tenantContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tenantContext, "TenantContext", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.tenantContextShrink)) {
      body["TenantContext"] = request.tenantContextShrink;
    }

    if (!Util.isUnset(request.honorId)) {
      body["honorId"] = request.honorId;
    }

    if (!Util.isUnset(request.orgId)) {
      body["orgId"] = request.orgId;
    }

    if (!Util.isUnset(request.userId)) {
      body["userId"] = request.userId;
    }

    if (!Util.isUnset(request.wear)) {
      body["wear"] = request.wear;
    }

    let realHeaders : {[key: string ]: string} = { };
    if (!Util.isUnset(headers.commonHeaders)) {
      realHeaders = headers.commonHeaders;
    }

    if (!Util.isUnset(headers.accountContextShrink)) {
      realHeaders["AccountContext"] = Util.toJSONString(headers.accountContextShrink);
    }

    let req = new $OpenApi.OpenApiRequest({
      headers: realHeaders,
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "WearOrgHonor",
      version: "2023-04-26",
      protocol: "HTTPS",
      pathname: `/aliding/v1/honor/wearOrgHonor`,
      method: "POST",
      authType: "AK",
      style: "ROA",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<WearOrgHonorResponse>(await this.callApi(params, req, runtime), new WearOrgHonorResponse({}));
  }

  async wearOrgHonor(request: WearOrgHonorRequest): Promise<WearOrgHonorResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    let headers = new WearOrgHonorHeaders({ });
    return await this.wearOrgHonorWithOptions(request, headers, runtime);
  }

}
