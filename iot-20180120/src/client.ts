// This file is auto-generated, don't edit it
import Util, * as $Util from '@alicloud/tea-util';
import RPCUtil from '@alicloud/rpc-util';
import RPC, * as $RPC from '@alicloud/rpc-client';
import EndpointUtil from '@alicloud/endpoint-util';
import * as $tea from '@alicloud/tea-typescript';

export class AddDataForApiSourceRequest extends $tea.Model {
  apiId: string;
  content: string;
  iotInstanceId: string;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      content: 'Content',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'string',
      content: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddDataForApiSourceResponse extends $tea.Model {
  code: string;
  data: number;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'number',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddShareTaskDeviceRequest extends $tea.Model {
  iotIdList?: string[];
  iotInstanceId?: string;
  productKey?: string;
  shareTaskId: string;
  static names(): { [key: string]: string } {
    return {
      iotIdList: 'IotIdList',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
      shareTaskId: 'ShareTaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotIdList: { 'type': 'array', 'itemType': 'string' },
      iotInstanceId: 'string',
      productKey: 'string',
      shareTaskId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddShareTaskDeviceResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: AddShareTaskDeviceResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: AddShareTaskDeviceResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AttachDestinationRequest extends $tea.Model {
  destinationId: number;
  iotInstanceId?: string;
  isFailover: boolean;
  parserId: number;
  static names(): { [key: string]: string } {
    return {
      destinationId: 'DestinationId',
      iotInstanceId: 'IotInstanceId',
      isFailover: 'IsFailover',
      parserId: 'ParserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      destinationId: 'number',
      iotInstanceId: 'string',
      isFailover: 'boolean',
      parserId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AttachDestinationResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AttachParserDataSourceRequest extends $tea.Model {
  dataSourceId: number;
  iotInstanceId?: string;
  parserId: number;
  static names(): { [key: string]: string } {
    return {
      dataSourceId: 'DataSourceId',
      iotInstanceId: 'IotInstanceId',
      parserId: 'ParserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataSourceId: 'number',
      iotInstanceId: 'string',
      parserId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AttachParserDataSourceResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchAddDataForApiSourceRequest extends $tea.Model {
  apiId: string;
  contentList: { [key: string]: any };
  iotInstanceId: string;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      contentList: 'ContentList',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'string',
      contentList: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchAddDataForApiSourceShrinkRequest extends $tea.Model {
  apiId: string;
  contentListShrink: string;
  iotInstanceId: string;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      contentListShrink: 'ContentList',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'string',
      contentListShrink: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchAddDataForApiSourceResponse extends $tea.Model {
  code: string;
  data: { [key: string]: any };
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchAddDeviceGroupRelationsRequest extends $tea.Model {
  device?: BatchAddDeviceGroupRelationsRequestDevice[];
  groupId: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      device: 'Device',
      groupId: 'GroupId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      device: { 'type': 'array', 'itemType': BatchAddDeviceGroupRelationsRequestDevice },
      groupId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchAddDeviceGroupRelationsResponse extends $tea.Model {
  alreadyRelatedGroupDeviceCount: number;
  code: string;
  errorMessage: string;
  exceedTenGroupDeviceCount: number;
  requestId: string;
  success: boolean;
  successAddedDeviceCount: number;
  validDeviceCount: number;
  static names(): { [key: string]: string } {
    return {
      alreadyRelatedGroupDeviceCount: 'AlreadyRelatedGroupDeviceCount',
      code: 'Code',
      errorMessage: 'ErrorMessage',
      exceedTenGroupDeviceCount: 'ExceedTenGroupDeviceCount',
      requestId: 'RequestId',
      success: 'Success',
      successAddedDeviceCount: 'SuccessAddedDeviceCount',
      validDeviceCount: 'ValidDeviceCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alreadyRelatedGroupDeviceCount: 'number',
      code: 'string',
      errorMessage: 'string',
      exceedTenGroupDeviceCount: 'number',
      requestId: 'string',
      success: 'boolean',
      successAddedDeviceCount: 'number',
      validDeviceCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchAddThingTopoRequest extends $tea.Model {
  gwDeviceName: string;
  gwProductKey: string;
  iotInstanceId?: string;
  topoAddItem: BatchAddThingTopoRequestTopoAddItem[];
  static names(): { [key: string]: string } {
    return {
      gwDeviceName: 'GwDeviceName',
      gwProductKey: 'GwProductKey',
      iotInstanceId: 'IotInstanceId',
      topoAddItem: 'TopoAddItem',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gwDeviceName: 'string',
      gwProductKey: 'string',
      iotInstanceId: 'string',
      topoAddItem: { 'type': 'array', 'itemType': BatchAddThingTopoRequestTopoAddItem },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchAddThingTopoResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchBindDeviceToEdgeInstanceWithDriverRequest extends $tea.Model {
  driverId: string;
  instanceId: string;
  iotIds: string[];
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      driverId: 'DriverId',
      instanceId: 'InstanceId',
      iotIds: 'IotIds',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      driverId: 'string',
      instanceId: 'string',
      iotIds: { 'type': 'array', 'itemType': 'string' },
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchBindDeviceToEdgeInstanceWithDriverResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchBindDevicesIntoProjectRequest extends $tea.Model {
  devices: BatchBindDevicesIntoProjectRequestDevices[];
  iotInstanceId?: string;
  projectId: string;
  static names(): { [key: string]: string } {
    return {
      devices: 'Devices',
      iotInstanceId: 'IotInstanceId',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      devices: { 'type': 'array', 'itemType': BatchBindDevicesIntoProjectRequestDevices },
      iotInstanceId: 'string',
      projectId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchBindDevicesIntoProjectResponse extends $tea.Model {
  code: string;
  data: boolean;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'boolean',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchBindProductsIntoProjectRequest extends $tea.Model {
  iotInstanceId?: string;
  productKeys: string[];
  projectId: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      productKeys: 'ProductKeys',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      productKeys: { 'type': 'array', 'itemType': 'string' },
      projectId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchBindProductsIntoProjectResponse extends $tea.Model {
  code: string;
  data: boolean;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'boolean',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCheckDeviceNamesRequest extends $tea.Model {
  deviceName?: string[];
  deviceNameList?: BatchCheckDeviceNamesRequestDeviceNameList[];
  iotInstanceId?: string;
  productKey: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      deviceNameList: 'DeviceNameList',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: { 'type': 'array', 'itemType': 'string' },
      deviceNameList: { 'type': 'array', 'itemType': BatchCheckDeviceNamesRequestDeviceNameList },
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCheckDeviceNamesResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: BatchCheckDeviceNamesResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: BatchCheckDeviceNamesResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCheckImportDeviceRequest extends $tea.Model {
  deviceList: BatchCheckImportDeviceRequestDeviceList[];
  iotInstanceId?: string;
  productKey: string;
  static names(): { [key: string]: string } {
    return {
      deviceList: 'DeviceList',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceList: { 'type': 'array', 'itemType': BatchCheckImportDeviceRequestDeviceList },
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCheckImportDeviceResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: BatchCheckImportDeviceResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: BatchCheckImportDeviceResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCheckVehicleDeviceRequest extends $tea.Model {
  deviceList: BatchCheckVehicleDeviceRequestDeviceList[];
  iotInstanceId?: string;
  productKey: string;
  static names(): { [key: string]: string } {
    return {
      deviceList: 'DeviceList',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceList: { 'type': 'array', 'itemType': BatchCheckVehicleDeviceRequestDeviceList },
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCheckVehicleDeviceResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: BatchCheckVehicleDeviceResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: BatchCheckVehicleDeviceResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchClearEdgeInstanceDeviceConfigRequest extends $tea.Model {
  instanceId: string;
  iotIds: string[];
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      iotIds: 'IotIds',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      iotIds: { 'type': 'array', 'itemType': 'string' },
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchClearEdgeInstanceDeviceConfigResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCreateSoundCodeLabelRequest extends $tea.Model {
  description?: string;
  iotInstanceId?: string;
  scheduleCode: string;
  total: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      iotInstanceId: 'IotInstanceId',
      scheduleCode: 'ScheduleCode',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      iotInstanceId: 'string',
      scheduleCode: 'string',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCreateSoundCodeLabelResponse extends $tea.Model {
  code: string;
  data: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCreateSoundCodeLabelWithLabelsRequest extends $tea.Model {
  description?: string;
  iotInstanceId?: string;
  labels: string[];
  scheduleCode: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      iotInstanceId: 'IotInstanceId',
      labels: 'Labels',
      scheduleCode: 'ScheduleCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      iotInstanceId: 'string',
      labels: { 'type': 'array', 'itemType': 'string' },
      scheduleCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCreateSoundCodeLabelWithLabelsResponse extends $tea.Model {
  code: string;
  data: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchDeleteDeviceGroupRelationsRequest extends $tea.Model {
  device?: BatchDeleteDeviceGroupRelationsRequestDevice[];
  groupId: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      device: 'Device',
      groupId: 'GroupId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      device: { 'type': 'array', 'itemType': BatchDeleteDeviceGroupRelationsRequestDevice },
      groupId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchDeleteDeviceGroupRelationsResponse extends $tea.Model {
  alreadyRelatedGroupDeviceCount: number;
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  successDeviceCount: number;
  validDeviceCount: number;
  static names(): { [key: string]: string } {
    return {
      alreadyRelatedGroupDeviceCount: 'AlreadyRelatedGroupDeviceCount',
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      successDeviceCount: 'SuccessDeviceCount',
      validDeviceCount: 'ValidDeviceCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alreadyRelatedGroupDeviceCount: 'number',
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      successDeviceCount: 'number',
      validDeviceCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchDeleteEdgeInstanceChannelRequest extends $tea.Model {
  channelIds: string[];
  driverId: string;
  instanceId: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      channelIds: 'ChannelIds',
      driverId: 'DriverId',
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelIds: { 'type': 'array', 'itemType': 'string' },
      driverId: 'string',
      instanceId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchDeleteEdgeInstanceChannelResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetDeviceBindStatusRequest extends $tea.Model {
  iotIds: string[];
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      iotIds: 'IotIds',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotIds: { 'type': 'array', 'itemType': 'string' },
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetDeviceBindStatusResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: BatchGetDeviceBindStatusResponseData[];
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: { 'type': 'array', 'itemType': BatchGetDeviceBindStatusResponseData },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetDeviceStateRequest extends $tea.Model {
  deviceName?: string[];
  iotId?: string[];
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: { 'type': 'array', 'itemType': 'string' },
      iotId: { 'type': 'array', 'itemType': 'string' },
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetDeviceStateResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  deviceStatusList: BatchGetDeviceStateResponseDeviceStatusList;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      deviceStatusList: 'DeviceStatusList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      deviceStatusList: BatchGetDeviceStateResponseDeviceStatusList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeDriverRequest extends $tea.Model {
  driverIds: string[];
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      driverIds: 'DriverIds',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      driverIds: { 'type': 'array', 'itemType': 'string' },
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeDriverResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  driverList: BatchGetEdgeDriverResponseDriverList[];
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      driverList: 'DriverList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      driverList: { 'type': 'array', 'itemType': BatchGetEdgeDriverResponseDriverList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeInstanceChannelRequest extends $tea.Model {
  channelIds: string[];
  driverId: string;
  instanceId: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      channelIds: 'ChannelIds',
      driverId: 'DriverId',
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelIds: { 'type': 'array', 'itemType': 'string' },
      driverId: 'string',
      instanceId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeInstanceChannelResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: BatchGetEdgeInstanceChannelResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: BatchGetEdgeInstanceChannelResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeInstanceDeviceChannelRequest extends $tea.Model {
  driverId: string;
  instanceId: string;
  iotIds: string[];
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      driverId: 'DriverId',
      instanceId: 'InstanceId',
      iotIds: 'IotIds',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      driverId: 'string',
      instanceId: 'string',
      iotIds: { 'type': 'array', 'itemType': 'string' },
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeInstanceDeviceChannelResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  deviceChannelList: BatchGetEdgeInstanceDeviceChannelResponseDeviceChannelList[];
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      deviceChannelList: 'DeviceChannelList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      deviceChannelList: { 'type': 'array', 'itemType': BatchGetEdgeInstanceDeviceChannelResponseDeviceChannelList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeInstanceDeviceConfigRequest extends $tea.Model {
  instanceId: string;
  iotIds: string[];
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      iotIds: 'IotIds',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      iotIds: { 'type': 'array', 'itemType': 'string' },
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeInstanceDeviceConfigResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  deviceConfigList: BatchGetEdgeInstanceDeviceConfigResponseDeviceConfigList[];
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      deviceConfigList: 'DeviceConfigList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      deviceConfigList: { 'type': 'array', 'itemType': BatchGetEdgeInstanceDeviceConfigResponseDeviceConfigList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeInstanceDeviceDriverRequest extends $tea.Model {
  instanceId: string;
  iotIds: string[];
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      iotIds: 'IotIds',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      iotIds: { 'type': 'array', 'itemType': 'string' },
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeInstanceDeviceDriverResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  deviceDriverList: BatchGetEdgeInstanceDeviceDriverResponseDeviceDriverList[];
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      deviceDriverList: 'DeviceDriverList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      deviceDriverList: { 'type': 'array', 'itemType': BatchGetEdgeInstanceDeviceDriverResponseDeviceDriverList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeInstanceDriverConfigsRequest extends $tea.Model {
  driverIds: string[];
  instanceId: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      driverIds: 'DriverIds',
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      driverIds: { 'type': 'array', 'itemType': 'string' },
      instanceId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeInstanceDriverConfigsResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  driverConfigList: BatchGetEdgeInstanceDriverConfigsResponseDriverConfigList[];
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      driverConfigList: 'DriverConfigList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      driverConfigList: { 'type': 'array', 'itemType': BatchGetEdgeInstanceDriverConfigsResponseDriverConfigList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchImportDeviceRequest extends $tea.Model {
  deviceList: BatchImportDeviceRequestDeviceList[];
  iotInstanceId?: string;
  productKey: string;
  static names(): { [key: string]: string } {
    return {
      deviceList: 'DeviceList',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceList: { 'type': 'array', 'itemType': BatchImportDeviceRequestDeviceList },
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchImportDeviceResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: BatchImportDeviceResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: BatchImportDeviceResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchImportVehicleDeviceRequest extends $tea.Model {
  deviceList: BatchImportVehicleDeviceRequestDeviceList[];
  iotInstanceId?: string;
  productKey: string;
  static names(): { [key: string]: string } {
    return {
      deviceList: 'DeviceList',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceList: { 'type': 'array', 'itemType': BatchImportVehicleDeviceRequestDeviceList },
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchImportVehicleDeviceResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: BatchImportVehicleDeviceResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: BatchImportVehicleDeviceResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchPubRequest extends $tea.Model {
  deviceName: string[];
  iotInstanceId?: string;
  messageContent: string;
  productKey: string;
  qos?: number;
  topicShortName: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotInstanceId: 'IotInstanceId',
      messageContent: 'MessageContent',
      productKey: 'ProductKey',
      qos: 'Qos',
      topicShortName: 'TopicShortName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: { 'type': 'array', 'itemType': 'string' },
      iotInstanceId: 'string',
      messageContent: 'string',
      productKey: 'string',
      qos: 'number',
      topicShortName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchPubResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchQueryDeviceDetailRequest extends $tea.Model {
  deviceName: string[];
  iotInstanceId?: string;
  productKey: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: { 'type': 'array', 'itemType': 'string' },
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchQueryDeviceDetailResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: BatchQueryDeviceDetailResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: BatchQueryDeviceDetailResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchRegisterDeviceRequest extends $tea.Model {
  count: number;
  iotInstanceId?: string;
  productKey: string;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchRegisterDeviceResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: BatchRegisterDeviceResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: BatchRegisterDeviceResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchRegisterDeviceWithApplyIdRequest extends $tea.Model {
  applyId: number;
  iotInstanceId?: string;
  productKey: string;
  static names(): { [key: string]: string } {
    return {
      applyId: 'ApplyId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applyId: 'number',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchRegisterDeviceWithApplyIdResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: BatchRegisterDeviceWithApplyIdResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: BatchRegisterDeviceWithApplyIdResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchSetEdgeInstanceDeviceChannelRequest extends $tea.Model {
  channelId: string;
  driverId: string;
  instanceId: string;
  iotIds: string[];
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      channelId: 'ChannelId',
      driverId: 'DriverId',
      instanceId: 'InstanceId',
      iotIds: 'IotIds',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelId: 'string',
      driverId: 'string',
      instanceId: 'string',
      iotIds: { 'type': 'array', 'itemType': 'string' },
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchSetEdgeInstanceDeviceChannelResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchSetEdgeInstanceDeviceConfigRequest extends $tea.Model {
  deviceConfigs: BatchSetEdgeInstanceDeviceConfigRequestDeviceConfigs[];
  instanceId: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      deviceConfigs: 'DeviceConfigs',
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceConfigs: { 'type': 'array', 'itemType': BatchSetEdgeInstanceDeviceConfigRequestDeviceConfigs },
      instanceId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchSetEdgeInstanceDeviceConfigResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchUnbindDeviceFromEdgeInstanceRequest extends $tea.Model {
  instanceId: string;
  iotIds: string[];
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      iotIds: 'IotIds',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      iotIds: { 'type': 'array', 'itemType': 'string' },
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchUnbindDeviceFromEdgeInstanceResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchUnbindProjectDevicesRequest extends $tea.Model {
  devices: BatchUnbindProjectDevicesRequestDevices[];
  iotInstanceId?: string;
  projectId: string;
  static names(): { [key: string]: string } {
    return {
      devices: 'Devices',
      iotInstanceId: 'IotInstanceId',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      devices: { 'type': 'array', 'itemType': BatchUnbindProjectDevicesRequestDevices },
      iotInstanceId: 'string',
      projectId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchUnbindProjectDevicesResponse extends $tea.Model {
  code: string;
  data: boolean;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'boolean',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchUnbindProjectProductsRequest extends $tea.Model {
  iotInstanceId?: string;
  productKeys: string[];
  projectId: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      productKeys: 'ProductKeys',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      productKeys: { 'type': 'array', 'itemType': 'string' },
      projectId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchUnbindProjectProductsResponse extends $tea.Model {
  code: string;
  data: boolean;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'boolean',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchUpdateDeviceNicknameRequest extends $tea.Model {
  deviceNicknameInfo: BatchUpdateDeviceNicknameRequestDeviceNicknameInfo[];
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      deviceNicknameInfo: 'DeviceNicknameInfo',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceNicknameInfo: { 'type': 'array', 'itemType': BatchUpdateDeviceNicknameRequestDeviceNicknameInfo },
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchUpdateDeviceNicknameResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BindApplicationToEdgeInstanceRequest extends $tea.Model {
  applicationId: string;
  applicationVersion: string;
  instanceId: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      applicationId: 'ApplicationId',
      applicationVersion: 'ApplicationVersion',
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applicationId: 'string',
      applicationVersion: 'string',
      instanceId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BindApplicationToEdgeInstanceResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BindDriverToEdgeInstanceRequest extends $tea.Model {
  driverId: string;
  driverVersion?: string;
  instanceId: string;
  iotInstanceId?: string;
  orderId?: string;
  static names(): { [key: string]: string } {
    return {
      driverId: 'DriverId',
      driverVersion: 'DriverVersion',
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
      orderId: 'OrderId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      driverId: 'string',
      driverVersion: 'string',
      instanceId: 'string',
      iotInstanceId: 'string',
      orderId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BindDriverToEdgeInstanceResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BindGatewayToEdgeInstanceRequest extends $tea.Model {
  deviceName?: string;
  instanceId: string;
  iotId?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      instanceId: 'InstanceId',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      instanceId: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BindGatewayToEdgeInstanceResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BindLicenseDeviceRequest extends $tea.Model {
  deviceNameList?: string[];
  iotIdList?: string[];
  iotInstanceId?: string;
  licenseCode: string;
  productKey: string;
  static names(): { [key: string]: string } {
    return {
      deviceNameList: 'DeviceNameList',
      iotIdList: 'IotIdList',
      iotInstanceId: 'IotInstanceId',
      licenseCode: 'LicenseCode',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceNameList: { 'type': 'array', 'itemType': 'string' },
      iotIdList: { 'type': 'array', 'itemType': 'string' },
      iotInstanceId: 'string',
      licenseCode: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BindLicenseDeviceResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: BindLicenseDeviceResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: BindLicenseDeviceResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BindLicenseProductRequest extends $tea.Model {
  iotInstanceId?: string;
  licenseCode: string;
  productKey: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      licenseCode: 'LicenseCode',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      licenseCode: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BindLicenseProductResponse extends $tea.Model {
  code: string;
  data: boolean;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'boolean',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BindRoleToEdgeInstanceRequest extends $tea.Model {
  instanceId: string;
  iotInstanceId?: string;
  roleArn: string;
  roleName: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
      roleArn: 'RoleArn',
      roleName: 'RoleName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      iotInstanceId: 'string',
      roleArn: 'string',
      roleName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BindRoleToEdgeInstanceResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BindSceneRuleToEdgeInstanceRequest extends $tea.Model {
  instanceId: string;
  iotInstanceId?: string;
  ruleId: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
      ruleId: 'RuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      iotInstanceId: 'string',
      ruleId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BindSceneRuleToEdgeInstanceResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelJobRequest extends $tea.Model {
  iotInstanceId?: string;
  jobId: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      jobId: 'JobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      jobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelJobResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelOTAStrategyByJobRequest extends $tea.Model {
  iotInstanceId?: string;
  jobId: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      jobId: 'JobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      jobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelOTAStrategyByJobResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelOTATaskByDeviceRequest extends $tea.Model {
  deviceName: string[];
  firmwareId: string;
  iotInstanceId?: string;
  jobId?: string;
  productKey: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      firmwareId: 'FirmwareId',
      iotInstanceId: 'IotInstanceId',
      jobId: 'JobId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: { 'type': 'array', 'itemType': 'string' },
      firmwareId: 'string',
      iotInstanceId: 'string',
      jobId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelOTATaskByDeviceResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelOTATaskByJobRequest extends $tea.Model {
  cancelInProgressTask?: boolean;
  cancelNotifiedTask?: boolean;
  cancelQueuedTask?: boolean;
  cancelScheduledTask?: boolean;
  cancelUnconfirmedTask?: boolean;
  iotInstanceId?: string;
  jobId: string;
  static names(): { [key: string]: string } {
    return {
      cancelInProgressTask: 'CancelInProgressTask',
      cancelNotifiedTask: 'CancelNotifiedTask',
      cancelQueuedTask: 'CancelQueuedTask',
      cancelScheduledTask: 'CancelScheduledTask',
      cancelUnconfirmedTask: 'CancelUnconfirmedTask',
      iotInstanceId: 'IotInstanceId',
      jobId: 'JobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cancelInProgressTask: 'boolean',
      cancelNotifiedTask: 'boolean',
      cancelQueuedTask: 'boolean',
      cancelScheduledTask: 'boolean',
      cancelUnconfirmedTask: 'boolean',
      iotInstanceId: 'string',
      jobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelOTATaskByJobResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelReleaseProductRequest extends $tea.Model {
  iotInstanceId?: string;
  productKey: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelReleaseProductResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CheckBindLicenseDeviceProgressRequest extends $tea.Model {
  checkProgressId: string;
  iotInstanceId?: string;
  licenseCode: string;
  productKey: string;
  static names(): { [key: string]: string } {
    return {
      checkProgressId: 'CheckProgressId',
      iotInstanceId: 'IotInstanceId',
      licenseCode: 'LicenseCode',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkProgressId: 'string',
      iotInstanceId: 'string',
      licenseCode: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CheckBindLicenseDeviceProgressResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: CheckBindLicenseDeviceProgressResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: CheckBindLicenseDeviceProgressResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ClearDeviceDesiredPropertyRequest extends $tea.Model {
  deviceName?: string;
  identifies?: string[];
  iotId?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      identifies: 'Identifies',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      identifies: { 'type': 'array', 'itemType': 'string' },
      iotId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ClearDeviceDesiredPropertyResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: ClearDeviceDesiredPropertyResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: ClearDeviceDesiredPropertyResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ClearEdgeInstanceDriverConfigsRequest extends $tea.Model {
  driverId: string;
  instanceId: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      driverId: 'DriverId',
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      driverId: 'string',
      instanceId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ClearEdgeInstanceDriverConfigsResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CloseDeviceTunnelRequest extends $tea.Model {
  tunnelId: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      tunnelId: 'TunnelId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tunnelId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CloseDeviceTunnelResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CloseEdgeInstanceDeploymentRequest extends $tea.Model {
  instanceId: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CloseEdgeInstanceDeploymentResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ConfirmOTATaskRequest extends $tea.Model {
  iotInstanceId?: string;
  taskId: string[];
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      taskId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ConfirmOTATaskResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CopyThingModelRequest extends $tea.Model {
  iotInstanceId?: string;
  resourceGroupId?: string;
  sourceModelVersion?: string;
  sourceProductKey: string;
  targetProductKey: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      resourceGroupId: 'ResourceGroupId',
      sourceModelVersion: 'SourceModelVersion',
      sourceProductKey: 'SourceProductKey',
      targetProductKey: 'TargetProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      resourceGroupId: 'string',
      sourceModelVersion: 'string',
      sourceProductKey: 'string',
      targetProductKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CopyThingModelResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CountSpeechBroadcastHourRequest extends $tea.Model {
  iotInstanceId?: string;
  queryDateTimeHour: string;
  shareTaskCode: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      queryDateTimeHour: 'QueryDateTimeHour',
      shareTaskCode: 'ShareTaskCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      queryDateTimeHour: 'string',
      shareTaskCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CountSpeechBroadcastHourResponse extends $tea.Model {
  code: string;
  data: number;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'number',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateConsumerGroupRequest extends $tea.Model {
  groupName: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      groupName: 'GroupName',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupName: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateConsumerGroupResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  groupId: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      groupId: 'GroupId',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      groupId: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateConsumerGroupSubscribeRelationRequest extends $tea.Model {
  consumerGroupId: string;
  iotInstanceId?: string;
  productKey: string;
  static names(): { [key: string]: string } {
    return {
      consumerGroupId: 'ConsumerGroupId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consumerGroupId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateConsumerGroupSubscribeRelationResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataAPIServiceRequest extends $tea.Model {
  displayName: string;
  originSql: string;
  requestParam?: CreateDataAPIServiceRequestRequestParam[];
  desc?: string;
  responseParam?: CreateDataAPIServiceRequestResponseParam[];
  templateSql: string;
  apiPath: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      displayName: 'DisplayName',
      originSql: 'OriginSql',
      requestParam: 'RequestParam',
      desc: 'Desc',
      responseParam: 'ResponseParam',
      templateSql: 'TemplateSql',
      apiPath: 'ApiPath',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      displayName: 'string',
      originSql: 'string',
      requestParam: { 'type': 'array', 'itemType': CreateDataAPIServiceRequestRequestParam },
      desc: 'string',
      responseParam: { 'type': 'array', 'itemType': CreateDataAPIServiceRequestResponseParam },
      templateSql: 'string',
      apiPath: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataAPIServiceResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: CreateDataAPIServiceResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: CreateDataAPIServiceResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataSourceItemRequest extends $tea.Model {
  dataSourceId: number;
  deviceName?: string;
  iotInstanceId?: string;
  productKey?: string;
  scopeType?: string;
  topic: string;
  static names(): { [key: string]: string } {
    return {
      dataSourceId: 'DataSourceId',
      deviceName: 'DeviceName',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
      scopeType: 'ScopeType',
      topic: 'Topic',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataSourceId: 'number',
      deviceName: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
      scopeType: 'string',
      topic: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataSourceItemResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDestinationRequest extends $tea.Model {
  configuration: string;
  description?: string;
  iotInstanceId?: string;
  name: string;
  type: string;
  static names(): { [key: string]: string } {
    return {
      configuration: 'Configuration',
      description: 'Description',
      iotInstanceId: 'IotInstanceId',
      name: 'Name',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configuration: 'string',
      description: 'string',
      iotInstanceId: 'string',
      name: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDestinationResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  destination: CreateDestinationResponseDestination;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      destination: 'Destination',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      destination: CreateDestinationResponseDestination,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDeviceDistributeJobRequest extends $tea.Model {
  deviceName: string[];
  sourceInstanceId: string;
  productKey: string;
  targetUid?: string;
  targetAliyunId?: string;
  targetInstanceConfig: CreateDeviceDistributeJobRequestTargetInstanceConfig[];
  strategy: number;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      sourceInstanceId: 'SourceInstanceId',
      productKey: 'ProductKey',
      targetUid: 'TargetUid',
      targetAliyunId: 'TargetAliyunId',
      targetInstanceConfig: 'TargetInstanceConfig',
      strategy: 'Strategy',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: { 'type': 'array', 'itemType': 'string' },
      sourceInstanceId: 'string',
      productKey: 'string',
      targetUid: 'string',
      targetAliyunId: 'string',
      targetInstanceConfig: { 'type': 'array', 'itemType': CreateDeviceDistributeJobRequestTargetInstanceConfig },
      strategy: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDeviceDistributeJobResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  jobId: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      jobId: 'JobId',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      jobId: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDeviceDynamicGroupRequest extends $tea.Model {
  dynamicGroupExpression: string;
  groupDesc?: string;
  groupName: string;
  iotInstanceId: string;
  static names(): { [key: string]: string } {
    return {
      dynamicGroupExpression: 'DynamicGroupExpression',
      groupDesc: 'GroupDesc',
      groupName: 'GroupName',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dynamicGroupExpression: 'string',
      groupDesc: 'string',
      groupName: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDeviceDynamicGroupResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: CreateDeviceDynamicGroupResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: CreateDeviceDynamicGroupResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDeviceGroupRequest extends $tea.Model {
  groupDesc?: string;
  groupName: string;
  iotInstanceId?: string;
  superGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      groupDesc: 'GroupDesc',
      groupName: 'GroupName',
      iotInstanceId: 'IotInstanceId',
      superGroupId: 'SuperGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupDesc: 'string',
      groupName: 'string',
      iotInstanceId: 'string',
      superGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDeviceGroupResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: CreateDeviceGroupResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: CreateDeviceGroupResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDeviceTunnelRequest extends $tea.Model {
  iotId?: string;
  description?: string;
  udi?: string;
  productKey?: string;
  deviceName?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      iotId: 'IotId',
      description: 'Description',
      udi: 'Udi',
      productKey: 'ProductKey',
      deviceName: 'DeviceName',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotId: 'string',
      description: 'string',
      udi: 'string',
      productKey: 'string',
      deviceName: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDeviceTunnelResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: CreateDeviceTunnelResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: CreateDeviceTunnelResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDownloadDataJobRequest extends $tea.Model {
  context?: { [key: string]: any };
  downloadDataType: string;
  endTime?: number;
  fileConfig?: { [key: string]: any };
  iotInstanceId?: string;
  startTime?: number;
  tableName: string;
  static names(): { [key: string]: string } {
    return {
      context: 'Context',
      downloadDataType: 'DownloadDataType',
      endTime: 'EndTime',
      fileConfig: 'FileConfig',
      iotInstanceId: 'IotInstanceId',
      startTime: 'StartTime',
      tableName: 'TableName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      context: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      downloadDataType: 'string',
      endTime: 'number',
      fileConfig: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      iotInstanceId: 'string',
      startTime: 'number',
      tableName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDownloadDataJobShrinkRequest extends $tea.Model {
  contextShrink?: string;
  downloadDataType: string;
  endTime?: number;
  fileConfigShrink?: string;
  iotInstanceId?: string;
  startTime?: number;
  tableName: string;
  static names(): { [key: string]: string } {
    return {
      contextShrink: 'Context',
      downloadDataType: 'DownloadDataType',
      endTime: 'EndTime',
      fileConfigShrink: 'FileConfig',
      iotInstanceId: 'IotInstanceId',
      startTime: 'StartTime',
      tableName: 'TableName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contextShrink: 'string',
      downloadDataType: 'string',
      endTime: 'number',
      fileConfigShrink: 'string',
      iotInstanceId: 'string',
      startTime: 'number',
      tableName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDownloadDataJobResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: CreateDownloadDataJobResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: CreateDownloadDataJobResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeDriverRequest extends $tea.Model {
  cpuArch?: string;
  driverName: string;
  driverProtocol: string;
  iotInstanceId?: string;
  isBuiltIn?: boolean;
  runtime: string;
  static names(): { [key: string]: string } {
    return {
      cpuArch: 'CpuArch',
      driverName: 'DriverName',
      driverProtocol: 'DriverProtocol',
      iotInstanceId: 'IotInstanceId',
      isBuiltIn: 'IsBuiltIn',
      runtime: 'Runtime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cpuArch: 'string',
      driverName: 'string',
      driverProtocol: 'string',
      iotInstanceId: 'string',
      isBuiltIn: 'boolean',
      runtime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeDriverResponse extends $tea.Model {
  code: string;
  driverId: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      driverId: 'DriverId',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      driverId: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeDriverVersionRequest extends $tea.Model {
  argument?: string;
  configCheckRule?: string;
  containerConfig?: string;
  description?: string;
  driverConfig?: string;
  driverId: string;
  driverVersion: string;
  edgeVersion: string;
  iotInstanceId?: string;
  sourceConfig?: string;
  static names(): { [key: string]: string } {
    return {
      argument: 'Argument',
      configCheckRule: 'ConfigCheckRule',
      containerConfig: 'ContainerConfig',
      description: 'Description',
      driverConfig: 'DriverConfig',
      driverId: 'DriverId',
      driverVersion: 'DriverVersion',
      edgeVersion: 'EdgeVersion',
      iotInstanceId: 'IotInstanceId',
      sourceConfig: 'SourceConfig',
    };
  }

  static types(): { [key: string]: any } {
    return {
      argument: 'string',
      configCheckRule: 'string',
      containerConfig: 'string',
      description: 'string',
      driverConfig: 'string',
      driverId: 'string',
      driverVersion: 'string',
      edgeVersion: 'string',
      iotInstanceId: 'string',
      sourceConfig: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeDriverVersionResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeInstanceRequest extends $tea.Model {
  iotInstanceId?: string;
  name: string;
  spec?: number;
  tags?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      name: 'Name',
      spec: 'Spec',
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      name: 'string',
      spec: 'number',
      tags: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeInstanceResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  instanceId: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      instanceId: 'InstanceId',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      instanceId: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeInstanceChannelRequest extends $tea.Model {
  channelName: string;
  configs: CreateEdgeInstanceChannelRequestConfigs[];
  driverId: string;
  instanceId: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      channelName: 'ChannelName',
      configs: 'Configs',
      driverId: 'DriverId',
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelName: 'string',
      configs: { 'type': 'array', 'itemType': CreateEdgeInstanceChannelRequestConfigs },
      driverId: 'string',
      instanceId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeInstanceChannelResponse extends $tea.Model {
  code: string;
  data: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeInstanceDeploymentRequest extends $tea.Model {
  instanceId: string;
  iotInstanceId?: string;
  type: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      iotInstanceId: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeInstanceDeploymentResponse extends $tea.Model {
  code: string;
  deploymentId: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      deploymentId: 'DeploymentId',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      deploymentId: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeInstanceMessageRoutingRequest extends $tea.Model {
  instanceId: string;
  iotInstanceId?: string;
  name?: string;
  sourceData?: string;
  sourceType: string;
  targetData?: string;
  targetIotHubQos?: number;
  targetType: string;
  topicFilter?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
      name: 'Name',
      sourceData: 'SourceData',
      sourceType: 'SourceType',
      targetData: 'TargetData',
      targetIotHubQos: 'TargetIotHubQos',
      targetType: 'TargetType',
      topicFilter: 'TopicFilter',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      iotInstanceId: 'string',
      name: 'string',
      sourceData: 'string',
      sourceType: 'string',
      targetData: 'string',
      targetIotHubQos: 'number',
      targetType: 'string',
      topicFilter: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeInstanceMessageRoutingResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  routeId: number;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      routeId: 'RouteId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      routeId: 'number',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeOssPreSignedAddressRequest extends $tea.Model {
  fileName: string;
  instanceId?: string;
  iotInstanceId?: string;
  resourceId: string;
  resourceVersion: string;
  type: string;
  static names(): { [key: string]: string } {
    return {
      fileName: 'FileName',
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
      resourceId: 'ResourceId',
      resourceVersion: 'ResourceVersion',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fileName: 'string',
      instanceId: 'string',
      iotInstanceId: 'string',
      resourceId: 'string',
      resourceVersion: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeOssPreSignedAddressResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: CreateEdgeOssPreSignedAddressResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: CreateEdgeOssPreSignedAddressResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateJobRequest extends $tea.Model {
  description?: string;
  iotInstanceId?: string;
  jobDocument: string;
  jobFile?: { [key: string]: any };
  jobName: string;
  rolloutConfig?: { [key: string]: any };
  scheduledTime?: number;
  targetConfig: { [key: string]: any };
  timeoutConfig?: { [key: string]: any };
  type: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      iotInstanceId: 'IotInstanceId',
      jobDocument: 'JobDocument',
      jobFile: 'JobFile',
      jobName: 'JobName',
      rolloutConfig: 'RolloutConfig',
      scheduledTime: 'ScheduledTime',
      targetConfig: 'TargetConfig',
      timeoutConfig: 'TimeoutConfig',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      iotInstanceId: 'string',
      jobDocument: 'string',
      jobFile: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      jobName: 'string',
      rolloutConfig: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      scheduledTime: 'number',
      targetConfig: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      timeoutConfig: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateJobShrinkRequest extends $tea.Model {
  description?: string;
  iotInstanceId?: string;
  jobDocument: string;
  jobFileShrink?: string;
  jobName: string;
  rolloutConfigShrink?: string;
  scheduledTime?: number;
  targetConfigShrink: string;
  timeoutConfigShrink?: string;
  type: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      iotInstanceId: 'IotInstanceId',
      jobDocument: 'JobDocument',
      jobFileShrink: 'JobFile',
      jobName: 'JobName',
      rolloutConfigShrink: 'RolloutConfig',
      scheduledTime: 'ScheduledTime',
      targetConfigShrink: 'TargetConfig',
      timeoutConfigShrink: 'TimeoutConfig',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      iotInstanceId: 'string',
      jobDocument: 'string',
      jobFileShrink: 'string',
      jobName: 'string',
      rolloutConfigShrink: 'string',
      scheduledTime: 'number',
      targetConfigShrink: 'string',
      timeoutConfigShrink: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateJobResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  jobId: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      jobId: 'JobId',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      jobId: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLoRaNodesTaskRequest extends $tea.Model {
  deviceInfo: CreateLoRaNodesTaskRequestDeviceInfo[];
  iotInstanceId?: string;
  productKey: string;
  static names(): { [key: string]: string } {
    return {
      deviceInfo: 'DeviceInfo',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceInfo: { 'type': 'array', 'itemType': CreateLoRaNodesTaskRequestDeviceInfo },
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLoRaNodesTaskResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  taskId: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      taskId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOTADynamicUpgradeJobRequest extends $tea.Model {
  downloadProtocol?: string;
  dynamicMode?: number;
  firmwareId: string;
  groupId?: string;
  groupType?: string;
  iotInstanceId?: string;
  maximumPerMinute?: number;
  multiModuleMode?: boolean;
  needConfirm?: boolean;
  needPush?: boolean;
  overwriteMode?: number;
  productKey: string;
  retryCount?: number;
  retryInterval?: number;
  srcVersion?: string[];
  tag?: CreateOTADynamicUpgradeJobRequestTag[];
  timeoutInMinutes?: number;
  static names(): { [key: string]: string } {
    return {
      downloadProtocol: 'DownloadProtocol',
      dynamicMode: 'DynamicMode',
      firmwareId: 'FirmwareId',
      groupId: 'GroupId',
      groupType: 'GroupType',
      iotInstanceId: 'IotInstanceId',
      maximumPerMinute: 'MaximumPerMinute',
      multiModuleMode: 'MultiModuleMode',
      needConfirm: 'NeedConfirm',
      needPush: 'NeedPush',
      overwriteMode: 'OverwriteMode',
      productKey: 'ProductKey',
      retryCount: 'RetryCount',
      retryInterval: 'RetryInterval',
      srcVersion: 'SrcVersion',
      tag: 'Tag',
      timeoutInMinutes: 'TimeoutInMinutes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      downloadProtocol: 'string',
      dynamicMode: 'number',
      firmwareId: 'string',
      groupId: 'string',
      groupType: 'string',
      iotInstanceId: 'string',
      maximumPerMinute: 'number',
      multiModuleMode: 'boolean',
      needConfirm: 'boolean',
      needPush: 'boolean',
      overwriteMode: 'number',
      productKey: 'string',
      retryCount: 'number',
      retryInterval: 'number',
      srcVersion: { 'type': 'array', 'itemType': 'string' },
      tag: { 'type': 'array', 'itemType': CreateOTADynamicUpgradeJobRequestTag },
      timeoutInMinutes: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOTADynamicUpgradeJobResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: CreateOTADynamicUpgradeJobResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: CreateOTADynamicUpgradeJobResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOTAFirmwareRequest extends $tea.Model {
  destVersion: string;
  firmwareDesc?: string;
  firmwareName: string;
  firmwareSign?: string;
  firmwareSize?: number;
  firmwareUrl?: string;
  iotInstanceId?: string;
  moduleName?: string;
  multiFiles?: CreateOTAFirmwareRequestMultiFiles[];
  needToVerify?: boolean;
  productKey?: string;
  signMethod?: string;
  srcVersion?: string;
  type?: number;
  udi?: string;
  static names(): { [key: string]: string } {
    return {
      destVersion: 'DestVersion',
      firmwareDesc: 'FirmwareDesc',
      firmwareName: 'FirmwareName',
      firmwareSign: 'FirmwareSign',
      firmwareSize: 'FirmwareSize',
      firmwareUrl: 'FirmwareUrl',
      iotInstanceId: 'IotInstanceId',
      moduleName: 'ModuleName',
      multiFiles: 'MultiFiles',
      needToVerify: 'NeedToVerify',
      productKey: 'ProductKey',
      signMethod: 'SignMethod',
      srcVersion: 'SrcVersion',
      type: 'Type',
      udi: 'Udi',
    };
  }

  static types(): { [key: string]: any } {
    return {
      destVersion: 'string',
      firmwareDesc: 'string',
      firmwareName: 'string',
      firmwareSign: 'string',
      firmwareSize: 'number',
      firmwareUrl: 'string',
      iotInstanceId: 'string',
      moduleName: 'string',
      multiFiles: { 'type': 'array', 'itemType': CreateOTAFirmwareRequestMultiFiles },
      needToVerify: 'boolean',
      productKey: 'string',
      signMethod: 'string',
      srcVersion: 'string',
      type: 'number',
      udi: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOTAFirmwareResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: CreateOTAFirmwareResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: CreateOTAFirmwareResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOTAModuleRequest extends $tea.Model {
  aliasName?: string;
  desc?: string;
  iotInstanceId?: string;
  moduleName: string;
  productKey: string;
  static names(): { [key: string]: string } {
    return {
      aliasName: 'AliasName',
      desc: 'Desc',
      iotInstanceId: 'IotInstanceId',
      moduleName: 'ModuleName',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliasName: 'string',
      desc: 'string',
      iotInstanceId: 'string',
      moduleName: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOTAModuleResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOTAStaticUpgradeJobRequest extends $tea.Model {
  dnListFileUrl?: string;
  downloadProtocol?: string;
  firmwareId: string;
  grayPercent?: string;
  groupId?: string;
  groupType?: string;
  iotInstanceId?: string;
  maximumPerMinute?: number;
  multiModuleMode?: boolean;
  needConfirm?: boolean;
  needPush?: boolean;
  overwriteMode?: number;
  productKey: string;
  retryCount?: number;
  retryInterval?: number;
  scheduleFinishTime?: number;
  scheduleTime?: number;
  srcVersion?: string[];
  tag?: CreateOTAStaticUpgradeJobRequestTag[];
  targetDeviceName?: string[];
  targetSelection: string;
  timeoutInMinutes?: number;
  static names(): { [key: string]: string } {
    return {
      dnListFileUrl: 'DnListFileUrl',
      downloadProtocol: 'DownloadProtocol',
      firmwareId: 'FirmwareId',
      grayPercent: 'GrayPercent',
      groupId: 'GroupId',
      groupType: 'GroupType',
      iotInstanceId: 'IotInstanceId',
      maximumPerMinute: 'MaximumPerMinute',
      multiModuleMode: 'MultiModuleMode',
      needConfirm: 'NeedConfirm',
      needPush: 'NeedPush',
      overwriteMode: 'OverwriteMode',
      productKey: 'ProductKey',
      retryCount: 'RetryCount',
      retryInterval: 'RetryInterval',
      scheduleFinishTime: 'ScheduleFinishTime',
      scheduleTime: 'ScheduleTime',
      srcVersion: 'SrcVersion',
      tag: 'Tag',
      targetDeviceName: 'TargetDeviceName',
      targetSelection: 'TargetSelection',
      timeoutInMinutes: 'TimeoutInMinutes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dnListFileUrl: 'string',
      downloadProtocol: 'string',
      firmwareId: 'string',
      grayPercent: 'string',
      groupId: 'string',
      groupType: 'string',
      iotInstanceId: 'string',
      maximumPerMinute: 'number',
      multiModuleMode: 'boolean',
      needConfirm: 'boolean',
      needPush: 'boolean',
      overwriteMode: 'number',
      productKey: 'string',
      retryCount: 'number',
      retryInterval: 'number',
      scheduleFinishTime: 'number',
      scheduleTime: 'number',
      srcVersion: { 'type': 'array', 'itemType': 'string' },
      tag: { 'type': 'array', 'itemType': CreateOTAStaticUpgradeJobRequestTag },
      targetDeviceName: { 'type': 'array', 'itemType': 'string' },
      targetSelection: 'string',
      timeoutInMinutes: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOTAStaticUpgradeJobResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: CreateOTAStaticUpgradeJobResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: CreateOTAStaticUpgradeJobResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOTAVerifyJobRequest extends $tea.Model {
  downloadProtocol?: string;
  firmwareId: string;
  iotInstanceId?: string;
  needConfirm?: boolean;
  needPush?: boolean;
  productKey: string;
  tag?: CreateOTAVerifyJobRequestTag[];
  targetDeviceName: string[];
  timeoutInMinutes?: number;
  static names(): { [key: string]: string } {
    return {
      downloadProtocol: 'DownloadProtocol',
      firmwareId: 'FirmwareId',
      iotInstanceId: 'IotInstanceId',
      needConfirm: 'NeedConfirm',
      needPush: 'NeedPush',
      productKey: 'ProductKey',
      tag: 'Tag',
      targetDeviceName: 'TargetDeviceName',
      timeoutInMinutes: 'TimeoutInMinutes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      downloadProtocol: 'string',
      firmwareId: 'string',
      iotInstanceId: 'string',
      needConfirm: 'boolean',
      needPush: 'boolean',
      productKey: 'string',
      tag: { 'type': 'array', 'itemType': CreateOTAVerifyJobRequestTag },
      targetDeviceName: { 'type': 'array', 'itemType': 'string' },
      timeoutInMinutes: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOTAVerifyJobResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: CreateOTAVerifyJobResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: CreateOTAVerifyJobResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateParserRequest extends $tea.Model {
  description?: string;
  iotInstanceId?: string;
  name: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      iotInstanceId: 'IotInstanceId',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      iotInstanceId: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateParserResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  parserId: number;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      parserId: 'ParserId',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      parserId: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateParserDataSourceRequest extends $tea.Model {
  description?: string;
  iotInstanceId?: string;
  name: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      iotInstanceId: 'IotInstanceId',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      iotInstanceId: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateParserDataSourceResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  dataSource: CreateParserDataSourceResponseDataSource;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      dataSource: 'DataSource',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      dataSource: CreateParserDataSourceResponseDataSource,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProductRequest extends $tea.Model {
  aliyunCommodityCode?: string;
  authType?: string;
  categoryKey?: string;
  dataFormat?: number;
  description?: string;
  id2?: boolean;
  iotInstanceId?: string;
  joinPermissionId?: string;
  netType?: string;
  nodeType: number;
  productName: string;
  protocolType?: string;
  publishAuto?: boolean;
  resourceGroupId?: string;
  validateType?: number;
  static names(): { [key: string]: string } {
    return {
      aliyunCommodityCode: 'AliyunCommodityCode',
      authType: 'AuthType',
      categoryKey: 'CategoryKey',
      dataFormat: 'DataFormat',
      description: 'Description',
      id2: 'Id2',
      iotInstanceId: 'IotInstanceId',
      joinPermissionId: 'JoinPermissionId',
      netType: 'NetType',
      nodeType: 'NodeType',
      productName: 'ProductName',
      protocolType: 'ProtocolType',
      publishAuto: 'PublishAuto',
      resourceGroupId: 'ResourceGroupId',
      validateType: 'ValidateType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunCommodityCode: 'string',
      authType: 'string',
      categoryKey: 'string',
      dataFormat: 'number',
      description: 'string',
      id2: 'boolean',
      iotInstanceId: 'string',
      joinPermissionId: 'string',
      netType: 'string',
      nodeType: 'number',
      productName: 'string',
      protocolType: 'string',
      publishAuto: 'boolean',
      resourceGroupId: 'string',
      validateType: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProductResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  productKey: string;
  requestId: string;
  success: boolean;
  data: CreateProductResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      productKey: 'ProductKey',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      productKey: 'string',
      requestId: 'string',
      success: 'boolean',
      data: CreateProductResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProductDistributeJobRequest extends $tea.Model {
  productKey: string;
  sourceInstanceId: string;
  targetAliyunId?: string;
  targetInstanceId: string;
  targetUid?: string;
  static names(): { [key: string]: string } {
    return {
      productKey: 'ProductKey',
      sourceInstanceId: 'SourceInstanceId',
      targetAliyunId: 'TargetAliyunId',
      targetInstanceId: 'TargetInstanceId',
      targetUid: 'TargetUid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      productKey: 'string',
      sourceInstanceId: 'string',
      targetAliyunId: 'string',
      targetInstanceId: 'string',
      targetUid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProductDistributeJobResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  jobId: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      jobId: 'JobId',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      jobId: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProductTagsRequest extends $tea.Model {
  iotInstanceId?: string;
  productKey: string;
  productTag: CreateProductTagsRequestProductTag[];
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
      productTag: 'ProductTag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      productKey: 'string',
      productTag: { 'type': 'array', 'itemType': CreateProductTagsRequestProductTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProductTagsResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  invalidProductTags: CreateProductTagsResponseInvalidProductTags;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      invalidProductTags: 'InvalidProductTags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      invalidProductTags: CreateProductTagsResponseInvalidProductTags,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProductTopicRequest extends $tea.Model {
  desc?: string;
  iotInstanceId?: string;
  operation: string;
  productKey: string;
  topicShortName: string;
  static names(): { [key: string]: string } {
    return {
      desc: 'Desc',
      iotInstanceId: 'IotInstanceId',
      operation: 'Operation',
      productKey: 'ProductKey',
      topicShortName: 'TopicShortName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      desc: 'string',
      iotInstanceId: 'string',
      operation: 'string',
      productKey: 'string',
      topicShortName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProductTopicResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  topicId: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      topicId: 'TopicId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      topicId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRuleRequest extends $tea.Model {
  dataType?: string;
  iotInstanceId?: string;
  name: string;
  productKey?: string;
  resourceGroupId?: string;
  ruleDesc?: string;
  select?: string;
  shortTopic?: string;
  topic?: string;
  topicType?: number;
  where?: string;
  static names(): { [key: string]: string } {
    return {
      dataType: 'DataType',
      iotInstanceId: 'IotInstanceId',
      name: 'Name',
      productKey: 'ProductKey',
      resourceGroupId: 'ResourceGroupId',
      ruleDesc: 'RuleDesc',
      select: 'Select',
      shortTopic: 'ShortTopic',
      topic: 'Topic',
      topicType: 'TopicType',
      where: 'Where',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataType: 'string',
      iotInstanceId: 'string',
      name: 'string',
      productKey: 'string',
      resourceGroupId: 'string',
      ruleDesc: 'string',
      select: 'string',
      shortTopic: 'string',
      topic: 'string',
      topicType: 'number',
      where: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRuleResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  ruleId: number;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      ruleId: 'RuleId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      ruleId: 'number',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRuleActionRequest extends $tea.Model {
  configuration: string;
  errorActionFlag?: boolean;
  iotInstanceId?: string;
  ruleId: number;
  type: string;
  static names(): { [key: string]: string } {
    return {
      configuration: 'Configuration',
      errorActionFlag: 'ErrorActionFlag',
      iotInstanceId: 'IotInstanceId',
      ruleId: 'RuleId',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configuration: 'string',
      errorActionFlag: 'boolean',
      iotInstanceId: 'string',
      ruleId: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRuleActionResponse extends $tea.Model {
  actionId: number;
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      actionId: 'ActionId',
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actionId: 'number',
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSceneRuleRequest extends $tea.Model {
  iotInstanceId?: string;
  ruleContent?: string;
  ruleDescription?: string;
  ruleName: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      ruleContent: 'RuleContent',
      ruleDescription: 'RuleDescription',
      ruleName: 'RuleName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      ruleContent: 'string',
      ruleDescription: 'string',
      ruleName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSceneRuleResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  ruleId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      ruleId: 'RuleId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      ruleId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSchedulePeriodRequest extends $tea.Model {
  description: string;
  endTime: string;
  iotInstanceId?: string;
  scheduleCode: string;
  soundCodeContent: string;
  startTime: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      endTime: 'EndTime',
      iotInstanceId: 'IotInstanceId',
      scheduleCode: 'ScheduleCode',
      soundCodeContent: 'SoundCodeContent',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      endTime: 'string',
      iotInstanceId: 'string',
      scheduleCode: 'string',
      soundCodeContent: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSchedulePeriodResponse extends $tea.Model {
  code: string;
  data: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSoundCodeRequest extends $tea.Model {
  duration: number;
  iotInstanceId?: string;
  name?: string;
  openType?: string;
  soundCodeContent: string;
  static names(): { [key: string]: string } {
    return {
      duration: 'Duration',
      iotInstanceId: 'IotInstanceId',
      name: 'Name',
      openType: 'OpenType',
      soundCodeContent: 'SoundCodeContent',
    };
  }

  static types(): { [key: string]: any } {
    return {
      duration: 'number',
      iotInstanceId: 'string',
      name: 'string',
      openType: 'string',
      soundCodeContent: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSoundCodeResponse extends $tea.Model {
  code: string;
  data: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSoundCodeLabelRequest extends $tea.Model {
  iotInstanceId?: string;
  label: string;
  scheduleCode: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      label: 'Label',
      scheduleCode: 'ScheduleCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      label: 'string',
      scheduleCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSoundCodeLabelResponse extends $tea.Model {
  code: string;
  data: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSoundCodeScheduleRequest extends $tea.Model {
  description?: string;
  endDate: string;
  iotInstanceId?: string;
  name: string;
  openType?: string;
  startDate: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      endDate: 'EndDate',
      iotInstanceId: 'IotInstanceId',
      name: 'Name',
      openType: 'OpenType',
      startDate: 'StartDate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      endDate: 'string',
      iotInstanceId: 'string',
      name: 'string',
      openType: 'string',
      startDate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSoundCodeScheduleResponse extends $tea.Model {
  code: string;
  data: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSpeechRequest extends $tea.Model {
  audioFormat?: string;
  bizCode?: string;
  enableSoundCode?: boolean;
  iotInstanceId?: string;
  projectCode: string;
  soundCodeConfig?: { [key: string]: any };
  speechRate?: number;
  speechType?: string;
  text?: string;
  voice: string;
  volume?: number;
  static names(): { [key: string]: string } {
    return {
      audioFormat: 'AudioFormat',
      bizCode: 'BizCode',
      enableSoundCode: 'EnableSoundCode',
      iotInstanceId: 'IotInstanceId',
      projectCode: 'ProjectCode',
      soundCodeConfig: 'SoundCodeConfig',
      speechRate: 'SpeechRate',
      speechType: 'SpeechType',
      text: 'Text',
      voice: 'Voice',
      volume: 'Volume',
    };
  }

  static types(): { [key: string]: any } {
    return {
      audioFormat: 'string',
      bizCode: 'string',
      enableSoundCode: 'boolean',
      iotInstanceId: 'string',
      projectCode: 'string',
      soundCodeConfig: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      speechRate: 'number',
      speechType: 'string',
      text: 'string',
      voice: 'string',
      volume: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSpeechShrinkRequest extends $tea.Model {
  audioFormat?: string;
  bizCode?: string;
  enableSoundCode?: boolean;
  iotInstanceId?: string;
  projectCode: string;
  soundCodeConfigShrink?: string;
  speechRate?: number;
  speechType?: string;
  text?: string;
  voice: string;
  volume?: number;
  static names(): { [key: string]: string } {
    return {
      audioFormat: 'AudioFormat',
      bizCode: 'BizCode',
      enableSoundCode: 'EnableSoundCode',
      iotInstanceId: 'IotInstanceId',
      projectCode: 'ProjectCode',
      soundCodeConfigShrink: 'SoundCodeConfig',
      speechRate: 'SpeechRate',
      speechType: 'SpeechType',
      text: 'Text',
      voice: 'Voice',
      volume: 'Volume',
    };
  }

  static types(): { [key: string]: any } {
    return {
      audioFormat: 'string',
      bizCode: 'string',
      enableSoundCode: 'boolean',
      iotInstanceId: 'string',
      projectCode: 'string',
      soundCodeConfigShrink: 'string',
      speechRate: 'number',
      speechType: 'string',
      text: 'string',
      voice: 'string',
      volume: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSpeechResponse extends $tea.Model {
  code: string;
  data: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateStudioAppDomainOpenRequest extends $tea.Model {
  appId: string;
  host: string;
  iotInstanceId?: string;
  projectId: string;
  protocol: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      host: 'Host',
      iotInstanceId: 'IotInstanceId',
      projectId: 'ProjectId',
      protocol: 'Protocol',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      host: 'string',
      iotInstanceId: 'string',
      projectId: 'string',
      protocol: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateStudioAppDomainOpenResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: CreateStudioAppDomainOpenResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: CreateStudioAppDomainOpenResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSubscribeRelationRequest extends $tea.Model {
  consumerGroupIds?: string[];
  deviceDataFlag?: boolean;
  deviceLifeCycleFlag?: boolean;
  deviceStatusChangeFlag?: boolean;
  deviceTagFlag?: boolean;
  deviceTopoLifeCycleFlag?: boolean;
  foundDeviceListFlag?: boolean;
  iotInstanceId?: string;
  mnsConfiguration?: string;
  otaEventFlag?: boolean;
  otaJobFlag?: boolean;
  otaVersionFlag?: boolean;
  productKey: string;
  subscribeFlags?: string;
  thingHistoryFlag?: boolean;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      consumerGroupIds: 'ConsumerGroupIds',
      deviceDataFlag: 'DeviceDataFlag',
      deviceLifeCycleFlag: 'DeviceLifeCycleFlag',
      deviceStatusChangeFlag: 'DeviceStatusChangeFlag',
      deviceTagFlag: 'DeviceTagFlag',
      deviceTopoLifeCycleFlag: 'DeviceTopoLifeCycleFlag',
      foundDeviceListFlag: 'FoundDeviceListFlag',
      iotInstanceId: 'IotInstanceId',
      mnsConfiguration: 'MnsConfiguration',
      otaEventFlag: 'OtaEventFlag',
      otaJobFlag: 'OtaJobFlag',
      otaVersionFlag: 'OtaVersionFlag',
      productKey: 'ProductKey',
      subscribeFlags: 'SubscribeFlags',
      thingHistoryFlag: 'ThingHistoryFlag',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consumerGroupIds: { 'type': 'array', 'itemType': 'string' },
      deviceDataFlag: 'boolean',
      deviceLifeCycleFlag: 'boolean',
      deviceStatusChangeFlag: 'boolean',
      deviceTagFlag: 'boolean',
      deviceTopoLifeCycleFlag: 'boolean',
      foundDeviceListFlag: 'boolean',
      iotInstanceId: 'string',
      mnsConfiguration: 'string',
      otaEventFlag: 'boolean',
      otaJobFlag: 'boolean',
      otaVersionFlag: 'boolean',
      productKey: 'string',
      subscribeFlags: 'string',
      thingHistoryFlag: 'boolean',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSubscribeRelationResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateThingModelRequest extends $tea.Model {
  iotInstanceId?: string;
  productKey: string;
  thingModelJson?: string;
  functionBlockId?: string;
  functionBlockName?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
      thingModelJson: 'ThingModelJson',
      functionBlockId: 'FunctionBlockId',
      functionBlockName: 'FunctionBlockName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      productKey: 'string',
      thingModelJson: 'string',
      functionBlockId: 'string',
      functionBlockName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateThingModelResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateThingScriptRequest extends $tea.Model {
  iotInstanceId?: string;
  productKey: string;
  scriptContent: string;
  scriptType: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
      scriptContent: 'ScriptContent',
      scriptType: 'ScriptType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      productKey: 'string',
      scriptContent: 'string',
      scriptType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateThingScriptResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTopicRouteTableRequest extends $tea.Model {
  dstTopic: string[];
  iotInstanceId?: string;
  srcTopic: string;
  static names(): { [key: string]: string } {
    return {
      dstTopic: 'DstTopic',
      iotInstanceId: 'IotInstanceId',
      srcTopic: 'SrcTopic',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dstTopic: { 'type': 'array', 'itemType': 'string' },
      iotInstanceId: 'string',
      srcTopic: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTopicRouteTableResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  isAllSucceed: boolean;
  requestId: string;
  success: boolean;
  failureTopics: CreateTopicRouteTableResponseFailureTopics;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      isAllSucceed: 'IsAllSucceed',
      requestId: 'RequestId',
      success: 'Success',
      failureTopics: 'FailureTopics',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      isAllSucceed: 'boolean',
      requestId: 'string',
      success: 'boolean',
      failureTopics: CreateTopicRouteTableResponseFailureTopics,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteClientIdsRequest extends $tea.Model {
  iotId: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteClientIdsResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteConsumerGroupRequest extends $tea.Model {
  groupId: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteConsumerGroupResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteConsumerGroupSubscribeRelationRequest extends $tea.Model {
  consumerGroupId: string;
  iotInstanceId?: string;
  productKey: string;
  static names(): { [key: string]: string } {
    return {
      consumerGroupId: 'ConsumerGroupId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consumerGroupId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteConsumerGroupSubscribeRelationResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDataSourceItemRequest extends $tea.Model {
  dataSourceId: number;
  dataSourceItemId: number;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      dataSourceId: 'DataSourceId',
      dataSourceItemId: 'DataSourceItemId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataSourceId: 'number',
      dataSourceItemId: 'number',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDataSourceItemResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDestinationRequest extends $tea.Model {
  destinationId: number;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      destinationId: 'DestinationId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      destinationId: 'number',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDestinationResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDeviceRequest extends $tea.Model {
  deviceName?: string;
  iotId?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDeviceResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDeviceDistributeJobRequest extends $tea.Model {
  jobId: string;
  static names(): { [key: string]: string } {
    return {
      jobId: 'JobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      jobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDeviceDistributeJobResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDeviceDynamicGroupRequest extends $tea.Model {
  groupId: string;
  iotInstanceId: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDeviceDynamicGroupResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDeviceFileRequest extends $tea.Model {
  deviceName?: string;
  fileId: string;
  iotId?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      fileId: 'FileId',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      fileId: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDeviceFileResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDeviceGroupRequest extends $tea.Model {
  groupId: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDeviceGroupResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDevicePropRequest extends $tea.Model {
  deviceName?: string;
  iotId?: string;
  iotInstanceId?: string;
  productKey?: string;
  propKey: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
      propKey: 'PropKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
      propKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDevicePropResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDeviceSpeechRequest extends $tea.Model {
  deviceSpeechList: DeleteDeviceSpeechRequestDeviceSpeechList[];
  iotId: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      deviceSpeechList: 'DeviceSpeechList',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceSpeechList: { 'type': 'array', 'itemType': DeleteDeviceSpeechRequestDeviceSpeechList },
      iotId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDeviceSpeechResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDeviceTunnelRequest extends $tea.Model {
  tunnelId: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      tunnelId: 'TunnelId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tunnelId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDeviceTunnelResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEdgeDriverRequest extends $tea.Model {
  driverId: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      driverId: 'DriverId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      driverId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEdgeDriverResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEdgeDriverVersionRequest extends $tea.Model {
  driverId: string;
  driverVersion: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      driverId: 'DriverId',
      driverVersion: 'DriverVersion',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      driverId: 'string',
      driverVersion: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEdgeDriverVersionResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEdgeInstanceRequest extends $tea.Model {
  instanceId: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEdgeInstanceResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEdgeInstanceMessageRoutingRequest extends $tea.Model {
  instanceId: string;
  iotInstanceId?: string;
  routeId: number;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
      routeId: 'RouteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      iotInstanceId: 'string',
      routeId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEdgeInstanceMessageRoutingResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteJobRequest extends $tea.Model {
  iotInstanceId?: string;
  jobId: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      jobId: 'JobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      jobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteJobResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteOTAFirmwareRequest extends $tea.Model {
  firmwareId: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      firmwareId: 'FirmwareId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      firmwareId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteOTAFirmwareResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteOTAModuleRequest extends $tea.Model {
  iotInstanceId?: string;
  moduleName: string;
  productKey: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      moduleName: 'ModuleName',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      moduleName: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteOTAModuleResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteParserRequest extends $tea.Model {
  iotInstanceId?: string;
  parserId: number;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      parserId: 'ParserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      parserId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteParserResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteParserDataSourceRequest extends $tea.Model {
  dataSourceId: number;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      dataSourceId: 'DataSourceId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataSourceId: 'number',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteParserDataSourceResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteProductRequest extends $tea.Model {
  iotInstanceId?: string;
  productKey: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteProductResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteProductTagsRequest extends $tea.Model {
  iotInstanceId?: string;
  productKey: string;
  productTagKey: string[];
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
      productTagKey: 'ProductTagKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      productKey: 'string',
      productTagKey: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteProductTagsResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteProductTopicRequest extends $tea.Model {
  iotInstanceId?: string;
  topicId: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      topicId: 'TopicId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      topicId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteProductTopicResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRuleRequest extends $tea.Model {
  iotInstanceId?: string;
  ruleId: number;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      ruleId: 'RuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      ruleId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRuleResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRuleActionRequest extends $tea.Model {
  actionId: number;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      actionId: 'ActionId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actionId: 'number',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRuleActionResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSceneRuleRequest extends $tea.Model {
  iotInstanceId?: string;
  ruleId: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      ruleId: 'RuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      ruleId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSceneRuleResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSchedulePeriodRequest extends $tea.Model {
  iotInstanceId?: string;
  periodCode: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      periodCode: 'PeriodCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      periodCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSchedulePeriodResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteShareTaskDeviceRequest extends $tea.Model {
  iotIdList?: string[];
  iotInstanceId?: string;
  shareTaskId: string;
  static names(): { [key: string]: string } {
    return {
      iotIdList: 'IotIdList',
      iotInstanceId: 'IotInstanceId',
      shareTaskId: 'ShareTaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotIdList: { 'type': 'array', 'itemType': 'string' },
      iotInstanceId: 'string',
      shareTaskId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteShareTaskDeviceResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: DeleteShareTaskDeviceResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: DeleteShareTaskDeviceResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSoundCodeRequest extends $tea.Model {
  iotInstanceId?: string;
  soundCode: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      soundCode: 'SoundCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      soundCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSoundCodeResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSoundCodeLabelRequest extends $tea.Model {
  iotInstanceId?: string;
  soundCode: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      soundCode: 'SoundCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      soundCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSoundCodeLabelResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSoundCodeScheduleRequest extends $tea.Model {
  iotInstanceId?: string;
  scheduleCode: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      scheduleCode: 'ScheduleCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      scheduleCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSoundCodeScheduleResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSpeechRequest extends $tea.Model {
  iotInstanceId?: string;
  speechCodeList: string[];
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      speechCodeList: 'SpeechCodeList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      speechCodeList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSpeechResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteStudioAppDomainOpenRequest extends $tea.Model {
  appId: string;
  domainId: number;
  iotInstanceId?: string;
  projectId: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      domainId: 'DomainId',
      iotInstanceId: 'IotInstanceId',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      domainId: 'number',
      iotInstanceId: 'string',
      projectId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteStudioAppDomainOpenResponse extends $tea.Model {
  code: string;
  data: boolean;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'boolean',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSubscribeRelationRequest extends $tea.Model {
  iotInstanceId?: string;
  productKey: string;
  type: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      productKey: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSubscribeRelationResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteThingModelRequest extends $tea.Model {
  eventIdentifier?: string[];
  functionBlockId?: string;
  iotInstanceId?: string;
  productKey?: string;
  propertyIdentifier?: string[];
  resourceGroupId?: string;
  serviceIdentifier?: string[];
  static names(): { [key: string]: string } {
    return {
      eventIdentifier: 'EventIdentifier',
      functionBlockId: 'FunctionBlockId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
      propertyIdentifier: 'PropertyIdentifier',
      resourceGroupId: 'ResourceGroupId',
      serviceIdentifier: 'ServiceIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      eventIdentifier: { 'type': 'array', 'itemType': 'string' },
      functionBlockId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
      propertyIdentifier: { 'type': 'array', 'itemType': 'string' },
      resourceGroupId: 'string',
      serviceIdentifier: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteThingModelResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTopicRouteTableRequest extends $tea.Model {
  dstTopic: string[];
  iotInstanceId?: string;
  srcTopic: string;
  static names(): { [key: string]: string } {
    return {
      dstTopic: 'DstTopic',
      iotInstanceId: 'IotInstanceId',
      srcTopic: 'SrcTopic',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dstTopic: { 'type': 'array', 'itemType': 'string' },
      iotInstanceId: 'string',
      srcTopic: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTopicRouteTableResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  isAllSucceed: boolean;
  requestId: string;
  success: boolean;
  failureTopics: DeleteTopicRouteTableResponseFailureTopics;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      isAllSucceed: 'IsAllSucceed',
      requestId: 'RequestId',
      success: 'Success',
      failureTopics: 'FailureTopics',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      isAllSucceed: 'boolean',
      requestId: 'string',
      success: 'boolean',
      failureTopics: DeleteTopicRouteTableResponseFailureTopics,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DetachDestinationRequest extends $tea.Model {
  destinationId: number;
  iotInstanceId?: string;
  parserId: number;
  static names(): { [key: string]: string } {
    return {
      destinationId: 'DestinationId',
      iotInstanceId: 'IotInstanceId',
      parserId: 'ParserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      destinationId: 'number',
      iotInstanceId: 'string',
      parserId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DetachDestinationResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DetachParserDataSourceRequest extends $tea.Model {
  dataSourceId: number;
  iotInstanceId?: string;
  parserId: number;
  static names(): { [key: string]: string } {
    return {
      dataSourceId: 'DataSourceId',
      iotInstanceId: 'IotInstanceId',
      parserId: 'ParserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataSourceId: 'number',
      iotInstanceId: 'string',
      parserId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DetachParserDataSourceResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableDeviceTunnelRequest extends $tea.Model {
  deviceName: string;
  iotInstanceId?: string;
  productKey: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableDeviceTunnelResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableDeviceTunnelShareRequest extends $tea.Model {
  deviceName: string;
  iotInstanceId?: string;
  productKey: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableDeviceTunnelShareResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableSceneRuleRequest extends $tea.Model {
  iotInstanceId?: string;
  ruleId: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      ruleId: 'RuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      ruleId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableSceneRuleResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableThingRequest extends $tea.Model {
  deviceName?: string;
  iotId?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableThingResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableDeviceTunnelRequest extends $tea.Model {
  deviceName: string;
  iotInstanceId?: string;
  productKey: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableDeviceTunnelResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableDeviceTunnelShareRequest extends $tea.Model {
  deviceName: string;
  iotInstanceId?: string;
  productKey: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableDeviceTunnelShareResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableSceneRuleRequest extends $tea.Model {
  iotInstanceId?: string;
  ruleId: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      ruleId: 'RuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      ruleId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableSceneRuleResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableThingRequest extends $tea.Model {
  deviceName?: string;
  iotId?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableThingResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GenerateDeviceNameListURLRequest extends $tea.Model {
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GenerateDeviceNameListURLResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: GenerateDeviceNameListURLResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: GenerateDeviceNameListURLResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GenerateFileUploadURLRequest extends $tea.Model {
  bizCode: string;
  fileName?: string;
  fileSuffix: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      bizCode: 'BizCode',
      fileName: 'FileName',
      fileSuffix: 'FileSuffix',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizCode: 'string',
      fileName: 'string',
      fileSuffix: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GenerateFileUploadURLResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: GenerateFileUploadURLResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: GenerateFileUploadURLResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GenerateOTAUploadURLRequest extends $tea.Model {
  fileSuffix?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      fileSuffix: 'FileSuffix',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fileSuffix: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GenerateOTAUploadURLResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: GenerateOTAUploadURLResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: GenerateOTAUploadURLResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataAPIServiceDetailRequest extends $tea.Model {
  apiSrn: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      apiSrn: 'ApiSrn',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiSrn: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataAPIServiceDetailResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: GetDataAPIServiceDetailResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: GetDataAPIServiceDetailResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDestinationRequest extends $tea.Model {
  destinationId: number;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      destinationId: 'DestinationId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      destinationId: 'number',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDestinationResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  destination: GetDestinationResponseDestination;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      destination: 'Destination',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      destination: GetDestinationResponseDestination,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDeviceShadowRequest extends $tea.Model {
  deviceName: string;
  iotInstanceId?: string;
  productKey: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDeviceShadowResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  shadowMessage: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      shadowMessage: 'ShadowMessage',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      shadowMessage: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDeviceStatusRequest extends $tea.Model {
  deviceName?: string;
  iotId?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDeviceStatusResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: GetDeviceStatusResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: GetDeviceStatusResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDeviceTunnelShareStatusRequest extends $tea.Model {
  deviceName: string;
  iotInstanceId?: string;
  productKey: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDeviceTunnelShareStatusResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: GetDeviceTunnelShareStatusResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: GetDeviceTunnelShareStatusResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDeviceTunnelStatusRequest extends $tea.Model {
  deviceName: string;
  iotInstanceId?: string;
  productKey: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDeviceTunnelStatusResponse extends $tea.Model {
  code: string;
  data: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDownloadFileRequest extends $tea.Model {
  context?: { [key: string]: any };
  iotInstanceId?: string;
  longJobId: string;
  static names(): { [key: string]: string } {
    return {
      context: 'Context',
      iotInstanceId: 'IotInstanceId',
      longJobId: 'LongJobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      context: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      iotInstanceId: 'string',
      longJobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDownloadFileShrinkRequest extends $tea.Model {
  contextShrink?: string;
  iotInstanceId?: string;
  longJobId: string;
  static names(): { [key: string]: string } {
    return {
      contextShrink: 'Context',
      iotInstanceId: 'IotInstanceId',
      longJobId: 'LongJobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contextShrink: 'string',
      iotInstanceId: 'string',
      longJobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDownloadFileResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: GetDownloadFileResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: GetDownloadFileResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeDriverVersionRequest extends $tea.Model {
  driverId: string;
  driverVersion: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      driverId: 'DriverId',
      driverVersion: 'DriverVersion',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      driverId: 'string',
      driverVersion: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeDriverVersionResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: GetEdgeDriverVersionResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: GetEdgeDriverVersionResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeInstanceRequest extends $tea.Model {
  instanceId: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeInstanceResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: GetEdgeInstanceResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: GetEdgeInstanceResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeInstanceDeploymentRequest extends $tea.Model {
  deploymentId: string;
  instanceId: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      deploymentId: 'DeploymentId',
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deploymentId: 'string',
      instanceId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeInstanceDeploymentResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: GetEdgeInstanceDeploymentResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: GetEdgeInstanceDeploymentResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeInstanceMessageRoutingRequest extends $tea.Model {
  instanceId: string;
  iotInstanceId?: string;
  routeId: number;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
      routeId: 'RouteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      iotInstanceId: 'string',
      routeId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeInstanceMessageRoutingResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: GetEdgeInstanceMessageRoutingResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: GetEdgeInstanceMessageRoutingResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayBySubDeviceRequest extends $tea.Model {
  deviceName?: string;
  iotId?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayBySubDeviceResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: GetGatewayBySubDeviceResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: GetGatewayBySubDeviceResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetLoraNodesTaskRequest extends $tea.Model {
  iotInstanceId?: string;
  taskId: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      taskId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetLoraNodesTaskResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  successCount: number;
  taskId: string;
  taskState: string;
  totalCount: number;
  successDevEuis: GetLoraNodesTaskResponseSuccessDevEuis;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      successCount: 'SuccessCount',
      taskId: 'TaskId',
      taskState: 'TaskState',
      totalCount: 'TotalCount',
      successDevEuis: 'SuccessDevEuis',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      successCount: 'number',
      taskId: 'string',
      taskState: 'string',
      totalCount: 'number',
      successDevEuis: GetLoraNodesTaskResponseSuccessDevEuis,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetParserRequest extends $tea.Model {
  iotInstanceId?: string;
  parserId: number;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      parserId: 'ParserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      parserId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetParserResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: GetParserResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: GetParserResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetParserDataSourceRequest extends $tea.Model {
  dataSourceId: number;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      dataSourceId: 'DataSourceId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataSourceId: 'number',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetParserDataSourceResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  dataSource: GetParserDataSourceResponseDataSource;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      dataSource: 'DataSource',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      dataSource: GetParserDataSourceResponseDataSource,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRuleRequest extends $tea.Model {
  iotInstanceId?: string;
  ruleId: number;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      ruleId: 'RuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      ruleId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRuleResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  ruleInfo: GetRuleResponseRuleInfo;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      ruleInfo: 'RuleInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      ruleInfo: GetRuleResponseRuleInfo,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRuleActionRequest extends $tea.Model {
  actionId: number;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      actionId: 'ActionId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actionId: 'number',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRuleActionResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  ruleActionInfo: GetRuleActionResponseRuleActionInfo;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      ruleActionInfo: 'RuleActionInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      ruleActionInfo: GetRuleActionResponseRuleActionInfo,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSceneRuleRequest extends $tea.Model {
  iotInstanceId?: string;
  ruleId: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      ruleId: 'RuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      ruleId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSceneRuleResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: GetSceneRuleResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: GetSceneRuleResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetShareTaskByDeviceOpenRequest extends $tea.Model {
  deviceName?: string;
  iotId?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetShareTaskByDeviceOpenResponse extends $tea.Model {
  code: string;
  data: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSoundCodeAudioRequest extends $tea.Model {
  iotInstanceId?: string;
  soundCodeList: string[];
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      soundCodeList: 'SoundCodeList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      soundCodeList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSoundCodeAudioResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: GetSoundCodeAudioResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: GetSoundCodeAudioResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSoundCodeScheduleRequest extends $tea.Model {
  iotInstanceId?: string;
  scheduleCode: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      scheduleCode: 'ScheduleCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      scheduleCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSoundCodeScheduleResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: GetSoundCodeScheduleResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: GetSoundCodeScheduleResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSpeechDeviceDetailRequest extends $tea.Model {
  iotId: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSpeechDeviceDetailResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: GetSpeechDeviceDetailResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: GetSpeechDeviceDetailResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSpeechLicenseDeviceStatisticsRequest extends $tea.Model {
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSpeechLicenseDeviceStatisticsResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: GetSpeechLicenseDeviceStatisticsResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: GetSpeechLicenseDeviceStatisticsResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSpeechVoiceRequest extends $tea.Model {
  static names(): { [key: string]: string } {
    return {
    };
  }

  static types(): { [key: string]: any } {
    return {
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSpeechVoiceResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: GetSpeechVoiceResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: GetSpeechVoiceResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStudioAppTokenOpenRequest extends $tea.Model {
  appId: string;
  iotInstanceId?: string;
  projectId: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      iotInstanceId: 'IotInstanceId',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      iotInstanceId: 'string',
      projectId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStudioAppTokenOpenResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: GetStudioAppTokenOpenResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: GetStudioAppTokenOpenResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetThingModelTslRequest extends $tea.Model {
  functionBlockId?: string;
  iotInstanceId?: string;
  modelVersion?: string;
  productKey?: string;
  simple?: boolean;
  static names(): { [key: string]: string } {
    return {
      functionBlockId: 'FunctionBlockId',
      iotInstanceId: 'IotInstanceId',
      modelVersion: 'ModelVersion',
      productKey: 'ProductKey',
      simple: 'Simple',
    };
  }

  static types(): { [key: string]: any } {
    return {
      functionBlockId: 'string',
      iotInstanceId: 'string',
      modelVersion: 'string',
      productKey: 'string',
      simple: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetThingModelTslResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: GetThingModelTslResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: GetThingModelTslResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetThingModelTslPublishedRequest extends $tea.Model {
  functionBlockId?: string;
  iotInstanceId?: string;
  modelVersion?: string;
  productKey: string;
  resourceGroupId?: string;
  simple?: boolean;
  static names(): { [key: string]: string } {
    return {
      functionBlockId: 'FunctionBlockId',
      iotInstanceId: 'IotInstanceId',
      modelVersion: 'ModelVersion',
      productKey: 'ProductKey',
      resourceGroupId: 'ResourceGroupId',
      simple: 'Simple',
    };
  }

  static types(): { [key: string]: any } {
    return {
      functionBlockId: 'string',
      iotInstanceId: 'string',
      modelVersion: 'string',
      productKey: 'string',
      resourceGroupId: 'string',
      simple: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetThingModelTslPublishedResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: GetThingModelTslPublishedResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: GetThingModelTslPublishedResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetThingScriptRequest extends $tea.Model {
  iotInstanceId?: string;
  productKey: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetThingScriptResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: GetThingScriptResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: GetThingScriptResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetThingTemplateRequest extends $tea.Model {
  categoryKey?: string;
  iotInstanceId?: string;
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      categoryKey: 'CategoryKey',
      iotInstanceId: 'IotInstanceId',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      categoryKey: 'string',
      iotInstanceId: 'string',
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetThingTemplateResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  thingModelJSON: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      thingModelJSON: 'ThingModelJSON',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      thingModelJSON: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetThingTopoRequest extends $tea.Model {
  deviceName?: string;
  iotId?: string;
  iotInstanceId?: string;
  pageNo: number;
  pageSize: number;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      pageNo: 'PageNo',
      pageSize: 'PageSize',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      pageNo: 'number',
      pageSize: 'number',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetThingTopoResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: GetThingTopoResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: GetThingTopoResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GisQueryDeviceLocationRequest extends $tea.Model {
  iotInstanceId?: string;
  thingList: GisQueryDeviceLocationRequestThingList[];
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      thingList: 'ThingList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      thingList: { 'type': 'array', 'itemType': GisQueryDeviceLocationRequestThingList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GisQueryDeviceLocationResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: GisQueryDeviceLocationResponseData[];
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: { 'type': 'array', 'itemType': GisQueryDeviceLocationResponseData },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GisSearchDeviceTraceRequest extends $tea.Model {
  mapMatch: number;
  iotInstanceId?: string;
  endTime: number;
  startTime: number;
  productKey: string;
  deviceName: string;
  static names(): { [key: string]: string } {
    return {
      mapMatch: 'MapMatch',
      iotInstanceId: 'IotInstanceId',
      endTime: 'EndTime',
      startTime: 'StartTime',
      productKey: 'ProductKey',
      deviceName: 'DeviceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      mapMatch: 'number',
      iotInstanceId: 'string',
      endTime: 'number',
      startTime: 'number',
      productKey: 'string',
      deviceName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GisSearchDeviceTraceResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: GisSearchDeviceTraceResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: GisSearchDeviceTraceResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportDTDataRequest extends $tea.Model {
  iotInstanceId?: string;
  items: ImportDTDataRequestItems[];
  productKey: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      items: 'Items',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      items: { 'type': 'array', 'itemType': ImportDTDataRequestItems },
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportDTDataResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportDeviceRequest extends $tea.Model {
  deviceName: string;
  deviceSecret: string;
  iotInstanceId?: string;
  nickname?: string;
  productKey: string;
  sn?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      deviceSecret: 'DeviceSecret',
      iotInstanceId: 'IotInstanceId',
      nickname: 'Nickname',
      productKey: 'ProductKey',
      sn: 'Sn',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      deviceSecret: 'string',
      iotInstanceId: 'string',
      nickname: 'string',
      productKey: 'string',
      sn: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportDeviceResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: ImportDeviceResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: ImportDeviceResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportThingModelTslRequest extends $tea.Model {
  functionBlockId?: string;
  functionBlockName?: string;
  iotInstanceId?: string;
  productKey: string;
  resourceGroupId?: string;
  tslStr?: string;
  tslUrl?: string;
  static names(): { [key: string]: string } {
    return {
      functionBlockId: 'FunctionBlockId',
      functionBlockName: 'FunctionBlockName',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
      resourceGroupId: 'ResourceGroupId',
      tslStr: 'TslStr',
      tslUrl: 'TslUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      functionBlockId: 'string',
      functionBlockName: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
      resourceGroupId: 'string',
      tslStr: 'string',
      tslUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportThingModelTslResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InvokeDataAPIServiceRequest extends $tea.Model {
  apiSrn: string;
  param?: InvokeDataAPIServiceRequestParam[];
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      apiSrn: 'ApiSrn',
      param: 'Param',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiSrn: 'string',
      param: { 'type': 'array', 'itemType': InvokeDataAPIServiceRequestParam },
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InvokeDataAPIServiceResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: InvokeDataAPIServiceResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: InvokeDataAPIServiceResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InvokeThingServiceRequest extends $tea.Model {
  args: string;
  deviceName?: string;
  identifier: string;
  iotId?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      args: 'Args',
      deviceName: 'DeviceName',
      identifier: 'Identifier',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      args: 'string',
      deviceName: 'string',
      identifier: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InvokeThingServiceResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: InvokeThingServiceResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: InvokeThingServiceResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InvokeThingsServiceRequest extends $tea.Model {
  args: string;
  deviceName: string[];
  identifier: string;
  iotInstanceId?: string;
  productKey: string;
  static names(): { [key: string]: string } {
    return {
      args: 'Args',
      deviceName: 'DeviceName',
      identifier: 'Identifier',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      args: 'string',
      deviceName: { 'type': 'array', 'itemType': 'string' },
      identifier: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InvokeThingsServiceResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAnalyticsDataRequest extends $tea.Model {
  apiPath: string;
  condition?: ListAnalyticsDataRequestCondition[];
  iotInstanceId: string;
  isoId?: string;
  pageNum?: number;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      apiPath: 'ApiPath',
      condition: 'Condition',
      iotInstanceId: 'IotInstanceId',
      isoId: 'IsoId',
      pageNum: 'PageNum',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiPath: 'string',
      condition: { 'type': 'array', 'itemType': ListAnalyticsDataRequestCondition },
      iotInstanceId: 'string',
      isoId: 'string',
      pageNum: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAnalyticsDataResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: ListAnalyticsDataResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: ListAnalyticsDataResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataSourceItemRequest extends $tea.Model {
  dataSourceId: number;
  iotInstanceId?: string;
  page: number;
  pageSize: number;
  searchName?: string;
  static names(): { [key: string]: string } {
    return {
      dataSourceId: 'DataSourceId',
      iotInstanceId: 'IotInstanceId',
      page: 'Page',
      pageSize: 'PageSize',
      searchName: 'SearchName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataSourceId: 'number',
      iotInstanceId: 'string',
      page: 'number',
      pageSize: 'number',
      searchName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataSourceItemResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  page: number;
  pageSize: number;
  requestId: string;
  success: boolean;
  total: number;
  dataSourceItems: ListDataSourceItemResponseDataSourceItems;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      page: 'Page',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      total: 'Total',
      dataSourceItems: 'DataSourceItems',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      page: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      total: 'number',
      dataSourceItems: ListDataSourceItemResponseDataSourceItems,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDestinationRequest extends $tea.Model {
  iotInstanceId?: string;
  page: number;
  pageSize: number;
  searchName?: string;
  types?: string[];
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      page: 'Page',
      pageSize: 'PageSize',
      searchName: 'SearchName',
      types: 'Types',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      page: 'number',
      pageSize: 'number',
      searchName: 'string',
      types: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDestinationResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  page: number;
  pageSize: number;
  requestId: string;
  success: boolean;
  total: number;
  destinations: ListDestinationResponseDestinations;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      page: 'Page',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      total: 'Total',
      destinations: 'Destinations',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      page: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      total: 'number',
      destinations: ListDestinationResponseDestinations,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDeviceDistributeJobRequest extends $tea.Model {
  targetUid?: string;
  currentPage?: number;
  pageSize: number;
  status?: number;
  jobId?: string;
  nextToken?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      targetUid: 'TargetUid',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      status: 'Status',
      jobId: 'JobId',
      nextToken: 'NextToken',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      targetUid: 'string',
      currentPage: 'number',
      pageSize: 'number',
      status: 'number',
      jobId: 'string',
      nextToken: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDeviceDistributeJobResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: ListDeviceDistributeJobResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: ListDeviceDistributeJobResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDistributedDeviceRequest extends $tea.Model {
  currentPage: number;
  deviceName?: string;
  pageSize: number;
  productKey?: string;
  sourceInstanceId?: string;
  targetUid?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      deviceName: 'DeviceName',
      pageSize: 'PageSize',
      productKey: 'ProductKey',
      sourceInstanceId: 'SourceInstanceId',
      targetUid: 'TargetUid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      deviceName: 'string',
      pageSize: 'number',
      productKey: 'string',
      sourceInstanceId: 'string',
      targetUid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDistributedDeviceResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: ListDistributedDeviceResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: ListDistributedDeviceResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDistributedProductRequest extends $tea.Model {
  pageSize: number;
  sourceInstanceId?: string;
  productKey?: string;
  targetInstanceId?: string;
  targetUid?: string;
  currentPage: number;
  static names(): { [key: string]: string } {
    return {
      pageSize: 'PageSize',
      sourceInstanceId: 'SourceInstanceId',
      productKey: 'ProductKey',
      targetInstanceId: 'TargetInstanceId',
      targetUid: 'TargetUid',
      currentPage: 'CurrentPage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageSize: 'number',
      sourceInstanceId: 'string',
      productKey: 'string',
      targetInstanceId: 'string',
      targetUid: 'string',
      currentPage: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDistributedProductResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: ListDistributedProductResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: ListDistributedProductResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobRequest extends $tea.Model {
  currentPage: number;
  iotInstanceId?: string;
  pageSize: number;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      iotInstanceId: 'string',
      pageSize: 'number',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  page: number;
  pageSize: number;
  requestId: string;
  success: boolean;
  total: number;
  data: ListJobResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      page: 'Page',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      total: 'Total',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      page: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      total: 'number',
      data: ListJobResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAFirmwareRequest extends $tea.Model {
  currentPage: number;
  destVersion?: string;
  iotInstanceId?: string;
  pageSize: number;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      destVersion: 'DestVersion',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      destVersion: 'string',
      iotInstanceId: 'string',
      pageSize: 'number',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAFirmwareResponse extends $tea.Model {
  code: string;
  currentPage: number;
  errorMessage: string;
  pageCount: number;
  pageSize: number;
  requestId: string;
  success: boolean;
  total: number;
  firmwareInfo: ListOTAFirmwareResponseFirmwareInfo;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      currentPage: 'CurrentPage',
      errorMessage: 'ErrorMessage',
      pageCount: 'PageCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      total: 'Total',
      firmwareInfo: 'FirmwareInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      currentPage: 'number',
      errorMessage: 'string',
      pageCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      total: 'number',
      firmwareInfo: ListOTAFirmwareResponseFirmwareInfo,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAJobByDeviceRequest extends $tea.Model {
  currentPage: number;
  deviceName: string;
  firmwareId: string;
  iotInstanceId?: string;
  pageSize: number;
  productKey: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      deviceName: 'DeviceName',
      firmwareId: 'FirmwareId',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      deviceName: 'string',
      firmwareId: 'string',
      iotInstanceId: 'string',
      pageSize: 'number',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAJobByDeviceResponse extends $tea.Model {
  code: string;
  currentPage: number;
  errorMessage: string;
  pageCount: number;
  pageSize: number;
  requestId: string;
  success: boolean;
  total: number;
  data: ListOTAJobByDeviceResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      currentPage: 'CurrentPage',
      errorMessage: 'ErrorMessage',
      pageCount: 'PageCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      total: 'Total',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      currentPage: 'number',
      errorMessage: 'string',
      pageCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      total: 'number',
      data: ListOTAJobByDeviceResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAJobByFirmwareRequest extends $tea.Model {
  currentPage: number;
  firmwareId: string;
  iotInstanceId?: string;
  pageSize: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      firmwareId: 'FirmwareId',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      firmwareId: 'string',
      iotInstanceId: 'string',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAJobByFirmwareResponse extends $tea.Model {
  code: string;
  currentPage: number;
  errorMessage: string;
  pageCount: number;
  pageSize: number;
  requestId: string;
  success: boolean;
  total: number;
  data: ListOTAJobByFirmwareResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      currentPage: 'CurrentPage',
      errorMessage: 'ErrorMessage',
      pageCount: 'PageCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      total: 'Total',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      currentPage: 'number',
      errorMessage: 'string',
      pageCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      total: 'number',
      data: ListOTAJobByFirmwareResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAModuleByProductRequest extends $tea.Model {
  iotInstanceId?: string;
  productKey: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAModuleByProductResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: ListOTAModuleByProductResponseData[];
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: { 'type': 'array', 'itemType': ListOTAModuleByProductResponseData },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAModuleVersionsByDeviceRequest extends $tea.Model {
  currentPage: number;
  deviceName?: string;
  iotId?: string;
  iotInstanceId?: string;
  pageSize: number;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      deviceName: 'DeviceName',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      deviceName: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      pageSize: 'number',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAModuleVersionsByDeviceResponse extends $tea.Model {
  code: string;
  currentPage: number;
  errorMessage: string;
  pageCount: number;
  pageSize: number;
  requestId: string;
  success: boolean;
  total: number;
  data: ListOTAModuleVersionsByDeviceResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      currentPage: 'CurrentPage',
      errorMessage: 'ErrorMessage',
      pageCount: 'PageCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      total: 'Total',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      currentPage: 'number',
      errorMessage: 'string',
      pageCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      total: 'number',
      data: ListOTAModuleVersionsByDeviceResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTATaskByJobRequest extends $tea.Model {
  currentPage?: number;
  deviceNames?: string[];
  iotInstanceId?: string;
  jobId: string;
  pageSize?: number;
  taskStatus?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      deviceNames: 'DeviceNames',
      iotInstanceId: 'IotInstanceId',
      jobId: 'JobId',
      pageSize: 'PageSize',
      taskStatus: 'TaskStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      deviceNames: { 'type': 'array', 'itemType': 'string' },
      iotInstanceId: 'string',
      jobId: 'string',
      pageSize: 'number',
      taskStatus: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTATaskByJobResponse extends $tea.Model {
  code: string;
  currentPage: number;
  errorMessage: string;
  pageCount: number;
  pageSize: number;
  requestId: string;
  success: boolean;
  total: number;
  data: ListOTATaskByJobResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      currentPage: 'CurrentPage',
      errorMessage: 'ErrorMessage',
      pageCount: 'PageCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      total: 'Total',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      currentPage: 'number',
      errorMessage: 'string',
      pageCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      total: 'number',
      data: ListOTATaskByJobResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAUnfinishedTaskByDeviceRequest extends $tea.Model {
  deviceName?: string;
  iotId?: string;
  iotInstanceId?: string;
  moduleName?: string;
  productKey?: string;
  taskStatus: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      moduleName: 'ModuleName',
      productKey: 'ProductKey',
      taskStatus: 'TaskStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      moduleName: 'string',
      productKey: 'string',
      taskStatus: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAUnfinishedTaskByDeviceResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: ListOTAUnfinishedTaskByDeviceResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: ListOTAUnfinishedTaskByDeviceResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListParserRequest extends $tea.Model {
  currentPage: number;
  iotInstanceId?: string;
  pageSize: number;
  searchName?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
      searchName: 'SearchName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      iotInstanceId: 'string',
      pageSize: 'number',
      searchName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListParserResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  total: number;
  data: ListParserResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      total: 'Total',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      total: 'number',
      data: ListParserResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListParserDataSourceRequest extends $tea.Model {
  iotInstanceId?: string;
  page: number;
  pageSize: number;
  searchName?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      page: 'Page',
      pageSize: 'PageSize',
      searchName: 'SearchName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      page: 'number',
      pageSize: 'number',
      searchName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListParserDataSourceResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  page: number;
  pageSize: number;
  requestId: string;
  success: boolean;
  total: number;
  data: ListParserDataSourceResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      page: 'Page',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      total: 'Total',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      page: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      total: 'number',
      data: ListParserDataSourceResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListParserDestinationRequest extends $tea.Model {
  iotInstanceId?: string;
  isFailover?: boolean;
  parserId: number;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      isFailover: 'IsFailover',
      parserId: 'ParserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      isFailover: 'boolean',
      parserId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListParserDestinationResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: ListParserDestinationResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: ListParserDestinationResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProductByTagsRequest extends $tea.Model {
  currentPage?: number;
  iotInstanceId?: string;
  pageSize?: number;
  productTag: ListProductByTagsRequestProductTag[];
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
      productTag: 'ProductTag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      iotInstanceId: 'string',
      pageSize: 'number',
      productTag: { 'type': 'array', 'itemType': ListProductByTagsRequestProductTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProductByTagsResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  productInfos: ListProductByTagsResponseProductInfos;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      productInfos: 'ProductInfos',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      productInfos: ListProductByTagsResponseProductInfos,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProductTagsRequest extends $tea.Model {
  iotInstanceId?: string;
  productKey: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProductTagsResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: ListProductTagsResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: ListProductTagsResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRuleRequest extends $tea.Model {
  currentPage: number;
  iotInstanceId?: string;
  pageSize: number;
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      iotInstanceId: 'string',
      pageSize: 'number',
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRuleResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  page: number;
  pageSize: number;
  requestId: string;
  success: boolean;
  total: number;
  data: ListRuleResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      page: 'Page',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      total: 'Total',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      page: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      total: 'number',
      data: ListRuleResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRuleActionsRequest extends $tea.Model {
  iotInstanceId?: string;
  ruleId: number;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      ruleId: 'RuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      ruleId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRuleActionsResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  ruleActionList: ListRuleActionsResponseRuleActionList;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      ruleActionList: 'RuleActionList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      ruleActionList: ListRuleActionsResponseRuleActionList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskRequest extends $tea.Model {
  device?: { [key: string]: any };
  iotInstanceId?: string;
  jobId?: string;
  limit: number;
  nextToken?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      device: 'Device',
      iotInstanceId: 'IotInstanceId',
      jobId: 'JobId',
      limit: 'Limit',
      nextToken: 'NextToken',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      device: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      iotInstanceId: 'string',
      jobId: 'string',
      limit: 'number',
      nextToken: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskShrinkRequest extends $tea.Model {
  deviceShrink?: string;
  iotInstanceId?: string;
  jobId?: string;
  limit: number;
  nextToken?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      deviceShrink: 'Device',
      iotInstanceId: 'IotInstanceId',
      jobId: 'JobId',
      limit: 'Limit',
      nextToken: 'NextToken',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceShrink: 'string',
      iotInstanceId: 'string',
      jobId: 'string',
      limit: 'number',
      nextToken: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  nextToken: string;
  requestId: string;
  success: boolean;
  data: ListTaskResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      nextToken: 'NextToken',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      nextToken: 'string',
      requestId: 'string',
      success: 'boolean',
      data: ListTaskResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListThingModelVersionRequest extends $tea.Model {
  iotInstanceId?: string;
  productKey: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListThingModelVersionResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: ListThingModelVersionResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: ListThingModelVersionResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListThingTemplatesRequest extends $tea.Model {
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListThingTemplatesResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: ListThingTemplatesResponseData[];
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: { 'type': 'array', 'itemType': ListThingTemplatesResponseData },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class NotifyAddThingTopoRequest extends $tea.Model {
  deviceListStr?: string;
  gwDeviceName?: string;
  gwIotId?: string;
  gwProductKey?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      deviceListStr: 'DeviceListStr',
      gwDeviceName: 'GwDeviceName',
      gwIotId: 'GwIotId',
      gwProductKey: 'GwProductKey',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceListStr: 'string',
      gwDeviceName: 'string',
      gwIotId: 'string',
      gwProductKey: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class NotifyAddThingTopoResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: NotifyAddThingTopoResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: NotifyAddThingTopoResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OpenIotServiceRequest extends $tea.Model {
  ownerId?: number;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OpenIotServiceResponse extends $tea.Model {
  orderId: string;
  requestId: string;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PackageSoundCodeLabelBatchAudioRequest extends $tea.Model {
  batchCode: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      batchCode: 'BatchCode',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      batchCode: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PackageSoundCodeLabelBatchAudioResponse extends $tea.Model {
  code: string;
  data: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PageQuerySharedSpeechOpenRequest extends $tea.Model {
  deviceName?: string;
  iotId?: string;
  iotInstanceId?: string;
  pageId?: number;
  pageSize?: number;
  productKey?: string;
  shareTaskCode?: string;
  status?: number;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      pageId: 'PageId',
      pageSize: 'PageSize',
      productKey: 'ProductKey',
      shareTaskCode: 'ShareTaskCode',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      pageId: 'number',
      pageSize: 'number',
      productKey: 'string',
      shareTaskCode: 'string',
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PageQuerySharedSpeechOpenResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: PageQuerySharedSpeechOpenResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: PageQuerySharedSpeechOpenResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PageQuerySpeechBroadcastHourRequest extends $tea.Model {
  iotInstanceId?: string;
  pageSize?: number;
  pageToken?: string;
  queryDateTimeHour: string;
  shareTaskCode: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
      pageToken: 'PageToken',
      queryDateTimeHour: 'QueryDateTimeHour',
      shareTaskCode: 'ShareTaskCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      pageSize: 'number',
      pageToken: 'string',
      queryDateTimeHour: 'string',
      shareTaskCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PageQuerySpeechBroadcastHourResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: PageQuerySpeechBroadcastHourResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: PageQuerySpeechBroadcastHourResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PrintByTemplateRequest extends $tea.Model {
  deviceName?: string;
  historyPrintTopic?: boolean;
  iotId?: string;
  iotInstanceId?: string;
  paramsJsonString?: string;
  productKey?: string;
  templateBizCode: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      historyPrintTopic: 'HistoryPrintTopic',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      paramsJsonString: 'ParamsJsonString',
      productKey: 'ProductKey',
      templateBizCode: 'TemplateBizCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      historyPrintTopic: 'boolean',
      iotId: 'string',
      iotInstanceId: 'string',
      paramsJsonString: 'string',
      productKey: 'string',
      templateBizCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PrintByTemplateResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: PrintByTemplateResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: PrintByTemplateResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PubRequest extends $tea.Model {
  contentType?: string;
  correlationData?: string;
  deviceName?: string;
  iotInstanceId?: string;
  messageContent: string;
  messageExpiryInterval?: number;
  payloadFormatIndicator?: number;
  productKey: string;
  qos?: number;
  responseTopic?: string;
  retained?: boolean;
  topicFullName: string;
  userProp?: PubRequestUserProp[];
  static names(): { [key: string]: string } {
    return {
      contentType: 'ContentType',
      correlationData: 'CorrelationData',
      deviceName: 'DeviceName',
      iotInstanceId: 'IotInstanceId',
      messageContent: 'MessageContent',
      messageExpiryInterval: 'MessageExpiryInterval',
      payloadFormatIndicator: 'PayloadFormatIndicator',
      productKey: 'ProductKey',
      qos: 'Qos',
      responseTopic: 'ResponseTopic',
      retained: 'Retained',
      topicFullName: 'TopicFullName',
      userProp: 'UserProp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contentType: 'string',
      correlationData: 'string',
      deviceName: 'string',
      iotInstanceId: 'string',
      messageContent: 'string',
      messageExpiryInterval: 'number',
      payloadFormatIndicator: 'number',
      productKey: 'string',
      qos: 'number',
      responseTopic: 'string',
      retained: 'boolean',
      topicFullName: 'string',
      userProp: { 'type': 'array', 'itemType': PubRequestUserProp },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PubResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  messageId: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      messageId: 'MessageId',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      messageId: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PubBroadcastRequest extends $tea.Model {
  iotInstanceId?: string;
  messageContent: string;
  productKey: string;
  topicFullName?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      messageContent: 'MessageContent',
      productKey: 'ProductKey',
      topicFullName: 'TopicFullName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      messageContent: 'string',
      productKey: 'string',
      topicFullName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PubBroadcastResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  messageId: number;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      messageId: 'MessageId',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      messageId: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PublishScriptRequest extends $tea.Model {
  iotInstanceId?: string;
  parserId: number;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      parserId: 'ParserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      parserId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PublishScriptResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  syntaxErrorMsg: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      syntaxErrorMsg: 'SyntaxErrorMsg',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      syntaxErrorMsg: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PublishStudioAppRequest extends $tea.Model {
  appId: string;
  description?: string;
  iotInstanceId?: string;
  projectId: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      description: 'Description',
      iotInstanceId: 'IotInstanceId',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      description: 'string',
      iotInstanceId: 'string',
      projectId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PublishStudioAppResponse extends $tea.Model {
  code: string;
  data: boolean;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'boolean',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PublishThingModelRequest extends $tea.Model {
  description?: string;
  iotInstanceId?: string;
  modelVersion?: string;
  productKey: string;
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      iotInstanceId: 'IotInstanceId',
      modelVersion: 'ModelVersion',
      productKey: 'ProductKey',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      iotInstanceId: 'string',
      modelVersion: 'string',
      productKey: 'string',
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PublishThingModelResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PushSpeechRequest extends $tea.Model {
  deviceName?: string;
  groupId?: string;
  iotId?: string;
  iotInstanceId?: string;
  productKey?: string;
  projectCode: string;
  pushMode: string;
  speechCodeList: string[];
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      groupId: 'GroupId',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
      projectCode: 'ProjectCode',
      pushMode: 'PushMode',
      speechCodeList: 'SpeechCodeList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      groupId: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
      projectCode: 'string',
      pushMode: 'string',
      speechCodeList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PushSpeechResponse extends $tea.Model {
  code: string;
  data: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryBatchRegisterDeviceStatusRequest extends $tea.Model {
  applyId: number;
  iotInstanceId?: string;
  productKey: string;
  static names(): { [key: string]: string } {
    return {
      applyId: 'ApplyId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applyId: 'number',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryBatchRegisterDeviceStatusResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: QueryBatchRegisterDeviceStatusResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: QueryBatchRegisterDeviceStatusResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCertUrlByApplyIdRequest extends $tea.Model {
  applyId: number;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      applyId: 'ApplyId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applyId: 'number',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCertUrlByApplyIdResponse extends $tea.Model {
  certUrl: string;
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      certUrl: 'CertUrl',
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      certUrl: 'string',
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryClientIdsRequest extends $tea.Model {
  iotId: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryClientIdsResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: QueryClientIdsResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: QueryClientIdsResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryConsumerGroupByGroupIdRequest extends $tea.Model {
  groupId: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryConsumerGroupByGroupIdResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: QueryConsumerGroupByGroupIdResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: QueryConsumerGroupByGroupIdResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryConsumerGroupListRequest extends $tea.Model {
  currentPage: number;
  fuzzy?: boolean;
  groupName?: string;
  iotInstanceId?: string;
  pageSize: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      fuzzy: 'Fuzzy',
      groupName: 'GroupName',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      fuzzy: 'boolean',
      groupName: 'string',
      iotInstanceId: 'string',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryConsumerGroupListResponse extends $tea.Model {
  code: string;
  currentPage: number;
  errorMessage: string;
  pageCount: number;
  pageSize: number;
  requestId: string;
  success: boolean;
  total: number;
  data: QueryConsumerGroupListResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      currentPage: 'CurrentPage',
      errorMessage: 'ErrorMessage',
      pageCount: 'PageCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      total: 'Total',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      currentPage: 'number',
      errorMessage: 'string',
      pageCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      total: 'number',
      data: QueryConsumerGroupListResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryConsumerGroupStatusRequest extends $tea.Model {
  groupId: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryConsumerGroupStatusResponse extends $tea.Model {
  accumulatedConsumeCountPerMinute: number;
  accumulationCount: number;
  code: string;
  consumerSpeed: number;
  errorMessage: string;
  lastConsumerTime: string;
  realTimeConsumeCountPerMinute: number;
  requestId: string;
  success: boolean;
  clientConnectionStatusList: QueryConsumerGroupStatusResponseClientConnectionStatusList;
  static names(): { [key: string]: string } {
    return {
      accumulatedConsumeCountPerMinute: 'AccumulatedConsumeCountPerMinute',
      accumulationCount: 'AccumulationCount',
      code: 'Code',
      consumerSpeed: 'ConsumerSpeed',
      errorMessage: 'ErrorMessage',
      lastConsumerTime: 'LastConsumerTime',
      realTimeConsumeCountPerMinute: 'RealTimeConsumeCountPerMinute',
      requestId: 'RequestId',
      success: 'Success',
      clientConnectionStatusList: 'ClientConnectionStatusList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accumulatedConsumeCountPerMinute: 'number',
      accumulationCount: 'number',
      code: 'string',
      consumerSpeed: 'number',
      errorMessage: 'string',
      lastConsumerTime: 'string',
      realTimeConsumeCountPerMinute: 'number',
      requestId: 'string',
      success: 'boolean',
      clientConnectionStatusList: QueryConsumerGroupStatusResponseClientConnectionStatusList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDetailSceneRuleLogRequest extends $tea.Model {
  currentPage: number;
  endTime: number;
  iotInstanceId?: string;
  pageSize: number;
  ruleId: string;
  startTime: number;
  traceId: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      endTime: 'EndTime',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
      ruleId: 'RuleId',
      startTime: 'StartTime',
      traceId: 'TraceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      endTime: 'number',
      iotInstanceId: 'string',
      pageSize: 'number',
      ruleId: 'string',
      startTime: 'number',
      traceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDetailSceneRuleLogResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: QueryDetailSceneRuleLogResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: QueryDetailSceneRuleLogResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceRequest extends $tea.Model {
  currentPage?: number;
  iotInstanceId?: string;
  nextToken?: string;
  pageSize?: number;
  productKey: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      iotInstanceId: 'IotInstanceId',
      nextToken: 'NextToken',
      pageSize: 'PageSize',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      iotInstanceId: 'string',
      nextToken: 'string',
      pageSize: 'number',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  nextToken: string;
  page: number;
  pageCount: number;
  pageSize: number;
  requestId: string;
  success: boolean;
  total: number;
  data: QueryDeviceResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      nextToken: 'NextToken',
      page: 'Page',
      pageCount: 'PageCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      total: 'Total',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      nextToken: 'string',
      page: 'number',
      pageCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      total: 'number',
      data: QueryDeviceResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceBySQLRequest extends $tea.Model {
  iotInstanceId?: string;
  SQL: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      SQL: 'SQL',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      SQL: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceBySQLResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  totalCount: number;
  data: QueryDeviceBySQLResponseData[];
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
      data: { 'type': 'array', 'itemType': QueryDeviceBySQLResponseData },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceByStatusRequest extends $tea.Model {
  currentPage?: number;
  iotInstanceId?: string;
  pageSize?: number;
  productKey?: string;
  resourceGroupId?: string;
  status: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
      productKey: 'ProductKey',
      resourceGroupId: 'ResourceGroupId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      iotInstanceId: 'string',
      pageSize: 'number',
      productKey: 'string',
      resourceGroupId: 'string',
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceByStatusResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  page: number;
  pageCount: number;
  pageSize: number;
  requestId: string;
  success: boolean;
  total: number;
  data: QueryDeviceByStatusResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      page: 'Page',
      pageCount: 'PageCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      total: 'Total',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      page: 'number',
      pageCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      total: 'number',
      data: QueryDeviceByStatusResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceByTagsRequest extends $tea.Model {
  currentPage?: number;
  iotInstanceId?: string;
  pageSize?: number;
  tag?: QueryDeviceByTagsRequestTag[];
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      iotInstanceId: 'string',
      pageSize: 'number',
      tag: { 'type': 'array', 'itemType': QueryDeviceByTagsRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceByTagsResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  page: number;
  pageCount: number;
  pageSize: number;
  requestId: string;
  success: boolean;
  total: number;
  data: QueryDeviceByTagsResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      page: 'Page',
      pageCount: 'PageCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      total: 'Total',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      page: 'number',
      pageCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      total: 'number',
      data: QueryDeviceByTagsResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceCertRequest extends $tea.Model {
  deviceName: string;
  iotInstanceId?: string;
  productKey: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceCertResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  deviceCertInfo: QueryDeviceCertResponseDeviceCertInfo;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      deviceCertInfo: 'DeviceCertInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      deviceCertInfo: QueryDeviceCertResponseDeviceCertInfo,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceDesiredPropertyRequest extends $tea.Model {
  deviceName?: string;
  functionBlockId?: string;
  identifier?: string[];
  iotId?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      functionBlockId: 'FunctionBlockId',
      identifier: 'Identifier',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      functionBlockId: 'string',
      identifier: { 'type': 'array', 'itemType': 'string' },
      iotId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceDesiredPropertyResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: QueryDeviceDesiredPropertyResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: QueryDeviceDesiredPropertyResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceDetailRequest extends $tea.Model {
  deviceName?: string;
  iotId?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceDetailResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: QueryDeviceDetailResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: QueryDeviceDetailResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceDistributeDetailRequest extends $tea.Model {
  jobId: string;
  static names(): { [key: string]: string } {
    return {
      jobId: 'JobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      jobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceDistributeDetailResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  file: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      file: 'File',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      file: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceDistributeJobRequest extends $tea.Model {
  jobId: string;
  static names(): { [key: string]: string } {
    return {
      jobId: 'JobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      jobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceDistributeJobResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: QueryDeviceDistributeJobResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: QueryDeviceDistributeJobResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceEventDataRequest extends $tea.Model {
  asc?: number;
  deviceName?: string;
  endTime: number;
  eventType?: string;
  identifier?: string;
  iotId?: string;
  iotInstanceId?: string;
  pageSize?: number;
  productKey?: string;
  startTime: number;
  static names(): { [key: string]: string } {
    return {
      asc: 'Asc',
      deviceName: 'DeviceName',
      endTime: 'EndTime',
      eventType: 'EventType',
      identifier: 'Identifier',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
      productKey: 'ProductKey',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      asc: 'number',
      deviceName: 'string',
      endTime: 'number',
      eventType: 'string',
      identifier: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      pageSize: 'number',
      productKey: 'string',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceEventDataResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: QueryDeviceEventDataResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: QueryDeviceEventDataResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceFileRequest extends $tea.Model {
  deviceName?: string;
  fileId: string;
  iotId?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      fileId: 'FileId',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      fileId: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceFileResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: QueryDeviceFileResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: QueryDeviceFileResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceFileListRequest extends $tea.Model {
  currentPage?: number;
  deviceName?: string;
  iotId?: string;
  iotInstanceId?: string;
  pageSize?: number;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      deviceName: 'DeviceName',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      deviceName: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      pageSize: 'number',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceFileListResponse extends $tea.Model {
  code: string;
  currentPage: number;
  errorMessage: string;
  pageCount: number;
  pageSize: number;
  requestId: string;
  success: boolean;
  total: number;
  data: QueryDeviceFileListResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      currentPage: 'CurrentPage',
      errorMessage: 'ErrorMessage',
      pageCount: 'PageCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      total: 'Total',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      currentPage: 'number',
      errorMessage: 'string',
      pageCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      total: 'number',
      data: QueryDeviceFileListResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceGroupByDeviceRequest extends $tea.Model {
  deviceName: string;
  iotInstanceId?: string;
  productKey: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceGroupByDeviceResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  groupInfos: QueryDeviceGroupByDeviceResponseGroupInfos;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      groupInfos: 'GroupInfos',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      groupInfos: QueryDeviceGroupByDeviceResponseGroupInfos,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceGroupByTagsRequest extends $tea.Model {
  currentPage?: number;
  iotInstanceId?: string;
  pageSize?: number;
  tag?: QueryDeviceGroupByTagsRequestTag[];
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      iotInstanceId: 'string',
      pageSize: 'number',
      tag: { 'type': 'array', 'itemType': QueryDeviceGroupByTagsRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceGroupByTagsResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  page: number;
  pageCount: number;
  pageSize: number;
  requestId: string;
  success: boolean;
  total: number;
  data: QueryDeviceGroupByTagsResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      page: 'Page',
      pageCount: 'PageCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      total: 'Total',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      page: 'number',
      pageCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      total: 'number',
      data: QueryDeviceGroupByTagsResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceGroupInfoRequest extends $tea.Model {
  groupId: string;
  groupType?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      groupType: 'GroupType',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      groupType: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceGroupInfoResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: QueryDeviceGroupInfoResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: QueryDeviceGroupInfoResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceGroupListRequest extends $tea.Model {
  currentPage?: number;
  groupName?: string;
  groupTypes?: string[];
  iotInstanceId?: string;
  pageSize?: number;
  superGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      groupName: 'GroupName',
      groupTypes: 'GroupTypes',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
      superGroupId: 'SuperGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      groupName: 'string',
      groupTypes: { 'type': 'array', 'itemType': 'string' },
      iotInstanceId: 'string',
      pageSize: 'number',
      superGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceGroupListResponse extends $tea.Model {
  code: string;
  currentPage: number;
  errorMessage: string;
  pageCount: number;
  pageSize: number;
  requestId: string;
  success: boolean;
  total: number;
  data: QueryDeviceGroupListResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      currentPage: 'CurrentPage',
      errorMessage: 'ErrorMessage',
      pageCount: 'PageCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      total: 'Total',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      currentPage: 'number',
      errorMessage: 'string',
      pageCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      total: 'number',
      data: QueryDeviceGroupListResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceGroupTagListRequest extends $tea.Model {
  groupId: string;
  groupType?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      groupType: 'GroupType',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      groupType: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceGroupTagListResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: QueryDeviceGroupTagListResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: QueryDeviceGroupTagListResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceInfoRequest extends $tea.Model {
  deviceName?: string;
  iotId?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceInfoResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: QueryDeviceInfoResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: QueryDeviceInfoResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceListByDeviceGroupRequest extends $tea.Model {
  currentPage?: number;
  groupId: string;
  iotInstanceId?: string;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      groupId: 'GroupId',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      groupId: 'string',
      iotInstanceId: 'string',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceListByDeviceGroupResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  page: number;
  pageCount: number;
  pageSize: number;
  requestId: string;
  success: boolean;
  total: number;
  data: QueryDeviceListByDeviceGroupResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      page: 'Page',
      pageCount: 'PageCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      total: 'Total',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      page: 'number',
      pageCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      total: 'number',
      data: QueryDeviceListByDeviceGroupResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceOriginalEventDataRequest extends $tea.Model {
  asc: number;
  deviceName?: string;
  endTime: number;
  identifier: string;
  iotId?: string;
  iotInstanceId?: string;
  nextPageToken?: string;
  pageSize: number;
  productKey?: string;
  startTime: number;
  static names(): { [key: string]: string } {
    return {
      asc: 'Asc',
      deviceName: 'DeviceName',
      endTime: 'EndTime',
      identifier: 'Identifier',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      nextPageToken: 'NextPageToken',
      pageSize: 'PageSize',
      productKey: 'ProductKey',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      asc: 'number',
      deviceName: 'string',
      endTime: 'number',
      identifier: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      nextPageToken: 'string',
      pageSize: 'number',
      productKey: 'string',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceOriginalEventDataResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: QueryDeviceOriginalEventDataResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: QueryDeviceOriginalEventDataResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceOriginalPropertyDataRequest extends $tea.Model {
  asc: number;
  deviceName?: string;
  endTime: number;
  identifier: string;
  iotId?: string;
  iotInstanceId?: string;
  nextPageToken?: string;
  pageSize: number;
  productKey?: string;
  startTime: number;
  static names(): { [key: string]: string } {
    return {
      asc: 'Asc',
      deviceName: 'DeviceName',
      endTime: 'EndTime',
      identifier: 'Identifier',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      nextPageToken: 'NextPageToken',
      pageSize: 'PageSize',
      productKey: 'ProductKey',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      asc: 'number',
      deviceName: 'string',
      endTime: 'number',
      identifier: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      nextPageToken: 'string',
      pageSize: 'number',
      productKey: 'string',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceOriginalPropertyDataResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: QueryDeviceOriginalPropertyDataResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: QueryDeviceOriginalPropertyDataResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceOriginalPropertyStatusRequest extends $tea.Model {
  asc: number;
  deviceName?: string;
  iotId?: string;
  iotInstanceId?: string;
  nextPageToken?: string;
  pageSize: number;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      asc: 'Asc',
      deviceName: 'DeviceName',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      nextPageToken: 'NextPageToken',
      pageSize: 'PageSize',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      asc: 'number',
      deviceName: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      nextPageToken: 'string',
      pageSize: 'number',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceOriginalPropertyStatusResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: QueryDeviceOriginalPropertyStatusResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: QueryDeviceOriginalPropertyStatusResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceOriginalServiceDataRequest extends $tea.Model {
  asc: number;
  deviceName?: string;
  endTime: number;
  identifier: string;
  iotId?: string;
  iotInstanceId?: string;
  nextPageToken?: string;
  pageSize: number;
  productKey?: string;
  startTime: number;
  static names(): { [key: string]: string } {
    return {
      asc: 'Asc',
      deviceName: 'DeviceName',
      endTime: 'EndTime',
      identifier: 'Identifier',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      nextPageToken: 'NextPageToken',
      pageSize: 'PageSize',
      productKey: 'ProductKey',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      asc: 'number',
      deviceName: 'string',
      endTime: 'number',
      identifier: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      nextPageToken: 'string',
      pageSize: 'number',
      productKey: 'string',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceOriginalServiceDataResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: QueryDeviceOriginalServiceDataResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: QueryDeviceOriginalServiceDataResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicePropRequest extends $tea.Model {
  deviceName?: string;
  iotId?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicePropResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  props: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      props: 'Props',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      props: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicePropertiesDataRequest extends $tea.Model {
  asc: number;
  deviceName?: string;
  endTime: number;
  identifier: string[];
  iotId?: string;
  iotInstanceId?: string;
  pageSize: number;
  productKey?: string;
  startTime: number;
  static names(): { [key: string]: string } {
    return {
      asc: 'Asc',
      deviceName: 'DeviceName',
      endTime: 'EndTime',
      identifier: 'Identifier',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
      productKey: 'ProductKey',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      asc: 'number',
      deviceName: 'string',
      endTime: 'number',
      identifier: { 'type': 'array', 'itemType': 'string' },
      iotId: 'string',
      iotInstanceId: 'string',
      pageSize: 'number',
      productKey: 'string',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicePropertiesDataResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  nextTime: number;
  nextValid: boolean;
  requestId: string;
  success: boolean;
  propertyDataInfos: QueryDevicePropertiesDataResponsePropertyDataInfos;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      nextTime: 'NextTime',
      nextValid: 'NextValid',
      requestId: 'RequestId',
      success: 'Success',
      propertyDataInfos: 'PropertyDataInfos',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      nextTime: 'number',
      nextValid: 'boolean',
      requestId: 'string',
      success: 'boolean',
      propertyDataInfos: QueryDevicePropertiesDataResponsePropertyDataInfos,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicePropertyDataRequest extends $tea.Model {
  asc: number;
  deviceName?: string;
  endTime: number;
  identifier: string;
  iotId?: string;
  iotInstanceId?: string;
  pageSize: number;
  productKey?: string;
  startTime: number;
  static names(): { [key: string]: string } {
    return {
      asc: 'Asc',
      deviceName: 'DeviceName',
      endTime: 'EndTime',
      identifier: 'Identifier',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
      productKey: 'ProductKey',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      asc: 'number',
      deviceName: 'string',
      endTime: 'number',
      identifier: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      pageSize: 'number',
      productKey: 'string',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicePropertyDataResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: QueryDevicePropertyDataResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: QueryDevicePropertyDataResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicePropertyStatusRequest extends $tea.Model {
  deviceName?: string;
  functionBlockId?: string;
  iotId?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      functionBlockId: 'FunctionBlockId',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      functionBlockId: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicePropertyStatusResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: QueryDevicePropertyStatusResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: QueryDevicePropertyStatusResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceServiceDataRequest extends $tea.Model {
  asc?: number;
  deviceName?: string;
  endTime: number;
  identifier?: string;
  iotId?: string;
  iotInstanceId?: string;
  pageSize?: number;
  productKey?: string;
  startTime: number;
  static names(): { [key: string]: string } {
    return {
      asc: 'Asc',
      deviceName: 'DeviceName',
      endTime: 'EndTime',
      identifier: 'Identifier',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
      productKey: 'ProductKey',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      asc: 'number',
      deviceName: 'string',
      endTime: 'number',
      identifier: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      pageSize: 'number',
      productKey: 'string',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceServiceDataResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: QueryDeviceServiceDataResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: QueryDeviceServiceDataResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceSpeechRequest extends $tea.Model {
  iotId: string;
  iotInstanceId?: string;
  pageId?: number;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      pageId: 'PageId',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotId: 'string',
      iotInstanceId: 'string',
      pageId: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceSpeechResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: QueryDeviceSpeechResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: QueryDeviceSpeechResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceStatisticsRequest extends $tea.Model {
  groupId?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceStatisticsResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: QueryDeviceStatisticsResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: QueryDeviceStatisticsResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceSubTopicRequest extends $tea.Model {
  deviceName: string;
  iotInstanceId?: string;
  productKey: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceSubTopicResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  topicList: QueryDeviceSubTopicResponseTopicList[];
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      topicList: 'TopicList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      topicList: { 'type': 'array', 'itemType': QueryDeviceSubTopicResponseTopicList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceTunnelRequest extends $tea.Model {
  tunnelId: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      tunnelId: 'TunnelId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tunnelId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceTunnelResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: QueryDeviceTunnelResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: QueryDeviceTunnelResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicesHotStorageDataRequest extends $tea.Model {
  asc: number;
  deviceName?: string;
  endTime: number;
  identifier: string;
  iotId?: string;
  iotInstanceId: string;
  nextPageToken?: string;
  pageSize: number;
  productKey?: string;
  startTime: number;
  userTopic: string;
  static names(): { [key: string]: string } {
    return {
      asc: 'Asc',
      deviceName: 'DeviceName',
      endTime: 'EndTime',
      identifier: 'Identifier',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      nextPageToken: 'NextPageToken',
      pageSize: 'PageSize',
      productKey: 'ProductKey',
      startTime: 'StartTime',
      userTopic: 'UserTopic',
    };
  }

  static types(): { [key: string]: any } {
    return {
      asc: 'number',
      deviceName: 'string',
      endTime: 'number',
      identifier: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      nextPageToken: 'string',
      pageSize: 'number',
      productKey: 'string',
      startTime: 'number',
      userTopic: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicesHotStorageDataResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: QueryDevicesHotStorageDataResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: QueryDevicesHotStorageDataResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicesHotStorageDataStatusRequest extends $tea.Model {
  asc: number;
  deviceName?: string;
  iotId?: string;
  iotInstanceId: string;
  nextPageToken?: string;
  pageSize: number;
  productKey?: string;
  userTopic: string;
  static names(): { [key: string]: string } {
    return {
      asc: 'Asc',
      deviceName: 'DeviceName',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      nextPageToken: 'NextPageToken',
      pageSize: 'PageSize',
      productKey: 'ProductKey',
      userTopic: 'UserTopic',
    };
  }

  static types(): { [key: string]: any } {
    return {
      asc: 'number',
      deviceName: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      nextPageToken: 'string',
      pageSize: 'number',
      productKey: 'string',
      userTopic: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicesHotStorageDataStatusResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: QueryDevicesHotStorageDataStatusResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: QueryDevicesHotStorageDataStatusResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDynamicGroupDevicesRequest extends $tea.Model {
  currentPage?: number;
  deviceName?: string;
  fuzzyName?: boolean;
  groupId: string;
  iotInstanceId: string;
  nextToken?: string;
  pageSize?: number;
  productKey?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      deviceName: 'DeviceName',
      fuzzyName: 'FuzzyName',
      groupId: 'GroupId',
      iotInstanceId: 'IotInstanceId',
      nextToken: 'NextToken',
      pageSize: 'PageSize',
      productKey: 'ProductKey',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      deviceName: 'string',
      fuzzyName: 'boolean',
      groupId: 'string',
      iotInstanceId: 'string',
      nextToken: 'string',
      pageSize: 'number',
      productKey: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDynamicGroupDevicesResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  nextToken: string;
  page: number;
  pageCount: number;
  pageSize: number;
  requestId: string;
  success: boolean;
  total: number;
  data: QueryDynamicGroupDevicesResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      nextToken: 'NextToken',
      page: 'Page',
      pageCount: 'PageCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      total: 'Total',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      nextToken: 'string',
      page: 'number',
      pageCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      total: 'number',
      data: QueryDynamicGroupDevicesResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeDriverRequest extends $tea.Model {
  currentPage: number;
  driverName?: string;
  iotInstanceId?: string;
  pageSize: number;
  type: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      driverName: 'DriverName',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      driverName: 'string',
      iotInstanceId: 'string',
      pageSize: 'number',
      type: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeDriverResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: QueryEdgeDriverResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: QueryEdgeDriverResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeDriverVersionRequest extends $tea.Model {
  currentPage: number;
  driverId: string;
  driverVersion?: string;
  iotInstanceId?: string;
  pageSize: number;
  versionState?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      driverId: 'DriverId',
      driverVersion: 'DriverVersion',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
      versionState: 'VersionState',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      driverId: 'string',
      driverVersion: 'string',
      iotInstanceId: 'string',
      pageSize: 'number',
      versionState: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeDriverVersionResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: QueryEdgeDriverVersionResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: QueryEdgeDriverVersionResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceRequest extends $tea.Model {
  currentPage: number;
  iotInstanceId?: string;
  name?: string;
  pageSize: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      iotInstanceId: 'IotInstanceId',
      name: 'Name',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      iotInstanceId: 'string',
      name: 'string',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: QueryEdgeInstanceResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: QueryEdgeInstanceResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceChannelRequest extends $tea.Model {
  channelName?: string;
  currentPage: number;
  driverId: string;
  instanceId: string;
  iotInstanceId?: string;
  pageSize: number;
  static names(): { [key: string]: string } {
    return {
      channelName: 'ChannelName',
      currentPage: 'CurrentPage',
      driverId: 'DriverId',
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelName: 'string',
      currentPage: 'number',
      driverId: 'string',
      instanceId: 'string',
      iotInstanceId: 'string',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceChannelResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: QueryEdgeInstanceChannelResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: QueryEdgeInstanceChannelResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceDeviceRequest extends $tea.Model {
  currentPage: number;
  instanceId: string;
  iotInstanceId?: string;
  pageSize: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      instanceId: 'string',
      iotInstanceId: 'string',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceDeviceResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: QueryEdgeInstanceDeviceResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: QueryEdgeInstanceDeviceResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceDeviceByDriverRequest extends $tea.Model {
  channelId?: string;
  currentPage: number;
  driverId: string;
  instanceId: string;
  iotInstanceId?: string;
  pageSize: number;
  static names(): { [key: string]: string } {
    return {
      channelId: 'ChannelId',
      currentPage: 'CurrentPage',
      driverId: 'DriverId',
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelId: 'string',
      currentPage: 'number',
      driverId: 'string',
      instanceId: 'string',
      iotInstanceId: 'string',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceDeviceByDriverResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: QueryEdgeInstanceDeviceByDriverResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: QueryEdgeInstanceDeviceByDriverResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceDriverRequest extends $tea.Model {
  currentPage: number;
  instanceId: string;
  iotInstanceId?: string;
  pageSize: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      instanceId: 'string',
      iotInstanceId: 'string',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceDriverResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: QueryEdgeInstanceDriverResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: QueryEdgeInstanceDriverResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceGatewayRequest extends $tea.Model {
  instanceId: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceGatewayResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  gatewayList: QueryEdgeInstanceGatewayResponseGatewayList[];
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      gatewayList: 'GatewayList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      gatewayList: { 'type': 'array', 'itemType': QueryEdgeInstanceGatewayResponseGatewayList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceHistoricDeploymentRequest extends $tea.Model {
  currentPage: number;
  endTime?: number;
  instanceId: string;
  iotInstanceId?: string;
  pageSize: number;
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      endTime: 'EndTime',
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      endTime: 'number',
      instanceId: 'string',
      iotInstanceId: 'string',
      pageSize: 'number',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceHistoricDeploymentResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: QueryEdgeInstanceHistoricDeploymentResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: QueryEdgeInstanceHistoricDeploymentResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceMessageRoutingRequest extends $tea.Model {
  currentPage: number;
  instanceId: string;
  iotInstanceId?: string;
  pageSize: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      instanceId: 'string',
      iotInstanceId: 'string',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceMessageRoutingResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: QueryEdgeInstanceMessageRoutingResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: QueryEdgeInstanceMessageRoutingResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceSceneRuleRequest extends $tea.Model {
  currentPage: number;
  instanceId: string;
  iotInstanceId?: string;
  pageSize: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      instanceId: 'string',
      iotInstanceId: 'string',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceSceneRuleResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: QueryEdgeInstanceSceneRuleResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: QueryEdgeInstanceSceneRuleResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryImportedDeviceByApplyIdRequest extends $tea.Model {
  applyId: number;
  iotInstanceId?: string;
  pageNo: number;
  pageSize: number;
  static names(): { [key: string]: string } {
    return {
      applyId: 'ApplyId',
      iotInstanceId: 'IotInstanceId',
      pageNo: 'PageNo',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applyId: 'number',
      iotInstanceId: 'string',
      pageNo: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryImportedDeviceByApplyIdResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  pageNo: number;
  pageSize: number;
  productKey: string;
  requestId: string;
  success: boolean;
  totalPage: number;
  deviceList: QueryImportedDeviceByApplyIdResponseDeviceList;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      pageNo: 'PageNo',
      pageSize: 'PageSize',
      productKey: 'ProductKey',
      requestId: 'RequestId',
      success: 'Success',
      totalPage: 'TotalPage',
      deviceList: 'DeviceList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      pageNo: 'number',
      pageSize: 'number',
      productKey: 'string',
      requestId: 'string',
      success: 'boolean',
      totalPage: 'number',
      deviceList: QueryImportedDeviceByApplyIdResponseDeviceList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobRequest extends $tea.Model {
  iotInstanceId?: string;
  jobId: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      jobId: 'JobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      jobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: QueryJobResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: QueryJobResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobStatisticsRequest extends $tea.Model {
  iotInstanceId?: string;
  jobId: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      jobId: 'JobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      jobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobStatisticsResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: QueryJobStatisticsResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: QueryJobStatisticsResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryLicenseDeviceListRequest extends $tea.Model {
  endTime?: number;
  iotId?: string;
  iotInstanceId?: string;
  licenseCode?: string;
  pageId?: number;
  pageSize?: number;
  productKey?: string;
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      licenseCode: 'LicenseCode',
      pageId: 'PageId',
      pageSize: 'PageSize',
      productKey: 'ProductKey',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'number',
      iotId: 'string',
      iotInstanceId: 'string',
      licenseCode: 'string',
      pageId: 'number',
      pageSize: 'number',
      productKey: 'string',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryLicenseDeviceListResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: QueryLicenseDeviceListResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: QueryLicenseDeviceListResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryLoRaJoinPermissionsRequest extends $tea.Model {
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryLoRaJoinPermissionsResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  productKey: string;
  requestId: string;
  success: boolean;
  joinPermissions: QueryLoRaJoinPermissionsResponseJoinPermissions;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      productKey: 'ProductKey',
      requestId: 'RequestId',
      success: 'Success',
      joinPermissions: 'JoinPermissions',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      productKey: 'string',
      requestId: 'string',
      success: 'boolean',
      joinPermissions: QueryLoRaJoinPermissionsResponseJoinPermissions,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMessageInfoRequest extends $tea.Model {
  iotInstanceId?: string;
  uniMsgId: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      uniMsgId: 'UniMsgId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      uniMsgId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMessageInfoResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  message: QueryMessageInfoResponseMessage;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      message: 'Message',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      message: QueryMessageInfoResponseMessage,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryOTAFirmwareRequest extends $tea.Model {
  firmwareId: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      firmwareId: 'FirmwareId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      firmwareId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryOTAFirmwareResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  firmwareInfo: QueryOTAFirmwareResponseFirmwareInfo;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      firmwareInfo: 'FirmwareInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      firmwareInfo: QueryOTAFirmwareResponseFirmwareInfo,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryOTAJobRequest extends $tea.Model {
  iotInstanceId?: string;
  jobId: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      jobId: 'JobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      jobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryOTAJobResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: QueryOTAJobResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: QueryOTAJobResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryPageByApplyIdRequest extends $tea.Model {
  applyId: number;
  currentPage?: number;
  iotInstanceId?: string;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      applyId: 'ApplyId',
      currentPage: 'CurrentPage',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applyId: 'number',
      currentPage: 'number',
      iotInstanceId: 'string',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryPageByApplyIdResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  page: number;
  pageCount: number;
  pageSize: number;
  requestId: string;
  success: boolean;
  total: number;
  applyDeviceList: QueryPageByApplyIdResponseApplyDeviceList;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      page: 'Page',
      pageCount: 'PageCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      total: 'Total',
      applyDeviceList: 'ApplyDeviceList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      page: 'number',
      pageCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      total: 'number',
      applyDeviceList: QueryPageByApplyIdResponseApplyDeviceList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryProductRequest extends $tea.Model {
  iotInstanceId?: string;
  productKey: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryProductResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: QueryProductResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: QueryProductResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryProductCertInfoRequest extends $tea.Model {
  iotInstanceId?: string;
  productKey: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryProductCertInfoResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  productCertInfo: QueryProductCertInfoResponseProductCertInfo;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      productCertInfo: 'ProductCertInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      productCertInfo: QueryProductCertInfoResponseProductCertInfo,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryProductListRequest extends $tea.Model {
  aliyunCommodityCode?: string;
  currentPage: number;
  iotInstanceId?: string;
  pageSize: number;
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      aliyunCommodityCode: 'AliyunCommodityCode',
      currentPage: 'CurrentPage',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunCommodityCode: 'string',
      currentPage: 'number',
      iotInstanceId: 'string',
      pageSize: 'number',
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryProductListResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: QueryProductListResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: QueryProductListResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryProductTopicRequest extends $tea.Model {
  iotInstanceId?: string;
  productKey: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryProductTopicResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: QueryProductTopicResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: QueryProductTopicResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryProjectShareDeviceListRequest extends $tea.Model {
  deviceName?: string;
  iotInstanceId?: string;
  pageId?: number;
  pageSize?: number;
  productKey: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotInstanceId: 'IotInstanceId',
      pageId: 'PageId',
      pageSize: 'PageSize',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotInstanceId: 'string',
      pageId: 'number',
      pageSize: 'number',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryProjectShareDeviceListResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: QueryProjectShareDeviceListResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: QueryProjectShareDeviceListResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySceneRuleRequest extends $tea.Model {
  currentPage: number;
  iotInstanceId?: string;
  pageSize: number;
  ruleName?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
      ruleName: 'RuleName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      iotInstanceId: 'string',
      pageSize: 'number',
      ruleName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySceneRuleResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: QuerySceneRuleResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: QuerySceneRuleResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySchedulePeriodListRequest extends $tea.Model {
  iotInstanceId?: string;
  pageId?: number;
  pageSize?: number;
  scheduleCode: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      pageId: 'PageId',
      pageSize: 'PageSize',
      scheduleCode: 'ScheduleCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      pageId: 'number',
      pageSize: 'number',
      scheduleCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySchedulePeriodListResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: QuerySchedulePeriodListResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: QuerySchedulePeriodListResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryShareTaskDeviceListRequest extends $tea.Model {
  deviceName?: string;
  iotInstanceId?: string;
  pageId?: number;
  pageSize?: number;
  shareTaskId: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotInstanceId: 'IotInstanceId',
      pageId: 'PageId',
      pageSize: 'PageSize',
      shareTaskId: 'ShareTaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotInstanceId: 'string',
      pageId: 'number',
      pageSize: 'number',
      shareTaskId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryShareTaskDeviceListResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: QueryShareTaskDeviceListResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: QueryShareTaskDeviceListResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySolutionDeviceGroupPageRequest extends $tea.Model {
  fuzzyGroupName?: string;
  iotInstanceId?: string;
  pageId: number;
  pageSize: number;
  projectCode: string;
  static names(): { [key: string]: string } {
    return {
      fuzzyGroupName: 'FuzzyGroupName',
      iotInstanceId: 'IotInstanceId',
      pageId: 'PageId',
      pageSize: 'PageSize',
      projectCode: 'ProjectCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fuzzyGroupName: 'string',
      iotInstanceId: 'string',
      pageId: 'number',
      pageSize: 'number',
      projectCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySolutionDeviceGroupPageResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: QuerySolutionDeviceGroupPageResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: QuerySolutionDeviceGroupPageResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySoundCodeLabelBatchFailedResultRequest extends $tea.Model {
  batchCode: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      batchCode: 'BatchCode',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      batchCode: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySoundCodeLabelBatchFailedResultResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: QuerySoundCodeLabelBatchFailedResultResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: QuerySoundCodeLabelBatchFailedResultResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySoundCodeLabelBatchListRequest extends $tea.Model {
  iotInstanceId?: string;
  pageId?: number;
  pageSize?: number;
  scheduleCode: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      pageId: 'PageId',
      pageSize: 'PageSize',
      scheduleCode: 'ScheduleCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      pageId: 'number',
      pageSize: 'number',
      scheduleCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySoundCodeLabelBatchListResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: QuerySoundCodeLabelBatchListResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: QuerySoundCodeLabelBatchListResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySoundCodeLabelListRequest extends $tea.Model {
  iotInstanceId?: string;
  pageId?: number;
  pageSize?: number;
  scheduleCode: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      pageId: 'PageId',
      pageSize: 'PageSize',
      scheduleCode: 'ScheduleCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      pageId: 'number',
      pageSize: 'number',
      scheduleCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySoundCodeLabelListResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: QuerySoundCodeLabelListResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: QuerySoundCodeLabelListResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySoundCodeListRequest extends $tea.Model {
  iotInstanceId?: string;
  pageId?: number;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      pageId: 'PageId',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      pageId: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySoundCodeListResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: QuerySoundCodeListResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: QuerySoundCodeListResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySoundCodeScheduleListRequest extends $tea.Model {
  iotInstanceId?: string;
  pageId?: number;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      pageId: 'PageId',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      pageId: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySoundCodeScheduleListResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: QuerySoundCodeScheduleListResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: QuerySoundCodeScheduleListResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechRequest extends $tea.Model {
  iotInstanceId?: string;
  speechCode: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      speechCode: 'SpeechCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      speechCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: QuerySpeechResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: QuerySpeechResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechDeviceRequest extends $tea.Model {
  availableSpace?: string;
  availableSpaceScope?: string;
  deviceName?: string;
  iotInstanceId?: string;
  pageId?: number;
  pageSize?: number;
  projectCode: string;
  static names(): { [key: string]: string } {
    return {
      availableSpace: 'AvailableSpace',
      availableSpaceScope: 'AvailableSpaceScope',
      deviceName: 'DeviceName',
      iotInstanceId: 'IotInstanceId',
      pageId: 'PageId',
      pageSize: 'PageSize',
      projectCode: 'ProjectCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      availableSpace: 'string',
      availableSpaceScope: 'string',
      deviceName: 'string',
      iotInstanceId: 'string',
      pageId: 'number',
      pageSize: 'number',
      projectCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechDeviceResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: QuerySpeechDeviceResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: QuerySpeechDeviceResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechLicenseDeviceListRequest extends $tea.Model {
  checkGroupId?: string;
  deviceName?: string;
  iotInstanceId?: string;
  licenseStatusList?: string[];
  pageId?: number;
  pageSize?: number;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      checkGroupId: 'CheckGroupId',
      deviceName: 'DeviceName',
      iotInstanceId: 'IotInstanceId',
      licenseStatusList: 'LicenseStatusList',
      pageId: 'PageId',
      pageSize: 'PageSize',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkGroupId: 'string',
      deviceName: 'string',
      iotInstanceId: 'string',
      licenseStatusList: { 'type': 'array', 'itemType': 'string' },
      pageId: 'number',
      pageSize: 'number',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechLicenseDeviceListResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: QuerySpeechLicenseDeviceListResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: QuerySpeechLicenseDeviceListResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechListRequest extends $tea.Model {
  audioFormat?: string;
  iotInstanceId?: string;
  pageId?: number;
  pageSize?: number;
  projectCode: string;
  static names(): { [key: string]: string } {
    return {
      audioFormat: 'AudioFormat',
      iotInstanceId: 'IotInstanceId',
      pageId: 'PageId',
      pageSize: 'PageSize',
      projectCode: 'ProjectCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      audioFormat: 'string',
      iotInstanceId: 'string',
      pageId: 'number',
      pageSize: 'number',
      projectCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechListResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: QuerySpeechListResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: QuerySpeechListResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechPushJobRequest extends $tea.Model {
  iotInstanceId?: string;
  jobCode?: string;
  pageId?: number;
  pageSize?: number;
  projectCode: string;
  pushMode?: string;
  statusList?: string[];
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      jobCode: 'JobCode',
      pageId: 'PageId',
      pageSize: 'PageSize',
      projectCode: 'ProjectCode',
      pushMode: 'PushMode',
      statusList: 'StatusList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      jobCode: 'string',
      pageId: 'number',
      pageSize: 'number',
      projectCode: 'string',
      pushMode: 'string',
      statusList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechPushJobResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: QuerySpeechPushJobResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: QuerySpeechPushJobResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechPushJobDeviceRequest extends $tea.Model {
  deviceName?: string;
  iotInstanceId?: string;
  jobCode: string;
  pageId?: number;
  pageSize?: number;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotInstanceId: 'IotInstanceId',
      jobCode: 'JobCode',
      pageId: 'PageId',
      pageSize: 'PageSize',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotInstanceId: 'string',
      jobCode: 'string',
      pageId: 'number',
      pageSize: 'number',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechPushJobDeviceResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: QuerySpeechPushJobDeviceResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: QuerySpeechPushJobDeviceResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechPushJobSpeechRequest extends $tea.Model {
  iotInstanceId?: string;
  jobCode: string;
  pageId?: number;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      jobCode: 'JobCode',
      pageId: 'PageId',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      jobCode: 'string',
      pageId: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechPushJobSpeechResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: QuerySpeechPushJobSpeechResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: QuerySpeechPushJobSpeechResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryStudioAppDomainListOpenRequest extends $tea.Model {
  appId: string;
  iotInstanceId?: string;
  projectId: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      iotInstanceId: 'IotInstanceId',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      iotInstanceId: 'string',
      projectId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryStudioAppDomainListOpenResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: QueryStudioAppDomainListOpenResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: QueryStudioAppDomainListOpenResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryStudioAppListRequest extends $tea.Model {
  fuzzyName?: string;
  iotInstanceId?: string;
  pageNo?: number;
  pageSize?: number;
  projectId: string;
  types: string[];
  static names(): { [key: string]: string } {
    return {
      fuzzyName: 'FuzzyName',
      iotInstanceId: 'IotInstanceId',
      pageNo: 'PageNo',
      pageSize: 'PageSize',
      projectId: 'ProjectId',
      types: 'Types',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fuzzyName: 'string',
      iotInstanceId: 'string',
      pageNo: 'number',
      pageSize: 'number',
      projectId: 'string',
      types: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryStudioAppListResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: QueryStudioAppListResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: QueryStudioAppListResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryStudioAppPageListOpenRequest extends $tea.Model {
  appId: string;
  iotInstanceId?: string;
  isRelease?: boolean;
  pageNo?: number;
  pageSize?: number;
  projectId: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      iotInstanceId: 'IotInstanceId',
      isRelease: 'IsRelease',
      pageNo: 'PageNo',
      pageSize: 'PageSize',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      iotInstanceId: 'string',
      isRelease: 'boolean',
      pageNo: 'number',
      pageSize: 'number',
      projectId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryStudioAppPageListOpenResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: QueryStudioAppPageListOpenResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: QueryStudioAppPageListOpenResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryStudioProjectListRequest extends $tea.Model {
  iotInstanceId?: string;
  name?: string;
  pageNo?: number;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      name: 'Name',
      pageNo: 'PageNo',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      name: 'string',
      pageNo: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryStudioProjectListResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: QueryStudioProjectListResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: QueryStudioProjectListResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySubscribeRelationRequest extends $tea.Model {
  iotInstanceId?: string;
  productKey: string;
  type: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      productKey: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySubscribeRelationResponse extends $tea.Model {
  code: string;
  deviceDataFlag: boolean;
  deviceLifeCycleFlag: boolean;
  deviceStatusChangeFlag: boolean;
  deviceTagFlag: boolean;
  deviceTopoLifeCycleFlag: boolean;
  errorMessage: string;
  foundDeviceListFlag: boolean;
  mnsConfiguration: string;
  otaEventFlag: boolean;
  otaJobFlag: boolean;
  otaVersionFlag: boolean;
  productKey: string;
  requestId: string;
  subscribeFlags: string;
  success: boolean;
  thingHistoryFlag: boolean;
  type: string;
  consumerGroupIds: string[];
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      deviceDataFlag: 'DeviceDataFlag',
      deviceLifeCycleFlag: 'DeviceLifeCycleFlag',
      deviceStatusChangeFlag: 'DeviceStatusChangeFlag',
      deviceTagFlag: 'DeviceTagFlag',
      deviceTopoLifeCycleFlag: 'DeviceTopoLifeCycleFlag',
      errorMessage: 'ErrorMessage',
      foundDeviceListFlag: 'FoundDeviceListFlag',
      mnsConfiguration: 'MnsConfiguration',
      otaEventFlag: 'OtaEventFlag',
      otaJobFlag: 'OtaJobFlag',
      otaVersionFlag: 'OtaVersionFlag',
      productKey: 'ProductKey',
      requestId: 'RequestId',
      subscribeFlags: 'SubscribeFlags',
      success: 'Success',
      thingHistoryFlag: 'ThingHistoryFlag',
      type: 'Type',
      consumerGroupIds: 'ConsumerGroupIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      deviceDataFlag: 'boolean',
      deviceLifeCycleFlag: 'boolean',
      deviceStatusChangeFlag: 'boolean',
      deviceTagFlag: 'boolean',
      deviceTopoLifeCycleFlag: 'boolean',
      errorMessage: 'string',
      foundDeviceListFlag: 'boolean',
      mnsConfiguration: 'string',
      otaEventFlag: 'boolean',
      otaJobFlag: 'boolean',
      otaVersionFlag: 'boolean',
      productKey: 'string',
      requestId: 'string',
      subscribeFlags: 'string',
      success: 'boolean',
      thingHistoryFlag: 'boolean',
      type: 'string',
      consumerGroupIds: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySummarySceneRuleLogRequest extends $tea.Model {
  currentPage: number;
  endTime: number;
  iotInstanceId?: string;
  pageSize: number;
  ruleId: string;
  startTime: number;
  status: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      endTime: 'EndTime',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
      ruleId: 'RuleId',
      startTime: 'StartTime',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      endTime: 'number',
      iotInstanceId: 'string',
      pageSize: 'number',
      ruleId: 'string',
      startTime: 'number',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySummarySceneRuleLogResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: QuerySummarySceneRuleLogResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: QuerySummarySceneRuleLogResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySuperDeviceGroupRequest extends $tea.Model {
  groupId: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySuperDeviceGroupResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: QuerySuperDeviceGroupResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: QuerySuperDeviceGroupResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTaskRequest extends $tea.Model {
  iotInstanceId?: string;
  taskId: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      taskId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTaskResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: QueryTaskResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: QueryTaskResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryThingModelRequest extends $tea.Model {
  functionBlockId?: string;
  iotInstanceId?: string;
  modelVersion?: string;
  productKey?: string;
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      functionBlockId: 'FunctionBlockId',
      iotInstanceId: 'IotInstanceId',
      modelVersion: 'ModelVersion',
      productKey: 'ProductKey',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      functionBlockId: 'string',
      iotInstanceId: 'string',
      modelVersion: 'string',
      productKey: 'string',
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryThingModelResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  productKey: string;
  requestId: string;
  success: boolean;
  data: QueryThingModelResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      productKey: 'ProductKey',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      productKey: 'string',
      requestId: 'string',
      success: 'boolean',
      data: QueryThingModelResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryThingModelExtendConfigRequest extends $tea.Model {
  functionBlockId?: string;
  iotInstanceId?: string;
  modelVersion?: string;
  productKey: string;
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      functionBlockId: 'FunctionBlockId',
      iotInstanceId: 'IotInstanceId',
      modelVersion: 'ModelVersion',
      productKey: 'ProductKey',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      functionBlockId: 'string',
      iotInstanceId: 'string',
      modelVersion: 'string',
      productKey: 'string',
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryThingModelExtendConfigResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: QueryThingModelExtendConfigResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: QueryThingModelExtendConfigResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryThingModelExtendConfigPublishedRequest extends $tea.Model {
  functionBlockId?: string;
  iotInstanceId?: string;
  modelVersion?: string;
  productKey: string;
  static names(): { [key: string]: string } {
    return {
      functionBlockId: 'FunctionBlockId',
      iotInstanceId: 'IotInstanceId',
      modelVersion: 'ModelVersion',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      functionBlockId: 'string',
      iotInstanceId: 'string',
      modelVersion: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryThingModelExtendConfigPublishedResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: QueryThingModelExtendConfigPublishedResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: QueryThingModelExtendConfigPublishedResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryThingModelPublishedRequest extends $tea.Model {
  functionBlockId?: string;
  iotInstanceId?: string;
  modelVersion?: string;
  productKey: string;
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      functionBlockId: 'FunctionBlockId',
      iotInstanceId: 'IotInstanceId',
      modelVersion: 'ModelVersion',
      productKey: 'ProductKey',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      functionBlockId: 'string',
      iotInstanceId: 'string',
      modelVersion: 'string',
      productKey: 'string',
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryThingModelPublishedResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  productKey: string;
  requestId: string;
  success: boolean;
  data: QueryThingModelPublishedResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      productKey: 'ProductKey',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      productKey: 'string',
      requestId: 'string',
      success: 'boolean',
      data: QueryThingModelPublishedResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTopicReverseRouteTableRequest extends $tea.Model {
  iotInstanceId?: string;
  regionId?: string;
  topic: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      regionId: 'RegionId',
      topic: 'Topic',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      regionId: 'string',
      topic: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTopicReverseRouteTableResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  srcTopics: QueryTopicReverseRouteTableResponseSrcTopics;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      srcTopics: 'SrcTopics',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      srcTopics: QueryTopicReverseRouteTableResponseSrcTopics,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTopicRouteTableRequest extends $tea.Model {
  iotInstanceId?: string;
  topic: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      topic: 'Topic',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      topic: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTopicRouteTableResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  dstTopics: QueryTopicRouteTableResponseDstTopics;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      dstTopics: 'DstTopics',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      dstTopics: QueryTopicRouteTableResponseDstTopics,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryVehicleDeviceRequest extends $tea.Model {
  deviceName?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryVehicleDeviceResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: QueryVehicleDeviceResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: QueryVehicleDeviceResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RRpcRequest extends $tea.Model {
  contentType?: string;
  deviceName: string;
  iotInstanceId?: string;
  productKey: string;
  requestBase64Byte: string;
  timeout: number;
  topic?: string;
  static names(): { [key: string]: string } {
    return {
      contentType: 'ContentType',
      deviceName: 'DeviceName',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
      requestBase64Byte: 'RequestBase64Byte',
      timeout: 'Timeout',
      topic: 'Topic',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contentType: 'string',
      deviceName: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
      requestBase64Byte: 'string',
      timeout: 'number',
      topic: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RRpcResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  messageId: number;
  payloadBase64Byte: string;
  requestId: string;
  rrpcCode: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      messageId: 'MessageId',
      payloadBase64Byte: 'PayloadBase64Byte',
      requestId: 'RequestId',
      rrpcCode: 'RrpcCode',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      messageId: 'number',
      payloadBase64Byte: 'string',
      requestId: 'string',
      rrpcCode: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReBindLicenseDeviceRequest extends $tea.Model {
  deviceNameList: string[];
  iotInstanceId?: string;
  licenseCode: string;
  productKey: string;
  static names(): { [key: string]: string } {
    return {
      deviceNameList: 'DeviceNameList',
      iotInstanceId: 'IotInstanceId',
      licenseCode: 'LicenseCode',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceNameList: { 'type': 'array', 'itemType': 'string' },
      iotInstanceId: 'string',
      licenseCode: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReBindLicenseDeviceResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: ReBindLicenseDeviceResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: ReBindLicenseDeviceResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RecognizeCarNumRequest extends $tea.Model {
  url?: string;
  static names(): { [key: string]: string } {
    return {
      url: 'Url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      url: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RecognizeCarNumResponse extends $tea.Model {
  code: string;
  data: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RecognizePictureGeneralRequest extends $tea.Model {
  url: string;
  static names(): { [key: string]: string } {
    return {
      url: 'Url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      url: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RecognizePictureGeneralResponse extends $tea.Model {
  code: string;
  data: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RefreshDeviceTunnelSharePasswordRequest extends $tea.Model {
  deviceName: string;
  iotInstanceId?: string;
  productKey: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RefreshDeviceTunnelSharePasswordResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  password: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      password: 'Password',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      password: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RefreshStudioAppTokenOpenRequest extends $tea.Model {
  appId: string;
  iotInstanceId?: string;
  projectId: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      iotInstanceId: 'IotInstanceId',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      iotInstanceId: 'string',
      projectId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RefreshStudioAppTokenOpenResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: RefreshStudioAppTokenOpenResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: RefreshStudioAppTokenOpenResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RegisterDeviceRequest extends $tea.Model {
  appKey?: string;
  devEui?: string;
  deviceName?: string;
  iotInstanceId?: string;
  joinEui?: string;
  loraNodeType?: string;
  nickname?: string;
  pinCode?: string;
  productKey: string;
  static names(): { [key: string]: string } {
    return {
      appKey: 'AppKey',
      devEui: 'DevEui',
      deviceName: 'DeviceName',
      iotInstanceId: 'IotInstanceId',
      joinEui: 'JoinEui',
      loraNodeType: 'LoraNodeType',
      nickname: 'Nickname',
      pinCode: 'PinCode',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appKey: 'string',
      devEui: 'string',
      deviceName: 'string',
      iotInstanceId: 'string',
      joinEui: 'string',
      loraNodeType: 'string',
      nickname: 'string',
      pinCode: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RegisterDeviceResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: RegisterDeviceResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: RegisterDeviceResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReleaseEdgeDriverVersionRequest extends $tea.Model {
  driverId: string;
  driverVersion: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      driverId: 'DriverId',
      driverVersion: 'DriverVersion',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      driverId: 'string',
      driverVersion: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReleaseEdgeDriverVersionResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReleaseProductRequest extends $tea.Model {
  iotInstanceId?: string;
  productKey: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReleaseProductResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveThingTopoRequest extends $tea.Model {
  deviceName?: string;
  iotId?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveThingTopoResponse extends $tea.Model {
  code: string;
  data: boolean;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'boolean',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReplaceEdgeInstanceGatewayRequest extends $tea.Model {
  currentGatewayId: string;
  instanceId: string;
  iotInstanceId?: string;
  newGatewayId: string;
  static names(): { [key: string]: string } {
    return {
      currentGatewayId: 'CurrentGatewayId',
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
      newGatewayId: 'NewGatewayId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentGatewayId: 'string',
      instanceId: 'string',
      iotInstanceId: 'string',
      newGatewayId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReplaceEdgeInstanceGatewayResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RerunJobRequest extends $tea.Model {
  iotInstanceId?: string;
  jobId: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      jobId: 'JobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      jobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RerunJobResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResetConsumerGroupPositionRequest extends $tea.Model {
  groupId: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResetConsumerGroupPositionResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResetThingRequest extends $tea.Model {
  deviceName?: string;
  iotId?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResetThingResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  jobId: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      jobId: 'JobId',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      jobId: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RetrySoundCodeLabelBatchRequest extends $tea.Model {
  batchCode: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      batchCode: 'BatchCode',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      batchCode: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RetrySoundCodeLabelBatchResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReupgradeOTATaskRequest extends $tea.Model {
  iotInstanceId?: string;
  jobId: string;
  taskId: string[];
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      jobId: 'JobId',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      jobId: 'string',
      taskId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReupgradeOTATaskResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SaveDevicePropRequest extends $tea.Model {
  deviceName?: string;
  iotId?: string;
  iotInstanceId?: string;
  productKey?: string;
  props: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
      props: 'Props',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
      props: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SaveDevicePropResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SaveScriptRequest extends $tea.Model {
  iotInstanceId?: string;
  parserId: number;
  scriptDraft: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      parserId: 'ParserId',
      scriptDraft: 'ScriptDraft',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      parserId: 'number',
      scriptDraft: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SaveScriptResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDeviceDesiredPropertyRequest extends $tea.Model {
  deviceName?: string;
  iotId?: string;
  iotInstanceId?: string;
  items: string;
  productKey?: string;
  versions: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      items: 'Items',
      productKey: 'ProductKey',
      versions: 'Versions',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      items: 'string',
      productKey: 'string',
      versions: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDeviceDesiredPropertyResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: SetDeviceDesiredPropertyResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: SetDeviceDesiredPropertyResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDeviceGroupTagsRequest extends $tea.Model {
  groupId: string;
  groupType?: string;
  iotInstanceId?: string;
  tagString?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      groupType: 'GroupType',
      iotInstanceId: 'IotInstanceId',
      tagString: 'TagString',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      groupType: 'string',
      iotInstanceId: 'string',
      tagString: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDeviceGroupTagsResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDevicePropertyRequest extends $tea.Model {
  deviceName?: string;
  iotId?: string;
  iotInstanceId?: string;
  items: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      items: 'Items',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      items: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDevicePropertyResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: SetDevicePropertyResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: SetDevicePropertyResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDevicesPropertyRequest extends $tea.Model {
  deviceName: string[];
  iotInstanceId?: string;
  items: string;
  productKey: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotInstanceId: 'IotInstanceId',
      items: 'Items',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: { 'type': 'array', 'itemType': 'string' },
      iotInstanceId: 'string',
      items: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDevicesPropertyResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetEdgeInstanceDriverConfigsRequest extends $tea.Model {
  configs: SetEdgeInstanceDriverConfigsRequestConfigs[];
  driverId: string;
  instanceId: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      configs: 'Configs',
      driverId: 'DriverId',
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configs: { 'type': 'array', 'itemType': SetEdgeInstanceDriverConfigsRequestConfigs },
      driverId: 'string',
      instanceId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetEdgeInstanceDriverConfigsResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetProductCertInfoRequest extends $tea.Model {
  iotInstanceId?: string;
  issueModel: number;
  productKey: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      issueModel: 'IssueModel',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      issueModel: 'number',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetProductCertInfoResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetStudioProjectCooperationRequest extends $tea.Model {
  iotInstanceId?: string;
  status: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetStudioProjectCooperationResponse extends $tea.Model {
  code: string;
  data: boolean;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'boolean',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetupStudioAppAuthModeOpenRequest extends $tea.Model {
  appId: string;
  authMode: number;
  iotInstanceId?: string;
  projectId: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      authMode: 'AuthMode',
      iotInstanceId: 'IotInstanceId',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      authMode: 'number',
      iotInstanceId: 'string',
      projectId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetupStudioAppAuthModeOpenResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: SetupStudioAppAuthModeOpenResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: SetupStudioAppAuthModeOpenResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ShareSpeechByCombinationRequest extends $tea.Model {
  audioFormat?: string;
  combinationList: string[];
  deviceName?: string;
  iotId?: string;
  iotInstanceId?: string;
  productKey?: string;
  speechId?: string;
  static names(): { [key: string]: string } {
    return {
      audioFormat: 'AudioFormat',
      combinationList: 'CombinationList',
      deviceName: 'DeviceName',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
      speechId: 'SpeechId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      audioFormat: 'string',
      combinationList: { 'type': 'array', 'itemType': 'string' },
      deviceName: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
      speechId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ShareSpeechByCombinationResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SpeechByCombinationRequest extends $tea.Model {
  audioFormat?: string;
  combinationList: string[];
  deviceName?: string;
  enforceFlag?: boolean;
  iotId?: string;
  iotInstanceId?: string;
  productKey?: string;
  speechId?: string;
  static names(): { [key: string]: string } {
    return {
      audioFormat: 'AudioFormat',
      combinationList: 'CombinationList',
      deviceName: 'DeviceName',
      enforceFlag: 'EnforceFlag',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
      speechId: 'SpeechId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      audioFormat: 'string',
      combinationList: { 'type': 'array', 'itemType': 'string' },
      deviceName: 'string',
      enforceFlag: 'boolean',
      iotId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
      speechId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SpeechByCombinationResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SpeechBySynthesisRequest extends $tea.Model {
  audioFormat: string;
  deviceName?: string;
  iotId?: string;
  iotInstanceId?: string;
  productKey?: string;
  speechId?: string;
  speechRate?: number;
  text: string;
  voice: string;
  volume?: number;
  static names(): { [key: string]: string } {
    return {
      audioFormat: 'AudioFormat',
      deviceName: 'DeviceName',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
      speechId: 'SpeechId',
      speechRate: 'SpeechRate',
      text: 'Text',
      voice: 'Voice',
      volume: 'Volume',
    };
  }

  static types(): { [key: string]: any } {
    return {
      audioFormat: 'string',
      deviceName: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
      speechId: 'string',
      speechRate: 'number',
      text: 'string',
      voice: 'string',
      volume: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SpeechBySynthesisResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartParserRequest extends $tea.Model {
  iotInstanceId?: string;
  parserId: number;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      parserId: 'ParserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      parserId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartParserResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartRuleRequest extends $tea.Model {
  iotInstanceId?: string;
  ruleId: number;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      ruleId: 'RuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      ruleId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartRuleResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopParserRequest extends $tea.Model {
  iotInstanceId?: string;
  parserId: number;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      parserId: 'ParserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      parserId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopParserResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopRuleRequest extends $tea.Model {
  iotInstanceId?: string;
  ruleId: number;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      ruleId: 'RuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      ruleId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopRuleResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubscribeTopicRequest extends $tea.Model {
  deviceName: string;
  iotInstanceId?: string;
  productKey: string;
  topic: string[];
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
      topic: 'Topic',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
      topic: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubscribeTopicResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SyncSpeechByCombinationRequest extends $tea.Model {
  audioFormat?: string;
  combinationList: string[];
  deviceName?: string;
  enforceFlag?: boolean;
  iotId?: string;
  iotInstanceId?: string;
  productKey?: string;
  speechId?: string;
  static names(): { [key: string]: string } {
    return {
      audioFormat: 'AudioFormat',
      combinationList: 'CombinationList',
      deviceName: 'DeviceName',
      enforceFlag: 'EnforceFlag',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
      speechId: 'SpeechId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      audioFormat: 'string',
      combinationList: { 'type': 'array', 'itemType': 'string' },
      deviceName: 'string',
      enforceFlag: 'boolean',
      iotId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
      speechId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SyncSpeechByCombinationResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: SyncSpeechByCombinationResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: SyncSpeechByCombinationResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TestSpeechRequest extends $tea.Model {
  audioFormat?: string;
  enableSoundCode?: boolean;
  iotInstanceId?: string;
  projectCode: string;
  soundCodeConfig?: { [key: string]: any };
  speechRate?: number;
  speechType?: string;
  text?: string;
  voice: string;
  volume?: number;
  static names(): { [key: string]: string } {
    return {
      audioFormat: 'AudioFormat',
      enableSoundCode: 'EnableSoundCode',
      iotInstanceId: 'IotInstanceId',
      projectCode: 'ProjectCode',
      soundCodeConfig: 'SoundCodeConfig',
      speechRate: 'SpeechRate',
      speechType: 'SpeechType',
      text: 'Text',
      voice: 'Voice',
      volume: 'Volume',
    };
  }

  static types(): { [key: string]: any } {
    return {
      audioFormat: 'string',
      enableSoundCode: 'boolean',
      iotInstanceId: 'string',
      projectCode: 'string',
      soundCodeConfig: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      speechRate: 'number',
      speechType: 'string',
      text: 'string',
      voice: 'string',
      volume: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TestSpeechShrinkRequest extends $tea.Model {
  audioFormat?: string;
  enableSoundCode?: boolean;
  iotInstanceId?: string;
  projectCode: string;
  soundCodeConfigShrink?: string;
  speechRate?: number;
  speechType?: string;
  text?: string;
  voice: string;
  volume?: number;
  static names(): { [key: string]: string } {
    return {
      audioFormat: 'AudioFormat',
      enableSoundCode: 'EnableSoundCode',
      iotInstanceId: 'IotInstanceId',
      projectCode: 'ProjectCode',
      soundCodeConfigShrink: 'SoundCodeConfig',
      speechRate: 'SpeechRate',
      speechType: 'SpeechType',
      text: 'Text',
      voice: 'Voice',
      volume: 'Volume',
    };
  }

  static types(): { [key: string]: any } {
    return {
      audioFormat: 'string',
      enableSoundCode: 'boolean',
      iotInstanceId: 'string',
      projectCode: 'string',
      soundCodeConfigShrink: 'string',
      speechRate: 'number',
      speechType: 'string',
      text: 'string',
      voice: 'string',
      volume: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TestSpeechResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  data: TestSpeechResponseData;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      data: TestSpeechResponseData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TransformClientIdRequest extends $tea.Model {
  clientId: string;
  iotId: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      clientId: 'ClientId',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clientId: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TransformClientIdResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TriggerSceneRuleRequest extends $tea.Model {
  instanceId?: string;
  iotInstanceId?: string;
  ruleId: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
      ruleId: 'RuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      iotInstanceId: 'string',
      ruleId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TriggerSceneRuleResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnbindApplicationFromEdgeInstanceRequest extends $tea.Model {
  applicationId: string;
  instanceId: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      applicationId: 'ApplicationId',
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applicationId: 'string',
      instanceId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnbindApplicationFromEdgeInstanceResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnbindDriverFromEdgeInstanceRequest extends $tea.Model {
  driverId: string;
  instanceId: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      driverId: 'DriverId',
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      driverId: 'string',
      instanceId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnbindDriverFromEdgeInstanceResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnbindLicenseProductRequest extends $tea.Model {
  iotInstanceId?: string;
  licenseCode: string;
  productKey: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      licenseCode: 'LicenseCode',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      licenseCode: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnbindLicenseProductResponse extends $tea.Model {
  code: string;
  data: boolean;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'boolean',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnbindRoleFromEdgeInstanceRequest extends $tea.Model {
  instanceId: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnbindRoleFromEdgeInstanceResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnbindSceneRuleFromEdgeInstanceRequest extends $tea.Model {
  instanceId: string;
  iotInstanceId?: string;
  ruleId: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
      ruleId: 'RuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      iotInstanceId: 'string',
      ruleId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnbindSceneRuleFromEdgeInstanceResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateConsumerGroupRequest extends $tea.Model {
  groupId: string;
  iotInstanceId?: string;
  newGroupName: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      iotInstanceId: 'IotInstanceId',
      newGroupName: 'NewGroupName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      iotInstanceId: 'string',
      newGroupName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateConsumerGroupResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDestinationRequest extends $tea.Model {
  configuration: string;
  description?: string;
  destinationId: number;
  iotInstanceId?: string;
  name: string;
  type: string;
  static names(): { [key: string]: string } {
    return {
      configuration: 'Configuration',
      description: 'Description',
      destinationId: 'DestinationId',
      iotInstanceId: 'IotInstanceId',
      name: 'Name',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configuration: 'string',
      description: 'string',
      destinationId: 'number',
      iotInstanceId: 'string',
      name: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDestinationResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDeviceGroupRequest extends $tea.Model {
  groupDesc?: string;
  groupId: string;
  groupType?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      groupDesc: 'GroupDesc',
      groupId: 'GroupId',
      groupType: 'GroupType',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupDesc: 'string',
      groupId: 'string',
      groupType: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDeviceGroupResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDeviceShadowRequest extends $tea.Model {
  deltaUpdate?: boolean;
  deviceName: string;
  iotInstanceId?: string;
  productKey: string;
  shadowMessage: string;
  static names(): { [key: string]: string } {
    return {
      deltaUpdate: 'DeltaUpdate',
      deviceName: 'DeviceName',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
      shadowMessage: 'ShadowMessage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deltaUpdate: 'boolean',
      deviceName: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
      shadowMessage: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDeviceShadowResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateEdgeDriverVersionRequest extends $tea.Model {
  argument?: string;
  configCheckRule?: string;
  containerConfig?: string;
  description?: string;
  driverConfig?: string;
  driverId: string;
  driverVersion: string;
  edgeVersion: string;
  iotInstanceId?: string;
  sourceConfig?: string;
  static names(): { [key: string]: string } {
    return {
      argument: 'Argument',
      configCheckRule: 'ConfigCheckRule',
      containerConfig: 'ContainerConfig',
      description: 'Description',
      driverConfig: 'DriverConfig',
      driverId: 'DriverId',
      driverVersion: 'DriverVersion',
      edgeVersion: 'EdgeVersion',
      iotInstanceId: 'IotInstanceId',
      sourceConfig: 'SourceConfig',
    };
  }

  static types(): { [key: string]: any } {
    return {
      argument: 'string',
      configCheckRule: 'string',
      containerConfig: 'string',
      description: 'string',
      driverConfig: 'string',
      driverId: 'string',
      driverVersion: 'string',
      edgeVersion: 'string',
      iotInstanceId: 'string',
      sourceConfig: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateEdgeDriverVersionResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateEdgeInstanceRequest extends $tea.Model {
  bizEnable?: boolean;
  instanceId: string;
  iotInstanceId?: string;
  name: string;
  spec?: number;
  tags?: string;
  static names(): { [key: string]: string } {
    return {
      bizEnable: 'BizEnable',
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
      name: 'Name',
      spec: 'Spec',
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizEnable: 'boolean',
      instanceId: 'string',
      iotInstanceId: 'string',
      name: 'string',
      spec: 'number',
      tags: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateEdgeInstanceResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateEdgeInstanceChannelRequest extends $tea.Model {
  channelId: string;
  channelName: string;
  configs: UpdateEdgeInstanceChannelRequestConfigs[];
  driverId: string;
  instanceId: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      channelId: 'ChannelId',
      channelName: 'ChannelName',
      configs: 'Configs',
      driverId: 'DriverId',
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelId: 'string',
      channelName: 'string',
      configs: { 'type': 'array', 'itemType': UpdateEdgeInstanceChannelRequestConfigs },
      driverId: 'string',
      instanceId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateEdgeInstanceChannelResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateEdgeInstanceMessageRoutingRequest extends $tea.Model {
  instanceId: string;
  iotInstanceId?: string;
  name?: string;
  routeId: number;
  sourceData?: string;
  sourceType: string;
  targetData?: string;
  targetIotHubQos?: number;
  targetType: string;
  topicFilter?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
      name: 'Name',
      routeId: 'RouteId',
      sourceData: 'SourceData',
      sourceType: 'SourceType',
      targetData: 'TargetData',
      targetIotHubQos: 'TargetIotHubQos',
      targetType: 'TargetType',
      topicFilter: 'TopicFilter',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      iotInstanceId: 'string',
      name: 'string',
      routeId: 'number',
      sourceData: 'string',
      sourceType: 'string',
      targetData: 'string',
      targetIotHubQos: 'number',
      targetType: 'string',
      topicFilter: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateEdgeInstanceMessageRoutingResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateJobRequest extends $tea.Model {
  description?: string;
  iotInstanceId?: string;
  jobId: string;
  rolloutConfig?: { [key: string]: any };
  timeoutConfig?: { [key: string]: any };
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      iotInstanceId: 'IotInstanceId',
      jobId: 'JobId',
      rolloutConfig: 'RolloutConfig',
      timeoutConfig: 'TimeoutConfig',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      iotInstanceId: 'string',
      jobId: 'string',
      rolloutConfig: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      timeoutConfig: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateJobShrinkRequest extends $tea.Model {
  description?: string;
  iotInstanceId?: string;
  jobId: string;
  rolloutConfigShrink?: string;
  timeoutConfigShrink?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      iotInstanceId: 'IotInstanceId',
      jobId: 'JobId',
      rolloutConfigShrink: 'RolloutConfig',
      timeoutConfigShrink: 'TimeoutConfig',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      iotInstanceId: 'string',
      jobId: 'string',
      rolloutConfigShrink: 'string',
      timeoutConfigShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateJobResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateOTAModuleRequest extends $tea.Model {
  aliasName?: string;
  desc?: string;
  iotInstanceId?: string;
  moduleName: string;
  productKey: string;
  static names(): { [key: string]: string } {
    return {
      aliasName: 'AliasName',
      desc: 'Desc',
      iotInstanceId: 'IotInstanceId',
      moduleName: 'ModuleName',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliasName: 'string',
      desc: 'string',
      iotInstanceId: 'string',
      moduleName: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateOTAModuleResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateParserRequest extends $tea.Model {
  description?: string;
  iotInstanceId?: string;
  name?: string;
  parserId: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      iotInstanceId: 'IotInstanceId',
      name: 'Name',
      parserId: 'ParserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      iotInstanceId: 'string',
      name: 'string',
      parserId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateParserResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateParserDataSourceRequest extends $tea.Model {
  dataSourceId: number;
  description?: string;
  iotInstanceId?: string;
  name: string;
  static names(): { [key: string]: string } {
    return {
      dataSourceId: 'DataSourceId',
      description: 'Description',
      iotInstanceId: 'IotInstanceId',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataSourceId: 'number',
      description: 'string',
      iotInstanceId: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateParserDataSourceResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProductRequest extends $tea.Model {
  description?: string;
  iotInstanceId?: string;
  productKey: string;
  productName: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
      productName: 'ProductName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
      productName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProductResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProductFilterConfigRequest extends $tea.Model {
  iotInstanceId?: string;
  productKey: string;
  propertyTimestampFilter: boolean;
  propertyValueFilter: boolean;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
      propertyTimestampFilter: 'PropertyTimestampFilter',
      propertyValueFilter: 'PropertyValueFilter',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      productKey: 'string',
      propertyTimestampFilter: 'boolean',
      propertyValueFilter: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProductFilterConfigResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProductTagsRequest extends $tea.Model {
  iotInstanceId?: string;
  productKey: string;
  productTag: UpdateProductTagsRequestProductTag[];
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
      productTag: 'ProductTag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      productKey: 'string',
      productTag: { 'type': 'array', 'itemType': UpdateProductTagsRequestProductTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProductTagsResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  invalidProductTags: UpdateProductTagsResponseInvalidProductTags;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      invalidProductTags: 'InvalidProductTags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      invalidProductTags: UpdateProductTagsResponseInvalidProductTags,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProductTopicRequest extends $tea.Model {
  desc?: string;
  iotInstanceId?: string;
  operation: string;
  topicId: string;
  topicShortName: string;
  static names(): { [key: string]: string } {
    return {
      desc: 'Desc',
      iotInstanceId: 'IotInstanceId',
      operation: 'Operation',
      topicId: 'TopicId',
      topicShortName: 'TopicShortName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      desc: 'string',
      iotInstanceId: 'string',
      operation: 'string',
      topicId: 'string',
      topicShortName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProductTopicResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRuleRequest extends $tea.Model {
  iotInstanceId?: string;
  name?: string;
  productKey?: string;
  ruleDesc?: string;
  ruleId: number;
  select?: string;
  shortTopic?: string;
  topic?: string;
  topicType?: number;
  where?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      name: 'Name',
      productKey: 'ProductKey',
      ruleDesc: 'RuleDesc',
      ruleId: 'RuleId',
      select: 'Select',
      shortTopic: 'ShortTopic',
      topic: 'Topic',
      topicType: 'TopicType',
      where: 'Where',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      name: 'string',
      productKey: 'string',
      ruleDesc: 'string',
      ruleId: 'number',
      select: 'string',
      shortTopic: 'string',
      topic: 'string',
      topicType: 'number',
      where: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRuleResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRuleActionRequest extends $tea.Model {
  actionId: number;
  configuration: string;
  iotInstanceId?: string;
  type: string;
  static names(): { [key: string]: string } {
    return {
      actionId: 'ActionId',
      configuration: 'Configuration',
      iotInstanceId: 'IotInstanceId',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actionId: 'number',
      configuration: 'string',
      iotInstanceId: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRuleActionResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSceneRuleRequest extends $tea.Model {
  iotInstanceId?: string;
  ruleContent?: string;
  ruleDescription?: string;
  ruleId: string;
  ruleName?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      ruleContent: 'RuleContent',
      ruleDescription: 'RuleDescription',
      ruleId: 'RuleId',
      ruleName: 'RuleName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      ruleContent: 'string',
      ruleDescription: 'string',
      ruleId: 'string',
      ruleName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSceneRuleResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSchedulePeriodRequest extends $tea.Model {
  description?: string;
  endTime?: string;
  iotInstanceId?: string;
  periodCode: string;
  soundCodeContent?: string;
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      endTime: 'EndTime',
      iotInstanceId: 'IotInstanceId',
      periodCode: 'PeriodCode',
      soundCodeContent: 'SoundCodeContent',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      endTime: 'string',
      iotInstanceId: 'string',
      periodCode: 'string',
      soundCodeContent: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSchedulePeriodResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSoundCodeRequest extends $tea.Model {
  duration?: number;
  iotInstanceId?: string;
  name?: string;
  soundCode: string;
  soundCodeContent?: string;
  static names(): { [key: string]: string } {
    return {
      duration: 'Duration',
      iotInstanceId: 'IotInstanceId',
      name: 'Name',
      soundCode: 'SoundCode',
      soundCodeContent: 'SoundCodeContent',
    };
  }

  static types(): { [key: string]: any } {
    return {
      duration: 'number',
      iotInstanceId: 'string',
      name: 'string',
      soundCode: 'string',
      soundCodeContent: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSoundCodeResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSoundCodeLabelRequest extends $tea.Model {
  iotInstanceId?: string;
  label: string;
  soundCode: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      label: 'Label',
      soundCode: 'SoundCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      label: 'string',
      soundCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSoundCodeLabelResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSoundCodeScheduleRequest extends $tea.Model {
  description?: string;
  endDate?: string;
  endTime?: string;
  iotInstanceId?: string;
  name?: string;
  scheduleCode: string;
  startDate?: string;
  startTime?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      endDate: 'EndDate',
      endTime: 'EndTime',
      iotInstanceId: 'IotInstanceId',
      name: 'Name',
      scheduleCode: 'ScheduleCode',
      startDate: 'StartDate',
      startTime: 'StartTime',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      endDate: 'string',
      endTime: 'string',
      iotInstanceId: 'string',
      name: 'string',
      scheduleCode: 'string',
      startDate: 'string',
      startTime: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSoundCodeScheduleResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSpeechRequest extends $tea.Model {
  enableSoundCode?: boolean;
  iotInstanceId?: string;
  projectCode: string;
  soundCodeConfig?: { [key: string]: any };
  speechCode: string;
  speechRate?: number;
  voice: string;
  volume?: number;
  static names(): { [key: string]: string } {
    return {
      enableSoundCode: 'EnableSoundCode',
      iotInstanceId: 'IotInstanceId',
      projectCode: 'ProjectCode',
      soundCodeConfig: 'SoundCodeConfig',
      speechCode: 'SpeechCode',
      speechRate: 'SpeechRate',
      voice: 'Voice',
      volume: 'Volume',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enableSoundCode: 'boolean',
      iotInstanceId: 'string',
      projectCode: 'string',
      soundCodeConfig: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      speechCode: 'string',
      speechRate: 'number',
      voice: 'string',
      volume: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSpeechShrinkRequest extends $tea.Model {
  enableSoundCode?: boolean;
  iotInstanceId?: string;
  projectCode: string;
  soundCodeConfigShrink?: string;
  speechCode: string;
  speechRate?: number;
  voice: string;
  volume?: number;
  static names(): { [key: string]: string } {
    return {
      enableSoundCode: 'EnableSoundCode',
      iotInstanceId: 'IotInstanceId',
      projectCode: 'ProjectCode',
      soundCodeConfigShrink: 'SoundCodeConfig',
      speechCode: 'SpeechCode',
      speechRate: 'SpeechRate',
      voice: 'Voice',
      volume: 'Volume',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enableSoundCode: 'boolean',
      iotInstanceId: 'string',
      projectCode: 'string',
      soundCodeConfigShrink: 'string',
      speechCode: 'string',
      speechRate: 'number',
      voice: 'string',
      volume: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSpeechResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSubscribeRelationRequest extends $tea.Model {
  consumerGroupIds?: string[];
  deviceDataFlag?: boolean;
  deviceLifeCycleFlag?: boolean;
  deviceStatusChangeFlag?: boolean;
  deviceTagFlag?: boolean;
  deviceTopoLifeCycleFlag?: boolean;
  foundDeviceListFlag?: boolean;
  iotInstanceId?: string;
  mnsConfiguration?: string;
  otaEventFlag?: boolean;
  otaJobFlag?: boolean;
  otaVersionFlag?: boolean;
  productKey: string;
  subscribeFlags?: string;
  thingHistoryFlag?: boolean;
  type: string;
  static names(): { [key: string]: string } {
    return {
      consumerGroupIds: 'ConsumerGroupIds',
      deviceDataFlag: 'DeviceDataFlag',
      deviceLifeCycleFlag: 'DeviceLifeCycleFlag',
      deviceStatusChangeFlag: 'DeviceStatusChangeFlag',
      deviceTagFlag: 'DeviceTagFlag',
      deviceTopoLifeCycleFlag: 'DeviceTopoLifeCycleFlag',
      foundDeviceListFlag: 'FoundDeviceListFlag',
      iotInstanceId: 'IotInstanceId',
      mnsConfiguration: 'MnsConfiguration',
      otaEventFlag: 'OtaEventFlag',
      otaJobFlag: 'OtaJobFlag',
      otaVersionFlag: 'OtaVersionFlag',
      productKey: 'ProductKey',
      subscribeFlags: 'SubscribeFlags',
      thingHistoryFlag: 'ThingHistoryFlag',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consumerGroupIds: { 'type': 'array', 'itemType': 'string' },
      deviceDataFlag: 'boolean',
      deviceLifeCycleFlag: 'boolean',
      deviceStatusChangeFlag: 'boolean',
      deviceTagFlag: 'boolean',
      deviceTopoLifeCycleFlag: 'boolean',
      foundDeviceListFlag: 'boolean',
      iotInstanceId: 'string',
      mnsConfiguration: 'string',
      otaEventFlag: 'boolean',
      otaJobFlag: 'boolean',
      otaVersionFlag: 'boolean',
      productKey: 'string',
      subscribeFlags: 'string',
      thingHistoryFlag: 'boolean',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSubscribeRelationResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateThingModelRequest extends $tea.Model {
  iotInstanceId?: string;
  productKey: string;
  identifier?: string;
  thingModelJson?: string;
  functionBlockId?: string;
  functionBlockName?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
      identifier: 'Identifier',
      thingModelJson: 'ThingModelJson',
      functionBlockId: 'FunctionBlockId',
      functionBlockName: 'FunctionBlockName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      productKey: 'string',
      identifier: 'string',
      thingModelJson: 'string',
      functionBlockId: 'string',
      functionBlockName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateThingModelResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateThingScriptRequest extends $tea.Model {
  iotInstanceId?: string;
  productKey: string;
  scriptContent: string;
  scriptType: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
      scriptContent: 'ScriptContent',
      scriptType: 'ScriptType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      productKey: 'string',
      scriptContent: 'string',
      scriptType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateThingScriptResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WriteDevicesHotStorageDataRequest extends $tea.Model {
  deviceName?: string;
  iotId?: string;
  iotInstanceId: string;
  items: string;
  productKey?: string;
  userTopic: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      items: 'Items',
      productKey: 'ProductKey',
      userTopic: 'UserTopic',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      items: 'string',
      productKey: 'string',
      userTopic: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WriteDevicesHotStorageDataResponse extends $tea.Model {
  code: string;
  errorMessage: string;
  requestId: string;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddShareTaskDeviceResponseData extends $tea.Model {
  progress: number;
  progressId: string;
  static names(): { [key: string]: string } {
    return {
      progress: 'Progress',
      progressId: 'ProgressId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      progress: 'number',
      progressId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchAddDeviceGroupRelationsRequestDevice extends $tea.Model {
  deviceName: string;
  productKey: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchAddThingTopoRequestTopoAddItem extends $tea.Model {
  clientId?: string;
  deviceName: string;
  productKey: string;
  sign: string;
  signMethod: string;
  timestamp?: string;
  static names(): { [key: string]: string } {
    return {
      clientId: 'ClientId',
      deviceName: 'DeviceName',
      productKey: 'ProductKey',
      sign: 'Sign',
      signMethod: 'SignMethod',
      timestamp: 'Timestamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clientId: 'string',
      deviceName: 'string',
      productKey: 'string',
      sign: 'string',
      signMethod: 'string',
      timestamp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchBindDevicesIntoProjectRequestDevices extends $tea.Model {
  deviceName: string;
  productKey: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCheckDeviceNamesRequestDeviceNameList extends $tea.Model {
  deviceName?: string;
  deviceNickname?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      deviceNickname: 'DeviceNickname',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      deviceNickname: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCheckDeviceNamesResponseDataInvalidDeviceNameList extends $tea.Model {
  invalidDeviceName: string[];
  static names(): { [key: string]: string } {
    return {
      invalidDeviceName: 'InvalidDeviceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      invalidDeviceName: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCheckDeviceNamesResponseDataInvalidDeviceNicknameList extends $tea.Model {
  invalidDeviceNickname: string[];
  static names(): { [key: string]: string } {
    return {
      invalidDeviceNickname: 'InvalidDeviceNickname',
    };
  }

  static types(): { [key: string]: any } {
    return {
      invalidDeviceNickname: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCheckDeviceNamesResponseData extends $tea.Model {
  applyId: number;
  invalidDeviceNameList: BatchCheckDeviceNamesResponseDataInvalidDeviceNameList;
  invalidDeviceNicknameList: BatchCheckDeviceNamesResponseDataInvalidDeviceNicknameList;
  static names(): { [key: string]: string } {
    return {
      applyId: 'ApplyId',
      invalidDeviceNameList: 'InvalidDeviceNameList',
      invalidDeviceNicknameList: 'InvalidDeviceNicknameList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applyId: 'number',
      invalidDeviceNameList: BatchCheckDeviceNamesResponseDataInvalidDeviceNameList,
      invalidDeviceNicknameList: BatchCheckDeviceNamesResponseDataInvalidDeviceNicknameList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCheckImportDeviceRequestDeviceList extends $tea.Model {
  deviceName: string;
  deviceSecret: string;
  sn?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      deviceSecret: 'DeviceSecret',
      sn: 'Sn',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      deviceSecret: 'string',
      sn: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCheckImportDeviceResponseData extends $tea.Model {
  invalidDeviceNameList: string[];
  invalidDeviceSecretList: string[];
  invalidSnList: string[];
  repeatedDeviceNameList: string[];
  static names(): { [key: string]: string } {
    return {
      invalidDeviceNameList: 'InvalidDeviceNameList',
      invalidDeviceSecretList: 'InvalidDeviceSecretList',
      invalidSnList: 'InvalidSnList',
      repeatedDeviceNameList: 'RepeatedDeviceNameList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      invalidDeviceNameList: { 'type': 'array', 'itemType': 'string' },
      invalidDeviceSecretList: { 'type': 'array', 'itemType': 'string' },
      invalidSnList: { 'type': 'array', 'itemType': 'string' },
      repeatedDeviceNameList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCheckVehicleDeviceRequestDeviceList extends $tea.Model {
  deviceId?: string;
  deviceModel: string;
  manufacturer: string;
  static names(): { [key: string]: string } {
    return {
      deviceId: 'DeviceId',
      deviceModel: 'DeviceModel',
      manufacturer: 'Manufacturer',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceId: 'string',
      deviceModel: 'string',
      manufacturer: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCheckVehicleDeviceResponseData extends $tea.Model {
  invalidDeviceIdList: string[];
  invalidDeviceModelList: string[];
  invalidManufacturerList: string[];
  repeatedDeviceIdList: string[];
  static names(): { [key: string]: string } {
    return {
      invalidDeviceIdList: 'InvalidDeviceIdList',
      invalidDeviceModelList: 'InvalidDeviceModelList',
      invalidManufacturerList: 'InvalidManufacturerList',
      repeatedDeviceIdList: 'RepeatedDeviceIdList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      invalidDeviceIdList: { 'type': 'array', 'itemType': 'string' },
      invalidDeviceModelList: { 'type': 'array', 'itemType': 'string' },
      invalidManufacturerList: { 'type': 'array', 'itemType': 'string' },
      repeatedDeviceIdList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchDeleteDeviceGroupRelationsRequestDevice extends $tea.Model {
  deviceName: string;
  productKey: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetDeviceBindStatusResponseData extends $tea.Model {
  bindStatus: number;
  instanceId: string;
  iotId: string;
  static names(): { [key: string]: string } {
    return {
      bindStatus: 'BindStatus',
      instanceId: 'InstanceId',
      iotId: 'IotId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bindStatus: 'number',
      instanceId: 'string',
      iotId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetDeviceStateResponseDeviceStatusListDeviceStatus extends $tea.Model {
  asAddress: string;
  deviceId: string;
  deviceName: string;
  iotId: string;
  lastOnlineTime: string;
  status: string;
  static names(): { [key: string]: string } {
    return {
      asAddress: 'AsAddress',
      deviceId: 'DeviceId',
      deviceName: 'DeviceName',
      iotId: 'IotId',
      lastOnlineTime: 'LastOnlineTime',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      asAddress: 'string',
      deviceId: 'string',
      deviceName: 'string',
      iotId: 'string',
      lastOnlineTime: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetDeviceStateResponseDeviceStatusList extends $tea.Model {
  deviceStatus: BatchGetDeviceStateResponseDeviceStatusListDeviceStatus[];
  static names(): { [key: string]: string } {
    return {
      deviceStatus: 'DeviceStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceStatus: { 'type': 'array', 'itemType': BatchGetDeviceStateResponseDeviceStatusListDeviceStatus },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeDriverResponseDriverList extends $tea.Model {
  cpuArch: string;
  driverId: string;
  driverName: string;
  driverProtocol: string;
  gmtCreateTimestamp: number;
  gmtModifiedTimestamp: number;
  isBuiltIn: boolean;
  runtime: string;
  type: number;
  static names(): { [key: string]: string } {
    return {
      cpuArch: 'CpuArch',
      driverId: 'DriverId',
      driverName: 'DriverName',
      driverProtocol: 'DriverProtocol',
      gmtCreateTimestamp: 'GmtCreateTimestamp',
      gmtModifiedTimestamp: 'GmtModifiedTimestamp',
      isBuiltIn: 'IsBuiltIn',
      runtime: 'Runtime',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cpuArch: 'string',
      driverId: 'string',
      driverName: 'string',
      driverProtocol: 'string',
      gmtCreateTimestamp: 'number',
      gmtModifiedTimestamp: 'number',
      isBuiltIn: 'boolean',
      runtime: 'string',
      type: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeInstanceChannelResponseDataChannelConfigListConfig extends $tea.Model {
  configId: string;
  content: string;
  format: string;
  key: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      content: 'Content',
      format: 'Format',
      key: 'Key',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'string',
      content: 'string',
      format: 'string',
      key: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeInstanceChannelResponseDataChannelConfigList extends $tea.Model {
  config: BatchGetEdgeInstanceChannelResponseDataChannelConfigListConfig[];
  static names(): { [key: string]: string } {
    return {
      config: 'Config',
    };
  }

  static types(): { [key: string]: any } {
    return {
      config: { 'type': 'array', 'itemType': BatchGetEdgeInstanceChannelResponseDataChannelConfigListConfig },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeInstanceChannelResponseDataChannel extends $tea.Model {
  channelId: string;
  channelName: string;
  configList: BatchGetEdgeInstanceChannelResponseDataChannelConfigList;
  static names(): { [key: string]: string } {
    return {
      channelId: 'ChannelId',
      channelName: 'ChannelName',
      configList: 'ConfigList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelId: 'string',
      channelName: 'string',
      configList: BatchGetEdgeInstanceChannelResponseDataChannelConfigList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeInstanceChannelResponseData extends $tea.Model {
  channel: BatchGetEdgeInstanceChannelResponseDataChannel[];
  static names(): { [key: string]: string } {
    return {
      channel: 'Channel',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channel: { 'type': 'array', 'itemType': BatchGetEdgeInstanceChannelResponseDataChannel },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeInstanceDeviceChannelResponseDeviceChannelList extends $tea.Model {
  channelId: string;
  channelName: string;
  iotId: string;
  static names(): { [key: string]: string } {
    return {
      channelId: 'ChannelId',
      channelName: 'ChannelName',
      iotId: 'IotId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelId: 'string',
      channelName: 'string',
      iotId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeInstanceDeviceConfigResponseDeviceConfigListConfig extends $tea.Model {
  content: string;
  format: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      format: 'Format',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      format: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeInstanceDeviceConfigResponseDeviceConfigList extends $tea.Model {
  iotId: string;
  config: BatchGetEdgeInstanceDeviceConfigResponseDeviceConfigListConfig;
  static names(): { [key: string]: string } {
    return {
      iotId: 'IotId',
      config: 'Config',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotId: 'string',
      config: BatchGetEdgeInstanceDeviceConfigResponseDeviceConfigListConfig,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeInstanceDeviceDriverResponseDeviceDriverList extends $tea.Model {
  driverId: string;
  iotId: string;
  static names(): { [key: string]: string } {
    return {
      driverId: 'DriverId',
      iotId: 'IotId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      driverId: 'string',
      iotId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeInstanceDriverConfigsResponseDriverConfigListConfigList extends $tea.Model {
  configId: string;
  content: string;
  format: string;
  key: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      content: 'Content',
      format: 'Format',
      key: 'Key',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'string',
      content: 'string',
      format: 'string',
      key: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeInstanceDriverConfigsResponseDriverConfigList extends $tea.Model {
  driverId: string;
  configList: BatchGetEdgeInstanceDriverConfigsResponseDriverConfigListConfigList[];
  static names(): { [key: string]: string } {
    return {
      driverId: 'DriverId',
      configList: 'ConfigList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      driverId: 'string',
      configList: { 'type': 'array', 'itemType': BatchGetEdgeInstanceDriverConfigsResponseDriverConfigListConfigList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchImportDeviceRequestDeviceList extends $tea.Model {
  deviceName: string;
  deviceSecret: string;
  sn?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      deviceSecret: 'DeviceSecret',
      sn: 'Sn',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      deviceSecret: 'string',
      sn: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchImportDeviceResponseDataInvalidDeviceNameList extends $tea.Model {
  invalidDeviceName: string[];
  static names(): { [key: string]: string } {
    return {
      invalidDeviceName: 'invalidDeviceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      invalidDeviceName: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchImportDeviceResponseDataInvalidDeviceSecretList extends $tea.Model {
  invalidDeviceSecret: string[];
  static names(): { [key: string]: string } {
    return {
      invalidDeviceSecret: 'invalidDeviceSecret',
    };
  }

  static types(): { [key: string]: any } {
    return {
      invalidDeviceSecret: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchImportDeviceResponseDataInvalidSnList extends $tea.Model {
  invalidSn: string[];
  static names(): { [key: string]: string } {
    return {
      invalidSn: 'invalidSn',
    };
  }

  static types(): { [key: string]: any } {
    return {
      invalidSn: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchImportDeviceResponseDataRepeatedDeviceNameList extends $tea.Model {
  repeatedDeviceName: string[];
  static names(): { [key: string]: string } {
    return {
      repeatedDeviceName: 'repeatedDeviceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      repeatedDeviceName: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchImportDeviceResponseData extends $tea.Model {
  applyId: number;
  invalidDeviceNameList: BatchImportDeviceResponseDataInvalidDeviceNameList;
  invalidDeviceSecretList: BatchImportDeviceResponseDataInvalidDeviceSecretList;
  invalidSnList: BatchImportDeviceResponseDataInvalidSnList;
  repeatedDeviceNameList: BatchImportDeviceResponseDataRepeatedDeviceNameList;
  static names(): { [key: string]: string } {
    return {
      applyId: 'ApplyId',
      invalidDeviceNameList: 'InvalidDeviceNameList',
      invalidDeviceSecretList: 'InvalidDeviceSecretList',
      invalidSnList: 'InvalidSnList',
      repeatedDeviceNameList: 'RepeatedDeviceNameList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applyId: 'number',
      invalidDeviceNameList: BatchImportDeviceResponseDataInvalidDeviceNameList,
      invalidDeviceSecretList: BatchImportDeviceResponseDataInvalidDeviceSecretList,
      invalidSnList: BatchImportDeviceResponseDataInvalidSnList,
      repeatedDeviceNameList: BatchImportDeviceResponseDataRepeatedDeviceNameList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchImportVehicleDeviceRequestDeviceList extends $tea.Model {
  deviceId?: string;
  deviceModel: string;
  manufacturer: string;
  static names(): { [key: string]: string } {
    return {
      deviceId: 'DeviceId',
      deviceModel: 'DeviceModel',
      manufacturer: 'Manufacturer',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceId: 'string',
      deviceModel: 'string',
      manufacturer: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchImportVehicleDeviceResponseData extends $tea.Model {
  applyId: number;
  static names(): { [key: string]: string } {
    return {
      applyId: 'ApplyId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applyId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchQueryDeviceDetailResponseDataData extends $tea.Model {
  deviceName: string;
  deviceSecret: string;
  firmwareVersion: string;
  gmtActive: string;
  gmtCreate: string;
  iotId: string;
  nickname: string;
  nodeType: number;
  productKey: string;
  productName: string;
  region: string;
  status: string;
  utcActive: string;
  utcCreate: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      deviceSecret: 'DeviceSecret',
      firmwareVersion: 'FirmwareVersion',
      gmtActive: 'GmtActive',
      gmtCreate: 'GmtCreate',
      iotId: 'IotId',
      nickname: 'Nickname',
      nodeType: 'NodeType',
      productKey: 'ProductKey',
      productName: 'ProductName',
      region: 'Region',
      status: 'Status',
      utcActive: 'UtcActive',
      utcCreate: 'UtcCreate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      deviceSecret: 'string',
      firmwareVersion: 'string',
      gmtActive: 'string',
      gmtCreate: 'string',
      iotId: 'string',
      nickname: 'string',
      nodeType: 'number',
      productKey: 'string',
      productName: 'string',
      region: 'string',
      status: 'string',
      utcActive: 'string',
      utcCreate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchQueryDeviceDetailResponseData extends $tea.Model {
  data: BatchQueryDeviceDetailResponseDataData[];
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': BatchQueryDeviceDetailResponseDataData },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchRegisterDeviceResponseData extends $tea.Model {
  applyId: number;
  static names(): { [key: string]: string } {
    return {
      applyId: 'ApplyId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applyId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchRegisterDeviceWithApplyIdResponseData extends $tea.Model {
  applyId: number;
  static names(): { [key: string]: string } {
    return {
      applyId: 'ApplyId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applyId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchSetEdgeInstanceDeviceConfigRequestDeviceConfigs extends $tea.Model {
  content: string;
  iotId: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      iotId: 'IotId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      iotId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchUnbindProjectDevicesRequestDevices extends $tea.Model {
  deviceName: string;
  productKey: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchUpdateDeviceNicknameRequestDeviceNicknameInfo extends $tea.Model {
  deviceName?: string;
  iotId?: string;
  nickname?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      nickname: 'Nickname',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      nickname: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BindLicenseDeviceResponseData extends $tea.Model {
  checkProgressId: string;
  failSum: number;
  progress: number;
  resultCsvFile: string;
  successSum: number;
  static names(): { [key: string]: string } {
    return {
      checkProgressId: 'CheckProgressId',
      failSum: 'FailSum',
      progress: 'Progress',
      resultCsvFile: 'ResultCsvFile',
      successSum: 'SuccessSum',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkProgressId: 'string',
      failSum: 'number',
      progress: 'number',
      resultCsvFile: 'string',
      successSum: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CheckBindLicenseDeviceProgressResponseData extends $tea.Model {
  failSum: number;
  progress: number;
  resultCsvFile: string;
  successSum: number;
  static names(): { [key: string]: string } {
    return {
      failSum: 'FailSum',
      progress: 'Progress',
      resultCsvFile: 'ResultCsvFile',
      successSum: 'SuccessSum',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failSum: 'number',
      progress: 'number',
      resultCsvFile: 'string',
      successSum: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ClearDeviceDesiredPropertyResponseData extends $tea.Model {
  versions: string;
  static names(): { [key: string]: string } {
    return {
      versions: 'Versions',
    };
  }

  static types(): { [key: string]: any } {
    return {
      versions: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataAPIServiceRequestRequestParam extends $tea.Model {
  name?: string;
  type?: string;
  desc?: string;
  example?: string;
  required?: boolean;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      type: 'Type',
      desc: 'Desc',
      example: 'Example',
      required: 'Required',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      type: 'string',
      desc: 'string',
      example: 'string',
      required: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataAPIServiceRequestResponseParam extends $tea.Model {
  name?: string;
  type?: string;
  desc?: string;
  example?: string;
  required?: boolean;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      type: 'Type',
      desc: 'Desc',
      example: 'Example',
      required: 'Required',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      type: 'string',
      desc: 'string',
      example: 'string',
      required: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataAPIServiceResponseData extends $tea.Model {
  apiSrn: string;
  createTime: number;
  lastUpdateTime: number;
  static names(): { [key: string]: string } {
    return {
      apiSrn: 'ApiSrn',
      createTime: 'CreateTime',
      lastUpdateTime: 'LastUpdateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiSrn: 'string',
      createTime: 'number',
      lastUpdateTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDestinationResponseDestination extends $tea.Model {
  configuration: string;
  destinationId: number;
  isFailover: boolean;
  name: string;
  type: string;
  utcCreated: string;
  static names(): { [key: string]: string } {
    return {
      configuration: 'Configuration',
      destinationId: 'DestinationId',
      isFailover: 'IsFailover',
      name: 'Name',
      type: 'Type',
      utcCreated: 'UtcCreated',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configuration: 'string',
      destinationId: 'number',
      isFailover: 'boolean',
      name: 'string',
      type: 'string',
      utcCreated: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDeviceDistributeJobRequestTargetInstanceConfig extends $tea.Model {
  targetInstanceId: string;
  static names(): { [key: string]: string } {
    return {
      targetInstanceId: 'TargetInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      targetInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDeviceDynamicGroupResponseData extends $tea.Model {
  dynamicGroupExpression: string;
  groupDesc: string;
  groupId: string;
  groupName: string;
  utcCreate: string;
  static names(): { [key: string]: string } {
    return {
      dynamicGroupExpression: 'DynamicGroupExpression',
      groupDesc: 'GroupDesc',
      groupId: 'GroupId',
      groupName: 'GroupName',
      utcCreate: 'UtcCreate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dynamicGroupExpression: 'string',
      groupDesc: 'string',
      groupId: 'string',
      groupName: 'string',
      utcCreate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDeviceGroupResponseData extends $tea.Model {
  groupDesc: string;
  groupId: string;
  groupName: string;
  utcCreate: string;
  static names(): { [key: string]: string } {
    return {
      groupDesc: 'GroupDesc',
      groupId: 'GroupId',
      groupName: 'GroupName',
      utcCreate: 'UtcCreate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupDesc: 'string',
      groupId: 'string',
      groupName: 'string',
      utcCreate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDeviceTunnelResponseData extends $tea.Model {
  sourceAccessToken: string;
  sourceURI: string;
  tunnelId: string;
  static names(): { [key: string]: string } {
    return {
      sourceAccessToken: 'SourceAccessToken',
      sourceURI: 'SourceURI',
      tunnelId: 'TunnelId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      sourceAccessToken: 'string',
      sourceURI: 'string',
      tunnelId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDownloadDataJobResponseDataHeader extends $tea.Model {
  alias: string;
  dataPrecision: string;
  dimDateClass: string;
  fieldName: string;
  fieldType: string;
  geoClass: string;
  timeClass: string;
  typeClass: string;
  static names(): { [key: string]: string } {
    return {
      alias: 'Alias',
      dataPrecision: 'DataPrecision',
      dimDateClass: 'DimDateClass',
      fieldName: 'FieldName',
      fieldType: 'FieldType',
      geoClass: 'GeoClass',
      timeClass: 'TimeClass',
      typeClass: 'TypeClass',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alias: 'string',
      dataPrecision: 'string',
      dimDateClass: 'string',
      fieldName: 'string',
      fieldType: 'string',
      geoClass: 'string',
      timeClass: 'string',
      typeClass: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDownloadDataJobResponseDataQuerySettingAstExpr extends $tea.Model {
  expr: string;
  exprType: string;
  static names(): { [key: string]: string } {
    return {
      expr: 'Expr',
      exprType: 'ExprType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      expr: 'string',
      exprType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDownloadDataJobResponseDataQuerySettingSelectedHeaders extends $tea.Model {
  alias: string;
  dimDateClass: string;
  fieldName: string;
  fieldType: string;
  geoClass: string;
  timeClass: string;
  static names(): { [key: string]: string } {
    return {
      alias: 'Alias',
      dimDateClass: 'DimDateClass',
      fieldName: 'FieldName',
      fieldType: 'FieldType',
      geoClass: 'GeoClass',
      timeClass: 'TimeClass',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alias: 'string',
      dimDateClass: 'string',
      fieldName: 'string',
      fieldType: 'string',
      geoClass: 'string',
      timeClass: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDownloadDataJobResponseDataQuerySetting extends $tea.Model {
  astExpr: CreateDownloadDataJobResponseDataQuerySettingAstExpr[];
  selectedHeaders: CreateDownloadDataJobResponseDataQuerySettingSelectedHeaders[];
  static names(): { [key: string]: string } {
    return {
      astExpr: 'AstExpr',
      selectedHeaders: 'SelectedHeaders',
    };
  }

  static types(): { [key: string]: any } {
    return {
      astExpr: { 'type': 'array', 'itemType': CreateDownloadDataJobResponseDataQuerySettingAstExpr },
      selectedHeaders: { 'type': 'array', 'itemType': CreateDownloadDataJobResponseDataQuerySettingSelectedHeaders },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDownloadDataJobResponseData extends $tea.Model {
  asyncExecute: boolean;
  beginTime: number;
  csvFileName: string;
  csvUrl: string;
  datasetId: string;
  endTime: number;
  longJobId: string;
  pageNo: number;
  pageSize: number;
  previewSize: number;
  resultDataInString: string;
  status: number;
  totalCount: number;
  header: CreateDownloadDataJobResponseDataHeader[];
  querySetting: CreateDownloadDataJobResponseDataQuerySetting;
  static names(): { [key: string]: string } {
    return {
      asyncExecute: 'AsyncExecute',
      beginTime: 'BeginTime',
      csvFileName: 'CsvFileName',
      csvUrl: 'CsvUrl',
      datasetId: 'DatasetId',
      endTime: 'EndTime',
      longJobId: 'LongJobId',
      pageNo: 'PageNo',
      pageSize: 'PageSize',
      previewSize: 'PreviewSize',
      resultDataInString: 'ResultDataInString',
      status: 'Status',
      totalCount: 'TotalCount',
      header: 'Header',
      querySetting: 'QuerySetting',
    };
  }

  static types(): { [key: string]: any } {
    return {
      asyncExecute: 'boolean',
      beginTime: 'number',
      csvFileName: 'string',
      csvUrl: 'string',
      datasetId: 'string',
      endTime: 'number',
      longJobId: 'string',
      pageNo: 'number',
      pageSize: 'number',
      previewSize: 'number',
      resultDataInString: 'string',
      status: 'number',
      totalCount: 'number',
      header: { 'type': 'array', 'itemType': CreateDownloadDataJobResponseDataHeader },
      querySetting: CreateDownloadDataJobResponseDataQuerySetting,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeInstanceChannelRequestConfigs extends $tea.Model {
  content: string;
  format: string;
  key?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      format: 'Format',
      key: 'Key',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      format: 'string',
      key: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeOssPreSignedAddressResponseData extends $tea.Model {
  ossAddress: string;
  ossPreSignedAddress: string;
  static names(): { [key: string]: string } {
    return {
      ossAddress: 'OssAddress',
      ossPreSignedAddress: 'OssPreSignedAddress',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ossAddress: 'string',
      ossPreSignedAddress: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLoRaNodesTaskRequestDeviceInfo extends $tea.Model {
  devEui?: string;
  pinCode?: string;
  static names(): { [key: string]: string } {
    return {
      devEui: 'DevEui',
      pinCode: 'PinCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      devEui: 'string',
      pinCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOTADynamicUpgradeJobRequestTag extends $tea.Model {
  key: string;
  value: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOTADynamicUpgradeJobResponseData extends $tea.Model {
  jobId: string;
  utcCreate: string;
  static names(): { [key: string]: string } {
    return {
      jobId: 'JobId',
      utcCreate: 'UtcCreate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      jobId: 'string',
      utcCreate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOTAFirmwareRequestMultiFiles extends $tea.Model {
  fileMd5?: string;
  name?: string;
  signValue?: string;
  size?: number;
  url?: string;
  static names(): { [key: string]: string } {
    return {
      fileMd5: 'FileMd5',
      name: 'Name',
      signValue: 'SignValue',
      size: 'Size',
      url: 'Url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fileMd5: 'string',
      name: 'string',
      signValue: 'string',
      size: 'number',
      url: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOTAFirmwareResponseData extends $tea.Model {
  firmwareId: string;
  utcCreate: string;
  static names(): { [key: string]: string } {
    return {
      firmwareId: 'FirmwareId',
      utcCreate: 'UtcCreate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      firmwareId: 'string',
      utcCreate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOTAStaticUpgradeJobRequestTag extends $tea.Model {
  key: string;
  value: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOTAStaticUpgradeJobResponseData extends $tea.Model {
  jobId: string;
  utcCreate: string;
  static names(): { [key: string]: string } {
    return {
      jobId: 'JobId',
      utcCreate: 'UtcCreate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      jobId: 'string',
      utcCreate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOTAVerifyJobRequestTag extends $tea.Model {
  key: string;
  value: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOTAVerifyJobResponseData extends $tea.Model {
  jobId: string;
  utcCreate: string;
  static names(): { [key: string]: string } {
    return {
      jobId: 'JobId',
      utcCreate: 'UtcCreate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      jobId: 'string',
      utcCreate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateParserDataSourceResponseDataSource extends $tea.Model {
  dataSourceId: number;
  description: string;
  name: string;
  utcCreated: string;
  static names(): { [key: string]: string } {
    return {
      dataSourceId: 'DataSourceId',
      description: 'Description',
      name: 'Name',
      utcCreated: 'UtcCreated',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataSourceId: 'number',
      description: 'string',
      name: 'string',
      utcCreated: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProductResponseData extends $tea.Model {
  aliyunCommodityCode: string;
  authType: string;
  dataFormat: number;
  description: string;
  id2: boolean;
  nodeType: number;
  productKey: string;
  productName: string;
  productSecret: string;
  protocolType: string;
  static names(): { [key: string]: string } {
    return {
      aliyunCommodityCode: 'AliyunCommodityCode',
      authType: 'AuthType',
      dataFormat: 'DataFormat',
      description: 'Description',
      id2: 'Id2',
      nodeType: 'NodeType',
      productKey: 'ProductKey',
      productName: 'ProductName',
      productSecret: 'ProductSecret',
      protocolType: 'ProtocolType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunCommodityCode: 'string',
      authType: 'string',
      dataFormat: 'number',
      description: 'string',
      id2: 'boolean',
      nodeType: 'number',
      productKey: 'string',
      productName: 'string',
      productSecret: 'string',
      protocolType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProductTagsRequestProductTag extends $tea.Model {
  tagKey?: string;
  tagValue?: string;
  static names(): { [key: string]: string } {
    return {
      tagKey: 'TagKey',
      tagValue: 'TagValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagKey: 'string',
      tagValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProductTagsResponseInvalidProductTagsProductTag extends $tea.Model {
  tagKey: string;
  tagValue: string;
  static names(): { [key: string]: string } {
    return {
      tagKey: 'TagKey',
      tagValue: 'TagValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagKey: 'string',
      tagValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProductTagsResponseInvalidProductTags extends $tea.Model {
  productTag: CreateProductTagsResponseInvalidProductTagsProductTag[];
  static names(): { [key: string]: string } {
    return {
      productTag: 'ProductTag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      productTag: { 'type': 'array', 'itemType': CreateProductTagsResponseInvalidProductTagsProductTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateStudioAppDomainOpenResponseData extends $tea.Model {
  appId: string;
  host: string;
  id: number;
  isBeian: string;
  projectId: string;
  protocol: string;
  tenantId: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      host: 'Host',
      id: 'Id',
      isBeian: 'IsBeian',
      projectId: 'ProjectId',
      protocol: 'Protocol',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      host: 'string',
      id: 'number',
      isBeian: 'string',
      projectId: 'string',
      protocol: 'string',
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTopicRouteTableResponseFailureTopics extends $tea.Model {
  topic: { [key: string]: any }[];
  static names(): { [key: string]: string } {
    return {
      topic: 'Topic',
    };
  }

  static types(): { [key: string]: any } {
    return {
      topic: { 'type': 'array', 'itemType': { 'type': 'map', 'keyType': 'string', 'valueType': 'any' } },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDeviceSpeechRequestDeviceSpeechList extends $tea.Model {
  audioFormat: string;
  bizCode: string;
  static names(): { [key: string]: string } {
    return {
      audioFormat: 'AudioFormat',
      bizCode: 'BizCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      audioFormat: 'string',
      bizCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteShareTaskDeviceResponseData extends $tea.Model {
  progress: number;
  progressId: string;
  static names(): { [key: string]: string } {
    return {
      progress: 'Progress',
      progressId: 'ProgressId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      progress: 'number',
      progressId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTopicRouteTableResponseFailureTopics extends $tea.Model {
  topic: { [key: string]: any }[];
  static names(): { [key: string]: string } {
    return {
      topic: 'Topic',
    };
  }

  static types(): { [key: string]: any } {
    return {
      topic: { 'type': 'array', 'itemType': { 'type': 'map', 'keyType': 'string', 'valueType': 'any' } },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GenerateDeviceNameListURLResponseData extends $tea.Model {
  accessKeyId: string;
  fileUrl: string;
  host: string;
  key: string;
  objectStorage: string;
  policy: string;
  signature: string;
  utcCreate: string;
  static names(): { [key: string]: string } {
    return {
      accessKeyId: 'AccessKeyId',
      fileUrl: 'FileUrl',
      host: 'Host',
      key: 'Key',
      objectStorage: 'ObjectStorage',
      policy: 'Policy',
      signature: 'Signature',
      utcCreate: 'UtcCreate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessKeyId: 'string',
      fileUrl: 'string',
      host: 'string',
      key: 'string',
      objectStorage: 'string',
      policy: 'string',
      signature: 'string',
      utcCreate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GenerateFileUploadURLResponseData extends $tea.Model {
  host: string;
  key: string;
  objectStorage: string;
  ossAccessKeyId: string;
  policy: string;
  signature: string;
  static names(): { [key: string]: string } {
    return {
      host: 'Host',
      key: 'Key',
      objectStorage: 'ObjectStorage',
      ossAccessKeyId: 'OssAccessKeyId',
      policy: 'Policy',
      signature: 'Signature',
    };
  }

  static types(): { [key: string]: any } {
    return {
      host: 'string',
      key: 'string',
      objectStorage: 'string',
      ossAccessKeyId: 'string',
      policy: 'string',
      signature: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GenerateOTAUploadURLResponseData extends $tea.Model {
  firmwareUrl: string;
  host: string;
  key: string;
  OSSAccessKeyId: string;
  objectStorage: string;
  policy: string;
  signature: string;
  utcCreate: string;
  static names(): { [key: string]: string } {
    return {
      firmwareUrl: 'FirmwareUrl',
      host: 'Host',
      key: 'Key',
      OSSAccessKeyId: 'OSSAccessKeyId',
      objectStorage: 'ObjectStorage',
      policy: 'Policy',
      signature: 'Signature',
      utcCreate: 'UtcCreate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      firmwareUrl: 'string',
      host: 'string',
      key: 'string',
      OSSAccessKeyId: 'string',
      objectStorage: 'string',
      policy: 'string',
      signature: 'string',
      utcCreate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataAPIServiceDetailResponseDataSqlTemplateDTORequestParamsRequestParams extends $tea.Model {
  desc: string;
  example: string;
  name: string;
  required: boolean;
  type: string;
  static names(): { [key: string]: string } {
    return {
      desc: 'Desc',
      example: 'Example',
      name: 'Name',
      required: 'Required',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      desc: 'string',
      example: 'string',
      name: 'string',
      required: 'boolean',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataAPIServiceDetailResponseDataSqlTemplateDTORequestParams extends $tea.Model {
  requestParams: GetDataAPIServiceDetailResponseDataSqlTemplateDTORequestParamsRequestParams[];
  static names(): { [key: string]: string } {
    return {
      requestParams: 'RequestParams',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestParams: { 'type': 'array', 'itemType': GetDataAPIServiceDetailResponseDataSqlTemplateDTORequestParamsRequestParams },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataAPIServiceDetailResponseDataSqlTemplateDTOResponseParamsResponseParams extends $tea.Model {
  desc: string;
  example: string;
  name: string;
  required: boolean;
  type: string;
  static names(): { [key: string]: string } {
    return {
      desc: 'Desc',
      example: 'Example',
      name: 'Name',
      required: 'Required',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      desc: 'string',
      example: 'string',
      name: 'string',
      required: 'boolean',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataAPIServiceDetailResponseDataSqlTemplateDTOResponseParams extends $tea.Model {
  responseParams: GetDataAPIServiceDetailResponseDataSqlTemplateDTOResponseParamsResponseParams[];
  static names(): { [key: string]: string } {
    return {
      responseParams: 'ResponseParams',
    };
  }

  static types(): { [key: string]: any } {
    return {
      responseParams: { 'type': 'array', 'itemType': GetDataAPIServiceDetailResponseDataSqlTemplateDTOResponseParamsResponseParams },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataAPIServiceDetailResponseDataSqlTemplateDTO extends $tea.Model {
  originSql: string;
  templateSql: string;
  requestParams: GetDataAPIServiceDetailResponseDataSqlTemplateDTORequestParams;
  responseParams: GetDataAPIServiceDetailResponseDataSqlTemplateDTOResponseParams;
  static names(): { [key: string]: string } {
    return {
      originSql: 'OriginSql',
      templateSql: 'TemplateSql',
      requestParams: 'RequestParams',
      responseParams: 'ResponseParams',
    };
  }

  static types(): { [key: string]: any } {
    return {
      originSql: 'string',
      templateSql: 'string',
      requestParams: GetDataAPIServiceDetailResponseDataSqlTemplateDTORequestParams,
      responseParams: GetDataAPIServiceDetailResponseDataSqlTemplateDTOResponseParams,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataAPIServiceDetailResponseData extends $tea.Model {
  apiPath: string;
  apiSrn: string;
  createTime: number;
  dateFormat: string;
  description: string;
  displayName: string;
  lastUpdateTime: number;
  requestMethod: string;
  requestProtocol: string;
  status: number;
  sqlTemplateDTO: GetDataAPIServiceDetailResponseDataSqlTemplateDTO;
  static names(): { [key: string]: string } {
    return {
      apiPath: 'ApiPath',
      apiSrn: 'ApiSrn',
      createTime: 'CreateTime',
      dateFormat: 'DateFormat',
      description: 'Description',
      displayName: 'DisplayName',
      lastUpdateTime: 'LastUpdateTime',
      requestMethod: 'RequestMethod',
      requestProtocol: 'RequestProtocol',
      status: 'Status',
      sqlTemplateDTO: 'SqlTemplateDTO',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiPath: 'string',
      apiSrn: 'string',
      createTime: 'number',
      dateFormat: 'string',
      description: 'string',
      displayName: 'string',
      lastUpdateTime: 'number',
      requestMethod: 'string',
      requestProtocol: 'string',
      status: 'number',
      sqlTemplateDTO: GetDataAPIServiceDetailResponseDataSqlTemplateDTO,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDestinationResponseDestination extends $tea.Model {
  configuration: string;
  destinationId: string;
  isFailover: boolean;
  name: string;
  status: string;
  type: string;
  utcCreated: string;
  static names(): { [key: string]: string } {
    return {
      configuration: 'Configuration',
      destinationId: 'DestinationId',
      isFailover: 'IsFailover',
      name: 'Name',
      status: 'Status',
      type: 'Type',
      utcCreated: 'UtcCreated',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configuration: 'string',
      destinationId: 'string',
      isFailover: 'boolean',
      name: 'string',
      status: 'string',
      type: 'string',
      utcCreated: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDeviceStatusResponseData extends $tea.Model {
  status: string;
  timestamp: number;
  static names(): { [key: string]: string } {
    return {
      status: 'Status',
      timestamp: 'Timestamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      status: 'string',
      timestamp: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDeviceTunnelShareStatusResponseData extends $tea.Model {
  gmtOpened: number;
  isOpen: boolean;
  password: string;
  shareId: string;
  static names(): { [key: string]: string } {
    return {
      gmtOpened: 'GmtOpened',
      isOpen: 'IsOpen',
      password: 'Password',
      shareId: 'ShareId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gmtOpened: 'number',
      isOpen: 'boolean',
      password: 'string',
      shareId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDownloadFileResponseDataHeader extends $tea.Model {
  alias: string;
  dimDateClass: string;
  fieldName: string;
  fieldType: string;
  geoClass: string;
  timeClass: string;
  typeClass: string;
  static names(): { [key: string]: string } {
    return {
      alias: 'Alias',
      dimDateClass: 'DimDateClass',
      fieldName: 'FieldName',
      fieldType: 'FieldType',
      geoClass: 'GeoClass',
      timeClass: 'TimeClass',
      typeClass: 'TypeClass',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alias: 'string',
      dimDateClass: 'string',
      fieldName: 'string',
      fieldType: 'string',
      geoClass: 'string',
      timeClass: 'string',
      typeClass: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDownloadFileResponseDataQuerySettingAstExpr extends $tea.Model {
  expr: string;
  exprType: string;
  static names(): { [key: string]: string } {
    return {
      expr: 'Expr',
      exprType: 'ExprType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      expr: 'string',
      exprType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDownloadFileResponseDataQuerySettingSelectedHeaders extends $tea.Model {
  alias: string;
  dimDateClass: string;
  fieldName: string;
  fieldType: string;
  geoClass: string;
  timeClass: string;
  static names(): { [key: string]: string } {
    return {
      alias: 'Alias',
      dimDateClass: 'DimDateClass',
      fieldName: 'FieldName',
      fieldType: 'FieldType',
      geoClass: 'GeoClass',
      timeClass: 'TimeClass',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alias: 'string',
      dimDateClass: 'string',
      fieldName: 'string',
      fieldType: 'string',
      geoClass: 'string',
      timeClass: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDownloadFileResponseDataQuerySetting extends $tea.Model {
  astExpr: GetDownloadFileResponseDataQuerySettingAstExpr[];
  selectedHeaders: GetDownloadFileResponseDataQuerySettingSelectedHeaders[];
  static names(): { [key: string]: string } {
    return {
      astExpr: 'AstExpr',
      selectedHeaders: 'SelectedHeaders',
    };
  }

  static types(): { [key: string]: any } {
    return {
      astExpr: { 'type': 'array', 'itemType': GetDownloadFileResponseDataQuerySettingAstExpr },
      selectedHeaders: { 'type': 'array', 'itemType': GetDownloadFileResponseDataQuerySettingSelectedHeaders },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDownloadFileResponseData extends $tea.Model {
  asyncExecute: boolean;
  beginTime: number;
  csvFileName: string;
  csvUrl: string;
  datasetId: string;
  endTime: number;
  longJobId: string;
  pageNo: number;
  pageSize: number;
  previewSize: number;
  resultDataInString: string;
  status: number;
  totalCount: number;
  header: GetDownloadFileResponseDataHeader[];
  querySetting: GetDownloadFileResponseDataQuerySetting;
  result: { [key: string]: any }[];
  static names(): { [key: string]: string } {
    return {
      asyncExecute: 'AsyncExecute',
      beginTime: 'BeginTime',
      csvFileName: 'CsvFileName',
      csvUrl: 'CsvUrl',
      datasetId: 'DatasetId',
      endTime: 'EndTime',
      longJobId: 'LongJobId',
      pageNo: 'PageNo',
      pageSize: 'PageSize',
      previewSize: 'PreviewSize',
      resultDataInString: 'ResultDataInString',
      status: 'Status',
      totalCount: 'TotalCount',
      header: 'Header',
      querySetting: 'QuerySetting',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      asyncExecute: 'boolean',
      beginTime: 'number',
      csvFileName: 'string',
      csvUrl: 'string',
      datasetId: 'string',
      endTime: 'number',
      longJobId: 'string',
      pageNo: 'number',
      pageSize: 'number',
      previewSize: 'number',
      resultDataInString: 'string',
      status: 'number',
      totalCount: 'number',
      header: { 'type': 'array', 'itemType': GetDownloadFileResponseDataHeader },
      querySetting: GetDownloadFileResponseDataQuerySetting,
      result: { 'type': 'array', 'itemType': { 'type': 'map', 'keyType': 'string', 'valueType': 'any' } },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeDriverVersionResponseData extends $tea.Model {
  argument: string;
  configCheckRule: string;
  containerConfig: string;
  description: string;
  driverConfig: string;
  driverId: string;
  driverVersion: string;
  edgeVersion: string;
  gmtCreateTimestamp: number;
  gmtModifiedTimestamp: number;
  sourceConfig: string;
  versionState: string;
  static names(): { [key: string]: string } {
    return {
      argument: 'Argument',
      configCheckRule: 'ConfigCheckRule',
      containerConfig: 'ContainerConfig',
      description: 'Description',
      driverConfig: 'DriverConfig',
      driverId: 'DriverId',
      driverVersion: 'DriverVersion',
      edgeVersion: 'EdgeVersion',
      gmtCreateTimestamp: 'GmtCreateTimestamp',
      gmtModifiedTimestamp: 'GmtModifiedTimestamp',
      sourceConfig: 'SourceConfig',
      versionState: 'VersionState',
    };
  }

  static types(): { [key: string]: any } {
    return {
      argument: 'string',
      configCheckRule: 'string',
      containerConfig: 'string',
      description: 'string',
      driverConfig: 'string',
      driverId: 'string',
      driverVersion: 'string',
      edgeVersion: 'string',
      gmtCreateTimestamp: 'number',
      gmtModifiedTimestamp: 'number',
      sourceConfig: 'string',
      versionState: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeInstanceResponseData extends $tea.Model {
  bizEnable: boolean;
  gmtCreate: string;
  gmtCreateTimestamp: number;
  gmtModified: string;
  gmtModifiedTimestamp: number;
  instanceId: string;
  latestDeploymentStatus: number;
  latestDeploymentType: string;
  name: string;
  roleArn: string;
  roleAttachTime: string;
  roleAttachTimestamp: number;
  roleName: string;
  spec: number;
  tags: string;
  type: string;
  static names(): { [key: string]: string } {
    return {
      bizEnable: 'BizEnable',
      gmtCreate: 'GmtCreate',
      gmtCreateTimestamp: 'GmtCreateTimestamp',
      gmtModified: 'GmtModified',
      gmtModifiedTimestamp: 'GmtModifiedTimestamp',
      instanceId: 'InstanceId',
      latestDeploymentStatus: 'LatestDeploymentStatus',
      latestDeploymentType: 'LatestDeploymentType',
      name: 'Name',
      roleArn: 'RoleArn',
      roleAttachTime: 'RoleAttachTime',
      roleAttachTimestamp: 'RoleAttachTimestamp',
      roleName: 'RoleName',
      spec: 'Spec',
      tags: 'Tags',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizEnable: 'boolean',
      gmtCreate: 'string',
      gmtCreateTimestamp: 'number',
      gmtModified: 'string',
      gmtModifiedTimestamp: 'number',
      instanceId: 'string',
      latestDeploymentStatus: 'number',
      latestDeploymentType: 'string',
      name: 'string',
      roleArn: 'string',
      roleAttachTime: 'string',
      roleAttachTimestamp: 'number',
      roleName: 'string',
      spec: 'number',
      tags: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeInstanceDeploymentResponseDataTaskListResourceSnapshotList extends $tea.Model {
  gmtCompleted: string;
  gmtCompletedTimestamp: number;
  gmtCreate: string;
  gmtCreateTimestamp: number;
  gmtModified: string;
  gmtModifiedTimestamp: number;
  log: string;
  operateType: number;
  resourceId: string;
  resourceName: string;
  resourceType: string;
  snapshotId: string;
  stage: number;
  status: number;
  static names(): { [key: string]: string } {
    return {
      gmtCompleted: 'GmtCompleted',
      gmtCompletedTimestamp: 'GmtCompletedTimestamp',
      gmtCreate: 'GmtCreate',
      gmtCreateTimestamp: 'GmtCreateTimestamp',
      gmtModified: 'GmtModified',
      gmtModifiedTimestamp: 'GmtModifiedTimestamp',
      log: 'Log',
      operateType: 'OperateType',
      resourceId: 'ResourceId',
      resourceName: 'ResourceName',
      resourceType: 'ResourceType',
      snapshotId: 'SnapshotId',
      stage: 'Stage',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gmtCompleted: 'string',
      gmtCompletedTimestamp: 'number',
      gmtCreate: 'string',
      gmtCreateTimestamp: 'number',
      gmtModified: 'string',
      gmtModifiedTimestamp: 'number',
      log: 'string',
      operateType: 'number',
      resourceId: 'string',
      resourceName: 'string',
      resourceType: 'string',
      snapshotId: 'string',
      stage: 'number',
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeInstanceDeploymentResponseDataTaskList extends $tea.Model {
  gatewayId: string;
  gmtCompleted: string;
  gmtCompletedTimestamp: number;
  gmtCreate: string;
  gmtCreateTimestamp: number;
  gmtModified: string;
  gmtModifiedTimestamp: number;
  stage: number;
  status: number;
  taskId: string;
  resourceSnapshotList: GetEdgeInstanceDeploymentResponseDataTaskListResourceSnapshotList[];
  static names(): { [key: string]: string } {
    return {
      gatewayId: 'GatewayId',
      gmtCompleted: 'GmtCompleted',
      gmtCompletedTimestamp: 'GmtCompletedTimestamp',
      gmtCreate: 'GmtCreate',
      gmtCreateTimestamp: 'GmtCreateTimestamp',
      gmtModified: 'GmtModified',
      gmtModifiedTimestamp: 'GmtModifiedTimestamp',
      stage: 'Stage',
      status: 'Status',
      taskId: 'TaskId',
      resourceSnapshotList: 'ResourceSnapshotList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gatewayId: 'string',
      gmtCompleted: 'string',
      gmtCompletedTimestamp: 'number',
      gmtCreate: 'string',
      gmtCreateTimestamp: 'number',
      gmtModified: 'string',
      gmtModifiedTimestamp: 'number',
      stage: 'number',
      status: 'number',
      taskId: 'string',
      resourceSnapshotList: { 'type': 'array', 'itemType': GetEdgeInstanceDeploymentResponseDataTaskListResourceSnapshotList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeInstanceDeploymentResponseData extends $tea.Model {
  deploymentId: string;
  description: string;
  gmtCompleted: string;
  gmtCompletedTimestamp: number;
  gmtCreate: string;
  gmtCreateTimestamp: number;
  gmtModified: string;
  gmtModifiedTimestamp: number;
  status: number;
  type: string;
  taskList: GetEdgeInstanceDeploymentResponseDataTaskList[];
  static names(): { [key: string]: string } {
    return {
      deploymentId: 'DeploymentId',
      description: 'Description',
      gmtCompleted: 'GmtCompleted',
      gmtCompletedTimestamp: 'GmtCompletedTimestamp',
      gmtCreate: 'GmtCreate',
      gmtCreateTimestamp: 'GmtCreateTimestamp',
      gmtModified: 'GmtModified',
      gmtModifiedTimestamp: 'GmtModifiedTimestamp',
      status: 'Status',
      type: 'Type',
      taskList: 'TaskList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deploymentId: 'string',
      description: 'string',
      gmtCompleted: 'string',
      gmtCompletedTimestamp: 'number',
      gmtCreate: 'string',
      gmtCreateTimestamp: 'number',
      gmtModified: 'string',
      gmtModifiedTimestamp: 'number',
      status: 'number',
      type: 'string',
      taskList: { 'type': 'array', 'itemType': GetEdgeInstanceDeploymentResponseDataTaskList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeInstanceMessageRoutingResponseDataRouteContext extends $tea.Model {
  qos: string;
  sourceApplicationName: string;
  sourceFcFunctionName: string;
  sourceFcServiceName: string;
  targetApplicationName: string;
  targetFcFunctionName: string;
  targetFcServiceName: string;
  static names(): { [key: string]: string } {
    return {
      qos: 'Qos',
      sourceApplicationName: 'SourceApplicationName',
      sourceFcFunctionName: 'SourceFcFunctionName',
      sourceFcServiceName: 'SourceFcServiceName',
      targetApplicationName: 'TargetApplicationName',
      targetFcFunctionName: 'TargetFcFunctionName',
      targetFcServiceName: 'TargetFcServiceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      qos: 'string',
      sourceApplicationName: 'string',
      sourceFcFunctionName: 'string',
      sourceFcServiceName: 'string',
      targetApplicationName: 'string',
      targetFcFunctionName: 'string',
      targetFcServiceName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeInstanceMessageRoutingResponseData extends $tea.Model {
  gmtCreate: string;
  gmtCreateTimestamp: number;
  gmtModified: string;
  gmtModifiedTimestamp: number;
  name: string;
  sourceData: string;
  sourceType: string;
  targetData: string;
  targetType: string;
  topicFilter: string;
  routeContext: GetEdgeInstanceMessageRoutingResponseDataRouteContext;
  static names(): { [key: string]: string } {
    return {
      gmtCreate: 'GmtCreate',
      gmtCreateTimestamp: 'GmtCreateTimestamp',
      gmtModified: 'GmtModified',
      gmtModifiedTimestamp: 'GmtModifiedTimestamp',
      name: 'Name',
      sourceData: 'SourceData',
      sourceType: 'SourceType',
      targetData: 'TargetData',
      targetType: 'TargetType',
      topicFilter: 'TopicFilter',
      routeContext: 'RouteContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gmtCreate: 'string',
      gmtCreateTimestamp: 'number',
      gmtModified: 'string',
      gmtModifiedTimestamp: 'number',
      name: 'string',
      sourceData: 'string',
      sourceType: 'string',
      targetData: 'string',
      targetType: 'string',
      topicFilter: 'string',
      routeContext: GetEdgeInstanceMessageRoutingResponseDataRouteContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayBySubDeviceResponseData extends $tea.Model {
  deviceName: string;
  deviceSecret: string;
  firmwareVersion: string;
  gmtActive: string;
  gmtCreate: string;
  gmtOnline: string;
  ipAddress: string;
  nodeType: string;
  productKey: string;
  productName: string;
  status: string;
  utcActive: string;
  utcCreate: string;
  utcOnline: string;
  iotId: string;
  region: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      deviceSecret: 'DeviceSecret',
      firmwareVersion: 'FirmwareVersion',
      gmtActive: 'GmtActive',
      gmtCreate: 'GmtCreate',
      gmtOnline: 'GmtOnline',
      ipAddress: 'IpAddress',
      nodeType: 'NodeType',
      productKey: 'ProductKey',
      productName: 'ProductName',
      status: 'Status',
      utcActive: 'UtcActive',
      utcCreate: 'UtcCreate',
      utcOnline: 'UtcOnline',
      iotId: 'iotId',
      region: 'region',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      deviceSecret: 'string',
      firmwareVersion: 'string',
      gmtActive: 'string',
      gmtCreate: 'string',
      gmtOnline: 'string',
      ipAddress: 'string',
      nodeType: 'string',
      productKey: 'string',
      productName: 'string',
      status: 'string',
      utcActive: 'string',
      utcCreate: 'string',
      utcOnline: 'string',
      iotId: 'string',
      region: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetLoraNodesTaskResponseSuccessDevEuis extends $tea.Model {
  successDevEui: string[];
  static names(): { [key: string]: string } {
    return {
      successDevEui: 'SuccessDevEui',
    };
  }

  static types(): { [key: string]: any } {
    return {
      successDevEui: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetParserResponseData extends $tea.Model {
  dataSourceId: number;
  description: string;
  name: string;
  parserId: number;
  script: string;
  scriptDraft: string;
  status: string;
  utcCreated: string;
  utcModified: string;
  static names(): { [key: string]: string } {
    return {
      dataSourceId: 'DataSourceId',
      description: 'Description',
      name: 'Name',
      parserId: 'ParserId',
      script: 'Script',
      scriptDraft: 'ScriptDraft',
      status: 'Status',
      utcCreated: 'UtcCreated',
      utcModified: 'UtcModified',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataSourceId: 'number',
      description: 'string',
      name: 'string',
      parserId: 'number',
      script: 'string',
      scriptDraft: 'string',
      status: 'string',
      utcCreated: 'string',
      utcModified: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetParserDataSourceResponseDataSource extends $tea.Model {
  createUserId: number;
  dataSourceId: number;
  description: string;
  name: string;
  utcCreated: string;
  static names(): { [key: string]: string } {
    return {
      createUserId: 'CreateUserId',
      dataSourceId: 'DataSourceId',
      description: 'Description',
      name: 'Name',
      utcCreated: 'UtcCreated',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createUserId: 'number',
      dataSourceId: 'number',
      description: 'string',
      name: 'string',
      utcCreated: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRuleResponseRuleInfo extends $tea.Model {
  createUserId: number;
  created: string;
  dataType: string;
  id: number;
  modified: string;
  name: string;
  productKey: string;
  ruleDesc: string;
  select: string;
  shortTopic: string;
  status: string;
  topic: string;
  topicType: number;
  utcCreated: string;
  utcModified: string;
  where: string;
  static names(): { [key: string]: string } {
    return {
      createUserId: 'CreateUserId',
      created: 'Created',
      dataType: 'DataType',
      id: 'Id',
      modified: 'Modified',
      name: 'Name',
      productKey: 'ProductKey',
      ruleDesc: 'RuleDesc',
      select: 'Select',
      shortTopic: 'ShortTopic',
      status: 'Status',
      topic: 'Topic',
      topicType: 'TopicType',
      utcCreated: 'UtcCreated',
      utcModified: 'UtcModified',
      where: 'Where',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createUserId: 'number',
      created: 'string',
      dataType: 'string',
      id: 'number',
      modified: 'string',
      name: 'string',
      productKey: 'string',
      ruleDesc: 'string',
      select: 'string',
      shortTopic: 'string',
      status: 'string',
      topic: 'string',
      topicType: 'number',
      utcCreated: 'string',
      utcModified: 'string',
      where: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRuleActionResponseRuleActionInfo extends $tea.Model {
  configuration: string;
  errorActionFlag: boolean;
  id: number;
  ruleId: number;
  type: string;
  static names(): { [key: string]: string } {
    return {
      configuration: 'Configuration',
      errorActionFlag: 'ErrorActionFlag',
      id: 'Id',
      ruleId: 'RuleId',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configuration: 'string',
      errorActionFlag: 'boolean',
      id: 'number',
      ruleId: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSceneRuleResponseData extends $tea.Model {
  gmtCreate: number;
  gmtModified: number;
  ruleContent: string;
  ruleDescription: string;
  ruleName: string;
  ruleStatus: number;
  static names(): { [key: string]: string } {
    return {
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      ruleContent: 'RuleContent',
      ruleDescription: 'RuleDescription',
      ruleName: 'RuleName',
      ruleStatus: 'RuleStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gmtCreate: 'number',
      gmtModified: 'number',
      ruleContent: 'string',
      ruleDescription: 'string',
      ruleName: 'string',
      ruleStatus: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSoundCodeAudioResponseData extends $tea.Model {
  items: string[];
  static names(): { [key: string]: string } {
    return {
      items: 'Items',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSoundCodeScheduleResponseData extends $tea.Model {
  description: string;
  endDate: string;
  endTime: string;
  gmtCreate: number;
  name: string;
  openType: string;
  scheduleCode: string;
  startDate: string;
  startTime: string;
  status: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      endDate: 'EndDate',
      endTime: 'EndTime',
      gmtCreate: 'GmtCreate',
      name: 'Name',
      openType: 'OpenType',
      scheduleCode: 'ScheduleCode',
      startDate: 'StartDate',
      startTime: 'StartTime',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      endDate: 'string',
      endTime: 'string',
      gmtCreate: 'number',
      name: 'string',
      openType: 'string',
      scheduleCode: 'string',
      startDate: 'string',
      startTime: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSpeechDeviceDetailResponseData extends $tea.Model {
  availableSpace: number;
  deviceName: string;
  iotId: string;
  productKey: string;
  speechListUpdateTime: number;
  status: string;
  totalSpace: number;
  static names(): { [key: string]: string } {
    return {
      availableSpace: 'AvailableSpace',
      deviceName: 'DeviceName',
      iotId: 'IotId',
      productKey: 'ProductKey',
      speechListUpdateTime: 'SpeechListUpdateTime',
      status: 'Status',
      totalSpace: 'TotalSpace',
    };
  }

  static types(): { [key: string]: any } {
    return {
      availableSpace: 'number',
      deviceName: 'string',
      iotId: 'string',
      productKey: 'string',
      speechListUpdateTime: 'number',
      status: 'string',
      totalSpace: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSpeechLicenseDeviceStatisticsResponseData extends $tea.Model {
  availableQuota: number;
  expiredQuota: number;
  expiringQuota: number;
  static names(): { [key: string]: string } {
    return {
      availableQuota: 'AvailableQuota',
      expiredQuota: 'ExpiredQuota',
      expiringQuota: 'ExpiringQuota',
    };
  }

  static types(): { [key: string]: any } {
    return {
      availableQuota: 'number',
      expiredQuota: 'number',
      expiringQuota: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSpeechVoiceResponseDataItemsVoiceListItems extends $tea.Model {
  label: string;
  value: string;
  static names(): { [key: string]: string } {
    return {
      label: 'Label',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      label: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSpeechVoiceResponseDataItemsVoiceList extends $tea.Model {
  items: GetSpeechVoiceResponseDataItemsVoiceListItems[];
  static names(): { [key: string]: string } {
    return {
      items: 'Items',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: { 'type': 'array', 'itemType': GetSpeechVoiceResponseDataItemsVoiceListItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSpeechVoiceResponseDataItems extends $tea.Model {
  label: string;
  value: string;
  voiceList: GetSpeechVoiceResponseDataItemsVoiceList;
  static names(): { [key: string]: string } {
    return {
      label: 'Label',
      value: 'Value',
      voiceList: 'VoiceList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      label: 'string',
      value: 'string',
      voiceList: GetSpeechVoiceResponseDataItemsVoiceList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSpeechVoiceResponseData extends $tea.Model {
  items: GetSpeechVoiceResponseDataItems[];
  static names(): { [key: string]: string } {
    return {
      items: 'Items',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: { 'type': 'array', 'itemType': GetSpeechVoiceResponseDataItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStudioAppTokenOpenResponseData extends $tea.Model {
  bizId: string;
  bizType: string;
  isEnable: string;
  token: string;
  type: string;
  static names(): { [key: string]: string } {
    return {
      bizId: 'BizId',
      bizType: 'BizType',
      isEnable: 'IsEnable',
      token: 'Token',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizId: 'string',
      bizType: 'string',
      isEnable: 'string',
      token: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetThingModelTslResponseData extends $tea.Model {
  tslStr: string;
  tslUri: string;
  static names(): { [key: string]: string } {
    return {
      tslStr: 'TslStr',
      tslUri: 'TslUri',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tslStr: 'string',
      tslUri: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetThingModelTslPublishedResponseData extends $tea.Model {
  tslStr: string;
  tslUri: string;
  static names(): { [key: string]: string } {
    return {
      tslStr: 'TslStr',
      tslUri: 'TslUri',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tslStr: 'string',
      tslUri: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetThingScriptResponseData extends $tea.Model {
  scriptType: string;
  scriptUrl: string;
  static names(): { [key: string]: string } {
    return {
      scriptType: 'ScriptType',
      scriptUrl: 'ScriptUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      scriptType: 'string',
      scriptUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetThingTopoResponseDataListDeviceInfo extends $tea.Model {
  deviceName: string;
  iotId: string;
  productKey: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetThingTopoResponseDataList extends $tea.Model {
  deviceInfo: GetThingTopoResponseDataListDeviceInfo[];
  static names(): { [key: string]: string } {
    return {
      deviceInfo: 'deviceInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceInfo: { 'type': 'array', 'itemType': GetThingTopoResponseDataListDeviceInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetThingTopoResponseData extends $tea.Model {
  currentPage: number;
  pageCount: number;
  pageSize: number;
  total: number;
  list: GetThingTopoResponseDataList;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      pageCount: 'PageCount',
      pageSize: 'PageSize',
      total: 'Total',
      list: 'List',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      pageCount: 'number',
      pageSize: 'number',
      total: 'number',
      list: GetThingTopoResponseDataList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GisQueryDeviceLocationRequestThingList extends $tea.Model {
  productKey?: string;
  deviceName?: string;
  static names(): { [key: string]: string } {
    return {
      productKey: 'ProductKey',
      deviceName: 'DeviceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      productKey: 'string',
      deviceName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GisQueryDeviceLocationResponseData extends $tea.Model {
  adcode: number;
  city: string;
  coordinateSystem: number;
  country: string;
  deviceName: string;
  ip: string;
  latitude: number;
  longitude: number;
  productKey: string;
  province: string;
  static names(): { [key: string]: string } {
    return {
      adcode: 'Adcode',
      city: 'City',
      coordinateSystem: 'CoordinateSystem',
      country: 'Country',
      deviceName: 'DeviceName',
      ip: 'Ip',
      latitude: 'Latitude',
      longitude: 'Longitude',
      productKey: 'ProductKey',
      province: 'Province',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adcode: 'number',
      city: 'string',
      coordinateSystem: 'number',
      country: 'string',
      deviceName: 'string',
      ip: 'string',
      latitude: 'number',
      longitude: 'number',
      productKey: 'string',
      province: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GisSearchDeviceTraceResponseDataPoints extends $tea.Model {
  locateTime: number;
  location: string;
  static names(): { [key: string]: string } {
    return {
      locateTime: 'LocateTime',
      location: 'Location',
    };
  }

  static types(): { [key: string]: any } {
    return {
      locateTime: 'number',
      location: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GisSearchDeviceTraceResponseData extends $tea.Model {
  deviceName: string;
  productKey: string;
  points: GisSearchDeviceTraceResponseDataPoints[];
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      productKey: 'ProductKey',
      points: 'Points',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      productKey: 'string',
      points: { 'type': 'array', 'itemType': GisSearchDeviceTraceResponseDataPoints },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportDTDataRequestItems extends $tea.Model {
  deviceName: string;
  params: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      params: 'Params',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      params: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportDeviceResponseData extends $tea.Model {
  deviceName: string;
  deviceSecret: string;
  iotId: string;
  nickname: string;
  productKey: string;
  sn: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      deviceSecret: 'DeviceSecret',
      iotId: 'IotId',
      nickname: 'Nickname',
      productKey: 'ProductKey',
      sn: 'Sn',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      deviceSecret: 'string',
      iotId: 'string',
      nickname: 'string',
      productKey: 'string',
      sn: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InvokeDataAPIServiceRequestParam extends $tea.Model {
  paramType?: string;
  listParamValue?: string[];
  listParamType?: string;
  paramName?: string;
  paramValue?: string;
  static names(): { [key: string]: string } {
    return {
      paramType: 'ParamType',
      listParamValue: 'ListParamValue',
      listParamType: 'ListParamType',
      paramName: 'ParamName',
      paramValue: 'ParamValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      paramType: 'string',
      listParamValue: { 'type': 'array', 'itemType': 'string' },
      listParamType: 'string',
      paramName: 'string',
      paramValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InvokeDataAPIServiceResponseDataFieldNameList extends $tea.Model {
  fieldNameList: string[];
  static names(): { [key: string]: string } {
    return {
      fieldNameList: 'FieldNameList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fieldNameList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InvokeDataAPIServiceResponseDataResultList extends $tea.Model {
  resultList: { [key: string]: any }[];
  static names(): { [key: string]: string } {
    return {
      resultList: 'ResultList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resultList: { 'type': 'array', 'itemType': { 'type': 'map', 'keyType': 'string', 'valueType': 'any' } },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InvokeDataAPIServiceResponseData extends $tea.Model {
  apiSrn: string;
  pageNo: number;
  pageSize: number;
  totalSize: number;
  fieldNameList: InvokeDataAPIServiceResponseDataFieldNameList;
  resultList: InvokeDataAPIServiceResponseDataResultList;
  static names(): { [key: string]: string } {
    return {
      apiSrn: 'ApiSrn',
      pageNo: 'PageNo',
      pageSize: 'PageSize',
      totalSize: 'TotalSize',
      fieldNameList: 'FieldNameList',
      resultList: 'ResultList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiSrn: 'string',
      pageNo: 'number',
      pageSize: 'number',
      totalSize: 'number',
      fieldNameList: InvokeDataAPIServiceResponseDataFieldNameList,
      resultList: InvokeDataAPIServiceResponseDataResultList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InvokeThingServiceResponseData extends $tea.Model {
  messageId: string;
  result: string;
  static names(): { [key: string]: string } {
    return {
      messageId: 'MessageId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      messageId: 'string',
      result: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAnalyticsDataRequestCondition extends $tea.Model {
  betweenEnd?: string;
  betweenStart?: string;
  fieldName: string;
  operate: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      betweenEnd: 'BetweenEnd',
      betweenStart: 'BetweenStart',
      fieldName: 'FieldName',
      operate: 'Operate',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      betweenEnd: 'string',
      betweenStart: 'string',
      fieldName: 'string',
      operate: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAnalyticsDataResponseData extends $tea.Model {
  count: number;
  hasNext: boolean;
  pageNum: number;
  pageSize: number;
  resultJson: string;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      hasNext: 'HasNext',
      pageNum: 'PageNum',
      pageSize: 'PageSize',
      resultJson: 'ResultJson',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      hasNext: 'boolean',
      pageNum: 'number',
      pageSize: 'number',
      resultJson: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataSourceItemResponseDataSourceItemsDataSourceItem extends $tea.Model {
  dataSourceItemId: number;
  deviceName: string;
  productKey: string;
  scopeType: string;
  topic: string;
  static names(): { [key: string]: string } {
    return {
      dataSourceItemId: 'DataSourceItemId',
      deviceName: 'DeviceName',
      productKey: 'ProductKey',
      scopeType: 'ScopeType',
      topic: 'Topic',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataSourceItemId: 'number',
      deviceName: 'string',
      productKey: 'string',
      scopeType: 'string',
      topic: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataSourceItemResponseDataSourceItems extends $tea.Model {
  dataSourceItem: ListDataSourceItemResponseDataSourceItemsDataSourceItem[];
  static names(): { [key: string]: string } {
    return {
      dataSourceItem: 'dataSourceItem',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataSourceItem: { 'type': 'array', 'itemType': ListDataSourceItemResponseDataSourceItemsDataSourceItem },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDestinationResponseDestinationsDestinations extends $tea.Model {
  configuration: string;
  description: string;
  destinationId: number;
  isFailover: boolean;
  name: string;
  status: string;
  type: string;
  utcCreated: string;
  static names(): { [key: string]: string } {
    return {
      configuration: 'Configuration',
      description: 'Description',
      destinationId: 'DestinationId',
      isFailover: 'IsFailover',
      name: 'Name',
      status: 'Status',
      type: 'Type',
      utcCreated: 'UtcCreated',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configuration: 'string',
      description: 'string',
      destinationId: 'number',
      isFailover: 'boolean',
      name: 'string',
      status: 'string',
      type: 'string',
      utcCreated: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDestinationResponseDestinations extends $tea.Model {
  destinations: ListDestinationResponseDestinationsDestinations[];
  static names(): { [key: string]: string } {
    return {
      destinations: 'destinations',
    };
  }

  static types(): { [key: string]: any } {
    return {
      destinations: { 'type': 'array', 'itemType': ListDestinationResponseDestinationsDestinations },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDeviceDistributeJobResponseDataJobInfoItemsTargetInstanceConfigsTargetInstanceConfigs extends $tea.Model {
  targetInstanceId: string;
  targetInstanceName: string;
  targetRegion: string;
  static names(): { [key: string]: string } {
    return {
      targetInstanceId: 'TargetInstanceId',
      targetInstanceName: 'TargetInstanceName',
      targetRegion: 'TargetRegion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      targetInstanceId: 'string',
      targetInstanceName: 'string',
      targetRegion: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDeviceDistributeJobResponseDataJobInfoItemsTargetInstanceConfigs extends $tea.Model {
  targetInstanceConfigs: ListDeviceDistributeJobResponseDataJobInfoItemsTargetInstanceConfigsTargetInstanceConfigs[];
  static names(): { [key: string]: string } {
    return {
      targetInstanceConfigs: 'targetInstanceConfigs',
    };
  }

  static types(): { [key: string]: any } {
    return {
      targetInstanceConfigs: { 'type': 'array', 'itemType': ListDeviceDistributeJobResponseDataJobInfoItemsTargetInstanceConfigsTargetInstanceConfigs },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDeviceDistributeJobResponseDataJobInfoItems extends $tea.Model {
  gmtCreate: number;
  jobId: string;
  productKey: string;
  sourceInstanceId: string;
  sourceInstanceName: string;
  sourceRegion: string;
  sourceUid: string;
  status: number;
  strategy: number;
  targetUid: string;
  total: number;
  targetInstanceConfigs: ListDeviceDistributeJobResponseDataJobInfoItemsTargetInstanceConfigs;
  static names(): { [key: string]: string } {
    return {
      gmtCreate: 'GmtCreate',
      jobId: 'JobId',
      productKey: 'ProductKey',
      sourceInstanceId: 'SourceInstanceId',
      sourceInstanceName: 'SourceInstanceName',
      sourceRegion: 'SourceRegion',
      sourceUid: 'SourceUid',
      status: 'Status',
      strategy: 'Strategy',
      targetUid: 'TargetUid',
      total: 'Total',
      targetInstanceConfigs: 'TargetInstanceConfigs',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gmtCreate: 'number',
      jobId: 'string',
      productKey: 'string',
      sourceInstanceId: 'string',
      sourceInstanceName: 'string',
      sourceRegion: 'string',
      sourceUid: 'string',
      status: 'number',
      strategy: 'number',
      targetUid: 'string',
      total: 'number',
      targetInstanceConfigs: ListDeviceDistributeJobResponseDataJobInfoItemsTargetInstanceConfigs,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDeviceDistributeJobResponseDataJobInfo extends $tea.Model {
  items: ListDeviceDistributeJobResponseDataJobInfoItems[];
  static names(): { [key: string]: string } {
    return {
      items: 'items',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: { 'type': 'array', 'itemType': ListDeviceDistributeJobResponseDataJobInfoItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDeviceDistributeJobResponseData extends $tea.Model {
  nextToken: string;
  total: number;
  jobInfo: ListDeviceDistributeJobResponseDataJobInfo;
  static names(): { [key: string]: string } {
    return {
      nextToken: 'NextToken',
      total: 'Total',
      jobInfo: 'JobInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nextToken: 'string',
      total: 'number',
      jobInfo: ListDeviceDistributeJobResponseDataJobInfo,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDistributedDeviceResponseDataInfoItems extends $tea.Model {
  deviceName: string;
  gmtCreate: number;
  gmtModified: number;
  productKey: string;
  sourceInstanceId: string;
  sourceInstanceName: string;
  sourceRegion: string;
  sourceUid: string;
  targetAliyunId: string;
  targetInstanceId: string;
  targetInstanceName: string;
  targetRegion: string;
  targetUid: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      productKey: 'ProductKey',
      sourceInstanceId: 'SourceInstanceId',
      sourceInstanceName: 'SourceInstanceName',
      sourceRegion: 'SourceRegion',
      sourceUid: 'SourceUid',
      targetAliyunId: 'TargetAliyunId',
      targetInstanceId: 'TargetInstanceId',
      targetInstanceName: 'TargetInstanceName',
      targetRegion: 'TargetRegion',
      targetUid: 'TargetUid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      gmtCreate: 'number',
      gmtModified: 'number',
      productKey: 'string',
      sourceInstanceId: 'string',
      sourceInstanceName: 'string',
      sourceRegion: 'string',
      sourceUid: 'string',
      targetAliyunId: 'string',
      targetInstanceId: 'string',
      targetInstanceName: 'string',
      targetRegion: 'string',
      targetUid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDistributedDeviceResponseDataInfo extends $tea.Model {
  items: ListDistributedDeviceResponseDataInfoItems[];
  static names(): { [key: string]: string } {
    return {
      items: 'items',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: { 'type': 'array', 'itemType': ListDistributedDeviceResponseDataInfoItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDistributedDeviceResponseData extends $tea.Model {
  total: number;
  info: ListDistributedDeviceResponseDataInfo;
  static names(): { [key: string]: string } {
    return {
      total: 'Total',
      info: 'Info',
    };
  }

  static types(): { [key: string]: any } {
    return {
      total: 'number',
      info: ListDistributedDeviceResponseDataInfo,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDistributedProductResponseDataInfoItems extends $tea.Model {
  gmtCreate: number;
  productKey: string;
  sourceInstanceId: string;
  sourceInstanceName: string;
  sourceRegion: string;
  sourceUid: string;
  targetAliyunId: string;
  targetInstanceId: string;
  targetInstanceName: string;
  targetRegion: string;
  targetUid: string;
  static names(): { [key: string]: string } {
    return {
      gmtCreate: 'GmtCreate',
      productKey: 'ProductKey',
      sourceInstanceId: 'SourceInstanceId',
      sourceInstanceName: 'SourceInstanceName',
      sourceRegion: 'SourceRegion',
      sourceUid: 'SourceUid',
      targetAliyunId: 'TargetAliyunId',
      targetInstanceId: 'TargetInstanceId',
      targetInstanceName: 'TargetInstanceName',
      targetRegion: 'TargetRegion',
      targetUid: 'TargetUid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gmtCreate: 'number',
      productKey: 'string',
      sourceInstanceId: 'string',
      sourceInstanceName: 'string',
      sourceRegion: 'string',
      sourceUid: 'string',
      targetAliyunId: 'string',
      targetInstanceId: 'string',
      targetInstanceName: 'string',
      targetRegion: 'string',
      targetUid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDistributedProductResponseDataInfo extends $tea.Model {
  items: ListDistributedProductResponseDataInfoItems[];
  static names(): { [key: string]: string } {
    return {
      items: 'items',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: { 'type': 'array', 'itemType': ListDistributedProductResponseDataInfoItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDistributedProductResponseData extends $tea.Model {
  total: number;
  info: ListDistributedProductResponseDataInfo;
  static names(): { [key: string]: string } {
    return {
      total: 'Total',
      info: 'Info',
    };
  }

  static types(): { [key: string]: any } {
    return {
      total: 'number',
      info: ListDistributedProductResponseDataInfo,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobResponseDataData extends $tea.Model {
  description: string;
  jobId: string;
  jobName: string;
  scheduledTime: number;
  status: string;
  type: string;
  utcCreate: string;
  utcModified: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      jobId: 'JobId',
      jobName: 'JobName',
      scheduledTime: 'ScheduledTime',
      status: 'Status',
      type: 'Type',
      utcCreate: 'UtcCreate',
      utcModified: 'UtcModified',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      jobId: 'string',
      jobName: 'string',
      scheduledTime: 'number',
      status: 'string',
      type: 'string',
      utcCreate: 'string',
      utcModified: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobResponseData extends $tea.Model {
  data: ListJobResponseDataData[];
  static names(): { [key: string]: string } {
    return {
      data: 'data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': ListJobResponseDataData },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAFirmwareResponseFirmwareInfoSimpleFirmwareInfo extends $tea.Model {
  destVersion: string;
  firmwareDesc: string;
  firmwareId: string;
  firmwareName: string;
  firmwareSign: string;
  firmwareSize: number;
  moduleName: string;
  productKey: string;
  productName: string;
  signMethod: string;
  srcVersion: string;
  status: number;
  type: number;
  utcCreate: string;
  utcModified: string;
  static names(): { [key: string]: string } {
    return {
      destVersion: 'DestVersion',
      firmwareDesc: 'FirmwareDesc',
      firmwareId: 'FirmwareId',
      firmwareName: 'FirmwareName',
      firmwareSign: 'FirmwareSign',
      firmwareSize: 'FirmwareSize',
      moduleName: 'ModuleName',
      productKey: 'ProductKey',
      productName: 'ProductName',
      signMethod: 'SignMethod',
      srcVersion: 'SrcVersion',
      status: 'Status',
      type: 'Type',
      utcCreate: 'UtcCreate',
      utcModified: 'UtcModified',
    };
  }

  static types(): { [key: string]: any } {
    return {
      destVersion: 'string',
      firmwareDesc: 'string',
      firmwareId: 'string',
      firmwareName: 'string',
      firmwareSign: 'string',
      firmwareSize: 'number',
      moduleName: 'string',
      productKey: 'string',
      productName: 'string',
      signMethod: 'string',
      srcVersion: 'string',
      status: 'number',
      type: 'number',
      utcCreate: 'string',
      utcModified: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAFirmwareResponseFirmwareInfo extends $tea.Model {
  simpleFirmwareInfo: ListOTAFirmwareResponseFirmwareInfoSimpleFirmwareInfo[];
  static names(): { [key: string]: string } {
    return {
      simpleFirmwareInfo: 'SimpleFirmwareInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      simpleFirmwareInfo: { 'type': 'array', 'itemType': ListOTAFirmwareResponseFirmwareInfoSimpleFirmwareInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAJobByDeviceResponseDataSimpleOTAJobInfoTagsOtaTagDTO extends $tea.Model {
  key: string;
  value: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAJobByDeviceResponseDataSimpleOTAJobInfoTags extends $tea.Model {
  otaTagDTO: ListOTAJobByDeviceResponseDataSimpleOTAJobInfoTagsOtaTagDTO[];
  static names(): { [key: string]: string } {
    return {
      otaTagDTO: 'OtaTagDTO',
    };
  }

  static types(): { [key: string]: any } {
    return {
      otaTagDTO: { 'type': 'array', 'itemType': ListOTAJobByDeviceResponseDataSimpleOTAJobInfoTagsOtaTagDTO },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAJobByDeviceResponseDataSimpleOTAJobInfo extends $tea.Model {
  firmwareId: string;
  jobId: string;
  jobStatus: string;
  jobType: string;
  productKey: string;
  selectionType: string;
  targetSelection: string;
  utcCreate: string;
  utcEndTime: string;
  utcModified: string;
  utcStartTime: string;
  tags: ListOTAJobByDeviceResponseDataSimpleOTAJobInfoTags;
  static names(): { [key: string]: string } {
    return {
      firmwareId: 'FirmwareId',
      jobId: 'JobId',
      jobStatus: 'JobStatus',
      jobType: 'JobType',
      productKey: 'ProductKey',
      selectionType: 'SelectionType',
      targetSelection: 'TargetSelection',
      utcCreate: 'UtcCreate',
      utcEndTime: 'UtcEndTime',
      utcModified: 'UtcModified',
      utcStartTime: 'UtcStartTime',
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      firmwareId: 'string',
      jobId: 'string',
      jobStatus: 'string',
      jobType: 'string',
      productKey: 'string',
      selectionType: 'string',
      targetSelection: 'string',
      utcCreate: 'string',
      utcEndTime: 'string',
      utcModified: 'string',
      utcStartTime: 'string',
      tags: ListOTAJobByDeviceResponseDataSimpleOTAJobInfoTags,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAJobByDeviceResponseData extends $tea.Model {
  simpleOTAJobInfo: ListOTAJobByDeviceResponseDataSimpleOTAJobInfo[];
  static names(): { [key: string]: string } {
    return {
      simpleOTAJobInfo: 'SimpleOTAJobInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      simpleOTAJobInfo: { 'type': 'array', 'itemType': ListOTAJobByDeviceResponseDataSimpleOTAJobInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAJobByFirmwareResponseDataSimpleOTAJobInfoTagsOtaTagDTO extends $tea.Model {
  key: string;
  value: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAJobByFirmwareResponseDataSimpleOTAJobInfoTags extends $tea.Model {
  otaTagDTO: ListOTAJobByFirmwareResponseDataSimpleOTAJobInfoTagsOtaTagDTO[];
  static names(): { [key: string]: string } {
    return {
      otaTagDTO: 'OtaTagDTO',
    };
  }

  static types(): { [key: string]: any } {
    return {
      otaTagDTO: { 'type': 'array', 'itemType': ListOTAJobByFirmwareResponseDataSimpleOTAJobInfoTagsOtaTagDTO },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAJobByFirmwareResponseDataSimpleOTAJobInfo extends $tea.Model {
  firmwareId: string;
  jobId: string;
  jobStatus: string;
  jobType: string;
  productKey: string;
  selectionType: string;
  targetSelection: string;
  utcCreate: string;
  utcEndTime: string;
  utcModified: string;
  utcStartTime: string;
  tags: ListOTAJobByFirmwareResponseDataSimpleOTAJobInfoTags;
  static names(): { [key: string]: string } {
    return {
      firmwareId: 'FirmwareId',
      jobId: 'JobId',
      jobStatus: 'JobStatus',
      jobType: 'JobType',
      productKey: 'ProductKey',
      selectionType: 'SelectionType',
      targetSelection: 'TargetSelection',
      utcCreate: 'UtcCreate',
      utcEndTime: 'UtcEndTime',
      utcModified: 'UtcModified',
      utcStartTime: 'UtcStartTime',
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      firmwareId: 'string',
      jobId: 'string',
      jobStatus: 'string',
      jobType: 'string',
      productKey: 'string',
      selectionType: 'string',
      targetSelection: 'string',
      utcCreate: 'string',
      utcEndTime: 'string',
      utcModified: 'string',
      utcStartTime: 'string',
      tags: ListOTAJobByFirmwareResponseDataSimpleOTAJobInfoTags,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAJobByFirmwareResponseData extends $tea.Model {
  simpleOTAJobInfo: ListOTAJobByFirmwareResponseDataSimpleOTAJobInfo[];
  static names(): { [key: string]: string } {
    return {
      simpleOTAJobInfo: 'SimpleOTAJobInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      simpleOTAJobInfo: { 'type': 'array', 'itemType': ListOTAJobByFirmwareResponseDataSimpleOTAJobInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAModuleByProductResponseData extends $tea.Model {
  aliasName: string;
  desc: string;
  gmtCreate: string;
  gmtModified: string;
  moduleName: string;
  productKey: string;
  static names(): { [key: string]: string } {
    return {
      aliasName: 'AliasName',
      desc: 'Desc',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      moduleName: 'ModuleName',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliasName: 'string',
      desc: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      moduleName: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAModuleVersionsByDeviceResponseDataSimpleOTAModuleInfo extends $tea.Model {
  deviceName: string;
  iotId: string;
  moduleName: string;
  moduleVersion: string;
  productKey: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      moduleName: 'ModuleName',
      moduleVersion: 'ModuleVersion',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      moduleName: 'string',
      moduleVersion: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAModuleVersionsByDeviceResponseData extends $tea.Model {
  simpleOTAModuleInfo: ListOTAModuleVersionsByDeviceResponseDataSimpleOTAModuleInfo[];
  static names(): { [key: string]: string } {
    return {
      simpleOTAModuleInfo: 'SimpleOTAModuleInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      simpleOTAModuleInfo: { 'type': 'array', 'itemType': ListOTAModuleVersionsByDeviceResponseDataSimpleOTAModuleInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTATaskByJobResponseDataSimpleOTATaskInfo extends $tea.Model {
  destVersion: string;
  deviceName: string;
  firmwareId: string;
  iotId: string;
  jobId: string;
  productKey: string;
  productName: string;
  progress: string;
  srcVersion: string;
  taskDesc: string;
  taskId: string;
  taskStatus: string;
  timeout: string;
  utcCreate: string;
  utcModified: string;
  static names(): { [key: string]: string } {
    return {
      destVersion: 'DestVersion',
      deviceName: 'DeviceName',
      firmwareId: 'FirmwareId',
      iotId: 'IotId',
      jobId: 'JobId',
      productKey: 'ProductKey',
      productName: 'ProductName',
      progress: 'Progress',
      srcVersion: 'SrcVersion',
      taskDesc: 'TaskDesc',
      taskId: 'TaskId',
      taskStatus: 'TaskStatus',
      timeout: 'Timeout',
      utcCreate: 'UtcCreate',
      utcModified: 'UtcModified',
    };
  }

  static types(): { [key: string]: any } {
    return {
      destVersion: 'string',
      deviceName: 'string',
      firmwareId: 'string',
      iotId: 'string',
      jobId: 'string',
      productKey: 'string',
      productName: 'string',
      progress: 'string',
      srcVersion: 'string',
      taskDesc: 'string',
      taskId: 'string',
      taskStatus: 'string',
      timeout: 'string',
      utcCreate: 'string',
      utcModified: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTATaskByJobResponseData extends $tea.Model {
  simpleOTATaskInfo: ListOTATaskByJobResponseDataSimpleOTATaskInfo[];
  static names(): { [key: string]: string } {
    return {
      simpleOTATaskInfo: 'SimpleOTATaskInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      simpleOTATaskInfo: { 'type': 'array', 'itemType': ListOTATaskByJobResponseDataSimpleOTATaskInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAUnfinishedTaskByDeviceResponseDataSimpleOTATaskInfo extends $tea.Model {
  destVersion: string;
  deviceName: string;
  firmwareId: string;
  iotId: string;
  jobId: string;
  moduleName: string;
  productKey: string;
  productName: string;
  srcVersion: string;
  taskId: string;
  taskStatus: string;
  utcCreate: string;
  utcModified: string;
  static names(): { [key: string]: string } {
    return {
      destVersion: 'DestVersion',
      deviceName: 'DeviceName',
      firmwareId: 'FirmwareId',
      iotId: 'IotId',
      jobId: 'JobId',
      moduleName: 'ModuleName',
      productKey: 'ProductKey',
      productName: 'ProductName',
      srcVersion: 'SrcVersion',
      taskId: 'TaskId',
      taskStatus: 'TaskStatus',
      utcCreate: 'UtcCreate',
      utcModified: 'UtcModified',
    };
  }

  static types(): { [key: string]: any } {
    return {
      destVersion: 'string',
      deviceName: 'string',
      firmwareId: 'string',
      iotId: 'string',
      jobId: 'string',
      moduleName: 'string',
      productKey: 'string',
      productName: 'string',
      srcVersion: 'string',
      taskId: 'string',
      taskStatus: 'string',
      utcCreate: 'string',
      utcModified: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAUnfinishedTaskByDeviceResponseData extends $tea.Model {
  simpleOTATaskInfo: ListOTAUnfinishedTaskByDeviceResponseDataSimpleOTATaskInfo[];
  static names(): { [key: string]: string } {
    return {
      simpleOTATaskInfo: 'SimpleOTATaskInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      simpleOTATaskInfo: { 'type': 'array', 'itemType': ListOTAUnfinishedTaskByDeviceResponseDataSimpleOTATaskInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListParserResponseDataParserList extends $tea.Model {
  description: string;
  name: string;
  parserId: number;
  status: string;
  utcCreated: string;
  utcModified: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      parserId: 'ParserId',
      status: 'Status',
      utcCreated: 'UtcCreated',
      utcModified: 'UtcModified',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      parserId: 'number',
      status: 'string',
      utcCreated: 'string',
      utcModified: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListParserResponseData extends $tea.Model {
  parserList: ListParserResponseDataParserList[];
  static names(): { [key: string]: string } {
    return {
      parserList: 'ParserList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      parserList: { 'type': 'array', 'itemType': ListParserResponseDataParserList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListParserDataSourceResponseDataDataSource extends $tea.Model {
  dataSourceId: number;
  description: string;
  name: string;
  utcCreated: string;
  static names(): { [key: string]: string } {
    return {
      dataSourceId: 'DataSourceId',
      description: 'Description',
      name: 'Name',
      utcCreated: 'UtcCreated',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataSourceId: 'number',
      description: 'string',
      name: 'string',
      utcCreated: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListParserDataSourceResponseData extends $tea.Model {
  dataSource: ListParserDataSourceResponseDataDataSource[];
  static names(): { [key: string]: string } {
    return {
      dataSource: 'DataSource',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataSource: { 'type': 'array', 'itemType': ListParserDataSourceResponseDataDataSource },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListParserDestinationResponseDataDestinations extends $tea.Model {
  configuration: string;
  destinationId: number;
  isFailover: boolean;
  name: string;
  type: string;
  utcCreated: string;
  utcModified: string;
  static names(): { [key: string]: string } {
    return {
      configuration: 'Configuration',
      destinationId: 'DestinationId',
      isFailover: 'IsFailover',
      name: 'Name',
      type: 'Type',
      utcCreated: 'UtcCreated',
      utcModified: 'UtcModified',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configuration: 'string',
      destinationId: 'number',
      isFailover: 'boolean',
      name: 'string',
      type: 'string',
      utcCreated: 'string',
      utcModified: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListParserDestinationResponseData extends $tea.Model {
  destinations: ListParserDestinationResponseDataDestinations[];
  static names(): { [key: string]: string } {
    return {
      destinations: 'destinations',
    };
  }

  static types(): { [key: string]: any } {
    return {
      destinations: { 'type': 'array', 'itemType': ListParserDestinationResponseDataDestinations },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProductByTagsRequestProductTag extends $tea.Model {
  tagKey: string;
  tagValue?: string;
  static names(): { [key: string]: string } {
    return {
      tagKey: 'TagKey',
      tagValue: 'TagValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagKey: 'string',
      tagValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProductByTagsResponseProductInfosProductInfo extends $tea.Model {
  createTime: number;
  description: string;
  nodeType: number;
  productKey: string;
  productName: string;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      description: 'Description',
      nodeType: 'NodeType',
      productKey: 'ProductKey',
      productName: 'ProductName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'number',
      description: 'string',
      nodeType: 'number',
      productKey: 'string',
      productName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProductByTagsResponseProductInfos extends $tea.Model {
  productInfo: ListProductByTagsResponseProductInfosProductInfo[];
  static names(): { [key: string]: string } {
    return {
      productInfo: 'ProductInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      productInfo: { 'type': 'array', 'itemType': ListProductByTagsResponseProductInfosProductInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProductTagsResponseDataProductTag extends $tea.Model {
  tagKey: string;
  tagValue: string;
  static names(): { [key: string]: string } {
    return {
      tagKey: 'TagKey',
      tagValue: 'TagValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagKey: 'string',
      tagValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProductTagsResponseData extends $tea.Model {
  productTag: ListProductTagsResponseDataProductTag[];
  static names(): { [key: string]: string } {
    return {
      productTag: 'ProductTag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      productTag: { 'type': 'array', 'itemType': ListProductTagsResponseDataProductTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRuleResponseDataRuleInfo extends $tea.Model {
  createUserId: number;
  created: string;
  dataType: string;
  id: number;
  modified: string;
  name: string;
  productKey: string;
  ruleDesc: string;
  select: string;
  shortTopic: string;
  status: string;
  topic: string;
  utcCreated: string;
  utcModified: string;
  where: string;
  static names(): { [key: string]: string } {
    return {
      createUserId: 'CreateUserId',
      created: 'Created',
      dataType: 'DataType',
      id: 'Id',
      modified: 'Modified',
      name: 'Name',
      productKey: 'ProductKey',
      ruleDesc: 'RuleDesc',
      select: 'Select',
      shortTopic: 'ShortTopic',
      status: 'Status',
      topic: 'Topic',
      utcCreated: 'UtcCreated',
      utcModified: 'UtcModified',
      where: 'Where',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createUserId: 'number',
      created: 'string',
      dataType: 'string',
      id: 'number',
      modified: 'string',
      name: 'string',
      productKey: 'string',
      ruleDesc: 'string',
      select: 'string',
      shortTopic: 'string',
      status: 'string',
      topic: 'string',
      utcCreated: 'string',
      utcModified: 'string',
      where: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRuleResponseData extends $tea.Model {
  ruleInfo: ListRuleResponseDataRuleInfo[];
  static names(): { [key: string]: string } {
    return {
      ruleInfo: 'RuleInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ruleInfo: { 'type': 'array', 'itemType': ListRuleResponseDataRuleInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRuleActionsResponseRuleActionListRuleActionInfo extends $tea.Model {
  configuration: string;
  errorActionFlag: boolean;
  id: number;
  ruleId: number;
  status: string;
  type: string;
  static names(): { [key: string]: string } {
    return {
      configuration: 'Configuration',
      errorActionFlag: 'ErrorActionFlag',
      id: 'Id',
      ruleId: 'RuleId',
      status: 'Status',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configuration: 'string',
      errorActionFlag: 'boolean',
      id: 'number',
      ruleId: 'number',
      status: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRuleActionsResponseRuleActionList extends $tea.Model {
  ruleActionInfo: ListRuleActionsResponseRuleActionListRuleActionInfo[];
  static names(): { [key: string]: string } {
    return {
      ruleActionInfo: 'RuleActionInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ruleActionInfo: { 'type': 'array', 'itemType': ListRuleActionsResponseRuleActionListRuleActionInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskResponseDataData extends $tea.Model {
  deviceName: string;
  iotId: string;
  jobId: string;
  jobName: string;
  productKey: string;
  progress: string;
  status: string;
  taskId: string;
  utcModified: string;
  utcQueueTime: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      jobId: 'JobId',
      jobName: 'JobName',
      productKey: 'ProductKey',
      progress: 'Progress',
      status: 'Status',
      taskId: 'TaskId',
      utcModified: 'UtcModified',
      utcQueueTime: 'UtcQueueTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      jobId: 'string',
      jobName: 'string',
      productKey: 'string',
      progress: 'string',
      status: 'string',
      taskId: 'string',
      utcModified: 'string',
      utcQueueTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskResponseData extends $tea.Model {
  data: ListTaskResponseDataData[];
  static names(): { [key: string]: string } {
    return {
      data: 'data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': ListTaskResponseDataData },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListThingModelVersionResponseDataModelVersions extends $tea.Model {
  description: string;
  gmtCreate: number;
  modelVersion: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      gmtCreate: 'GmtCreate',
      modelVersion: 'ModelVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      gmtCreate: 'number',
      modelVersion: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListThingModelVersionResponseData extends $tea.Model {
  modelVersions: ListThingModelVersionResponseDataModelVersions[];
  static names(): { [key: string]: string } {
    return {
      modelVersions: 'ModelVersions',
    };
  }

  static types(): { [key: string]: any } {
    return {
      modelVersions: { 'type': 'array', 'itemType': ListThingModelVersionResponseDataModelVersions },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListThingTemplatesResponseData extends $tea.Model {
  categoryKey: string;
  categoryName: string;
  static names(): { [key: string]: string } {
    return {
      categoryKey: 'CategoryKey',
      categoryName: 'CategoryName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      categoryKey: 'string',
      categoryName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class NotifyAddThingTopoResponseData extends $tea.Model {
  messageId: string;
  static names(): { [key: string]: string } {
    return {
      messageId: 'MessageId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      messageId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PageQuerySharedSpeechOpenResponseDataResultDataData extends $tea.Model {
  audioFormat: string;
  bizCode: string;
  code: string;
  speechRate: number;
  status: number;
  text: string;
  voice: string;
  volume: number;
  static names(): { [key: string]: string } {
    return {
      audioFormat: 'AudioFormat',
      bizCode: 'BizCode',
      code: 'Code',
      speechRate: 'SpeechRate',
      status: 'Status',
      text: 'Text',
      voice: 'Voice',
      volume: 'Volume',
    };
  }

  static types(): { [key: string]: any } {
    return {
      audioFormat: 'string',
      bizCode: 'string',
      code: 'string',
      speechRate: 'number',
      status: 'number',
      text: 'string',
      voice: 'string',
      volume: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PageQuerySharedSpeechOpenResponseDataResultData extends $tea.Model {
  data: PageQuerySharedSpeechOpenResponseDataResultDataData[];
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': PageQuerySharedSpeechOpenResponseDataResultDataData },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PageQuerySharedSpeechOpenResponseData extends $tea.Model {
  pageId: number;
  pageSize: number;
  total: number;
  resultData: PageQuerySharedSpeechOpenResponseDataResultData;
  static names(): { [key: string]: string } {
    return {
      pageId: 'PageId',
      pageSize: 'PageSize',
      total: 'Total',
      resultData: 'ResultData',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageId: 'number',
      pageSize: 'number',
      total: 'number',
      resultData: PageQuerySharedSpeechOpenResponseDataResultData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PageQuerySpeechBroadcastHourResponseDataResultDataData extends $tea.Model {
  code: number;
  deviceName: string;
  msg: string;
  productKey: string;
  shareTaskCode: string;
  speechId: string;
  speechs: string;
  startTime: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      deviceName: 'DeviceName',
      msg: 'Msg',
      productKey: 'ProductKey',
      shareTaskCode: 'ShareTaskCode',
      speechId: 'SpeechId',
      speechs: 'Speechs',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      deviceName: 'string',
      msg: 'string',
      productKey: 'string',
      shareTaskCode: 'string',
      speechId: 'string',
      speechs: 'string',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PageQuerySpeechBroadcastHourResponseDataResultData extends $tea.Model {
  data: PageQuerySpeechBroadcastHourResponseDataResultDataData[];
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': PageQuerySpeechBroadcastHourResponseDataResultDataData },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PageQuerySpeechBroadcastHourResponseData extends $tea.Model {
  pageId: number;
  pageSize: number;
  pageToken: string;
  total: number;
  resultData: PageQuerySpeechBroadcastHourResponseDataResultData;
  static names(): { [key: string]: string } {
    return {
      pageId: 'PageId',
      pageSize: 'PageSize',
      pageToken: 'PageToken',
      total: 'Total',
      resultData: 'ResultData',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageId: 'number',
      pageSize: 'number',
      pageToken: 'string',
      total: 'number',
      resultData: PageQuerySpeechBroadcastHourResponseDataResultData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PrintByTemplateResponseData extends $tea.Model {
  deviceErrorCode: string;
  deviceErrorMessage: string;
  id: string;
  maxRetryCount: number;
  retryCount: number;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      deviceErrorCode: 'DeviceErrorCode',
      deviceErrorMessage: 'DeviceErrorMessage',
      id: 'Id',
      maxRetryCount: 'MaxRetryCount',
      retryCount: 'RetryCount',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceErrorCode: 'string',
      deviceErrorMessage: 'string',
      id: 'string',
      maxRetryCount: 'number',
      retryCount: 'number',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PubRequestUserProp extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryBatchRegisterDeviceStatusResponseDataInvalidList extends $tea.Model {
  name: string[];
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryBatchRegisterDeviceStatusResponseDataValidList extends $tea.Model {
  name: string[];
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryBatchRegisterDeviceStatusResponseData extends $tea.Model {
  status: string;
  invalidList: QueryBatchRegisterDeviceStatusResponseDataInvalidList;
  validList: QueryBatchRegisterDeviceStatusResponseDataValidList;
  static names(): { [key: string]: string } {
    return {
      status: 'Status',
      invalidList: 'InvalidList',
      validList: 'ValidList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      status: 'string',
      invalidList: QueryBatchRegisterDeviceStatusResponseDataInvalidList,
      validList: QueryBatchRegisterDeviceStatusResponseDataValidList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryClientIdsResponseDataDynamicRegClientIds extends $tea.Model {
  clientId: string;
  createTime: number;
  static names(): { [key: string]: string } {
    return {
      clientId: 'ClientId',
      createTime: 'CreateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clientId: 'string',
      createTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryClientIdsResponseData extends $tea.Model {
  iotId: string;
  dynamicRegClientIds: QueryClientIdsResponseDataDynamicRegClientIds[];
  static names(): { [key: string]: string } {
    return {
      iotId: 'IotId',
      dynamicRegClientIds: 'DynamicRegClientIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotId: 'string',
      dynamicRegClientIds: { 'type': 'array', 'itemType': QueryClientIdsResponseDataDynamicRegClientIds },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryConsumerGroupByGroupIdResponseData extends $tea.Model {
  createTime: string;
  groupId: string;
  groupName: string;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      groupId: 'GroupId',
      groupName: 'GroupName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'string',
      groupId: 'string',
      groupName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryConsumerGroupListResponseDataConsumerGroupDTO extends $tea.Model {
  createTime: string;
  groupId: string;
  groupName: string;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      groupId: 'GroupId',
      groupName: 'GroupName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'string',
      groupId: 'string',
      groupName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryConsumerGroupListResponseData extends $tea.Model {
  consumerGroupDTO: QueryConsumerGroupListResponseDataConsumerGroupDTO[];
  static names(): { [key: string]: string } {
    return {
      consumerGroupDTO: 'ConsumerGroupDTO',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consumerGroupDTO: { 'type': 'array', 'itemType': QueryConsumerGroupListResponseDataConsumerGroupDTO },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryConsumerGroupStatusResponseClientConnectionStatusListConsumerGroupClientConnectionInfo extends $tea.Model {
  accumulatedConsumeCountPerMinute: number;
  clientId: string;
  clientIpPort: string;
  onlineTime: number;
  realTimeConsumeCountPerMinute: number;
  static names(): { [key: string]: string } {
    return {
      accumulatedConsumeCountPerMinute: 'AccumulatedConsumeCountPerMinute',
      clientId: 'ClientId',
      clientIpPort: 'ClientIpPort',
      onlineTime: 'OnlineTime',
      realTimeConsumeCountPerMinute: 'RealTimeConsumeCountPerMinute',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accumulatedConsumeCountPerMinute: 'number',
      clientId: 'string',
      clientIpPort: 'string',
      onlineTime: 'number',
      realTimeConsumeCountPerMinute: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryConsumerGroupStatusResponseClientConnectionStatusList extends $tea.Model {
  consumerGroupClientConnectionInfo: QueryConsumerGroupStatusResponseClientConnectionStatusListConsumerGroupClientConnectionInfo[];
  static names(): { [key: string]: string } {
    return {
      consumerGroupClientConnectionInfo: 'ConsumerGroupClientConnectionInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consumerGroupClientConnectionInfo: { 'type': 'array', 'itemType': QueryConsumerGroupStatusResponseClientConnectionStatusListConsumerGroupClientConnectionInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDetailSceneRuleLogResponseDataLogList extends $tea.Model {
  code: string;
  message: string;
  pkDn: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      pkDn: 'PkDn',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      pkDn: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDetailSceneRuleLogResponseData extends $tea.Model {
  currentPage: number;
  pageSize: number;
  total: number;
  logList: QueryDetailSceneRuleLogResponseDataLogList[];
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      total: 'Total',
      logList: 'LogList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      pageSize: 'number',
      total: 'number',
      logList: { 'type': 'array', 'itemType': QueryDetailSceneRuleLogResponseDataLogList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceResponseDataDeviceInfo extends $tea.Model {
  deviceId: string;
  deviceName: string;
  deviceSecret: string;
  deviceStatus: string;
  deviceType: string;
  gmtCreate: string;
  gmtModified: string;
  iotId: string;
  nickname: string;
  productKey: string;
  utcCreate: string;
  utcModified: string;
  static names(): { [key: string]: string } {
    return {
      deviceId: 'DeviceId',
      deviceName: 'DeviceName',
      deviceSecret: 'DeviceSecret',
      deviceStatus: 'DeviceStatus',
      deviceType: 'DeviceType',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      iotId: 'IotId',
      nickname: 'Nickname',
      productKey: 'ProductKey',
      utcCreate: 'UtcCreate',
      utcModified: 'UtcModified',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceId: 'string',
      deviceName: 'string',
      deviceSecret: 'string',
      deviceStatus: 'string',
      deviceType: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      iotId: 'string',
      nickname: 'string',
      productKey: 'string',
      utcCreate: 'string',
      utcModified: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceResponseData extends $tea.Model {
  deviceInfo: QueryDeviceResponseDataDeviceInfo[];
  static names(): { [key: string]: string } {
    return {
      deviceInfo: 'DeviceInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceInfo: { 'type': 'array', 'itemType': QueryDeviceResponseDataDeviceInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceBySQLResponseDataGroups extends $tea.Model {
  groupId: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceBySQLResponseDataOTAModules extends $tea.Model {
  firmwareVersion: string;
  moduleName: string;
  static names(): { [key: string]: string } {
    return {
      firmwareVersion: 'FirmwareVersion',
      moduleName: 'ModuleName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      firmwareVersion: 'string',
      moduleName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceBySQLResponseDataTags extends $tea.Model {
  tagName: string;
  tagValue: string;
  static names(): { [key: string]: string } {
    return {
      tagName: 'TagName',
      tagValue: 'TagValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagName: 'string',
      tagValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceBySQLResponseData extends $tea.Model {
  activeTime: string;
  deviceName: string;
  gmtCreate: string;
  gmtModified: string;
  iotId: string;
  nickname: string;
  productKey: string;
  status: string;
  groups: QueryDeviceBySQLResponseDataGroups[];
  OTAModules: QueryDeviceBySQLResponseDataOTAModules[];
  tags: QueryDeviceBySQLResponseDataTags[];
  static names(): { [key: string]: string } {
    return {
      activeTime: 'ActiveTime',
      deviceName: 'DeviceName',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      iotId: 'IotId',
      nickname: 'Nickname',
      productKey: 'ProductKey',
      status: 'Status',
      groups: 'Groups',
      OTAModules: 'OTAModules',
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      activeTime: 'string',
      deviceName: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      iotId: 'string',
      nickname: 'string',
      productKey: 'string',
      status: 'string',
      groups: { 'type': 'array', 'itemType': QueryDeviceBySQLResponseDataGroups },
      OTAModules: { 'type': 'array', 'itemType': QueryDeviceBySQLResponseDataOTAModules },
      tags: { 'type': 'array', 'itemType': QueryDeviceBySQLResponseDataTags },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceByStatusResponseDataSimpleDeviceInfo extends $tea.Model {
  deviceName: string;
  deviceSecret: string;
  gmtCreate: string;
  gmtModified: string;
  iotId: string;
  nickname: string;
  productKey: string;
  status: string;
  utcCreate: string;
  utcModified: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      deviceSecret: 'DeviceSecret',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      iotId: 'IotId',
      nickname: 'Nickname',
      productKey: 'ProductKey',
      status: 'Status',
      utcCreate: 'UtcCreate',
      utcModified: 'UtcModified',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      deviceSecret: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      iotId: 'string',
      nickname: 'string',
      productKey: 'string',
      status: 'string',
      utcCreate: 'string',
      utcModified: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceByStatusResponseData extends $tea.Model {
  simpleDeviceInfo: QueryDeviceByStatusResponseDataSimpleDeviceInfo[];
  static names(): { [key: string]: string } {
    return {
      simpleDeviceInfo: 'SimpleDeviceInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      simpleDeviceInfo: { 'type': 'array', 'itemType': QueryDeviceByStatusResponseDataSimpleDeviceInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceByTagsRequestTag extends $tea.Model {
  tagKey: string;
  tagValue: string;
  static names(): { [key: string]: string } {
    return {
      tagKey: 'TagKey',
      tagValue: 'TagValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagKey: 'string',
      tagValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceByTagsResponseDataSimpleDeviceInfo extends $tea.Model {
  deviceName: string;
  iotId: string;
  productKey: string;
  productName: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      productKey: 'ProductKey',
      productName: 'ProductName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      productKey: 'string',
      productName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceByTagsResponseData extends $tea.Model {
  simpleDeviceInfo: QueryDeviceByTagsResponseDataSimpleDeviceInfo[];
  static names(): { [key: string]: string } {
    return {
      simpleDeviceInfo: 'SimpleDeviceInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      simpleDeviceInfo: { 'type': 'array', 'itemType': QueryDeviceByTagsResponseDataSimpleDeviceInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceCertResponseDeviceCertInfo extends $tea.Model {
  certSN: string;
  certificate: string;
  privateKey: string;
  status: number;
  static names(): { [key: string]: string } {
    return {
      certSN: 'CertSN',
      certificate: 'Certificate',
      privateKey: 'PrivateKey',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      certSN: 'string',
      certificate: 'string',
      privateKey: 'string',
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceDesiredPropertyResponseDataListDesiredPropertyInfo extends $tea.Model {
  dataType: string;
  identifier: string;
  name: string;
  time: string;
  unit: string;
  value: string;
  version: number;
  static names(): { [key: string]: string } {
    return {
      dataType: 'DataType',
      identifier: 'Identifier',
      name: 'Name',
      time: 'Time',
      unit: 'Unit',
      value: 'Value',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataType: 'string',
      identifier: 'string',
      name: 'string',
      time: 'string',
      unit: 'string',
      value: 'string',
      version: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceDesiredPropertyResponseDataList extends $tea.Model {
  desiredPropertyInfo: QueryDeviceDesiredPropertyResponseDataListDesiredPropertyInfo[];
  static names(): { [key: string]: string } {
    return {
      desiredPropertyInfo: 'DesiredPropertyInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      desiredPropertyInfo: { 'type': 'array', 'itemType': QueryDeviceDesiredPropertyResponseDataListDesiredPropertyInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceDesiredPropertyResponseData extends $tea.Model {
  list: QueryDeviceDesiredPropertyResponseDataList;
  static names(): { [key: string]: string } {
    return {
      list: 'List',
    };
  }

  static types(): { [key: string]: any } {
    return {
      list: QueryDeviceDesiredPropertyResponseDataList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceDetailResponseData extends $tea.Model {
  deviceName: string;
  deviceSecret: string;
  firmwareVersion: string;
  gmtActive: string;
  gmtCreate: string;
  gmtOnline: string;
  iotId: string;
  ipAddress: string;
  nickname: string;
  nodeType: number;
  owner: boolean;
  productKey: string;
  productName: string;
  region: string;
  status: string;
  utcActive: string;
  utcCreate: string;
  utcOnline: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      deviceSecret: 'DeviceSecret',
      firmwareVersion: 'FirmwareVersion',
      gmtActive: 'GmtActive',
      gmtCreate: 'GmtCreate',
      gmtOnline: 'GmtOnline',
      iotId: 'IotId',
      ipAddress: 'IpAddress',
      nickname: 'Nickname',
      nodeType: 'NodeType',
      owner: 'Owner',
      productKey: 'ProductKey',
      productName: 'ProductName',
      region: 'Region',
      status: 'Status',
      utcActive: 'UtcActive',
      utcCreate: 'UtcCreate',
      utcOnline: 'UtcOnline',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      deviceSecret: 'string',
      firmwareVersion: 'string',
      gmtActive: 'string',
      gmtCreate: 'string',
      gmtOnline: 'string',
      iotId: 'string',
      ipAddress: 'string',
      nickname: 'string',
      nodeType: 'number',
      owner: 'boolean',
      productKey: 'string',
      productName: 'string',
      region: 'string',
      status: 'string',
      utcActive: 'string',
      utcCreate: 'string',
      utcOnline: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceDistributeJobResponseDataTargetInstanceConfigsTargetInstanceConfigs extends $tea.Model {
  targetInstanceId: string;
  static names(): { [key: string]: string } {
    return {
      targetInstanceId: 'TargetInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      targetInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceDistributeJobResponseDataTargetInstanceConfigs extends $tea.Model {
  targetInstanceConfigs: QueryDeviceDistributeJobResponseDataTargetInstanceConfigsTargetInstanceConfigs[];
  static names(): { [key: string]: string } {
    return {
      targetInstanceConfigs: 'targetInstanceConfigs',
    };
  }

  static types(): { [key: string]: any } {
    return {
      targetInstanceConfigs: { 'type': 'array', 'itemType': QueryDeviceDistributeJobResponseDataTargetInstanceConfigsTargetInstanceConfigs },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceDistributeJobResponseData extends $tea.Model {
  gmtCreate: number;
  jobId: string;
  productKey: string;
  sourceInstanceId: string;
  sourceUid: string;
  status: number;
  strategy: number;
  targetUid: string;
  total: number;
  targetInstanceConfigs: QueryDeviceDistributeJobResponseDataTargetInstanceConfigs;
  static names(): { [key: string]: string } {
    return {
      gmtCreate: 'GmtCreate',
      jobId: 'JobId',
      productKey: 'ProductKey',
      sourceInstanceId: 'SourceInstanceId',
      sourceUid: 'SourceUid',
      status: 'Status',
      strategy: 'Strategy',
      targetUid: 'TargetUid',
      total: 'Total',
      targetInstanceConfigs: 'TargetInstanceConfigs',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gmtCreate: 'number',
      jobId: 'string',
      productKey: 'string',
      sourceInstanceId: 'string',
      sourceUid: 'string',
      status: 'number',
      strategy: 'number',
      targetUid: 'string',
      total: 'number',
      targetInstanceConfigs: QueryDeviceDistributeJobResponseDataTargetInstanceConfigs,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceEventDataResponseDataListEventInfo extends $tea.Model {
  eventType: string;
  identifier: string;
  name: string;
  outputData: string;
  time: string;
  static names(): { [key: string]: string } {
    return {
      eventType: 'EventType',
      identifier: 'Identifier',
      name: 'Name',
      outputData: 'OutputData',
      time: 'Time',
    };
  }

  static types(): { [key: string]: any } {
    return {
      eventType: 'string',
      identifier: 'string',
      name: 'string',
      outputData: 'string',
      time: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceEventDataResponseDataList extends $tea.Model {
  eventInfo: QueryDeviceEventDataResponseDataListEventInfo[];
  static names(): { [key: string]: string } {
    return {
      eventInfo: 'EventInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      eventInfo: { 'type': 'array', 'itemType': QueryDeviceEventDataResponseDataListEventInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceEventDataResponseData extends $tea.Model {
  nextTime: number;
  nextValid: boolean;
  list: QueryDeviceEventDataResponseDataList;
  static names(): { [key: string]: string } {
    return {
      nextTime: 'NextTime',
      nextValid: 'NextValid',
      list: 'List',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nextTime: 'number',
      nextValid: 'boolean',
      list: QueryDeviceEventDataResponseDataList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceFileResponseData extends $tea.Model {
  downloadUrl: string;
  fileId: string;
  name: string;
  size: string;
  utcCreatedOn: string;
  static names(): { [key: string]: string } {
    return {
      downloadUrl: 'DownloadUrl',
      fileId: 'FileId',
      name: 'Name',
      size: 'Size',
      utcCreatedOn: 'UtcCreatedOn',
    };
  }

  static types(): { [key: string]: any } {
    return {
      downloadUrl: 'string',
      fileId: 'string',
      name: 'string',
      size: 'string',
      utcCreatedOn: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceFileListResponseDataFileSummary extends $tea.Model {
  fileId: string;
  name: string;
  size: string;
  utcCreatedOn: string;
  static names(): { [key: string]: string } {
    return {
      fileId: 'FileId',
      name: 'Name',
      size: 'Size',
      utcCreatedOn: 'UtcCreatedOn',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fileId: 'string',
      name: 'string',
      size: 'string',
      utcCreatedOn: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceFileListResponseData extends $tea.Model {
  fileSummary: QueryDeviceFileListResponseDataFileSummary[];
  static names(): { [key: string]: string } {
    return {
      fileSummary: 'FileSummary',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fileSummary: { 'type': 'array', 'itemType': QueryDeviceFileListResponseDataFileSummary },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceGroupByDeviceResponseGroupInfosGroupInfo extends $tea.Model {
  groupDesc: string;
  groupId: string;
  groupName: string;
  groupType: string;
  utcCreate: string;
  static names(): { [key: string]: string } {
    return {
      groupDesc: 'GroupDesc',
      groupId: 'GroupId',
      groupName: 'GroupName',
      groupType: 'GroupType',
      utcCreate: 'UtcCreate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupDesc: 'string',
      groupId: 'string',
      groupName: 'string',
      groupType: 'string',
      utcCreate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceGroupByDeviceResponseGroupInfos extends $tea.Model {
  groupInfo: QueryDeviceGroupByDeviceResponseGroupInfosGroupInfo[];
  static names(): { [key: string]: string } {
    return {
      groupInfo: 'GroupInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupInfo: { 'type': 'array', 'itemType': QueryDeviceGroupByDeviceResponseGroupInfosGroupInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceGroupByTagsRequestTag extends $tea.Model {
  tagKey: string;
  tagValue: string;
  static names(): { [key: string]: string } {
    return {
      tagKey: 'TagKey',
      tagValue: 'TagValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagKey: 'string',
      tagValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceGroupByTagsResponseDataDeviceGroup extends $tea.Model {
  groupId: string;
  groupName: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      groupName: 'GroupName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      groupName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceGroupByTagsResponseData extends $tea.Model {
  deviceGroup: QueryDeviceGroupByTagsResponseDataDeviceGroup[];
  static names(): { [key: string]: string } {
    return {
      deviceGroup: 'DeviceGroup',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceGroup: { 'type': 'array', 'itemType': QueryDeviceGroupByTagsResponseDataDeviceGroup },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceGroupInfoResponseData extends $tea.Model {
  deviceActive: number;
  deviceCount: number;
  deviceOnline: number;
  dynamicGroupExpression: string;
  groupDesc: string;
  groupId: string;
  groupName: string;
  utcCreate: string;
  static names(): { [key: string]: string } {
    return {
      deviceActive: 'DeviceActive',
      deviceCount: 'DeviceCount',
      deviceOnline: 'DeviceOnline',
      dynamicGroupExpression: 'DynamicGroupExpression',
      groupDesc: 'GroupDesc',
      groupId: 'GroupId',
      groupName: 'GroupName',
      utcCreate: 'UtcCreate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceActive: 'number',
      deviceCount: 'number',
      deviceOnline: 'number',
      dynamicGroupExpression: 'string',
      groupDesc: 'string',
      groupId: 'string',
      groupName: 'string',
      utcCreate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceGroupListResponseDataGroupInfo extends $tea.Model {
  groupDesc: string;
  groupId: string;
  groupName: string;
  groupType: string;
  utcCreate: string;
  static names(): { [key: string]: string } {
    return {
      groupDesc: 'GroupDesc',
      groupId: 'GroupId',
      groupName: 'GroupName',
      groupType: 'GroupType',
      utcCreate: 'UtcCreate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupDesc: 'string',
      groupId: 'string',
      groupName: 'string',
      groupType: 'string',
      utcCreate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceGroupListResponseData extends $tea.Model {
  groupInfo: QueryDeviceGroupListResponseDataGroupInfo[];
  static names(): { [key: string]: string } {
    return {
      groupInfo: 'GroupInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupInfo: { 'type': 'array', 'itemType': QueryDeviceGroupListResponseDataGroupInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceGroupTagListResponseDataGroupTagInfo extends $tea.Model {
  tagKey: string;
  tagValue: string;
  static names(): { [key: string]: string } {
    return {
      tagKey: 'TagKey',
      tagValue: 'TagValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagKey: 'string',
      tagValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceGroupTagListResponseData extends $tea.Model {
  groupTagInfo: QueryDeviceGroupTagListResponseDataGroupTagInfo[];
  static names(): { [key: string]: string } {
    return {
      groupTagInfo: 'GroupTagInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupTagInfo: { 'type': 'array', 'itemType': QueryDeviceGroupTagListResponseDataGroupTagInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceInfoResponseData extends $tea.Model {
  deviceName: string;
  deviceSecret: string;
  iotId: string;
  nickname: string;
  productKey: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      deviceSecret: 'DeviceSecret',
      iotId: 'IotId',
      nickname: 'Nickname',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      deviceSecret: 'string',
      iotId: 'string',
      nickname: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceListByDeviceGroupResponseDataSimpleDeviceInfo extends $tea.Model {
  deviceName: string;
  iotId: string;
  productKey: string;
  productName: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      productKey: 'ProductKey',
      productName: 'ProductName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      productKey: 'string',
      productName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceListByDeviceGroupResponseData extends $tea.Model {
  simpleDeviceInfo: QueryDeviceListByDeviceGroupResponseDataSimpleDeviceInfo[];
  static names(): { [key: string]: string } {
    return {
      simpleDeviceInfo: 'SimpleDeviceInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      simpleDeviceInfo: { 'type': 'array', 'itemType': QueryDeviceListByDeviceGroupResponseDataSimpleDeviceInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceOriginalEventDataResponseDataListEventInfo extends $tea.Model {
  eventType: string;
  identifier: string;
  name: string;
  outputData: string;
  time: string;
  static names(): { [key: string]: string } {
    return {
      eventType: 'EventType',
      identifier: 'Identifier',
      name: 'Name',
      outputData: 'OutputData',
      time: 'Time',
    };
  }

  static types(): { [key: string]: any } {
    return {
      eventType: 'string',
      identifier: 'string',
      name: 'string',
      outputData: 'string',
      time: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceOriginalEventDataResponseDataList extends $tea.Model {
  eventInfo: QueryDeviceOriginalEventDataResponseDataListEventInfo[];
  static names(): { [key: string]: string } {
    return {
      eventInfo: 'EventInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      eventInfo: { 'type': 'array', 'itemType': QueryDeviceOriginalEventDataResponseDataListEventInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceOriginalEventDataResponseData extends $tea.Model {
  nextPageToken: string;
  nextValid: boolean;
  list: QueryDeviceOriginalEventDataResponseDataList;
  static names(): { [key: string]: string } {
    return {
      nextPageToken: 'NextPageToken',
      nextValid: 'NextValid',
      list: 'List',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nextPageToken: 'string',
      nextValid: 'boolean',
      list: QueryDeviceOriginalEventDataResponseDataList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceOriginalPropertyDataResponseDataListPropertyInfo extends $tea.Model {
  time: string;
  value: string;
  static names(): { [key: string]: string } {
    return {
      time: 'Time',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      time: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceOriginalPropertyDataResponseDataList extends $tea.Model {
  propertyInfo: QueryDeviceOriginalPropertyDataResponseDataListPropertyInfo[];
  static names(): { [key: string]: string } {
    return {
      propertyInfo: 'PropertyInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      propertyInfo: { 'type': 'array', 'itemType': QueryDeviceOriginalPropertyDataResponseDataListPropertyInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceOriginalPropertyDataResponseData extends $tea.Model {
  nextValid: boolean;
  nextPageToken: string;
  list: QueryDeviceOriginalPropertyDataResponseDataList;
  static names(): { [key: string]: string } {
    return {
      nextValid: 'NextValid',
      nextPageToken: 'nextPageToken',
      list: 'List',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nextValid: 'boolean',
      nextPageToken: 'string',
      list: QueryDeviceOriginalPropertyDataResponseDataList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceOriginalPropertyStatusResponseDataListPropertyStatusDataInfo extends $tea.Model {
  identifier: string;
  time: number;
  value: string;
  static names(): { [key: string]: string } {
    return {
      identifier: 'Identifier',
      time: 'Time',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      identifier: 'string',
      time: 'number',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceOriginalPropertyStatusResponseDataList extends $tea.Model {
  propertyStatusDataInfo: QueryDeviceOriginalPropertyStatusResponseDataListPropertyStatusDataInfo[];
  static names(): { [key: string]: string } {
    return {
      propertyStatusDataInfo: 'PropertyStatusDataInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      propertyStatusDataInfo: { 'type': 'array', 'itemType': QueryDeviceOriginalPropertyStatusResponseDataListPropertyStatusDataInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceOriginalPropertyStatusResponseData extends $tea.Model {
  nextPageToken: string;
  nextValid: boolean;
  list: QueryDeviceOriginalPropertyStatusResponseDataList;
  static names(): { [key: string]: string } {
    return {
      nextPageToken: 'NextPageToken',
      nextValid: 'NextValid',
      list: 'List',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nextPageToken: 'string',
      nextValid: 'boolean',
      list: QueryDeviceOriginalPropertyStatusResponseDataList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceOriginalServiceDataResponseDataListServiceInfo extends $tea.Model {
  identifier: string;
  inputData: string;
  name: string;
  outputData: string;
  time: string;
  static names(): { [key: string]: string } {
    return {
      identifier: 'Identifier',
      inputData: 'InputData',
      name: 'Name',
      outputData: 'OutputData',
      time: 'Time',
    };
  }

  static types(): { [key: string]: any } {
    return {
      identifier: 'string',
      inputData: 'string',
      name: 'string',
      outputData: 'string',
      time: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceOriginalServiceDataResponseDataList extends $tea.Model {
  serviceInfo: QueryDeviceOriginalServiceDataResponseDataListServiceInfo[];
  static names(): { [key: string]: string } {
    return {
      serviceInfo: 'ServiceInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      serviceInfo: { 'type': 'array', 'itemType': QueryDeviceOriginalServiceDataResponseDataListServiceInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceOriginalServiceDataResponseData extends $tea.Model {
  nextPageToken: string;
  nextValid: boolean;
  list: QueryDeviceOriginalServiceDataResponseDataList;
  static names(): { [key: string]: string } {
    return {
      nextPageToken: 'NextPageToken',
      nextValid: 'NextValid',
      list: 'List',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nextPageToken: 'string',
      nextValid: 'boolean',
      list: QueryDeviceOriginalServiceDataResponseDataList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicePropertiesDataResponsePropertyDataInfosPropertyDataInfoListPropertyInfo extends $tea.Model {
  time: number;
  value: string;
  static names(): { [key: string]: string } {
    return {
      time: 'Time',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      time: 'number',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicePropertiesDataResponsePropertyDataInfosPropertyDataInfoList extends $tea.Model {
  propertyInfo: QueryDevicePropertiesDataResponsePropertyDataInfosPropertyDataInfoListPropertyInfo[];
  static names(): { [key: string]: string } {
    return {
      propertyInfo: 'PropertyInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      propertyInfo: { 'type': 'array', 'itemType': QueryDevicePropertiesDataResponsePropertyDataInfosPropertyDataInfoListPropertyInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicePropertiesDataResponsePropertyDataInfosPropertyDataInfo extends $tea.Model {
  identifier: string;
  list: QueryDevicePropertiesDataResponsePropertyDataInfosPropertyDataInfoList;
  static names(): { [key: string]: string } {
    return {
      identifier: 'Identifier',
      list: 'List',
    };
  }

  static types(): { [key: string]: any } {
    return {
      identifier: 'string',
      list: QueryDevicePropertiesDataResponsePropertyDataInfosPropertyDataInfoList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicePropertiesDataResponsePropertyDataInfos extends $tea.Model {
  propertyDataInfo: QueryDevicePropertiesDataResponsePropertyDataInfosPropertyDataInfo[];
  static names(): { [key: string]: string } {
    return {
      propertyDataInfo: 'PropertyDataInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      propertyDataInfo: { 'type': 'array', 'itemType': QueryDevicePropertiesDataResponsePropertyDataInfosPropertyDataInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicePropertyDataResponseDataListPropertyInfo extends $tea.Model {
  time: string;
  value: string;
  static names(): { [key: string]: string } {
    return {
      time: 'Time',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      time: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicePropertyDataResponseDataList extends $tea.Model {
  propertyInfo: QueryDevicePropertyDataResponseDataListPropertyInfo[];
  static names(): { [key: string]: string } {
    return {
      propertyInfo: 'PropertyInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      propertyInfo: { 'type': 'array', 'itemType': QueryDevicePropertyDataResponseDataListPropertyInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicePropertyDataResponseData extends $tea.Model {
  nextTime: number;
  nextValid: boolean;
  list: QueryDevicePropertyDataResponseDataList;
  static names(): { [key: string]: string } {
    return {
      nextTime: 'NextTime',
      nextValid: 'NextValid',
      list: 'List',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nextTime: 'number',
      nextValid: 'boolean',
      list: QueryDevicePropertyDataResponseDataList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicePropertyStatusResponseDataListPropertyStatusInfo extends $tea.Model {
  dataType: string;
  identifier: string;
  name: string;
  time: string;
  unit: string;
  value: string;
  static names(): { [key: string]: string } {
    return {
      dataType: 'DataType',
      identifier: 'Identifier',
      name: 'Name',
      time: 'Time',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataType: 'string',
      identifier: 'string',
      name: 'string',
      time: 'string',
      unit: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicePropertyStatusResponseDataList extends $tea.Model {
  propertyStatusInfo: QueryDevicePropertyStatusResponseDataListPropertyStatusInfo[];
  static names(): { [key: string]: string } {
    return {
      propertyStatusInfo: 'PropertyStatusInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      propertyStatusInfo: { 'type': 'array', 'itemType': QueryDevicePropertyStatusResponseDataListPropertyStatusInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicePropertyStatusResponseData extends $tea.Model {
  list: QueryDevicePropertyStatusResponseDataList;
  static names(): { [key: string]: string } {
    return {
      list: 'List',
    };
  }

  static types(): { [key: string]: any } {
    return {
      list: QueryDevicePropertyStatusResponseDataList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceServiceDataResponseDataListServiceInfo extends $tea.Model {
  identifier: string;
  inputData: string;
  name: string;
  outputData: string;
  time: string;
  static names(): { [key: string]: string } {
    return {
      identifier: 'Identifier',
      inputData: 'InputData',
      name: 'Name',
      outputData: 'OutputData',
      time: 'Time',
    };
  }

  static types(): { [key: string]: any } {
    return {
      identifier: 'string',
      inputData: 'string',
      name: 'string',
      outputData: 'string',
      time: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceServiceDataResponseDataList extends $tea.Model {
  serviceInfo: QueryDeviceServiceDataResponseDataListServiceInfo[];
  static names(): { [key: string]: string } {
    return {
      serviceInfo: 'ServiceInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      serviceInfo: { 'type': 'array', 'itemType': QueryDeviceServiceDataResponseDataListServiceInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceServiceDataResponseData extends $tea.Model {
  nextTime: number;
  nextValid: boolean;
  list: QueryDeviceServiceDataResponseDataList;
  static names(): { [key: string]: string } {
    return {
      nextTime: 'NextTime',
      nextValid: 'NextValid',
      list: 'List',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nextTime: 'number',
      nextValid: 'boolean',
      list: QueryDeviceServiceDataResponseDataList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceSpeechResponseDataListItems extends $tea.Model {
  audioFormat: string;
  bizCode: string;
  size: number;
  static names(): { [key: string]: string } {
    return {
      audioFormat: 'AudioFormat',
      bizCode: 'BizCode',
      size: 'Size',
    };
  }

  static types(): { [key: string]: any } {
    return {
      audioFormat: 'string',
      bizCode: 'string',
      size: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceSpeechResponseDataList extends $tea.Model {
  items: QueryDeviceSpeechResponseDataListItems[];
  static names(): { [key: string]: string } {
    return {
      items: 'Items',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: { 'type': 'array', 'itemType': QueryDeviceSpeechResponseDataListItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceSpeechResponseData extends $tea.Model {
  pageId: number;
  pageSize: number;
  total: number;
  list: QueryDeviceSpeechResponseDataList;
  static names(): { [key: string]: string } {
    return {
      pageId: 'PageId',
      pageSize: 'PageSize',
      total: 'Total',
      list: 'List',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageId: 'number',
      pageSize: 'number',
      total: 'number',
      list: QueryDeviceSpeechResponseDataList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceStatisticsResponseData extends $tea.Model {
  activeCount: number;
  deviceCount: number;
  onlineCount: number;
  static names(): { [key: string]: string } {
    return {
      activeCount: 'activeCount',
      deviceCount: 'deviceCount',
      onlineCount: 'onlineCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      activeCount: 'number',
      deviceCount: 'number',
      onlineCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceSubTopicResponseTopicList extends $tea.Model {
  timestamp: number;
  topicName: string;
  static names(): { [key: string]: string } {
    return {
      timestamp: 'Timestamp',
      topicName: 'TopicName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      timestamp: 'number',
      topicName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceTunnelResponseData extends $tea.Model {
  description: string;
  deviceConnState: string;
  deviceName: string;
  iotId: string;
  productKey: string;
  productName: string;
  sourceConnState: string;
  tunnelId: string;
  tunnelState: string;
  udi: string;
  utcClosed: string;
  utcCreated: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      deviceConnState: 'DeviceConnState',
      deviceName: 'DeviceName',
      iotId: 'IotId',
      productKey: 'ProductKey',
      productName: 'ProductName',
      sourceConnState: 'SourceConnState',
      tunnelId: 'TunnelId',
      tunnelState: 'TunnelState',
      udi: 'Udi',
      utcClosed: 'UtcClosed',
      utcCreated: 'UtcCreated',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      deviceConnState: 'string',
      deviceName: 'string',
      iotId: 'string',
      productKey: 'string',
      productName: 'string',
      sourceConnState: 'string',
      tunnelId: 'string',
      tunnelState: 'string',
      udi: 'string',
      utcClosed: 'string',
      utcCreated: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicesHotStorageDataResponseDataListPropertyInfo extends $tea.Model {
  time: string;
  value: string;
  static names(): { [key: string]: string } {
    return {
      time: 'Time',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      time: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicesHotStorageDataResponseDataList extends $tea.Model {
  propertyInfo: QueryDevicesHotStorageDataResponseDataListPropertyInfo[];
  static names(): { [key: string]: string } {
    return {
      propertyInfo: 'PropertyInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      propertyInfo: { 'type': 'array', 'itemType': QueryDevicesHotStorageDataResponseDataListPropertyInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicesHotStorageDataResponseData extends $tea.Model {
  nextValid: boolean;
  nextPageToken: string;
  list: QueryDevicesHotStorageDataResponseDataList;
  static names(): { [key: string]: string } {
    return {
      nextValid: 'NextValid',
      nextPageToken: 'nextPageToken',
      list: 'List',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nextValid: 'boolean',
      nextPageToken: 'string',
      list: QueryDevicesHotStorageDataResponseDataList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicesHotStorageDataStatusResponseDataListPropertyStatusDataInfo extends $tea.Model {
  identifier: string;
  time: number;
  value: string;
  static names(): { [key: string]: string } {
    return {
      identifier: 'Identifier',
      time: 'Time',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      identifier: 'string',
      time: 'number',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicesHotStorageDataStatusResponseDataList extends $tea.Model {
  propertyStatusDataInfo: QueryDevicesHotStorageDataStatusResponseDataListPropertyStatusDataInfo[];
  static names(): { [key: string]: string } {
    return {
      propertyStatusDataInfo: 'PropertyStatusDataInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      propertyStatusDataInfo: { 'type': 'array', 'itemType': QueryDevicesHotStorageDataStatusResponseDataListPropertyStatusDataInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicesHotStorageDataStatusResponseData extends $tea.Model {
  nextPageToken: string;
  nextValid: boolean;
  list: QueryDevicesHotStorageDataStatusResponseDataList;
  static names(): { [key: string]: string } {
    return {
      nextPageToken: 'NextPageToken',
      nextValid: 'NextValid',
      list: 'List',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nextPageToken: 'string',
      nextValid: 'boolean',
      list: QueryDevicesHotStorageDataStatusResponseDataList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDynamicGroupDevicesResponseDataSimpleDeviceInfo extends $tea.Model {
  activeTime: string;
  categoryKey: string;
  deviceName: string;
  iotId: string;
  lastOnlineTime: string;
  nickname: string;
  nodeType: number;
  productKey: string;
  productName: string;
  status: string;
  utcActiveTime: string;
  utcLastOnlineTime: string;
  static names(): { [key: string]: string } {
    return {
      activeTime: 'ActiveTime',
      categoryKey: 'CategoryKey',
      deviceName: 'DeviceName',
      iotId: 'IotId',
      lastOnlineTime: 'LastOnlineTime',
      nickname: 'Nickname',
      nodeType: 'NodeType',
      productKey: 'ProductKey',
      productName: 'ProductName',
      status: 'Status',
      utcActiveTime: 'UtcActiveTime',
      utcLastOnlineTime: 'UtcLastOnlineTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      activeTime: 'string',
      categoryKey: 'string',
      deviceName: 'string',
      iotId: 'string',
      lastOnlineTime: 'string',
      nickname: 'string',
      nodeType: 'number',
      productKey: 'string',
      productName: 'string',
      status: 'string',
      utcActiveTime: 'string',
      utcLastOnlineTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDynamicGroupDevicesResponseData extends $tea.Model {
  simpleDeviceInfo: QueryDynamicGroupDevicesResponseDataSimpleDeviceInfo[];
  static names(): { [key: string]: string } {
    return {
      simpleDeviceInfo: 'SimpleDeviceInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      simpleDeviceInfo: { 'type': 'array', 'itemType': QueryDynamicGroupDevicesResponseDataSimpleDeviceInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeDriverResponseDataDriverList extends $tea.Model {
  cpuArch: string;
  driverId: string;
  driverName: string;
  driverProtocol: string;
  gmtCreateTimestamp: number;
  gmtModifiedTimestamp: number;
  isApply: boolean;
  isBuiltIn: boolean;
  runtime: string;
  type: number;
  static names(): { [key: string]: string } {
    return {
      cpuArch: 'CpuArch',
      driverId: 'DriverId',
      driverName: 'DriverName',
      driverProtocol: 'DriverProtocol',
      gmtCreateTimestamp: 'GmtCreateTimestamp',
      gmtModifiedTimestamp: 'GmtModifiedTimestamp',
      isApply: 'IsApply',
      isBuiltIn: 'IsBuiltIn',
      runtime: 'Runtime',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cpuArch: 'string',
      driverId: 'string',
      driverName: 'string',
      driverProtocol: 'string',
      gmtCreateTimestamp: 'number',
      gmtModifiedTimestamp: 'number',
      isApply: 'boolean',
      isBuiltIn: 'boolean',
      runtime: 'string',
      type: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeDriverResponseData extends $tea.Model {
  currentPage: number;
  pageSize: number;
  total: number;
  driverList: QueryEdgeDriverResponseDataDriverList[];
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      total: 'Total',
      driverList: 'DriverList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      pageSize: 'number',
      total: 'number',
      driverList: { 'type': 'array', 'itemType': QueryEdgeDriverResponseDataDriverList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeDriverVersionResponseDataDriverVersionList extends $tea.Model {
  argument: string;
  configCheckRule: string;
  containerConfig: string;
  description: string;
  driverConfig: string;
  driverId: string;
  driverVersion: string;
  edgeVersion: string;
  gmtCreateTimestamp: number;
  gmtModifiedTimestamp: number;
  sourceConfig: string;
  versionState: string;
  static names(): { [key: string]: string } {
    return {
      argument: 'Argument',
      configCheckRule: 'ConfigCheckRule',
      containerConfig: 'ContainerConfig',
      description: 'Description',
      driverConfig: 'DriverConfig',
      driverId: 'DriverId',
      driverVersion: 'DriverVersion',
      edgeVersion: 'EdgeVersion',
      gmtCreateTimestamp: 'GmtCreateTimestamp',
      gmtModifiedTimestamp: 'GmtModifiedTimestamp',
      sourceConfig: 'SourceConfig',
      versionState: 'VersionState',
    };
  }

  static types(): { [key: string]: any } {
    return {
      argument: 'string',
      configCheckRule: 'string',
      containerConfig: 'string',
      description: 'string',
      driverConfig: 'string',
      driverId: 'string',
      driverVersion: 'string',
      edgeVersion: 'string',
      gmtCreateTimestamp: 'number',
      gmtModifiedTimestamp: 'number',
      sourceConfig: 'string',
      versionState: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeDriverVersionResponseData extends $tea.Model {
  currentPage: number;
  pageSize: number;
  total: number;
  driverVersionList: QueryEdgeDriverVersionResponseDataDriverVersionList[];
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      total: 'Total',
      driverVersionList: 'DriverVersionList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      pageSize: 'number',
      total: 'number',
      driverVersionList: { 'type': 'array', 'itemType': QueryEdgeDriverVersionResponseDataDriverVersionList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceResponseDataInstanceList extends $tea.Model {
  bizEnable: boolean;
  gmtCreate: string;
  gmtCreateTimestamp: number;
  gmtModified: string;
  gmtModifiedTimestamp: number;
  instanceId: string;
  latestDeploymentStatus: number;
  latestDeploymentType: string;
  name: string;
  roleArn: string;
  roleAttachTime: string;
  roleAttachTimestamp: number;
  roleName: string;
  spec: number;
  tags: string;
  type: number;
  static names(): { [key: string]: string } {
    return {
      bizEnable: 'BizEnable',
      gmtCreate: 'GmtCreate',
      gmtCreateTimestamp: 'GmtCreateTimestamp',
      gmtModified: 'GmtModified',
      gmtModifiedTimestamp: 'GmtModifiedTimestamp',
      instanceId: 'InstanceId',
      latestDeploymentStatus: 'LatestDeploymentStatus',
      latestDeploymentType: 'LatestDeploymentType',
      name: 'Name',
      roleArn: 'RoleArn',
      roleAttachTime: 'RoleAttachTime',
      roleAttachTimestamp: 'RoleAttachTimestamp',
      roleName: 'RoleName',
      spec: 'Spec',
      tags: 'Tags',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizEnable: 'boolean',
      gmtCreate: 'string',
      gmtCreateTimestamp: 'number',
      gmtModified: 'string',
      gmtModifiedTimestamp: 'number',
      instanceId: 'string',
      latestDeploymentStatus: 'number',
      latestDeploymentType: 'string',
      name: 'string',
      roleArn: 'string',
      roleAttachTime: 'string',
      roleAttachTimestamp: 'number',
      roleName: 'string',
      spec: 'number',
      tags: 'string',
      type: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceResponseData extends $tea.Model {
  currentPage: number;
  pageSize: number;
  total: number;
  instanceList: QueryEdgeInstanceResponseDataInstanceList[];
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      total: 'Total',
      instanceList: 'InstanceList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      pageSize: 'number',
      total: 'number',
      instanceList: { 'type': 'array', 'itemType': QueryEdgeInstanceResponseDataInstanceList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceChannelResponseDataChannelListChannelConfigListConfig extends $tea.Model {
  configId: string;
  content: string;
  format: string;
  key: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      content: 'Content',
      format: 'Format',
      key: 'Key',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'string',
      content: 'string',
      format: 'string',
      key: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceChannelResponseDataChannelListChannelConfigList extends $tea.Model {
  config: QueryEdgeInstanceChannelResponseDataChannelListChannelConfigListConfig[];
  static names(): { [key: string]: string } {
    return {
      config: 'Config',
    };
  }

  static types(): { [key: string]: any } {
    return {
      config: { 'type': 'array', 'itemType': QueryEdgeInstanceChannelResponseDataChannelListChannelConfigListConfig },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceChannelResponseDataChannelListChannel extends $tea.Model {
  channelId: string;
  channelName: string;
  gmtCreate: string;
  gmtCreateTimestamp: number;
  gmtModified: string;
  gmtModifiedTimestamp: number;
  configList: QueryEdgeInstanceChannelResponseDataChannelListChannelConfigList;
  static names(): { [key: string]: string } {
    return {
      channelId: 'ChannelId',
      channelName: 'ChannelName',
      gmtCreate: 'GmtCreate',
      gmtCreateTimestamp: 'GmtCreateTimestamp',
      gmtModified: 'GmtModified',
      gmtModifiedTimestamp: 'GmtModifiedTimestamp',
      configList: 'ConfigList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelId: 'string',
      channelName: 'string',
      gmtCreate: 'string',
      gmtCreateTimestamp: 'number',
      gmtModified: 'string',
      gmtModifiedTimestamp: 'number',
      configList: QueryEdgeInstanceChannelResponseDataChannelListChannelConfigList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceChannelResponseDataChannelList extends $tea.Model {
  channel: QueryEdgeInstanceChannelResponseDataChannelListChannel[];
  static names(): { [key: string]: string } {
    return {
      channel: 'Channel',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channel: { 'type': 'array', 'itemType': QueryEdgeInstanceChannelResponseDataChannelListChannel },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceChannelResponseData extends $tea.Model {
  currentPage: number;
  pageSize: number;
  total: number;
  channelList: QueryEdgeInstanceChannelResponseDataChannelList;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      total: 'Total',
      channelList: 'ChannelList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      pageSize: 'number',
      total: 'number',
      channelList: QueryEdgeInstanceChannelResponseDataChannelList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceDeviceResponseDataDeviceList extends $tea.Model {
  deviceName: string;
  driverId: string;
  iotId: string;
  productKey: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      driverId: 'DriverId',
      iotId: 'IotId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      driverId: 'string',
      iotId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceDeviceResponseData extends $tea.Model {
  currentPage: number;
  pageSize: number;
  total: number;
  deviceList: QueryEdgeInstanceDeviceResponseDataDeviceList[];
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      total: 'Total',
      deviceList: 'DeviceList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      pageSize: 'number',
      total: 'number',
      deviceList: { 'type': 'array', 'itemType': QueryEdgeInstanceDeviceResponseDataDeviceList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceDeviceByDriverResponseDataDeviceList extends $tea.Model {
  iotId: string;
  static names(): { [key: string]: string } {
    return {
      iotId: 'IotId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceDeviceByDriverResponseData extends $tea.Model {
  currentPage: number;
  pageSize: number;
  total: number;
  deviceList: QueryEdgeInstanceDeviceByDriverResponseDataDeviceList[];
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      total: 'Total',
      deviceList: 'DeviceList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      pageSize: 'number',
      total: 'number',
      deviceList: { 'type': 'array', 'itemType': QueryEdgeInstanceDeviceByDriverResponseDataDeviceList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceDriverResponseDataDriverList extends $tea.Model {
  driverId: string;
  driverVersion: string;
  gmtCreate: string;
  gmtModified: string;
  orderId: string;
  static names(): { [key: string]: string } {
    return {
      driverId: 'DriverId',
      driverVersion: 'DriverVersion',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      orderId: 'OrderId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      driverId: 'string',
      driverVersion: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      orderId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceDriverResponseData extends $tea.Model {
  currentPage: number;
  pageSize: number;
  total: number;
  driverList: QueryEdgeInstanceDriverResponseDataDriverList[];
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      total: 'Total',
      driverList: 'DriverList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      pageSize: 'number',
      total: 'number',
      driverList: { 'type': 'array', 'itemType': QueryEdgeInstanceDriverResponseDataDriverList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceGatewayResponseGatewayList extends $tea.Model {
  deviceName: string;
  edgeVersion: string;
  iotId: string;
  productKey: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      edgeVersion: 'EdgeVersion',
      iotId: 'IotId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      edgeVersion: 'string',
      iotId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceHistoricDeploymentResponseDataDeploymentList extends $tea.Model {
  deploymentId: string;
  description: string;
  gmtCompleted: string;
  gmtCompletedTimestamp: number;
  gmtCreate: string;
  gmtCreateTimestamp: number;
  gmtModified: string;
  gmtModifiedTimestamp: number;
  status: number;
  type: string;
  static names(): { [key: string]: string } {
    return {
      deploymentId: 'DeploymentId',
      description: 'Description',
      gmtCompleted: 'GmtCompleted',
      gmtCompletedTimestamp: 'GmtCompletedTimestamp',
      gmtCreate: 'GmtCreate',
      gmtCreateTimestamp: 'GmtCreateTimestamp',
      gmtModified: 'GmtModified',
      gmtModifiedTimestamp: 'GmtModifiedTimestamp',
      status: 'Status',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deploymentId: 'string',
      description: 'string',
      gmtCompleted: 'string',
      gmtCompletedTimestamp: 'number',
      gmtCreate: 'string',
      gmtCreateTimestamp: 'number',
      gmtModified: 'string',
      gmtModifiedTimestamp: 'number',
      status: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceHistoricDeploymentResponseData extends $tea.Model {
  currentPage: number;
  pageSize: number;
  total: number;
  deploymentList: QueryEdgeInstanceHistoricDeploymentResponseDataDeploymentList[];
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      total: 'Total',
      deploymentList: 'DeploymentList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      pageSize: 'number',
      total: 'number',
      deploymentList: { 'type': 'array', 'itemType': QueryEdgeInstanceHistoricDeploymentResponseDataDeploymentList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceMessageRoutingResponseDataMessageRouteListMessageRouteRouteContext extends $tea.Model {
  qos: string;
  sourceApplicationName: string;
  sourceFcFunctionName: string;
  sourceFcServiceName: string;
  targetApplicationName: string;
  targetFcFunctionName: string;
  targetFcServiceName: string;
  static names(): { [key: string]: string } {
    return {
      qos: 'Qos',
      sourceApplicationName: 'SourceApplicationName',
      sourceFcFunctionName: 'SourceFcFunctionName',
      sourceFcServiceName: 'SourceFcServiceName',
      targetApplicationName: 'TargetApplicationName',
      targetFcFunctionName: 'TargetFcFunctionName',
      targetFcServiceName: 'TargetFcServiceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      qos: 'string',
      sourceApplicationName: 'string',
      sourceFcFunctionName: 'string',
      sourceFcServiceName: 'string',
      targetApplicationName: 'string',
      targetFcFunctionName: 'string',
      targetFcServiceName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceMessageRoutingResponseDataMessageRouteListMessageRoute extends $tea.Model {
  gmtCreate: string;
  gmtCreateTimestamp: number;
  gmtModified: string;
  gmtModifiedTimestamp: number;
  name: string;
  routeId: number;
  sourceData: string;
  sourceType: string;
  targetData: string;
  targetType: string;
  topicFilter: string;
  routeContext: QueryEdgeInstanceMessageRoutingResponseDataMessageRouteListMessageRouteRouteContext;
  static names(): { [key: string]: string } {
    return {
      gmtCreate: 'GmtCreate',
      gmtCreateTimestamp: 'GmtCreateTimestamp',
      gmtModified: 'GmtModified',
      gmtModifiedTimestamp: 'GmtModifiedTimestamp',
      name: 'Name',
      routeId: 'RouteId',
      sourceData: 'SourceData',
      sourceType: 'SourceType',
      targetData: 'TargetData',
      targetType: 'TargetType',
      topicFilter: 'TopicFilter',
      routeContext: 'RouteContext',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gmtCreate: 'string',
      gmtCreateTimestamp: 'number',
      gmtModified: 'string',
      gmtModifiedTimestamp: 'number',
      name: 'string',
      routeId: 'number',
      sourceData: 'string',
      sourceType: 'string',
      targetData: 'string',
      targetType: 'string',
      topicFilter: 'string',
      routeContext: QueryEdgeInstanceMessageRoutingResponseDataMessageRouteListMessageRouteRouteContext,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceMessageRoutingResponseDataMessageRouteList extends $tea.Model {
  messageRoute: QueryEdgeInstanceMessageRoutingResponseDataMessageRouteListMessageRoute[];
  static names(): { [key: string]: string } {
    return {
      messageRoute: 'MessageRoute',
    };
  }

  static types(): { [key: string]: any } {
    return {
      messageRoute: { 'type': 'array', 'itemType': QueryEdgeInstanceMessageRoutingResponseDataMessageRouteListMessageRoute },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceMessageRoutingResponseData extends $tea.Model {
  currentPage: number;
  pageSize: number;
  total: number;
  messageRouteList: QueryEdgeInstanceMessageRoutingResponseDataMessageRouteList;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      total: 'Total',
      messageRouteList: 'MessageRouteList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      pageSize: 'number',
      total: 'number',
      messageRouteList: QueryEdgeInstanceMessageRoutingResponseDataMessageRouteList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceSceneRuleResponseDataRuleList extends $tea.Model {
  gmtCreate: number;
  isExisted: number;
  ruleId: string;
  ruleName: string;
  status: number;
  static names(): { [key: string]: string } {
    return {
      gmtCreate: 'GmtCreate',
      isExisted: 'IsExisted',
      ruleId: 'RuleId',
      ruleName: 'RuleName',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gmtCreate: 'number',
      isExisted: 'number',
      ruleId: 'string',
      ruleName: 'string',
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceSceneRuleResponseData extends $tea.Model {
  currentPage: number;
  pageSize: number;
  total: number;
  ruleList: QueryEdgeInstanceSceneRuleResponseDataRuleList[];
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      total: 'Total',
      ruleList: 'RuleList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      pageSize: 'number',
      total: 'number',
      ruleList: { 'type': 'array', 'itemType': QueryEdgeInstanceSceneRuleResponseDataRuleList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryImportedDeviceByApplyIdResponseDeviceListDevice extends $tea.Model {
  deviceName: string;
  deviceSecret: string;
  productKey: string;
  sn: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      deviceSecret: 'DeviceSecret',
      productKey: 'ProductKey',
      sn: 'Sn',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      deviceSecret: 'string',
      productKey: 'string',
      sn: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryImportedDeviceByApplyIdResponseDeviceList extends $tea.Model {
  device: QueryImportedDeviceByApplyIdResponseDeviceListDevice[];
  static names(): { [key: string]: string } {
    return {
      device: 'device',
    };
  }

  static types(): { [key: string]: any } {
    return {
      device: { 'type': 'array', 'itemType': QueryImportedDeviceByApplyIdResponseDeviceListDevice },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobResponseDataJobFile extends $tea.Model {
  fileUrl: string;
  sign: string;
  signMethod: string;
  static names(): { [key: string]: string } {
    return {
      fileUrl: 'FileUrl',
      sign: 'Sign',
      signMethod: 'SignMethod',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fileUrl: 'string',
      sign: 'string',
      signMethod: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobResponseDataRolloutConfig extends $tea.Model {
  maximumPerMinute: number;
  messageQoS: string;
  static names(): { [key: string]: string } {
    return {
      maximumPerMinute: 'MaximumPerMinute',
      messageQoS: 'MessageQoS',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maximumPerMinute: 'number',
      messageQoS: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobResponseDataTargetConfigTargetDevicesTargetDevices extends $tea.Model {
  deviceName: string;
  productKey: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobResponseDataTargetConfigTargetDevices extends $tea.Model {
  targetDevices: QueryJobResponseDataTargetConfigTargetDevicesTargetDevices[];
  static names(): { [key: string]: string } {
    return {
      targetDevices: 'targetDevices',
    };
  }

  static types(): { [key: string]: any } {
    return {
      targetDevices: { 'type': 'array', 'itemType': QueryJobResponseDataTargetConfigTargetDevicesTargetDevices },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobResponseDataTargetConfig extends $tea.Model {
  targetGroup: string;
  targetProduct: string;
  targetType: string;
  targetDevices: QueryJobResponseDataTargetConfigTargetDevices;
  static names(): { [key: string]: string } {
    return {
      targetGroup: 'TargetGroup',
      targetProduct: 'TargetProduct',
      targetType: 'TargetType',
      targetDevices: 'TargetDevices',
    };
  }

  static types(): { [key: string]: any } {
    return {
      targetGroup: 'string',
      targetProduct: 'string',
      targetType: 'string',
      targetDevices: QueryJobResponseDataTargetConfigTargetDevices,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobResponseDataTimeoutConfig extends $tea.Model {
  inProgressTimeoutInMinutes: number;
  static names(): { [key: string]: string } {
    return {
      inProgressTimeoutInMinutes: 'InProgressTimeoutInMinutes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      inProgressTimeoutInMinutes: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobResponseData extends $tea.Model {
  description: string;
  jobDocument: string;
  jobId: string;
  jobName: string;
  scheduledTime: number;
  status: string;
  type: string;
  utcCreate: string;
  utcModified: string;
  jobFile: QueryJobResponseDataJobFile;
  rolloutConfig: QueryJobResponseDataRolloutConfig;
  targetConfig: QueryJobResponseDataTargetConfig;
  timeoutConfig: QueryJobResponseDataTimeoutConfig;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      jobDocument: 'JobDocument',
      jobId: 'JobId',
      jobName: 'JobName',
      scheduledTime: 'ScheduledTime',
      status: 'Status',
      type: 'Type',
      utcCreate: 'UtcCreate',
      utcModified: 'UtcModified',
      jobFile: 'JobFile',
      rolloutConfig: 'RolloutConfig',
      targetConfig: 'TargetConfig',
      timeoutConfig: 'TimeoutConfig',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      jobDocument: 'string',
      jobId: 'string',
      jobName: 'string',
      scheduledTime: 'number',
      status: 'string',
      type: 'string',
      utcCreate: 'string',
      utcModified: 'string',
      jobFile: QueryJobResponseDataJobFile,
      rolloutConfig: QueryJobResponseDataRolloutConfig,
      targetConfig: QueryJobResponseDataTargetConfig,
      timeoutConfig: QueryJobResponseDataTimeoutConfig,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobStatisticsResponseData extends $tea.Model {
  cancelled: number;
  failed: number;
  inProgress: number;
  queued: number;
  rejected: number;
  sent: number;
  succeeded: number;
  timeOut: number;
  total: number;
  static names(): { [key: string]: string } {
    return {
      cancelled: 'Cancelled',
      failed: 'Failed',
      inProgress: 'InProgress',
      queued: 'Queued',
      rejected: 'Rejected',
      sent: 'Sent',
      succeeded: 'Succeeded',
      timeOut: 'TimeOut',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cancelled: 'number',
      failed: 'number',
      inProgress: 'number',
      queued: 'number',
      rejected: 'number',
      sent: 'number',
      succeeded: 'number',
      timeOut: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryLicenseDeviceListResponseDataDeviceListItem extends $tea.Model {
  deviceName: string;
  expiryTime: number;
  gmtCreate: number;
  iotId: string;
  licenseCode: string;
  productKey: string;
  productName: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      expiryTime: 'ExpiryTime',
      gmtCreate: 'GmtCreate',
      iotId: 'IotId',
      licenseCode: 'LicenseCode',
      productKey: 'ProductKey',
      productName: 'ProductName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      expiryTime: 'number',
      gmtCreate: 'number',
      iotId: 'string',
      licenseCode: 'string',
      productKey: 'string',
      productName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryLicenseDeviceListResponseDataDeviceList extends $tea.Model {
  item: QueryLicenseDeviceListResponseDataDeviceListItem[];
  static names(): { [key: string]: string } {
    return {
      item: 'item',
    };
  }

  static types(): { [key: string]: any } {
    return {
      item: { 'type': 'array', 'itemType': QueryLicenseDeviceListResponseDataDeviceListItem },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryLicenseDeviceListResponseData extends $tea.Model {
  pageId: number;
  pageSize: number;
  total: number;
  deviceList: QueryLicenseDeviceListResponseDataDeviceList;
  static names(): { [key: string]: string } {
    return {
      pageId: 'PageId',
      pageSize: 'PageSize',
      total: 'Total',
      deviceList: 'DeviceList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageId: 'number',
      pageSize: 'number',
      total: 'number',
      deviceList: QueryLicenseDeviceListResponseDataDeviceList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryLoRaJoinPermissionsResponseJoinPermissionsJoinPermission extends $tea.Model {
  classMode: string;
  enabled: boolean;
  joinPermissionId: string;
  joinPermissionName: string;
  joinPermissionType: string;
  ownerAliyunPk: string;
  static names(): { [key: string]: string } {
    return {
      classMode: 'ClassMode',
      enabled: 'Enabled',
      joinPermissionId: 'JoinPermissionId',
      joinPermissionName: 'JoinPermissionName',
      joinPermissionType: 'JoinPermissionType',
      ownerAliyunPk: 'OwnerAliyunPk',
    };
  }

  static types(): { [key: string]: any } {
    return {
      classMode: 'string',
      enabled: 'boolean',
      joinPermissionId: 'string',
      joinPermissionName: 'string',
      joinPermissionType: 'string',
      ownerAliyunPk: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryLoRaJoinPermissionsResponseJoinPermissions extends $tea.Model {
  joinPermission: QueryLoRaJoinPermissionsResponseJoinPermissionsJoinPermission[];
  static names(): { [key: string]: string } {
    return {
      joinPermission: 'JoinPermission',
    };
  }

  static types(): { [key: string]: any } {
    return {
      joinPermission: { 'type': 'array', 'itemType': QueryLoRaJoinPermissionsResponseJoinPermissionsJoinPermission },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMessageInfoResponseMessageUserProperties extends $tea.Model {
  key: string;
  value: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMessageInfoResponseMessage extends $tea.Model {
  generateTime: number;
  messageContent: string;
  topicFullName: string;
  uniMsgId: string;
  userProperties: QueryMessageInfoResponseMessageUserProperties[];
  static names(): { [key: string]: string } {
    return {
      generateTime: 'GenerateTime',
      messageContent: 'MessageContent',
      topicFullName: 'TopicFullName',
      uniMsgId: 'UniMsgId',
      userProperties: 'UserProperties',
    };
  }

  static types(): { [key: string]: any } {
    return {
      generateTime: 'number',
      messageContent: 'string',
      topicFullName: 'string',
      uniMsgId: 'string',
      userProperties: { 'type': 'array', 'itemType': QueryMessageInfoResponseMessageUserProperties },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryOTAFirmwareResponseFirmwareInfoMultiFiles extends $tea.Model {
  fileMd5: string;
  name: string;
  signValue: string;
  size: number;
  url: string;
  static names(): { [key: string]: string } {
    return {
      fileMd5: 'FileMd5',
      name: 'Name',
      signValue: 'SignValue',
      size: 'Size',
      url: 'Url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fileMd5: 'string',
      name: 'string',
      signValue: 'string',
      size: 'number',
      url: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryOTAFirmwareResponseFirmwareInfo extends $tea.Model {
  destVersion: string;
  firmwareDesc: string;
  firmwareId: string;
  firmwareName: string;
  firmwareSign: string;
  firmwareSize: number;
  firmwareUrl: string;
  moduleName: string;
  productKey: string;
  productName: string;
  signMethod: string;
  srcVersion: string;
  status: number;
  type: number;
  udi: string;
  utcCreate: string;
  utcModified: string;
  verifyProgress: number;
  multiFiles: QueryOTAFirmwareResponseFirmwareInfoMultiFiles[];
  static names(): { [key: string]: string } {
    return {
      destVersion: 'DestVersion',
      firmwareDesc: 'FirmwareDesc',
      firmwareId: 'FirmwareId',
      firmwareName: 'FirmwareName',
      firmwareSign: 'FirmwareSign',
      firmwareSize: 'FirmwareSize',
      firmwareUrl: 'FirmwareUrl',
      moduleName: 'ModuleName',
      productKey: 'ProductKey',
      productName: 'ProductName',
      signMethod: 'SignMethod',
      srcVersion: 'SrcVersion',
      status: 'Status',
      type: 'Type',
      udi: 'Udi',
      utcCreate: 'UtcCreate',
      utcModified: 'UtcModified',
      verifyProgress: 'VerifyProgress',
      multiFiles: 'MultiFiles',
    };
  }

  static types(): { [key: string]: any } {
    return {
      destVersion: 'string',
      firmwareDesc: 'string',
      firmwareId: 'string',
      firmwareName: 'string',
      firmwareSign: 'string',
      firmwareSize: 'number',
      firmwareUrl: 'string',
      moduleName: 'string',
      productKey: 'string',
      productName: 'string',
      signMethod: 'string',
      srcVersion: 'string',
      status: 'number',
      type: 'number',
      udi: 'string',
      utcCreate: 'string',
      utcModified: 'string',
      verifyProgress: 'number',
      multiFiles: { 'type': 'array', 'itemType': QueryOTAFirmwareResponseFirmwareInfoMultiFiles },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryOTAJobResponseDataTagsOtaTagDTO extends $tea.Model {
  key: string;
  value: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryOTAJobResponseDataTags extends $tea.Model {
  otaTagDTO: QueryOTAJobResponseDataTagsOtaTagDTO[];
  static names(): { [key: string]: string } {
    return {
      otaTagDTO: 'OtaTagDTO',
    };
  }

  static types(): { [key: string]: any } {
    return {
      otaTagDTO: { 'type': 'array', 'itemType': QueryOTAJobResponseDataTagsOtaTagDTO },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryOTAJobResponseDataSrcVersions extends $tea.Model {
  srcVersion: string[];
  static names(): { [key: string]: string } {
    return {
      srcVersion: 'SrcVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      srcVersion: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryOTAJobResponseData extends $tea.Model {
  destVersion: string;
  downloadProtocol: string;
  dynamicMode: number;
  firmwareId: string;
  grayPercent: string;
  groupId: string;
  groupName: string;
  jobDesc: string;
  jobId: string;
  jobStatus: string;
  jobType: string;
  maximumPerMinute: number;
  multiModuleMode: boolean;
  name: string;
  needConfirm: boolean;
  needPush: boolean;
  overwriteMode: number;
  productKey: string;
  retryCount: number;
  retryInterval: number;
  selectionType: string;
  targetSelection: string;
  timeoutInMinutes: number;
  utcCreate: string;
  utcEndTime: string;
  utcModified: string;
  utcScheduleFinishTime: string;
  utcScheduleTime: string;
  utcStartTime: string;
  tags: QueryOTAJobResponseDataTags;
  srcVersions: QueryOTAJobResponseDataSrcVersions;
  static names(): { [key: string]: string } {
    return {
      destVersion: 'DestVersion',
      downloadProtocol: 'DownloadProtocol',
      dynamicMode: 'DynamicMode',
      firmwareId: 'FirmwareId',
      grayPercent: 'GrayPercent',
      groupId: 'GroupId',
      groupName: 'GroupName',
      jobDesc: 'JobDesc',
      jobId: 'JobId',
      jobStatus: 'JobStatus',
      jobType: 'JobType',
      maximumPerMinute: 'MaximumPerMinute',
      multiModuleMode: 'MultiModuleMode',
      name: 'Name',
      needConfirm: 'NeedConfirm',
      needPush: 'NeedPush',
      overwriteMode: 'OverwriteMode',
      productKey: 'ProductKey',
      retryCount: 'RetryCount',
      retryInterval: 'RetryInterval',
      selectionType: 'SelectionType',
      targetSelection: 'TargetSelection',
      timeoutInMinutes: 'TimeoutInMinutes',
      utcCreate: 'UtcCreate',
      utcEndTime: 'UtcEndTime',
      utcModified: 'UtcModified',
      utcScheduleFinishTime: 'UtcScheduleFinishTime',
      utcScheduleTime: 'UtcScheduleTime',
      utcStartTime: 'UtcStartTime',
      tags: 'Tags',
      srcVersions: 'SrcVersions',
    };
  }

  static types(): { [key: string]: any } {
    return {
      destVersion: 'string',
      downloadProtocol: 'string',
      dynamicMode: 'number',
      firmwareId: 'string',
      grayPercent: 'string',
      groupId: 'string',
      groupName: 'string',
      jobDesc: 'string',
      jobId: 'string',
      jobStatus: 'string',
      jobType: 'string',
      maximumPerMinute: 'number',
      multiModuleMode: 'boolean',
      name: 'string',
      needConfirm: 'boolean',
      needPush: 'boolean',
      overwriteMode: 'number',
      productKey: 'string',
      retryCount: 'number',
      retryInterval: 'number',
      selectionType: 'string',
      targetSelection: 'string',
      timeoutInMinutes: 'number',
      utcCreate: 'string',
      utcEndTime: 'string',
      utcModified: 'string',
      utcScheduleFinishTime: 'string',
      utcScheduleTime: 'string',
      utcStartTime: 'string',
      tags: QueryOTAJobResponseDataTags,
      srcVersions: QueryOTAJobResponseDataSrcVersions,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryPageByApplyIdResponseApplyDeviceListApplyDeviceInfo extends $tea.Model {
  deviceId: string;
  deviceName: string;
  deviceSecret: string;
  iotId: string;
  static names(): { [key: string]: string } {
    return {
      deviceId: 'DeviceId',
      deviceName: 'DeviceName',
      deviceSecret: 'DeviceSecret',
      iotId: 'IotId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceId: 'string',
      deviceName: 'string',
      deviceSecret: 'string',
      iotId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryPageByApplyIdResponseApplyDeviceList extends $tea.Model {
  applyDeviceInfo: QueryPageByApplyIdResponseApplyDeviceListApplyDeviceInfo[];
  static names(): { [key: string]: string } {
    return {
      applyDeviceInfo: 'ApplyDeviceInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applyDeviceInfo: { 'type': 'array', 'itemType': QueryPageByApplyIdResponseApplyDeviceListApplyDeviceInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryProductResponseData extends $tea.Model {
  aliyunCommodityCode: string;
  authType: string;
  categoryKey: string;
  categoryName: string;
  dataFormat: number;
  description: string;
  deviceCount: number;
  gmtCreate: number;
  id2: boolean;
  netType: number;
  nodeType: number;
  owner: boolean;
  productKey: string;
  productName: string;
  productSecret: string;
  productStatus: string;
  protocolType: string;
  validateType: number;
  static names(): { [key: string]: string } {
    return {
      aliyunCommodityCode: 'AliyunCommodityCode',
      authType: 'AuthType',
      categoryKey: 'CategoryKey',
      categoryName: 'CategoryName',
      dataFormat: 'DataFormat',
      description: 'Description',
      deviceCount: 'DeviceCount',
      gmtCreate: 'GmtCreate',
      id2: 'Id2',
      netType: 'NetType',
      nodeType: 'NodeType',
      owner: 'Owner',
      productKey: 'ProductKey',
      productName: 'ProductName',
      productSecret: 'ProductSecret',
      productStatus: 'ProductStatus',
      protocolType: 'ProtocolType',
      validateType: 'ValidateType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunCommodityCode: 'string',
      authType: 'string',
      categoryKey: 'string',
      categoryName: 'string',
      dataFormat: 'number',
      description: 'string',
      deviceCount: 'number',
      gmtCreate: 'number',
      id2: 'boolean',
      netType: 'number',
      nodeType: 'number',
      owner: 'boolean',
      productKey: 'string',
      productName: 'string',
      productSecret: 'string',
      productStatus: 'string',
      protocolType: 'string',
      validateType: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryProductCertInfoResponseProductCertInfo extends $tea.Model {
  issueModel: number;
  static names(): { [key: string]: string } {
    return {
      issueModel: 'IssueModel',
    };
  }

  static types(): { [key: string]: any } {
    return {
      issueModel: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryProductListResponseDataListProductInfo extends $tea.Model {
  authType: string;
  dataFormat: number;
  description: string;
  deviceCount: number;
  gmtCreate: number;
  nodeType: number;
  productKey: string;
  productName: string;
  static names(): { [key: string]: string } {
    return {
      authType: 'AuthType',
      dataFormat: 'DataFormat',
      description: 'Description',
      deviceCount: 'DeviceCount',
      gmtCreate: 'GmtCreate',
      nodeType: 'NodeType',
      productKey: 'ProductKey',
      productName: 'ProductName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authType: 'string',
      dataFormat: 'number',
      description: 'string',
      deviceCount: 'number',
      gmtCreate: 'number',
      nodeType: 'number',
      productKey: 'string',
      productName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryProductListResponseDataList extends $tea.Model {
  productInfo: QueryProductListResponseDataListProductInfo[];
  static names(): { [key: string]: string } {
    return {
      productInfo: 'ProductInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      productInfo: { 'type': 'array', 'itemType': QueryProductListResponseDataListProductInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryProductListResponseData extends $tea.Model {
  currentPage: number;
  pageCount: number;
  pageSize: number;
  total: number;
  list: QueryProductListResponseDataList;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      pageCount: 'PageCount',
      pageSize: 'PageSize',
      total: 'Total',
      list: 'List',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      pageCount: 'number',
      pageSize: 'number',
      total: 'number',
      list: QueryProductListResponseDataList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryProductTopicResponseDataProductTopicInfo extends $tea.Model {
  desc: string;
  id: string;
  operation: string;
  productKey: string;
  topicShortName: string;
  static names(): { [key: string]: string } {
    return {
      desc: 'Desc',
      id: 'Id',
      operation: 'Operation',
      productKey: 'ProductKey',
      topicShortName: 'TopicShortName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      desc: 'string',
      id: 'string',
      operation: 'string',
      productKey: 'string',
      topicShortName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryProductTopicResponseData extends $tea.Model {
  productTopicInfo: QueryProductTopicResponseDataProductTopicInfo[];
  static names(): { [key: string]: string } {
    return {
      productTopicInfo: 'ProductTopicInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      productTopicInfo: { 'type': 'array', 'itemType': QueryProductTopicResponseDataProductTopicInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryProjectShareDeviceListResponseDataDeviceListItems extends $tea.Model {
  deviceName: string;
  iotId: string;
  productKey: string;
  sharable: number;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      productKey: 'ProductKey',
      sharable: 'Sharable',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      productKey: 'string',
      sharable: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryProjectShareDeviceListResponseDataDeviceList extends $tea.Model {
  items: QueryProjectShareDeviceListResponseDataDeviceListItems[];
  static names(): { [key: string]: string } {
    return {
      items: 'items',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: { 'type': 'array', 'itemType': QueryProjectShareDeviceListResponseDataDeviceListItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryProjectShareDeviceListResponseData extends $tea.Model {
  pageId: number;
  pageSize: number;
  total: number;
  deviceList: QueryProjectShareDeviceListResponseDataDeviceList;
  static names(): { [key: string]: string } {
    return {
      pageId: 'PageId',
      pageSize: 'PageSize',
      total: 'Total',
      deviceList: 'DeviceList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageId: 'number',
      pageSize: 'number',
      total: 'number',
      deviceList: QueryProjectShareDeviceListResponseDataDeviceList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySceneRuleResponseDataRuleList extends $tea.Model {
  gmtCreate: number;
  gmtModified: number;
  ruleDescription: string;
  ruleId: string;
  ruleName: string;
  ruleStatus: number;
  static names(): { [key: string]: string } {
    return {
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      ruleDescription: 'RuleDescription',
      ruleId: 'RuleId',
      ruleName: 'RuleName',
      ruleStatus: 'RuleStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gmtCreate: 'number',
      gmtModified: 'number',
      ruleDescription: 'string',
      ruleId: 'string',
      ruleName: 'string',
      ruleStatus: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySceneRuleResponseData extends $tea.Model {
  currentPage: number;
  pageSize: number;
  total: number;
  ruleList: QuerySceneRuleResponseDataRuleList[];
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      total: 'Total',
      ruleList: 'RuleList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      pageSize: 'number',
      total: 'number',
      ruleList: { 'type': 'array', 'itemType': QuerySceneRuleResponseDataRuleList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySchedulePeriodListResponseDataListItems extends $tea.Model {
  description: string;
  endTime: string;
  periodCode: string;
  soundCodeContent: string;
  startTime: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      endTime: 'EndTime',
      periodCode: 'PeriodCode',
      soundCodeContent: 'SoundCodeContent',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      endTime: 'string',
      periodCode: 'string',
      soundCodeContent: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySchedulePeriodListResponseDataList extends $tea.Model {
  items: QuerySchedulePeriodListResponseDataListItems[];
  static names(): { [key: string]: string } {
    return {
      items: 'Items',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: { 'type': 'array', 'itemType': QuerySchedulePeriodListResponseDataListItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySchedulePeriodListResponseData extends $tea.Model {
  pageId: number;
  pageSize: number;
  total: number;
  list: QuerySchedulePeriodListResponseDataList;
  static names(): { [key: string]: string } {
    return {
      pageId: 'PageId',
      pageSize: 'PageSize',
      total: 'Total',
      list: 'List',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageId: 'number',
      pageSize: 'number',
      total: 'number',
      list: QuerySchedulePeriodListResponseDataList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryShareTaskDeviceListResponseDataDeviceListItems extends $tea.Model {
  deviceName: string;
  gmtAdded: number;
  iotId: string;
  productKey: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      gmtAdded: 'GmtAdded',
      iotId: 'IotId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      gmtAdded: 'number',
      iotId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryShareTaskDeviceListResponseDataDeviceList extends $tea.Model {
  items: QueryShareTaskDeviceListResponseDataDeviceListItems[];
  static names(): { [key: string]: string } {
    return {
      items: 'items',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: { 'type': 'array', 'itemType': QueryShareTaskDeviceListResponseDataDeviceListItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryShareTaskDeviceListResponseData extends $tea.Model {
  pageId: number;
  pageSize: number;
  total: number;
  deviceList: QueryShareTaskDeviceListResponseDataDeviceList;
  static names(): { [key: string]: string } {
    return {
      pageId: 'PageId',
      pageSize: 'PageSize',
      total: 'Total',
      deviceList: 'DeviceList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageId: 'number',
      pageSize: 'number',
      total: 'number',
      deviceList: QueryShareTaskDeviceListResponseDataDeviceList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySolutionDeviceGroupPageResponseDataListItemName extends $tea.Model {
  deviceCount: number;
  gmtCreate: number;
  gmtModified: number;
  groupDesc: string;
  groupId: string;
  groupName: string;
  static names(): { [key: string]: string } {
    return {
      deviceCount: 'DeviceCount',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      groupDesc: 'GroupDesc',
      groupId: 'GroupId',
      groupName: 'GroupName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceCount: 'number',
      gmtCreate: 'number',
      gmtModified: 'number',
      groupDesc: 'string',
      groupId: 'string',
      groupName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySolutionDeviceGroupPageResponseDataList extends $tea.Model {
  itemName: QuerySolutionDeviceGroupPageResponseDataListItemName[];
  static names(): { [key: string]: string } {
    return {
      itemName: 'itemName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      itemName: { 'type': 'array', 'itemType': QuerySolutionDeviceGroupPageResponseDataListItemName },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySolutionDeviceGroupPageResponseData extends $tea.Model {
  pageId: number;
  pageSize: number;
  total: number;
  list: QuerySolutionDeviceGroupPageResponseDataList;
  static names(): { [key: string]: string } {
    return {
      pageId: 'PageId',
      pageSize: 'PageSize',
      total: 'Total',
      list: 'List',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageId: 'number',
      pageSize: 'number',
      total: 'number',
      list: QuerySolutionDeviceGroupPageResponseDataList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySoundCodeLabelBatchFailedResultResponseDataItems extends $tea.Model {
  errorMessage: string;
  label: string;
  resultCode: string;
  static names(): { [key: string]: string } {
    return {
      errorMessage: 'ErrorMessage',
      label: 'Label',
      resultCode: 'ResultCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorMessage: 'string',
      label: 'string',
      resultCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySoundCodeLabelBatchFailedResultResponseData extends $tea.Model {
  items: QuerySoundCodeLabelBatchFailedResultResponseDataItems[];
  static names(): { [key: string]: string } {
    return {
      items: 'Items',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: { 'type': 'array', 'itemType': QuerySoundCodeLabelBatchFailedResultResponseDataItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySoundCodeLabelBatchListResponseDataListItems extends $tea.Model {
  batchCode: string;
  description: string;
  gmtCreate: number;
  status: string;
  successNum: number;
  total: number;
  static names(): { [key: string]: string } {
    return {
      batchCode: 'BatchCode',
      description: 'Description',
      gmtCreate: 'GmtCreate',
      status: 'Status',
      successNum: 'SuccessNum',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      batchCode: 'string',
      description: 'string',
      gmtCreate: 'number',
      status: 'string',
      successNum: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySoundCodeLabelBatchListResponseDataList extends $tea.Model {
  items: QuerySoundCodeLabelBatchListResponseDataListItems[];
  static names(): { [key: string]: string } {
    return {
      items: 'Items',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: { 'type': 'array', 'itemType': QuerySoundCodeLabelBatchListResponseDataListItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySoundCodeLabelBatchListResponseData extends $tea.Model {
  pageId: number;
  pageSize: number;
  total: number;
  list: QuerySoundCodeLabelBatchListResponseDataList;
  static names(): { [key: string]: string } {
    return {
      pageId: 'PageId',
      pageSize: 'PageSize',
      total: 'Total',
      list: 'List',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageId: 'number',
      pageSize: 'number',
      total: 'number',
      list: QuerySoundCodeLabelBatchListResponseDataList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySoundCodeLabelListResponseDataListItems extends $tea.Model {
  label: string;
  soundCode: string;
  static names(): { [key: string]: string } {
    return {
      label: 'Label',
      soundCode: 'SoundCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      label: 'string',
      soundCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySoundCodeLabelListResponseDataList extends $tea.Model {
  items: QuerySoundCodeLabelListResponseDataListItems[];
  static names(): { [key: string]: string } {
    return {
      items: 'Items',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: { 'type': 'array', 'itemType': QuerySoundCodeLabelListResponseDataListItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySoundCodeLabelListResponseData extends $tea.Model {
  pageId: number;
  pageSize: number;
  total: number;
  list: QuerySoundCodeLabelListResponseDataList;
  static names(): { [key: string]: string } {
    return {
      pageId: 'PageId',
      pageSize: 'PageSize',
      total: 'Total',
      list: 'List',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageId: 'number',
      pageSize: 'number',
      total: 'number',
      list: QuerySoundCodeLabelListResponseDataList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySoundCodeListResponseDataListItems extends $tea.Model {
  duration: number;
  gmtCreate: number;
  name: string;
  openType: string;
  soundCode: string;
  soundCodeContent: string;
  static names(): { [key: string]: string } {
    return {
      duration: 'Duration',
      gmtCreate: 'GmtCreate',
      name: 'Name',
      openType: 'OpenType',
      soundCode: 'SoundCode',
      soundCodeContent: 'SoundCodeContent',
    };
  }

  static types(): { [key: string]: any } {
    return {
      duration: 'number',
      gmtCreate: 'number',
      name: 'string',
      openType: 'string',
      soundCode: 'string',
      soundCodeContent: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySoundCodeListResponseDataList extends $tea.Model {
  items: QuerySoundCodeListResponseDataListItems[];
  static names(): { [key: string]: string } {
    return {
      items: 'Items',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: { 'type': 'array', 'itemType': QuerySoundCodeListResponseDataListItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySoundCodeListResponseData extends $tea.Model {
  pageId: number;
  pageSize: number;
  total: number;
  list: QuerySoundCodeListResponseDataList;
  static names(): { [key: string]: string } {
    return {
      pageId: 'PageId',
      pageSize: 'PageSize',
      total: 'Total',
      list: 'List',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageId: 'number',
      pageSize: 'number',
      total: 'number',
      list: QuerySoundCodeListResponseDataList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySoundCodeScheduleListResponseDataListItems extends $tea.Model {
  description: string;
  endDate: string;
  endTime: string;
  gmtCreate: number;
  name: string;
  openType: string;
  scheduleCode: string;
  startDate: string;
  startTime: string;
  status: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      endDate: 'EndDate',
      endTime: 'EndTime',
      gmtCreate: 'GmtCreate',
      name: 'Name',
      openType: 'OpenType',
      scheduleCode: 'ScheduleCode',
      startDate: 'StartDate',
      startTime: 'StartTime',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      endDate: 'string',
      endTime: 'string',
      gmtCreate: 'number',
      name: 'string',
      openType: 'string',
      scheduleCode: 'string',
      startDate: 'string',
      startTime: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySoundCodeScheduleListResponseDataList extends $tea.Model {
  items: QuerySoundCodeScheduleListResponseDataListItems[];
  static names(): { [key: string]: string } {
    return {
      items: 'Items',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: { 'type': 'array', 'itemType': QuerySoundCodeScheduleListResponseDataListItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySoundCodeScheduleListResponseData extends $tea.Model {
  pageId: number;
  pageSize: number;
  total: number;
  list: QuerySoundCodeScheduleListResponseDataList;
  static names(): { [key: string]: string } {
    return {
      pageId: 'PageId',
      pageSize: 'PageSize',
      total: 'Total',
      list: 'List',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageId: 'number',
      pageSize: 'number',
      total: 'number',
      list: QuerySoundCodeScheduleListResponseDataList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechResponseDataSoundCodeConfig extends $tea.Model {
  additionalDuration: number;
  soundCodeContent: string;
  static names(): { [key: string]: string } {
    return {
      additionalDuration: 'AdditionalDuration',
      soundCodeContent: 'SoundCodeContent',
    };
  }

  static types(): { [key: string]: any } {
    return {
      additionalDuration: 'number',
      soundCodeContent: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechResponseData extends $tea.Model {
  audioFormat: string;
  bizCode: string;
  enableSoundCode: boolean;
  speechCode: string;
  speechRate: number;
  speechType: string;
  text: string;
  voice: string;
  volume: number;
  soundCodeConfig: QuerySpeechResponseDataSoundCodeConfig;
  static names(): { [key: string]: string } {
    return {
      audioFormat: 'AudioFormat',
      bizCode: 'BizCode',
      enableSoundCode: 'EnableSoundCode',
      speechCode: 'SpeechCode',
      speechRate: 'SpeechRate',
      speechType: 'SpeechType',
      text: 'Text',
      voice: 'Voice',
      volume: 'Volume',
      soundCodeConfig: 'SoundCodeConfig',
    };
  }

  static types(): { [key: string]: any } {
    return {
      audioFormat: 'string',
      bizCode: 'string',
      enableSoundCode: 'boolean',
      speechCode: 'string',
      speechRate: 'number',
      speechType: 'string',
      text: 'string',
      voice: 'string',
      volume: 'number',
      soundCodeConfig: QuerySpeechResponseDataSoundCodeConfig,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechDeviceResponseDataListItems extends $tea.Model {
  availableSpace: number;
  deviceName: string;
  iotId: string;
  productKey: string;
  static names(): { [key: string]: string } {
    return {
      availableSpace: 'AvailableSpace',
      deviceName: 'DeviceName',
      iotId: 'IotId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      availableSpace: 'number',
      deviceName: 'string',
      iotId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechDeviceResponseDataList extends $tea.Model {
  items: QuerySpeechDeviceResponseDataListItems[];
  static names(): { [key: string]: string } {
    return {
      items: 'Items',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: { 'type': 'array', 'itemType': QuerySpeechDeviceResponseDataListItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechDeviceResponseData extends $tea.Model {
  pageId: number;
  pageSize: number;
  total: number;
  list: QuerySpeechDeviceResponseDataList;
  static names(): { [key: string]: string } {
    return {
      pageId: 'PageId',
      pageSize: 'PageSize',
      total: 'Total',
      list: 'List',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageId: 'number',
      pageSize: 'number',
      total: 'number',
      list: QuerySpeechDeviceResponseDataList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechLicenseDeviceListResponseDataDeviceListItem extends $tea.Model {
  deviceName: string;
  deviceStatus: string;
  expiryTime: number;
  inSpecifiedGroup: boolean;
  iotId: string;
  licenseStatus: string;
  productKey: string;
  productName: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      deviceStatus: 'DeviceStatus',
      expiryTime: 'ExpiryTime',
      inSpecifiedGroup: 'InSpecifiedGroup',
      iotId: 'IotId',
      licenseStatus: 'LicenseStatus',
      productKey: 'ProductKey',
      productName: 'ProductName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      deviceStatus: 'string',
      expiryTime: 'number',
      inSpecifiedGroup: 'boolean',
      iotId: 'string',
      licenseStatus: 'string',
      productKey: 'string',
      productName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechLicenseDeviceListResponseDataDeviceList extends $tea.Model {
  item: QuerySpeechLicenseDeviceListResponseDataDeviceListItem[];
  static names(): { [key: string]: string } {
    return {
      item: 'item',
    };
  }

  static types(): { [key: string]: any } {
    return {
      item: { 'type': 'array', 'itemType': QuerySpeechLicenseDeviceListResponseDataDeviceListItem },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechLicenseDeviceListResponseData extends $tea.Model {
  pageId: number;
  pageSize: number;
  total: number;
  deviceList: QuerySpeechLicenseDeviceListResponseDataDeviceList;
  static names(): { [key: string]: string } {
    return {
      pageId: 'PageId',
      pageSize: 'PageSize',
      total: 'Total',
      deviceList: 'DeviceList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageId: 'number',
      pageSize: 'number',
      total: 'number',
      deviceList: QuerySpeechLicenseDeviceListResponseDataDeviceList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechListResponseDataListItemsSpeechListItems extends $tea.Model {
  bizCode: string;
  speechCode: string;
  text: string;
  voice: string;
  static names(): { [key: string]: string } {
    return {
      bizCode: 'BizCode',
      speechCode: 'SpeechCode',
      text: 'Text',
      voice: 'Voice',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizCode: 'string',
      speechCode: 'string',
      text: 'string',
      voice: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechListResponseDataListItemsSpeechList extends $tea.Model {
  items: QuerySpeechListResponseDataListItemsSpeechListItems[];
  static names(): { [key: string]: string } {
    return {
      items: 'Items',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: { 'type': 'array', 'itemType': QuerySpeechListResponseDataListItemsSpeechListItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechListResponseDataListItems extends $tea.Model {
  audioFormat: string;
  bizCode: string;
  speechCode: string;
  speechType: string;
  text: string;
  voice: string;
  speechList: QuerySpeechListResponseDataListItemsSpeechList;
  static names(): { [key: string]: string } {
    return {
      audioFormat: 'AudioFormat',
      bizCode: 'BizCode',
      speechCode: 'SpeechCode',
      speechType: 'SpeechType',
      text: 'Text',
      voice: 'Voice',
      speechList: 'SpeechList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      audioFormat: 'string',
      bizCode: 'string',
      speechCode: 'string',
      speechType: 'string',
      text: 'string',
      voice: 'string',
      speechList: QuerySpeechListResponseDataListItemsSpeechList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechListResponseDataList extends $tea.Model {
  items: QuerySpeechListResponseDataListItems[];
  static names(): { [key: string]: string } {
    return {
      items: 'Items',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: { 'type': 'array', 'itemType': QuerySpeechListResponseDataListItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechListResponseData extends $tea.Model {
  pageId: number;
  pageSize: number;
  total: number;
  list: QuerySpeechListResponseDataList;
  static names(): { [key: string]: string } {
    return {
      pageId: 'PageId',
      pageSize: 'PageSize',
      total: 'Total',
      list: 'List',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageId: 'number',
      pageSize: 'number',
      total: 'number',
      list: QuerySpeechListResponseDataList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechPushJobResponseDataListItems extends $tea.Model {
  code: string;
  createdTime: number;
  deviceName: string;
  expiredTime: number;
  failDeviceNum: number;
  groupId: string;
  groupName: string;
  iotId: string;
  productKey: string;
  pushMode: string;
  runningDeviceNum: number;
  speechNum: number;
  speechStatus: boolean;
  status: string;
  successDeviceNum: number;
  totalDeviceNum: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      createdTime: 'CreatedTime',
      deviceName: 'DeviceName',
      expiredTime: 'ExpiredTime',
      failDeviceNum: 'FailDeviceNum',
      groupId: 'GroupId',
      groupName: 'GroupName',
      iotId: 'IotId',
      productKey: 'ProductKey',
      pushMode: 'PushMode',
      runningDeviceNum: 'RunningDeviceNum',
      speechNum: 'SpeechNum',
      speechStatus: 'SpeechStatus',
      status: 'Status',
      successDeviceNum: 'SuccessDeviceNum',
      totalDeviceNum: 'TotalDeviceNum',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      createdTime: 'number',
      deviceName: 'string',
      expiredTime: 'number',
      failDeviceNum: 'number',
      groupId: 'string',
      groupName: 'string',
      iotId: 'string',
      productKey: 'string',
      pushMode: 'string',
      runningDeviceNum: 'number',
      speechNum: 'number',
      speechStatus: 'boolean',
      status: 'string',
      successDeviceNum: 'number',
      totalDeviceNum: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechPushJobResponseDataList extends $tea.Model {
  items: QuerySpeechPushJobResponseDataListItems[];
  static names(): { [key: string]: string } {
    return {
      items: 'Items',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: { 'type': 'array', 'itemType': QuerySpeechPushJobResponseDataListItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechPushJobResponseData extends $tea.Model {
  pageId: number;
  pageSize: number;
  total: number;
  list: QuerySpeechPushJobResponseDataList;
  static names(): { [key: string]: string } {
    return {
      pageId: 'PageId',
      pageSize: 'PageSize',
      total: 'Total',
      list: 'List',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageId: 'number',
      pageSize: 'number',
      total: 'number',
      list: QuerySpeechPushJobResponseDataList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechPushJobDeviceResponseDataListItems extends $tea.Model {
  deviceName: string;
  errorCode: string;
  errorMessage: string;
  gmtModified: number;
  status: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      gmtModified: 'GmtModified',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      errorCode: 'string',
      errorMessage: 'string',
      gmtModified: 'number',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechPushJobDeviceResponseDataList extends $tea.Model {
  items: QuerySpeechPushJobDeviceResponseDataListItems[];
  static names(): { [key: string]: string } {
    return {
      items: 'Items',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: { 'type': 'array', 'itemType': QuerySpeechPushJobDeviceResponseDataListItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechPushJobDeviceResponseData extends $tea.Model {
  pageId: number;
  pageSize: number;
  total: number;
  list: QuerySpeechPushJobDeviceResponseDataList;
  static names(): { [key: string]: string } {
    return {
      pageId: 'PageId',
      pageSize: 'PageSize',
      total: 'Total',
      list: 'List',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageId: 'number',
      pageSize: 'number',
      total: 'number',
      list: QuerySpeechPushJobDeviceResponseDataList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechPushJobSpeechResponseDataListItemsSpeechListItems extends $tea.Model {
  bizCode: string;
  text: string;
  voice: string;
  static names(): { [key: string]: string } {
    return {
      bizCode: 'BizCode',
      text: 'Text',
      voice: 'Voice',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizCode: 'string',
      text: 'string',
      voice: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechPushJobSpeechResponseDataListItemsSpeechList extends $tea.Model {
  items: QuerySpeechPushJobSpeechResponseDataListItemsSpeechListItems[];
  static names(): { [key: string]: string } {
    return {
      items: 'Items',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: { 'type': 'array', 'itemType': QuerySpeechPushJobSpeechResponseDataListItemsSpeechListItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechPushJobSpeechResponseDataListItems extends $tea.Model {
  bizCode: string;
  speechType: string;
  text: string;
  voice: string;
  speechList: QuerySpeechPushJobSpeechResponseDataListItemsSpeechList;
  static names(): { [key: string]: string } {
    return {
      bizCode: 'BizCode',
      speechType: 'SpeechType',
      text: 'Text',
      voice: 'Voice',
      speechList: 'SpeechList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizCode: 'string',
      speechType: 'string',
      text: 'string',
      voice: 'string',
      speechList: QuerySpeechPushJobSpeechResponseDataListItemsSpeechList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechPushJobSpeechResponseDataList extends $tea.Model {
  items: QuerySpeechPushJobSpeechResponseDataListItems[];
  static names(): { [key: string]: string } {
    return {
      items: 'Items',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: { 'type': 'array', 'itemType': QuerySpeechPushJobSpeechResponseDataListItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechPushJobSpeechResponseData extends $tea.Model {
  pageId: number;
  pageSize: number;
  total: number;
  list: QuerySpeechPushJobSpeechResponseDataList;
  static names(): { [key: string]: string } {
    return {
      pageId: 'PageId',
      pageSize: 'PageSize',
      total: 'Total',
      list: 'List',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageId: 'number',
      pageSize: 'number',
      total: 'number',
      list: QuerySpeechPushJobSpeechResponseDataList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryStudioAppDomainListOpenResponseDataListDomainInfo extends $tea.Model {
  appId: string;
  gmtCreate: string;
  gmtModified: string;
  host: string;
  id: number;
  isBeian: string;
  projectId: string;
  protocol: string;
  tenantId: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      host: 'Host',
      id: 'Id',
      isBeian: 'IsBeian',
      projectId: 'ProjectId',
      protocol: 'Protocol',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      host: 'string',
      id: 'number',
      isBeian: 'string',
      projectId: 'string',
      protocol: 'string',
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryStudioAppDomainListOpenResponseDataList extends $tea.Model {
  domainInfo: QueryStudioAppDomainListOpenResponseDataListDomainInfo[];
  static names(): { [key: string]: string } {
    return {
      domainInfo: 'DomainInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainInfo: { 'type': 'array', 'itemType': QueryStudioAppDomainListOpenResponseDataListDomainInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryStudioAppDomainListOpenResponseData extends $tea.Model {
  pageNo: number;
  pageSize: number;
  total: number;
  totalPage: number;
  list: QueryStudioAppDomainListOpenResponseDataList;
  static names(): { [key: string]: string } {
    return {
      pageNo: 'PageNo',
      pageSize: 'PageSize',
      total: 'Total',
      totalPage: 'TotalPage',
      list: 'List',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNo: 'number',
      pageSize: 'number',
      total: 'number',
      totalPage: 'number',
      list: QueryStudioAppDomainListOpenResponseDataList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryStudioAppListResponseDataListAppInfo extends $tea.Model {
  appId: string;
  appKey: string;
  appSecret: string;
  description: string;
  gmtCreate: string;
  gmtModified: string;
  gmtRelease: string;
  name: string;
  projectId: string;
  type: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      appKey: 'AppKey',
      appSecret: 'AppSecret',
      description: 'Description',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      gmtRelease: 'GmtRelease',
      name: 'Name',
      projectId: 'ProjectId',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      appKey: 'string',
      appSecret: 'string',
      description: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      gmtRelease: 'string',
      name: 'string',
      projectId: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryStudioAppListResponseDataList extends $tea.Model {
  appInfo: QueryStudioAppListResponseDataListAppInfo[];
  static names(): { [key: string]: string } {
    return {
      appInfo: 'AppInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appInfo: { 'type': 'array', 'itemType': QueryStudioAppListResponseDataListAppInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryStudioAppListResponseData extends $tea.Model {
  pageNo: number;
  pageSize: number;
  total: number;
  totalPage: number;
  list: QueryStudioAppListResponseDataList;
  static names(): { [key: string]: string } {
    return {
      pageNo: 'PageNo',
      pageSize: 'PageSize',
      total: 'Total',
      totalPage: 'TotalPage',
      list: 'List',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNo: 'number',
      pageSize: 'number',
      total: 'number',
      totalPage: 'number',
      list: QueryStudioAppListResponseDataList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryStudioAppPageListOpenResponseDataListPageInfo extends $tea.Model {
  gmtCreate: string;
  gmtModified: string;
  id: number;
  isHidden: number;
  isHome: number;
  isLoginPage: number;
  name: string;
  pageId: string;
  path: string;
  static names(): { [key: string]: string } {
    return {
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      id: 'Id',
      isHidden: 'IsHidden',
      isHome: 'IsHome',
      isLoginPage: 'IsLoginPage',
      name: 'Name',
      pageId: 'PageId',
      path: 'Path',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gmtCreate: 'string',
      gmtModified: 'string',
      id: 'number',
      isHidden: 'number',
      isHome: 'number',
      isLoginPage: 'number',
      name: 'string',
      pageId: 'string',
      path: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryStudioAppPageListOpenResponseDataList extends $tea.Model {
  pageInfo: QueryStudioAppPageListOpenResponseDataListPageInfo[];
  static names(): { [key: string]: string } {
    return {
      pageInfo: 'PageInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageInfo: { 'type': 'array', 'itemType': QueryStudioAppPageListOpenResponseDataListPageInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryStudioAppPageListOpenResponseData extends $tea.Model {
  pageNo: number;
  pageSize: number;
  total: number;
  totalPage: number;
  list: QueryStudioAppPageListOpenResponseDataList;
  static names(): { [key: string]: string } {
    return {
      pageNo: 'PageNo',
      pageSize: 'PageSize',
      total: 'Total',
      totalPage: 'TotalPage',
      list: 'List',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNo: 'number',
      pageSize: 'number',
      total: 'number',
      totalPage: 'number',
      list: QueryStudioAppPageListOpenResponseDataList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryStudioProjectListResponseDataListProjectInfo extends $tea.Model {
  description: string;
  gmtCreate: number;
  gmtModified: number;
  name: string;
  projectId: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      name: 'Name',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      gmtCreate: 'number',
      gmtModified: 'number',
      name: 'string',
      projectId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryStudioProjectListResponseDataList extends $tea.Model {
  projectInfo: QueryStudioProjectListResponseDataListProjectInfo[];
  static names(): { [key: string]: string } {
    return {
      projectInfo: 'ProjectInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      projectInfo: { 'type': 'array', 'itemType': QueryStudioProjectListResponseDataListProjectInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryStudioProjectListResponseData extends $tea.Model {
  pageNo: number;
  pageSize: number;
  total: number;
  totalPage: number;
  list: QueryStudioProjectListResponseDataList;
  static names(): { [key: string]: string } {
    return {
      pageNo: 'PageNo',
      pageSize: 'PageSize',
      total: 'Total',
      totalPage: 'TotalPage',
      list: 'List',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNo: 'number',
      pageSize: 'number',
      total: 'number',
      totalPage: 'number',
      list: QueryStudioProjectListResponseDataList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySummarySceneRuleLogResponseDataLogListLogInfo extends $tea.Model {
  logTime: number;
  result: string;
  traceId: string;
  static names(): { [key: string]: string } {
    return {
      logTime: 'LogTime',
      result: 'Result',
      traceId: 'TraceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      logTime: 'number',
      result: 'string',
      traceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySummarySceneRuleLogResponseDataLogList extends $tea.Model {
  logInfo: QuerySummarySceneRuleLogResponseDataLogListLogInfo[];
  static names(): { [key: string]: string } {
    return {
      logInfo: 'LogInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      logInfo: { 'type': 'array', 'itemType': QuerySummarySceneRuleLogResponseDataLogListLogInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySummarySceneRuleLogResponseData extends $tea.Model {
  currentPage: number;
  pageSize: number;
  total: number;
  logList: QuerySummarySceneRuleLogResponseDataLogList;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      total: 'Total',
      logList: 'LogList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      pageSize: 'number',
      total: 'number',
      logList: QuerySummarySceneRuleLogResponseDataLogList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySuperDeviceGroupResponseDataGroupInfo extends $tea.Model {
  groupDesc: string;
  groupId: string;
  groupName: string;
  static names(): { [key: string]: string } {
    return {
      groupDesc: 'GroupDesc',
      groupId: 'GroupId',
      groupName: 'GroupName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupDesc: 'string',
      groupId: 'string',
      groupName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySuperDeviceGroupResponseData extends $tea.Model {
  groupInfo: QuerySuperDeviceGroupResponseDataGroupInfo[];
  static names(): { [key: string]: string } {
    return {
      groupInfo: 'GroupInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupInfo: { 'type': 'array', 'itemType': QuerySuperDeviceGroupResponseDataGroupInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTaskResponseData extends $tea.Model {
  deviceName: string;
  iotId: string;
  jobId: string;
  jobName: string;
  message: string;
  productKey: string;
  progress: string;
  status: string;
  statusDetail: string;
  taskId: string;
  utcModified: string;
  utcQueueTime: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      jobId: 'JobId',
      jobName: 'JobName',
      message: 'Message',
      productKey: 'ProductKey',
      progress: 'Progress',
      status: 'Status',
      statusDetail: 'StatusDetail',
      taskId: 'TaskId',
      utcModified: 'UtcModified',
      utcQueueTime: 'UtcQueueTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      jobId: 'string',
      jobName: 'string',
      message: 'string',
      productKey: 'string',
      progress: 'string',
      status: 'string',
      statusDetail: 'string',
      taskId: 'string',
      utcModified: 'string',
      utcQueueTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryThingModelResponseData extends $tea.Model {
  thingModelJson: string;
  static names(): { [key: string]: string } {
    return {
      thingModelJson: 'ThingModelJson',
    };
  }

  static types(): { [key: string]: any } {
    return {
      thingModelJson: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryThingModelExtendConfigResponseData extends $tea.Model {
  configuration: string;
  static names(): { [key: string]: string } {
    return {
      configuration: 'Configuration',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configuration: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryThingModelExtendConfigPublishedResponseData extends $tea.Model {
  configuration: string;
  static names(): { [key: string]: string } {
    return {
      configuration: 'Configuration',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configuration: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryThingModelPublishedResponseData extends $tea.Model {
  thingModelJson: string;
  static names(): { [key: string]: string } {
    return {
      thingModelJson: 'ThingModelJson',
    };
  }

  static types(): { [key: string]: any } {
    return {
      thingModelJson: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTopicReverseRouteTableResponseSrcTopics extends $tea.Model {
  topic: { [key: string]: any }[];
  static names(): { [key: string]: string } {
    return {
      topic: 'Topic',
    };
  }

  static types(): { [key: string]: any } {
    return {
      topic: { 'type': 'array', 'itemType': { 'type': 'map', 'keyType': 'string', 'valueType': 'any' } },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTopicRouteTableResponseDstTopics extends $tea.Model {
  topic: { [key: string]: any }[];
  static names(): { [key: string]: string } {
    return {
      topic: 'Topic',
    };
  }

  static types(): { [key: string]: any } {
    return {
      topic: { 'type': 'array', 'itemType': { 'type': 'map', 'keyType': 'string', 'valueType': 'any' } },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryVehicleDeviceResponseData extends $tea.Model {
  authCode: string;
  city: string;
  createTime: number;
  deviceId: string;
  deviceModel: string;
  deviceName: string;
  iotId: string;
  manufacturer: string;
  modifiedTime: number;
  productKey: string;
  province: string;
  registerTime: number;
  status: string;
  vehicleColour: string;
  vehicleNumber: string;
  static names(): { [key: string]: string } {
    return {
      authCode: 'AuthCode',
      city: 'City',
      createTime: 'CreateTime',
      deviceId: 'DeviceId',
      deviceModel: 'DeviceModel',
      deviceName: 'DeviceName',
      iotId: 'IotId',
      manufacturer: 'Manufacturer',
      modifiedTime: 'ModifiedTime',
      productKey: 'ProductKey',
      province: 'Province',
      registerTime: 'RegisterTime',
      status: 'Status',
      vehicleColour: 'VehicleColour',
      vehicleNumber: 'VehicleNumber',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authCode: 'string',
      city: 'string',
      createTime: 'number',
      deviceId: 'string',
      deviceModel: 'string',
      deviceName: 'string',
      iotId: 'string',
      manufacturer: 'string',
      modifiedTime: 'number',
      productKey: 'string',
      province: 'string',
      registerTime: 'number',
      status: 'string',
      vehicleColour: 'string',
      vehicleNumber: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReBindLicenseDeviceResponseData extends $tea.Model {
  checkProgressId: string;
  failSum: number;
  progress: number;
  resultCsvFile: string;
  successSum: number;
  static names(): { [key: string]: string } {
    return {
      checkProgressId: 'CheckProgressId',
      failSum: 'FailSum',
      progress: 'Progress',
      resultCsvFile: 'ResultCsvFile',
      successSum: 'SuccessSum',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkProgressId: 'string',
      failSum: 'number',
      progress: 'number',
      resultCsvFile: 'string',
      successSum: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RefreshStudioAppTokenOpenResponseData extends $tea.Model {
  bizId: string;
  bizType: string;
  isEnable: string;
  token: string;
  type: string;
  static names(): { [key: string]: string } {
    return {
      bizId: 'BizId',
      bizType: 'BizType',
      isEnable: 'IsEnable',
      token: 'Token',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizId: 'string',
      bizType: 'string',
      isEnable: 'string',
      token: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RegisterDeviceResponseData extends $tea.Model {
  devEui: string;
  deviceName: string;
  deviceSecret: string;
  iotId: string;
  joinEui: string;
  nickname: string;
  productKey: string;
  static names(): { [key: string]: string } {
    return {
      devEui: 'DevEui',
      deviceName: 'DeviceName',
      deviceSecret: 'DeviceSecret',
      iotId: 'IotId',
      joinEui: 'JoinEui',
      nickname: 'Nickname',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      devEui: 'string',
      deviceName: 'string',
      deviceSecret: 'string',
      iotId: 'string',
      joinEui: 'string',
      nickname: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDeviceDesiredPropertyResponseData extends $tea.Model {
  messageId: string;
  versions: string;
  static names(): { [key: string]: string } {
    return {
      messageId: 'MessageId',
      versions: 'Versions',
    };
  }

  static types(): { [key: string]: any } {
    return {
      messageId: 'string',
      versions: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDevicePropertyResponseData extends $tea.Model {
  messageId: string;
  static names(): { [key: string]: string } {
    return {
      messageId: 'MessageId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      messageId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetEdgeInstanceDriverConfigsRequestConfigs extends $tea.Model {
  content: string;
  format: string;
  key?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      format: 'Format',
      key: 'Key',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      format: 'string',
      key: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetupStudioAppAuthModeOpenResponseDataTokenInfo extends $tea.Model {
  bizId: string;
  bizType: string;
  isEnable: string;
  token: string;
  type: string;
  static names(): { [key: string]: string } {
    return {
      bizId: 'BizId',
      bizType: 'BizType',
      isEnable: 'IsEnable',
      token: 'Token',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizId: 'string',
      bizType: 'string',
      isEnable: 'string',
      token: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetupStudioAppAuthModeOpenResponseData extends $tea.Model {
  authMode: number;
  tokenInfo: SetupStudioAppAuthModeOpenResponseDataTokenInfo;
  static names(): { [key: string]: string } {
    return {
      authMode: 'AuthMode',
      tokenInfo: 'TokenInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authMode: 'number',
      tokenInfo: SetupStudioAppAuthModeOpenResponseDataTokenInfo,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SyncSpeechByCombinationResponseData extends $tea.Model {
  detail: string;
  deviceErrorCode: string;
  deviceErrorMessage: string;
  id: string;
  maxRetryCount: number;
  retryCount: number;
  success: boolean;
  static names(): { [key: string]: string } {
    return {
      detail: 'Detail',
      deviceErrorCode: 'DeviceErrorCode',
      deviceErrorMessage: 'DeviceErrorMessage',
      id: 'Id',
      maxRetryCount: 'MaxRetryCount',
      retryCount: 'RetryCount',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      detail: 'string',
      deviceErrorCode: 'string',
      deviceErrorMessage: 'string',
      id: 'string',
      maxRetryCount: 'number',
      retryCount: 'number',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TestSpeechResponseData extends $tea.Model {
  items: string[];
  static names(): { [key: string]: string } {
    return {
      items: 'items',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateEdgeInstanceChannelRequestConfigs extends $tea.Model {
  content: string;
  format: string;
  key?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      format: 'Format',
      key: 'Key',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      format: 'string',
      key: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProductTagsRequestProductTag extends $tea.Model {
  tagKey?: string;
  tagValue?: string;
  static names(): { [key: string]: string } {
    return {
      tagKey: 'TagKey',
      tagValue: 'TagValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagKey: 'string',
      tagValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProductTagsResponseInvalidProductTagsProductTag extends $tea.Model {
  tagKey: string;
  tagValue: string;
  static names(): { [key: string]: string } {
    return {
      tagKey: 'TagKey',
      tagValue: 'TagValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagKey: 'string',
      tagValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProductTagsResponseInvalidProductTags extends $tea.Model {
  productTag: UpdateProductTagsResponseInvalidProductTagsProductTag[];
  static names(): { [key: string]: string } {
    return {
      productTag: 'ProductTag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      productTag: { 'type': 'array', 'itemType': UpdateProductTagsResponseInvalidProductTagsProductTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}


export default class Client extends RPC {

  constructor(config: $RPC.Config) {
    super(config);
    this._endpointRule = "regional";
    this._endpointMap = {
      'ap-northeast-2-pop': "iot.aliyuncs.com",
      'ap-south-1': "iot.aliyuncs.com",
      'ap-southeast-2': "iot.aliyuncs.com",
      'ap-southeast-3': "iot.aliyuncs.com",
      'ap-southeast-5': "iot.aliyuncs.com",
      'cn-beijing-finance-1': "iot.aliyuncs.com",
      'cn-beijing-finance-pop': "iot.aliyuncs.com",
      'cn-beijing-gov-1': "iot.aliyuncs.com",
      'cn-beijing-nu16-b01': "iot.aliyuncs.com",
      'cn-chengdu': "iot.aliyuncs.com",
      'cn-edge-1': "iot.aliyuncs.com",
      'cn-fujian': "iot.aliyuncs.com",
      'cn-haidian-cm12-c01': "iot.aliyuncs.com",
      'cn-hangzhou-bj-b01': "iot.aliyuncs.com",
      'cn-hangzhou-finance': "iot.aliyuncs.com",
      'cn-hangzhou-internal-prod-1': "iot.aliyuncs.com",
      'cn-hangzhou-internal-test-1': "iot.aliyuncs.com",
      'cn-hangzhou-internal-test-2': "iot.aliyuncs.com",
      'cn-hangzhou-internal-test-3': "iot.aliyuncs.com",
      'cn-hangzhou-test-306': "iot.aliyuncs.com",
      'cn-hongkong': "iot.aliyuncs.com",
      'cn-hongkong-finance-pop': "iot.aliyuncs.com",
      'cn-huhehaote': "iot.aliyuncs.com",
      'cn-huhehaote-nebula-1': "iot.aliyuncs.com",
      'cn-qingdao': "iot.aliyuncs.com",
      'cn-qingdao-nebula': "iot.aliyuncs.com",
      'cn-shanghai-et15-b01': "iot.aliyuncs.com",
      'cn-shanghai-et2-b01': "iot.aliyuncs.com",
      'cn-shanghai-finance-1': "iot.aliyuncs.com",
      'cn-shanghai-inner': "iot.aliyuncs.com",
      'cn-shanghai-internal-test-1': "iot.aliyuncs.com",
      'cn-shenzhen-finance-1': "iot.aliyuncs.com",
      'cn-shenzhen-inner': "iot.aliyuncs.com",
      'cn-shenzhen-st4-d01': "iot.aliyuncs.com",
      'cn-shenzhen-su18-b01': "iot.aliyuncs.com",
      'cn-wuhan': "iot.aliyuncs.com",
      'cn-wulanchabu': "iot.aliyuncs.com",
      'cn-yushanfang': "iot.aliyuncs.com",
      'cn-zhangbei': "iot.aliyuncs.com",
      'cn-zhangbei-na61-b01': "iot.aliyuncs.com",
      'cn-zhangjiakou': "iot.aliyuncs.com",
      'cn-zhangjiakou-na62-a01': "iot.aliyuncs.com",
      'cn-zhengzhou-nebula-1': "iot.aliyuncs.com",
      'eu-west-1': "iot.aliyuncs.com",
      'eu-west-1-oxs': "iot.aliyuncs.com",
      'me-east-1': "iot.aliyuncs.com",
      'rus-west-1-pop': "iot.aliyuncs.com",
    };
    this.checkConfig(config);
    this._endpoint = this.getEndpoint("iot", this._regionId, this._endpointRule, this._network, this._suffix, this._endpointMap, this._endpoint);
  }


  async addDataForApiSourceWithOptions(request: AddDataForApiSourceRequest, runtime: $Util.RuntimeOptions): Promise<AddDataForApiSourceResponse> {
    Util.validateModel(request);
    return $tea.cast<AddDataForApiSourceResponse>(await this.doRequest("AddDataForApiSource", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new AddDataForApiSourceResponse({}));
  }

  async addDataForApiSource(request: AddDataForApiSourceRequest): Promise<AddDataForApiSourceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addDataForApiSourceWithOptions(request, runtime);
  }

  async addShareTaskDeviceWithOptions(request: AddShareTaskDeviceRequest, runtime: $Util.RuntimeOptions): Promise<AddShareTaskDeviceResponse> {
    Util.validateModel(request);
    return $tea.cast<AddShareTaskDeviceResponse>(await this.doRequest("AddShareTaskDevice", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new AddShareTaskDeviceResponse({}));
  }

  async addShareTaskDevice(request: AddShareTaskDeviceRequest): Promise<AddShareTaskDeviceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addShareTaskDeviceWithOptions(request, runtime);
  }

  async attachDestinationWithOptions(request: AttachDestinationRequest, runtime: $Util.RuntimeOptions): Promise<AttachDestinationResponse> {
    Util.validateModel(request);
    return $tea.cast<AttachDestinationResponse>(await this.doRequest("AttachDestination", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new AttachDestinationResponse({}));
  }

  async attachDestination(request: AttachDestinationRequest): Promise<AttachDestinationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.attachDestinationWithOptions(request, runtime);
  }

  async attachParserDataSourceWithOptions(request: AttachParserDataSourceRequest, runtime: $Util.RuntimeOptions): Promise<AttachParserDataSourceResponse> {
    Util.validateModel(request);
    return $tea.cast<AttachParserDataSourceResponse>(await this.doRequest("AttachParserDataSource", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new AttachParserDataSourceResponse({}));
  }

  async attachParserDataSource(request: AttachParserDataSourceRequest): Promise<AttachParserDataSourceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.attachParserDataSourceWithOptions(request, runtime);
  }

  async batchAddDataForApiSourceWithOptions(tmp: BatchAddDataForApiSourceRequest, runtime: $Util.RuntimeOptions): Promise<BatchAddDataForApiSourceResponse> {
    Util.validateModel(tmp);
    let request = new BatchAddDataForApiSourceShrinkRequest({ });
    RPCUtil.convert(tmp, request);
    if (!Util.isUnset(tmp.contentList)) {
      request.contentListShrink = Util.toJSONString(tmp.contentList);
    }

    return $tea.cast<BatchAddDataForApiSourceResponse>(await this.doRequest("BatchAddDataForApiSource", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new BatchAddDataForApiSourceResponse({}));
  }

  async batchAddDataForApiSource(request: BatchAddDataForApiSourceRequest): Promise<BatchAddDataForApiSourceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchAddDataForApiSourceWithOptions(request, runtime);
  }

  async batchAddDeviceGroupRelationsWithOptions(request: BatchAddDeviceGroupRelationsRequest, runtime: $Util.RuntimeOptions): Promise<BatchAddDeviceGroupRelationsResponse> {
    Util.validateModel(request);
    return $tea.cast<BatchAddDeviceGroupRelationsResponse>(await this.doRequest("BatchAddDeviceGroupRelations", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new BatchAddDeviceGroupRelationsResponse({}));
  }

  async batchAddDeviceGroupRelations(request: BatchAddDeviceGroupRelationsRequest): Promise<BatchAddDeviceGroupRelationsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchAddDeviceGroupRelationsWithOptions(request, runtime);
  }

  async batchAddThingTopoWithOptions(request: BatchAddThingTopoRequest, runtime: $Util.RuntimeOptions): Promise<BatchAddThingTopoResponse> {
    Util.validateModel(request);
    return $tea.cast<BatchAddThingTopoResponse>(await this.doRequest("BatchAddThingTopo", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new BatchAddThingTopoResponse({}));
  }

  async batchAddThingTopo(request: BatchAddThingTopoRequest): Promise<BatchAddThingTopoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchAddThingTopoWithOptions(request, runtime);
  }

  async batchBindDeviceToEdgeInstanceWithDriverWithOptions(request: BatchBindDeviceToEdgeInstanceWithDriverRequest, runtime: $Util.RuntimeOptions): Promise<BatchBindDeviceToEdgeInstanceWithDriverResponse> {
    Util.validateModel(request);
    return $tea.cast<BatchBindDeviceToEdgeInstanceWithDriverResponse>(await this.doRequest("BatchBindDeviceToEdgeInstanceWithDriver", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new BatchBindDeviceToEdgeInstanceWithDriverResponse({}));
  }

  async batchBindDeviceToEdgeInstanceWithDriver(request: BatchBindDeviceToEdgeInstanceWithDriverRequest): Promise<BatchBindDeviceToEdgeInstanceWithDriverResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchBindDeviceToEdgeInstanceWithDriverWithOptions(request, runtime);
  }

  async batchBindDevicesIntoProjectWithOptions(request: BatchBindDevicesIntoProjectRequest, runtime: $Util.RuntimeOptions): Promise<BatchBindDevicesIntoProjectResponse> {
    Util.validateModel(request);
    return $tea.cast<BatchBindDevicesIntoProjectResponse>(await this.doRequest("BatchBindDevicesIntoProject", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new BatchBindDevicesIntoProjectResponse({}));
  }

  async batchBindDevicesIntoProject(request: BatchBindDevicesIntoProjectRequest): Promise<BatchBindDevicesIntoProjectResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchBindDevicesIntoProjectWithOptions(request, runtime);
  }

  async batchBindProductsIntoProjectWithOptions(request: BatchBindProductsIntoProjectRequest, runtime: $Util.RuntimeOptions): Promise<BatchBindProductsIntoProjectResponse> {
    Util.validateModel(request);
    return $tea.cast<BatchBindProductsIntoProjectResponse>(await this.doRequest("BatchBindProductsIntoProject", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new BatchBindProductsIntoProjectResponse({}));
  }

  async batchBindProductsIntoProject(request: BatchBindProductsIntoProjectRequest): Promise<BatchBindProductsIntoProjectResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchBindProductsIntoProjectWithOptions(request, runtime);
  }

  async batchCheckDeviceNamesWithOptions(request: BatchCheckDeviceNamesRequest, runtime: $Util.RuntimeOptions): Promise<BatchCheckDeviceNamesResponse> {
    Util.validateModel(request);
    return $tea.cast<BatchCheckDeviceNamesResponse>(await this.doRequest("BatchCheckDeviceNames", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new BatchCheckDeviceNamesResponse({}));
  }

  async batchCheckDeviceNames(request: BatchCheckDeviceNamesRequest): Promise<BatchCheckDeviceNamesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchCheckDeviceNamesWithOptions(request, runtime);
  }

  async batchCheckImportDeviceWithOptions(request: BatchCheckImportDeviceRequest, runtime: $Util.RuntimeOptions): Promise<BatchCheckImportDeviceResponse> {
    Util.validateModel(request);
    return $tea.cast<BatchCheckImportDeviceResponse>(await this.doRequest("BatchCheckImportDevice", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new BatchCheckImportDeviceResponse({}));
  }

  async batchCheckImportDevice(request: BatchCheckImportDeviceRequest): Promise<BatchCheckImportDeviceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchCheckImportDeviceWithOptions(request, runtime);
  }

  async batchCheckVehicleDeviceWithOptions(request: BatchCheckVehicleDeviceRequest, runtime: $Util.RuntimeOptions): Promise<BatchCheckVehicleDeviceResponse> {
    Util.validateModel(request);
    return $tea.cast<BatchCheckVehicleDeviceResponse>(await this.doRequest("BatchCheckVehicleDevice", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new BatchCheckVehicleDeviceResponse({}));
  }

  async batchCheckVehicleDevice(request: BatchCheckVehicleDeviceRequest): Promise<BatchCheckVehicleDeviceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchCheckVehicleDeviceWithOptions(request, runtime);
  }

  async batchClearEdgeInstanceDeviceConfigWithOptions(request: BatchClearEdgeInstanceDeviceConfigRequest, runtime: $Util.RuntimeOptions): Promise<BatchClearEdgeInstanceDeviceConfigResponse> {
    Util.validateModel(request);
    return $tea.cast<BatchClearEdgeInstanceDeviceConfigResponse>(await this.doRequest("BatchClearEdgeInstanceDeviceConfig", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new BatchClearEdgeInstanceDeviceConfigResponse({}));
  }

  async batchClearEdgeInstanceDeviceConfig(request: BatchClearEdgeInstanceDeviceConfigRequest): Promise<BatchClearEdgeInstanceDeviceConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchClearEdgeInstanceDeviceConfigWithOptions(request, runtime);
  }

  async batchCreateSoundCodeLabelWithOptions(request: BatchCreateSoundCodeLabelRequest, runtime: $Util.RuntimeOptions): Promise<BatchCreateSoundCodeLabelResponse> {
    Util.validateModel(request);
    return $tea.cast<BatchCreateSoundCodeLabelResponse>(await this.doRequest("BatchCreateSoundCodeLabel", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new BatchCreateSoundCodeLabelResponse({}));
  }

  async batchCreateSoundCodeLabel(request: BatchCreateSoundCodeLabelRequest): Promise<BatchCreateSoundCodeLabelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchCreateSoundCodeLabelWithOptions(request, runtime);
  }

  async batchCreateSoundCodeLabelWithLabelsWithOptions(request: BatchCreateSoundCodeLabelWithLabelsRequest, runtime: $Util.RuntimeOptions): Promise<BatchCreateSoundCodeLabelWithLabelsResponse> {
    Util.validateModel(request);
    return $tea.cast<BatchCreateSoundCodeLabelWithLabelsResponse>(await this.doRequest("BatchCreateSoundCodeLabelWithLabels", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new BatchCreateSoundCodeLabelWithLabelsResponse({}));
  }

  async batchCreateSoundCodeLabelWithLabels(request: BatchCreateSoundCodeLabelWithLabelsRequest): Promise<BatchCreateSoundCodeLabelWithLabelsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchCreateSoundCodeLabelWithLabelsWithOptions(request, runtime);
  }

  async batchDeleteDeviceGroupRelationsWithOptions(request: BatchDeleteDeviceGroupRelationsRequest, runtime: $Util.RuntimeOptions): Promise<BatchDeleteDeviceGroupRelationsResponse> {
    Util.validateModel(request);
    return $tea.cast<BatchDeleteDeviceGroupRelationsResponse>(await this.doRequest("BatchDeleteDeviceGroupRelations", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new BatchDeleteDeviceGroupRelationsResponse({}));
  }

  async batchDeleteDeviceGroupRelations(request: BatchDeleteDeviceGroupRelationsRequest): Promise<BatchDeleteDeviceGroupRelationsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchDeleteDeviceGroupRelationsWithOptions(request, runtime);
  }

  async batchDeleteEdgeInstanceChannelWithOptions(request: BatchDeleteEdgeInstanceChannelRequest, runtime: $Util.RuntimeOptions): Promise<BatchDeleteEdgeInstanceChannelResponse> {
    Util.validateModel(request);
    return $tea.cast<BatchDeleteEdgeInstanceChannelResponse>(await this.doRequest("BatchDeleteEdgeInstanceChannel", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new BatchDeleteEdgeInstanceChannelResponse({}));
  }

  async batchDeleteEdgeInstanceChannel(request: BatchDeleteEdgeInstanceChannelRequest): Promise<BatchDeleteEdgeInstanceChannelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchDeleteEdgeInstanceChannelWithOptions(request, runtime);
  }

  async batchGetDeviceBindStatusWithOptions(request: BatchGetDeviceBindStatusRequest, runtime: $Util.RuntimeOptions): Promise<BatchGetDeviceBindStatusResponse> {
    Util.validateModel(request);
    return $tea.cast<BatchGetDeviceBindStatusResponse>(await this.doRequest("BatchGetDeviceBindStatus", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new BatchGetDeviceBindStatusResponse({}));
  }

  async batchGetDeviceBindStatus(request: BatchGetDeviceBindStatusRequest): Promise<BatchGetDeviceBindStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchGetDeviceBindStatusWithOptions(request, runtime);
  }

  async batchGetDeviceStateWithOptions(request: BatchGetDeviceStateRequest, runtime: $Util.RuntimeOptions): Promise<BatchGetDeviceStateResponse> {
    Util.validateModel(request);
    return $tea.cast<BatchGetDeviceStateResponse>(await this.doRequest("BatchGetDeviceState", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new BatchGetDeviceStateResponse({}));
  }

  async batchGetDeviceState(request: BatchGetDeviceStateRequest): Promise<BatchGetDeviceStateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchGetDeviceStateWithOptions(request, runtime);
  }

  async batchGetEdgeDriverWithOptions(request: BatchGetEdgeDriverRequest, runtime: $Util.RuntimeOptions): Promise<BatchGetEdgeDriverResponse> {
    Util.validateModel(request);
    return $tea.cast<BatchGetEdgeDriverResponse>(await this.doRequest("BatchGetEdgeDriver", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new BatchGetEdgeDriverResponse({}));
  }

  async batchGetEdgeDriver(request: BatchGetEdgeDriverRequest): Promise<BatchGetEdgeDriverResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchGetEdgeDriverWithOptions(request, runtime);
  }

  async batchGetEdgeInstanceChannelWithOptions(request: BatchGetEdgeInstanceChannelRequest, runtime: $Util.RuntimeOptions): Promise<BatchGetEdgeInstanceChannelResponse> {
    Util.validateModel(request);
    return $tea.cast<BatchGetEdgeInstanceChannelResponse>(await this.doRequest("BatchGetEdgeInstanceChannel", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new BatchGetEdgeInstanceChannelResponse({}));
  }

  async batchGetEdgeInstanceChannel(request: BatchGetEdgeInstanceChannelRequest): Promise<BatchGetEdgeInstanceChannelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchGetEdgeInstanceChannelWithOptions(request, runtime);
  }

  async batchGetEdgeInstanceDeviceChannelWithOptions(request: BatchGetEdgeInstanceDeviceChannelRequest, runtime: $Util.RuntimeOptions): Promise<BatchGetEdgeInstanceDeviceChannelResponse> {
    Util.validateModel(request);
    return $tea.cast<BatchGetEdgeInstanceDeviceChannelResponse>(await this.doRequest("BatchGetEdgeInstanceDeviceChannel", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new BatchGetEdgeInstanceDeviceChannelResponse({}));
  }

  async batchGetEdgeInstanceDeviceChannel(request: BatchGetEdgeInstanceDeviceChannelRequest): Promise<BatchGetEdgeInstanceDeviceChannelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchGetEdgeInstanceDeviceChannelWithOptions(request, runtime);
  }

  async batchGetEdgeInstanceDeviceConfigWithOptions(request: BatchGetEdgeInstanceDeviceConfigRequest, runtime: $Util.RuntimeOptions): Promise<BatchGetEdgeInstanceDeviceConfigResponse> {
    Util.validateModel(request);
    return $tea.cast<BatchGetEdgeInstanceDeviceConfigResponse>(await this.doRequest("BatchGetEdgeInstanceDeviceConfig", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new BatchGetEdgeInstanceDeviceConfigResponse({}));
  }

  async batchGetEdgeInstanceDeviceConfig(request: BatchGetEdgeInstanceDeviceConfigRequest): Promise<BatchGetEdgeInstanceDeviceConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchGetEdgeInstanceDeviceConfigWithOptions(request, runtime);
  }

  async batchGetEdgeInstanceDeviceDriverWithOptions(request: BatchGetEdgeInstanceDeviceDriverRequest, runtime: $Util.RuntimeOptions): Promise<BatchGetEdgeInstanceDeviceDriverResponse> {
    Util.validateModel(request);
    return $tea.cast<BatchGetEdgeInstanceDeviceDriverResponse>(await this.doRequest("BatchGetEdgeInstanceDeviceDriver", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new BatchGetEdgeInstanceDeviceDriverResponse({}));
  }

  async batchGetEdgeInstanceDeviceDriver(request: BatchGetEdgeInstanceDeviceDriverRequest): Promise<BatchGetEdgeInstanceDeviceDriverResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchGetEdgeInstanceDeviceDriverWithOptions(request, runtime);
  }

  async batchGetEdgeInstanceDriverConfigsWithOptions(request: BatchGetEdgeInstanceDriverConfigsRequest, runtime: $Util.RuntimeOptions): Promise<BatchGetEdgeInstanceDriverConfigsResponse> {
    Util.validateModel(request);
    return $tea.cast<BatchGetEdgeInstanceDriverConfigsResponse>(await this.doRequest("BatchGetEdgeInstanceDriverConfigs", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new BatchGetEdgeInstanceDriverConfigsResponse({}));
  }

  async batchGetEdgeInstanceDriverConfigs(request: BatchGetEdgeInstanceDriverConfigsRequest): Promise<BatchGetEdgeInstanceDriverConfigsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchGetEdgeInstanceDriverConfigsWithOptions(request, runtime);
  }

  async batchImportDeviceWithOptions(request: BatchImportDeviceRequest, runtime: $Util.RuntimeOptions): Promise<BatchImportDeviceResponse> {
    Util.validateModel(request);
    return $tea.cast<BatchImportDeviceResponse>(await this.doRequest("BatchImportDevice", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new BatchImportDeviceResponse({}));
  }

  async batchImportDevice(request: BatchImportDeviceRequest): Promise<BatchImportDeviceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchImportDeviceWithOptions(request, runtime);
  }

  async batchImportVehicleDeviceWithOptions(request: BatchImportVehicleDeviceRequest, runtime: $Util.RuntimeOptions): Promise<BatchImportVehicleDeviceResponse> {
    Util.validateModel(request);
    return $tea.cast<BatchImportVehicleDeviceResponse>(await this.doRequest("BatchImportVehicleDevice", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new BatchImportVehicleDeviceResponse({}));
  }

  async batchImportVehicleDevice(request: BatchImportVehicleDeviceRequest): Promise<BatchImportVehicleDeviceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchImportVehicleDeviceWithOptions(request, runtime);
  }

  async batchPubWithOptions(request: BatchPubRequest, runtime: $Util.RuntimeOptions): Promise<BatchPubResponse> {
    Util.validateModel(request);
    return $tea.cast<BatchPubResponse>(await this.doRequest("BatchPub", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new BatchPubResponse({}));
  }

  async batchPub(request: BatchPubRequest): Promise<BatchPubResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchPubWithOptions(request, runtime);
  }

  async batchQueryDeviceDetailWithOptions(request: BatchQueryDeviceDetailRequest, runtime: $Util.RuntimeOptions): Promise<BatchQueryDeviceDetailResponse> {
    Util.validateModel(request);
    return $tea.cast<BatchQueryDeviceDetailResponse>(await this.doRequest("BatchQueryDeviceDetail", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new BatchQueryDeviceDetailResponse({}));
  }

  async batchQueryDeviceDetail(request: BatchQueryDeviceDetailRequest): Promise<BatchQueryDeviceDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchQueryDeviceDetailWithOptions(request, runtime);
  }

  async batchRegisterDeviceWithOptions(request: BatchRegisterDeviceRequest, runtime: $Util.RuntimeOptions): Promise<BatchRegisterDeviceResponse> {
    Util.validateModel(request);
    return $tea.cast<BatchRegisterDeviceResponse>(await this.doRequest("BatchRegisterDevice", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new BatchRegisterDeviceResponse({}));
  }

  async batchRegisterDevice(request: BatchRegisterDeviceRequest): Promise<BatchRegisterDeviceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchRegisterDeviceWithOptions(request, runtime);
  }

  async batchRegisterDeviceWithApplyIdWithOptions(request: BatchRegisterDeviceWithApplyIdRequest, runtime: $Util.RuntimeOptions): Promise<BatchRegisterDeviceWithApplyIdResponse> {
    Util.validateModel(request);
    return $tea.cast<BatchRegisterDeviceWithApplyIdResponse>(await this.doRequest("BatchRegisterDeviceWithApplyId", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new BatchRegisterDeviceWithApplyIdResponse({}));
  }

  async batchRegisterDeviceWithApplyId(request: BatchRegisterDeviceWithApplyIdRequest): Promise<BatchRegisterDeviceWithApplyIdResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchRegisterDeviceWithApplyIdWithOptions(request, runtime);
  }

  async batchSetEdgeInstanceDeviceChannelWithOptions(request: BatchSetEdgeInstanceDeviceChannelRequest, runtime: $Util.RuntimeOptions): Promise<BatchSetEdgeInstanceDeviceChannelResponse> {
    Util.validateModel(request);
    return $tea.cast<BatchSetEdgeInstanceDeviceChannelResponse>(await this.doRequest("BatchSetEdgeInstanceDeviceChannel", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new BatchSetEdgeInstanceDeviceChannelResponse({}));
  }

  async batchSetEdgeInstanceDeviceChannel(request: BatchSetEdgeInstanceDeviceChannelRequest): Promise<BatchSetEdgeInstanceDeviceChannelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchSetEdgeInstanceDeviceChannelWithOptions(request, runtime);
  }

  async batchSetEdgeInstanceDeviceConfigWithOptions(request: BatchSetEdgeInstanceDeviceConfigRequest, runtime: $Util.RuntimeOptions): Promise<BatchSetEdgeInstanceDeviceConfigResponse> {
    Util.validateModel(request);
    return $tea.cast<BatchSetEdgeInstanceDeviceConfigResponse>(await this.doRequest("BatchSetEdgeInstanceDeviceConfig", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new BatchSetEdgeInstanceDeviceConfigResponse({}));
  }

  async batchSetEdgeInstanceDeviceConfig(request: BatchSetEdgeInstanceDeviceConfigRequest): Promise<BatchSetEdgeInstanceDeviceConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchSetEdgeInstanceDeviceConfigWithOptions(request, runtime);
  }

  async batchUnbindDeviceFromEdgeInstanceWithOptions(request: BatchUnbindDeviceFromEdgeInstanceRequest, runtime: $Util.RuntimeOptions): Promise<BatchUnbindDeviceFromEdgeInstanceResponse> {
    Util.validateModel(request);
    return $tea.cast<BatchUnbindDeviceFromEdgeInstanceResponse>(await this.doRequest("BatchUnbindDeviceFromEdgeInstance", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new BatchUnbindDeviceFromEdgeInstanceResponse({}));
  }

  async batchUnbindDeviceFromEdgeInstance(request: BatchUnbindDeviceFromEdgeInstanceRequest): Promise<BatchUnbindDeviceFromEdgeInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchUnbindDeviceFromEdgeInstanceWithOptions(request, runtime);
  }

  async batchUnbindProjectDevicesWithOptions(request: BatchUnbindProjectDevicesRequest, runtime: $Util.RuntimeOptions): Promise<BatchUnbindProjectDevicesResponse> {
    Util.validateModel(request);
    return $tea.cast<BatchUnbindProjectDevicesResponse>(await this.doRequest("BatchUnbindProjectDevices", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new BatchUnbindProjectDevicesResponse({}));
  }

  async batchUnbindProjectDevices(request: BatchUnbindProjectDevicesRequest): Promise<BatchUnbindProjectDevicesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchUnbindProjectDevicesWithOptions(request, runtime);
  }

  async batchUnbindProjectProductsWithOptions(request: BatchUnbindProjectProductsRequest, runtime: $Util.RuntimeOptions): Promise<BatchUnbindProjectProductsResponse> {
    Util.validateModel(request);
    return $tea.cast<BatchUnbindProjectProductsResponse>(await this.doRequest("BatchUnbindProjectProducts", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new BatchUnbindProjectProductsResponse({}));
  }

  async batchUnbindProjectProducts(request: BatchUnbindProjectProductsRequest): Promise<BatchUnbindProjectProductsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchUnbindProjectProductsWithOptions(request, runtime);
  }

  async batchUpdateDeviceNicknameWithOptions(request: BatchUpdateDeviceNicknameRequest, runtime: $Util.RuntimeOptions): Promise<BatchUpdateDeviceNicknameResponse> {
    Util.validateModel(request);
    return $tea.cast<BatchUpdateDeviceNicknameResponse>(await this.doRequest("BatchUpdateDeviceNickname", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new BatchUpdateDeviceNicknameResponse({}));
  }

  async batchUpdateDeviceNickname(request: BatchUpdateDeviceNicknameRequest): Promise<BatchUpdateDeviceNicknameResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchUpdateDeviceNicknameWithOptions(request, runtime);
  }

  async bindApplicationToEdgeInstanceWithOptions(request: BindApplicationToEdgeInstanceRequest, runtime: $Util.RuntimeOptions): Promise<BindApplicationToEdgeInstanceResponse> {
    Util.validateModel(request);
    return $tea.cast<BindApplicationToEdgeInstanceResponse>(await this.doRequest("BindApplicationToEdgeInstance", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new BindApplicationToEdgeInstanceResponse({}));
  }

  async bindApplicationToEdgeInstance(request: BindApplicationToEdgeInstanceRequest): Promise<BindApplicationToEdgeInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.bindApplicationToEdgeInstanceWithOptions(request, runtime);
  }

  async bindDriverToEdgeInstanceWithOptions(request: BindDriverToEdgeInstanceRequest, runtime: $Util.RuntimeOptions): Promise<BindDriverToEdgeInstanceResponse> {
    Util.validateModel(request);
    return $tea.cast<BindDriverToEdgeInstanceResponse>(await this.doRequest("BindDriverToEdgeInstance", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new BindDriverToEdgeInstanceResponse({}));
  }

  async bindDriverToEdgeInstance(request: BindDriverToEdgeInstanceRequest): Promise<BindDriverToEdgeInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.bindDriverToEdgeInstanceWithOptions(request, runtime);
  }

  async bindGatewayToEdgeInstanceWithOptions(request: BindGatewayToEdgeInstanceRequest, runtime: $Util.RuntimeOptions): Promise<BindGatewayToEdgeInstanceResponse> {
    Util.validateModel(request);
    return $tea.cast<BindGatewayToEdgeInstanceResponse>(await this.doRequest("BindGatewayToEdgeInstance", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new BindGatewayToEdgeInstanceResponse({}));
  }

  async bindGatewayToEdgeInstance(request: BindGatewayToEdgeInstanceRequest): Promise<BindGatewayToEdgeInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.bindGatewayToEdgeInstanceWithOptions(request, runtime);
  }

  async bindLicenseDeviceWithOptions(request: BindLicenseDeviceRequest, runtime: $Util.RuntimeOptions): Promise<BindLicenseDeviceResponse> {
    Util.validateModel(request);
    return $tea.cast<BindLicenseDeviceResponse>(await this.doRequest("BindLicenseDevice", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new BindLicenseDeviceResponse({}));
  }

  async bindLicenseDevice(request: BindLicenseDeviceRequest): Promise<BindLicenseDeviceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.bindLicenseDeviceWithOptions(request, runtime);
  }

  async bindLicenseProductWithOptions(request: BindLicenseProductRequest, runtime: $Util.RuntimeOptions): Promise<BindLicenseProductResponse> {
    Util.validateModel(request);
    return $tea.cast<BindLicenseProductResponse>(await this.doRequest("BindLicenseProduct", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new BindLicenseProductResponse({}));
  }

  async bindLicenseProduct(request: BindLicenseProductRequest): Promise<BindLicenseProductResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.bindLicenseProductWithOptions(request, runtime);
  }

  async bindRoleToEdgeInstanceWithOptions(request: BindRoleToEdgeInstanceRequest, runtime: $Util.RuntimeOptions): Promise<BindRoleToEdgeInstanceResponse> {
    Util.validateModel(request);
    return $tea.cast<BindRoleToEdgeInstanceResponse>(await this.doRequest("BindRoleToEdgeInstance", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new BindRoleToEdgeInstanceResponse({}));
  }

  async bindRoleToEdgeInstance(request: BindRoleToEdgeInstanceRequest): Promise<BindRoleToEdgeInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.bindRoleToEdgeInstanceWithOptions(request, runtime);
  }

  async bindSceneRuleToEdgeInstanceWithOptions(request: BindSceneRuleToEdgeInstanceRequest, runtime: $Util.RuntimeOptions): Promise<BindSceneRuleToEdgeInstanceResponse> {
    Util.validateModel(request);
    return $tea.cast<BindSceneRuleToEdgeInstanceResponse>(await this.doRequest("BindSceneRuleToEdgeInstance", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new BindSceneRuleToEdgeInstanceResponse({}));
  }

  async bindSceneRuleToEdgeInstance(request: BindSceneRuleToEdgeInstanceRequest): Promise<BindSceneRuleToEdgeInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.bindSceneRuleToEdgeInstanceWithOptions(request, runtime);
  }

  async cancelJobWithOptions(request: CancelJobRequest, runtime: $Util.RuntimeOptions): Promise<CancelJobResponse> {
    Util.validateModel(request);
    return $tea.cast<CancelJobResponse>(await this.doRequest("CancelJob", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new CancelJobResponse({}));
  }

  async cancelJob(request: CancelJobRequest): Promise<CancelJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.cancelJobWithOptions(request, runtime);
  }

  async cancelOTAStrategyByJobWithOptions(request: CancelOTAStrategyByJobRequest, runtime: $Util.RuntimeOptions): Promise<CancelOTAStrategyByJobResponse> {
    Util.validateModel(request);
    return $tea.cast<CancelOTAStrategyByJobResponse>(await this.doRequest("CancelOTAStrategyByJob", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new CancelOTAStrategyByJobResponse({}));
  }

  async cancelOTAStrategyByJob(request: CancelOTAStrategyByJobRequest): Promise<CancelOTAStrategyByJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.cancelOTAStrategyByJobWithOptions(request, runtime);
  }

  async cancelOTATaskByDeviceWithOptions(request: CancelOTATaskByDeviceRequest, runtime: $Util.RuntimeOptions): Promise<CancelOTATaskByDeviceResponse> {
    Util.validateModel(request);
    return $tea.cast<CancelOTATaskByDeviceResponse>(await this.doRequest("CancelOTATaskByDevice", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new CancelOTATaskByDeviceResponse({}));
  }

  async cancelOTATaskByDevice(request: CancelOTATaskByDeviceRequest): Promise<CancelOTATaskByDeviceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.cancelOTATaskByDeviceWithOptions(request, runtime);
  }

  async cancelOTATaskByJobWithOptions(request: CancelOTATaskByJobRequest, runtime: $Util.RuntimeOptions): Promise<CancelOTATaskByJobResponse> {
    Util.validateModel(request);
    return $tea.cast<CancelOTATaskByJobResponse>(await this.doRequest("CancelOTATaskByJob", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new CancelOTATaskByJobResponse({}));
  }

  async cancelOTATaskByJob(request: CancelOTATaskByJobRequest): Promise<CancelOTATaskByJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.cancelOTATaskByJobWithOptions(request, runtime);
  }

  async cancelReleaseProductWithOptions(request: CancelReleaseProductRequest, runtime: $Util.RuntimeOptions): Promise<CancelReleaseProductResponse> {
    Util.validateModel(request);
    return $tea.cast<CancelReleaseProductResponse>(await this.doRequest("CancelReleaseProduct", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new CancelReleaseProductResponse({}));
  }

  async cancelReleaseProduct(request: CancelReleaseProductRequest): Promise<CancelReleaseProductResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.cancelReleaseProductWithOptions(request, runtime);
  }

  async checkBindLicenseDeviceProgressWithOptions(request: CheckBindLicenseDeviceProgressRequest, runtime: $Util.RuntimeOptions): Promise<CheckBindLicenseDeviceProgressResponse> {
    Util.validateModel(request);
    return $tea.cast<CheckBindLicenseDeviceProgressResponse>(await this.doRequest("CheckBindLicenseDeviceProgress", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new CheckBindLicenseDeviceProgressResponse({}));
  }

  async checkBindLicenseDeviceProgress(request: CheckBindLicenseDeviceProgressRequest): Promise<CheckBindLicenseDeviceProgressResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.checkBindLicenseDeviceProgressWithOptions(request, runtime);
  }

  async clearDeviceDesiredPropertyWithOptions(request: ClearDeviceDesiredPropertyRequest, runtime: $Util.RuntimeOptions): Promise<ClearDeviceDesiredPropertyResponse> {
    Util.validateModel(request);
    return $tea.cast<ClearDeviceDesiredPropertyResponse>(await this.doRequest("ClearDeviceDesiredProperty", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new ClearDeviceDesiredPropertyResponse({}));
  }

  async clearDeviceDesiredProperty(request: ClearDeviceDesiredPropertyRequest): Promise<ClearDeviceDesiredPropertyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.clearDeviceDesiredPropertyWithOptions(request, runtime);
  }

  async clearEdgeInstanceDriverConfigsWithOptions(request: ClearEdgeInstanceDriverConfigsRequest, runtime: $Util.RuntimeOptions): Promise<ClearEdgeInstanceDriverConfigsResponse> {
    Util.validateModel(request);
    return $tea.cast<ClearEdgeInstanceDriverConfigsResponse>(await this.doRequest("ClearEdgeInstanceDriverConfigs", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new ClearEdgeInstanceDriverConfigsResponse({}));
  }

  async clearEdgeInstanceDriverConfigs(request: ClearEdgeInstanceDriverConfigsRequest): Promise<ClearEdgeInstanceDriverConfigsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.clearEdgeInstanceDriverConfigsWithOptions(request, runtime);
  }

  async closeDeviceTunnelWithOptions(request: CloseDeviceTunnelRequest, runtime: $Util.RuntimeOptions): Promise<CloseDeviceTunnelResponse> {
    Util.validateModel(request);
    return $tea.cast<CloseDeviceTunnelResponse>(await this.doRequest("CloseDeviceTunnel", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new CloseDeviceTunnelResponse({}));
  }

  async closeDeviceTunnel(request: CloseDeviceTunnelRequest): Promise<CloseDeviceTunnelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.closeDeviceTunnelWithOptions(request, runtime);
  }

  async closeEdgeInstanceDeploymentWithOptions(request: CloseEdgeInstanceDeploymentRequest, runtime: $Util.RuntimeOptions): Promise<CloseEdgeInstanceDeploymentResponse> {
    Util.validateModel(request);
    return $tea.cast<CloseEdgeInstanceDeploymentResponse>(await this.doRequest("CloseEdgeInstanceDeployment", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new CloseEdgeInstanceDeploymentResponse({}));
  }

  async closeEdgeInstanceDeployment(request: CloseEdgeInstanceDeploymentRequest): Promise<CloseEdgeInstanceDeploymentResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.closeEdgeInstanceDeploymentWithOptions(request, runtime);
  }

  async confirmOTATaskWithOptions(request: ConfirmOTATaskRequest, runtime: $Util.RuntimeOptions): Promise<ConfirmOTATaskResponse> {
    Util.validateModel(request);
    return $tea.cast<ConfirmOTATaskResponse>(await this.doRequest("ConfirmOTATask", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new ConfirmOTATaskResponse({}));
  }

  async confirmOTATask(request: ConfirmOTATaskRequest): Promise<ConfirmOTATaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.confirmOTATaskWithOptions(request, runtime);
  }

  async copyThingModelWithOptions(request: CopyThingModelRequest, runtime: $Util.RuntimeOptions): Promise<CopyThingModelResponse> {
    Util.validateModel(request);
    return $tea.cast<CopyThingModelResponse>(await this.doRequest("CopyThingModel", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new CopyThingModelResponse({}));
  }

  async copyThingModel(request: CopyThingModelRequest): Promise<CopyThingModelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.copyThingModelWithOptions(request, runtime);
  }

  async countSpeechBroadcastHourWithOptions(request: CountSpeechBroadcastHourRequest, runtime: $Util.RuntimeOptions): Promise<CountSpeechBroadcastHourResponse> {
    Util.validateModel(request);
    return $tea.cast<CountSpeechBroadcastHourResponse>(await this.doRequest("CountSpeechBroadcastHour", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new CountSpeechBroadcastHourResponse({}));
  }

  async countSpeechBroadcastHour(request: CountSpeechBroadcastHourRequest): Promise<CountSpeechBroadcastHourResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.countSpeechBroadcastHourWithOptions(request, runtime);
  }

  async createConsumerGroupWithOptions(request: CreateConsumerGroupRequest, runtime: $Util.RuntimeOptions): Promise<CreateConsumerGroupResponse> {
    Util.validateModel(request);
    return $tea.cast<CreateConsumerGroupResponse>(await this.doRequest("CreateConsumerGroup", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new CreateConsumerGroupResponse({}));
  }

  async createConsumerGroup(request: CreateConsumerGroupRequest): Promise<CreateConsumerGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createConsumerGroupWithOptions(request, runtime);
  }

  async createConsumerGroupSubscribeRelationWithOptions(request: CreateConsumerGroupSubscribeRelationRequest, runtime: $Util.RuntimeOptions): Promise<CreateConsumerGroupSubscribeRelationResponse> {
    Util.validateModel(request);
    return $tea.cast<CreateConsumerGroupSubscribeRelationResponse>(await this.doRequest("CreateConsumerGroupSubscribeRelation", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new CreateConsumerGroupSubscribeRelationResponse({}));
  }

  async createConsumerGroupSubscribeRelation(request: CreateConsumerGroupSubscribeRelationRequest): Promise<CreateConsumerGroupSubscribeRelationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createConsumerGroupSubscribeRelationWithOptions(request, runtime);
  }

  async createDataAPIServiceWithOptions(request: CreateDataAPIServiceRequest, runtime: $Util.RuntimeOptions): Promise<CreateDataAPIServiceResponse> {
    Util.validateModel(request);
    return $tea.cast<CreateDataAPIServiceResponse>(await this.doRequest("CreateDataAPIService", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new CreateDataAPIServiceResponse({}));
  }

  async createDataAPIService(request: CreateDataAPIServiceRequest): Promise<CreateDataAPIServiceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createDataAPIServiceWithOptions(request, runtime);
  }

  async createDataSourceItemWithOptions(request: CreateDataSourceItemRequest, runtime: $Util.RuntimeOptions): Promise<CreateDataSourceItemResponse> {
    Util.validateModel(request);
    return $tea.cast<CreateDataSourceItemResponse>(await this.doRequest("CreateDataSourceItem", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new CreateDataSourceItemResponse({}));
  }

  async createDataSourceItem(request: CreateDataSourceItemRequest): Promise<CreateDataSourceItemResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createDataSourceItemWithOptions(request, runtime);
  }

  async createDestinationWithOptions(request: CreateDestinationRequest, runtime: $Util.RuntimeOptions): Promise<CreateDestinationResponse> {
    Util.validateModel(request);
    return $tea.cast<CreateDestinationResponse>(await this.doRequest("CreateDestination", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new CreateDestinationResponse({}));
  }

  async createDestination(request: CreateDestinationRequest): Promise<CreateDestinationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createDestinationWithOptions(request, runtime);
  }

  async createDeviceDistributeJobWithOptions(request: CreateDeviceDistributeJobRequest, runtime: $Util.RuntimeOptions): Promise<CreateDeviceDistributeJobResponse> {
    Util.validateModel(request);
    return $tea.cast<CreateDeviceDistributeJobResponse>(await this.doRequest("CreateDeviceDistributeJob", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new CreateDeviceDistributeJobResponse({}));
  }

  async createDeviceDistributeJob(request: CreateDeviceDistributeJobRequest): Promise<CreateDeviceDistributeJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createDeviceDistributeJobWithOptions(request, runtime);
  }

  async createDeviceDynamicGroupWithOptions(request: CreateDeviceDynamicGroupRequest, runtime: $Util.RuntimeOptions): Promise<CreateDeviceDynamicGroupResponse> {
    Util.validateModel(request);
    return $tea.cast<CreateDeviceDynamicGroupResponse>(await this.doRequest("CreateDeviceDynamicGroup", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new CreateDeviceDynamicGroupResponse({}));
  }

  async createDeviceDynamicGroup(request: CreateDeviceDynamicGroupRequest): Promise<CreateDeviceDynamicGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createDeviceDynamicGroupWithOptions(request, runtime);
  }

  async createDeviceGroupWithOptions(request: CreateDeviceGroupRequest, runtime: $Util.RuntimeOptions): Promise<CreateDeviceGroupResponse> {
    Util.validateModel(request);
    return $tea.cast<CreateDeviceGroupResponse>(await this.doRequest("CreateDeviceGroup", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new CreateDeviceGroupResponse({}));
  }

  async createDeviceGroup(request: CreateDeviceGroupRequest): Promise<CreateDeviceGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createDeviceGroupWithOptions(request, runtime);
  }

  async createDeviceTunnelWithOptions(request: CreateDeviceTunnelRequest, runtime: $Util.RuntimeOptions): Promise<CreateDeviceTunnelResponse> {
    Util.validateModel(request);
    return $tea.cast<CreateDeviceTunnelResponse>(await this.doRequest("CreateDeviceTunnel", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new CreateDeviceTunnelResponse({}));
  }

  async createDeviceTunnel(request: CreateDeviceTunnelRequest): Promise<CreateDeviceTunnelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createDeviceTunnelWithOptions(request, runtime);
  }

  async createDownloadDataJobWithOptions(tmp: CreateDownloadDataJobRequest, runtime: $Util.RuntimeOptions): Promise<CreateDownloadDataJobResponse> {
    Util.validateModel(tmp);
    let request = new CreateDownloadDataJobShrinkRequest({ });
    RPCUtil.convert(tmp, request);
    if (!Util.isUnset(tmp.context)) {
      request.contextShrink = Util.toJSONString(tmp.context);
    }

    if (!Util.isUnset(tmp.fileConfig)) {
      request.fileConfigShrink = Util.toJSONString(tmp.fileConfig);
    }

    return $tea.cast<CreateDownloadDataJobResponse>(await this.doRequest("CreateDownloadDataJob", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new CreateDownloadDataJobResponse({}));
  }

  async createDownloadDataJob(request: CreateDownloadDataJobRequest): Promise<CreateDownloadDataJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createDownloadDataJobWithOptions(request, runtime);
  }

  async createEdgeDriverWithOptions(request: CreateEdgeDriverRequest, runtime: $Util.RuntimeOptions): Promise<CreateEdgeDriverResponse> {
    Util.validateModel(request);
    return $tea.cast<CreateEdgeDriverResponse>(await this.doRequest("CreateEdgeDriver", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new CreateEdgeDriverResponse({}));
  }

  async createEdgeDriver(request: CreateEdgeDriverRequest): Promise<CreateEdgeDriverResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createEdgeDriverWithOptions(request, runtime);
  }

  async createEdgeDriverVersionWithOptions(request: CreateEdgeDriverVersionRequest, runtime: $Util.RuntimeOptions): Promise<CreateEdgeDriverVersionResponse> {
    Util.validateModel(request);
    return $tea.cast<CreateEdgeDriverVersionResponse>(await this.doRequest("CreateEdgeDriverVersion", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new CreateEdgeDriverVersionResponse({}));
  }

  async createEdgeDriverVersion(request: CreateEdgeDriverVersionRequest): Promise<CreateEdgeDriverVersionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createEdgeDriverVersionWithOptions(request, runtime);
  }

  async createEdgeInstanceWithOptions(request: CreateEdgeInstanceRequest, runtime: $Util.RuntimeOptions): Promise<CreateEdgeInstanceResponse> {
    Util.validateModel(request);
    return $tea.cast<CreateEdgeInstanceResponse>(await this.doRequest("CreateEdgeInstance", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new CreateEdgeInstanceResponse({}));
  }

  async createEdgeInstance(request: CreateEdgeInstanceRequest): Promise<CreateEdgeInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createEdgeInstanceWithOptions(request, runtime);
  }

  async createEdgeInstanceChannelWithOptions(request: CreateEdgeInstanceChannelRequest, runtime: $Util.RuntimeOptions): Promise<CreateEdgeInstanceChannelResponse> {
    Util.validateModel(request);
    return $tea.cast<CreateEdgeInstanceChannelResponse>(await this.doRequest("CreateEdgeInstanceChannel", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new CreateEdgeInstanceChannelResponse({}));
  }

  async createEdgeInstanceChannel(request: CreateEdgeInstanceChannelRequest): Promise<CreateEdgeInstanceChannelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createEdgeInstanceChannelWithOptions(request, runtime);
  }

  async createEdgeInstanceDeploymentWithOptions(request: CreateEdgeInstanceDeploymentRequest, runtime: $Util.RuntimeOptions): Promise<CreateEdgeInstanceDeploymentResponse> {
    Util.validateModel(request);
    return $tea.cast<CreateEdgeInstanceDeploymentResponse>(await this.doRequest("CreateEdgeInstanceDeployment", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new CreateEdgeInstanceDeploymentResponse({}));
  }

  async createEdgeInstanceDeployment(request: CreateEdgeInstanceDeploymentRequest): Promise<CreateEdgeInstanceDeploymentResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createEdgeInstanceDeploymentWithOptions(request, runtime);
  }

  async createEdgeInstanceMessageRoutingWithOptions(request: CreateEdgeInstanceMessageRoutingRequest, runtime: $Util.RuntimeOptions): Promise<CreateEdgeInstanceMessageRoutingResponse> {
    Util.validateModel(request);
    return $tea.cast<CreateEdgeInstanceMessageRoutingResponse>(await this.doRequest("CreateEdgeInstanceMessageRouting", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new CreateEdgeInstanceMessageRoutingResponse({}));
  }

  async createEdgeInstanceMessageRouting(request: CreateEdgeInstanceMessageRoutingRequest): Promise<CreateEdgeInstanceMessageRoutingResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createEdgeInstanceMessageRoutingWithOptions(request, runtime);
  }

  async createEdgeOssPreSignedAddressWithOptions(request: CreateEdgeOssPreSignedAddressRequest, runtime: $Util.RuntimeOptions): Promise<CreateEdgeOssPreSignedAddressResponse> {
    Util.validateModel(request);
    return $tea.cast<CreateEdgeOssPreSignedAddressResponse>(await this.doRequest("CreateEdgeOssPreSignedAddress", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new CreateEdgeOssPreSignedAddressResponse({}));
  }

  async createEdgeOssPreSignedAddress(request: CreateEdgeOssPreSignedAddressRequest): Promise<CreateEdgeOssPreSignedAddressResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createEdgeOssPreSignedAddressWithOptions(request, runtime);
  }

  async createJobWithOptions(tmp: CreateJobRequest, runtime: $Util.RuntimeOptions): Promise<CreateJobResponse> {
    Util.validateModel(tmp);
    let request = new CreateJobShrinkRequest({ });
    RPCUtil.convert(tmp, request);
    if (!Util.isUnset(tmp.jobFile)) {
      request.jobFileShrink = Util.toJSONString(tmp.jobFile);
    }

    if (!Util.isUnset(tmp.rolloutConfig)) {
      request.rolloutConfigShrink = Util.toJSONString(tmp.rolloutConfig);
    }

    if (!Util.isUnset(tmp.targetConfig)) {
      request.targetConfigShrink = Util.toJSONString(tmp.targetConfig);
    }

    if (!Util.isUnset(tmp.timeoutConfig)) {
      request.timeoutConfigShrink = Util.toJSONString(tmp.timeoutConfig);
    }

    return $tea.cast<CreateJobResponse>(await this.doRequest("CreateJob", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new CreateJobResponse({}));
  }

  async createJob(request: CreateJobRequest): Promise<CreateJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createJobWithOptions(request, runtime);
  }

  async createLoRaNodesTaskWithOptions(request: CreateLoRaNodesTaskRequest, runtime: $Util.RuntimeOptions): Promise<CreateLoRaNodesTaskResponse> {
    Util.validateModel(request);
    return $tea.cast<CreateLoRaNodesTaskResponse>(await this.doRequest("CreateLoRaNodesTask", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new CreateLoRaNodesTaskResponse({}));
  }

  async createLoRaNodesTask(request: CreateLoRaNodesTaskRequest): Promise<CreateLoRaNodesTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createLoRaNodesTaskWithOptions(request, runtime);
  }

  async createOTADynamicUpgradeJobWithOptions(request: CreateOTADynamicUpgradeJobRequest, runtime: $Util.RuntimeOptions): Promise<CreateOTADynamicUpgradeJobResponse> {
    Util.validateModel(request);
    return $tea.cast<CreateOTADynamicUpgradeJobResponse>(await this.doRequest("CreateOTADynamicUpgradeJob", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new CreateOTADynamicUpgradeJobResponse({}));
  }

  async createOTADynamicUpgradeJob(request: CreateOTADynamicUpgradeJobRequest): Promise<CreateOTADynamicUpgradeJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createOTADynamicUpgradeJobWithOptions(request, runtime);
  }

  async createOTAFirmwareWithOptions(request: CreateOTAFirmwareRequest, runtime: $Util.RuntimeOptions): Promise<CreateOTAFirmwareResponse> {
    Util.validateModel(request);
    return $tea.cast<CreateOTAFirmwareResponse>(await this.doRequest("CreateOTAFirmware", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new CreateOTAFirmwareResponse({}));
  }

  async createOTAFirmware(request: CreateOTAFirmwareRequest): Promise<CreateOTAFirmwareResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createOTAFirmwareWithOptions(request, runtime);
  }

  async createOTAModuleWithOptions(request: CreateOTAModuleRequest, runtime: $Util.RuntimeOptions): Promise<CreateOTAModuleResponse> {
    Util.validateModel(request);
    return $tea.cast<CreateOTAModuleResponse>(await this.doRequest("CreateOTAModule", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new CreateOTAModuleResponse({}));
  }

  async createOTAModule(request: CreateOTAModuleRequest): Promise<CreateOTAModuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createOTAModuleWithOptions(request, runtime);
  }

  async createOTAStaticUpgradeJobWithOptions(request: CreateOTAStaticUpgradeJobRequest, runtime: $Util.RuntimeOptions): Promise<CreateOTAStaticUpgradeJobResponse> {
    Util.validateModel(request);
    return $tea.cast<CreateOTAStaticUpgradeJobResponse>(await this.doRequest("CreateOTAStaticUpgradeJob", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new CreateOTAStaticUpgradeJobResponse({}));
  }

  async createOTAStaticUpgradeJob(request: CreateOTAStaticUpgradeJobRequest): Promise<CreateOTAStaticUpgradeJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createOTAStaticUpgradeJobWithOptions(request, runtime);
  }

  async createOTAVerifyJobWithOptions(request: CreateOTAVerifyJobRequest, runtime: $Util.RuntimeOptions): Promise<CreateOTAVerifyJobResponse> {
    Util.validateModel(request);
    return $tea.cast<CreateOTAVerifyJobResponse>(await this.doRequest("CreateOTAVerifyJob", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new CreateOTAVerifyJobResponse({}));
  }

  async createOTAVerifyJob(request: CreateOTAVerifyJobRequest): Promise<CreateOTAVerifyJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createOTAVerifyJobWithOptions(request, runtime);
  }

  async createParserWithOptions(request: CreateParserRequest, runtime: $Util.RuntimeOptions): Promise<CreateParserResponse> {
    Util.validateModel(request);
    return $tea.cast<CreateParserResponse>(await this.doRequest("CreateParser", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new CreateParserResponse({}));
  }

  async createParser(request: CreateParserRequest): Promise<CreateParserResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createParserWithOptions(request, runtime);
  }

  async createParserDataSourceWithOptions(request: CreateParserDataSourceRequest, runtime: $Util.RuntimeOptions): Promise<CreateParserDataSourceResponse> {
    Util.validateModel(request);
    return $tea.cast<CreateParserDataSourceResponse>(await this.doRequest("CreateParserDataSource", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new CreateParserDataSourceResponse({}));
  }

  async createParserDataSource(request: CreateParserDataSourceRequest): Promise<CreateParserDataSourceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createParserDataSourceWithOptions(request, runtime);
  }

  async createProductWithOptions(request: CreateProductRequest, runtime: $Util.RuntimeOptions): Promise<CreateProductResponse> {
    Util.validateModel(request);
    return $tea.cast<CreateProductResponse>(await this.doRequest("CreateProduct", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new CreateProductResponse({}));
  }

  async createProduct(request: CreateProductRequest): Promise<CreateProductResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createProductWithOptions(request, runtime);
  }

  async createProductDistributeJobWithOptions(request: CreateProductDistributeJobRequest, runtime: $Util.RuntimeOptions): Promise<CreateProductDistributeJobResponse> {
    Util.validateModel(request);
    return $tea.cast<CreateProductDistributeJobResponse>(await this.doRequest("CreateProductDistributeJob", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new CreateProductDistributeJobResponse({}));
  }

  async createProductDistributeJob(request: CreateProductDistributeJobRequest): Promise<CreateProductDistributeJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createProductDistributeJobWithOptions(request, runtime);
  }

  async createProductTagsWithOptions(request: CreateProductTagsRequest, runtime: $Util.RuntimeOptions): Promise<CreateProductTagsResponse> {
    Util.validateModel(request);
    return $tea.cast<CreateProductTagsResponse>(await this.doRequest("CreateProductTags", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new CreateProductTagsResponse({}));
  }

  async createProductTags(request: CreateProductTagsRequest): Promise<CreateProductTagsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createProductTagsWithOptions(request, runtime);
  }

  async createProductTopicWithOptions(request: CreateProductTopicRequest, runtime: $Util.RuntimeOptions): Promise<CreateProductTopicResponse> {
    Util.validateModel(request);
    return $tea.cast<CreateProductTopicResponse>(await this.doRequest("CreateProductTopic", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new CreateProductTopicResponse({}));
  }

  async createProductTopic(request: CreateProductTopicRequest): Promise<CreateProductTopicResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createProductTopicWithOptions(request, runtime);
  }

  async createRuleWithOptions(request: CreateRuleRequest, runtime: $Util.RuntimeOptions): Promise<CreateRuleResponse> {
    Util.validateModel(request);
    return $tea.cast<CreateRuleResponse>(await this.doRequest("CreateRule", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new CreateRuleResponse({}));
  }

  async createRule(request: CreateRuleRequest): Promise<CreateRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createRuleWithOptions(request, runtime);
  }

  async createRuleActionWithOptions(request: CreateRuleActionRequest, runtime: $Util.RuntimeOptions): Promise<CreateRuleActionResponse> {
    Util.validateModel(request);
    return $tea.cast<CreateRuleActionResponse>(await this.doRequest("CreateRuleAction", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new CreateRuleActionResponse({}));
  }

  async createRuleAction(request: CreateRuleActionRequest): Promise<CreateRuleActionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createRuleActionWithOptions(request, runtime);
  }

  async createSceneRuleWithOptions(request: CreateSceneRuleRequest, runtime: $Util.RuntimeOptions): Promise<CreateSceneRuleResponse> {
    Util.validateModel(request);
    return $tea.cast<CreateSceneRuleResponse>(await this.doRequest("CreateSceneRule", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new CreateSceneRuleResponse({}));
  }

  async createSceneRule(request: CreateSceneRuleRequest): Promise<CreateSceneRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createSceneRuleWithOptions(request, runtime);
  }

  async createSchedulePeriodWithOptions(request: CreateSchedulePeriodRequest, runtime: $Util.RuntimeOptions): Promise<CreateSchedulePeriodResponse> {
    Util.validateModel(request);
    return $tea.cast<CreateSchedulePeriodResponse>(await this.doRequest("CreateSchedulePeriod", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new CreateSchedulePeriodResponse({}));
  }

  async createSchedulePeriod(request: CreateSchedulePeriodRequest): Promise<CreateSchedulePeriodResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createSchedulePeriodWithOptions(request, runtime);
  }

  async createSoundCodeWithOptions(request: CreateSoundCodeRequest, runtime: $Util.RuntimeOptions): Promise<CreateSoundCodeResponse> {
    Util.validateModel(request);
    return $tea.cast<CreateSoundCodeResponse>(await this.doRequest("CreateSoundCode", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new CreateSoundCodeResponse({}));
  }

  async createSoundCode(request: CreateSoundCodeRequest): Promise<CreateSoundCodeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createSoundCodeWithOptions(request, runtime);
  }

  async createSoundCodeLabelWithOptions(request: CreateSoundCodeLabelRequest, runtime: $Util.RuntimeOptions): Promise<CreateSoundCodeLabelResponse> {
    Util.validateModel(request);
    return $tea.cast<CreateSoundCodeLabelResponse>(await this.doRequest("CreateSoundCodeLabel", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new CreateSoundCodeLabelResponse({}));
  }

  async createSoundCodeLabel(request: CreateSoundCodeLabelRequest): Promise<CreateSoundCodeLabelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createSoundCodeLabelWithOptions(request, runtime);
  }

  async createSoundCodeScheduleWithOptions(request: CreateSoundCodeScheduleRequest, runtime: $Util.RuntimeOptions): Promise<CreateSoundCodeScheduleResponse> {
    Util.validateModel(request);
    return $tea.cast<CreateSoundCodeScheduleResponse>(await this.doRequest("CreateSoundCodeSchedule", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new CreateSoundCodeScheduleResponse({}));
  }

  async createSoundCodeSchedule(request: CreateSoundCodeScheduleRequest): Promise<CreateSoundCodeScheduleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createSoundCodeScheduleWithOptions(request, runtime);
  }

  async createSpeechWithOptions(tmp: CreateSpeechRequest, runtime: $Util.RuntimeOptions): Promise<CreateSpeechResponse> {
    Util.validateModel(tmp);
    let request = new CreateSpeechShrinkRequest({ });
    RPCUtil.convert(tmp, request);
    if (!Util.isUnset(tmp.soundCodeConfig)) {
      request.soundCodeConfigShrink = Util.toJSONString(tmp.soundCodeConfig);
    }

    return $tea.cast<CreateSpeechResponse>(await this.doRequest("CreateSpeech", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new CreateSpeechResponse({}));
  }

  async createSpeech(request: CreateSpeechRequest): Promise<CreateSpeechResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createSpeechWithOptions(request, runtime);
  }

  async createStudioAppDomainOpenWithOptions(request: CreateStudioAppDomainOpenRequest, runtime: $Util.RuntimeOptions): Promise<CreateStudioAppDomainOpenResponse> {
    Util.validateModel(request);
    return $tea.cast<CreateStudioAppDomainOpenResponse>(await this.doRequest("CreateStudioAppDomainOpen", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new CreateStudioAppDomainOpenResponse({}));
  }

  async createStudioAppDomainOpen(request: CreateStudioAppDomainOpenRequest): Promise<CreateStudioAppDomainOpenResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createStudioAppDomainOpenWithOptions(request, runtime);
  }

  async createSubscribeRelationWithOptions(request: CreateSubscribeRelationRequest, runtime: $Util.RuntimeOptions): Promise<CreateSubscribeRelationResponse> {
    Util.validateModel(request);
    return $tea.cast<CreateSubscribeRelationResponse>(await this.doRequest("CreateSubscribeRelation", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new CreateSubscribeRelationResponse({}));
  }

  async createSubscribeRelation(request: CreateSubscribeRelationRequest): Promise<CreateSubscribeRelationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createSubscribeRelationWithOptions(request, runtime);
  }

  async createThingModelWithOptions(request: CreateThingModelRequest, runtime: $Util.RuntimeOptions): Promise<CreateThingModelResponse> {
    Util.validateModel(request);
    return $tea.cast<CreateThingModelResponse>(await this.doRequest("CreateThingModel", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new CreateThingModelResponse({}));
  }

  async createThingModel(request: CreateThingModelRequest): Promise<CreateThingModelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createThingModelWithOptions(request, runtime);
  }

  async createThingScriptWithOptions(request: CreateThingScriptRequest, runtime: $Util.RuntimeOptions): Promise<CreateThingScriptResponse> {
    Util.validateModel(request);
    return $tea.cast<CreateThingScriptResponse>(await this.doRequest("CreateThingScript", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new CreateThingScriptResponse({}));
  }

  async createThingScript(request: CreateThingScriptRequest): Promise<CreateThingScriptResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createThingScriptWithOptions(request, runtime);
  }

  async createTopicRouteTableWithOptions(request: CreateTopicRouteTableRequest, runtime: $Util.RuntimeOptions): Promise<CreateTopicRouteTableResponse> {
    Util.validateModel(request);
    return $tea.cast<CreateTopicRouteTableResponse>(await this.doRequest("CreateTopicRouteTable", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new CreateTopicRouteTableResponse({}));
  }

  async createTopicRouteTable(request: CreateTopicRouteTableRequest): Promise<CreateTopicRouteTableResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createTopicRouteTableWithOptions(request, runtime);
  }

  async deleteClientIdsWithOptions(request: DeleteClientIdsRequest, runtime: $Util.RuntimeOptions): Promise<DeleteClientIdsResponse> {
    Util.validateModel(request);
    return $tea.cast<DeleteClientIdsResponse>(await this.doRequest("DeleteClientIds", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new DeleteClientIdsResponse({}));
  }

  async deleteClientIds(request: DeleteClientIdsRequest): Promise<DeleteClientIdsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteClientIdsWithOptions(request, runtime);
  }

  async deleteConsumerGroupWithOptions(request: DeleteConsumerGroupRequest, runtime: $Util.RuntimeOptions): Promise<DeleteConsumerGroupResponse> {
    Util.validateModel(request);
    return $tea.cast<DeleteConsumerGroupResponse>(await this.doRequest("DeleteConsumerGroup", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new DeleteConsumerGroupResponse({}));
  }

  async deleteConsumerGroup(request: DeleteConsumerGroupRequest): Promise<DeleteConsumerGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteConsumerGroupWithOptions(request, runtime);
  }

  async deleteConsumerGroupSubscribeRelationWithOptions(request: DeleteConsumerGroupSubscribeRelationRequest, runtime: $Util.RuntimeOptions): Promise<DeleteConsumerGroupSubscribeRelationResponse> {
    Util.validateModel(request);
    return $tea.cast<DeleteConsumerGroupSubscribeRelationResponse>(await this.doRequest("DeleteConsumerGroupSubscribeRelation", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new DeleteConsumerGroupSubscribeRelationResponse({}));
  }

  async deleteConsumerGroupSubscribeRelation(request: DeleteConsumerGroupSubscribeRelationRequest): Promise<DeleteConsumerGroupSubscribeRelationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteConsumerGroupSubscribeRelationWithOptions(request, runtime);
  }

  async deleteDataSourceItemWithOptions(request: DeleteDataSourceItemRequest, runtime: $Util.RuntimeOptions): Promise<DeleteDataSourceItemResponse> {
    Util.validateModel(request);
    return $tea.cast<DeleteDataSourceItemResponse>(await this.doRequest("DeleteDataSourceItem", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new DeleteDataSourceItemResponse({}));
  }

  async deleteDataSourceItem(request: DeleteDataSourceItemRequest): Promise<DeleteDataSourceItemResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteDataSourceItemWithOptions(request, runtime);
  }

  async deleteDestinationWithOptions(request: DeleteDestinationRequest, runtime: $Util.RuntimeOptions): Promise<DeleteDestinationResponse> {
    Util.validateModel(request);
    return $tea.cast<DeleteDestinationResponse>(await this.doRequest("DeleteDestination", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new DeleteDestinationResponse({}));
  }

  async deleteDestination(request: DeleteDestinationRequest): Promise<DeleteDestinationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteDestinationWithOptions(request, runtime);
  }

  async deleteDeviceWithOptions(request: DeleteDeviceRequest, runtime: $Util.RuntimeOptions): Promise<DeleteDeviceResponse> {
    Util.validateModel(request);
    return $tea.cast<DeleteDeviceResponse>(await this.doRequest("DeleteDevice", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new DeleteDeviceResponse({}));
  }

  async deleteDevice(request: DeleteDeviceRequest): Promise<DeleteDeviceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteDeviceWithOptions(request, runtime);
  }

  async deleteDeviceDistributeJobWithOptions(request: DeleteDeviceDistributeJobRequest, runtime: $Util.RuntimeOptions): Promise<DeleteDeviceDistributeJobResponse> {
    Util.validateModel(request);
    return $tea.cast<DeleteDeviceDistributeJobResponse>(await this.doRequest("DeleteDeviceDistributeJob", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new DeleteDeviceDistributeJobResponse({}));
  }

  async deleteDeviceDistributeJob(request: DeleteDeviceDistributeJobRequest): Promise<DeleteDeviceDistributeJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteDeviceDistributeJobWithOptions(request, runtime);
  }

  async deleteDeviceDynamicGroupWithOptions(request: DeleteDeviceDynamicGroupRequest, runtime: $Util.RuntimeOptions): Promise<DeleteDeviceDynamicGroupResponse> {
    Util.validateModel(request);
    return $tea.cast<DeleteDeviceDynamicGroupResponse>(await this.doRequest("DeleteDeviceDynamicGroup", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new DeleteDeviceDynamicGroupResponse({}));
  }

  async deleteDeviceDynamicGroup(request: DeleteDeviceDynamicGroupRequest): Promise<DeleteDeviceDynamicGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteDeviceDynamicGroupWithOptions(request, runtime);
  }

  async deleteDeviceFileWithOptions(request: DeleteDeviceFileRequest, runtime: $Util.RuntimeOptions): Promise<DeleteDeviceFileResponse> {
    Util.validateModel(request);
    return $tea.cast<DeleteDeviceFileResponse>(await this.doRequest("DeleteDeviceFile", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new DeleteDeviceFileResponse({}));
  }

  async deleteDeviceFile(request: DeleteDeviceFileRequest): Promise<DeleteDeviceFileResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteDeviceFileWithOptions(request, runtime);
  }

  async deleteDeviceGroupWithOptions(request: DeleteDeviceGroupRequest, runtime: $Util.RuntimeOptions): Promise<DeleteDeviceGroupResponse> {
    Util.validateModel(request);
    return $tea.cast<DeleteDeviceGroupResponse>(await this.doRequest("DeleteDeviceGroup", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new DeleteDeviceGroupResponse({}));
  }

  async deleteDeviceGroup(request: DeleteDeviceGroupRequest): Promise<DeleteDeviceGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteDeviceGroupWithOptions(request, runtime);
  }

  async deleteDevicePropWithOptions(request: DeleteDevicePropRequest, runtime: $Util.RuntimeOptions): Promise<DeleteDevicePropResponse> {
    Util.validateModel(request);
    return $tea.cast<DeleteDevicePropResponse>(await this.doRequest("DeleteDeviceProp", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new DeleteDevicePropResponse({}));
  }

  async deleteDeviceProp(request: DeleteDevicePropRequest): Promise<DeleteDevicePropResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteDevicePropWithOptions(request, runtime);
  }

  async deleteDeviceSpeechWithOptions(request: DeleteDeviceSpeechRequest, runtime: $Util.RuntimeOptions): Promise<DeleteDeviceSpeechResponse> {
    Util.validateModel(request);
    return $tea.cast<DeleteDeviceSpeechResponse>(await this.doRequest("DeleteDeviceSpeech", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new DeleteDeviceSpeechResponse({}));
  }

  async deleteDeviceSpeech(request: DeleteDeviceSpeechRequest): Promise<DeleteDeviceSpeechResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteDeviceSpeechWithOptions(request, runtime);
  }

  async deleteDeviceTunnelWithOptions(request: DeleteDeviceTunnelRequest, runtime: $Util.RuntimeOptions): Promise<DeleteDeviceTunnelResponse> {
    Util.validateModel(request);
    return $tea.cast<DeleteDeviceTunnelResponse>(await this.doRequest("DeleteDeviceTunnel", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new DeleteDeviceTunnelResponse({}));
  }

  async deleteDeviceTunnel(request: DeleteDeviceTunnelRequest): Promise<DeleteDeviceTunnelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteDeviceTunnelWithOptions(request, runtime);
  }

  async deleteEdgeDriverWithOptions(request: DeleteEdgeDriverRequest, runtime: $Util.RuntimeOptions): Promise<DeleteEdgeDriverResponse> {
    Util.validateModel(request);
    return $tea.cast<DeleteEdgeDriverResponse>(await this.doRequest("DeleteEdgeDriver", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new DeleteEdgeDriverResponse({}));
  }

  async deleteEdgeDriver(request: DeleteEdgeDriverRequest): Promise<DeleteEdgeDriverResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteEdgeDriverWithOptions(request, runtime);
  }

  async deleteEdgeDriverVersionWithOptions(request: DeleteEdgeDriverVersionRequest, runtime: $Util.RuntimeOptions): Promise<DeleteEdgeDriverVersionResponse> {
    Util.validateModel(request);
    return $tea.cast<DeleteEdgeDriverVersionResponse>(await this.doRequest("DeleteEdgeDriverVersion", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new DeleteEdgeDriverVersionResponse({}));
  }

  async deleteEdgeDriverVersion(request: DeleteEdgeDriverVersionRequest): Promise<DeleteEdgeDriverVersionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteEdgeDriverVersionWithOptions(request, runtime);
  }

  async deleteEdgeInstanceWithOptions(request: DeleteEdgeInstanceRequest, runtime: $Util.RuntimeOptions): Promise<DeleteEdgeInstanceResponse> {
    Util.validateModel(request);
    return $tea.cast<DeleteEdgeInstanceResponse>(await this.doRequest("DeleteEdgeInstance", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new DeleteEdgeInstanceResponse({}));
  }

  async deleteEdgeInstance(request: DeleteEdgeInstanceRequest): Promise<DeleteEdgeInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteEdgeInstanceWithOptions(request, runtime);
  }

  async deleteEdgeInstanceMessageRoutingWithOptions(request: DeleteEdgeInstanceMessageRoutingRequest, runtime: $Util.RuntimeOptions): Promise<DeleteEdgeInstanceMessageRoutingResponse> {
    Util.validateModel(request);
    return $tea.cast<DeleteEdgeInstanceMessageRoutingResponse>(await this.doRequest("DeleteEdgeInstanceMessageRouting", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new DeleteEdgeInstanceMessageRoutingResponse({}));
  }

  async deleteEdgeInstanceMessageRouting(request: DeleteEdgeInstanceMessageRoutingRequest): Promise<DeleteEdgeInstanceMessageRoutingResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteEdgeInstanceMessageRoutingWithOptions(request, runtime);
  }

  async deleteJobWithOptions(request: DeleteJobRequest, runtime: $Util.RuntimeOptions): Promise<DeleteJobResponse> {
    Util.validateModel(request);
    return $tea.cast<DeleteJobResponse>(await this.doRequest("DeleteJob", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new DeleteJobResponse({}));
  }

  async deleteJob(request: DeleteJobRequest): Promise<DeleteJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteJobWithOptions(request, runtime);
  }

  async deleteOTAFirmwareWithOptions(request: DeleteOTAFirmwareRequest, runtime: $Util.RuntimeOptions): Promise<DeleteOTAFirmwareResponse> {
    Util.validateModel(request);
    return $tea.cast<DeleteOTAFirmwareResponse>(await this.doRequest("DeleteOTAFirmware", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new DeleteOTAFirmwareResponse({}));
  }

  async deleteOTAFirmware(request: DeleteOTAFirmwareRequest): Promise<DeleteOTAFirmwareResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteOTAFirmwareWithOptions(request, runtime);
  }

  async deleteOTAModuleWithOptions(request: DeleteOTAModuleRequest, runtime: $Util.RuntimeOptions): Promise<DeleteOTAModuleResponse> {
    Util.validateModel(request);
    return $tea.cast<DeleteOTAModuleResponse>(await this.doRequest("DeleteOTAModule", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new DeleteOTAModuleResponse({}));
  }

  async deleteOTAModule(request: DeleteOTAModuleRequest): Promise<DeleteOTAModuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteOTAModuleWithOptions(request, runtime);
  }

  async deleteParserWithOptions(request: DeleteParserRequest, runtime: $Util.RuntimeOptions): Promise<DeleteParserResponse> {
    Util.validateModel(request);
    return $tea.cast<DeleteParserResponse>(await this.doRequest("DeleteParser", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new DeleteParserResponse({}));
  }

  async deleteParser(request: DeleteParserRequest): Promise<DeleteParserResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteParserWithOptions(request, runtime);
  }

  async deleteParserDataSourceWithOptions(request: DeleteParserDataSourceRequest, runtime: $Util.RuntimeOptions): Promise<DeleteParserDataSourceResponse> {
    Util.validateModel(request);
    return $tea.cast<DeleteParserDataSourceResponse>(await this.doRequest("DeleteParserDataSource", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new DeleteParserDataSourceResponse({}));
  }

  async deleteParserDataSource(request: DeleteParserDataSourceRequest): Promise<DeleteParserDataSourceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteParserDataSourceWithOptions(request, runtime);
  }

  async deleteProductWithOptions(request: DeleteProductRequest, runtime: $Util.RuntimeOptions): Promise<DeleteProductResponse> {
    Util.validateModel(request);
    return $tea.cast<DeleteProductResponse>(await this.doRequest("DeleteProduct", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new DeleteProductResponse({}));
  }

  async deleteProduct(request: DeleteProductRequest): Promise<DeleteProductResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteProductWithOptions(request, runtime);
  }

  async deleteProductTagsWithOptions(request: DeleteProductTagsRequest, runtime: $Util.RuntimeOptions): Promise<DeleteProductTagsResponse> {
    Util.validateModel(request);
    return $tea.cast<DeleteProductTagsResponse>(await this.doRequest("DeleteProductTags", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new DeleteProductTagsResponse({}));
  }

  async deleteProductTags(request: DeleteProductTagsRequest): Promise<DeleteProductTagsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteProductTagsWithOptions(request, runtime);
  }

  async deleteProductTopicWithOptions(request: DeleteProductTopicRequest, runtime: $Util.RuntimeOptions): Promise<DeleteProductTopicResponse> {
    Util.validateModel(request);
    return $tea.cast<DeleteProductTopicResponse>(await this.doRequest("DeleteProductTopic", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new DeleteProductTopicResponse({}));
  }

  async deleteProductTopic(request: DeleteProductTopicRequest): Promise<DeleteProductTopicResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteProductTopicWithOptions(request, runtime);
  }

  async deleteRuleWithOptions(request: DeleteRuleRequest, runtime: $Util.RuntimeOptions): Promise<DeleteRuleResponse> {
    Util.validateModel(request);
    return $tea.cast<DeleteRuleResponse>(await this.doRequest("DeleteRule", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new DeleteRuleResponse({}));
  }

  async deleteRule(request: DeleteRuleRequest): Promise<DeleteRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteRuleWithOptions(request, runtime);
  }

  async deleteRuleActionWithOptions(request: DeleteRuleActionRequest, runtime: $Util.RuntimeOptions): Promise<DeleteRuleActionResponse> {
    Util.validateModel(request);
    return $tea.cast<DeleteRuleActionResponse>(await this.doRequest("DeleteRuleAction", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new DeleteRuleActionResponse({}));
  }

  async deleteRuleAction(request: DeleteRuleActionRequest): Promise<DeleteRuleActionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteRuleActionWithOptions(request, runtime);
  }

  async deleteSceneRuleWithOptions(request: DeleteSceneRuleRequest, runtime: $Util.RuntimeOptions): Promise<DeleteSceneRuleResponse> {
    Util.validateModel(request);
    return $tea.cast<DeleteSceneRuleResponse>(await this.doRequest("DeleteSceneRule", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new DeleteSceneRuleResponse({}));
  }

  async deleteSceneRule(request: DeleteSceneRuleRequest): Promise<DeleteSceneRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteSceneRuleWithOptions(request, runtime);
  }

  async deleteSchedulePeriodWithOptions(request: DeleteSchedulePeriodRequest, runtime: $Util.RuntimeOptions): Promise<DeleteSchedulePeriodResponse> {
    Util.validateModel(request);
    return $tea.cast<DeleteSchedulePeriodResponse>(await this.doRequest("DeleteSchedulePeriod", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new DeleteSchedulePeriodResponse({}));
  }

  async deleteSchedulePeriod(request: DeleteSchedulePeriodRequest): Promise<DeleteSchedulePeriodResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteSchedulePeriodWithOptions(request, runtime);
  }

  async deleteShareTaskDeviceWithOptions(request: DeleteShareTaskDeviceRequest, runtime: $Util.RuntimeOptions): Promise<DeleteShareTaskDeviceResponse> {
    Util.validateModel(request);
    return $tea.cast<DeleteShareTaskDeviceResponse>(await this.doRequest("DeleteShareTaskDevice", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new DeleteShareTaskDeviceResponse({}));
  }

  async deleteShareTaskDevice(request: DeleteShareTaskDeviceRequest): Promise<DeleteShareTaskDeviceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteShareTaskDeviceWithOptions(request, runtime);
  }

  async deleteSoundCodeWithOptions(request: DeleteSoundCodeRequest, runtime: $Util.RuntimeOptions): Promise<DeleteSoundCodeResponse> {
    Util.validateModel(request);
    return $tea.cast<DeleteSoundCodeResponse>(await this.doRequest("DeleteSoundCode", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new DeleteSoundCodeResponse({}));
  }

  async deleteSoundCode(request: DeleteSoundCodeRequest): Promise<DeleteSoundCodeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteSoundCodeWithOptions(request, runtime);
  }

  async deleteSoundCodeLabelWithOptions(request: DeleteSoundCodeLabelRequest, runtime: $Util.RuntimeOptions): Promise<DeleteSoundCodeLabelResponse> {
    Util.validateModel(request);
    return $tea.cast<DeleteSoundCodeLabelResponse>(await this.doRequest("DeleteSoundCodeLabel", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new DeleteSoundCodeLabelResponse({}));
  }

  async deleteSoundCodeLabel(request: DeleteSoundCodeLabelRequest): Promise<DeleteSoundCodeLabelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteSoundCodeLabelWithOptions(request, runtime);
  }

  async deleteSoundCodeScheduleWithOptions(request: DeleteSoundCodeScheduleRequest, runtime: $Util.RuntimeOptions): Promise<DeleteSoundCodeScheduleResponse> {
    Util.validateModel(request);
    return $tea.cast<DeleteSoundCodeScheduleResponse>(await this.doRequest("DeleteSoundCodeSchedule", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new DeleteSoundCodeScheduleResponse({}));
  }

  async deleteSoundCodeSchedule(request: DeleteSoundCodeScheduleRequest): Promise<DeleteSoundCodeScheduleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteSoundCodeScheduleWithOptions(request, runtime);
  }

  async deleteSpeechWithOptions(request: DeleteSpeechRequest, runtime: $Util.RuntimeOptions): Promise<DeleteSpeechResponse> {
    Util.validateModel(request);
    return $tea.cast<DeleteSpeechResponse>(await this.doRequest("DeleteSpeech", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new DeleteSpeechResponse({}));
  }

  async deleteSpeech(request: DeleteSpeechRequest): Promise<DeleteSpeechResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteSpeechWithOptions(request, runtime);
  }

  async deleteStudioAppDomainOpenWithOptions(request: DeleteStudioAppDomainOpenRequest, runtime: $Util.RuntimeOptions): Promise<DeleteStudioAppDomainOpenResponse> {
    Util.validateModel(request);
    return $tea.cast<DeleteStudioAppDomainOpenResponse>(await this.doRequest("DeleteStudioAppDomainOpen", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new DeleteStudioAppDomainOpenResponse({}));
  }

  async deleteStudioAppDomainOpen(request: DeleteStudioAppDomainOpenRequest): Promise<DeleteStudioAppDomainOpenResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteStudioAppDomainOpenWithOptions(request, runtime);
  }

  async deleteSubscribeRelationWithOptions(request: DeleteSubscribeRelationRequest, runtime: $Util.RuntimeOptions): Promise<DeleteSubscribeRelationResponse> {
    Util.validateModel(request);
    return $tea.cast<DeleteSubscribeRelationResponse>(await this.doRequest("DeleteSubscribeRelation", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new DeleteSubscribeRelationResponse({}));
  }

  async deleteSubscribeRelation(request: DeleteSubscribeRelationRequest): Promise<DeleteSubscribeRelationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteSubscribeRelationWithOptions(request, runtime);
  }

  async deleteThingModelWithOptions(request: DeleteThingModelRequest, runtime: $Util.RuntimeOptions): Promise<DeleteThingModelResponse> {
    Util.validateModel(request);
    return $tea.cast<DeleteThingModelResponse>(await this.doRequest("DeleteThingModel", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new DeleteThingModelResponse({}));
  }

  async deleteThingModel(request: DeleteThingModelRequest): Promise<DeleteThingModelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteThingModelWithOptions(request, runtime);
  }

  async deleteTopicRouteTableWithOptions(request: DeleteTopicRouteTableRequest, runtime: $Util.RuntimeOptions): Promise<DeleteTopicRouteTableResponse> {
    Util.validateModel(request);
    return $tea.cast<DeleteTopicRouteTableResponse>(await this.doRequest("DeleteTopicRouteTable", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new DeleteTopicRouteTableResponse({}));
  }

  async deleteTopicRouteTable(request: DeleteTopicRouteTableRequest): Promise<DeleteTopicRouteTableResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteTopicRouteTableWithOptions(request, runtime);
  }

  async detachDestinationWithOptions(request: DetachDestinationRequest, runtime: $Util.RuntimeOptions): Promise<DetachDestinationResponse> {
    Util.validateModel(request);
    return $tea.cast<DetachDestinationResponse>(await this.doRequest("DetachDestination", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new DetachDestinationResponse({}));
  }

  async detachDestination(request: DetachDestinationRequest): Promise<DetachDestinationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.detachDestinationWithOptions(request, runtime);
  }

  async detachParserDataSourceWithOptions(request: DetachParserDataSourceRequest, runtime: $Util.RuntimeOptions): Promise<DetachParserDataSourceResponse> {
    Util.validateModel(request);
    return $tea.cast<DetachParserDataSourceResponse>(await this.doRequest("DetachParserDataSource", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new DetachParserDataSourceResponse({}));
  }

  async detachParserDataSource(request: DetachParserDataSourceRequest): Promise<DetachParserDataSourceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.detachParserDataSourceWithOptions(request, runtime);
  }

  async disableDeviceTunnelWithOptions(request: DisableDeviceTunnelRequest, runtime: $Util.RuntimeOptions): Promise<DisableDeviceTunnelResponse> {
    Util.validateModel(request);
    return $tea.cast<DisableDeviceTunnelResponse>(await this.doRequest("DisableDeviceTunnel", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new DisableDeviceTunnelResponse({}));
  }

  async disableDeviceTunnel(request: DisableDeviceTunnelRequest): Promise<DisableDeviceTunnelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.disableDeviceTunnelWithOptions(request, runtime);
  }

  async disableDeviceTunnelShareWithOptions(request: DisableDeviceTunnelShareRequest, runtime: $Util.RuntimeOptions): Promise<DisableDeviceTunnelShareResponse> {
    Util.validateModel(request);
    return $tea.cast<DisableDeviceTunnelShareResponse>(await this.doRequest("DisableDeviceTunnelShare", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new DisableDeviceTunnelShareResponse({}));
  }

  async disableDeviceTunnelShare(request: DisableDeviceTunnelShareRequest): Promise<DisableDeviceTunnelShareResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.disableDeviceTunnelShareWithOptions(request, runtime);
  }

  async disableSceneRuleWithOptions(request: DisableSceneRuleRequest, runtime: $Util.RuntimeOptions): Promise<DisableSceneRuleResponse> {
    Util.validateModel(request);
    return $tea.cast<DisableSceneRuleResponse>(await this.doRequest("DisableSceneRule", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new DisableSceneRuleResponse({}));
  }

  async disableSceneRule(request: DisableSceneRuleRequest): Promise<DisableSceneRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.disableSceneRuleWithOptions(request, runtime);
  }

  async disableThingWithOptions(request: DisableThingRequest, runtime: $Util.RuntimeOptions): Promise<DisableThingResponse> {
    Util.validateModel(request);
    return $tea.cast<DisableThingResponse>(await this.doRequest("DisableThing", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new DisableThingResponse({}));
  }

  async disableThing(request: DisableThingRequest): Promise<DisableThingResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.disableThingWithOptions(request, runtime);
  }

  async enableDeviceTunnelWithOptions(request: EnableDeviceTunnelRequest, runtime: $Util.RuntimeOptions): Promise<EnableDeviceTunnelResponse> {
    Util.validateModel(request);
    return $tea.cast<EnableDeviceTunnelResponse>(await this.doRequest("EnableDeviceTunnel", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new EnableDeviceTunnelResponse({}));
  }

  async enableDeviceTunnel(request: EnableDeviceTunnelRequest): Promise<EnableDeviceTunnelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.enableDeviceTunnelWithOptions(request, runtime);
  }

  async enableDeviceTunnelShareWithOptions(request: EnableDeviceTunnelShareRequest, runtime: $Util.RuntimeOptions): Promise<EnableDeviceTunnelShareResponse> {
    Util.validateModel(request);
    return $tea.cast<EnableDeviceTunnelShareResponse>(await this.doRequest("EnableDeviceTunnelShare", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new EnableDeviceTunnelShareResponse({}));
  }

  async enableDeviceTunnelShare(request: EnableDeviceTunnelShareRequest): Promise<EnableDeviceTunnelShareResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.enableDeviceTunnelShareWithOptions(request, runtime);
  }

  async enableSceneRuleWithOptions(request: EnableSceneRuleRequest, runtime: $Util.RuntimeOptions): Promise<EnableSceneRuleResponse> {
    Util.validateModel(request);
    return $tea.cast<EnableSceneRuleResponse>(await this.doRequest("EnableSceneRule", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new EnableSceneRuleResponse({}));
  }

  async enableSceneRule(request: EnableSceneRuleRequest): Promise<EnableSceneRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.enableSceneRuleWithOptions(request, runtime);
  }

  async enableThingWithOptions(request: EnableThingRequest, runtime: $Util.RuntimeOptions): Promise<EnableThingResponse> {
    Util.validateModel(request);
    return $tea.cast<EnableThingResponse>(await this.doRequest("EnableThing", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new EnableThingResponse({}));
  }

  async enableThing(request: EnableThingRequest): Promise<EnableThingResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.enableThingWithOptions(request, runtime);
  }

  async generateDeviceNameListURLWithOptions(request: GenerateDeviceNameListURLRequest, runtime: $Util.RuntimeOptions): Promise<GenerateDeviceNameListURLResponse> {
    Util.validateModel(request);
    return $tea.cast<GenerateDeviceNameListURLResponse>(await this.doRequest("GenerateDeviceNameListURL", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new GenerateDeviceNameListURLResponse({}));
  }

  async generateDeviceNameListURL(request: GenerateDeviceNameListURLRequest): Promise<GenerateDeviceNameListURLResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.generateDeviceNameListURLWithOptions(request, runtime);
  }

  async generateFileUploadURLWithOptions(request: GenerateFileUploadURLRequest, runtime: $Util.RuntimeOptions): Promise<GenerateFileUploadURLResponse> {
    Util.validateModel(request);
    return $tea.cast<GenerateFileUploadURLResponse>(await this.doRequest("GenerateFileUploadURL", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new GenerateFileUploadURLResponse({}));
  }

  async generateFileUploadURL(request: GenerateFileUploadURLRequest): Promise<GenerateFileUploadURLResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.generateFileUploadURLWithOptions(request, runtime);
  }

  async generateOTAUploadURLWithOptions(request: GenerateOTAUploadURLRequest, runtime: $Util.RuntimeOptions): Promise<GenerateOTAUploadURLResponse> {
    Util.validateModel(request);
    return $tea.cast<GenerateOTAUploadURLResponse>(await this.doRequest("GenerateOTAUploadURL", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new GenerateOTAUploadURLResponse({}));
  }

  async generateOTAUploadURL(request: GenerateOTAUploadURLRequest): Promise<GenerateOTAUploadURLResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.generateOTAUploadURLWithOptions(request, runtime);
  }

  async getDataAPIServiceDetailWithOptions(request: GetDataAPIServiceDetailRequest, runtime: $Util.RuntimeOptions): Promise<GetDataAPIServiceDetailResponse> {
    Util.validateModel(request);
    return $tea.cast<GetDataAPIServiceDetailResponse>(await this.doRequest("GetDataAPIServiceDetail", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new GetDataAPIServiceDetailResponse({}));
  }

  async getDataAPIServiceDetail(request: GetDataAPIServiceDetailRequest): Promise<GetDataAPIServiceDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDataAPIServiceDetailWithOptions(request, runtime);
  }

  async getDestinationWithOptions(request: GetDestinationRequest, runtime: $Util.RuntimeOptions): Promise<GetDestinationResponse> {
    Util.validateModel(request);
    return $tea.cast<GetDestinationResponse>(await this.doRequest("GetDestination", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new GetDestinationResponse({}));
  }

  async getDestination(request: GetDestinationRequest): Promise<GetDestinationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDestinationWithOptions(request, runtime);
  }

  async getDeviceShadowWithOptions(request: GetDeviceShadowRequest, runtime: $Util.RuntimeOptions): Promise<GetDeviceShadowResponse> {
    Util.validateModel(request);
    return $tea.cast<GetDeviceShadowResponse>(await this.doRequest("GetDeviceShadow", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new GetDeviceShadowResponse({}));
  }

  async getDeviceShadow(request: GetDeviceShadowRequest): Promise<GetDeviceShadowResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDeviceShadowWithOptions(request, runtime);
  }

  async getDeviceStatusWithOptions(request: GetDeviceStatusRequest, runtime: $Util.RuntimeOptions): Promise<GetDeviceStatusResponse> {
    Util.validateModel(request);
    return $tea.cast<GetDeviceStatusResponse>(await this.doRequest("GetDeviceStatus", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new GetDeviceStatusResponse({}));
  }

  async getDeviceStatus(request: GetDeviceStatusRequest): Promise<GetDeviceStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDeviceStatusWithOptions(request, runtime);
  }

  async getDeviceTunnelShareStatusWithOptions(request: GetDeviceTunnelShareStatusRequest, runtime: $Util.RuntimeOptions): Promise<GetDeviceTunnelShareStatusResponse> {
    Util.validateModel(request);
    return $tea.cast<GetDeviceTunnelShareStatusResponse>(await this.doRequest("GetDeviceTunnelShareStatus", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new GetDeviceTunnelShareStatusResponse({}));
  }

  async getDeviceTunnelShareStatus(request: GetDeviceTunnelShareStatusRequest): Promise<GetDeviceTunnelShareStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDeviceTunnelShareStatusWithOptions(request, runtime);
  }

  async getDeviceTunnelStatusWithOptions(request: GetDeviceTunnelStatusRequest, runtime: $Util.RuntimeOptions): Promise<GetDeviceTunnelStatusResponse> {
    Util.validateModel(request);
    return $tea.cast<GetDeviceTunnelStatusResponse>(await this.doRequest("GetDeviceTunnelStatus", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new GetDeviceTunnelStatusResponse({}));
  }

  async getDeviceTunnelStatus(request: GetDeviceTunnelStatusRequest): Promise<GetDeviceTunnelStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDeviceTunnelStatusWithOptions(request, runtime);
  }

  async getDownloadFileWithOptions(tmp: GetDownloadFileRequest, runtime: $Util.RuntimeOptions): Promise<GetDownloadFileResponse> {
    Util.validateModel(tmp);
    let request = new GetDownloadFileShrinkRequest({ });
    RPCUtil.convert(tmp, request);
    if (!Util.isUnset(tmp.context)) {
      request.contextShrink = Util.toJSONString(tmp.context);
    }

    return $tea.cast<GetDownloadFileResponse>(await this.doRequest("GetDownloadFile", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new GetDownloadFileResponse({}));
  }

  async getDownloadFile(request: GetDownloadFileRequest): Promise<GetDownloadFileResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDownloadFileWithOptions(request, runtime);
  }

  async getEdgeDriverVersionWithOptions(request: GetEdgeDriverVersionRequest, runtime: $Util.RuntimeOptions): Promise<GetEdgeDriverVersionResponse> {
    Util.validateModel(request);
    return $tea.cast<GetEdgeDriverVersionResponse>(await this.doRequest("GetEdgeDriverVersion", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new GetEdgeDriverVersionResponse({}));
  }

  async getEdgeDriverVersion(request: GetEdgeDriverVersionRequest): Promise<GetEdgeDriverVersionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getEdgeDriverVersionWithOptions(request, runtime);
  }

  async getEdgeInstanceWithOptions(request: GetEdgeInstanceRequest, runtime: $Util.RuntimeOptions): Promise<GetEdgeInstanceResponse> {
    Util.validateModel(request);
    return $tea.cast<GetEdgeInstanceResponse>(await this.doRequest("GetEdgeInstance", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new GetEdgeInstanceResponse({}));
  }

  async getEdgeInstance(request: GetEdgeInstanceRequest): Promise<GetEdgeInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getEdgeInstanceWithOptions(request, runtime);
  }

  async getEdgeInstanceDeploymentWithOptions(request: GetEdgeInstanceDeploymentRequest, runtime: $Util.RuntimeOptions): Promise<GetEdgeInstanceDeploymentResponse> {
    Util.validateModel(request);
    return $tea.cast<GetEdgeInstanceDeploymentResponse>(await this.doRequest("GetEdgeInstanceDeployment", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new GetEdgeInstanceDeploymentResponse({}));
  }

  async getEdgeInstanceDeployment(request: GetEdgeInstanceDeploymentRequest): Promise<GetEdgeInstanceDeploymentResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getEdgeInstanceDeploymentWithOptions(request, runtime);
  }

  async getEdgeInstanceMessageRoutingWithOptions(request: GetEdgeInstanceMessageRoutingRequest, runtime: $Util.RuntimeOptions): Promise<GetEdgeInstanceMessageRoutingResponse> {
    Util.validateModel(request);
    return $tea.cast<GetEdgeInstanceMessageRoutingResponse>(await this.doRequest("GetEdgeInstanceMessageRouting", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new GetEdgeInstanceMessageRoutingResponse({}));
  }

  async getEdgeInstanceMessageRouting(request: GetEdgeInstanceMessageRoutingRequest): Promise<GetEdgeInstanceMessageRoutingResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getEdgeInstanceMessageRoutingWithOptions(request, runtime);
  }

  async getGatewayBySubDeviceWithOptions(request: GetGatewayBySubDeviceRequest, runtime: $Util.RuntimeOptions): Promise<GetGatewayBySubDeviceResponse> {
    Util.validateModel(request);
    return $tea.cast<GetGatewayBySubDeviceResponse>(await this.doRequest("GetGatewayBySubDevice", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new GetGatewayBySubDeviceResponse({}));
  }

  async getGatewayBySubDevice(request: GetGatewayBySubDeviceRequest): Promise<GetGatewayBySubDeviceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getGatewayBySubDeviceWithOptions(request, runtime);
  }

  async getLoraNodesTaskWithOptions(request: GetLoraNodesTaskRequest, runtime: $Util.RuntimeOptions): Promise<GetLoraNodesTaskResponse> {
    Util.validateModel(request);
    return $tea.cast<GetLoraNodesTaskResponse>(await this.doRequest("GetLoraNodesTask", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new GetLoraNodesTaskResponse({}));
  }

  async getLoraNodesTask(request: GetLoraNodesTaskRequest): Promise<GetLoraNodesTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getLoraNodesTaskWithOptions(request, runtime);
  }

  async getParserWithOptions(request: GetParserRequest, runtime: $Util.RuntimeOptions): Promise<GetParserResponse> {
    Util.validateModel(request);
    return $tea.cast<GetParserResponse>(await this.doRequest("GetParser", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new GetParserResponse({}));
  }

  async getParser(request: GetParserRequest): Promise<GetParserResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getParserWithOptions(request, runtime);
  }

  async getParserDataSourceWithOptions(request: GetParserDataSourceRequest, runtime: $Util.RuntimeOptions): Promise<GetParserDataSourceResponse> {
    Util.validateModel(request);
    return $tea.cast<GetParserDataSourceResponse>(await this.doRequest("GetParserDataSource", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new GetParserDataSourceResponse({}));
  }

  async getParserDataSource(request: GetParserDataSourceRequest): Promise<GetParserDataSourceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getParserDataSourceWithOptions(request, runtime);
  }

  async getRuleWithOptions(request: GetRuleRequest, runtime: $Util.RuntimeOptions): Promise<GetRuleResponse> {
    Util.validateModel(request);
    return $tea.cast<GetRuleResponse>(await this.doRequest("GetRule", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new GetRuleResponse({}));
  }

  async getRule(request: GetRuleRequest): Promise<GetRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getRuleWithOptions(request, runtime);
  }

  async getRuleActionWithOptions(request: GetRuleActionRequest, runtime: $Util.RuntimeOptions): Promise<GetRuleActionResponse> {
    Util.validateModel(request);
    return $tea.cast<GetRuleActionResponse>(await this.doRequest("GetRuleAction", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new GetRuleActionResponse({}));
  }

  async getRuleAction(request: GetRuleActionRequest): Promise<GetRuleActionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getRuleActionWithOptions(request, runtime);
  }

  async getSceneRuleWithOptions(request: GetSceneRuleRequest, runtime: $Util.RuntimeOptions): Promise<GetSceneRuleResponse> {
    Util.validateModel(request);
    return $tea.cast<GetSceneRuleResponse>(await this.doRequest("GetSceneRule", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new GetSceneRuleResponse({}));
  }

  async getSceneRule(request: GetSceneRuleRequest): Promise<GetSceneRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getSceneRuleWithOptions(request, runtime);
  }

  async getShareTaskByDeviceOpenWithOptions(request: GetShareTaskByDeviceOpenRequest, runtime: $Util.RuntimeOptions): Promise<GetShareTaskByDeviceOpenResponse> {
    Util.validateModel(request);
    return $tea.cast<GetShareTaskByDeviceOpenResponse>(await this.doRequest("GetShareTaskByDeviceOpen", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new GetShareTaskByDeviceOpenResponse({}));
  }

  async getShareTaskByDeviceOpen(request: GetShareTaskByDeviceOpenRequest): Promise<GetShareTaskByDeviceOpenResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getShareTaskByDeviceOpenWithOptions(request, runtime);
  }

  async getSoundCodeAudioWithOptions(request: GetSoundCodeAudioRequest, runtime: $Util.RuntimeOptions): Promise<GetSoundCodeAudioResponse> {
    Util.validateModel(request);
    return $tea.cast<GetSoundCodeAudioResponse>(await this.doRequest("GetSoundCodeAudio", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new GetSoundCodeAudioResponse({}));
  }

  async getSoundCodeAudio(request: GetSoundCodeAudioRequest): Promise<GetSoundCodeAudioResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getSoundCodeAudioWithOptions(request, runtime);
  }

  async getSoundCodeScheduleWithOptions(request: GetSoundCodeScheduleRequest, runtime: $Util.RuntimeOptions): Promise<GetSoundCodeScheduleResponse> {
    Util.validateModel(request);
    return $tea.cast<GetSoundCodeScheduleResponse>(await this.doRequest("GetSoundCodeSchedule", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new GetSoundCodeScheduleResponse({}));
  }

  async getSoundCodeSchedule(request: GetSoundCodeScheduleRequest): Promise<GetSoundCodeScheduleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getSoundCodeScheduleWithOptions(request, runtime);
  }

  async getSpeechDeviceDetailWithOptions(request: GetSpeechDeviceDetailRequest, runtime: $Util.RuntimeOptions): Promise<GetSpeechDeviceDetailResponse> {
    Util.validateModel(request);
    return $tea.cast<GetSpeechDeviceDetailResponse>(await this.doRequest("GetSpeechDeviceDetail", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new GetSpeechDeviceDetailResponse({}));
  }

  async getSpeechDeviceDetail(request: GetSpeechDeviceDetailRequest): Promise<GetSpeechDeviceDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getSpeechDeviceDetailWithOptions(request, runtime);
  }

  async getSpeechLicenseDeviceStatisticsWithOptions(request: GetSpeechLicenseDeviceStatisticsRequest, runtime: $Util.RuntimeOptions): Promise<GetSpeechLicenseDeviceStatisticsResponse> {
    Util.validateModel(request);
    return $tea.cast<GetSpeechLicenseDeviceStatisticsResponse>(await this.doRequest("GetSpeechLicenseDeviceStatistics", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new GetSpeechLicenseDeviceStatisticsResponse({}));
  }

  async getSpeechLicenseDeviceStatistics(request: GetSpeechLicenseDeviceStatisticsRequest): Promise<GetSpeechLicenseDeviceStatisticsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getSpeechLicenseDeviceStatisticsWithOptions(request, runtime);
  }

  async getSpeechVoiceWithOptions(request: GetSpeechVoiceRequest, runtime: $Util.RuntimeOptions): Promise<GetSpeechVoiceResponse> {
    Util.validateModel(request);
    return $tea.cast<GetSpeechVoiceResponse>(await this.doRequest("GetSpeechVoice", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new GetSpeechVoiceResponse({}));
  }

  async getSpeechVoice(request: GetSpeechVoiceRequest): Promise<GetSpeechVoiceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getSpeechVoiceWithOptions(request, runtime);
  }

  async getStudioAppTokenOpenWithOptions(request: GetStudioAppTokenOpenRequest, runtime: $Util.RuntimeOptions): Promise<GetStudioAppTokenOpenResponse> {
    Util.validateModel(request);
    return $tea.cast<GetStudioAppTokenOpenResponse>(await this.doRequest("GetStudioAppTokenOpen", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new GetStudioAppTokenOpenResponse({}));
  }

  async getStudioAppTokenOpen(request: GetStudioAppTokenOpenRequest): Promise<GetStudioAppTokenOpenResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getStudioAppTokenOpenWithOptions(request, runtime);
  }

  async getThingModelTslWithOptions(request: GetThingModelTslRequest, runtime: $Util.RuntimeOptions): Promise<GetThingModelTslResponse> {
    Util.validateModel(request);
    return $tea.cast<GetThingModelTslResponse>(await this.doRequest("GetThingModelTsl", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new GetThingModelTslResponse({}));
  }

  async getThingModelTsl(request: GetThingModelTslRequest): Promise<GetThingModelTslResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getThingModelTslWithOptions(request, runtime);
  }

  async getThingModelTslPublishedWithOptions(request: GetThingModelTslPublishedRequest, runtime: $Util.RuntimeOptions): Promise<GetThingModelTslPublishedResponse> {
    Util.validateModel(request);
    return $tea.cast<GetThingModelTslPublishedResponse>(await this.doRequest("GetThingModelTslPublished", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new GetThingModelTslPublishedResponse({}));
  }

  async getThingModelTslPublished(request: GetThingModelTslPublishedRequest): Promise<GetThingModelTslPublishedResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getThingModelTslPublishedWithOptions(request, runtime);
  }

  async getThingScriptWithOptions(request: GetThingScriptRequest, runtime: $Util.RuntimeOptions): Promise<GetThingScriptResponse> {
    Util.validateModel(request);
    return $tea.cast<GetThingScriptResponse>(await this.doRequest("GetThingScript", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new GetThingScriptResponse({}));
  }

  async getThingScript(request: GetThingScriptRequest): Promise<GetThingScriptResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getThingScriptWithOptions(request, runtime);
  }

  async getThingTemplateWithOptions(request: GetThingTemplateRequest, runtime: $Util.RuntimeOptions): Promise<GetThingTemplateResponse> {
    Util.validateModel(request);
    return $tea.cast<GetThingTemplateResponse>(await this.doRequest("GetThingTemplate", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new GetThingTemplateResponse({}));
  }

  async getThingTemplate(request: GetThingTemplateRequest): Promise<GetThingTemplateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getThingTemplateWithOptions(request, runtime);
  }

  async getThingTopoWithOptions(request: GetThingTopoRequest, runtime: $Util.RuntimeOptions): Promise<GetThingTopoResponse> {
    Util.validateModel(request);
    return $tea.cast<GetThingTopoResponse>(await this.doRequest("GetThingTopo", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new GetThingTopoResponse({}));
  }

  async getThingTopo(request: GetThingTopoRequest): Promise<GetThingTopoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getThingTopoWithOptions(request, runtime);
  }

  async gisQueryDeviceLocationWithOptions(request: GisQueryDeviceLocationRequest, runtime: $Util.RuntimeOptions): Promise<GisQueryDeviceLocationResponse> {
    Util.validateModel(request);
    return $tea.cast<GisQueryDeviceLocationResponse>(await this.doRequest("GisQueryDeviceLocation", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new GisQueryDeviceLocationResponse({}));
  }

  async gisQueryDeviceLocation(request: GisQueryDeviceLocationRequest): Promise<GisQueryDeviceLocationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.gisQueryDeviceLocationWithOptions(request, runtime);
  }

  async gisSearchDeviceTraceWithOptions(request: GisSearchDeviceTraceRequest, runtime: $Util.RuntimeOptions): Promise<GisSearchDeviceTraceResponse> {
    Util.validateModel(request);
    return $tea.cast<GisSearchDeviceTraceResponse>(await this.doRequest("GisSearchDeviceTrace", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new GisSearchDeviceTraceResponse({}));
  }

  async gisSearchDeviceTrace(request: GisSearchDeviceTraceRequest): Promise<GisSearchDeviceTraceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.gisSearchDeviceTraceWithOptions(request, runtime);
  }

  async importDTDataWithOptions(request: ImportDTDataRequest, runtime: $Util.RuntimeOptions): Promise<ImportDTDataResponse> {
    Util.validateModel(request);
    return $tea.cast<ImportDTDataResponse>(await this.doRequest("ImportDTData", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new ImportDTDataResponse({}));
  }

  async importDTData(request: ImportDTDataRequest): Promise<ImportDTDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.importDTDataWithOptions(request, runtime);
  }

  async importDeviceWithOptions(request: ImportDeviceRequest, runtime: $Util.RuntimeOptions): Promise<ImportDeviceResponse> {
    Util.validateModel(request);
    return $tea.cast<ImportDeviceResponse>(await this.doRequest("ImportDevice", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new ImportDeviceResponse({}));
  }

  async importDevice(request: ImportDeviceRequest): Promise<ImportDeviceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.importDeviceWithOptions(request, runtime);
  }

  async importThingModelTslWithOptions(request: ImportThingModelTslRequest, runtime: $Util.RuntimeOptions): Promise<ImportThingModelTslResponse> {
    Util.validateModel(request);
    return $tea.cast<ImportThingModelTslResponse>(await this.doRequest("ImportThingModelTsl", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new ImportThingModelTslResponse({}));
  }

  async importThingModelTsl(request: ImportThingModelTslRequest): Promise<ImportThingModelTslResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.importThingModelTslWithOptions(request, runtime);
  }

  async invokeDataAPIServiceWithOptions(request: InvokeDataAPIServiceRequest, runtime: $Util.RuntimeOptions): Promise<InvokeDataAPIServiceResponse> {
    Util.validateModel(request);
    return $tea.cast<InvokeDataAPIServiceResponse>(await this.doRequest("InvokeDataAPIService", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new InvokeDataAPIServiceResponse({}));
  }

  async invokeDataAPIService(request: InvokeDataAPIServiceRequest): Promise<InvokeDataAPIServiceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.invokeDataAPIServiceWithOptions(request, runtime);
  }

  async invokeThingServiceWithOptions(request: InvokeThingServiceRequest, runtime: $Util.RuntimeOptions): Promise<InvokeThingServiceResponse> {
    Util.validateModel(request);
    return $tea.cast<InvokeThingServiceResponse>(await this.doRequest("InvokeThingService", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new InvokeThingServiceResponse({}));
  }

  async invokeThingService(request: InvokeThingServiceRequest): Promise<InvokeThingServiceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.invokeThingServiceWithOptions(request, runtime);
  }

  async invokeThingsServiceWithOptions(request: InvokeThingsServiceRequest, runtime: $Util.RuntimeOptions): Promise<InvokeThingsServiceResponse> {
    Util.validateModel(request);
    return $tea.cast<InvokeThingsServiceResponse>(await this.doRequest("InvokeThingsService", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new InvokeThingsServiceResponse({}));
  }

  async invokeThingsService(request: InvokeThingsServiceRequest): Promise<InvokeThingsServiceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.invokeThingsServiceWithOptions(request, runtime);
  }

  async listAnalyticsDataWithOptions(request: ListAnalyticsDataRequest, runtime: $Util.RuntimeOptions): Promise<ListAnalyticsDataResponse> {
    Util.validateModel(request);
    return $tea.cast<ListAnalyticsDataResponse>(await this.doRequest("ListAnalyticsData", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new ListAnalyticsDataResponse({}));
  }

  async listAnalyticsData(request: ListAnalyticsDataRequest): Promise<ListAnalyticsDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listAnalyticsDataWithOptions(request, runtime);
  }

  async listDataSourceItemWithOptions(request: ListDataSourceItemRequest, runtime: $Util.RuntimeOptions): Promise<ListDataSourceItemResponse> {
    Util.validateModel(request);
    return $tea.cast<ListDataSourceItemResponse>(await this.doRequest("ListDataSourceItem", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new ListDataSourceItemResponse({}));
  }

  async listDataSourceItem(request: ListDataSourceItemRequest): Promise<ListDataSourceItemResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listDataSourceItemWithOptions(request, runtime);
  }

  async listDestinationWithOptions(request: ListDestinationRequest, runtime: $Util.RuntimeOptions): Promise<ListDestinationResponse> {
    Util.validateModel(request);
    return $tea.cast<ListDestinationResponse>(await this.doRequest("ListDestination", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new ListDestinationResponse({}));
  }

  async listDestination(request: ListDestinationRequest): Promise<ListDestinationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listDestinationWithOptions(request, runtime);
  }

  async listDeviceDistributeJobWithOptions(request: ListDeviceDistributeJobRequest, runtime: $Util.RuntimeOptions): Promise<ListDeviceDistributeJobResponse> {
    Util.validateModel(request);
    return $tea.cast<ListDeviceDistributeJobResponse>(await this.doRequest("ListDeviceDistributeJob", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new ListDeviceDistributeJobResponse({}));
  }

  async listDeviceDistributeJob(request: ListDeviceDistributeJobRequest): Promise<ListDeviceDistributeJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listDeviceDistributeJobWithOptions(request, runtime);
  }

  async listDistributedDeviceWithOptions(request: ListDistributedDeviceRequest, runtime: $Util.RuntimeOptions): Promise<ListDistributedDeviceResponse> {
    Util.validateModel(request);
    return $tea.cast<ListDistributedDeviceResponse>(await this.doRequest("ListDistributedDevice", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new ListDistributedDeviceResponse({}));
  }

  async listDistributedDevice(request: ListDistributedDeviceRequest): Promise<ListDistributedDeviceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listDistributedDeviceWithOptions(request, runtime);
  }

  async listDistributedProductWithOptions(request: ListDistributedProductRequest, runtime: $Util.RuntimeOptions): Promise<ListDistributedProductResponse> {
    Util.validateModel(request);
    return $tea.cast<ListDistributedProductResponse>(await this.doRequest("ListDistributedProduct", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new ListDistributedProductResponse({}));
  }

  async listDistributedProduct(request: ListDistributedProductRequest): Promise<ListDistributedProductResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listDistributedProductWithOptions(request, runtime);
  }

  async listJobWithOptions(request: ListJobRequest, runtime: $Util.RuntimeOptions): Promise<ListJobResponse> {
    Util.validateModel(request);
    return $tea.cast<ListJobResponse>(await this.doRequest("ListJob", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new ListJobResponse({}));
  }

  async listJob(request: ListJobRequest): Promise<ListJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listJobWithOptions(request, runtime);
  }

  async listOTAFirmwareWithOptions(request: ListOTAFirmwareRequest, runtime: $Util.RuntimeOptions): Promise<ListOTAFirmwareResponse> {
    Util.validateModel(request);
    return $tea.cast<ListOTAFirmwareResponse>(await this.doRequest("ListOTAFirmware", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new ListOTAFirmwareResponse({}));
  }

  async listOTAFirmware(request: ListOTAFirmwareRequest): Promise<ListOTAFirmwareResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listOTAFirmwareWithOptions(request, runtime);
  }

  async listOTAJobByDeviceWithOptions(request: ListOTAJobByDeviceRequest, runtime: $Util.RuntimeOptions): Promise<ListOTAJobByDeviceResponse> {
    Util.validateModel(request);
    return $tea.cast<ListOTAJobByDeviceResponse>(await this.doRequest("ListOTAJobByDevice", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new ListOTAJobByDeviceResponse({}));
  }

  async listOTAJobByDevice(request: ListOTAJobByDeviceRequest): Promise<ListOTAJobByDeviceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listOTAJobByDeviceWithOptions(request, runtime);
  }

  async listOTAJobByFirmwareWithOptions(request: ListOTAJobByFirmwareRequest, runtime: $Util.RuntimeOptions): Promise<ListOTAJobByFirmwareResponse> {
    Util.validateModel(request);
    return $tea.cast<ListOTAJobByFirmwareResponse>(await this.doRequest("ListOTAJobByFirmware", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new ListOTAJobByFirmwareResponse({}));
  }

  async listOTAJobByFirmware(request: ListOTAJobByFirmwareRequest): Promise<ListOTAJobByFirmwareResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listOTAJobByFirmwareWithOptions(request, runtime);
  }

  async listOTAModuleByProductWithOptions(request: ListOTAModuleByProductRequest, runtime: $Util.RuntimeOptions): Promise<ListOTAModuleByProductResponse> {
    Util.validateModel(request);
    return $tea.cast<ListOTAModuleByProductResponse>(await this.doRequest("ListOTAModuleByProduct", "HTTPS", "GET", "2018-01-20", "AK", $tea.toMap(request), null, runtime), new ListOTAModuleByProductResponse({}));
  }

  async listOTAModuleByProduct(request: ListOTAModuleByProductRequest): Promise<ListOTAModuleByProductResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listOTAModuleByProductWithOptions(request, runtime);
  }

  async listOTAModuleVersionsByDeviceWithOptions(request: ListOTAModuleVersionsByDeviceRequest, runtime: $Util.RuntimeOptions): Promise<ListOTAModuleVersionsByDeviceResponse> {
    Util.validateModel(request);
    return $tea.cast<ListOTAModuleVersionsByDeviceResponse>(await this.doRequest("ListOTAModuleVersionsByDevice", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new ListOTAModuleVersionsByDeviceResponse({}));
  }

  async listOTAModuleVersionsByDevice(request: ListOTAModuleVersionsByDeviceRequest): Promise<ListOTAModuleVersionsByDeviceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listOTAModuleVersionsByDeviceWithOptions(request, runtime);
  }

  async listOTATaskByJobWithOptions(request: ListOTATaskByJobRequest, runtime: $Util.RuntimeOptions): Promise<ListOTATaskByJobResponse> {
    Util.validateModel(request);
    return $tea.cast<ListOTATaskByJobResponse>(await this.doRequest("ListOTATaskByJob", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new ListOTATaskByJobResponse({}));
  }

  async listOTATaskByJob(request: ListOTATaskByJobRequest): Promise<ListOTATaskByJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listOTATaskByJobWithOptions(request, runtime);
  }

  async listOTAUnfinishedTaskByDeviceWithOptions(request: ListOTAUnfinishedTaskByDeviceRequest, runtime: $Util.RuntimeOptions): Promise<ListOTAUnfinishedTaskByDeviceResponse> {
    Util.validateModel(request);
    return $tea.cast<ListOTAUnfinishedTaskByDeviceResponse>(await this.doRequest("ListOTAUnfinishedTaskByDevice", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new ListOTAUnfinishedTaskByDeviceResponse({}));
  }

  async listOTAUnfinishedTaskByDevice(request: ListOTAUnfinishedTaskByDeviceRequest): Promise<ListOTAUnfinishedTaskByDeviceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listOTAUnfinishedTaskByDeviceWithOptions(request, runtime);
  }

  async listParserWithOptions(request: ListParserRequest, runtime: $Util.RuntimeOptions): Promise<ListParserResponse> {
    Util.validateModel(request);
    return $tea.cast<ListParserResponse>(await this.doRequest("ListParser", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new ListParserResponse({}));
  }

  async listParser(request: ListParserRequest): Promise<ListParserResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listParserWithOptions(request, runtime);
  }

  async listParserDataSourceWithOptions(request: ListParserDataSourceRequest, runtime: $Util.RuntimeOptions): Promise<ListParserDataSourceResponse> {
    Util.validateModel(request);
    return $tea.cast<ListParserDataSourceResponse>(await this.doRequest("ListParserDataSource", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new ListParserDataSourceResponse({}));
  }

  async listParserDataSource(request: ListParserDataSourceRequest): Promise<ListParserDataSourceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listParserDataSourceWithOptions(request, runtime);
  }

  async listParserDestinationWithOptions(request: ListParserDestinationRequest, runtime: $Util.RuntimeOptions): Promise<ListParserDestinationResponse> {
    Util.validateModel(request);
    return $tea.cast<ListParserDestinationResponse>(await this.doRequest("ListParserDestination", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new ListParserDestinationResponse({}));
  }

  async listParserDestination(request: ListParserDestinationRequest): Promise<ListParserDestinationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listParserDestinationWithOptions(request, runtime);
  }

  async listProductByTagsWithOptions(request: ListProductByTagsRequest, runtime: $Util.RuntimeOptions): Promise<ListProductByTagsResponse> {
    Util.validateModel(request);
    return $tea.cast<ListProductByTagsResponse>(await this.doRequest("ListProductByTags", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new ListProductByTagsResponse({}));
  }

  async listProductByTags(request: ListProductByTagsRequest): Promise<ListProductByTagsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listProductByTagsWithOptions(request, runtime);
  }

  async listProductTagsWithOptions(request: ListProductTagsRequest, runtime: $Util.RuntimeOptions): Promise<ListProductTagsResponse> {
    Util.validateModel(request);
    return $tea.cast<ListProductTagsResponse>(await this.doRequest("ListProductTags", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new ListProductTagsResponse({}));
  }

  async listProductTags(request: ListProductTagsRequest): Promise<ListProductTagsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listProductTagsWithOptions(request, runtime);
  }

  async listRuleWithOptions(request: ListRuleRequest, runtime: $Util.RuntimeOptions): Promise<ListRuleResponse> {
    Util.validateModel(request);
    return $tea.cast<ListRuleResponse>(await this.doRequest("ListRule", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new ListRuleResponse({}));
  }

  async listRule(request: ListRuleRequest): Promise<ListRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listRuleWithOptions(request, runtime);
  }

  async listRuleActionsWithOptions(request: ListRuleActionsRequest, runtime: $Util.RuntimeOptions): Promise<ListRuleActionsResponse> {
    Util.validateModel(request);
    return $tea.cast<ListRuleActionsResponse>(await this.doRequest("ListRuleActions", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new ListRuleActionsResponse({}));
  }

  async listRuleActions(request: ListRuleActionsRequest): Promise<ListRuleActionsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listRuleActionsWithOptions(request, runtime);
  }

  async listTaskWithOptions(tmp: ListTaskRequest, runtime: $Util.RuntimeOptions): Promise<ListTaskResponse> {
    Util.validateModel(tmp);
    let request = new ListTaskShrinkRequest({ });
    RPCUtil.convert(tmp, request);
    if (!Util.isUnset(tmp.device)) {
      request.deviceShrink = Util.toJSONString(tmp.device);
    }

    return $tea.cast<ListTaskResponse>(await this.doRequest("ListTask", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new ListTaskResponse({}));
  }

  async listTask(request: ListTaskRequest): Promise<ListTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listTaskWithOptions(request, runtime);
  }

  async listThingModelVersionWithOptions(request: ListThingModelVersionRequest, runtime: $Util.RuntimeOptions): Promise<ListThingModelVersionResponse> {
    Util.validateModel(request);
    return $tea.cast<ListThingModelVersionResponse>(await this.doRequest("ListThingModelVersion", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new ListThingModelVersionResponse({}));
  }

  async listThingModelVersion(request: ListThingModelVersionRequest): Promise<ListThingModelVersionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listThingModelVersionWithOptions(request, runtime);
  }

  async listThingTemplatesWithOptions(request: ListThingTemplatesRequest, runtime: $Util.RuntimeOptions): Promise<ListThingTemplatesResponse> {
    Util.validateModel(request);
    return $tea.cast<ListThingTemplatesResponse>(await this.doRequest("ListThingTemplates", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new ListThingTemplatesResponse({}));
  }

  async listThingTemplates(request: ListThingTemplatesRequest): Promise<ListThingTemplatesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listThingTemplatesWithOptions(request, runtime);
  }

  async notifyAddThingTopoWithOptions(request: NotifyAddThingTopoRequest, runtime: $Util.RuntimeOptions): Promise<NotifyAddThingTopoResponse> {
    Util.validateModel(request);
    return $tea.cast<NotifyAddThingTopoResponse>(await this.doRequest("NotifyAddThingTopo", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new NotifyAddThingTopoResponse({}));
  }

  async notifyAddThingTopo(request: NotifyAddThingTopoRequest): Promise<NotifyAddThingTopoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.notifyAddThingTopoWithOptions(request, runtime);
  }

  async openIotServiceWithOptions(request: OpenIotServiceRequest, runtime: $Util.RuntimeOptions): Promise<OpenIotServiceResponse> {
    Util.validateModel(request);
    return $tea.cast<OpenIotServiceResponse>(await this.doRequest("OpenIotService", "HTTPS", "POST", "2018-01-20", "AK,APP,PrivateKey,BearerToken", null, $tea.toMap(request), runtime), new OpenIotServiceResponse({}));
  }

  async openIotService(request: OpenIotServiceRequest): Promise<OpenIotServiceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.openIotServiceWithOptions(request, runtime);
  }

  async packageSoundCodeLabelBatchAudioWithOptions(request: PackageSoundCodeLabelBatchAudioRequest, runtime: $Util.RuntimeOptions): Promise<PackageSoundCodeLabelBatchAudioResponse> {
    Util.validateModel(request);
    return $tea.cast<PackageSoundCodeLabelBatchAudioResponse>(await this.doRequest("PackageSoundCodeLabelBatchAudio", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new PackageSoundCodeLabelBatchAudioResponse({}));
  }

  async packageSoundCodeLabelBatchAudio(request: PackageSoundCodeLabelBatchAudioRequest): Promise<PackageSoundCodeLabelBatchAudioResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.packageSoundCodeLabelBatchAudioWithOptions(request, runtime);
  }

  async pageQuerySharedSpeechOpenWithOptions(request: PageQuerySharedSpeechOpenRequest, runtime: $Util.RuntimeOptions): Promise<PageQuerySharedSpeechOpenResponse> {
    Util.validateModel(request);
    return $tea.cast<PageQuerySharedSpeechOpenResponse>(await this.doRequest("PageQuerySharedSpeechOpen", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new PageQuerySharedSpeechOpenResponse({}));
  }

  async pageQuerySharedSpeechOpen(request: PageQuerySharedSpeechOpenRequest): Promise<PageQuerySharedSpeechOpenResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.pageQuerySharedSpeechOpenWithOptions(request, runtime);
  }

  async pageQuerySpeechBroadcastHourWithOptions(request: PageQuerySpeechBroadcastHourRequest, runtime: $Util.RuntimeOptions): Promise<PageQuerySpeechBroadcastHourResponse> {
    Util.validateModel(request);
    return $tea.cast<PageQuerySpeechBroadcastHourResponse>(await this.doRequest("PageQuerySpeechBroadcastHour", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new PageQuerySpeechBroadcastHourResponse({}));
  }

  async pageQuerySpeechBroadcastHour(request: PageQuerySpeechBroadcastHourRequest): Promise<PageQuerySpeechBroadcastHourResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.pageQuerySpeechBroadcastHourWithOptions(request, runtime);
  }

  async printByTemplateWithOptions(request: PrintByTemplateRequest, runtime: $Util.RuntimeOptions): Promise<PrintByTemplateResponse> {
    Util.validateModel(request);
    return $tea.cast<PrintByTemplateResponse>(await this.doRequest("PrintByTemplate", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new PrintByTemplateResponse({}));
  }

  async printByTemplate(request: PrintByTemplateRequest): Promise<PrintByTemplateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.printByTemplateWithOptions(request, runtime);
  }

  async pubWithOptions(request: PubRequest, runtime: $Util.RuntimeOptions): Promise<PubResponse> {
    Util.validateModel(request);
    return $tea.cast<PubResponse>(await this.doRequest("Pub", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new PubResponse({}));
  }

  async pub(request: PubRequest): Promise<PubResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.pubWithOptions(request, runtime);
  }

  async pubBroadcastWithOptions(request: PubBroadcastRequest, runtime: $Util.RuntimeOptions): Promise<PubBroadcastResponse> {
    Util.validateModel(request);
    return $tea.cast<PubBroadcastResponse>(await this.doRequest("PubBroadcast", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new PubBroadcastResponse({}));
  }

  async pubBroadcast(request: PubBroadcastRequest): Promise<PubBroadcastResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.pubBroadcastWithOptions(request, runtime);
  }

  async publishScriptWithOptions(request: PublishScriptRequest, runtime: $Util.RuntimeOptions): Promise<PublishScriptResponse> {
    Util.validateModel(request);
    return $tea.cast<PublishScriptResponse>(await this.doRequest("PublishScript", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new PublishScriptResponse({}));
  }

  async publishScript(request: PublishScriptRequest): Promise<PublishScriptResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.publishScriptWithOptions(request, runtime);
  }

  async publishStudioAppWithOptions(request: PublishStudioAppRequest, runtime: $Util.RuntimeOptions): Promise<PublishStudioAppResponse> {
    Util.validateModel(request);
    return $tea.cast<PublishStudioAppResponse>(await this.doRequest("PublishStudioApp", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new PublishStudioAppResponse({}));
  }

  async publishStudioApp(request: PublishStudioAppRequest): Promise<PublishStudioAppResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.publishStudioAppWithOptions(request, runtime);
  }

  async publishThingModelWithOptions(request: PublishThingModelRequest, runtime: $Util.RuntimeOptions): Promise<PublishThingModelResponse> {
    Util.validateModel(request);
    return $tea.cast<PublishThingModelResponse>(await this.doRequest("PublishThingModel", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new PublishThingModelResponse({}));
  }

  async publishThingModel(request: PublishThingModelRequest): Promise<PublishThingModelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.publishThingModelWithOptions(request, runtime);
  }

  async pushSpeechWithOptions(request: PushSpeechRequest, runtime: $Util.RuntimeOptions): Promise<PushSpeechResponse> {
    Util.validateModel(request);
    return $tea.cast<PushSpeechResponse>(await this.doRequest("PushSpeech", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new PushSpeechResponse({}));
  }

  async pushSpeech(request: PushSpeechRequest): Promise<PushSpeechResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.pushSpeechWithOptions(request, runtime);
  }

  async queryBatchRegisterDeviceStatusWithOptions(request: QueryBatchRegisterDeviceStatusRequest, runtime: $Util.RuntimeOptions): Promise<QueryBatchRegisterDeviceStatusResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryBatchRegisterDeviceStatusResponse>(await this.doRequest("QueryBatchRegisterDeviceStatus", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryBatchRegisterDeviceStatusResponse({}));
  }

  async queryBatchRegisterDeviceStatus(request: QueryBatchRegisterDeviceStatusRequest): Promise<QueryBatchRegisterDeviceStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryBatchRegisterDeviceStatusWithOptions(request, runtime);
  }

  async queryCertUrlByApplyIdWithOptions(request: QueryCertUrlByApplyIdRequest, runtime: $Util.RuntimeOptions): Promise<QueryCertUrlByApplyIdResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryCertUrlByApplyIdResponse>(await this.doRequest("QueryCertUrlByApplyId", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryCertUrlByApplyIdResponse({}));
  }

  async queryCertUrlByApplyId(request: QueryCertUrlByApplyIdRequest): Promise<QueryCertUrlByApplyIdResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryCertUrlByApplyIdWithOptions(request, runtime);
  }

  async queryClientIdsWithOptions(request: QueryClientIdsRequest, runtime: $Util.RuntimeOptions): Promise<QueryClientIdsResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryClientIdsResponse>(await this.doRequest("QueryClientIds", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryClientIdsResponse({}));
  }

  async queryClientIds(request: QueryClientIdsRequest): Promise<QueryClientIdsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryClientIdsWithOptions(request, runtime);
  }

  async queryConsumerGroupByGroupIdWithOptions(request: QueryConsumerGroupByGroupIdRequest, runtime: $Util.RuntimeOptions): Promise<QueryConsumerGroupByGroupIdResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryConsumerGroupByGroupIdResponse>(await this.doRequest("QueryConsumerGroupByGroupId", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryConsumerGroupByGroupIdResponse({}));
  }

  async queryConsumerGroupByGroupId(request: QueryConsumerGroupByGroupIdRequest): Promise<QueryConsumerGroupByGroupIdResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryConsumerGroupByGroupIdWithOptions(request, runtime);
  }

  async queryConsumerGroupListWithOptions(request: QueryConsumerGroupListRequest, runtime: $Util.RuntimeOptions): Promise<QueryConsumerGroupListResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryConsumerGroupListResponse>(await this.doRequest("QueryConsumerGroupList", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryConsumerGroupListResponse({}));
  }

  async queryConsumerGroupList(request: QueryConsumerGroupListRequest): Promise<QueryConsumerGroupListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryConsumerGroupListWithOptions(request, runtime);
  }

  async queryConsumerGroupStatusWithOptions(request: QueryConsumerGroupStatusRequest, runtime: $Util.RuntimeOptions): Promise<QueryConsumerGroupStatusResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryConsumerGroupStatusResponse>(await this.doRequest("QueryConsumerGroupStatus", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryConsumerGroupStatusResponse({}));
  }

  async queryConsumerGroupStatus(request: QueryConsumerGroupStatusRequest): Promise<QueryConsumerGroupStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryConsumerGroupStatusWithOptions(request, runtime);
  }

  async queryDetailSceneRuleLogWithOptions(request: QueryDetailSceneRuleLogRequest, runtime: $Util.RuntimeOptions): Promise<QueryDetailSceneRuleLogResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryDetailSceneRuleLogResponse>(await this.doRequest("QueryDetailSceneRuleLog", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryDetailSceneRuleLogResponse({}));
  }

  async queryDetailSceneRuleLog(request: QueryDetailSceneRuleLogRequest): Promise<QueryDetailSceneRuleLogResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDetailSceneRuleLogWithOptions(request, runtime);
  }

  async queryDeviceWithOptions(request: QueryDeviceRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryDeviceResponse>(await this.doRequest("QueryDevice", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryDeviceResponse({}));
  }

  async queryDevice(request: QueryDeviceRequest): Promise<QueryDeviceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceWithOptions(request, runtime);
  }

  async queryDeviceBySQLWithOptions(request: QueryDeviceBySQLRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceBySQLResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryDeviceBySQLResponse>(await this.doRequest("QueryDeviceBySQL", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryDeviceBySQLResponse({}));
  }

  async queryDeviceBySQL(request: QueryDeviceBySQLRequest): Promise<QueryDeviceBySQLResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceBySQLWithOptions(request, runtime);
  }

  async queryDeviceByStatusWithOptions(request: QueryDeviceByStatusRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceByStatusResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryDeviceByStatusResponse>(await this.doRequest("QueryDeviceByStatus", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryDeviceByStatusResponse({}));
  }

  async queryDeviceByStatus(request: QueryDeviceByStatusRequest): Promise<QueryDeviceByStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceByStatusWithOptions(request, runtime);
  }

  async queryDeviceByTagsWithOptions(request: QueryDeviceByTagsRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceByTagsResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryDeviceByTagsResponse>(await this.doRequest("QueryDeviceByTags", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryDeviceByTagsResponse({}));
  }

  async queryDeviceByTags(request: QueryDeviceByTagsRequest): Promise<QueryDeviceByTagsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceByTagsWithOptions(request, runtime);
  }

  async queryDeviceCertWithOptions(request: QueryDeviceCertRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceCertResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryDeviceCertResponse>(await this.doRequest("QueryDeviceCert", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryDeviceCertResponse({}));
  }

  async queryDeviceCert(request: QueryDeviceCertRequest): Promise<QueryDeviceCertResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceCertWithOptions(request, runtime);
  }

  async queryDeviceDesiredPropertyWithOptions(request: QueryDeviceDesiredPropertyRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceDesiredPropertyResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryDeviceDesiredPropertyResponse>(await this.doRequest("QueryDeviceDesiredProperty", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryDeviceDesiredPropertyResponse({}));
  }

  async queryDeviceDesiredProperty(request: QueryDeviceDesiredPropertyRequest): Promise<QueryDeviceDesiredPropertyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceDesiredPropertyWithOptions(request, runtime);
  }

  async queryDeviceDetailWithOptions(request: QueryDeviceDetailRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceDetailResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryDeviceDetailResponse>(await this.doRequest("QueryDeviceDetail", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryDeviceDetailResponse({}));
  }

  async queryDeviceDetail(request: QueryDeviceDetailRequest): Promise<QueryDeviceDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceDetailWithOptions(request, runtime);
  }

  async queryDeviceDistributeDetailWithOptions(request: QueryDeviceDistributeDetailRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceDistributeDetailResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryDeviceDistributeDetailResponse>(await this.doRequest("QueryDeviceDistributeDetail", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryDeviceDistributeDetailResponse({}));
  }

  async queryDeviceDistributeDetail(request: QueryDeviceDistributeDetailRequest): Promise<QueryDeviceDistributeDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceDistributeDetailWithOptions(request, runtime);
  }

  async queryDeviceDistributeJobWithOptions(request: QueryDeviceDistributeJobRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceDistributeJobResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryDeviceDistributeJobResponse>(await this.doRequest("QueryDeviceDistributeJob", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryDeviceDistributeJobResponse({}));
  }

  async queryDeviceDistributeJob(request: QueryDeviceDistributeJobRequest): Promise<QueryDeviceDistributeJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceDistributeJobWithOptions(request, runtime);
  }

  async queryDeviceEventDataWithOptions(request: QueryDeviceEventDataRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceEventDataResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryDeviceEventDataResponse>(await this.doRequest("QueryDeviceEventData", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryDeviceEventDataResponse({}));
  }

  async queryDeviceEventData(request: QueryDeviceEventDataRequest): Promise<QueryDeviceEventDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceEventDataWithOptions(request, runtime);
  }

  async queryDeviceFileWithOptions(request: QueryDeviceFileRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceFileResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryDeviceFileResponse>(await this.doRequest("QueryDeviceFile", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryDeviceFileResponse({}));
  }

  async queryDeviceFile(request: QueryDeviceFileRequest): Promise<QueryDeviceFileResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceFileWithOptions(request, runtime);
  }

  async queryDeviceFileListWithOptions(request: QueryDeviceFileListRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceFileListResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryDeviceFileListResponse>(await this.doRequest("QueryDeviceFileList", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryDeviceFileListResponse({}));
  }

  async queryDeviceFileList(request: QueryDeviceFileListRequest): Promise<QueryDeviceFileListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceFileListWithOptions(request, runtime);
  }

  async queryDeviceGroupByDeviceWithOptions(request: QueryDeviceGroupByDeviceRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceGroupByDeviceResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryDeviceGroupByDeviceResponse>(await this.doRequest("QueryDeviceGroupByDevice", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryDeviceGroupByDeviceResponse({}));
  }

  async queryDeviceGroupByDevice(request: QueryDeviceGroupByDeviceRequest): Promise<QueryDeviceGroupByDeviceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceGroupByDeviceWithOptions(request, runtime);
  }

  async queryDeviceGroupByTagsWithOptions(request: QueryDeviceGroupByTagsRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceGroupByTagsResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryDeviceGroupByTagsResponse>(await this.doRequest("QueryDeviceGroupByTags", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryDeviceGroupByTagsResponse({}));
  }

  async queryDeviceGroupByTags(request: QueryDeviceGroupByTagsRequest): Promise<QueryDeviceGroupByTagsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceGroupByTagsWithOptions(request, runtime);
  }

  async queryDeviceGroupInfoWithOptions(request: QueryDeviceGroupInfoRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceGroupInfoResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryDeviceGroupInfoResponse>(await this.doRequest("QueryDeviceGroupInfo", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryDeviceGroupInfoResponse({}));
  }

  async queryDeviceGroupInfo(request: QueryDeviceGroupInfoRequest): Promise<QueryDeviceGroupInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceGroupInfoWithOptions(request, runtime);
  }

  async queryDeviceGroupListWithOptions(request: QueryDeviceGroupListRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceGroupListResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryDeviceGroupListResponse>(await this.doRequest("QueryDeviceGroupList", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryDeviceGroupListResponse({}));
  }

  async queryDeviceGroupList(request: QueryDeviceGroupListRequest): Promise<QueryDeviceGroupListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceGroupListWithOptions(request, runtime);
  }

  async queryDeviceGroupTagListWithOptions(request: QueryDeviceGroupTagListRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceGroupTagListResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryDeviceGroupTagListResponse>(await this.doRequest("QueryDeviceGroupTagList", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryDeviceGroupTagListResponse({}));
  }

  async queryDeviceGroupTagList(request: QueryDeviceGroupTagListRequest): Promise<QueryDeviceGroupTagListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceGroupTagListWithOptions(request, runtime);
  }

  async queryDeviceInfoWithOptions(request: QueryDeviceInfoRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceInfoResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryDeviceInfoResponse>(await this.doRequest("QueryDeviceInfo", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryDeviceInfoResponse({}));
  }

  async queryDeviceInfo(request: QueryDeviceInfoRequest): Promise<QueryDeviceInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceInfoWithOptions(request, runtime);
  }

  async queryDeviceListByDeviceGroupWithOptions(request: QueryDeviceListByDeviceGroupRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceListByDeviceGroupResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryDeviceListByDeviceGroupResponse>(await this.doRequest("QueryDeviceListByDeviceGroup", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryDeviceListByDeviceGroupResponse({}));
  }

  async queryDeviceListByDeviceGroup(request: QueryDeviceListByDeviceGroupRequest): Promise<QueryDeviceListByDeviceGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceListByDeviceGroupWithOptions(request, runtime);
  }

  async queryDeviceOriginalEventDataWithOptions(request: QueryDeviceOriginalEventDataRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceOriginalEventDataResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryDeviceOriginalEventDataResponse>(await this.doRequest("QueryDeviceOriginalEventData", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryDeviceOriginalEventDataResponse({}));
  }

  async queryDeviceOriginalEventData(request: QueryDeviceOriginalEventDataRequest): Promise<QueryDeviceOriginalEventDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceOriginalEventDataWithOptions(request, runtime);
  }

  async queryDeviceOriginalPropertyDataWithOptions(request: QueryDeviceOriginalPropertyDataRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceOriginalPropertyDataResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryDeviceOriginalPropertyDataResponse>(await this.doRequest("QueryDeviceOriginalPropertyData", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryDeviceOriginalPropertyDataResponse({}));
  }

  async queryDeviceOriginalPropertyData(request: QueryDeviceOriginalPropertyDataRequest): Promise<QueryDeviceOriginalPropertyDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceOriginalPropertyDataWithOptions(request, runtime);
  }

  async queryDeviceOriginalPropertyStatusWithOptions(request: QueryDeviceOriginalPropertyStatusRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceOriginalPropertyStatusResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryDeviceOriginalPropertyStatusResponse>(await this.doRequest("QueryDeviceOriginalPropertyStatus", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryDeviceOriginalPropertyStatusResponse({}));
  }

  async queryDeviceOriginalPropertyStatus(request: QueryDeviceOriginalPropertyStatusRequest): Promise<QueryDeviceOriginalPropertyStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceOriginalPropertyStatusWithOptions(request, runtime);
  }

  async queryDeviceOriginalServiceDataWithOptions(request: QueryDeviceOriginalServiceDataRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceOriginalServiceDataResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryDeviceOriginalServiceDataResponse>(await this.doRequest("QueryDeviceOriginalServiceData", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryDeviceOriginalServiceDataResponse({}));
  }

  async queryDeviceOriginalServiceData(request: QueryDeviceOriginalServiceDataRequest): Promise<QueryDeviceOriginalServiceDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceOriginalServiceDataWithOptions(request, runtime);
  }

  async queryDevicePropWithOptions(request: QueryDevicePropRequest, runtime: $Util.RuntimeOptions): Promise<QueryDevicePropResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryDevicePropResponse>(await this.doRequest("QueryDeviceProp", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryDevicePropResponse({}));
  }

  async queryDeviceProp(request: QueryDevicePropRequest): Promise<QueryDevicePropResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDevicePropWithOptions(request, runtime);
  }

  async queryDevicePropertiesDataWithOptions(request: QueryDevicePropertiesDataRequest, runtime: $Util.RuntimeOptions): Promise<QueryDevicePropertiesDataResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryDevicePropertiesDataResponse>(await this.doRequest("QueryDevicePropertiesData", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryDevicePropertiesDataResponse({}));
  }

  async queryDevicePropertiesData(request: QueryDevicePropertiesDataRequest): Promise<QueryDevicePropertiesDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDevicePropertiesDataWithOptions(request, runtime);
  }

  async queryDevicePropertyDataWithOptions(request: QueryDevicePropertyDataRequest, runtime: $Util.RuntimeOptions): Promise<QueryDevicePropertyDataResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryDevicePropertyDataResponse>(await this.doRequest("QueryDevicePropertyData", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryDevicePropertyDataResponse({}));
  }

  async queryDevicePropertyData(request: QueryDevicePropertyDataRequest): Promise<QueryDevicePropertyDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDevicePropertyDataWithOptions(request, runtime);
  }

  async queryDevicePropertyStatusWithOptions(request: QueryDevicePropertyStatusRequest, runtime: $Util.RuntimeOptions): Promise<QueryDevicePropertyStatusResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryDevicePropertyStatusResponse>(await this.doRequest("QueryDevicePropertyStatus", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryDevicePropertyStatusResponse({}));
  }

  async queryDevicePropertyStatus(request: QueryDevicePropertyStatusRequest): Promise<QueryDevicePropertyStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDevicePropertyStatusWithOptions(request, runtime);
  }

  async queryDeviceServiceDataWithOptions(request: QueryDeviceServiceDataRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceServiceDataResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryDeviceServiceDataResponse>(await this.doRequest("QueryDeviceServiceData", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryDeviceServiceDataResponse({}));
  }

  async queryDeviceServiceData(request: QueryDeviceServiceDataRequest): Promise<QueryDeviceServiceDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceServiceDataWithOptions(request, runtime);
  }

  async queryDeviceSpeechWithOptions(request: QueryDeviceSpeechRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceSpeechResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryDeviceSpeechResponse>(await this.doRequest("QueryDeviceSpeech", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryDeviceSpeechResponse({}));
  }

  async queryDeviceSpeech(request: QueryDeviceSpeechRequest): Promise<QueryDeviceSpeechResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceSpeechWithOptions(request, runtime);
  }

  async queryDeviceStatisticsWithOptions(request: QueryDeviceStatisticsRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceStatisticsResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryDeviceStatisticsResponse>(await this.doRequest("QueryDeviceStatistics", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryDeviceStatisticsResponse({}));
  }

  async queryDeviceStatistics(request: QueryDeviceStatisticsRequest): Promise<QueryDeviceStatisticsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceStatisticsWithOptions(request, runtime);
  }

  async queryDeviceSubTopicWithOptions(request: QueryDeviceSubTopicRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceSubTopicResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryDeviceSubTopicResponse>(await this.doRequest("QueryDeviceSubTopic", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryDeviceSubTopicResponse({}));
  }

  async queryDeviceSubTopic(request: QueryDeviceSubTopicRequest): Promise<QueryDeviceSubTopicResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceSubTopicWithOptions(request, runtime);
  }

  async queryDeviceTunnelWithOptions(request: QueryDeviceTunnelRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceTunnelResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryDeviceTunnelResponse>(await this.doRequest("QueryDeviceTunnel", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryDeviceTunnelResponse({}));
  }

  async queryDeviceTunnel(request: QueryDeviceTunnelRequest): Promise<QueryDeviceTunnelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceTunnelWithOptions(request, runtime);
  }

  async queryDevicesHotStorageDataWithOptions(request: QueryDevicesHotStorageDataRequest, runtime: $Util.RuntimeOptions): Promise<QueryDevicesHotStorageDataResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryDevicesHotStorageDataResponse>(await this.doRequest("QueryDevicesHotStorageData", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryDevicesHotStorageDataResponse({}));
  }

  async queryDevicesHotStorageData(request: QueryDevicesHotStorageDataRequest): Promise<QueryDevicesHotStorageDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDevicesHotStorageDataWithOptions(request, runtime);
  }

  async queryDevicesHotStorageDataStatusWithOptions(request: QueryDevicesHotStorageDataStatusRequest, runtime: $Util.RuntimeOptions): Promise<QueryDevicesHotStorageDataStatusResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryDevicesHotStorageDataStatusResponse>(await this.doRequest("QueryDevicesHotStorageDataStatus", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryDevicesHotStorageDataStatusResponse({}));
  }

  async queryDevicesHotStorageDataStatus(request: QueryDevicesHotStorageDataStatusRequest): Promise<QueryDevicesHotStorageDataStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDevicesHotStorageDataStatusWithOptions(request, runtime);
  }

  async queryDynamicGroupDevicesWithOptions(request: QueryDynamicGroupDevicesRequest, runtime: $Util.RuntimeOptions): Promise<QueryDynamicGroupDevicesResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryDynamicGroupDevicesResponse>(await this.doRequest("QueryDynamicGroupDevices", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryDynamicGroupDevicesResponse({}));
  }

  async queryDynamicGroupDevices(request: QueryDynamicGroupDevicesRequest): Promise<QueryDynamicGroupDevicesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDynamicGroupDevicesWithOptions(request, runtime);
  }

  async queryEdgeDriverWithOptions(request: QueryEdgeDriverRequest, runtime: $Util.RuntimeOptions): Promise<QueryEdgeDriverResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryEdgeDriverResponse>(await this.doRequest("QueryEdgeDriver", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryEdgeDriverResponse({}));
  }

  async queryEdgeDriver(request: QueryEdgeDriverRequest): Promise<QueryEdgeDriverResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryEdgeDriverWithOptions(request, runtime);
  }

  async queryEdgeDriverVersionWithOptions(request: QueryEdgeDriverVersionRequest, runtime: $Util.RuntimeOptions): Promise<QueryEdgeDriverVersionResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryEdgeDriverVersionResponse>(await this.doRequest("QueryEdgeDriverVersion", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryEdgeDriverVersionResponse({}));
  }

  async queryEdgeDriverVersion(request: QueryEdgeDriverVersionRequest): Promise<QueryEdgeDriverVersionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryEdgeDriverVersionWithOptions(request, runtime);
  }

  async queryEdgeInstanceWithOptions(request: QueryEdgeInstanceRequest, runtime: $Util.RuntimeOptions): Promise<QueryEdgeInstanceResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryEdgeInstanceResponse>(await this.doRequest("QueryEdgeInstance", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryEdgeInstanceResponse({}));
  }

  async queryEdgeInstance(request: QueryEdgeInstanceRequest): Promise<QueryEdgeInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryEdgeInstanceWithOptions(request, runtime);
  }

  async queryEdgeInstanceChannelWithOptions(request: QueryEdgeInstanceChannelRequest, runtime: $Util.RuntimeOptions): Promise<QueryEdgeInstanceChannelResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryEdgeInstanceChannelResponse>(await this.doRequest("QueryEdgeInstanceChannel", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryEdgeInstanceChannelResponse({}));
  }

  async queryEdgeInstanceChannel(request: QueryEdgeInstanceChannelRequest): Promise<QueryEdgeInstanceChannelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryEdgeInstanceChannelWithOptions(request, runtime);
  }

  async queryEdgeInstanceDeviceWithOptions(request: QueryEdgeInstanceDeviceRequest, runtime: $Util.RuntimeOptions): Promise<QueryEdgeInstanceDeviceResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryEdgeInstanceDeviceResponse>(await this.doRequest("QueryEdgeInstanceDevice", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryEdgeInstanceDeviceResponse({}));
  }

  async queryEdgeInstanceDevice(request: QueryEdgeInstanceDeviceRequest): Promise<QueryEdgeInstanceDeviceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryEdgeInstanceDeviceWithOptions(request, runtime);
  }

  async queryEdgeInstanceDeviceByDriverWithOptions(request: QueryEdgeInstanceDeviceByDriverRequest, runtime: $Util.RuntimeOptions): Promise<QueryEdgeInstanceDeviceByDriverResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryEdgeInstanceDeviceByDriverResponse>(await this.doRequest("QueryEdgeInstanceDeviceByDriver", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryEdgeInstanceDeviceByDriverResponse({}));
  }

  async queryEdgeInstanceDeviceByDriver(request: QueryEdgeInstanceDeviceByDriverRequest): Promise<QueryEdgeInstanceDeviceByDriverResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryEdgeInstanceDeviceByDriverWithOptions(request, runtime);
  }

  async queryEdgeInstanceDriverWithOptions(request: QueryEdgeInstanceDriverRequest, runtime: $Util.RuntimeOptions): Promise<QueryEdgeInstanceDriverResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryEdgeInstanceDriverResponse>(await this.doRequest("QueryEdgeInstanceDriver", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryEdgeInstanceDriverResponse({}));
  }

  async queryEdgeInstanceDriver(request: QueryEdgeInstanceDriverRequest): Promise<QueryEdgeInstanceDriverResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryEdgeInstanceDriverWithOptions(request, runtime);
  }

  async queryEdgeInstanceGatewayWithOptions(request: QueryEdgeInstanceGatewayRequest, runtime: $Util.RuntimeOptions): Promise<QueryEdgeInstanceGatewayResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryEdgeInstanceGatewayResponse>(await this.doRequest("QueryEdgeInstanceGateway", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryEdgeInstanceGatewayResponse({}));
  }

  async queryEdgeInstanceGateway(request: QueryEdgeInstanceGatewayRequest): Promise<QueryEdgeInstanceGatewayResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryEdgeInstanceGatewayWithOptions(request, runtime);
  }

  async queryEdgeInstanceHistoricDeploymentWithOptions(request: QueryEdgeInstanceHistoricDeploymentRequest, runtime: $Util.RuntimeOptions): Promise<QueryEdgeInstanceHistoricDeploymentResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryEdgeInstanceHistoricDeploymentResponse>(await this.doRequest("QueryEdgeInstanceHistoricDeployment", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryEdgeInstanceHistoricDeploymentResponse({}));
  }

  async queryEdgeInstanceHistoricDeployment(request: QueryEdgeInstanceHistoricDeploymentRequest): Promise<QueryEdgeInstanceHistoricDeploymentResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryEdgeInstanceHistoricDeploymentWithOptions(request, runtime);
  }

  async queryEdgeInstanceMessageRoutingWithOptions(request: QueryEdgeInstanceMessageRoutingRequest, runtime: $Util.RuntimeOptions): Promise<QueryEdgeInstanceMessageRoutingResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryEdgeInstanceMessageRoutingResponse>(await this.doRequest("QueryEdgeInstanceMessageRouting", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryEdgeInstanceMessageRoutingResponse({}));
  }

  async queryEdgeInstanceMessageRouting(request: QueryEdgeInstanceMessageRoutingRequest): Promise<QueryEdgeInstanceMessageRoutingResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryEdgeInstanceMessageRoutingWithOptions(request, runtime);
  }

  async queryEdgeInstanceSceneRuleWithOptions(request: QueryEdgeInstanceSceneRuleRequest, runtime: $Util.RuntimeOptions): Promise<QueryEdgeInstanceSceneRuleResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryEdgeInstanceSceneRuleResponse>(await this.doRequest("QueryEdgeInstanceSceneRule", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryEdgeInstanceSceneRuleResponse({}));
  }

  async queryEdgeInstanceSceneRule(request: QueryEdgeInstanceSceneRuleRequest): Promise<QueryEdgeInstanceSceneRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryEdgeInstanceSceneRuleWithOptions(request, runtime);
  }

  async queryImportedDeviceByApplyIdWithOptions(request: QueryImportedDeviceByApplyIdRequest, runtime: $Util.RuntimeOptions): Promise<QueryImportedDeviceByApplyIdResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryImportedDeviceByApplyIdResponse>(await this.doRequest("QueryImportedDeviceByApplyId", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryImportedDeviceByApplyIdResponse({}));
  }

  async queryImportedDeviceByApplyId(request: QueryImportedDeviceByApplyIdRequest): Promise<QueryImportedDeviceByApplyIdResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryImportedDeviceByApplyIdWithOptions(request, runtime);
  }

  async queryJobWithOptions(request: QueryJobRequest, runtime: $Util.RuntimeOptions): Promise<QueryJobResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryJobResponse>(await this.doRequest("QueryJob", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryJobResponse({}));
  }

  async queryJob(request: QueryJobRequest): Promise<QueryJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryJobWithOptions(request, runtime);
  }

  async queryJobStatisticsWithOptions(request: QueryJobStatisticsRequest, runtime: $Util.RuntimeOptions): Promise<QueryJobStatisticsResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryJobStatisticsResponse>(await this.doRequest("QueryJobStatistics", "HTTPS", "GET", "2018-01-20", "AK", $tea.toMap(request), null, runtime), new QueryJobStatisticsResponse({}));
  }

  async queryJobStatistics(request: QueryJobStatisticsRequest): Promise<QueryJobStatisticsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryJobStatisticsWithOptions(request, runtime);
  }

  async queryLicenseDeviceListWithOptions(request: QueryLicenseDeviceListRequest, runtime: $Util.RuntimeOptions): Promise<QueryLicenseDeviceListResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryLicenseDeviceListResponse>(await this.doRequest("QueryLicenseDeviceList", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryLicenseDeviceListResponse({}));
  }

  async queryLicenseDeviceList(request: QueryLicenseDeviceListRequest): Promise<QueryLicenseDeviceListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryLicenseDeviceListWithOptions(request, runtime);
  }

  async queryLoRaJoinPermissionsWithOptions(request: QueryLoRaJoinPermissionsRequest, runtime: $Util.RuntimeOptions): Promise<QueryLoRaJoinPermissionsResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryLoRaJoinPermissionsResponse>(await this.doRequest("QueryLoRaJoinPermissions", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryLoRaJoinPermissionsResponse({}));
  }

  async queryLoRaJoinPermissions(request: QueryLoRaJoinPermissionsRequest): Promise<QueryLoRaJoinPermissionsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryLoRaJoinPermissionsWithOptions(request, runtime);
  }

  async queryMessageInfoWithOptions(request: QueryMessageInfoRequest, runtime: $Util.RuntimeOptions): Promise<QueryMessageInfoResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryMessageInfoResponse>(await this.doRequest("QueryMessageInfo", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryMessageInfoResponse({}));
  }

  async queryMessageInfo(request: QueryMessageInfoRequest): Promise<QueryMessageInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryMessageInfoWithOptions(request, runtime);
  }

  async queryOTAFirmwareWithOptions(request: QueryOTAFirmwareRequest, runtime: $Util.RuntimeOptions): Promise<QueryOTAFirmwareResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryOTAFirmwareResponse>(await this.doRequest("QueryOTAFirmware", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryOTAFirmwareResponse({}));
  }

  async queryOTAFirmware(request: QueryOTAFirmwareRequest): Promise<QueryOTAFirmwareResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryOTAFirmwareWithOptions(request, runtime);
  }

  async queryOTAJobWithOptions(request: QueryOTAJobRequest, runtime: $Util.RuntimeOptions): Promise<QueryOTAJobResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryOTAJobResponse>(await this.doRequest("QueryOTAJob", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryOTAJobResponse({}));
  }

  async queryOTAJob(request: QueryOTAJobRequest): Promise<QueryOTAJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryOTAJobWithOptions(request, runtime);
  }

  async queryPageByApplyIdWithOptions(request: QueryPageByApplyIdRequest, runtime: $Util.RuntimeOptions): Promise<QueryPageByApplyIdResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryPageByApplyIdResponse>(await this.doRequest("QueryPageByApplyId", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryPageByApplyIdResponse({}));
  }

  async queryPageByApplyId(request: QueryPageByApplyIdRequest): Promise<QueryPageByApplyIdResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryPageByApplyIdWithOptions(request, runtime);
  }

  async queryProductWithOptions(request: QueryProductRequest, runtime: $Util.RuntimeOptions): Promise<QueryProductResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryProductResponse>(await this.doRequest("QueryProduct", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryProductResponse({}));
  }

  async queryProduct(request: QueryProductRequest): Promise<QueryProductResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryProductWithOptions(request, runtime);
  }

  async queryProductCertInfoWithOptions(request: QueryProductCertInfoRequest, runtime: $Util.RuntimeOptions): Promise<QueryProductCertInfoResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryProductCertInfoResponse>(await this.doRequest("QueryProductCertInfo", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryProductCertInfoResponse({}));
  }

  async queryProductCertInfo(request: QueryProductCertInfoRequest): Promise<QueryProductCertInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryProductCertInfoWithOptions(request, runtime);
  }

  async queryProductListWithOptions(request: QueryProductListRequest, runtime: $Util.RuntimeOptions): Promise<QueryProductListResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryProductListResponse>(await this.doRequest("QueryProductList", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryProductListResponse({}));
  }

  async queryProductList(request: QueryProductListRequest): Promise<QueryProductListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryProductListWithOptions(request, runtime);
  }

  async queryProductTopicWithOptions(request: QueryProductTopicRequest, runtime: $Util.RuntimeOptions): Promise<QueryProductTopicResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryProductTopicResponse>(await this.doRequest("QueryProductTopic", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryProductTopicResponse({}));
  }

  async queryProductTopic(request: QueryProductTopicRequest): Promise<QueryProductTopicResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryProductTopicWithOptions(request, runtime);
  }

  async queryProjectShareDeviceListWithOptions(request: QueryProjectShareDeviceListRequest, runtime: $Util.RuntimeOptions): Promise<QueryProjectShareDeviceListResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryProjectShareDeviceListResponse>(await this.doRequest("QueryProjectShareDeviceList", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryProjectShareDeviceListResponse({}));
  }

  async queryProjectShareDeviceList(request: QueryProjectShareDeviceListRequest): Promise<QueryProjectShareDeviceListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryProjectShareDeviceListWithOptions(request, runtime);
  }

  async querySceneRuleWithOptions(request: QuerySceneRuleRequest, runtime: $Util.RuntimeOptions): Promise<QuerySceneRuleResponse> {
    Util.validateModel(request);
    return $tea.cast<QuerySceneRuleResponse>(await this.doRequest("QuerySceneRule", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QuerySceneRuleResponse({}));
  }

  async querySceneRule(request: QuerySceneRuleRequest): Promise<QuerySceneRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.querySceneRuleWithOptions(request, runtime);
  }

  async querySchedulePeriodListWithOptions(request: QuerySchedulePeriodListRequest, runtime: $Util.RuntimeOptions): Promise<QuerySchedulePeriodListResponse> {
    Util.validateModel(request);
    return $tea.cast<QuerySchedulePeriodListResponse>(await this.doRequest("QuerySchedulePeriodList", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QuerySchedulePeriodListResponse({}));
  }

  async querySchedulePeriodList(request: QuerySchedulePeriodListRequest): Promise<QuerySchedulePeriodListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.querySchedulePeriodListWithOptions(request, runtime);
  }

  async queryShareTaskDeviceListWithOptions(request: QueryShareTaskDeviceListRequest, runtime: $Util.RuntimeOptions): Promise<QueryShareTaskDeviceListResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryShareTaskDeviceListResponse>(await this.doRequest("QueryShareTaskDeviceList", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryShareTaskDeviceListResponse({}));
  }

  async queryShareTaskDeviceList(request: QueryShareTaskDeviceListRequest): Promise<QueryShareTaskDeviceListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryShareTaskDeviceListWithOptions(request, runtime);
  }

  async querySolutionDeviceGroupPageWithOptions(request: QuerySolutionDeviceGroupPageRequest, runtime: $Util.RuntimeOptions): Promise<QuerySolutionDeviceGroupPageResponse> {
    Util.validateModel(request);
    return $tea.cast<QuerySolutionDeviceGroupPageResponse>(await this.doRequest("QuerySolutionDeviceGroupPage", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QuerySolutionDeviceGroupPageResponse({}));
  }

  async querySolutionDeviceGroupPage(request: QuerySolutionDeviceGroupPageRequest): Promise<QuerySolutionDeviceGroupPageResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.querySolutionDeviceGroupPageWithOptions(request, runtime);
  }

  async querySoundCodeLabelBatchFailedResultWithOptions(request: QuerySoundCodeLabelBatchFailedResultRequest, runtime: $Util.RuntimeOptions): Promise<QuerySoundCodeLabelBatchFailedResultResponse> {
    Util.validateModel(request);
    return $tea.cast<QuerySoundCodeLabelBatchFailedResultResponse>(await this.doRequest("QuerySoundCodeLabelBatchFailedResult", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QuerySoundCodeLabelBatchFailedResultResponse({}));
  }

  async querySoundCodeLabelBatchFailedResult(request: QuerySoundCodeLabelBatchFailedResultRequest): Promise<QuerySoundCodeLabelBatchFailedResultResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.querySoundCodeLabelBatchFailedResultWithOptions(request, runtime);
  }

  async querySoundCodeLabelBatchListWithOptions(request: QuerySoundCodeLabelBatchListRequest, runtime: $Util.RuntimeOptions): Promise<QuerySoundCodeLabelBatchListResponse> {
    Util.validateModel(request);
    return $tea.cast<QuerySoundCodeLabelBatchListResponse>(await this.doRequest("QuerySoundCodeLabelBatchList", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QuerySoundCodeLabelBatchListResponse({}));
  }

  async querySoundCodeLabelBatchList(request: QuerySoundCodeLabelBatchListRequest): Promise<QuerySoundCodeLabelBatchListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.querySoundCodeLabelBatchListWithOptions(request, runtime);
  }

  async querySoundCodeLabelListWithOptions(request: QuerySoundCodeLabelListRequest, runtime: $Util.RuntimeOptions): Promise<QuerySoundCodeLabelListResponse> {
    Util.validateModel(request);
    return $tea.cast<QuerySoundCodeLabelListResponse>(await this.doRequest("QuerySoundCodeLabelList", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QuerySoundCodeLabelListResponse({}));
  }

  async querySoundCodeLabelList(request: QuerySoundCodeLabelListRequest): Promise<QuerySoundCodeLabelListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.querySoundCodeLabelListWithOptions(request, runtime);
  }

  async querySoundCodeListWithOptions(request: QuerySoundCodeListRequest, runtime: $Util.RuntimeOptions): Promise<QuerySoundCodeListResponse> {
    Util.validateModel(request);
    return $tea.cast<QuerySoundCodeListResponse>(await this.doRequest("QuerySoundCodeList", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QuerySoundCodeListResponse({}));
  }

  async querySoundCodeList(request: QuerySoundCodeListRequest): Promise<QuerySoundCodeListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.querySoundCodeListWithOptions(request, runtime);
  }

  async querySoundCodeScheduleListWithOptions(request: QuerySoundCodeScheduleListRequest, runtime: $Util.RuntimeOptions): Promise<QuerySoundCodeScheduleListResponse> {
    Util.validateModel(request);
    return $tea.cast<QuerySoundCodeScheduleListResponse>(await this.doRequest("QuerySoundCodeScheduleList", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QuerySoundCodeScheduleListResponse({}));
  }

  async querySoundCodeScheduleList(request: QuerySoundCodeScheduleListRequest): Promise<QuerySoundCodeScheduleListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.querySoundCodeScheduleListWithOptions(request, runtime);
  }

  async querySpeechWithOptions(request: QuerySpeechRequest, runtime: $Util.RuntimeOptions): Promise<QuerySpeechResponse> {
    Util.validateModel(request);
    return $tea.cast<QuerySpeechResponse>(await this.doRequest("QuerySpeech", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QuerySpeechResponse({}));
  }

  async querySpeech(request: QuerySpeechRequest): Promise<QuerySpeechResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.querySpeechWithOptions(request, runtime);
  }

  async querySpeechDeviceWithOptions(request: QuerySpeechDeviceRequest, runtime: $Util.RuntimeOptions): Promise<QuerySpeechDeviceResponse> {
    Util.validateModel(request);
    return $tea.cast<QuerySpeechDeviceResponse>(await this.doRequest("QuerySpeechDevice", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QuerySpeechDeviceResponse({}));
  }

  async querySpeechDevice(request: QuerySpeechDeviceRequest): Promise<QuerySpeechDeviceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.querySpeechDeviceWithOptions(request, runtime);
  }

  async querySpeechLicenseDeviceListWithOptions(request: QuerySpeechLicenseDeviceListRequest, runtime: $Util.RuntimeOptions): Promise<QuerySpeechLicenseDeviceListResponse> {
    Util.validateModel(request);
    return $tea.cast<QuerySpeechLicenseDeviceListResponse>(await this.doRequest("QuerySpeechLicenseDeviceList", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QuerySpeechLicenseDeviceListResponse({}));
  }

  async querySpeechLicenseDeviceList(request: QuerySpeechLicenseDeviceListRequest): Promise<QuerySpeechLicenseDeviceListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.querySpeechLicenseDeviceListWithOptions(request, runtime);
  }

  async querySpeechListWithOptions(request: QuerySpeechListRequest, runtime: $Util.RuntimeOptions): Promise<QuerySpeechListResponse> {
    Util.validateModel(request);
    return $tea.cast<QuerySpeechListResponse>(await this.doRequest("QuerySpeechList", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QuerySpeechListResponse({}));
  }

  async querySpeechList(request: QuerySpeechListRequest): Promise<QuerySpeechListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.querySpeechListWithOptions(request, runtime);
  }

  async querySpeechPushJobWithOptions(request: QuerySpeechPushJobRequest, runtime: $Util.RuntimeOptions): Promise<QuerySpeechPushJobResponse> {
    Util.validateModel(request);
    return $tea.cast<QuerySpeechPushJobResponse>(await this.doRequest("QuerySpeechPushJob", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QuerySpeechPushJobResponse({}));
  }

  async querySpeechPushJob(request: QuerySpeechPushJobRequest): Promise<QuerySpeechPushJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.querySpeechPushJobWithOptions(request, runtime);
  }

  async querySpeechPushJobDeviceWithOptions(request: QuerySpeechPushJobDeviceRequest, runtime: $Util.RuntimeOptions): Promise<QuerySpeechPushJobDeviceResponse> {
    Util.validateModel(request);
    return $tea.cast<QuerySpeechPushJobDeviceResponse>(await this.doRequest("QuerySpeechPushJobDevice", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QuerySpeechPushJobDeviceResponse({}));
  }

  async querySpeechPushJobDevice(request: QuerySpeechPushJobDeviceRequest): Promise<QuerySpeechPushJobDeviceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.querySpeechPushJobDeviceWithOptions(request, runtime);
  }

  async querySpeechPushJobSpeechWithOptions(request: QuerySpeechPushJobSpeechRequest, runtime: $Util.RuntimeOptions): Promise<QuerySpeechPushJobSpeechResponse> {
    Util.validateModel(request);
    return $tea.cast<QuerySpeechPushJobSpeechResponse>(await this.doRequest("QuerySpeechPushJobSpeech", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QuerySpeechPushJobSpeechResponse({}));
  }

  async querySpeechPushJobSpeech(request: QuerySpeechPushJobSpeechRequest): Promise<QuerySpeechPushJobSpeechResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.querySpeechPushJobSpeechWithOptions(request, runtime);
  }

  async queryStudioAppDomainListOpenWithOptions(request: QueryStudioAppDomainListOpenRequest, runtime: $Util.RuntimeOptions): Promise<QueryStudioAppDomainListOpenResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryStudioAppDomainListOpenResponse>(await this.doRequest("QueryStudioAppDomainListOpen", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryStudioAppDomainListOpenResponse({}));
  }

  async queryStudioAppDomainListOpen(request: QueryStudioAppDomainListOpenRequest): Promise<QueryStudioAppDomainListOpenResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryStudioAppDomainListOpenWithOptions(request, runtime);
  }

  async queryStudioAppListWithOptions(request: QueryStudioAppListRequest, runtime: $Util.RuntimeOptions): Promise<QueryStudioAppListResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryStudioAppListResponse>(await this.doRequest("QueryStudioAppList", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryStudioAppListResponse({}));
  }

  async queryStudioAppList(request: QueryStudioAppListRequest): Promise<QueryStudioAppListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryStudioAppListWithOptions(request, runtime);
  }

  async queryStudioAppPageListOpenWithOptions(request: QueryStudioAppPageListOpenRequest, runtime: $Util.RuntimeOptions): Promise<QueryStudioAppPageListOpenResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryStudioAppPageListOpenResponse>(await this.doRequest("QueryStudioAppPageListOpen", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryStudioAppPageListOpenResponse({}));
  }

  async queryStudioAppPageListOpen(request: QueryStudioAppPageListOpenRequest): Promise<QueryStudioAppPageListOpenResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryStudioAppPageListOpenWithOptions(request, runtime);
  }

  async queryStudioProjectListWithOptions(request: QueryStudioProjectListRequest, runtime: $Util.RuntimeOptions): Promise<QueryStudioProjectListResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryStudioProjectListResponse>(await this.doRequest("QueryStudioProjectList", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryStudioProjectListResponse({}));
  }

  async queryStudioProjectList(request: QueryStudioProjectListRequest): Promise<QueryStudioProjectListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryStudioProjectListWithOptions(request, runtime);
  }

  async querySubscribeRelationWithOptions(request: QuerySubscribeRelationRequest, runtime: $Util.RuntimeOptions): Promise<QuerySubscribeRelationResponse> {
    Util.validateModel(request);
    return $tea.cast<QuerySubscribeRelationResponse>(await this.doRequest("QuerySubscribeRelation", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QuerySubscribeRelationResponse({}));
  }

  async querySubscribeRelation(request: QuerySubscribeRelationRequest): Promise<QuerySubscribeRelationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.querySubscribeRelationWithOptions(request, runtime);
  }

  async querySummarySceneRuleLogWithOptions(request: QuerySummarySceneRuleLogRequest, runtime: $Util.RuntimeOptions): Promise<QuerySummarySceneRuleLogResponse> {
    Util.validateModel(request);
    return $tea.cast<QuerySummarySceneRuleLogResponse>(await this.doRequest("QuerySummarySceneRuleLog", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QuerySummarySceneRuleLogResponse({}));
  }

  async querySummarySceneRuleLog(request: QuerySummarySceneRuleLogRequest): Promise<QuerySummarySceneRuleLogResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.querySummarySceneRuleLogWithOptions(request, runtime);
  }

  async querySuperDeviceGroupWithOptions(request: QuerySuperDeviceGroupRequest, runtime: $Util.RuntimeOptions): Promise<QuerySuperDeviceGroupResponse> {
    Util.validateModel(request);
    return $tea.cast<QuerySuperDeviceGroupResponse>(await this.doRequest("QuerySuperDeviceGroup", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QuerySuperDeviceGroupResponse({}));
  }

  async querySuperDeviceGroup(request: QuerySuperDeviceGroupRequest): Promise<QuerySuperDeviceGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.querySuperDeviceGroupWithOptions(request, runtime);
  }

  async queryTaskWithOptions(request: QueryTaskRequest, runtime: $Util.RuntimeOptions): Promise<QueryTaskResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryTaskResponse>(await this.doRequest("QueryTask", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryTaskResponse({}));
  }

  async queryTask(request: QueryTaskRequest): Promise<QueryTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryTaskWithOptions(request, runtime);
  }

  async queryThingModelWithOptions(request: QueryThingModelRequest, runtime: $Util.RuntimeOptions): Promise<QueryThingModelResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryThingModelResponse>(await this.doRequest("QueryThingModel", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryThingModelResponse({}));
  }

  async queryThingModel(request: QueryThingModelRequest): Promise<QueryThingModelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryThingModelWithOptions(request, runtime);
  }

  async queryThingModelExtendConfigWithOptions(request: QueryThingModelExtendConfigRequest, runtime: $Util.RuntimeOptions): Promise<QueryThingModelExtendConfigResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryThingModelExtendConfigResponse>(await this.doRequest("QueryThingModelExtendConfig", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryThingModelExtendConfigResponse({}));
  }

  async queryThingModelExtendConfig(request: QueryThingModelExtendConfigRequest): Promise<QueryThingModelExtendConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryThingModelExtendConfigWithOptions(request, runtime);
  }

  async queryThingModelExtendConfigPublishedWithOptions(request: QueryThingModelExtendConfigPublishedRequest, runtime: $Util.RuntimeOptions): Promise<QueryThingModelExtendConfigPublishedResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryThingModelExtendConfigPublishedResponse>(await this.doRequest("QueryThingModelExtendConfigPublished", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryThingModelExtendConfigPublishedResponse({}));
  }

  async queryThingModelExtendConfigPublished(request: QueryThingModelExtendConfigPublishedRequest): Promise<QueryThingModelExtendConfigPublishedResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryThingModelExtendConfigPublishedWithOptions(request, runtime);
  }

  async queryThingModelPublishedWithOptions(request: QueryThingModelPublishedRequest, runtime: $Util.RuntimeOptions): Promise<QueryThingModelPublishedResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryThingModelPublishedResponse>(await this.doRequest("QueryThingModelPublished", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryThingModelPublishedResponse({}));
  }

  async queryThingModelPublished(request: QueryThingModelPublishedRequest): Promise<QueryThingModelPublishedResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryThingModelPublishedWithOptions(request, runtime);
  }

  async queryTopicReverseRouteTableWithOptions(request: QueryTopicReverseRouteTableRequest, runtime: $Util.RuntimeOptions): Promise<QueryTopicReverseRouteTableResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryTopicReverseRouteTableResponse>(await this.doRequest("QueryTopicReverseRouteTable", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryTopicReverseRouteTableResponse({}));
  }

  async queryTopicReverseRouteTable(request: QueryTopicReverseRouteTableRequest): Promise<QueryTopicReverseRouteTableResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryTopicReverseRouteTableWithOptions(request, runtime);
  }

  async queryTopicRouteTableWithOptions(request: QueryTopicRouteTableRequest, runtime: $Util.RuntimeOptions): Promise<QueryTopicRouteTableResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryTopicRouteTableResponse>(await this.doRequest("QueryTopicRouteTable", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryTopicRouteTableResponse({}));
  }

  async queryTopicRouteTable(request: QueryTopicRouteTableRequest): Promise<QueryTopicRouteTableResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryTopicRouteTableWithOptions(request, runtime);
  }

  async queryVehicleDeviceWithOptions(request: QueryVehicleDeviceRequest, runtime: $Util.RuntimeOptions): Promise<QueryVehicleDeviceResponse> {
    Util.validateModel(request);
    return $tea.cast<QueryVehicleDeviceResponse>(await this.doRequest("QueryVehicleDevice", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new QueryVehicleDeviceResponse({}));
  }

  async queryVehicleDevice(request: QueryVehicleDeviceRequest): Promise<QueryVehicleDeviceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryVehicleDeviceWithOptions(request, runtime);
  }

  async RRpcWithOptions(request: RRpcRequest, runtime: $Util.RuntimeOptions): Promise<RRpcResponse> {
    Util.validateModel(request);
    return $tea.cast<RRpcResponse>(await this.doRequest("RRpc", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new RRpcResponse({}));
  }

  async RRpc(request: RRpcRequest): Promise<RRpcResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.RRpcWithOptions(request, runtime);
  }

  async reBindLicenseDeviceWithOptions(request: ReBindLicenseDeviceRequest, runtime: $Util.RuntimeOptions): Promise<ReBindLicenseDeviceResponse> {
    Util.validateModel(request);
    return $tea.cast<ReBindLicenseDeviceResponse>(await this.doRequest("ReBindLicenseDevice", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new ReBindLicenseDeviceResponse({}));
  }

  async reBindLicenseDevice(request: ReBindLicenseDeviceRequest): Promise<ReBindLicenseDeviceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.reBindLicenseDeviceWithOptions(request, runtime);
  }

  async recognizeCarNumWithOptions(request: RecognizeCarNumRequest, runtime: $Util.RuntimeOptions): Promise<RecognizeCarNumResponse> {
    Util.validateModel(request);
    return $tea.cast<RecognizeCarNumResponse>(await this.doRequest("RecognizeCarNum", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new RecognizeCarNumResponse({}));
  }

  async recognizeCarNum(request: RecognizeCarNumRequest): Promise<RecognizeCarNumResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.recognizeCarNumWithOptions(request, runtime);
  }

  async recognizePictureGeneralWithOptions(request: RecognizePictureGeneralRequest, runtime: $Util.RuntimeOptions): Promise<RecognizePictureGeneralResponse> {
    Util.validateModel(request);
    return $tea.cast<RecognizePictureGeneralResponse>(await this.doRequest("RecognizePictureGeneral", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new RecognizePictureGeneralResponse({}));
  }

  async recognizePictureGeneral(request: RecognizePictureGeneralRequest): Promise<RecognizePictureGeneralResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.recognizePictureGeneralWithOptions(request, runtime);
  }

  async refreshDeviceTunnelSharePasswordWithOptions(request: RefreshDeviceTunnelSharePasswordRequest, runtime: $Util.RuntimeOptions): Promise<RefreshDeviceTunnelSharePasswordResponse> {
    Util.validateModel(request);
    return $tea.cast<RefreshDeviceTunnelSharePasswordResponse>(await this.doRequest("RefreshDeviceTunnelSharePassword", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new RefreshDeviceTunnelSharePasswordResponse({}));
  }

  async refreshDeviceTunnelSharePassword(request: RefreshDeviceTunnelSharePasswordRequest): Promise<RefreshDeviceTunnelSharePasswordResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.refreshDeviceTunnelSharePasswordWithOptions(request, runtime);
  }

  async refreshStudioAppTokenOpenWithOptions(request: RefreshStudioAppTokenOpenRequest, runtime: $Util.RuntimeOptions): Promise<RefreshStudioAppTokenOpenResponse> {
    Util.validateModel(request);
    return $tea.cast<RefreshStudioAppTokenOpenResponse>(await this.doRequest("RefreshStudioAppTokenOpen", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new RefreshStudioAppTokenOpenResponse({}));
  }

  async refreshStudioAppTokenOpen(request: RefreshStudioAppTokenOpenRequest): Promise<RefreshStudioAppTokenOpenResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.refreshStudioAppTokenOpenWithOptions(request, runtime);
  }

  async registerDeviceWithOptions(request: RegisterDeviceRequest, runtime: $Util.RuntimeOptions): Promise<RegisterDeviceResponse> {
    Util.validateModel(request);
    return $tea.cast<RegisterDeviceResponse>(await this.doRequest("RegisterDevice", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new RegisterDeviceResponse({}));
  }

  async registerDevice(request: RegisterDeviceRequest): Promise<RegisterDeviceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.registerDeviceWithOptions(request, runtime);
  }

  async releaseEdgeDriverVersionWithOptions(request: ReleaseEdgeDriverVersionRequest, runtime: $Util.RuntimeOptions): Promise<ReleaseEdgeDriverVersionResponse> {
    Util.validateModel(request);
    return $tea.cast<ReleaseEdgeDriverVersionResponse>(await this.doRequest("ReleaseEdgeDriverVersion", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new ReleaseEdgeDriverVersionResponse({}));
  }

  async releaseEdgeDriverVersion(request: ReleaseEdgeDriverVersionRequest): Promise<ReleaseEdgeDriverVersionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.releaseEdgeDriverVersionWithOptions(request, runtime);
  }

  async releaseProductWithOptions(request: ReleaseProductRequest, runtime: $Util.RuntimeOptions): Promise<ReleaseProductResponse> {
    Util.validateModel(request);
    return $tea.cast<ReleaseProductResponse>(await this.doRequest("ReleaseProduct", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new ReleaseProductResponse({}));
  }

  async releaseProduct(request: ReleaseProductRequest): Promise<ReleaseProductResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.releaseProductWithOptions(request, runtime);
  }

  async removeThingTopoWithOptions(request: RemoveThingTopoRequest, runtime: $Util.RuntimeOptions): Promise<RemoveThingTopoResponse> {
    Util.validateModel(request);
    return $tea.cast<RemoveThingTopoResponse>(await this.doRequest("RemoveThingTopo", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new RemoveThingTopoResponse({}));
  }

  async removeThingTopo(request: RemoveThingTopoRequest): Promise<RemoveThingTopoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.removeThingTopoWithOptions(request, runtime);
  }

  async replaceEdgeInstanceGatewayWithOptions(request: ReplaceEdgeInstanceGatewayRequest, runtime: $Util.RuntimeOptions): Promise<ReplaceEdgeInstanceGatewayResponse> {
    Util.validateModel(request);
    return $tea.cast<ReplaceEdgeInstanceGatewayResponse>(await this.doRequest("ReplaceEdgeInstanceGateway", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new ReplaceEdgeInstanceGatewayResponse({}));
  }

  async replaceEdgeInstanceGateway(request: ReplaceEdgeInstanceGatewayRequest): Promise<ReplaceEdgeInstanceGatewayResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.replaceEdgeInstanceGatewayWithOptions(request, runtime);
  }

  async rerunJobWithOptions(request: RerunJobRequest, runtime: $Util.RuntimeOptions): Promise<RerunJobResponse> {
    Util.validateModel(request);
    return $tea.cast<RerunJobResponse>(await this.doRequest("RerunJob", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new RerunJobResponse({}));
  }

  async rerunJob(request: RerunJobRequest): Promise<RerunJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.rerunJobWithOptions(request, runtime);
  }

  async resetConsumerGroupPositionWithOptions(request: ResetConsumerGroupPositionRequest, runtime: $Util.RuntimeOptions): Promise<ResetConsumerGroupPositionResponse> {
    Util.validateModel(request);
    return $tea.cast<ResetConsumerGroupPositionResponse>(await this.doRequest("ResetConsumerGroupPosition", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new ResetConsumerGroupPositionResponse({}));
  }

  async resetConsumerGroupPosition(request: ResetConsumerGroupPositionRequest): Promise<ResetConsumerGroupPositionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.resetConsumerGroupPositionWithOptions(request, runtime);
  }

  async resetThingWithOptions(request: ResetThingRequest, runtime: $Util.RuntimeOptions): Promise<ResetThingResponse> {
    Util.validateModel(request);
    return $tea.cast<ResetThingResponse>(await this.doRequest("ResetThing", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new ResetThingResponse({}));
  }

  async resetThing(request: ResetThingRequest): Promise<ResetThingResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.resetThingWithOptions(request, runtime);
  }

  async retrySoundCodeLabelBatchWithOptions(request: RetrySoundCodeLabelBatchRequest, runtime: $Util.RuntimeOptions): Promise<RetrySoundCodeLabelBatchResponse> {
    Util.validateModel(request);
    return $tea.cast<RetrySoundCodeLabelBatchResponse>(await this.doRequest("RetrySoundCodeLabelBatch", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new RetrySoundCodeLabelBatchResponse({}));
  }

  async retrySoundCodeLabelBatch(request: RetrySoundCodeLabelBatchRequest): Promise<RetrySoundCodeLabelBatchResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.retrySoundCodeLabelBatchWithOptions(request, runtime);
  }

  async reupgradeOTATaskWithOptions(request: ReupgradeOTATaskRequest, runtime: $Util.RuntimeOptions): Promise<ReupgradeOTATaskResponse> {
    Util.validateModel(request);
    return $tea.cast<ReupgradeOTATaskResponse>(await this.doRequest("ReupgradeOTATask", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new ReupgradeOTATaskResponse({}));
  }

  async reupgradeOTATask(request: ReupgradeOTATaskRequest): Promise<ReupgradeOTATaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.reupgradeOTATaskWithOptions(request, runtime);
  }

  async saveDevicePropWithOptions(request: SaveDevicePropRequest, runtime: $Util.RuntimeOptions): Promise<SaveDevicePropResponse> {
    Util.validateModel(request);
    return $tea.cast<SaveDevicePropResponse>(await this.doRequest("SaveDeviceProp", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new SaveDevicePropResponse({}));
  }

  async saveDeviceProp(request: SaveDevicePropRequest): Promise<SaveDevicePropResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.saveDevicePropWithOptions(request, runtime);
  }

  async saveScriptWithOptions(request: SaveScriptRequest, runtime: $Util.RuntimeOptions): Promise<SaveScriptResponse> {
    Util.validateModel(request);
    return $tea.cast<SaveScriptResponse>(await this.doRequest("SaveScript", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new SaveScriptResponse({}));
  }

  async saveScript(request: SaveScriptRequest): Promise<SaveScriptResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.saveScriptWithOptions(request, runtime);
  }

  async setDeviceDesiredPropertyWithOptions(request: SetDeviceDesiredPropertyRequest, runtime: $Util.RuntimeOptions): Promise<SetDeviceDesiredPropertyResponse> {
    Util.validateModel(request);
    return $tea.cast<SetDeviceDesiredPropertyResponse>(await this.doRequest("SetDeviceDesiredProperty", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new SetDeviceDesiredPropertyResponse({}));
  }

  async setDeviceDesiredProperty(request: SetDeviceDesiredPropertyRequest): Promise<SetDeviceDesiredPropertyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setDeviceDesiredPropertyWithOptions(request, runtime);
  }

  async setDeviceGroupTagsWithOptions(request: SetDeviceGroupTagsRequest, runtime: $Util.RuntimeOptions): Promise<SetDeviceGroupTagsResponse> {
    Util.validateModel(request);
    return $tea.cast<SetDeviceGroupTagsResponse>(await this.doRequest("SetDeviceGroupTags", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new SetDeviceGroupTagsResponse({}));
  }

  async setDeviceGroupTags(request: SetDeviceGroupTagsRequest): Promise<SetDeviceGroupTagsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setDeviceGroupTagsWithOptions(request, runtime);
  }

  async setDevicePropertyWithOptions(request: SetDevicePropertyRequest, runtime: $Util.RuntimeOptions): Promise<SetDevicePropertyResponse> {
    Util.validateModel(request);
    return $tea.cast<SetDevicePropertyResponse>(await this.doRequest("SetDeviceProperty", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new SetDevicePropertyResponse({}));
  }

  async setDeviceProperty(request: SetDevicePropertyRequest): Promise<SetDevicePropertyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setDevicePropertyWithOptions(request, runtime);
  }

  async setDevicesPropertyWithOptions(request: SetDevicesPropertyRequest, runtime: $Util.RuntimeOptions): Promise<SetDevicesPropertyResponse> {
    Util.validateModel(request);
    return $tea.cast<SetDevicesPropertyResponse>(await this.doRequest("SetDevicesProperty", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new SetDevicesPropertyResponse({}));
  }

  async setDevicesProperty(request: SetDevicesPropertyRequest): Promise<SetDevicesPropertyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setDevicesPropertyWithOptions(request, runtime);
  }

  async setEdgeInstanceDriverConfigsWithOptions(request: SetEdgeInstanceDriverConfigsRequest, runtime: $Util.RuntimeOptions): Promise<SetEdgeInstanceDriverConfigsResponse> {
    Util.validateModel(request);
    return $tea.cast<SetEdgeInstanceDriverConfigsResponse>(await this.doRequest("SetEdgeInstanceDriverConfigs", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new SetEdgeInstanceDriverConfigsResponse({}));
  }

  async setEdgeInstanceDriverConfigs(request: SetEdgeInstanceDriverConfigsRequest): Promise<SetEdgeInstanceDriverConfigsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setEdgeInstanceDriverConfigsWithOptions(request, runtime);
  }

  async setProductCertInfoWithOptions(request: SetProductCertInfoRequest, runtime: $Util.RuntimeOptions): Promise<SetProductCertInfoResponse> {
    Util.validateModel(request);
    return $tea.cast<SetProductCertInfoResponse>(await this.doRequest("SetProductCertInfo", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new SetProductCertInfoResponse({}));
  }

  async setProductCertInfo(request: SetProductCertInfoRequest): Promise<SetProductCertInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setProductCertInfoWithOptions(request, runtime);
  }

  async setStudioProjectCooperationWithOptions(request: SetStudioProjectCooperationRequest, runtime: $Util.RuntimeOptions): Promise<SetStudioProjectCooperationResponse> {
    Util.validateModel(request);
    return $tea.cast<SetStudioProjectCooperationResponse>(await this.doRequest("SetStudioProjectCooperation", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new SetStudioProjectCooperationResponse({}));
  }

  async setStudioProjectCooperation(request: SetStudioProjectCooperationRequest): Promise<SetStudioProjectCooperationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setStudioProjectCooperationWithOptions(request, runtime);
  }

  async setupStudioAppAuthModeOpenWithOptions(request: SetupStudioAppAuthModeOpenRequest, runtime: $Util.RuntimeOptions): Promise<SetupStudioAppAuthModeOpenResponse> {
    Util.validateModel(request);
    return $tea.cast<SetupStudioAppAuthModeOpenResponse>(await this.doRequest("SetupStudioAppAuthModeOpen", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new SetupStudioAppAuthModeOpenResponse({}));
  }

  async setupStudioAppAuthModeOpen(request: SetupStudioAppAuthModeOpenRequest): Promise<SetupStudioAppAuthModeOpenResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setupStudioAppAuthModeOpenWithOptions(request, runtime);
  }

  async shareSpeechByCombinationWithOptions(request: ShareSpeechByCombinationRequest, runtime: $Util.RuntimeOptions): Promise<ShareSpeechByCombinationResponse> {
    Util.validateModel(request);
    return $tea.cast<ShareSpeechByCombinationResponse>(await this.doRequest("ShareSpeechByCombination", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new ShareSpeechByCombinationResponse({}));
  }

  async shareSpeechByCombination(request: ShareSpeechByCombinationRequest): Promise<ShareSpeechByCombinationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.shareSpeechByCombinationWithOptions(request, runtime);
  }

  async speechByCombinationWithOptions(request: SpeechByCombinationRequest, runtime: $Util.RuntimeOptions): Promise<SpeechByCombinationResponse> {
    Util.validateModel(request);
    return $tea.cast<SpeechByCombinationResponse>(await this.doRequest("SpeechByCombination", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new SpeechByCombinationResponse({}));
  }

  async speechByCombination(request: SpeechByCombinationRequest): Promise<SpeechByCombinationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.speechByCombinationWithOptions(request, runtime);
  }

  async speechBySynthesisWithOptions(request: SpeechBySynthesisRequest, runtime: $Util.RuntimeOptions): Promise<SpeechBySynthesisResponse> {
    Util.validateModel(request);
    return $tea.cast<SpeechBySynthesisResponse>(await this.doRequest("SpeechBySynthesis", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new SpeechBySynthesisResponse({}));
  }

  async speechBySynthesis(request: SpeechBySynthesisRequest): Promise<SpeechBySynthesisResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.speechBySynthesisWithOptions(request, runtime);
  }

  async startParserWithOptions(request: StartParserRequest, runtime: $Util.RuntimeOptions): Promise<StartParserResponse> {
    Util.validateModel(request);
    return $tea.cast<StartParserResponse>(await this.doRequest("StartParser", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new StartParserResponse({}));
  }

  async startParser(request: StartParserRequest): Promise<StartParserResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.startParserWithOptions(request, runtime);
  }

  async startRuleWithOptions(request: StartRuleRequest, runtime: $Util.RuntimeOptions): Promise<StartRuleResponse> {
    Util.validateModel(request);
    return $tea.cast<StartRuleResponse>(await this.doRequest("StartRule", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new StartRuleResponse({}));
  }

  async startRule(request: StartRuleRequest): Promise<StartRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.startRuleWithOptions(request, runtime);
  }

  async stopParserWithOptions(request: StopParserRequest, runtime: $Util.RuntimeOptions): Promise<StopParserResponse> {
    Util.validateModel(request);
    return $tea.cast<StopParserResponse>(await this.doRequest("StopParser", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new StopParserResponse({}));
  }

  async stopParser(request: StopParserRequest): Promise<StopParserResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.stopParserWithOptions(request, runtime);
  }

  async stopRuleWithOptions(request: StopRuleRequest, runtime: $Util.RuntimeOptions): Promise<StopRuleResponse> {
    Util.validateModel(request);
    return $tea.cast<StopRuleResponse>(await this.doRequest("StopRule", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new StopRuleResponse({}));
  }

  async stopRule(request: StopRuleRequest): Promise<StopRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.stopRuleWithOptions(request, runtime);
  }

  async subscribeTopicWithOptions(request: SubscribeTopicRequest, runtime: $Util.RuntimeOptions): Promise<SubscribeTopicResponse> {
    Util.validateModel(request);
    return $tea.cast<SubscribeTopicResponse>(await this.doRequest("SubscribeTopic", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new SubscribeTopicResponse({}));
  }

  async subscribeTopic(request: SubscribeTopicRequest): Promise<SubscribeTopicResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.subscribeTopicWithOptions(request, runtime);
  }

  async syncSpeechByCombinationWithOptions(request: SyncSpeechByCombinationRequest, runtime: $Util.RuntimeOptions): Promise<SyncSpeechByCombinationResponse> {
    Util.validateModel(request);
    return $tea.cast<SyncSpeechByCombinationResponse>(await this.doRequest("SyncSpeechByCombination", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new SyncSpeechByCombinationResponse({}));
  }

  async syncSpeechByCombination(request: SyncSpeechByCombinationRequest): Promise<SyncSpeechByCombinationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.syncSpeechByCombinationWithOptions(request, runtime);
  }

  async testSpeechWithOptions(tmp: TestSpeechRequest, runtime: $Util.RuntimeOptions): Promise<TestSpeechResponse> {
    Util.validateModel(tmp);
    let request = new TestSpeechShrinkRequest({ });
    RPCUtil.convert(tmp, request);
    if (!Util.isUnset(tmp.soundCodeConfig)) {
      request.soundCodeConfigShrink = Util.toJSONString(tmp.soundCodeConfig);
    }

    return $tea.cast<TestSpeechResponse>(await this.doRequest("TestSpeech", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new TestSpeechResponse({}));
  }

  async testSpeech(request: TestSpeechRequest): Promise<TestSpeechResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.testSpeechWithOptions(request, runtime);
  }

  async transformClientIdWithOptions(request: TransformClientIdRequest, runtime: $Util.RuntimeOptions): Promise<TransformClientIdResponse> {
    Util.validateModel(request);
    return $tea.cast<TransformClientIdResponse>(await this.doRequest("TransformClientId", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new TransformClientIdResponse({}));
  }

  async transformClientId(request: TransformClientIdRequest): Promise<TransformClientIdResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.transformClientIdWithOptions(request, runtime);
  }

  async triggerSceneRuleWithOptions(request: TriggerSceneRuleRequest, runtime: $Util.RuntimeOptions): Promise<TriggerSceneRuleResponse> {
    Util.validateModel(request);
    return $tea.cast<TriggerSceneRuleResponse>(await this.doRequest("TriggerSceneRule", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new TriggerSceneRuleResponse({}));
  }

  async triggerSceneRule(request: TriggerSceneRuleRequest): Promise<TriggerSceneRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.triggerSceneRuleWithOptions(request, runtime);
  }

  async unbindApplicationFromEdgeInstanceWithOptions(request: UnbindApplicationFromEdgeInstanceRequest, runtime: $Util.RuntimeOptions): Promise<UnbindApplicationFromEdgeInstanceResponse> {
    Util.validateModel(request);
    return $tea.cast<UnbindApplicationFromEdgeInstanceResponse>(await this.doRequest("UnbindApplicationFromEdgeInstance", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new UnbindApplicationFromEdgeInstanceResponse({}));
  }

  async unbindApplicationFromEdgeInstance(request: UnbindApplicationFromEdgeInstanceRequest): Promise<UnbindApplicationFromEdgeInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.unbindApplicationFromEdgeInstanceWithOptions(request, runtime);
  }

  async unbindDriverFromEdgeInstanceWithOptions(request: UnbindDriverFromEdgeInstanceRequest, runtime: $Util.RuntimeOptions): Promise<UnbindDriverFromEdgeInstanceResponse> {
    Util.validateModel(request);
    return $tea.cast<UnbindDriverFromEdgeInstanceResponse>(await this.doRequest("UnbindDriverFromEdgeInstance", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new UnbindDriverFromEdgeInstanceResponse({}));
  }

  async unbindDriverFromEdgeInstance(request: UnbindDriverFromEdgeInstanceRequest): Promise<UnbindDriverFromEdgeInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.unbindDriverFromEdgeInstanceWithOptions(request, runtime);
  }

  async unbindLicenseProductWithOptions(request: UnbindLicenseProductRequest, runtime: $Util.RuntimeOptions): Promise<UnbindLicenseProductResponse> {
    Util.validateModel(request);
    return $tea.cast<UnbindLicenseProductResponse>(await this.doRequest("UnbindLicenseProduct", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new UnbindLicenseProductResponse({}));
  }

  async unbindLicenseProduct(request: UnbindLicenseProductRequest): Promise<UnbindLicenseProductResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.unbindLicenseProductWithOptions(request, runtime);
  }

  async unbindRoleFromEdgeInstanceWithOptions(request: UnbindRoleFromEdgeInstanceRequest, runtime: $Util.RuntimeOptions): Promise<UnbindRoleFromEdgeInstanceResponse> {
    Util.validateModel(request);
    return $tea.cast<UnbindRoleFromEdgeInstanceResponse>(await this.doRequest("UnbindRoleFromEdgeInstance", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new UnbindRoleFromEdgeInstanceResponse({}));
  }

  async unbindRoleFromEdgeInstance(request: UnbindRoleFromEdgeInstanceRequest): Promise<UnbindRoleFromEdgeInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.unbindRoleFromEdgeInstanceWithOptions(request, runtime);
  }

  async unbindSceneRuleFromEdgeInstanceWithOptions(request: UnbindSceneRuleFromEdgeInstanceRequest, runtime: $Util.RuntimeOptions): Promise<UnbindSceneRuleFromEdgeInstanceResponse> {
    Util.validateModel(request);
    return $tea.cast<UnbindSceneRuleFromEdgeInstanceResponse>(await this.doRequest("UnbindSceneRuleFromEdgeInstance", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new UnbindSceneRuleFromEdgeInstanceResponse({}));
  }

  async unbindSceneRuleFromEdgeInstance(request: UnbindSceneRuleFromEdgeInstanceRequest): Promise<UnbindSceneRuleFromEdgeInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.unbindSceneRuleFromEdgeInstanceWithOptions(request, runtime);
  }

  async updateConsumerGroupWithOptions(request: UpdateConsumerGroupRequest, runtime: $Util.RuntimeOptions): Promise<UpdateConsumerGroupResponse> {
    Util.validateModel(request);
    return $tea.cast<UpdateConsumerGroupResponse>(await this.doRequest("UpdateConsumerGroup", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new UpdateConsumerGroupResponse({}));
  }

  async updateConsumerGroup(request: UpdateConsumerGroupRequest): Promise<UpdateConsumerGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateConsumerGroupWithOptions(request, runtime);
  }

  async updateDestinationWithOptions(request: UpdateDestinationRequest, runtime: $Util.RuntimeOptions): Promise<UpdateDestinationResponse> {
    Util.validateModel(request);
    return $tea.cast<UpdateDestinationResponse>(await this.doRequest("UpdateDestination", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new UpdateDestinationResponse({}));
  }

  async updateDestination(request: UpdateDestinationRequest): Promise<UpdateDestinationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateDestinationWithOptions(request, runtime);
  }

  async updateDeviceGroupWithOptions(request: UpdateDeviceGroupRequest, runtime: $Util.RuntimeOptions): Promise<UpdateDeviceGroupResponse> {
    Util.validateModel(request);
    return $tea.cast<UpdateDeviceGroupResponse>(await this.doRequest("UpdateDeviceGroup", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new UpdateDeviceGroupResponse({}));
  }

  async updateDeviceGroup(request: UpdateDeviceGroupRequest): Promise<UpdateDeviceGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateDeviceGroupWithOptions(request, runtime);
  }

  async updateDeviceShadowWithOptions(request: UpdateDeviceShadowRequest, runtime: $Util.RuntimeOptions): Promise<UpdateDeviceShadowResponse> {
    Util.validateModel(request);
    return $tea.cast<UpdateDeviceShadowResponse>(await this.doRequest("UpdateDeviceShadow", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new UpdateDeviceShadowResponse({}));
  }

  async updateDeviceShadow(request: UpdateDeviceShadowRequest): Promise<UpdateDeviceShadowResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateDeviceShadowWithOptions(request, runtime);
  }

  async updateEdgeDriverVersionWithOptions(request: UpdateEdgeDriverVersionRequest, runtime: $Util.RuntimeOptions): Promise<UpdateEdgeDriverVersionResponse> {
    Util.validateModel(request);
    return $tea.cast<UpdateEdgeDriverVersionResponse>(await this.doRequest("UpdateEdgeDriverVersion", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new UpdateEdgeDriverVersionResponse({}));
  }

  async updateEdgeDriverVersion(request: UpdateEdgeDriverVersionRequest): Promise<UpdateEdgeDriverVersionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateEdgeDriverVersionWithOptions(request, runtime);
  }

  async updateEdgeInstanceWithOptions(request: UpdateEdgeInstanceRequest, runtime: $Util.RuntimeOptions): Promise<UpdateEdgeInstanceResponse> {
    Util.validateModel(request);
    return $tea.cast<UpdateEdgeInstanceResponse>(await this.doRequest("UpdateEdgeInstance", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new UpdateEdgeInstanceResponse({}));
  }

  async updateEdgeInstance(request: UpdateEdgeInstanceRequest): Promise<UpdateEdgeInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateEdgeInstanceWithOptions(request, runtime);
  }

  async updateEdgeInstanceChannelWithOptions(request: UpdateEdgeInstanceChannelRequest, runtime: $Util.RuntimeOptions): Promise<UpdateEdgeInstanceChannelResponse> {
    Util.validateModel(request);
    return $tea.cast<UpdateEdgeInstanceChannelResponse>(await this.doRequest("UpdateEdgeInstanceChannel", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new UpdateEdgeInstanceChannelResponse({}));
  }

  async updateEdgeInstanceChannel(request: UpdateEdgeInstanceChannelRequest): Promise<UpdateEdgeInstanceChannelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateEdgeInstanceChannelWithOptions(request, runtime);
  }

  async updateEdgeInstanceMessageRoutingWithOptions(request: UpdateEdgeInstanceMessageRoutingRequest, runtime: $Util.RuntimeOptions): Promise<UpdateEdgeInstanceMessageRoutingResponse> {
    Util.validateModel(request);
    return $tea.cast<UpdateEdgeInstanceMessageRoutingResponse>(await this.doRequest("UpdateEdgeInstanceMessageRouting", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new UpdateEdgeInstanceMessageRoutingResponse({}));
  }

  async updateEdgeInstanceMessageRouting(request: UpdateEdgeInstanceMessageRoutingRequest): Promise<UpdateEdgeInstanceMessageRoutingResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateEdgeInstanceMessageRoutingWithOptions(request, runtime);
  }

  async updateJobWithOptions(tmp: UpdateJobRequest, runtime: $Util.RuntimeOptions): Promise<UpdateJobResponse> {
    Util.validateModel(tmp);
    let request = new UpdateJobShrinkRequest({ });
    RPCUtil.convert(tmp, request);
    if (!Util.isUnset(tmp.rolloutConfig)) {
      request.rolloutConfigShrink = Util.toJSONString(tmp.rolloutConfig);
    }

    if (!Util.isUnset(tmp.timeoutConfig)) {
      request.timeoutConfigShrink = Util.toJSONString(tmp.timeoutConfig);
    }

    return $tea.cast<UpdateJobResponse>(await this.doRequest("UpdateJob", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new UpdateJobResponse({}));
  }

  async updateJob(request: UpdateJobRequest): Promise<UpdateJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateJobWithOptions(request, runtime);
  }

  async updateOTAModuleWithOptions(request: UpdateOTAModuleRequest, runtime: $Util.RuntimeOptions): Promise<UpdateOTAModuleResponse> {
    Util.validateModel(request);
    return $tea.cast<UpdateOTAModuleResponse>(await this.doRequest("UpdateOTAModule", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new UpdateOTAModuleResponse({}));
  }

  async updateOTAModule(request: UpdateOTAModuleRequest): Promise<UpdateOTAModuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateOTAModuleWithOptions(request, runtime);
  }

  async updateParserWithOptions(request: UpdateParserRequest, runtime: $Util.RuntimeOptions): Promise<UpdateParserResponse> {
    Util.validateModel(request);
    return $tea.cast<UpdateParserResponse>(await this.doRequest("UpdateParser", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new UpdateParserResponse({}));
  }

  async updateParser(request: UpdateParserRequest): Promise<UpdateParserResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateParserWithOptions(request, runtime);
  }

  async updateParserDataSourceWithOptions(request: UpdateParserDataSourceRequest, runtime: $Util.RuntimeOptions): Promise<UpdateParserDataSourceResponse> {
    Util.validateModel(request);
    return $tea.cast<UpdateParserDataSourceResponse>(await this.doRequest("UpdateParserDataSource", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new UpdateParserDataSourceResponse({}));
  }

  async updateParserDataSource(request: UpdateParserDataSourceRequest): Promise<UpdateParserDataSourceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateParserDataSourceWithOptions(request, runtime);
  }

  async updateProductWithOptions(request: UpdateProductRequest, runtime: $Util.RuntimeOptions): Promise<UpdateProductResponse> {
    Util.validateModel(request);
    return $tea.cast<UpdateProductResponse>(await this.doRequest("UpdateProduct", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new UpdateProductResponse({}));
  }

  async updateProduct(request: UpdateProductRequest): Promise<UpdateProductResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateProductWithOptions(request, runtime);
  }

  async updateProductFilterConfigWithOptions(request: UpdateProductFilterConfigRequest, runtime: $Util.RuntimeOptions): Promise<UpdateProductFilterConfigResponse> {
    Util.validateModel(request);
    return $tea.cast<UpdateProductFilterConfigResponse>(await this.doRequest("UpdateProductFilterConfig", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new UpdateProductFilterConfigResponse({}));
  }

  async updateProductFilterConfig(request: UpdateProductFilterConfigRequest): Promise<UpdateProductFilterConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateProductFilterConfigWithOptions(request, runtime);
  }

  async updateProductTagsWithOptions(request: UpdateProductTagsRequest, runtime: $Util.RuntimeOptions): Promise<UpdateProductTagsResponse> {
    Util.validateModel(request);
    return $tea.cast<UpdateProductTagsResponse>(await this.doRequest("UpdateProductTags", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new UpdateProductTagsResponse({}));
  }

  async updateProductTags(request: UpdateProductTagsRequest): Promise<UpdateProductTagsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateProductTagsWithOptions(request, runtime);
  }

  async updateProductTopicWithOptions(request: UpdateProductTopicRequest, runtime: $Util.RuntimeOptions): Promise<UpdateProductTopicResponse> {
    Util.validateModel(request);
    return $tea.cast<UpdateProductTopicResponse>(await this.doRequest("UpdateProductTopic", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new UpdateProductTopicResponse({}));
  }

  async updateProductTopic(request: UpdateProductTopicRequest): Promise<UpdateProductTopicResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateProductTopicWithOptions(request, runtime);
  }

  async updateRuleWithOptions(request: UpdateRuleRequest, runtime: $Util.RuntimeOptions): Promise<UpdateRuleResponse> {
    Util.validateModel(request);
    return $tea.cast<UpdateRuleResponse>(await this.doRequest("UpdateRule", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new UpdateRuleResponse({}));
  }

  async updateRule(request: UpdateRuleRequest): Promise<UpdateRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateRuleWithOptions(request, runtime);
  }

  async updateRuleActionWithOptions(request: UpdateRuleActionRequest, runtime: $Util.RuntimeOptions): Promise<UpdateRuleActionResponse> {
    Util.validateModel(request);
    return $tea.cast<UpdateRuleActionResponse>(await this.doRequest("UpdateRuleAction", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new UpdateRuleActionResponse({}));
  }

  async updateRuleAction(request: UpdateRuleActionRequest): Promise<UpdateRuleActionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateRuleActionWithOptions(request, runtime);
  }

  async updateSceneRuleWithOptions(request: UpdateSceneRuleRequest, runtime: $Util.RuntimeOptions): Promise<UpdateSceneRuleResponse> {
    Util.validateModel(request);
    return $tea.cast<UpdateSceneRuleResponse>(await this.doRequest("UpdateSceneRule", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new UpdateSceneRuleResponse({}));
  }

  async updateSceneRule(request: UpdateSceneRuleRequest): Promise<UpdateSceneRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateSceneRuleWithOptions(request, runtime);
  }

  async updateSchedulePeriodWithOptions(request: UpdateSchedulePeriodRequest, runtime: $Util.RuntimeOptions): Promise<UpdateSchedulePeriodResponse> {
    Util.validateModel(request);
    return $tea.cast<UpdateSchedulePeriodResponse>(await this.doRequest("UpdateSchedulePeriod", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new UpdateSchedulePeriodResponse({}));
  }

  async updateSchedulePeriod(request: UpdateSchedulePeriodRequest): Promise<UpdateSchedulePeriodResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateSchedulePeriodWithOptions(request, runtime);
  }

  async updateSoundCodeWithOptions(request: UpdateSoundCodeRequest, runtime: $Util.RuntimeOptions): Promise<UpdateSoundCodeResponse> {
    Util.validateModel(request);
    return $tea.cast<UpdateSoundCodeResponse>(await this.doRequest("UpdateSoundCode", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new UpdateSoundCodeResponse({}));
  }

  async updateSoundCode(request: UpdateSoundCodeRequest): Promise<UpdateSoundCodeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateSoundCodeWithOptions(request, runtime);
  }

  async updateSoundCodeLabelWithOptions(request: UpdateSoundCodeLabelRequest, runtime: $Util.RuntimeOptions): Promise<UpdateSoundCodeLabelResponse> {
    Util.validateModel(request);
    return $tea.cast<UpdateSoundCodeLabelResponse>(await this.doRequest("UpdateSoundCodeLabel", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new UpdateSoundCodeLabelResponse({}));
  }

  async updateSoundCodeLabel(request: UpdateSoundCodeLabelRequest): Promise<UpdateSoundCodeLabelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateSoundCodeLabelWithOptions(request, runtime);
  }

  async updateSoundCodeScheduleWithOptions(request: UpdateSoundCodeScheduleRequest, runtime: $Util.RuntimeOptions): Promise<UpdateSoundCodeScheduleResponse> {
    Util.validateModel(request);
    return $tea.cast<UpdateSoundCodeScheduleResponse>(await this.doRequest("UpdateSoundCodeSchedule", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new UpdateSoundCodeScheduleResponse({}));
  }

  async updateSoundCodeSchedule(request: UpdateSoundCodeScheduleRequest): Promise<UpdateSoundCodeScheduleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateSoundCodeScheduleWithOptions(request, runtime);
  }

  async updateSpeechWithOptions(tmp: UpdateSpeechRequest, runtime: $Util.RuntimeOptions): Promise<UpdateSpeechResponse> {
    Util.validateModel(tmp);
    let request = new UpdateSpeechShrinkRequest({ });
    RPCUtil.convert(tmp, request);
    if (!Util.isUnset(tmp.soundCodeConfig)) {
      request.soundCodeConfigShrink = Util.toJSONString(tmp.soundCodeConfig);
    }

    return $tea.cast<UpdateSpeechResponse>(await this.doRequest("UpdateSpeech", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new UpdateSpeechResponse({}));
  }

  async updateSpeech(request: UpdateSpeechRequest): Promise<UpdateSpeechResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateSpeechWithOptions(request, runtime);
  }

  async updateSubscribeRelationWithOptions(request: UpdateSubscribeRelationRequest, runtime: $Util.RuntimeOptions): Promise<UpdateSubscribeRelationResponse> {
    Util.validateModel(request);
    return $tea.cast<UpdateSubscribeRelationResponse>(await this.doRequest("UpdateSubscribeRelation", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new UpdateSubscribeRelationResponse({}));
  }

  async updateSubscribeRelation(request: UpdateSubscribeRelationRequest): Promise<UpdateSubscribeRelationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateSubscribeRelationWithOptions(request, runtime);
  }

  async updateThingModelWithOptions(request: UpdateThingModelRequest, runtime: $Util.RuntimeOptions): Promise<UpdateThingModelResponse> {
    Util.validateModel(request);
    return $tea.cast<UpdateThingModelResponse>(await this.doRequest("UpdateThingModel", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new UpdateThingModelResponse({}));
  }

  async updateThingModel(request: UpdateThingModelRequest): Promise<UpdateThingModelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateThingModelWithOptions(request, runtime);
  }

  async updateThingScriptWithOptions(request: UpdateThingScriptRequest, runtime: $Util.RuntimeOptions): Promise<UpdateThingScriptResponse> {
    Util.validateModel(request);
    return $tea.cast<UpdateThingScriptResponse>(await this.doRequest("UpdateThingScript", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new UpdateThingScriptResponse({}));
  }

  async updateThingScript(request: UpdateThingScriptRequest): Promise<UpdateThingScriptResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateThingScriptWithOptions(request, runtime);
  }

  async writeDevicesHotStorageDataWithOptions(request: WriteDevicesHotStorageDataRequest, runtime: $Util.RuntimeOptions): Promise<WriteDevicesHotStorageDataResponse> {
    Util.validateModel(request);
    return $tea.cast<WriteDevicesHotStorageDataResponse>(await this.doRequest("WriteDevicesHotStorageData", "HTTPS", "POST", "2018-01-20", "AK", null, $tea.toMap(request), runtime), new WriteDevicesHotStorageDataResponse({}));
  }

  async writeDevicesHotStorageData(request: WriteDevicesHotStorageDataRequest): Promise<WriteDevicesHotStorageDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.writeDevicesHotStorageDataWithOptions(request, runtime);
  }

  getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: {[key: string ]: string}, endpoint: string): string {
    if (!Util.empty(endpoint)) {
      return endpoint;
    }

    if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
      return endpointMap[regionId];
    }

    return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
  }

}
