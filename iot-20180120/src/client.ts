// This file is auto-generated, don't edit it
/**
 *
 */
import Util, * as $Util from '@alicloud/tea-util';
import OpenApi, * as $OpenApi from '@alicloud/openapi-client';
import OpenApiUtil from '@alicloud/openapi-util';
import EndpointUtil from '@alicloud/endpoint-util';
import * as $tea from '@alicloud/tea-typescript';

export class AddDataForApiSourceRequest extends $tea.Model {
  apiId?: string;
  content?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      content: 'Content',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'string',
      content: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddDataForApiSourceResponseBody extends $tea.Model {
  code?: string;
  data?: number;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'number',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddDataForApiSourceResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: AddDataForApiSourceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: AddDataForApiSourceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchAddDeviceGroupRelationsRequest extends $tea.Model {
  device?: BatchAddDeviceGroupRelationsRequestDevice[];
  groupId?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      device: 'Device',
      groupId: 'GroupId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      device: { 'type': 'array', 'itemType': BatchAddDeviceGroupRelationsRequestDevice },
      groupId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchAddDeviceGroupRelationsResponseBody extends $tea.Model {
  alreadyRelatedGroupDeviceCount?: number;
  code?: string;
  errorMessage?: string;
  exceedTenGroupDeviceCount?: number;
  requestId?: string;
  success?: boolean;
  successAddedDeviceCount?: number;
  validDeviceCount?: number;
  static names(): { [key: string]: string } {
    return {
      alreadyRelatedGroupDeviceCount: 'AlreadyRelatedGroupDeviceCount',
      code: 'Code',
      errorMessage: 'ErrorMessage',
      exceedTenGroupDeviceCount: 'ExceedTenGroupDeviceCount',
      requestId: 'RequestId',
      success: 'Success',
      successAddedDeviceCount: 'SuccessAddedDeviceCount',
      validDeviceCount: 'ValidDeviceCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alreadyRelatedGroupDeviceCount: 'number',
      code: 'string',
      errorMessage: 'string',
      exceedTenGroupDeviceCount: 'number',
      requestId: 'string',
      success: 'boolean',
      successAddedDeviceCount: 'number',
      validDeviceCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchAddDeviceGroupRelationsResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: BatchAddDeviceGroupRelationsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: BatchAddDeviceGroupRelationsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchAddThingTopoRequest extends $tea.Model {
  gwDeviceName?: string;
  gwProductKey?: string;
  iotInstanceId?: string;
  topoAddItem?: BatchAddThingTopoRequestTopoAddItem[];
  static names(): { [key: string]: string } {
    return {
      gwDeviceName: 'GwDeviceName',
      gwProductKey: 'GwProductKey',
      iotInstanceId: 'IotInstanceId',
      topoAddItem: 'TopoAddItem',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gwDeviceName: 'string',
      gwProductKey: 'string',
      iotInstanceId: 'string',
      topoAddItem: { 'type': 'array', 'itemType': BatchAddThingTopoRequestTopoAddItem },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchAddThingTopoResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchAddThingTopoResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: BatchAddThingTopoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: BatchAddThingTopoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchBindDeviceToEdgeInstanceWithDriverRequest extends $tea.Model {
  driverId?: string;
  instanceId?: string;
  iotIds?: string[];
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      driverId: 'DriverId',
      instanceId: 'InstanceId',
      iotIds: 'IotIds',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      driverId: 'string',
      instanceId: 'string',
      iotIds: { 'type': 'array', 'itemType': 'string' },
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchBindDeviceToEdgeInstanceWithDriverResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchBindDeviceToEdgeInstanceWithDriverResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: BatchBindDeviceToEdgeInstanceWithDriverResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: BatchBindDeviceToEdgeInstanceWithDriverResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchBindDevicesIntoProjectRequest extends $tea.Model {
  devices?: BatchBindDevicesIntoProjectRequestDevices[];
  iotInstanceId?: string;
  projectId?: string;
  static names(): { [key: string]: string } {
    return {
      devices: 'Devices',
      iotInstanceId: 'IotInstanceId',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      devices: { 'type': 'array', 'itemType': BatchBindDevicesIntoProjectRequestDevices },
      iotInstanceId: 'string',
      projectId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchBindDevicesIntoProjectResponseBody extends $tea.Model {
  code?: string;
  data?: boolean;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'boolean',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchBindDevicesIntoProjectResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: BatchBindDevicesIntoProjectResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: BatchBindDevicesIntoProjectResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchBindProductsIntoProjectRequest extends $tea.Model {
  iotInstanceId?: string;
  productKeys?: string[];
  projectId?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      productKeys: 'ProductKeys',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      productKeys: { 'type': 'array', 'itemType': 'string' },
      projectId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchBindProductsIntoProjectResponseBody extends $tea.Model {
  code?: string;
  data?: boolean;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'boolean',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchBindProductsIntoProjectResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: BatchBindProductsIntoProjectResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: BatchBindProductsIntoProjectResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCheckDeviceNamesRequest extends $tea.Model {
  deviceName?: string[];
  deviceNameList?: BatchCheckDeviceNamesRequestDeviceNameList[];
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      deviceNameList: 'DeviceNameList',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: { 'type': 'array', 'itemType': 'string' },
      deviceNameList: { 'type': 'array', 'itemType': BatchCheckDeviceNamesRequestDeviceNameList },
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCheckDeviceNamesResponseBody extends $tea.Model {
  code?: string;
  data?: BatchCheckDeviceNamesResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: BatchCheckDeviceNamesResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCheckDeviceNamesResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: BatchCheckDeviceNamesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: BatchCheckDeviceNamesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchClearEdgeInstanceDeviceConfigRequest extends $tea.Model {
  instanceId?: string;
  iotIds?: string[];
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      iotIds: 'IotIds',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      iotIds: { 'type': 'array', 'itemType': 'string' },
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchClearEdgeInstanceDeviceConfigResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchClearEdgeInstanceDeviceConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: BatchClearEdgeInstanceDeviceConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: BatchClearEdgeInstanceDeviceConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchDeleteDeviceGroupRelationsRequest extends $tea.Model {
  device?: BatchDeleteDeviceGroupRelationsRequestDevice[];
  groupId?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      device: 'Device',
      groupId: 'GroupId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      device: { 'type': 'array', 'itemType': BatchDeleteDeviceGroupRelationsRequestDevice },
      groupId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchDeleteDeviceGroupRelationsResponseBody extends $tea.Model {
  alreadyRelatedGroupDeviceCount?: number;
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  successDeviceCount?: number;
  validDeviceCount?: number;
  static names(): { [key: string]: string } {
    return {
      alreadyRelatedGroupDeviceCount: 'AlreadyRelatedGroupDeviceCount',
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      successDeviceCount: 'SuccessDeviceCount',
      validDeviceCount: 'ValidDeviceCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alreadyRelatedGroupDeviceCount: 'number',
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      successDeviceCount: 'number',
      validDeviceCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchDeleteDeviceGroupRelationsResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: BatchDeleteDeviceGroupRelationsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: BatchDeleteDeviceGroupRelationsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchDeleteEdgeInstanceChannelRequest extends $tea.Model {
  channelIds?: string[];
  driverId?: string;
  instanceId?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      channelIds: 'ChannelIds',
      driverId: 'DriverId',
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelIds: { 'type': 'array', 'itemType': 'string' },
      driverId: 'string',
      instanceId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchDeleteEdgeInstanceChannelResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchDeleteEdgeInstanceChannelResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: BatchDeleteEdgeInstanceChannelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: BatchDeleteEdgeInstanceChannelResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetDeviceBindStatusRequest extends $tea.Model {
  iotIds?: string[];
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      iotIds: 'IotIds',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotIds: { 'type': 'array', 'itemType': 'string' },
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetDeviceBindStatusResponseBody extends $tea.Model {
  code?: string;
  data?: BatchGetDeviceBindStatusResponseBodyData[];
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: { 'type': 'array', 'itemType': BatchGetDeviceBindStatusResponseBodyData },
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetDeviceBindStatusResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: BatchGetDeviceBindStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: BatchGetDeviceBindStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetDeviceStateRequest extends $tea.Model {
  deviceName?: string[];
  iotId?: string[];
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: { 'type': 'array', 'itemType': 'string' },
      iotId: { 'type': 'array', 'itemType': 'string' },
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetDeviceStateResponseBody extends $tea.Model {
  code?: string;
  deviceStatusList?: BatchGetDeviceStateResponseBodyDeviceStatusList;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      deviceStatusList: 'DeviceStatusList',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      deviceStatusList: BatchGetDeviceStateResponseBodyDeviceStatusList,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetDeviceStateResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: BatchGetDeviceStateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: BatchGetDeviceStateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeDriverRequest extends $tea.Model {
  driverIds?: string[];
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      driverIds: 'DriverIds',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      driverIds: { 'type': 'array', 'itemType': 'string' },
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeDriverResponseBody extends $tea.Model {
  code?: string;
  driverList?: BatchGetEdgeDriverResponseBodyDriverList[];
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      driverList: 'DriverList',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      driverList: { 'type': 'array', 'itemType': BatchGetEdgeDriverResponseBodyDriverList },
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeDriverResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: BatchGetEdgeDriverResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: BatchGetEdgeDriverResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeInstanceChannelRequest extends $tea.Model {
  channelIds?: string[];
  driverId?: string;
  instanceId?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      channelIds: 'ChannelIds',
      driverId: 'DriverId',
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelIds: { 'type': 'array', 'itemType': 'string' },
      driverId: 'string',
      instanceId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeInstanceChannelResponseBody extends $tea.Model {
  code?: string;
  data?: BatchGetEdgeInstanceChannelResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: BatchGetEdgeInstanceChannelResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeInstanceChannelResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: BatchGetEdgeInstanceChannelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: BatchGetEdgeInstanceChannelResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeInstanceDeviceChannelRequest extends $tea.Model {
  driverId?: string;
  instanceId?: string;
  iotIds?: string[];
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      driverId: 'DriverId',
      instanceId: 'InstanceId',
      iotIds: 'IotIds',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      driverId: 'string',
      instanceId: 'string',
      iotIds: { 'type': 'array', 'itemType': 'string' },
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeInstanceDeviceChannelResponseBody extends $tea.Model {
  code?: string;
  deviceChannelList?: BatchGetEdgeInstanceDeviceChannelResponseBodyDeviceChannelList[];
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      deviceChannelList: 'DeviceChannelList',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      deviceChannelList: { 'type': 'array', 'itemType': BatchGetEdgeInstanceDeviceChannelResponseBodyDeviceChannelList },
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeInstanceDeviceChannelResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: BatchGetEdgeInstanceDeviceChannelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: BatchGetEdgeInstanceDeviceChannelResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeInstanceDeviceConfigRequest extends $tea.Model {
  instanceId?: string;
  iotIds?: string[];
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      iotIds: 'IotIds',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      iotIds: { 'type': 'array', 'itemType': 'string' },
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeInstanceDeviceConfigResponseBody extends $tea.Model {
  code?: string;
  deviceConfigList?: BatchGetEdgeInstanceDeviceConfigResponseBodyDeviceConfigList[];
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      deviceConfigList: 'DeviceConfigList',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      deviceConfigList: { 'type': 'array', 'itemType': BatchGetEdgeInstanceDeviceConfigResponseBodyDeviceConfigList },
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeInstanceDeviceConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: BatchGetEdgeInstanceDeviceConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: BatchGetEdgeInstanceDeviceConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeInstanceDeviceDriverRequest extends $tea.Model {
  instanceId?: string;
  iotIds?: string[];
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      iotIds: 'IotIds',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      iotIds: { 'type': 'array', 'itemType': 'string' },
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeInstanceDeviceDriverResponseBody extends $tea.Model {
  code?: string;
  deviceDriverList?: BatchGetEdgeInstanceDeviceDriverResponseBodyDeviceDriverList[];
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      deviceDriverList: 'DeviceDriverList',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      deviceDriverList: { 'type': 'array', 'itemType': BatchGetEdgeInstanceDeviceDriverResponseBodyDeviceDriverList },
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeInstanceDeviceDriverResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: BatchGetEdgeInstanceDeviceDriverResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: BatchGetEdgeInstanceDeviceDriverResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeInstanceDriverConfigsRequest extends $tea.Model {
  driverIds?: string[];
  instanceId?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      driverIds: 'DriverIds',
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      driverIds: { 'type': 'array', 'itemType': 'string' },
      instanceId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeInstanceDriverConfigsResponseBody extends $tea.Model {
  code?: string;
  driverConfigList?: BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigList[];
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      driverConfigList: 'DriverConfigList',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      driverConfigList: { 'type': 'array', 'itemType': BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigList },
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeInstanceDriverConfigsResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: BatchGetEdgeInstanceDriverConfigsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: BatchGetEdgeInstanceDriverConfigsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchPubRequest extends $tea.Model {
  deviceName?: string[];
  iotInstanceId?: string;
  messageContent?: string;
  productKey?: string;
  qos?: number;
  topicShortName?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotInstanceId: 'IotInstanceId',
      messageContent: 'MessageContent',
      productKey: 'ProductKey',
      qos: 'Qos',
      topicShortName: 'TopicShortName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: { 'type': 'array', 'itemType': 'string' },
      iotInstanceId: 'string',
      messageContent: 'string',
      productKey: 'string',
      qos: 'number',
      topicShortName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchPubResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchPubResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: BatchPubResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: BatchPubResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchQueryDeviceDetailRequest extends $tea.Model {
  deviceName?: string[];
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: { 'type': 'array', 'itemType': 'string' },
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchQueryDeviceDetailResponseBody extends $tea.Model {
  code?: string;
  data?: BatchQueryDeviceDetailResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: BatchQueryDeviceDetailResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchQueryDeviceDetailResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: BatchQueryDeviceDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: BatchQueryDeviceDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchRegisterDeviceRequest extends $tea.Model {
  count?: number;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchRegisterDeviceResponseBody extends $tea.Model {
  code?: string;
  data?: BatchRegisterDeviceResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: BatchRegisterDeviceResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchRegisterDeviceResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: BatchRegisterDeviceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: BatchRegisterDeviceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchRegisterDeviceWithApplyIdRequest extends $tea.Model {
  applyId?: number;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      applyId: 'ApplyId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applyId: 'number',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchRegisterDeviceWithApplyIdResponseBody extends $tea.Model {
  code?: string;
  data?: BatchRegisterDeviceWithApplyIdResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: BatchRegisterDeviceWithApplyIdResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchRegisterDeviceWithApplyIdResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: BatchRegisterDeviceWithApplyIdResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: BatchRegisterDeviceWithApplyIdResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchSetEdgeInstanceDeviceChannelRequest extends $tea.Model {
  channelId?: string;
  driverId?: string;
  instanceId?: string;
  iotIds?: string[];
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      channelId: 'ChannelId',
      driverId: 'DriverId',
      instanceId: 'InstanceId',
      iotIds: 'IotIds',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelId: 'string',
      driverId: 'string',
      instanceId: 'string',
      iotIds: { 'type': 'array', 'itemType': 'string' },
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchSetEdgeInstanceDeviceChannelResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchSetEdgeInstanceDeviceChannelResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: BatchSetEdgeInstanceDeviceChannelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: BatchSetEdgeInstanceDeviceChannelResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchSetEdgeInstanceDeviceConfigRequest extends $tea.Model {
  deviceConfigs?: BatchSetEdgeInstanceDeviceConfigRequestDeviceConfigs[];
  instanceId?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      deviceConfigs: 'DeviceConfigs',
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceConfigs: { 'type': 'array', 'itemType': BatchSetEdgeInstanceDeviceConfigRequestDeviceConfigs },
      instanceId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchSetEdgeInstanceDeviceConfigResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchSetEdgeInstanceDeviceConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: BatchSetEdgeInstanceDeviceConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: BatchSetEdgeInstanceDeviceConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchUnbindDeviceFromEdgeInstanceRequest extends $tea.Model {
  instanceId?: string;
  iotIds?: string[];
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      iotIds: 'IotIds',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      iotIds: { 'type': 'array', 'itemType': 'string' },
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchUnbindDeviceFromEdgeInstanceResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchUnbindDeviceFromEdgeInstanceResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: BatchUnbindDeviceFromEdgeInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: BatchUnbindDeviceFromEdgeInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchUnbindProjectDevicesRequest extends $tea.Model {
  devices?: BatchUnbindProjectDevicesRequestDevices[];
  iotInstanceId?: string;
  projectId?: string;
  static names(): { [key: string]: string } {
    return {
      devices: 'Devices',
      iotInstanceId: 'IotInstanceId',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      devices: { 'type': 'array', 'itemType': BatchUnbindProjectDevicesRequestDevices },
      iotInstanceId: 'string',
      projectId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchUnbindProjectDevicesResponseBody extends $tea.Model {
  code?: string;
  data?: boolean;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'boolean',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchUnbindProjectDevicesResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: BatchUnbindProjectDevicesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: BatchUnbindProjectDevicesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchUnbindProjectProductsRequest extends $tea.Model {
  iotInstanceId?: string;
  productKeys?: string[];
  projectId?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      productKeys: 'ProductKeys',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      productKeys: { 'type': 'array', 'itemType': 'string' },
      projectId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchUnbindProjectProductsResponseBody extends $tea.Model {
  code?: string;
  data?: boolean;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'boolean',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchUnbindProjectProductsResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: BatchUnbindProjectProductsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: BatchUnbindProjectProductsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchUpdateDeviceNicknameRequest extends $tea.Model {
  deviceNicknameInfo?: BatchUpdateDeviceNicknameRequestDeviceNicknameInfo[];
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      deviceNicknameInfo: 'DeviceNicknameInfo',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceNicknameInfo: { 'type': 'array', 'itemType': BatchUpdateDeviceNicknameRequestDeviceNicknameInfo },
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchUpdateDeviceNicknameResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchUpdateDeviceNicknameResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: BatchUpdateDeviceNicknameResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: BatchUpdateDeviceNicknameResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BindApplicationToEdgeInstanceRequest extends $tea.Model {
  applicationId?: string;
  applicationVersion?: string;
  instanceId?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      applicationId: 'ApplicationId',
      applicationVersion: 'ApplicationVersion',
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applicationId: 'string',
      applicationVersion: 'string',
      instanceId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BindApplicationToEdgeInstanceResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BindApplicationToEdgeInstanceResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: BindApplicationToEdgeInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: BindApplicationToEdgeInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BindDriverToEdgeInstanceRequest extends $tea.Model {
  driverId?: string;
  driverVersion?: string;
  instanceId?: string;
  iotInstanceId?: string;
  orderId?: string;
  static names(): { [key: string]: string } {
    return {
      driverId: 'DriverId',
      driverVersion: 'DriverVersion',
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
      orderId: 'OrderId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      driverId: 'string',
      driverVersion: 'string',
      instanceId: 'string',
      iotInstanceId: 'string',
      orderId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BindDriverToEdgeInstanceResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BindDriverToEdgeInstanceResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: BindDriverToEdgeInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: BindDriverToEdgeInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BindGatewayToEdgeInstanceRequest extends $tea.Model {
  deviceName?: string;
  instanceId?: string;
  iotId?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      instanceId: 'InstanceId',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      instanceId: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BindGatewayToEdgeInstanceResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BindGatewayToEdgeInstanceResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: BindGatewayToEdgeInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: BindGatewayToEdgeInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BindRoleToEdgeInstanceRequest extends $tea.Model {
  instanceId?: string;
  iotInstanceId?: string;
  roleArn?: string;
  roleName?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
      roleArn: 'RoleArn',
      roleName: 'RoleName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      iotInstanceId: 'string',
      roleArn: 'string',
      roleName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BindRoleToEdgeInstanceResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BindRoleToEdgeInstanceResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: BindRoleToEdgeInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: BindRoleToEdgeInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BindSceneRuleToEdgeInstanceRequest extends $tea.Model {
  instanceId?: string;
  iotInstanceId?: string;
  ruleId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
      ruleId: 'RuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      iotInstanceId: 'string',
      ruleId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BindSceneRuleToEdgeInstanceResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BindSceneRuleToEdgeInstanceResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: BindSceneRuleToEdgeInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: BindSceneRuleToEdgeInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelJobRequest extends $tea.Model {
  iotInstanceId?: string;
  jobId?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      jobId: 'JobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      jobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelJobResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CancelJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CancelJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelOTAStrategyByJobRequest extends $tea.Model {
  iotInstanceId?: string;
  jobId?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      jobId: 'JobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      jobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelOTAStrategyByJobResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelOTAStrategyByJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CancelOTAStrategyByJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CancelOTAStrategyByJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelOTATaskByDeviceRequest extends $tea.Model {
  deviceName?: string[];
  firmwareId?: string;
  iotInstanceId?: string;
  jobId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      firmwareId: 'FirmwareId',
      iotInstanceId: 'IotInstanceId',
      jobId: 'JobId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: { 'type': 'array', 'itemType': 'string' },
      firmwareId: 'string',
      iotInstanceId: 'string',
      jobId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelOTATaskByDeviceResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelOTATaskByDeviceResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CancelOTATaskByDeviceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CancelOTATaskByDeviceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelOTATaskByJobRequest extends $tea.Model {
  cancelInProgressTask?: boolean;
  cancelNotifiedTask?: boolean;
  cancelQueuedTask?: boolean;
  cancelScheduledTask?: boolean;
  cancelUnconfirmedTask?: boolean;
  iotInstanceId?: string;
  jobId?: string;
  static names(): { [key: string]: string } {
    return {
      cancelInProgressTask: 'CancelInProgressTask',
      cancelNotifiedTask: 'CancelNotifiedTask',
      cancelQueuedTask: 'CancelQueuedTask',
      cancelScheduledTask: 'CancelScheduledTask',
      cancelUnconfirmedTask: 'CancelUnconfirmedTask',
      iotInstanceId: 'IotInstanceId',
      jobId: 'JobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cancelInProgressTask: 'boolean',
      cancelNotifiedTask: 'boolean',
      cancelQueuedTask: 'boolean',
      cancelScheduledTask: 'boolean',
      cancelUnconfirmedTask: 'boolean',
      iotInstanceId: 'string',
      jobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelOTATaskByJobResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelOTATaskByJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CancelOTATaskByJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CancelOTATaskByJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelReleaseProductRequest extends $tea.Model {
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelReleaseProductResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelReleaseProductResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CancelReleaseProductResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CancelReleaseProductResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ClearEdgeInstanceDriverConfigsRequest extends $tea.Model {
  driverId?: string;
  instanceId?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      driverId: 'DriverId',
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      driverId: 'string',
      instanceId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ClearEdgeInstanceDriverConfigsResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ClearEdgeInstanceDriverConfigsResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ClearEdgeInstanceDriverConfigsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ClearEdgeInstanceDriverConfigsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CloseEdgeInstanceDeploymentRequest extends $tea.Model {
  instanceId?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CloseEdgeInstanceDeploymentResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CloseEdgeInstanceDeploymentResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CloseEdgeInstanceDeploymentResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CloseEdgeInstanceDeploymentResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ConfirmOTATaskRequest extends $tea.Model {
  iotInstanceId?: string;
  taskId?: string[];
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      taskId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ConfirmOTATaskResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ConfirmOTATaskResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ConfirmOTATaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ConfirmOTATaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CopyThingModelRequest extends $tea.Model {
  iotInstanceId?: string;
  resourceGroupId?: string;
  sourceModelVersion?: string;
  sourceProductKey?: string;
  targetProductKey?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      resourceGroupId: 'ResourceGroupId',
      sourceModelVersion: 'SourceModelVersion',
      sourceProductKey: 'SourceProductKey',
      targetProductKey: 'TargetProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      resourceGroupId: 'string',
      sourceModelVersion: 'string',
      sourceProductKey: 'string',
      targetProductKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CopyThingModelResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CopyThingModelResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CopyThingModelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CopyThingModelResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateConsumerGroupRequest extends $tea.Model {
  groupName?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      groupName: 'GroupName',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupName: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateConsumerGroupResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  groupId?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      groupId: 'GroupId',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      groupId: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateConsumerGroupResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateConsumerGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateConsumerGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateConsumerGroupSubscribeRelationRequest extends $tea.Model {
  consumerGroupId?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      consumerGroupId: 'ConsumerGroupId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consumerGroupId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateConsumerGroupSubscribeRelationResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateConsumerGroupSubscribeRelationResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateConsumerGroupSubscribeRelationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateConsumerGroupSubscribeRelationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataAPIServiceRequest extends $tea.Model {
  apiPath?: string;
  desc?: string;
  displayName?: string;
  iotInstanceId?: string;
  originSql?: string;
  requestParam?: CreateDataAPIServiceRequestRequestParam[];
  responseParam?: CreateDataAPIServiceRequestResponseParam[];
  templateSql?: string;
  static names(): { [key: string]: string } {
    return {
      apiPath: 'ApiPath',
      desc: 'Desc',
      displayName: 'DisplayName',
      iotInstanceId: 'IotInstanceId',
      originSql: 'OriginSql',
      requestParam: 'RequestParam',
      responseParam: 'ResponseParam',
      templateSql: 'TemplateSql',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiPath: 'string',
      desc: 'string',
      displayName: 'string',
      iotInstanceId: 'string',
      originSql: 'string',
      requestParam: { 'type': 'array', 'itemType': CreateDataAPIServiceRequestRequestParam },
      responseParam: { 'type': 'array', 'itemType': CreateDataAPIServiceRequestResponseParam },
      templateSql: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataAPIServiceResponseBody extends $tea.Model {
  code?: string;
  data?: CreateDataAPIServiceResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: CreateDataAPIServiceResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataAPIServiceResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateDataAPIServiceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateDataAPIServiceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDeviceDistributeJobRequest extends $tea.Model {
  deviceName?: string[];
  productKey?: string;
  sourceInstanceId?: string;
  strategy?: number;
  targetAliyunId?: string;
  targetInstanceConfig?: CreateDeviceDistributeJobRequestTargetInstanceConfig[];
  targetUid?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      productKey: 'ProductKey',
      sourceInstanceId: 'SourceInstanceId',
      strategy: 'Strategy',
      targetAliyunId: 'TargetAliyunId',
      targetInstanceConfig: 'TargetInstanceConfig',
      targetUid: 'TargetUid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: { 'type': 'array', 'itemType': 'string' },
      productKey: 'string',
      sourceInstanceId: 'string',
      strategy: 'number',
      targetAliyunId: 'string',
      targetInstanceConfig: { 'type': 'array', 'itemType': CreateDeviceDistributeJobRequestTargetInstanceConfig },
      targetUid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDeviceDistributeJobResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  jobId?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      jobId: 'JobId',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      jobId: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDeviceDistributeJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateDeviceDistributeJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateDeviceDistributeJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDeviceGroupRequest extends $tea.Model {
  groupDesc?: string;
  groupName?: string;
  iotInstanceId?: string;
  superGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      groupDesc: 'GroupDesc',
      groupName: 'GroupName',
      iotInstanceId: 'IotInstanceId',
      superGroupId: 'SuperGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupDesc: 'string',
      groupName: 'string',
      iotInstanceId: 'string',
      superGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDeviceGroupResponseBody extends $tea.Model {
  code?: string;
  data?: CreateDeviceGroupResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: CreateDeviceGroupResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDeviceGroupResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateDeviceGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateDeviceGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeDriverRequest extends $tea.Model {
  cpuArch?: string;
  driverName?: string;
  driverProtocol?: string;
  iotInstanceId?: string;
  isBuiltIn?: boolean;
  runtime?: string;
  static names(): { [key: string]: string } {
    return {
      cpuArch: 'CpuArch',
      driverName: 'DriverName',
      driverProtocol: 'DriverProtocol',
      iotInstanceId: 'IotInstanceId',
      isBuiltIn: 'IsBuiltIn',
      runtime: 'Runtime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cpuArch: 'string',
      driverName: 'string',
      driverProtocol: 'string',
      iotInstanceId: 'string',
      isBuiltIn: 'boolean',
      runtime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeDriverResponseBody extends $tea.Model {
  code?: string;
  driverId?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      driverId: 'DriverId',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      driverId: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeDriverResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateEdgeDriverResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateEdgeDriverResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeDriverVersionRequest extends $tea.Model {
  argument?: string;
  configCheckRule?: string;
  containerConfig?: string;
  description?: string;
  driverConfig?: string;
  driverId?: string;
  driverVersion?: string;
  edgeVersion?: string;
  iotInstanceId?: string;
  sourceConfig?: string;
  static names(): { [key: string]: string } {
    return {
      argument: 'Argument',
      configCheckRule: 'ConfigCheckRule',
      containerConfig: 'ContainerConfig',
      description: 'Description',
      driverConfig: 'DriverConfig',
      driverId: 'DriverId',
      driverVersion: 'DriverVersion',
      edgeVersion: 'EdgeVersion',
      iotInstanceId: 'IotInstanceId',
      sourceConfig: 'SourceConfig',
    };
  }

  static types(): { [key: string]: any } {
    return {
      argument: 'string',
      configCheckRule: 'string',
      containerConfig: 'string',
      description: 'string',
      driverConfig: 'string',
      driverId: 'string',
      driverVersion: 'string',
      edgeVersion: 'string',
      iotInstanceId: 'string',
      sourceConfig: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeDriverVersionResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeDriverVersionResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateEdgeDriverVersionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateEdgeDriverVersionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeInstanceRequest extends $tea.Model {
  iotInstanceId?: string;
  name?: string;
  spec?: number;
  tags?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      name: 'Name',
      spec: 'Spec',
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      name: 'string',
      spec: 'number',
      tags: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeInstanceResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  instanceId?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      instanceId: 'InstanceId',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      instanceId: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeInstanceResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateEdgeInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateEdgeInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeInstanceChannelRequest extends $tea.Model {
  channelName?: string;
  configs?: CreateEdgeInstanceChannelRequestConfigs[];
  driverId?: string;
  instanceId?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      channelName: 'ChannelName',
      configs: 'Configs',
      driverId: 'DriverId',
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelName: 'string',
      configs: { 'type': 'array', 'itemType': CreateEdgeInstanceChannelRequestConfigs },
      driverId: 'string',
      instanceId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeInstanceChannelResponseBody extends $tea.Model {
  code?: string;
  data?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeInstanceChannelResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateEdgeInstanceChannelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateEdgeInstanceChannelResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeInstanceDeploymentRequest extends $tea.Model {
  instanceId?: string;
  iotInstanceId?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      iotInstanceId: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeInstanceDeploymentResponseBody extends $tea.Model {
  code?: string;
  deploymentId?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      deploymentId: 'DeploymentId',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      deploymentId: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeInstanceDeploymentResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateEdgeInstanceDeploymentResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateEdgeInstanceDeploymentResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeInstanceMessageRoutingRequest extends $tea.Model {
  instanceId?: string;
  iotInstanceId?: string;
  name?: string;
  sourceData?: string;
  sourceType?: string;
  targetData?: string;
  targetIotHubQos?: number;
  targetType?: string;
  topicFilter?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
      name: 'Name',
      sourceData: 'SourceData',
      sourceType: 'SourceType',
      targetData: 'TargetData',
      targetIotHubQos: 'TargetIotHubQos',
      targetType: 'TargetType',
      topicFilter: 'TopicFilter',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      iotInstanceId: 'string',
      name: 'string',
      sourceData: 'string',
      sourceType: 'string',
      targetData: 'string',
      targetIotHubQos: 'number',
      targetType: 'string',
      topicFilter: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeInstanceMessageRoutingResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  routeId?: number;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      routeId: 'RouteId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      routeId: 'number',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeInstanceMessageRoutingResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateEdgeInstanceMessageRoutingResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateEdgeInstanceMessageRoutingResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeOssPreSignedAddressRequest extends $tea.Model {
  fileName?: string;
  instanceId?: string;
  iotInstanceId?: string;
  resourceId?: string;
  resourceVersion?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      fileName: 'FileName',
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
      resourceId: 'ResourceId',
      resourceVersion: 'ResourceVersion',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fileName: 'string',
      instanceId: 'string',
      iotInstanceId: 'string',
      resourceId: 'string',
      resourceVersion: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeOssPreSignedAddressResponseBody extends $tea.Model {
  code?: string;
  data?: CreateEdgeOssPreSignedAddressResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: CreateEdgeOssPreSignedAddressResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeOssPreSignedAddressResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateEdgeOssPreSignedAddressResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateEdgeOssPreSignedAddressResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateJobRequest extends $tea.Model {
  description?: string;
  iotInstanceId?: string;
  jobDocument?: string;
  jobFile?: string;
  jobName?: string;
  rolloutConfig?: string;
  scheduledTime?: number;
  targetConfig?: string;
  timeoutConfig?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      iotInstanceId: 'IotInstanceId',
      jobDocument: 'JobDocument',
      jobFile: 'JobFile',
      jobName: 'JobName',
      rolloutConfig: 'RolloutConfig',
      scheduledTime: 'ScheduledTime',
      targetConfig: 'TargetConfig',
      timeoutConfig: 'TimeoutConfig',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      iotInstanceId: 'string',
      jobDocument: 'string',
      jobFile: 'string',
      jobName: 'string',
      rolloutConfig: 'string',
      scheduledTime: 'number',
      targetConfig: 'string',
      timeoutConfig: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateJobResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  jobId?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      jobId: 'JobId',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      jobId: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLoRaNodesTaskRequest extends $tea.Model {
  deviceInfo?: CreateLoRaNodesTaskRequestDeviceInfo[];
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceInfo: 'DeviceInfo',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceInfo: { 'type': 'array', 'itemType': CreateLoRaNodesTaskRequestDeviceInfo },
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLoRaNodesTaskResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  taskId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      taskId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLoRaNodesTaskResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateLoRaNodesTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateLoRaNodesTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOTADynamicUpgradeJobRequest extends $tea.Model {
  dynamicMode?: number;
  firmwareId?: string;
  iotInstanceId?: string;
  maximumPerMinute?: number;
  needConfirm?: boolean;
  needPush?: boolean;
  overwriteMode?: number;
  productKey?: string;
  retryCount?: number;
  retryInterval?: number;
  srcVersion?: string[];
  tag?: CreateOTADynamicUpgradeJobRequestTag[];
  timeoutInMinutes?: number;
  static names(): { [key: string]: string } {
    return {
      dynamicMode: 'DynamicMode',
      firmwareId: 'FirmwareId',
      iotInstanceId: 'IotInstanceId',
      maximumPerMinute: 'MaximumPerMinute',
      needConfirm: 'NeedConfirm',
      needPush: 'NeedPush',
      overwriteMode: 'OverwriteMode',
      productKey: 'ProductKey',
      retryCount: 'RetryCount',
      retryInterval: 'RetryInterval',
      srcVersion: 'SrcVersion',
      tag: 'Tag',
      timeoutInMinutes: 'TimeoutInMinutes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dynamicMode: 'number',
      firmwareId: 'string',
      iotInstanceId: 'string',
      maximumPerMinute: 'number',
      needConfirm: 'boolean',
      needPush: 'boolean',
      overwriteMode: 'number',
      productKey: 'string',
      retryCount: 'number',
      retryInterval: 'number',
      srcVersion: { 'type': 'array', 'itemType': 'string' },
      tag: { 'type': 'array', 'itemType': CreateOTADynamicUpgradeJobRequestTag },
      timeoutInMinutes: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOTADynamicUpgradeJobResponseBody extends $tea.Model {
  code?: string;
  data?: CreateOTADynamicUpgradeJobResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: CreateOTADynamicUpgradeJobResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOTADynamicUpgradeJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateOTADynamicUpgradeJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateOTADynamicUpgradeJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOTAFirmwareRequest extends $tea.Model {
  destVersion?: string;
  firmwareDesc?: string;
  firmwareName?: string;
  firmwareSign?: string;
  firmwareSize?: number;
  firmwareUrl?: string;
  iotInstanceId?: string;
  moduleName?: string;
  needToVerify?: boolean;
  productKey?: string;
  signMethod?: string;
  srcVersion?: string;
  type?: number;
  udi?: string;
  static names(): { [key: string]: string } {
    return {
      destVersion: 'DestVersion',
      firmwareDesc: 'FirmwareDesc',
      firmwareName: 'FirmwareName',
      firmwareSign: 'FirmwareSign',
      firmwareSize: 'FirmwareSize',
      firmwareUrl: 'FirmwareUrl',
      iotInstanceId: 'IotInstanceId',
      moduleName: 'ModuleName',
      needToVerify: 'NeedToVerify',
      productKey: 'ProductKey',
      signMethod: 'SignMethod',
      srcVersion: 'SrcVersion',
      type: 'Type',
      udi: 'Udi',
    };
  }

  static types(): { [key: string]: any } {
    return {
      destVersion: 'string',
      firmwareDesc: 'string',
      firmwareName: 'string',
      firmwareSign: 'string',
      firmwareSize: 'number',
      firmwareUrl: 'string',
      iotInstanceId: 'string',
      moduleName: 'string',
      needToVerify: 'boolean',
      productKey: 'string',
      signMethod: 'string',
      srcVersion: 'string',
      type: 'number',
      udi: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOTAFirmwareResponseBody extends $tea.Model {
  code?: string;
  data?: CreateOTAFirmwareResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: CreateOTAFirmwareResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOTAFirmwareResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateOTAFirmwareResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateOTAFirmwareResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOTAModuleRequest extends $tea.Model {
  aliasName?: string;
  desc?: string;
  iotInstanceId?: string;
  moduleName?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      aliasName: 'AliasName',
      desc: 'Desc',
      iotInstanceId: 'IotInstanceId',
      moduleName: 'ModuleName',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliasName: 'string',
      desc: 'string',
      iotInstanceId: 'string',
      moduleName: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOTAModuleResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOTAModuleResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateOTAModuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateOTAModuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOTAStaticUpgradeJobRequest extends $tea.Model {
  dnListFileUrl?: string;
  firmwareId?: string;
  grayPercent?: string;
  iotInstanceId?: string;
  maximumPerMinute?: number;
  needConfirm?: boolean;
  needPush?: boolean;
  overwriteMode?: number;
  productKey?: string;
  retryCount?: number;
  retryInterval?: number;
  scheduleFinishTime?: number;
  scheduleTime?: number;
  srcVersion?: string[];
  tag?: CreateOTAStaticUpgradeJobRequestTag[];
  targetDeviceName?: string[];
  targetSelection?: string;
  timeoutInMinutes?: number;
  static names(): { [key: string]: string } {
    return {
      dnListFileUrl: 'DnListFileUrl',
      firmwareId: 'FirmwareId',
      grayPercent: 'GrayPercent',
      iotInstanceId: 'IotInstanceId',
      maximumPerMinute: 'MaximumPerMinute',
      needConfirm: 'NeedConfirm',
      needPush: 'NeedPush',
      overwriteMode: 'OverwriteMode',
      productKey: 'ProductKey',
      retryCount: 'RetryCount',
      retryInterval: 'RetryInterval',
      scheduleFinishTime: 'ScheduleFinishTime',
      scheduleTime: 'ScheduleTime',
      srcVersion: 'SrcVersion',
      tag: 'Tag',
      targetDeviceName: 'TargetDeviceName',
      targetSelection: 'TargetSelection',
      timeoutInMinutes: 'TimeoutInMinutes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dnListFileUrl: 'string',
      firmwareId: 'string',
      grayPercent: 'string',
      iotInstanceId: 'string',
      maximumPerMinute: 'number',
      needConfirm: 'boolean',
      needPush: 'boolean',
      overwriteMode: 'number',
      productKey: 'string',
      retryCount: 'number',
      retryInterval: 'number',
      scheduleFinishTime: 'number',
      scheduleTime: 'number',
      srcVersion: { 'type': 'array', 'itemType': 'string' },
      tag: { 'type': 'array', 'itemType': CreateOTAStaticUpgradeJobRequestTag },
      targetDeviceName: { 'type': 'array', 'itemType': 'string' },
      targetSelection: 'string',
      timeoutInMinutes: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOTAStaticUpgradeJobResponseBody extends $tea.Model {
  code?: string;
  data?: CreateOTAStaticUpgradeJobResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: CreateOTAStaticUpgradeJobResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOTAStaticUpgradeJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateOTAStaticUpgradeJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateOTAStaticUpgradeJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOTAVerifyJobRequest extends $tea.Model {
  firmwareId?: string;
  iotInstanceId?: string;
  needConfirm?: boolean;
  needPush?: boolean;
  productKey?: string;
  targetDeviceName?: string[];
  timeoutInMinutes?: number;
  static names(): { [key: string]: string } {
    return {
      firmwareId: 'FirmwareId',
      iotInstanceId: 'IotInstanceId',
      needConfirm: 'NeedConfirm',
      needPush: 'NeedPush',
      productKey: 'ProductKey',
      targetDeviceName: 'TargetDeviceName',
      timeoutInMinutes: 'TimeoutInMinutes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      firmwareId: 'string',
      iotInstanceId: 'string',
      needConfirm: 'boolean',
      needPush: 'boolean',
      productKey: 'string',
      targetDeviceName: { 'type': 'array', 'itemType': 'string' },
      timeoutInMinutes: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOTAVerifyJobResponseBody extends $tea.Model {
  code?: string;
  data?: CreateOTAVerifyJobResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: CreateOTAVerifyJobResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOTAVerifyJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateOTAVerifyJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateOTAVerifyJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProductRequest extends $tea.Model {
  aliyunCommodityCode?: string;
  authType?: string;
  categoryKey?: string;
  dataFormat?: number;
  description?: string;
  id2?: boolean;
  iotInstanceId?: string;
  joinPermissionId?: string;
  netType?: string;
  nodeType?: number;
  productName?: string;
  protocolType?: string;
  publishAuto?: boolean;
  resourceGroupId?: string;
  validateType?: number;
  static names(): { [key: string]: string } {
    return {
      aliyunCommodityCode: 'AliyunCommodityCode',
      authType: 'AuthType',
      categoryKey: 'CategoryKey',
      dataFormat: 'DataFormat',
      description: 'Description',
      id2: 'Id2',
      iotInstanceId: 'IotInstanceId',
      joinPermissionId: 'JoinPermissionId',
      netType: 'NetType',
      nodeType: 'NodeType',
      productName: 'ProductName',
      protocolType: 'ProtocolType',
      publishAuto: 'PublishAuto',
      resourceGroupId: 'ResourceGroupId',
      validateType: 'ValidateType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunCommodityCode: 'string',
      authType: 'string',
      categoryKey: 'string',
      dataFormat: 'number',
      description: 'string',
      id2: 'boolean',
      iotInstanceId: 'string',
      joinPermissionId: 'string',
      netType: 'string',
      nodeType: 'number',
      productName: 'string',
      protocolType: 'string',
      publishAuto: 'boolean',
      resourceGroupId: 'string',
      validateType: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProductResponseBody extends $tea.Model {
  code?: string;
  data?: CreateProductResponseBodyData;
  errorMessage?: string;
  productKey?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      productKey: 'ProductKey',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: CreateProductResponseBodyData,
      errorMessage: 'string',
      productKey: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProductResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateProductResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateProductResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProductDistributeJobRequest extends $tea.Model {
  productKey?: string;
  sourceInstanceId?: string;
  targetAliyunId?: string;
  targetInstanceId?: string;
  targetUid?: string;
  static names(): { [key: string]: string } {
    return {
      productKey: 'ProductKey',
      sourceInstanceId: 'SourceInstanceId',
      targetAliyunId: 'TargetAliyunId',
      targetInstanceId: 'TargetInstanceId',
      targetUid: 'TargetUid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      productKey: 'string',
      sourceInstanceId: 'string',
      targetAliyunId: 'string',
      targetInstanceId: 'string',
      targetUid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProductDistributeJobResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  jobId?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      jobId: 'JobId',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      jobId: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProductDistributeJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateProductDistributeJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateProductDistributeJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProductTagsRequest extends $tea.Model {
  iotInstanceId?: string;
  productKey?: string;
  productTag?: CreateProductTagsRequestProductTag[];
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
      productTag: 'ProductTag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      productKey: 'string',
      productTag: { 'type': 'array', 'itemType': CreateProductTagsRequestProductTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProductTagsResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  invalidProductTags?: CreateProductTagsResponseBodyInvalidProductTags;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      invalidProductTags: 'InvalidProductTags',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      invalidProductTags: CreateProductTagsResponseBodyInvalidProductTags,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProductTagsResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateProductTagsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateProductTagsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProductTopicRequest extends $tea.Model {
  desc?: string;
  iotInstanceId?: string;
  operation?: string;
  productKey?: string;
  topicShortName?: string;
  static names(): { [key: string]: string } {
    return {
      desc: 'Desc',
      iotInstanceId: 'IotInstanceId',
      operation: 'Operation',
      productKey: 'ProductKey',
      topicShortName: 'TopicShortName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      desc: 'string',
      iotInstanceId: 'string',
      operation: 'string',
      productKey: 'string',
      topicShortName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProductTopicResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  topicId?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      topicId: 'TopicId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      topicId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProductTopicResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateProductTopicResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateProductTopicResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRuleRequest extends $tea.Model {
  dataType?: string;
  iotInstanceId?: string;
  name?: string;
  productKey?: string;
  resourceGroupId?: string;
  ruleDesc?: string;
  select?: string;
  shortTopic?: string;
  topic?: string;
  topicType?: number;
  where?: string;
  static names(): { [key: string]: string } {
    return {
      dataType: 'DataType',
      iotInstanceId: 'IotInstanceId',
      name: 'Name',
      productKey: 'ProductKey',
      resourceGroupId: 'ResourceGroupId',
      ruleDesc: 'RuleDesc',
      select: 'Select',
      shortTopic: 'ShortTopic',
      topic: 'Topic',
      topicType: 'TopicType',
      where: 'Where',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataType: 'string',
      iotInstanceId: 'string',
      name: 'string',
      productKey: 'string',
      resourceGroupId: 'string',
      ruleDesc: 'string',
      select: 'string',
      shortTopic: 'string',
      topic: 'string',
      topicType: 'number',
      where: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRuleResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  ruleId?: number;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      ruleId: 'RuleId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      ruleId: 'number',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRuleResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRuleActionRequest extends $tea.Model {
  configuration?: string;
  errorActionFlag?: boolean;
  iotInstanceId?: string;
  ruleId?: number;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      configuration: 'Configuration',
      errorActionFlag: 'ErrorActionFlag',
      iotInstanceId: 'IotInstanceId',
      ruleId: 'RuleId',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configuration: 'string',
      errorActionFlag: 'boolean',
      iotInstanceId: 'string',
      ruleId: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRuleActionResponseBody extends $tea.Model {
  actionId?: number;
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      actionId: 'ActionId',
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actionId: 'number',
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRuleActionResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateRuleActionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateRuleActionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRulengDistributeJobRequest extends $tea.Model {
  productKey?: string;
  sourceInstanceId?: string;
  targetInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      productKey: 'ProductKey',
      sourceInstanceId: 'SourceInstanceId',
      targetInstanceId: 'TargetInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      productKey: 'string',
      sourceInstanceId: 'string',
      targetInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRulengDistributeJobResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRulengDistributeJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateRulengDistributeJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateRulengDistributeJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSceneRuleRequest extends $tea.Model {
  iotInstanceId?: string;
  ruleContent?: string;
  ruleDescription?: string;
  ruleName?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      ruleContent: 'RuleContent',
      ruleDescription: 'RuleDescription',
      ruleName: 'RuleName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      ruleContent: 'string',
      ruleDescription: 'string',
      ruleName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSceneRuleResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  ruleId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      ruleId: 'RuleId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      ruleId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSceneRuleResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateSceneRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateSceneRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSpeechRequest extends $tea.Model {
  bizCode?: string;
  iotInstanceId?: string;
  projectCode?: string;
  speechRate?: number;
  speechType?: string;
  text?: string;
  voice?: string;
  volume?: number;
  static names(): { [key: string]: string } {
    return {
      bizCode: 'BizCode',
      iotInstanceId: 'IotInstanceId',
      projectCode: 'ProjectCode',
      speechRate: 'SpeechRate',
      speechType: 'SpeechType',
      text: 'Text',
      voice: 'Voice',
      volume: 'Volume',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizCode: 'string',
      iotInstanceId: 'string',
      projectCode: 'string',
      speechRate: 'number',
      speechType: 'string',
      text: 'string',
      voice: 'string',
      volume: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSpeechResponseBody extends $tea.Model {
  code?: string;
  data?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSpeechResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateSpeechResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateSpeechResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateStudioAppDomainOpenRequest extends $tea.Model {
  appId?: string;
  host?: string;
  iotInstanceId?: string;
  projectId?: string;
  protocol?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      host: 'Host',
      iotInstanceId: 'IotInstanceId',
      projectId: 'ProjectId',
      protocol: 'Protocol',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      host: 'string',
      iotInstanceId: 'string',
      projectId: 'string',
      protocol: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateStudioAppDomainOpenResponseBody extends $tea.Model {
  code?: string;
  data?: CreateStudioAppDomainOpenResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: CreateStudioAppDomainOpenResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateStudioAppDomainOpenResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateStudioAppDomainOpenResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateStudioAppDomainOpenResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSubscribeRelationRequest extends $tea.Model {
  consumerGroupIds?: string[];
  deviceDataFlag?: boolean;
  deviceLifeCycleFlag?: boolean;
  deviceStatusChangeFlag?: boolean;
  deviceTagFlag?: boolean;
  deviceTopoLifeCycleFlag?: boolean;
  foundDeviceListFlag?: boolean;
  iotInstanceId?: string;
  mnsConfiguration?: string;
  otaEventFlag?: boolean;
  otaJobFlag?: boolean;
  otaVersionFlag?: boolean;
  productKey?: string;
  thingHistoryFlag?: boolean;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      consumerGroupIds: 'ConsumerGroupIds',
      deviceDataFlag: 'DeviceDataFlag',
      deviceLifeCycleFlag: 'DeviceLifeCycleFlag',
      deviceStatusChangeFlag: 'DeviceStatusChangeFlag',
      deviceTagFlag: 'DeviceTagFlag',
      deviceTopoLifeCycleFlag: 'DeviceTopoLifeCycleFlag',
      foundDeviceListFlag: 'FoundDeviceListFlag',
      iotInstanceId: 'IotInstanceId',
      mnsConfiguration: 'MnsConfiguration',
      otaEventFlag: 'OtaEventFlag',
      otaJobFlag: 'OtaJobFlag',
      otaVersionFlag: 'OtaVersionFlag',
      productKey: 'ProductKey',
      thingHistoryFlag: 'ThingHistoryFlag',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consumerGroupIds: { 'type': 'array', 'itemType': 'string' },
      deviceDataFlag: 'boolean',
      deviceLifeCycleFlag: 'boolean',
      deviceStatusChangeFlag: 'boolean',
      deviceTagFlag: 'boolean',
      deviceTopoLifeCycleFlag: 'boolean',
      foundDeviceListFlag: 'boolean',
      iotInstanceId: 'string',
      mnsConfiguration: 'string',
      otaEventFlag: 'boolean',
      otaJobFlag: 'boolean',
      otaVersionFlag: 'boolean',
      productKey: 'string',
      thingHistoryFlag: 'boolean',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSubscribeRelationResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSubscribeRelationResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateSubscribeRelationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateSubscribeRelationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateThingModelRequest extends $tea.Model {
  functionBlockId?: string;
  functionBlockName?: string;
  iotInstanceId?: string;
  productKey?: string;
  thingModelJson?: string;
  static names(): { [key: string]: string } {
    return {
      functionBlockId: 'FunctionBlockId',
      functionBlockName: 'FunctionBlockName',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
      thingModelJson: 'ThingModelJson',
    };
  }

  static types(): { [key: string]: any } {
    return {
      functionBlockId: 'string',
      functionBlockName: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
      thingModelJson: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateThingModelResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateThingModelResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateThingModelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateThingModelResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateThingScriptRequest extends $tea.Model {
  iotInstanceId?: string;
  productKey?: string;
  scriptContent?: string;
  scriptType?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
      scriptContent: 'ScriptContent',
      scriptType: 'ScriptType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      productKey: 'string',
      scriptContent: 'string',
      scriptType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateThingScriptResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateThingScriptResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateThingScriptResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateThingScriptResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTopicRouteTableRequest extends $tea.Model {
  dstTopic?: string[];
  iotInstanceId?: string;
  srcTopic?: string;
  static names(): { [key: string]: string } {
    return {
      dstTopic: 'DstTopic',
      iotInstanceId: 'IotInstanceId',
      srcTopic: 'SrcTopic',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dstTopic: { 'type': 'array', 'itemType': 'string' },
      iotInstanceId: 'string',
      srcTopic: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTopicRouteTableResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  failureTopics?: CreateTopicRouteTableResponseBodyFailureTopics;
  isAllSucceed?: boolean;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      failureTopics: 'FailureTopics',
      isAllSucceed: 'IsAllSucceed',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      failureTopics: CreateTopicRouteTableResponseBodyFailureTopics,
      isAllSucceed: 'boolean',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTopicRouteTableResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateTopicRouteTableResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateTopicRouteTableResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteConsumerGroupRequest extends $tea.Model {
  groupId?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteConsumerGroupResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteConsumerGroupResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteConsumerGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteConsumerGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteConsumerGroupSubscribeRelationRequest extends $tea.Model {
  consumerGroupId?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      consumerGroupId: 'ConsumerGroupId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consumerGroupId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteConsumerGroupSubscribeRelationResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteConsumerGroupSubscribeRelationResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteConsumerGroupSubscribeRelationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteConsumerGroupSubscribeRelationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDeviceRequest extends $tea.Model {
  deviceName?: string;
  iotId?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDeviceResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDeviceResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteDeviceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteDeviceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDeviceDistributeJobRequest extends $tea.Model {
  jobId?: string;
  static names(): { [key: string]: string } {
    return {
      jobId: 'JobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      jobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDeviceDistributeJobResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDeviceDistributeJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteDeviceDistributeJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteDeviceDistributeJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDeviceFileRequest extends $tea.Model {
  deviceName?: string;
  fileId?: string;
  iotId?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      fileId: 'FileId',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      fileId: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDeviceFileResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDeviceFileResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteDeviceFileResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteDeviceFileResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDeviceGroupRequest extends $tea.Model {
  groupId?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDeviceGroupResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDeviceGroupResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteDeviceGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteDeviceGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDevicePropRequest extends $tea.Model {
  deviceName?: string;
  iotId?: string;
  iotInstanceId?: string;
  productKey?: string;
  propKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
      propKey: 'PropKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
      propKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDevicePropResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDevicePropResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteDevicePropResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteDevicePropResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEdgeDriverRequest extends $tea.Model {
  driverId?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      driverId: 'DriverId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      driverId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEdgeDriverResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEdgeDriverResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteEdgeDriverResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteEdgeDriverResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEdgeDriverVersionRequest extends $tea.Model {
  driverId?: string;
  driverVersion?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      driverId: 'DriverId',
      driverVersion: 'DriverVersion',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      driverId: 'string',
      driverVersion: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEdgeDriverVersionResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEdgeDriverVersionResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteEdgeDriverVersionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteEdgeDriverVersionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEdgeInstanceRequest extends $tea.Model {
  instanceId?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEdgeInstanceResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEdgeInstanceResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteEdgeInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteEdgeInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEdgeInstanceMessageRoutingRequest extends $tea.Model {
  instanceId?: string;
  iotInstanceId?: string;
  routeId?: number;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
      routeId: 'RouteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      iotInstanceId: 'string',
      routeId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEdgeInstanceMessageRoutingResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEdgeInstanceMessageRoutingResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteEdgeInstanceMessageRoutingResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteEdgeInstanceMessageRoutingResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteJobRequest extends $tea.Model {
  iotInstanceId?: string;
  jobId?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      jobId: 'JobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      jobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteJobResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteOTAFirmwareRequest extends $tea.Model {
  firmwareId?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      firmwareId: 'FirmwareId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      firmwareId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteOTAFirmwareResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteOTAFirmwareResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteOTAFirmwareResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteOTAFirmwareResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteOTAModuleRequest extends $tea.Model {
  iotInstanceId?: string;
  moduleName?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      moduleName: 'ModuleName',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      moduleName: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteOTAModuleResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteOTAModuleResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteOTAModuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteOTAModuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteProductRequest extends $tea.Model {
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteProductResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteProductResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteProductResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteProductResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteProductTagsRequest extends $tea.Model {
  iotInstanceId?: string;
  productKey?: string;
  productTagKey?: string[];
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
      productTagKey: 'ProductTagKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      productKey: 'string',
      productTagKey: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteProductTagsResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteProductTagsResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteProductTagsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteProductTagsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteProductTopicRequest extends $tea.Model {
  iotInstanceId?: string;
  topicId?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      topicId: 'TopicId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      topicId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteProductTopicResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteProductTopicResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteProductTopicResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteProductTopicResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRuleRequest extends $tea.Model {
  iotInstanceId?: string;
  ruleId?: number;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      ruleId: 'RuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      ruleId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRuleResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRuleResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRuleActionRequest extends $tea.Model {
  actionId?: number;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      actionId: 'ActionId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actionId: 'number',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRuleActionResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRuleActionResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteRuleActionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteRuleActionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSceneRuleRequest extends $tea.Model {
  iotInstanceId?: string;
  ruleId?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      ruleId: 'RuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      ruleId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSceneRuleResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSceneRuleResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteSceneRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteSceneRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSpeechRequest extends $tea.Model {
  iotInstanceId?: string;
  speechCodeList?: string[];
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      speechCodeList: 'SpeechCodeList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      speechCodeList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSpeechResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSpeechResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteSpeechResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteSpeechResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteStudioAppDomainOpenRequest extends $tea.Model {
  appId?: string;
  domainId?: number;
  iotInstanceId?: string;
  projectId?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      domainId: 'DomainId',
      iotInstanceId: 'IotInstanceId',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      domainId: 'number',
      iotInstanceId: 'string',
      projectId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteStudioAppDomainOpenResponseBody extends $tea.Model {
  code?: string;
  data?: boolean;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'boolean',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteStudioAppDomainOpenResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteStudioAppDomainOpenResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteStudioAppDomainOpenResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSubscribeRelationRequest extends $tea.Model {
  iotInstanceId?: string;
  productKey?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      productKey: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSubscribeRelationResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSubscribeRelationResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteSubscribeRelationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteSubscribeRelationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteThingModelRequest extends $tea.Model {
  eventIdentifier?: string[];
  functionBlockId?: string;
  iotInstanceId?: string;
  productKey?: string;
  propertyIdentifier?: string[];
  resourceGroupId?: string;
  serviceIdentifier?: string[];
  static names(): { [key: string]: string } {
    return {
      eventIdentifier: 'EventIdentifier',
      functionBlockId: 'FunctionBlockId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
      propertyIdentifier: 'PropertyIdentifier',
      resourceGroupId: 'ResourceGroupId',
      serviceIdentifier: 'ServiceIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      eventIdentifier: { 'type': 'array', 'itemType': 'string' },
      functionBlockId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
      propertyIdentifier: { 'type': 'array', 'itemType': 'string' },
      resourceGroupId: 'string',
      serviceIdentifier: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteThingModelResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteThingModelResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteThingModelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteThingModelResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTopicRouteTableRequest extends $tea.Model {
  dstTopic?: string[];
  iotInstanceId?: string;
  srcTopic?: string;
  static names(): { [key: string]: string } {
    return {
      dstTopic: 'DstTopic',
      iotInstanceId: 'IotInstanceId',
      srcTopic: 'SrcTopic',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dstTopic: { 'type': 'array', 'itemType': 'string' },
      iotInstanceId: 'string',
      srcTopic: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTopicRouteTableResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  failureTopics?: DeleteTopicRouteTableResponseBodyFailureTopics;
  isAllSucceed?: boolean;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      failureTopics: 'FailureTopics',
      isAllSucceed: 'IsAllSucceed',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      failureTopics: DeleteTopicRouteTableResponseBodyFailureTopics,
      isAllSucceed: 'boolean',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTopicRouteTableResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteTopicRouteTableResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteTopicRouteTableResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableDeviceTunnelRequest extends $tea.Model {
  deviceName?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableDeviceTunnelResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableDeviceTunnelResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DisableDeviceTunnelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DisableDeviceTunnelResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableDeviceTunnelShareRequest extends $tea.Model {
  deviceName?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableDeviceTunnelShareResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableDeviceTunnelShareResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DisableDeviceTunnelShareResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DisableDeviceTunnelShareResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableSceneRuleRequest extends $tea.Model {
  iotInstanceId?: string;
  ruleId?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      ruleId: 'RuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      ruleId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableSceneRuleResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableSceneRuleResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DisableSceneRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DisableSceneRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableThingRequest extends $tea.Model {
  deviceName?: string;
  iotId?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableThingResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableThingResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DisableThingResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DisableThingResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableDeviceTunnelRequest extends $tea.Model {
  deviceName?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableDeviceTunnelResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableDeviceTunnelResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: EnableDeviceTunnelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: EnableDeviceTunnelResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableDeviceTunnelShareRequest extends $tea.Model {
  deviceName?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableDeviceTunnelShareResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableDeviceTunnelShareResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: EnableDeviceTunnelShareResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: EnableDeviceTunnelShareResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableSceneRuleRequest extends $tea.Model {
  iotInstanceId?: string;
  ruleId?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      ruleId: 'RuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      ruleId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableSceneRuleResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableSceneRuleResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: EnableSceneRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: EnableSceneRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableThingRequest extends $tea.Model {
  deviceName?: string;
  iotId?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableThingResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableThingResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: EnableThingResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: EnableThingResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GenerateDeviceNameListURLRequest extends $tea.Model {
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GenerateDeviceNameListURLResponseBody extends $tea.Model {
  code?: string;
  data?: GenerateDeviceNameListURLResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: GenerateDeviceNameListURLResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GenerateDeviceNameListURLResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: GenerateDeviceNameListURLResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: GenerateDeviceNameListURLResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GenerateFileUploadURLRequest extends $tea.Model {
  bizCode?: string;
  fileName?: string;
  fileSuffix?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      bizCode: 'BizCode',
      fileName: 'FileName',
      fileSuffix: 'FileSuffix',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizCode: 'string',
      fileName: 'string',
      fileSuffix: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GenerateFileUploadURLResponseBody extends $tea.Model {
  code?: string;
  data?: GenerateFileUploadURLResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: GenerateFileUploadURLResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GenerateFileUploadURLResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: GenerateFileUploadURLResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: GenerateFileUploadURLResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GenerateOTAUploadURLRequest extends $tea.Model {
  fileSuffix?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      fileSuffix: 'FileSuffix',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fileSuffix: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GenerateOTAUploadURLResponseBody extends $tea.Model {
  code?: string;
  data?: GenerateOTAUploadURLResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: GenerateOTAUploadURLResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GenerateOTAUploadURLResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: GenerateOTAUploadURLResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: GenerateOTAUploadURLResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataAPIServiceDetailRequest extends $tea.Model {
  apiSrn?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      apiSrn: 'ApiSrn',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiSrn: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataAPIServiceDetailResponseBody extends $tea.Model {
  code?: string;
  data?: GetDataAPIServiceDetailResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: GetDataAPIServiceDetailResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataAPIServiceDetailResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: GetDataAPIServiceDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: GetDataAPIServiceDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDeviceShadowRequest extends $tea.Model {
  deviceName?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDeviceShadowResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  shadowMessage?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      shadowMessage: 'ShadowMessage',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      shadowMessage: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDeviceShadowResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: GetDeviceShadowResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: GetDeviceShadowResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDeviceStatusRequest extends $tea.Model {
  deviceName?: string;
  iotId?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDeviceStatusResponseBody extends $tea.Model {
  code?: string;
  data?: GetDeviceStatusResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: GetDeviceStatusResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDeviceStatusResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: GetDeviceStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: GetDeviceStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDeviceTunnelShareStatusRequest extends $tea.Model {
  deviceName?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDeviceTunnelShareStatusResponseBody extends $tea.Model {
  code?: string;
  data?: GetDeviceTunnelShareStatusResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: GetDeviceTunnelShareStatusResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDeviceTunnelShareStatusResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: GetDeviceTunnelShareStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: GetDeviceTunnelShareStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDeviceTunnelStatusRequest extends $tea.Model {
  deviceName?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDeviceTunnelStatusResponseBody extends $tea.Model {
  code?: string;
  data?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDeviceTunnelStatusResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: GetDeviceTunnelStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: GetDeviceTunnelStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeDriverVersionRequest extends $tea.Model {
  driverId?: string;
  driverVersion?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      driverId: 'DriverId',
      driverVersion: 'DriverVersion',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      driverId: 'string',
      driverVersion: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeDriverVersionResponseBody extends $tea.Model {
  code?: string;
  data?: GetEdgeDriverVersionResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: GetEdgeDriverVersionResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeDriverVersionResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: GetEdgeDriverVersionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: GetEdgeDriverVersionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeInstanceRequest extends $tea.Model {
  instanceId?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeInstanceResponseBody extends $tea.Model {
  code?: string;
  data?: GetEdgeInstanceResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: GetEdgeInstanceResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeInstanceResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: GetEdgeInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: GetEdgeInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeInstanceDeploymentRequest extends $tea.Model {
  deploymentId?: string;
  instanceId?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      deploymentId: 'DeploymentId',
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deploymentId: 'string',
      instanceId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeInstanceDeploymentResponseBody extends $tea.Model {
  code?: string;
  data?: GetEdgeInstanceDeploymentResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: GetEdgeInstanceDeploymentResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeInstanceDeploymentResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: GetEdgeInstanceDeploymentResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: GetEdgeInstanceDeploymentResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeInstanceMessageRoutingRequest extends $tea.Model {
  instanceId?: string;
  iotInstanceId?: string;
  routeId?: number;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
      routeId: 'RouteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      iotInstanceId: 'string',
      routeId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeInstanceMessageRoutingResponseBody extends $tea.Model {
  code?: string;
  data?: GetEdgeInstanceMessageRoutingResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: GetEdgeInstanceMessageRoutingResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeInstanceMessageRoutingResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: GetEdgeInstanceMessageRoutingResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: GetEdgeInstanceMessageRoutingResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayBySubDeviceRequest extends $tea.Model {
  deviceName?: string;
  iotId?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayBySubDeviceResponseBody extends $tea.Model {
  code?: string;
  data?: GetGatewayBySubDeviceResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: GetGatewayBySubDeviceResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayBySubDeviceResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: GetGatewayBySubDeviceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: GetGatewayBySubDeviceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetLoraNodesTaskRequest extends $tea.Model {
  iotInstanceId?: string;
  taskId?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      taskId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetLoraNodesTaskResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  successCount?: number;
  successDevEuis?: GetLoraNodesTaskResponseBodySuccessDevEuis;
  taskId?: string;
  taskState?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      successCount: 'SuccessCount',
      successDevEuis: 'SuccessDevEuis',
      taskId: 'TaskId',
      taskState: 'TaskState',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      successCount: 'number',
      successDevEuis: GetLoraNodesTaskResponseBodySuccessDevEuis,
      taskId: 'string',
      taskState: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetLoraNodesTaskResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: GetLoraNodesTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: GetLoraNodesTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNodesAddingTaskRequest extends $tea.Model {
  iotInstanceId?: string;
  taskId?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      taskId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNodesAddingTaskResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  successCount?: number;
  successDevEuis?: GetNodesAddingTaskResponseBodySuccessDevEuis;
  taskId?: string;
  taskState?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      successCount: 'SuccessCount',
      successDevEuis: 'SuccessDevEuis',
      taskId: 'TaskId',
      taskState: 'TaskState',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      successCount: 'number',
      successDevEuis: GetNodesAddingTaskResponseBodySuccessDevEuis,
      taskId: 'string',
      taskState: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNodesAddingTaskResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: GetNodesAddingTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: GetNodesAddingTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRuleRequest extends $tea.Model {
  iotInstanceId?: string;
  ruleId?: number;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      ruleId: 'RuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      ruleId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRuleResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  ruleInfo?: GetRuleResponseBodyRuleInfo;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      ruleInfo: 'RuleInfo',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      ruleInfo: GetRuleResponseBodyRuleInfo,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRuleResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: GetRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: GetRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRuleActionRequest extends $tea.Model {
  actionId?: number;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      actionId: 'ActionId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actionId: 'number',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRuleActionResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  ruleActionInfo?: GetRuleActionResponseBodyRuleActionInfo;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      ruleActionInfo: 'RuleActionInfo',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      ruleActionInfo: GetRuleActionResponseBodyRuleActionInfo,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRuleActionResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: GetRuleActionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: GetRuleActionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSceneRuleRequest extends $tea.Model {
  iotInstanceId?: string;
  ruleId?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      ruleId: 'RuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      ruleId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSceneRuleResponseBody extends $tea.Model {
  code?: string;
  data?: GetSceneRuleResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: GetSceneRuleResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSceneRuleResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: GetSceneRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: GetSceneRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSpeechVoiceResponseBody extends $tea.Model {
  code?: string;
  data?: GetSpeechVoiceResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: GetSpeechVoiceResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSpeechVoiceResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: GetSpeechVoiceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: GetSpeechVoiceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStudioAppTokenOpenRequest extends $tea.Model {
  appId?: string;
  iotInstanceId?: string;
  projectId?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      iotInstanceId: 'IotInstanceId',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      iotInstanceId: 'string',
      projectId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStudioAppTokenOpenResponseBody extends $tea.Model {
  code?: string;
  data?: GetStudioAppTokenOpenResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: GetStudioAppTokenOpenResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStudioAppTokenOpenResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: GetStudioAppTokenOpenResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: GetStudioAppTokenOpenResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetThingModelTslRequest extends $tea.Model {
  functionBlockId?: string;
  iotInstanceId?: string;
  modelVersion?: string;
  productKey?: string;
  simple?: boolean;
  static names(): { [key: string]: string } {
    return {
      functionBlockId: 'FunctionBlockId',
      iotInstanceId: 'IotInstanceId',
      modelVersion: 'ModelVersion',
      productKey: 'ProductKey',
      simple: 'Simple',
    };
  }

  static types(): { [key: string]: any } {
    return {
      functionBlockId: 'string',
      iotInstanceId: 'string',
      modelVersion: 'string',
      productKey: 'string',
      simple: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetThingModelTslResponseBody extends $tea.Model {
  code?: string;
  data?: GetThingModelTslResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: GetThingModelTslResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetThingModelTslResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: GetThingModelTslResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: GetThingModelTslResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetThingModelTslPublishedRequest extends $tea.Model {
  functionBlockId?: string;
  iotInstanceId?: string;
  modelVersion?: string;
  productKey?: string;
  resourceGroupId?: string;
  simple?: boolean;
  static names(): { [key: string]: string } {
    return {
      functionBlockId: 'FunctionBlockId',
      iotInstanceId: 'IotInstanceId',
      modelVersion: 'ModelVersion',
      productKey: 'ProductKey',
      resourceGroupId: 'ResourceGroupId',
      simple: 'Simple',
    };
  }

  static types(): { [key: string]: any } {
    return {
      functionBlockId: 'string',
      iotInstanceId: 'string',
      modelVersion: 'string',
      productKey: 'string',
      resourceGroupId: 'string',
      simple: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetThingModelTslPublishedResponseBody extends $tea.Model {
  code?: string;
  data?: GetThingModelTslPublishedResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: GetThingModelTslPublishedResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetThingModelTslPublishedResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: GetThingModelTslPublishedResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: GetThingModelTslPublishedResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetThingScriptRequest extends $tea.Model {
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetThingScriptResponseBody extends $tea.Model {
  code?: string;
  data?: GetThingScriptResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: GetThingScriptResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetThingScriptResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: GetThingScriptResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: GetThingScriptResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetThingTemplateRequest extends $tea.Model {
  categoryKey?: string;
  iotInstanceId?: string;
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      categoryKey: 'CategoryKey',
      iotInstanceId: 'IotInstanceId',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      categoryKey: 'string',
      iotInstanceId: 'string',
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetThingTemplateResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  thingModelJSON?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      thingModelJSON: 'ThingModelJSON',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      thingModelJSON: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetThingTemplateResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: GetThingTemplateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: GetThingTemplateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetThingTopoRequest extends $tea.Model {
  deviceName?: string;
  iotId?: string;
  iotInstanceId?: string;
  pageNo?: number;
  pageSize?: number;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      pageNo: 'PageNo',
      pageSize: 'PageSize',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      pageNo: 'number',
      pageSize: 'number',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetThingTopoResponseBody extends $tea.Model {
  code?: string;
  data?: GetThingTopoResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: GetThingTopoResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetThingTopoResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: GetThingTopoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: GetThingTopoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportThingModelTslRequest extends $tea.Model {
  functionBlockId?: string;
  functionBlockName?: string;
  iotInstanceId?: string;
  productKey?: string;
  resourceGroupId?: string;
  tslStr?: string;
  tslUrl?: string;
  static names(): { [key: string]: string } {
    return {
      functionBlockId: 'FunctionBlockId',
      functionBlockName: 'FunctionBlockName',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
      resourceGroupId: 'ResourceGroupId',
      tslStr: 'TslStr',
      tslUrl: 'TslUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      functionBlockId: 'string',
      functionBlockName: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
      resourceGroupId: 'string',
      tslStr: 'string',
      tslUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportThingModelTslResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportThingModelTslResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ImportThingModelTslResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ImportThingModelTslResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InvokeDataAPIServiceRequest extends $tea.Model {
  apiSrn?: string;
  iotInstanceId?: string;
  param?: InvokeDataAPIServiceRequestParam[];
  static names(): { [key: string]: string } {
    return {
      apiSrn: 'ApiSrn',
      iotInstanceId: 'IotInstanceId',
      param: 'Param',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiSrn: 'string',
      iotInstanceId: 'string',
      param: { 'type': 'array', 'itemType': InvokeDataAPIServiceRequestParam },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InvokeDataAPIServiceResponseBody extends $tea.Model {
  code?: string;
  data?: InvokeDataAPIServiceResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: InvokeDataAPIServiceResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InvokeDataAPIServiceResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: InvokeDataAPIServiceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: InvokeDataAPIServiceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InvokeThingServiceRequest extends $tea.Model {
  args?: string;
  deviceName?: string;
  identifier?: string;
  iotId?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      args: 'Args',
      deviceName: 'DeviceName',
      identifier: 'Identifier',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      args: 'string',
      deviceName: 'string',
      identifier: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InvokeThingServiceResponseBody extends $tea.Model {
  code?: string;
  data?: InvokeThingServiceResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: InvokeThingServiceResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InvokeThingServiceResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: InvokeThingServiceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: InvokeThingServiceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InvokeThingsServiceRequest extends $tea.Model {
  args?: string;
  deviceName?: string[];
  identifier?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      args: 'Args',
      deviceName: 'DeviceName',
      identifier: 'Identifier',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      args: 'string',
      deviceName: { 'type': 'array', 'itemType': 'string' },
      identifier: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InvokeThingsServiceResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InvokeThingsServiceResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: InvokeThingsServiceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: InvokeThingsServiceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAnalyticsDataRequest extends $tea.Model {
  apiPath?: string;
  condition?: ListAnalyticsDataRequestCondition[];
  iotInstanceId?: string;
  isoId?: string;
  pageNum?: number;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      apiPath: 'ApiPath',
      condition: 'Condition',
      iotInstanceId: 'IotInstanceId',
      isoId: 'IsoId',
      pageNum: 'PageNum',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiPath: 'string',
      condition: { 'type': 'array', 'itemType': ListAnalyticsDataRequestCondition },
      iotInstanceId: 'string',
      isoId: 'string',
      pageNum: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAnalyticsDataResponseBody extends $tea.Model {
  code?: string;
  data?: ListAnalyticsDataResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: ListAnalyticsDataResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAnalyticsDataResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListAnalyticsDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListAnalyticsDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDeviceDistributeJobRequest extends $tea.Model {
  currentPage?: number;
  jobId?: string;
  nextToken?: string;
  pageSize?: number;
  status?: number;
  targetUid?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      jobId: 'JobId',
      nextToken: 'NextToken',
      pageSize: 'PageSize',
      status: 'Status',
      targetUid: 'TargetUid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      jobId: 'string',
      nextToken: 'string',
      pageSize: 'number',
      status: 'number',
      targetUid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDeviceDistributeJobResponseBody extends $tea.Model {
  code?: string;
  data?: ListDeviceDistributeJobResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: ListDeviceDistributeJobResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDeviceDistributeJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListDeviceDistributeJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListDeviceDistributeJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDistributedDeviceRequest extends $tea.Model {
  currentPage?: number;
  deviceName?: string;
  pageSize?: number;
  productKey?: string;
  sourceInstanceId?: string;
  targetUid?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      deviceName: 'DeviceName',
      pageSize: 'PageSize',
      productKey: 'ProductKey',
      sourceInstanceId: 'SourceInstanceId',
      targetUid: 'TargetUid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      deviceName: 'string',
      pageSize: 'number',
      productKey: 'string',
      sourceInstanceId: 'string',
      targetUid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDistributedDeviceResponseBody extends $tea.Model {
  code?: string;
  data?: ListDistributedDeviceResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: ListDistributedDeviceResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDistributedDeviceResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListDistributedDeviceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListDistributedDeviceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDistributedProductRequest extends $tea.Model {
  currentPage?: number;
  pageSize?: number;
  productKey?: string;
  sourceInstanceId?: string;
  targetInstanceId?: string;
  targetUid?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      productKey: 'ProductKey',
      sourceInstanceId: 'SourceInstanceId',
      targetInstanceId: 'TargetInstanceId',
      targetUid: 'TargetUid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      pageSize: 'number',
      productKey: 'string',
      sourceInstanceId: 'string',
      targetInstanceId: 'string',
      targetUid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDistributedProductResponseBody extends $tea.Model {
  code?: string;
  data?: ListDistributedProductResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: ListDistributedProductResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDistributedProductResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListDistributedProductResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListDistributedProductResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobRequest extends $tea.Model {
  currentPage?: number;
  iotInstanceId?: string;
  pageSize?: number;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      iotInstanceId: 'string',
      pageSize: 'number',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobResponseBody extends $tea.Model {
  code?: string;
  data?: ListJobResponseBodyData;
  errorMessage?: string;
  page?: number;
  pageSize?: number;
  requestId?: string;
  success?: boolean;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      page: 'Page',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: ListJobResponseBodyData,
      errorMessage: 'string',
      page: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAFirmwareRequest extends $tea.Model {
  currentPage?: number;
  destVersion?: string;
  iotInstanceId?: string;
  pageSize?: number;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      destVersion: 'DestVersion',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      destVersion: 'string',
      iotInstanceId: 'string',
      pageSize: 'number',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAFirmwareResponseBody extends $tea.Model {
  code?: string;
  currentPage?: number;
  errorMessage?: string;
  firmwareInfo?: ListOTAFirmwareResponseBodyFirmwareInfo;
  pageCount?: number;
  pageSize?: number;
  requestId?: string;
  success?: boolean;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      currentPage: 'CurrentPage',
      errorMessage: 'ErrorMessage',
      firmwareInfo: 'FirmwareInfo',
      pageCount: 'PageCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      currentPage: 'number',
      errorMessage: 'string',
      firmwareInfo: ListOTAFirmwareResponseBodyFirmwareInfo,
      pageCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAFirmwareResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListOTAFirmwareResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListOTAFirmwareResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAJobByDeviceRequest extends $tea.Model {
  currentPage?: number;
  deviceName?: string;
  firmwareId?: string;
  iotInstanceId?: string;
  pageSize?: number;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      deviceName: 'DeviceName',
      firmwareId: 'FirmwareId',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      deviceName: 'string',
      firmwareId: 'string',
      iotInstanceId: 'string',
      pageSize: 'number',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAJobByDeviceResponseBody extends $tea.Model {
  code?: string;
  currentPage?: number;
  data?: ListOTAJobByDeviceResponseBodyData;
  errorMessage?: string;
  pageCount?: number;
  pageSize?: number;
  requestId?: string;
  success?: boolean;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      currentPage: 'CurrentPage',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      pageCount: 'PageCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      currentPage: 'number',
      data: ListOTAJobByDeviceResponseBodyData,
      errorMessage: 'string',
      pageCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAJobByDeviceResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListOTAJobByDeviceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListOTAJobByDeviceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAJobByFirmwareRequest extends $tea.Model {
  currentPage?: number;
  firmwareId?: string;
  iotInstanceId?: string;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      firmwareId: 'FirmwareId',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      firmwareId: 'string',
      iotInstanceId: 'string',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAJobByFirmwareResponseBody extends $tea.Model {
  code?: string;
  currentPage?: number;
  data?: ListOTAJobByFirmwareResponseBodyData;
  errorMessage?: string;
  pageCount?: number;
  pageSize?: number;
  requestId?: string;
  success?: boolean;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      currentPage: 'CurrentPage',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      pageCount: 'PageCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      currentPage: 'number',
      data: ListOTAJobByFirmwareResponseBodyData,
      errorMessage: 'string',
      pageCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAJobByFirmwareResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListOTAJobByFirmwareResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListOTAJobByFirmwareResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAModuleByProductRequest extends $tea.Model {
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAModuleByProductResponseBody extends $tea.Model {
  code?: string;
  data?: ListOTAModuleByProductResponseBodyData[];
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: { 'type': 'array', 'itemType': ListOTAModuleByProductResponseBodyData },
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAModuleByProductResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListOTAModuleByProductResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListOTAModuleByProductResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAModuleVersionsByDeviceRequest extends $tea.Model {
  currentPage?: number;
  deviceName?: string;
  iotId?: string;
  iotInstanceId?: string;
  pageSize?: number;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      deviceName: 'DeviceName',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      deviceName: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      pageSize: 'number',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAModuleVersionsByDeviceResponseBody extends $tea.Model {
  code?: string;
  currentPage?: number;
  data?: ListOTAModuleVersionsByDeviceResponseBodyData;
  errorMessage?: string;
  pageCount?: number;
  pageSize?: number;
  requestId?: string;
  success?: boolean;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      currentPage: 'CurrentPage',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      pageCount: 'PageCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      currentPage: 'number',
      data: ListOTAModuleVersionsByDeviceResponseBodyData,
      errorMessage: 'string',
      pageCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAModuleVersionsByDeviceResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListOTAModuleVersionsByDeviceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListOTAModuleVersionsByDeviceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTATaskByJobRequest extends $tea.Model {
  currentPage?: number;
  deviceNames?: string[];
  iotInstanceId?: string;
  jobId?: string;
  pageSize?: number;
  taskStatus?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      deviceNames: 'DeviceNames',
      iotInstanceId: 'IotInstanceId',
      jobId: 'JobId',
      pageSize: 'PageSize',
      taskStatus: 'TaskStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      deviceNames: { 'type': 'array', 'itemType': 'string' },
      iotInstanceId: 'string',
      jobId: 'string',
      pageSize: 'number',
      taskStatus: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTATaskByJobResponseBody extends $tea.Model {
  code?: string;
  currentPage?: number;
  data?: ListOTATaskByJobResponseBodyData;
  errorMessage?: string;
  pageCount?: number;
  pageSize?: number;
  requestId?: string;
  success?: boolean;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      currentPage: 'CurrentPage',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      pageCount: 'PageCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      currentPage: 'number',
      data: ListOTATaskByJobResponseBodyData,
      errorMessage: 'string',
      pageCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTATaskByJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListOTATaskByJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListOTATaskByJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAUnfinishedTaskByDeviceRequest extends $tea.Model {
  deviceName?: string;
  iotId?: string;
  iotInstanceId?: string;
  moduleName?: string;
  productKey?: string;
  taskStatus?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      moduleName: 'ModuleName',
      productKey: 'ProductKey',
      taskStatus: 'TaskStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      moduleName: 'string',
      productKey: 'string',
      taskStatus: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAUnfinishedTaskByDeviceResponseBody extends $tea.Model {
  code?: string;
  data?: ListOTAUnfinishedTaskByDeviceResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: ListOTAUnfinishedTaskByDeviceResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAUnfinishedTaskByDeviceResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListOTAUnfinishedTaskByDeviceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListOTAUnfinishedTaskByDeviceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProductByTagsRequest extends $tea.Model {
  currentPage?: number;
  iotInstanceId?: string;
  pageSize?: number;
  productTag?: ListProductByTagsRequestProductTag[];
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
      productTag: 'ProductTag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      iotInstanceId: 'string',
      pageSize: 'number',
      productTag: { 'type': 'array', 'itemType': ListProductByTagsRequestProductTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProductByTagsResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  productInfos?: ListProductByTagsResponseBodyProductInfos;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      productInfos: 'ProductInfos',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      productInfos: ListProductByTagsResponseBodyProductInfos,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProductByTagsResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListProductByTagsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListProductByTagsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProductTagsRequest extends $tea.Model {
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProductTagsResponseBody extends $tea.Model {
  code?: string;
  data?: ListProductTagsResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: ListProductTagsResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProductTagsResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListProductTagsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListProductTagsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRuleRequest extends $tea.Model {
  currentPage?: number;
  iotInstanceId?: string;
  pageSize?: number;
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      iotInstanceId: 'string',
      pageSize: 'number',
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRuleResponseBody extends $tea.Model {
  code?: string;
  data?: ListRuleResponseBodyData;
  errorMessage?: string;
  page?: number;
  pageSize?: number;
  requestId?: string;
  success?: boolean;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      page: 'Page',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: ListRuleResponseBodyData,
      errorMessage: 'string',
      page: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRuleResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRuleActionsRequest extends $tea.Model {
  iotInstanceId?: string;
  ruleId?: number;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      ruleId: 'RuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      ruleId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRuleActionsResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  ruleActionList?: ListRuleActionsResponseBodyRuleActionList;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      ruleActionList: 'RuleActionList',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      ruleActionList: ListRuleActionsResponseBodyRuleActionList,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRuleActionsResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListRuleActionsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListRuleActionsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskRequest extends $tea.Model {
  device?: string;
  iotInstanceId?: string;
  jobId?: string;
  limit?: number;
  nextToken?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      device: 'Device',
      iotInstanceId: 'IotInstanceId',
      jobId: 'JobId',
      limit: 'Limit',
      nextToken: 'NextToken',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      device: 'string',
      iotInstanceId: 'string',
      jobId: 'string',
      limit: 'number',
      nextToken: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskResponseBody extends $tea.Model {
  code?: string;
  data?: ListTaskResponseBodyData;
  errorMessage?: string;
  nextToken?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      nextToken: 'NextToken',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: ListTaskResponseBodyData,
      errorMessage: 'string',
      nextToken: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskByPageRequest extends $tea.Model {
  device?: string;
  deviceName?: string;
  iotInstanceId?: string;
  jobId?: string;
  jobName?: string;
  pageNo?: string;
  pageSize?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      device: 'Device',
      deviceName: 'DeviceName',
      iotInstanceId: 'IotInstanceId',
      jobId: 'JobId',
      jobName: 'JobName',
      pageNo: 'PageNo',
      pageSize: 'PageSize',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      device: 'string',
      deviceName: 'string',
      iotInstanceId: 'string',
      jobId: 'string',
      jobName: 'string',
      pageNo: 'string',
      pageSize: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskByPageResponseBody extends $tea.Model {
  code?: string;
  data?: ListTaskByPageResponseBodyData;
  errorMessage?: string;
  page?: number;
  pageCount?: number;
  pageSize?: number;
  requestId?: string;
  success?: boolean;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      page: 'Page',
      pageCount: 'PageCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: ListTaskByPageResponseBodyData,
      errorMessage: 'string',
      page: 'number',
      pageCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskByPageResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListTaskByPageResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListTaskByPageResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListThingModelVersionRequest extends $tea.Model {
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListThingModelVersionResponseBody extends $tea.Model {
  code?: string;
  data?: ListThingModelVersionResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: ListThingModelVersionResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListThingModelVersionResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListThingModelVersionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListThingModelVersionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListThingTemplatesRequest extends $tea.Model {
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListThingTemplatesResponseBody extends $tea.Model {
  code?: string;
  data?: ListThingTemplatesResponseBodyData[];
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: { 'type': 'array', 'itemType': ListThingTemplatesResponseBodyData },
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListThingTemplatesResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListThingTemplatesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListThingTemplatesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class NotifyAddThingTopoRequest extends $tea.Model {
  deviceListStr?: string;
  gwDeviceName?: string;
  gwIotId?: string;
  gwProductKey?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      deviceListStr: 'DeviceListStr',
      gwDeviceName: 'GwDeviceName',
      gwIotId: 'GwIotId',
      gwProductKey: 'GwProductKey',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceListStr: 'string',
      gwDeviceName: 'string',
      gwIotId: 'string',
      gwProductKey: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class NotifyAddThingTopoResponseBody extends $tea.Model {
  code?: string;
  data?: NotifyAddThingTopoResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: NotifyAddThingTopoResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class NotifyAddThingTopoResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: NotifyAddThingTopoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: NotifyAddThingTopoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OpenIotServiceRequest extends $tea.Model {
  ownerId?: number;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OpenIotServiceResponseBody extends $tea.Model {
  orderId?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OpenIotServiceResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: OpenIotServiceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: OpenIotServiceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PrintByTemplateRequest extends $tea.Model {
  deviceName?: string;
  iotId?: string;
  iotInstanceId?: string;
  paramsJsonString?: string;
  productKey?: string;
  projectCode?: string;
  templateBizCode?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      paramsJsonString: 'ParamsJsonString',
      productKey: 'ProductKey',
      projectCode: 'ProjectCode',
      templateBizCode: 'TemplateBizCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      paramsJsonString: 'string',
      productKey: 'string',
      projectCode: 'string',
      templateBizCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PrintByTemplateResponseBody extends $tea.Model {
  code?: string;
  data?: PrintByTemplateResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: PrintByTemplateResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PrintByTemplateResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: PrintByTemplateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: PrintByTemplateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PubRequest extends $tea.Model {
  correlationData?: string;
  iotInstanceId?: string;
  messageContent?: string;
  productKey?: string;
  qos?: number;
  responseTopic?: string;
  topicFullName?: string;
  userProp?: PubRequestUserProp[];
  static names(): { [key: string]: string } {
    return {
      correlationData: 'CorrelationData',
      iotInstanceId: 'IotInstanceId',
      messageContent: 'MessageContent',
      productKey: 'ProductKey',
      qos: 'Qos',
      responseTopic: 'ResponseTopic',
      topicFullName: 'TopicFullName',
      userProp: 'UserProp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      correlationData: 'string',
      iotInstanceId: 'string',
      messageContent: 'string',
      productKey: 'string',
      qos: 'number',
      responseTopic: 'string',
      topicFullName: 'string',
      userProp: { 'type': 'array', 'itemType': PubRequestUserProp },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PubResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  messageId?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      messageId: 'MessageId',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      messageId: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PubResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: PubResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: PubResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PubBroadcastRequest extends $tea.Model {
  iotInstanceId?: string;
  messageContent?: string;
  productKey?: string;
  topicFullName?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      messageContent: 'MessageContent',
      productKey: 'ProductKey',
      topicFullName: 'TopicFullName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      messageContent: 'string',
      productKey: 'string',
      topicFullName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PubBroadcastResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  messageId?: number;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      messageId: 'MessageId',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      messageId: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PubBroadcastResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: PubBroadcastResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: PubBroadcastResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PublishStudioAppRequest extends $tea.Model {
  appId?: string;
  description?: string;
  iotInstanceId?: string;
  projectId?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      description: 'Description',
      iotInstanceId: 'IotInstanceId',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      description: 'string',
      iotInstanceId: 'string',
      projectId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PublishStudioAppResponseBody extends $tea.Model {
  code?: string;
  data?: boolean;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'boolean',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PublishStudioAppResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: PublishStudioAppResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: PublishStudioAppResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PublishThingModelRequest extends $tea.Model {
  description?: string;
  iotInstanceId?: string;
  modelVersion?: string;
  productKey?: string;
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      iotInstanceId: 'IotInstanceId',
      modelVersion: 'ModelVersion',
      productKey: 'ProductKey',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      iotInstanceId: 'string',
      modelVersion: 'string',
      productKey: 'string',
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PublishThingModelResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PublishThingModelResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: PublishThingModelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: PublishThingModelResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PushSpeechRequest extends $tea.Model {
  deviceName?: string;
  groupId?: string;
  iotId?: string;
  iotInstanceId?: string;
  productKey?: string;
  projectCode?: string;
  pushMode?: string;
  speechCodeList?: string[];
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      groupId: 'GroupId',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
      projectCode: 'ProjectCode',
      pushMode: 'PushMode',
      speechCodeList: 'SpeechCodeList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      groupId: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
      projectCode: 'string',
      pushMode: 'string',
      speechCodeList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PushSpeechResponseBody extends $tea.Model {
  code?: string;
  data?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PushSpeechResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: PushSpeechResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: PushSpeechResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAppDeviceListRequest extends $tea.Model {
  appKey?: string;
  categoryKeyList?: string[];
  currentPage?: number;
  iotInstanceId?: string;
  pageSize?: number;
  productKeyList?: string[];
  tagList?: QueryAppDeviceListRequestTagList[];
  static names(): { [key: string]: string } {
    return {
      appKey: 'AppKey',
      categoryKeyList: 'CategoryKeyList',
      currentPage: 'CurrentPage',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
      productKeyList: 'ProductKeyList',
      tagList: 'TagList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appKey: 'string',
      categoryKeyList: { 'type': 'array', 'itemType': 'string' },
      currentPage: 'number',
      iotInstanceId: 'string',
      pageSize: 'number',
      productKeyList: { 'type': 'array', 'itemType': 'string' },
      tagList: { 'type': 'array', 'itemType': QueryAppDeviceListRequestTagList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAppDeviceListResponseBody extends $tea.Model {
  code?: string;
  data?: QueryAppDeviceListResponseBodyData;
  errorMessage?: string;
  page?: number;
  pageCount?: number;
  pageSize?: number;
  requestId?: string;
  success?: boolean;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      page: 'Page',
      pageCount: 'PageCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryAppDeviceListResponseBodyData,
      errorMessage: 'string',
      page: 'number',
      pageCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAppDeviceListResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryAppDeviceListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryAppDeviceListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryBatchRegisterDeviceStatusRequest extends $tea.Model {
  applyId?: number;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      applyId: 'ApplyId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applyId: 'number',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryBatchRegisterDeviceStatusResponseBody extends $tea.Model {
  code?: string;
  data?: QueryBatchRegisterDeviceStatusResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryBatchRegisterDeviceStatusResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryBatchRegisterDeviceStatusResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryBatchRegisterDeviceStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryBatchRegisterDeviceStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCertUrlByApplyIdRequest extends $tea.Model {
  applyId?: number;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      applyId: 'ApplyId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applyId: 'number',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCertUrlByApplyIdResponseBody extends $tea.Model {
  certUrl?: string;
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      certUrl: 'CertUrl',
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      certUrl: 'string',
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCertUrlByApplyIdResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryCertUrlByApplyIdResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryCertUrlByApplyIdResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryConsumerGroupByGroupIdRequest extends $tea.Model {
  groupId?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryConsumerGroupByGroupIdResponseBody extends $tea.Model {
  code?: string;
  data?: QueryConsumerGroupByGroupIdResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryConsumerGroupByGroupIdResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryConsumerGroupByGroupIdResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryConsumerGroupByGroupIdResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryConsumerGroupByGroupIdResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryConsumerGroupListRequest extends $tea.Model {
  currentPage?: number;
  fuzzy?: boolean;
  groupName?: string;
  iotInstanceId?: string;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      fuzzy: 'Fuzzy',
      groupName: 'GroupName',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      fuzzy: 'boolean',
      groupName: 'string',
      iotInstanceId: 'string',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryConsumerGroupListResponseBody extends $tea.Model {
  code?: string;
  currentPage?: number;
  data?: QueryConsumerGroupListResponseBodyData;
  errorMessage?: string;
  pageCount?: number;
  pageSize?: number;
  requestId?: string;
  success?: boolean;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      currentPage: 'CurrentPage',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      pageCount: 'PageCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      currentPage: 'number',
      data: QueryConsumerGroupListResponseBodyData,
      errorMessage: 'string',
      pageCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryConsumerGroupListResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryConsumerGroupListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryConsumerGroupListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryConsumerGroupStatusRequest extends $tea.Model {
  groupId?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryConsumerGroupStatusResponseBody extends $tea.Model {
  accumulatedConsumeCountPerMinute?: number;
  accumulationCount?: number;
  clientConnectionStatusList?: QueryConsumerGroupStatusResponseBodyClientConnectionStatusList;
  code?: string;
  consumerSpeed?: number;
  errorMessage?: string;
  lastConsumerTime?: string;
  realTimeConsumeCountPerMinute?: number;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      accumulatedConsumeCountPerMinute: 'AccumulatedConsumeCountPerMinute',
      accumulationCount: 'AccumulationCount',
      clientConnectionStatusList: 'ClientConnectionStatusList',
      code: 'Code',
      consumerSpeed: 'ConsumerSpeed',
      errorMessage: 'ErrorMessage',
      lastConsumerTime: 'LastConsumerTime',
      realTimeConsumeCountPerMinute: 'RealTimeConsumeCountPerMinute',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accumulatedConsumeCountPerMinute: 'number',
      accumulationCount: 'number',
      clientConnectionStatusList: QueryConsumerGroupStatusResponseBodyClientConnectionStatusList,
      code: 'string',
      consumerSpeed: 'number',
      errorMessage: 'string',
      lastConsumerTime: 'string',
      realTimeConsumeCountPerMinute: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryConsumerGroupStatusResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryConsumerGroupStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryConsumerGroupStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDetailSceneRuleLogRequest extends $tea.Model {
  currentPage?: number;
  endTime?: number;
  iotInstanceId?: string;
  pageSize?: number;
  ruleId?: string;
  startTime?: number;
  traceId?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      endTime: 'EndTime',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
      ruleId: 'RuleId',
      startTime: 'StartTime',
      traceId: 'TraceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      endTime: 'number',
      iotInstanceId: 'string',
      pageSize: 'number',
      ruleId: 'string',
      startTime: 'number',
      traceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDetailSceneRuleLogResponseBody extends $tea.Model {
  code?: string;
  data?: QueryDetailSceneRuleLogResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryDetailSceneRuleLogResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDetailSceneRuleLogResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryDetailSceneRuleLogResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryDetailSceneRuleLogResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceRequest extends $tea.Model {
  currentPage?: number;
  iotInstanceId?: string;
  nextToken?: string;
  pageSize?: number;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      iotInstanceId: 'IotInstanceId',
      nextToken: 'NextToken',
      pageSize: 'PageSize',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      iotInstanceId: 'string',
      nextToken: 'string',
      pageSize: 'number',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceResponseBody extends $tea.Model {
  code?: string;
  data?: QueryDeviceResponseBodyData;
  errorMessage?: string;
  nextToken?: string;
  page?: number;
  pageCount?: number;
  pageSize?: number;
  requestId?: string;
  success?: boolean;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      nextToken: 'NextToken',
      page: 'Page',
      pageCount: 'PageCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryDeviceResponseBodyData,
      errorMessage: 'string',
      nextToken: 'string',
      page: 'number',
      pageCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryDeviceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryDeviceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceBySQLRequest extends $tea.Model {
  iotInstanceId?: string;
  SQL?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      SQL: 'SQL',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      SQL: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceBySQLResponseBody extends $tea.Model {
  code?: string;
  data?: QueryDeviceBySQLResponseBodyData[];
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: { 'type': 'array', 'itemType': QueryDeviceBySQLResponseBodyData },
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceBySQLResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryDeviceBySQLResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryDeviceBySQLResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceByStatusRequest extends $tea.Model {
  currentPage?: number;
  iotInstanceId?: string;
  pageSize?: number;
  productKey?: string;
  resourceGroupId?: string;
  status?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
      productKey: 'ProductKey',
      resourceGroupId: 'ResourceGroupId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      iotInstanceId: 'string',
      pageSize: 'number',
      productKey: 'string',
      resourceGroupId: 'string',
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceByStatusResponseBody extends $tea.Model {
  code?: string;
  data?: QueryDeviceByStatusResponseBodyData;
  errorMessage?: string;
  page?: number;
  pageCount?: number;
  pageSize?: number;
  requestId?: string;
  success?: boolean;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      page: 'Page',
      pageCount: 'PageCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryDeviceByStatusResponseBodyData,
      errorMessage: 'string',
      page: 'number',
      pageCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceByStatusResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryDeviceByStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryDeviceByStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceByTagsRequest extends $tea.Model {
  currentPage?: number;
  iotInstanceId?: string;
  pageSize?: number;
  tag?: QueryDeviceByTagsRequestTag[];
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      iotInstanceId: 'string',
      pageSize: 'number',
      tag: { 'type': 'array', 'itemType': QueryDeviceByTagsRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceByTagsResponseBody extends $tea.Model {
  code?: string;
  data?: QueryDeviceByTagsResponseBodyData;
  errorMessage?: string;
  page?: number;
  pageCount?: number;
  pageSize?: number;
  requestId?: string;
  success?: boolean;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      page: 'Page',
      pageCount: 'PageCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryDeviceByTagsResponseBodyData,
      errorMessage: 'string',
      page: 'number',
      pageCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceByTagsResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryDeviceByTagsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryDeviceByTagsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceCertRequest extends $tea.Model {
  deviceName?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceCertResponseBody extends $tea.Model {
  code?: string;
  deviceCertInfo?: QueryDeviceCertResponseBodyDeviceCertInfo;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      deviceCertInfo: 'DeviceCertInfo',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      deviceCertInfo: QueryDeviceCertResponseBodyDeviceCertInfo,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceCertResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryDeviceCertResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryDeviceCertResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceDesiredPropertyRequest extends $tea.Model {
  deviceName?: string;
  functionBlockId?: string;
  identifier?: string[];
  iotId?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      functionBlockId: 'FunctionBlockId',
      identifier: 'Identifier',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      functionBlockId: 'string',
      identifier: { 'type': 'array', 'itemType': 'string' },
      iotId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceDesiredPropertyResponseBody extends $tea.Model {
  code?: string;
  data?: QueryDeviceDesiredPropertyResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryDeviceDesiredPropertyResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceDesiredPropertyResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryDeviceDesiredPropertyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryDeviceDesiredPropertyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceDetailRequest extends $tea.Model {
  deviceName?: string;
  iotId?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceDetailResponseBody extends $tea.Model {
  code?: string;
  data?: QueryDeviceDetailResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryDeviceDetailResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceDetailResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryDeviceDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryDeviceDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceDistributeDetailRequest extends $tea.Model {
  jobId?: string;
  static names(): { [key: string]: string } {
    return {
      jobId: 'JobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      jobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceDistributeDetailResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  file?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      file: 'File',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      file: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceDistributeDetailResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryDeviceDistributeDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryDeviceDistributeDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceDistributeJobRequest extends $tea.Model {
  jobId?: string;
  static names(): { [key: string]: string } {
    return {
      jobId: 'JobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      jobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceDistributeJobResponseBody extends $tea.Model {
  code?: string;
  data?: QueryDeviceDistributeJobResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryDeviceDistributeJobResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceDistributeJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryDeviceDistributeJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryDeviceDistributeJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceEventDataRequest extends $tea.Model {
  asc?: number;
  deviceName?: string;
  endTime?: number;
  eventType?: string;
  identifier?: string;
  iotId?: string;
  iotInstanceId?: string;
  pageSize?: number;
  productKey?: string;
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      asc: 'Asc',
      deviceName: 'DeviceName',
      endTime: 'EndTime',
      eventType: 'EventType',
      identifier: 'Identifier',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
      productKey: 'ProductKey',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      asc: 'number',
      deviceName: 'string',
      endTime: 'number',
      eventType: 'string',
      identifier: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      pageSize: 'number',
      productKey: 'string',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceEventDataResponseBody extends $tea.Model {
  code?: string;
  data?: QueryDeviceEventDataResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryDeviceEventDataResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceEventDataResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryDeviceEventDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryDeviceEventDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceFileRequest extends $tea.Model {
  deviceName?: string;
  fileId?: string;
  iotId?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      fileId: 'FileId',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      fileId: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceFileResponseBody extends $tea.Model {
  code?: string;
  data?: QueryDeviceFileResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryDeviceFileResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceFileResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryDeviceFileResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryDeviceFileResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceFileListRequest extends $tea.Model {
  currentPage?: number;
  deviceName?: string;
  iotId?: string;
  iotInstanceId?: string;
  pageSize?: number;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      deviceName: 'DeviceName',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      deviceName: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      pageSize: 'number',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceFileListResponseBody extends $tea.Model {
  code?: string;
  currentPage?: number;
  data?: QueryDeviceFileListResponseBodyData;
  errorMessage?: string;
  pageCount?: number;
  pageSize?: number;
  requestId?: string;
  success?: boolean;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      currentPage: 'CurrentPage',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      pageCount: 'PageCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      currentPage: 'number',
      data: QueryDeviceFileListResponseBodyData,
      errorMessage: 'string',
      pageCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceFileListResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryDeviceFileListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryDeviceFileListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceGroupByDeviceRequest extends $tea.Model {
  deviceName?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceGroupByDeviceResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  groupInfos?: QueryDeviceGroupByDeviceResponseBodyGroupInfos;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      groupInfos: 'GroupInfos',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      groupInfos: QueryDeviceGroupByDeviceResponseBodyGroupInfos,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceGroupByDeviceResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryDeviceGroupByDeviceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryDeviceGroupByDeviceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceGroupByTagsRequest extends $tea.Model {
  currentPage?: number;
  iotInstanceId?: string;
  pageSize?: number;
  tag?: QueryDeviceGroupByTagsRequestTag[];
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      iotInstanceId: 'string',
      pageSize: 'number',
      tag: { 'type': 'array', 'itemType': QueryDeviceGroupByTagsRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceGroupByTagsResponseBody extends $tea.Model {
  code?: string;
  data?: QueryDeviceGroupByTagsResponseBodyData;
  errorMessage?: string;
  page?: number;
  pageCount?: number;
  pageSize?: number;
  requestId?: string;
  success?: boolean;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      page: 'Page',
      pageCount: 'PageCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryDeviceGroupByTagsResponseBodyData,
      errorMessage: 'string',
      page: 'number',
      pageCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceGroupByTagsResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryDeviceGroupByTagsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryDeviceGroupByTagsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceGroupInfoRequest extends $tea.Model {
  groupId?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceGroupInfoResponseBody extends $tea.Model {
  code?: string;
  data?: QueryDeviceGroupInfoResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryDeviceGroupInfoResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceGroupInfoResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryDeviceGroupInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryDeviceGroupInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceGroupListRequest extends $tea.Model {
  currentPage?: number;
  groupName?: string;
  iotInstanceId?: string;
  pageSize?: number;
  superGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      groupName: 'GroupName',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
      superGroupId: 'SuperGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      groupName: 'string',
      iotInstanceId: 'string',
      pageSize: 'number',
      superGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceGroupListResponseBody extends $tea.Model {
  code?: string;
  currentPage?: number;
  data?: QueryDeviceGroupListResponseBodyData;
  errorMessage?: string;
  pageCount?: number;
  pageSize?: number;
  requestId?: string;
  success?: boolean;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      currentPage: 'CurrentPage',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      pageCount: 'PageCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      currentPage: 'number',
      data: QueryDeviceGroupListResponseBodyData,
      errorMessage: 'string',
      pageCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceGroupListResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryDeviceGroupListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryDeviceGroupListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceGroupTagListRequest extends $tea.Model {
  groupId?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceGroupTagListResponseBody extends $tea.Model {
  code?: string;
  data?: QueryDeviceGroupTagListResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryDeviceGroupTagListResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceGroupTagListResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryDeviceGroupTagListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryDeviceGroupTagListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceInfoRequest extends $tea.Model {
  deviceName?: string;
  iotId?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceInfoResponseBody extends $tea.Model {
  code?: string;
  data?: QueryDeviceInfoResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryDeviceInfoResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceInfoResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryDeviceInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryDeviceInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceListByDeviceGroupRequest extends $tea.Model {
  currentPage?: number;
  groupId?: string;
  iotInstanceId?: string;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      groupId: 'GroupId',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      groupId: 'string',
      iotInstanceId: 'string',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceListByDeviceGroupResponseBody extends $tea.Model {
  code?: string;
  data?: QueryDeviceListByDeviceGroupResponseBodyData;
  errorMessage?: string;
  page?: number;
  pageCount?: number;
  pageSize?: number;
  requestId?: string;
  success?: boolean;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      page: 'Page',
      pageCount: 'PageCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryDeviceListByDeviceGroupResponseBodyData,
      errorMessage: 'string',
      page: 'number',
      pageCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceListByDeviceGroupResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryDeviceListByDeviceGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryDeviceListByDeviceGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceOriginalEventDataRequest extends $tea.Model {
  asc?: number;
  deviceName?: string;
  endTime?: number;
  identifier?: string;
  iotId?: string;
  iotInstanceId?: string;
  nextPageToken?: string;
  pageSize?: number;
  productKey?: string;
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      asc: 'Asc',
      deviceName: 'DeviceName',
      endTime: 'EndTime',
      identifier: 'Identifier',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      nextPageToken: 'NextPageToken',
      pageSize: 'PageSize',
      productKey: 'ProductKey',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      asc: 'number',
      deviceName: 'string',
      endTime: 'number',
      identifier: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      nextPageToken: 'string',
      pageSize: 'number',
      productKey: 'string',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceOriginalEventDataResponseBody extends $tea.Model {
  code?: string;
  data?: QueryDeviceOriginalEventDataResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryDeviceOriginalEventDataResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceOriginalEventDataResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryDeviceOriginalEventDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryDeviceOriginalEventDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceOriginalPropertyDataRequest extends $tea.Model {
  asc?: number;
  deviceName?: string;
  endTime?: number;
  identifier?: string;
  iotId?: string;
  iotInstanceId?: string;
  nextPageToken?: string;
  pageSize?: number;
  productKey?: string;
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      asc: 'Asc',
      deviceName: 'DeviceName',
      endTime: 'EndTime',
      identifier: 'Identifier',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      nextPageToken: 'NextPageToken',
      pageSize: 'PageSize',
      productKey: 'ProductKey',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      asc: 'number',
      deviceName: 'string',
      endTime: 'number',
      identifier: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      nextPageToken: 'string',
      pageSize: 'number',
      productKey: 'string',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceOriginalPropertyDataResponseBody extends $tea.Model {
  code?: string;
  data?: QueryDeviceOriginalPropertyDataResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryDeviceOriginalPropertyDataResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceOriginalPropertyDataResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryDeviceOriginalPropertyDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryDeviceOriginalPropertyDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceOriginalPropertyStatusRequest extends $tea.Model {
  asc?: number;
  deviceName?: string;
  iotId?: string;
  iotInstanceId?: string;
  nextPageToken?: string;
  pageSize?: number;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      asc: 'Asc',
      deviceName: 'DeviceName',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      nextPageToken: 'NextPageToken',
      pageSize: 'PageSize',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      asc: 'number',
      deviceName: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      nextPageToken: 'string',
      pageSize: 'number',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceOriginalPropertyStatusResponseBody extends $tea.Model {
  code?: string;
  data?: QueryDeviceOriginalPropertyStatusResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryDeviceOriginalPropertyStatusResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceOriginalPropertyStatusResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryDeviceOriginalPropertyStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryDeviceOriginalPropertyStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceOriginalServiceDataRequest extends $tea.Model {
  asc?: number;
  deviceName?: string;
  endTime?: number;
  identifier?: string;
  iotId?: string;
  iotInstanceId?: string;
  nextPageToken?: string;
  pageSize?: number;
  productKey?: string;
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      asc: 'Asc',
      deviceName: 'DeviceName',
      endTime: 'EndTime',
      identifier: 'Identifier',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      nextPageToken: 'NextPageToken',
      pageSize: 'PageSize',
      productKey: 'ProductKey',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      asc: 'number',
      deviceName: 'string',
      endTime: 'number',
      identifier: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      nextPageToken: 'string',
      pageSize: 'number',
      productKey: 'string',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceOriginalServiceDataResponseBody extends $tea.Model {
  code?: string;
  data?: QueryDeviceOriginalServiceDataResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryDeviceOriginalServiceDataResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceOriginalServiceDataResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryDeviceOriginalServiceDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryDeviceOriginalServiceDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicePropRequest extends $tea.Model {
  deviceName?: string;
  iotId?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicePropResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  props?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      props: 'Props',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      props: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicePropResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryDevicePropResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryDevicePropResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicePropertiesDataRequest extends $tea.Model {
  asc?: number;
  deviceName?: string;
  endTime?: number;
  identifier?: string[];
  iotId?: string;
  iotInstanceId?: string;
  pageSize?: number;
  productKey?: string;
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      asc: 'Asc',
      deviceName: 'DeviceName',
      endTime: 'EndTime',
      identifier: 'Identifier',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
      productKey: 'ProductKey',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      asc: 'number',
      deviceName: 'string',
      endTime: 'number',
      identifier: { 'type': 'array', 'itemType': 'string' },
      iotId: 'string',
      iotInstanceId: 'string',
      pageSize: 'number',
      productKey: 'string',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicePropertiesDataResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  nextTime?: number;
  nextValid?: boolean;
  propertyDataInfos?: QueryDevicePropertiesDataResponseBodyPropertyDataInfos;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      nextTime: 'NextTime',
      nextValid: 'NextValid',
      propertyDataInfos: 'PropertyDataInfos',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      nextTime: 'number',
      nextValid: 'boolean',
      propertyDataInfos: QueryDevicePropertiesDataResponseBodyPropertyDataInfos,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicePropertiesDataResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryDevicePropertiesDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryDevicePropertiesDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicePropertyDataRequest extends $tea.Model {
  asc?: number;
  deviceName?: string;
  endTime?: number;
  identifier?: string;
  iotId?: string;
  iotInstanceId?: string;
  pageSize?: number;
  productKey?: string;
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      asc: 'Asc',
      deviceName: 'DeviceName',
      endTime: 'EndTime',
      identifier: 'Identifier',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
      productKey: 'ProductKey',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      asc: 'number',
      deviceName: 'string',
      endTime: 'number',
      identifier: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      pageSize: 'number',
      productKey: 'string',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicePropertyDataResponseBody extends $tea.Model {
  code?: string;
  data?: QueryDevicePropertyDataResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryDevicePropertyDataResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicePropertyDataResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryDevicePropertyDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryDevicePropertyDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicePropertyStatusRequest extends $tea.Model {
  deviceName?: string;
  functionBlockId?: string;
  iotId?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      functionBlockId: 'FunctionBlockId',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      functionBlockId: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicePropertyStatusResponseBody extends $tea.Model {
  code?: string;
  data?: QueryDevicePropertyStatusResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryDevicePropertyStatusResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicePropertyStatusResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryDevicePropertyStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryDevicePropertyStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceServiceDataRequest extends $tea.Model {
  asc?: number;
  deviceName?: string;
  endTime?: number;
  identifier?: string;
  iotId?: string;
  iotInstanceId?: string;
  pageSize?: number;
  productKey?: string;
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      asc: 'Asc',
      deviceName: 'DeviceName',
      endTime: 'EndTime',
      identifier: 'Identifier',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
      productKey: 'ProductKey',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      asc: 'number',
      deviceName: 'string',
      endTime: 'number',
      identifier: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      pageSize: 'number',
      productKey: 'string',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceServiceDataResponseBody extends $tea.Model {
  code?: string;
  data?: QueryDeviceServiceDataResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryDeviceServiceDataResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceServiceDataResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryDeviceServiceDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryDeviceServiceDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceStatisticsRequest extends $tea.Model {
  groupId?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceStatisticsResponseBody extends $tea.Model {
  code?: string;
  data?: QueryDeviceStatisticsResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryDeviceStatisticsResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceStatisticsResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryDeviceStatisticsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryDeviceStatisticsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeDriverRequest extends $tea.Model {
  currentPage?: number;
  driverName?: string;
  iotInstanceId?: string;
  pageSize?: number;
  type?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      driverName: 'DriverName',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      driverName: 'string',
      iotInstanceId: 'string',
      pageSize: 'number',
      type: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeDriverResponseBody extends $tea.Model {
  code?: string;
  data?: QueryEdgeDriverResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryEdgeDriverResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeDriverResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryEdgeDriverResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryEdgeDriverResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeDriverVersionRequest extends $tea.Model {
  currentPage?: number;
  driverId?: string;
  driverVersion?: string;
  iotInstanceId?: string;
  pageSize?: number;
  versionState?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      driverId: 'DriverId',
      driverVersion: 'DriverVersion',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
      versionState: 'VersionState',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      driverId: 'string',
      driverVersion: 'string',
      iotInstanceId: 'string',
      pageSize: 'number',
      versionState: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeDriverVersionResponseBody extends $tea.Model {
  code?: string;
  data?: QueryEdgeDriverVersionResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryEdgeDriverVersionResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeDriverVersionResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryEdgeDriverVersionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryEdgeDriverVersionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceRequest extends $tea.Model {
  currentPage?: number;
  iotInstanceId?: string;
  name?: string;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      iotInstanceId: 'IotInstanceId',
      name: 'Name',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      iotInstanceId: 'string',
      name: 'string',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceResponseBody extends $tea.Model {
  code?: string;
  data?: QueryEdgeInstanceResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryEdgeInstanceResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryEdgeInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryEdgeInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceChannelRequest extends $tea.Model {
  channelName?: string;
  currentPage?: number;
  driverId?: string;
  instanceId?: string;
  iotInstanceId?: string;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      channelName: 'ChannelName',
      currentPage: 'CurrentPage',
      driverId: 'DriverId',
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelName: 'string',
      currentPage: 'number',
      driverId: 'string',
      instanceId: 'string',
      iotInstanceId: 'string',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceChannelResponseBody extends $tea.Model {
  code?: string;
  data?: QueryEdgeInstanceChannelResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryEdgeInstanceChannelResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceChannelResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryEdgeInstanceChannelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryEdgeInstanceChannelResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceDeviceRequest extends $tea.Model {
  currentPage?: number;
  instanceId?: string;
  iotInstanceId?: string;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      instanceId: 'string',
      iotInstanceId: 'string',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceDeviceResponseBody extends $tea.Model {
  code?: string;
  data?: QueryEdgeInstanceDeviceResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryEdgeInstanceDeviceResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceDeviceResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryEdgeInstanceDeviceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryEdgeInstanceDeviceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceDeviceByDriverRequest extends $tea.Model {
  channelId?: string;
  currentPage?: number;
  driverId?: string;
  instanceId?: string;
  iotInstanceId?: string;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      channelId: 'ChannelId',
      currentPage: 'CurrentPage',
      driverId: 'DriverId',
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelId: 'string',
      currentPage: 'number',
      driverId: 'string',
      instanceId: 'string',
      iotInstanceId: 'string',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceDeviceByDriverResponseBody extends $tea.Model {
  code?: string;
  data?: QueryEdgeInstanceDeviceByDriverResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryEdgeInstanceDeviceByDriverResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceDeviceByDriverResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryEdgeInstanceDeviceByDriverResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryEdgeInstanceDeviceByDriverResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceDriverRequest extends $tea.Model {
  currentPage?: number;
  instanceId?: string;
  iotInstanceId?: string;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      instanceId: 'string',
      iotInstanceId: 'string',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceDriverResponseBody extends $tea.Model {
  code?: string;
  data?: QueryEdgeInstanceDriverResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryEdgeInstanceDriverResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceDriverResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryEdgeInstanceDriverResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryEdgeInstanceDriverResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceGatewayRequest extends $tea.Model {
  instanceId?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceGatewayResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  gatewayList?: QueryEdgeInstanceGatewayResponseBodyGatewayList[];
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      gatewayList: 'GatewayList',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      gatewayList: { 'type': 'array', 'itemType': QueryEdgeInstanceGatewayResponseBodyGatewayList },
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceGatewayResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryEdgeInstanceGatewayResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryEdgeInstanceGatewayResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceHistoricDeploymentRequest extends $tea.Model {
  currentPage?: number;
  endTime?: number;
  instanceId?: string;
  iotInstanceId?: string;
  pageSize?: number;
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      endTime: 'EndTime',
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      endTime: 'number',
      instanceId: 'string',
      iotInstanceId: 'string',
      pageSize: 'number',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceHistoricDeploymentResponseBody extends $tea.Model {
  code?: string;
  data?: QueryEdgeInstanceHistoricDeploymentResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryEdgeInstanceHistoricDeploymentResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceHistoricDeploymentResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryEdgeInstanceHistoricDeploymentResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryEdgeInstanceHistoricDeploymentResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceMessageRoutingRequest extends $tea.Model {
  currentPage?: number;
  instanceId?: string;
  iotInstanceId?: string;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      instanceId: 'string',
      iotInstanceId: 'string',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceMessageRoutingResponseBody extends $tea.Model {
  code?: string;
  data?: QueryEdgeInstanceMessageRoutingResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryEdgeInstanceMessageRoutingResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceMessageRoutingResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryEdgeInstanceMessageRoutingResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryEdgeInstanceMessageRoutingResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceSceneRuleRequest extends $tea.Model {
  currentPage?: number;
  instanceId?: string;
  iotInstanceId?: string;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      instanceId: 'string',
      iotInstanceId: 'string',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceSceneRuleResponseBody extends $tea.Model {
  code?: string;
  data?: QueryEdgeInstanceSceneRuleResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryEdgeInstanceSceneRuleResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceSceneRuleResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryEdgeInstanceSceneRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryEdgeInstanceSceneRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobRequest extends $tea.Model {
  iotInstanceId?: string;
  jobId?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      jobId: 'JobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      jobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobResponseBody extends $tea.Model {
  code?: string;
  data?: QueryJobResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryJobResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobStatisticsRequest extends $tea.Model {
  iotInstanceId?: string;
  jobId?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      jobId: 'JobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      jobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobStatisticsResponseBody extends $tea.Model {
  code?: string;
  data?: QueryJobStatisticsResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryJobStatisticsResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobStatisticsResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryJobStatisticsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryJobStatisticsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryLoRaJoinPermissionsRequest extends $tea.Model {
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryLoRaJoinPermissionsResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  joinPermissions?: QueryLoRaJoinPermissionsResponseBodyJoinPermissions;
  productKey?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      joinPermissions: 'JoinPermissions',
      productKey: 'ProductKey',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      joinPermissions: QueryLoRaJoinPermissionsResponseBodyJoinPermissions,
      productKey: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryLoRaJoinPermissionsResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryLoRaJoinPermissionsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryLoRaJoinPermissionsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMessageInfoRequest extends $tea.Model {
  iotInstanceId?: string;
  uniMsgId?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      uniMsgId: 'UniMsgId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      uniMsgId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMessageInfoResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  message?: QueryMessageInfoResponseBodyMessage;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      message: QueryMessageInfoResponseBodyMessage,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMessageInfoResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryMessageInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryMessageInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryOTAFirmwareRequest extends $tea.Model {
  firmwareId?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      firmwareId: 'FirmwareId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      firmwareId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryOTAFirmwareResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  firmwareInfo?: QueryOTAFirmwareResponseBodyFirmwareInfo;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      firmwareInfo: 'FirmwareInfo',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      firmwareInfo: QueryOTAFirmwareResponseBodyFirmwareInfo,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryOTAFirmwareResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryOTAFirmwareResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryOTAFirmwareResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryOTAJobRequest extends $tea.Model {
  iotInstanceId?: string;
  jobId?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      jobId: 'JobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      jobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryOTAJobResponseBody extends $tea.Model {
  code?: string;
  data?: QueryOTAJobResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryOTAJobResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryOTAJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryOTAJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryOTAJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryPageByApplyIdRequest extends $tea.Model {
  applyId?: number;
  currentPage?: number;
  iotInstanceId?: string;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      applyId: 'ApplyId',
      currentPage: 'CurrentPage',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applyId: 'number',
      currentPage: 'number',
      iotInstanceId: 'string',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryPageByApplyIdResponseBody extends $tea.Model {
  applyDeviceList?: QueryPageByApplyIdResponseBodyApplyDeviceList;
  code?: string;
  errorMessage?: string;
  page?: number;
  pageCount?: number;
  pageSize?: number;
  requestId?: string;
  success?: boolean;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      applyDeviceList: 'ApplyDeviceList',
      code: 'Code',
      errorMessage: 'ErrorMessage',
      page: 'Page',
      pageCount: 'PageCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applyDeviceList: QueryPageByApplyIdResponseBodyApplyDeviceList,
      code: 'string',
      errorMessage: 'string',
      page: 'number',
      pageCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryPageByApplyIdResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryPageByApplyIdResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryPageByApplyIdResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryProductRequest extends $tea.Model {
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryProductResponseBody extends $tea.Model {
  code?: string;
  data?: QueryProductResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryProductResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryProductResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryProductResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryProductResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryProductCertInfoRequest extends $tea.Model {
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryProductCertInfoResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  productCertInfo?: QueryProductCertInfoResponseBodyProductCertInfo;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      productCertInfo: 'ProductCertInfo',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      productCertInfo: QueryProductCertInfoResponseBodyProductCertInfo,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryProductCertInfoResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryProductCertInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryProductCertInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryProductListRequest extends $tea.Model {
  aliyunCommodityCode?: string;
  currentPage?: number;
  iotInstanceId?: string;
  pageSize?: number;
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      aliyunCommodityCode: 'AliyunCommodityCode',
      currentPage: 'CurrentPage',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunCommodityCode: 'string',
      currentPage: 'number',
      iotInstanceId: 'string',
      pageSize: 'number',
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryProductListResponseBody extends $tea.Model {
  code?: string;
  data?: QueryProductListResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryProductListResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryProductListResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryProductListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryProductListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryProductTopicRequest extends $tea.Model {
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryProductTopicResponseBody extends $tea.Model {
  code?: string;
  data?: QueryProductTopicResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryProductTopicResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryProductTopicResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryProductTopicResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryProductTopicResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySceneRuleRequest extends $tea.Model {
  currentPage?: number;
  iotInstanceId?: string;
  pageSize?: number;
  ruleName?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
      ruleName: 'RuleName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      iotInstanceId: 'string',
      pageSize: 'number',
      ruleName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySceneRuleResponseBody extends $tea.Model {
  code?: string;
  data?: QuerySceneRuleResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QuerySceneRuleResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySceneRuleResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QuerySceneRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QuerySceneRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySolutionDeviceGroupPageRequest extends $tea.Model {
  fuzzyGroupName?: string;
  iotInstanceId?: string;
  pageId?: number;
  pageSize?: number;
  projectCode?: string;
  static names(): { [key: string]: string } {
    return {
      fuzzyGroupName: 'FuzzyGroupName',
      iotInstanceId: 'IotInstanceId',
      pageId: 'PageId',
      pageSize: 'PageSize',
      projectCode: 'ProjectCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fuzzyGroupName: 'string',
      iotInstanceId: 'string',
      pageId: 'number',
      pageSize: 'number',
      projectCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySolutionDeviceGroupPageResponseBody extends $tea.Model {
  code?: string;
  data?: QuerySolutionDeviceGroupPageResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QuerySolutionDeviceGroupPageResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySolutionDeviceGroupPageResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QuerySolutionDeviceGroupPageResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QuerySolutionDeviceGroupPageResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechRequest extends $tea.Model {
  iotInstanceId?: string;
  speechCode?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      speechCode: 'SpeechCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      speechCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechResponseBody extends $tea.Model {
  code?: string;
  data?: QuerySpeechResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QuerySpeechResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QuerySpeechResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QuerySpeechResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechListRequest extends $tea.Model {
  iotInstanceId?: string;
  pageId?: number;
  pageSize?: number;
  projectCode?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      pageId: 'PageId',
      pageSize: 'PageSize',
      projectCode: 'ProjectCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      pageId: 'number',
      pageSize: 'number',
      projectCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechListResponseBody extends $tea.Model {
  code?: string;
  data?: QuerySpeechListResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QuerySpeechListResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechListResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QuerySpeechListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QuerySpeechListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechPushJobRequest extends $tea.Model {
  iotInstanceId?: string;
  jobCode?: string;
  pageId?: number;
  pageSize?: number;
  projectCode?: string;
  pushMode?: string;
  statusList?: string[];
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      jobCode: 'JobCode',
      pageId: 'PageId',
      pageSize: 'PageSize',
      projectCode: 'ProjectCode',
      pushMode: 'PushMode',
      statusList: 'StatusList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      jobCode: 'string',
      pageId: 'number',
      pageSize: 'number',
      projectCode: 'string',
      pushMode: 'string',
      statusList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechPushJobResponseBody extends $tea.Model {
  code?: string;
  data?: QuerySpeechPushJobResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QuerySpeechPushJobResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechPushJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QuerySpeechPushJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QuerySpeechPushJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechPushJobDeviceRequest extends $tea.Model {
  deviceName?: string;
  iotInstanceId?: string;
  jobCode?: string;
  pageId?: number;
  pageSize?: number;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotInstanceId: 'IotInstanceId',
      jobCode: 'JobCode',
      pageId: 'PageId',
      pageSize: 'PageSize',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotInstanceId: 'string',
      jobCode: 'string',
      pageId: 'number',
      pageSize: 'number',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechPushJobDeviceResponseBody extends $tea.Model {
  code?: string;
  data?: QuerySpeechPushJobDeviceResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QuerySpeechPushJobDeviceResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechPushJobDeviceResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QuerySpeechPushJobDeviceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QuerySpeechPushJobDeviceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechPushJobSpeechRequest extends $tea.Model {
  iotInstanceId?: string;
  jobCode?: string;
  pageId?: number;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      jobCode: 'JobCode',
      pageId: 'PageId',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      jobCode: 'string',
      pageId: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechPushJobSpeechResponseBody extends $tea.Model {
  code?: string;
  data?: QuerySpeechPushJobSpeechResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QuerySpeechPushJobSpeechResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechPushJobSpeechResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QuerySpeechPushJobSpeechResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QuerySpeechPushJobSpeechResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryStudioAppDomainListOpenRequest extends $tea.Model {
  appId?: string;
  iotInstanceId?: string;
  projectId?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      iotInstanceId: 'IotInstanceId',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      iotInstanceId: 'string',
      projectId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryStudioAppDomainListOpenResponseBody extends $tea.Model {
  code?: string;
  data?: QueryStudioAppDomainListOpenResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryStudioAppDomainListOpenResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryStudioAppDomainListOpenResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryStudioAppDomainListOpenResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryStudioAppDomainListOpenResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryStudioAppListRequest extends $tea.Model {
  fuzzyName?: string;
  iotInstanceId?: string;
  pageNo?: number;
  pageSize?: number;
  projectId?: string;
  types?: string[];
  static names(): { [key: string]: string } {
    return {
      fuzzyName: 'FuzzyName',
      iotInstanceId: 'IotInstanceId',
      pageNo: 'PageNo',
      pageSize: 'PageSize',
      projectId: 'ProjectId',
      types: 'Types',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fuzzyName: 'string',
      iotInstanceId: 'string',
      pageNo: 'number',
      pageSize: 'number',
      projectId: 'string',
      types: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryStudioAppListResponseBody extends $tea.Model {
  code?: string;
  data?: QueryStudioAppListResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryStudioAppListResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryStudioAppListResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryStudioAppListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryStudioAppListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryStudioAppPageListOpenRequest extends $tea.Model {
  appId?: string;
  iotInstanceId?: string;
  isRelease?: boolean;
  pageNo?: number;
  pageSize?: number;
  projectId?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      iotInstanceId: 'IotInstanceId',
      isRelease: 'IsRelease',
      pageNo: 'PageNo',
      pageSize: 'PageSize',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      iotInstanceId: 'string',
      isRelease: 'boolean',
      pageNo: 'number',
      pageSize: 'number',
      projectId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryStudioAppPageListOpenResponseBody extends $tea.Model {
  code?: string;
  data?: QueryStudioAppPageListOpenResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryStudioAppPageListOpenResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryStudioAppPageListOpenResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryStudioAppPageListOpenResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryStudioAppPageListOpenResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryStudioProjectListRequest extends $tea.Model {
  iotInstanceId?: string;
  name?: string;
  pageNo?: number;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      name: 'Name',
      pageNo: 'PageNo',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      name: 'string',
      pageNo: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryStudioProjectListResponseBody extends $tea.Model {
  code?: string;
  data?: QueryStudioProjectListResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryStudioProjectListResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryStudioProjectListResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryStudioProjectListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryStudioProjectListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySubscribeRelationRequest extends $tea.Model {
  iotInstanceId?: string;
  productKey?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      productKey: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySubscribeRelationResponseBody extends $tea.Model {
  code?: string;
  consumerGroupIds?: string[];
  deviceDataFlag?: boolean;
  deviceLifeCycleFlag?: boolean;
  deviceStatusChangeFlag?: boolean;
  deviceTagFlag?: boolean;
  deviceTopoLifeCycleFlag?: boolean;
  errorMessage?: string;
  foundDeviceListFlag?: boolean;
  mnsConfiguration?: string;
  otaEventFlag?: boolean;
  otaJobFlag?: boolean;
  otaVersionFlag?: boolean;
  productKey?: string;
  requestId?: string;
  success?: boolean;
  thingHistoryFlag?: boolean;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      consumerGroupIds: 'ConsumerGroupIds',
      deviceDataFlag: 'DeviceDataFlag',
      deviceLifeCycleFlag: 'DeviceLifeCycleFlag',
      deviceStatusChangeFlag: 'DeviceStatusChangeFlag',
      deviceTagFlag: 'DeviceTagFlag',
      deviceTopoLifeCycleFlag: 'DeviceTopoLifeCycleFlag',
      errorMessage: 'ErrorMessage',
      foundDeviceListFlag: 'FoundDeviceListFlag',
      mnsConfiguration: 'MnsConfiguration',
      otaEventFlag: 'OtaEventFlag',
      otaJobFlag: 'OtaJobFlag',
      otaVersionFlag: 'OtaVersionFlag',
      productKey: 'ProductKey',
      requestId: 'RequestId',
      success: 'Success',
      thingHistoryFlag: 'ThingHistoryFlag',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      consumerGroupIds: { 'type': 'array', 'itemType': 'string' },
      deviceDataFlag: 'boolean',
      deviceLifeCycleFlag: 'boolean',
      deviceStatusChangeFlag: 'boolean',
      deviceTagFlag: 'boolean',
      deviceTopoLifeCycleFlag: 'boolean',
      errorMessage: 'string',
      foundDeviceListFlag: 'boolean',
      mnsConfiguration: 'string',
      otaEventFlag: 'boolean',
      otaJobFlag: 'boolean',
      otaVersionFlag: 'boolean',
      productKey: 'string',
      requestId: 'string',
      success: 'boolean',
      thingHistoryFlag: 'boolean',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySubscribeRelationResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QuerySubscribeRelationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QuerySubscribeRelationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySummarySceneRuleLogRequest extends $tea.Model {
  currentPage?: number;
  endTime?: number;
  iotInstanceId?: string;
  pageSize?: number;
  ruleId?: string;
  startTime?: number;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      endTime: 'EndTime',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
      ruleId: 'RuleId',
      startTime: 'StartTime',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      endTime: 'number',
      iotInstanceId: 'string',
      pageSize: 'number',
      ruleId: 'string',
      startTime: 'number',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySummarySceneRuleLogResponseBody extends $tea.Model {
  code?: string;
  data?: QuerySummarySceneRuleLogResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QuerySummarySceneRuleLogResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySummarySceneRuleLogResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QuerySummarySceneRuleLogResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QuerySummarySceneRuleLogResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySuperDeviceGroupRequest extends $tea.Model {
  groupId?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySuperDeviceGroupResponseBody extends $tea.Model {
  code?: string;
  data?: QuerySuperDeviceGroupResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QuerySuperDeviceGroupResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySuperDeviceGroupResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QuerySuperDeviceGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QuerySuperDeviceGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTaskRequest extends $tea.Model {
  iotInstanceId?: string;
  taskId?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      taskId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTaskResponseBody extends $tea.Model {
  code?: string;
  data?: QueryTaskResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryTaskResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTaskResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryThingModelRequest extends $tea.Model {
  functionBlockId?: string;
  iotInstanceId?: string;
  modelVersion?: string;
  productKey?: string;
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      functionBlockId: 'FunctionBlockId',
      iotInstanceId: 'IotInstanceId',
      modelVersion: 'ModelVersion',
      productKey: 'ProductKey',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      functionBlockId: 'string',
      iotInstanceId: 'string',
      modelVersion: 'string',
      productKey: 'string',
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryThingModelResponseBody extends $tea.Model {
  code?: string;
  data?: QueryThingModelResponseBodyData;
  errorMessage?: string;
  productKey?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      productKey: 'ProductKey',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryThingModelResponseBodyData,
      errorMessage: 'string',
      productKey: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryThingModelResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryThingModelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryThingModelResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryThingModelExtendConfigRequest extends $tea.Model {
  functionBlockId?: string;
  iotInstanceId?: string;
  modelVersion?: string;
  productKey?: string;
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      functionBlockId: 'FunctionBlockId',
      iotInstanceId: 'IotInstanceId',
      modelVersion: 'ModelVersion',
      productKey: 'ProductKey',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      functionBlockId: 'string',
      iotInstanceId: 'string',
      modelVersion: 'string',
      productKey: 'string',
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryThingModelExtendConfigResponseBody extends $tea.Model {
  code?: string;
  data?: QueryThingModelExtendConfigResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryThingModelExtendConfigResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryThingModelExtendConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryThingModelExtendConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryThingModelExtendConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryThingModelExtendConfigPublishedRequest extends $tea.Model {
  functionBlockId?: string;
  iotInstanceId?: string;
  modelVersion?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      functionBlockId: 'FunctionBlockId',
      iotInstanceId: 'IotInstanceId',
      modelVersion: 'ModelVersion',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      functionBlockId: 'string',
      iotInstanceId: 'string',
      modelVersion: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryThingModelExtendConfigPublishedResponseBody extends $tea.Model {
  code?: string;
  data?: QueryThingModelExtendConfigPublishedResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryThingModelExtendConfigPublishedResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryThingModelExtendConfigPublishedResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryThingModelExtendConfigPublishedResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryThingModelExtendConfigPublishedResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryThingModelPublishedRequest extends $tea.Model {
  functionBlockId?: string;
  iotInstanceId?: string;
  modelVersion?: string;
  productKey?: string;
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      functionBlockId: 'FunctionBlockId',
      iotInstanceId: 'IotInstanceId',
      modelVersion: 'ModelVersion',
      productKey: 'ProductKey',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      functionBlockId: 'string',
      iotInstanceId: 'string',
      modelVersion: 'string',
      productKey: 'string',
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryThingModelPublishedResponseBody extends $tea.Model {
  code?: string;
  data?: QueryThingModelPublishedResponseBodyData;
  errorMessage?: string;
  productKey?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      productKey: 'ProductKey',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryThingModelPublishedResponseBodyData,
      errorMessage: 'string',
      productKey: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryThingModelPublishedResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryThingModelPublishedResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryThingModelPublishedResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTopicReverseRouteTableRequest extends $tea.Model {
  iotInstanceId?: string;
  regionId?: string;
  topic?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      regionId: 'RegionId',
      topic: 'Topic',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      regionId: 'string',
      topic: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTopicReverseRouteTableResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  srcTopics?: QueryTopicReverseRouteTableResponseBodySrcTopics;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      srcTopics: 'SrcTopics',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      srcTopics: QueryTopicReverseRouteTableResponseBodySrcTopics,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTopicReverseRouteTableResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryTopicReverseRouteTableResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryTopicReverseRouteTableResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTopicRouteTableRequest extends $tea.Model {
  iotInstanceId?: string;
  topic?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      topic: 'Topic',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      topic: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTopicRouteTableResponseBody extends $tea.Model {
  code?: string;
  dstTopics?: QueryTopicRouteTableResponseBodyDstTopics;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      dstTopics: 'DstTopics',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      dstTopics: QueryTopicRouteTableResponseBodyDstTopics,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTopicRouteTableResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryTopicRouteTableResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryTopicRouteTableResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RRpcRequest extends $tea.Model {
  deviceName?: string;
  iotInstanceId?: string;
  productKey?: string;
  requestBase64Byte?: string;
  timeout?: number;
  topic?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
      requestBase64Byte: 'RequestBase64Byte',
      timeout: 'Timeout',
      topic: 'Topic',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
      requestBase64Byte: 'string',
      timeout: 'number',
      topic: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RRpcResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  messageId?: number;
  payloadBase64Byte?: string;
  requestId?: string;
  rrpcCode?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      messageId: 'MessageId',
      payloadBase64Byte: 'PayloadBase64Byte',
      requestId: 'RequestId',
      rrpcCode: 'RrpcCode',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      messageId: 'number',
      payloadBase64Byte: 'string',
      requestId: 'string',
      rrpcCode: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RRpcResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: RRpcResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: RRpcResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RefreshDeviceTunnelSharePasswordRequest extends $tea.Model {
  deviceName?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RefreshDeviceTunnelSharePasswordResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  password?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      password: 'Password',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      password: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RefreshDeviceTunnelSharePasswordResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: RefreshDeviceTunnelSharePasswordResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: RefreshDeviceTunnelSharePasswordResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RefreshStudioAppTokenOpenRequest extends $tea.Model {
  appId?: string;
  iotInstanceId?: string;
  projectId?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      iotInstanceId: 'IotInstanceId',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      iotInstanceId: 'string',
      projectId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RefreshStudioAppTokenOpenResponseBody extends $tea.Model {
  code?: string;
  data?: RefreshStudioAppTokenOpenResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: RefreshStudioAppTokenOpenResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RefreshStudioAppTokenOpenResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: RefreshStudioAppTokenOpenResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: RefreshStudioAppTokenOpenResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RegisterDeviceRequest extends $tea.Model {
  appKey?: string;
  devEui?: string;
  deviceName?: string;
  iotInstanceId?: string;
  joinEui?: string;
  loraNodeType?: string;
  nickname?: string;
  pinCode?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      appKey: 'AppKey',
      devEui: 'DevEui',
      deviceName: 'DeviceName',
      iotInstanceId: 'IotInstanceId',
      joinEui: 'JoinEui',
      loraNodeType: 'LoraNodeType',
      nickname: 'Nickname',
      pinCode: 'PinCode',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appKey: 'string',
      devEui: 'string',
      deviceName: 'string',
      iotInstanceId: 'string',
      joinEui: 'string',
      loraNodeType: 'string',
      nickname: 'string',
      pinCode: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RegisterDeviceResponseBody extends $tea.Model {
  code?: string;
  data?: RegisterDeviceResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: RegisterDeviceResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RegisterDeviceResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: RegisterDeviceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: RegisterDeviceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReleaseEdgeDriverVersionRequest extends $tea.Model {
  driverId?: string;
  driverVersion?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      driverId: 'DriverId',
      driverVersion: 'DriverVersion',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      driverId: 'string',
      driverVersion: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReleaseEdgeDriverVersionResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReleaseEdgeDriverVersionResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ReleaseEdgeDriverVersionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ReleaseEdgeDriverVersionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReleaseProductRequest extends $tea.Model {
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReleaseProductResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReleaseProductResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ReleaseProductResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ReleaseProductResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveThingTopoRequest extends $tea.Model {
  deviceName?: string;
  iotId?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveThingTopoResponseBody extends $tea.Model {
  code?: string;
  data?: boolean;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'boolean',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveThingTopoResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: RemoveThingTopoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: RemoveThingTopoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReplaceEdgeInstanceGatewayRequest extends $tea.Model {
  currentGatewayId?: string;
  instanceId?: string;
  iotInstanceId?: string;
  newGatewayId?: string;
  static names(): { [key: string]: string } {
    return {
      currentGatewayId: 'CurrentGatewayId',
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
      newGatewayId: 'NewGatewayId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentGatewayId: 'string',
      instanceId: 'string',
      iotInstanceId: 'string',
      newGatewayId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReplaceEdgeInstanceGatewayResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReplaceEdgeInstanceGatewayResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ReplaceEdgeInstanceGatewayResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ReplaceEdgeInstanceGatewayResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RerunJobRequest extends $tea.Model {
  iotInstanceId?: string;
  jobId?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      jobId: 'JobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      jobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RerunJobResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RerunJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: RerunJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: RerunJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResetConsumerGroupPositionRequest extends $tea.Model {
  groupId?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResetConsumerGroupPositionResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResetConsumerGroupPositionResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ResetConsumerGroupPositionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ResetConsumerGroupPositionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResetThingRequest extends $tea.Model {
  deviceName?: string;
  iotId?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResetThingResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResetThingResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ResetThingResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ResetThingResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SaveDevicePropRequest extends $tea.Model {
  deviceName?: string;
  iotId?: string;
  iotInstanceId?: string;
  productKey?: string;
  props?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
      props: 'Props',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
      props: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SaveDevicePropResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SaveDevicePropResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: SaveDevicePropResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: SaveDevicePropResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDeviceDesiredPropertyRequest extends $tea.Model {
  deviceName?: string;
  iotId?: string;
  iotInstanceId?: string;
  items?: string;
  productKey?: string;
  versions?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      items: 'Items',
      productKey: 'ProductKey',
      versions: 'Versions',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      items: 'string',
      productKey: 'string',
      versions: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDeviceDesiredPropertyResponseBody extends $tea.Model {
  code?: string;
  data?: SetDeviceDesiredPropertyResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: SetDeviceDesiredPropertyResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDeviceDesiredPropertyResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: SetDeviceDesiredPropertyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: SetDeviceDesiredPropertyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDeviceGroupTagsRequest extends $tea.Model {
  groupId?: string;
  iotInstanceId?: string;
  tagString?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      iotInstanceId: 'IotInstanceId',
      tagString: 'TagString',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      iotInstanceId: 'string',
      tagString: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDeviceGroupTagsResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDeviceGroupTagsResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: SetDeviceGroupTagsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: SetDeviceGroupTagsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDevicePropertyRequest extends $tea.Model {
  deviceName?: string;
  iotId?: string;
  iotInstanceId?: string;
  items?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      items: 'Items',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      items: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDevicePropertyResponseBody extends $tea.Model {
  code?: string;
  data?: SetDevicePropertyResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: SetDevicePropertyResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDevicePropertyResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: SetDevicePropertyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: SetDevicePropertyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDevicesPropertyRequest extends $tea.Model {
  deviceName?: string[];
  iotInstanceId?: string;
  items?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotInstanceId: 'IotInstanceId',
      items: 'Items',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: { 'type': 'array', 'itemType': 'string' },
      iotInstanceId: 'string',
      items: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDevicesPropertyResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDevicesPropertyResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: SetDevicesPropertyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: SetDevicesPropertyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetEdgeInstanceDriverConfigsRequest extends $tea.Model {
  configs?: SetEdgeInstanceDriverConfigsRequestConfigs[];
  driverId?: string;
  instanceId?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      configs: 'Configs',
      driverId: 'DriverId',
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configs: { 'type': 'array', 'itemType': SetEdgeInstanceDriverConfigsRequestConfigs },
      driverId: 'string',
      instanceId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetEdgeInstanceDriverConfigsResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetEdgeInstanceDriverConfigsResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: SetEdgeInstanceDriverConfigsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: SetEdgeInstanceDriverConfigsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetProductCertInfoRequest extends $tea.Model {
  iotInstanceId?: string;
  issueModel?: number;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      issueModel: 'IssueModel',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      issueModel: 'number',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetProductCertInfoResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetProductCertInfoResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: SetProductCertInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: SetProductCertInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetStudioProjectCooperationRequest extends $tea.Model {
  iotInstanceId?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetStudioProjectCooperationResponseBody extends $tea.Model {
  code?: string;
  data?: boolean;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'boolean',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetStudioProjectCooperationResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: SetStudioProjectCooperationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: SetStudioProjectCooperationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetupStudioAppAuthModeOpenRequest extends $tea.Model {
  appId?: string;
  authMode?: number;
  iotInstanceId?: string;
  projectId?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      authMode: 'AuthMode',
      iotInstanceId: 'IotInstanceId',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      authMode: 'number',
      iotInstanceId: 'string',
      projectId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetupStudioAppAuthModeOpenResponseBody extends $tea.Model {
  code?: string;
  data?: SetupStudioAppAuthModeOpenResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: SetupStudioAppAuthModeOpenResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetupStudioAppAuthModeOpenResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: SetupStudioAppAuthModeOpenResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: SetupStudioAppAuthModeOpenResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SpeechByCombinationRequest extends $tea.Model {
  combinationList?: string[];
  deviceName?: string;
  iotId?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      combinationList: 'CombinationList',
      deviceName: 'DeviceName',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      combinationList: { 'type': 'array', 'itemType': 'string' },
      deviceName: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SpeechByCombinationResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SpeechByCombinationResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: SpeechByCombinationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: SpeechByCombinationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartCpuRequest extends $tea.Model {
  iotId?: string;
  iotInstanceId?: string;
  targetValue?: string;
  static names(): { [key: string]: string } {
    return {
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      targetValue: 'TargetValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotId: 'string',
      iotInstanceId: 'string',
      targetValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartCpuResponseBody extends $tea.Model {
  code?: string;
  data?: StartCpuResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: StartCpuResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartCpuResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: StartCpuResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: StartCpuResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartRuleRequest extends $tea.Model {
  iotInstanceId?: string;
  ruleId?: number;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      ruleId: 'RuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      ruleId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartRuleResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartRuleResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: StartRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: StartRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopRuleRequest extends $tea.Model {
  iotInstanceId?: string;
  ruleId?: number;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      ruleId: 'RuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      ruleId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopRuleResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopRuleResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: StopRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: StopRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SyncSpeechByCombinationRequest extends $tea.Model {
  combinationList?: string[];
  deviceName?: string;
  iotId?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      combinationList: 'CombinationList',
      deviceName: 'DeviceName',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      combinationList: { 'type': 'array', 'itemType': 'string' },
      deviceName: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SyncSpeechByCombinationResponseBody extends $tea.Model {
  code?: string;
  data?: SyncSpeechByCombinationResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: SyncSpeechByCombinationResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SyncSpeechByCombinationResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: SyncSpeechByCombinationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: SyncSpeechByCombinationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TestSpeechRequest extends $tea.Model {
  iotInstanceId?: string;
  projectCode?: string;
  speechRate?: number;
  speechType?: string;
  text?: string;
  voice?: string;
  volume?: number;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      projectCode: 'ProjectCode',
      speechRate: 'SpeechRate',
      speechType: 'SpeechType',
      text: 'Text',
      voice: 'Voice',
      volume: 'Volume',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      projectCode: 'string',
      speechRate: 'number',
      speechType: 'string',
      text: 'string',
      voice: 'string',
      volume: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TestSpeechResponseBody extends $tea.Model {
  code?: string;
  data?: TestSpeechResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: TestSpeechResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TestSpeechResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: TestSpeechResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: TestSpeechResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TriggerSceneRuleRequest extends $tea.Model {
  instanceId?: string;
  iotInstanceId?: string;
  ruleId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
      ruleId: 'RuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      iotInstanceId: 'string',
      ruleId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TriggerSceneRuleResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TriggerSceneRuleResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: TriggerSceneRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: TriggerSceneRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnbindApplicationFromEdgeInstanceRequest extends $tea.Model {
  applicationId?: string;
  instanceId?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      applicationId: 'ApplicationId',
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applicationId: 'string',
      instanceId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnbindApplicationFromEdgeInstanceResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnbindApplicationFromEdgeInstanceResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: UnbindApplicationFromEdgeInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: UnbindApplicationFromEdgeInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnbindDriverFromEdgeInstanceRequest extends $tea.Model {
  driverId?: string;
  instanceId?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      driverId: 'DriverId',
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      driverId: 'string',
      instanceId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnbindDriverFromEdgeInstanceResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnbindDriverFromEdgeInstanceResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: UnbindDriverFromEdgeInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: UnbindDriverFromEdgeInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnbindRoleFromEdgeInstanceRequest extends $tea.Model {
  instanceId?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnbindRoleFromEdgeInstanceResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnbindRoleFromEdgeInstanceResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: UnbindRoleFromEdgeInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: UnbindRoleFromEdgeInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnbindSceneRuleFromEdgeInstanceRequest extends $tea.Model {
  instanceId?: string;
  iotInstanceId?: string;
  ruleId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
      ruleId: 'RuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      iotInstanceId: 'string',
      ruleId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnbindSceneRuleFromEdgeInstanceResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnbindSceneRuleFromEdgeInstanceResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: UnbindSceneRuleFromEdgeInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: UnbindSceneRuleFromEdgeInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateConsumerGroupRequest extends $tea.Model {
  groupId?: string;
  iotInstanceId?: string;
  newGroupName?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      iotInstanceId: 'IotInstanceId',
      newGroupName: 'NewGroupName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      iotInstanceId: 'string',
      newGroupName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateConsumerGroupResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateConsumerGroupResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: UpdateConsumerGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: UpdateConsumerGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDeviceGroupRequest extends $tea.Model {
  groupDesc?: string;
  groupId?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      groupDesc: 'GroupDesc',
      groupId: 'GroupId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupDesc: 'string',
      groupId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDeviceGroupResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDeviceGroupResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: UpdateDeviceGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: UpdateDeviceGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDeviceShadowRequest extends $tea.Model {
  deltaUpdate?: boolean;
  deviceName?: string;
  iotInstanceId?: string;
  productKey?: string;
  shadowMessage?: string;
  static names(): { [key: string]: string } {
    return {
      deltaUpdate: 'DeltaUpdate',
      deviceName: 'DeviceName',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
      shadowMessage: 'ShadowMessage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deltaUpdate: 'boolean',
      deviceName: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
      shadowMessage: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDeviceShadowResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDeviceShadowResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: UpdateDeviceShadowResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: UpdateDeviceShadowResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateEdgeDriverVersionRequest extends $tea.Model {
  argument?: string;
  configCheckRule?: string;
  containerConfig?: string;
  description?: string;
  driverConfig?: string;
  driverId?: string;
  driverVersion?: string;
  edgeVersion?: string;
  iotInstanceId?: string;
  sourceConfig?: string;
  static names(): { [key: string]: string } {
    return {
      argument: 'Argument',
      configCheckRule: 'ConfigCheckRule',
      containerConfig: 'ContainerConfig',
      description: 'Description',
      driverConfig: 'DriverConfig',
      driverId: 'DriverId',
      driverVersion: 'DriverVersion',
      edgeVersion: 'EdgeVersion',
      iotInstanceId: 'IotInstanceId',
      sourceConfig: 'SourceConfig',
    };
  }

  static types(): { [key: string]: any } {
    return {
      argument: 'string',
      configCheckRule: 'string',
      containerConfig: 'string',
      description: 'string',
      driverConfig: 'string',
      driverId: 'string',
      driverVersion: 'string',
      edgeVersion: 'string',
      iotInstanceId: 'string',
      sourceConfig: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateEdgeDriverVersionResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateEdgeDriverVersionResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: UpdateEdgeDriverVersionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: UpdateEdgeDriverVersionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateEdgeInstanceRequest extends $tea.Model {
  bizEnable?: boolean;
  instanceId?: string;
  iotInstanceId?: string;
  name?: string;
  spec?: number;
  tags?: string;
  static names(): { [key: string]: string } {
    return {
      bizEnable: 'BizEnable',
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
      name: 'Name',
      spec: 'Spec',
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizEnable: 'boolean',
      instanceId: 'string',
      iotInstanceId: 'string',
      name: 'string',
      spec: 'number',
      tags: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateEdgeInstanceResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateEdgeInstanceResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: UpdateEdgeInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: UpdateEdgeInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateEdgeInstanceChannelRequest extends $tea.Model {
  channelId?: string;
  channelName?: string;
  configs?: UpdateEdgeInstanceChannelRequestConfigs[];
  driverId?: string;
  instanceId?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      channelId: 'ChannelId',
      channelName: 'ChannelName',
      configs: 'Configs',
      driverId: 'DriverId',
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelId: 'string',
      channelName: 'string',
      configs: { 'type': 'array', 'itemType': UpdateEdgeInstanceChannelRequestConfigs },
      driverId: 'string',
      instanceId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateEdgeInstanceChannelResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateEdgeInstanceChannelResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: UpdateEdgeInstanceChannelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: UpdateEdgeInstanceChannelResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateEdgeInstanceMessageRoutingRequest extends $tea.Model {
  instanceId?: string;
  iotInstanceId?: string;
  name?: string;
  routeId?: number;
  sourceData?: string;
  sourceType?: string;
  targetData?: string;
  targetIotHubQos?: number;
  targetType?: string;
  topicFilter?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
      name: 'Name',
      routeId: 'RouteId',
      sourceData: 'SourceData',
      sourceType: 'SourceType',
      targetData: 'TargetData',
      targetIotHubQos: 'TargetIotHubQos',
      targetType: 'TargetType',
      topicFilter: 'TopicFilter',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      iotInstanceId: 'string',
      name: 'string',
      routeId: 'number',
      sourceData: 'string',
      sourceType: 'string',
      targetData: 'string',
      targetIotHubQos: 'number',
      targetType: 'string',
      topicFilter: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateEdgeInstanceMessageRoutingResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateEdgeInstanceMessageRoutingResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: UpdateEdgeInstanceMessageRoutingResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: UpdateEdgeInstanceMessageRoutingResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateJobRequest extends $tea.Model {
  description?: string;
  iotInstanceId?: string;
  jobId?: string;
  rolloutConfig?: string;
  timeoutConfig?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      iotInstanceId: 'IotInstanceId',
      jobId: 'JobId',
      rolloutConfig: 'RolloutConfig',
      timeoutConfig: 'TimeoutConfig',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      iotInstanceId: 'string',
      jobId: 'string',
      rolloutConfig: 'string',
      timeoutConfig: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateJobResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: UpdateJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: UpdateJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateOTAModuleRequest extends $tea.Model {
  aliasName?: string;
  desc?: string;
  iotInstanceId?: string;
  moduleName?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      aliasName: 'AliasName',
      desc: 'Desc',
      iotInstanceId: 'IotInstanceId',
      moduleName: 'ModuleName',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliasName: 'string',
      desc: 'string',
      iotInstanceId: 'string',
      moduleName: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateOTAModuleResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateOTAModuleResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: UpdateOTAModuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: UpdateOTAModuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProductRequest extends $tea.Model {
  description?: string;
  iotInstanceId?: string;
  productKey?: string;
  productName?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
      productName: 'ProductName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
      productName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProductResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProductResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: UpdateProductResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: UpdateProductResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProductFilterConfigRequest extends $tea.Model {
  iotInstanceId?: string;
  productKey?: string;
  propertyTimestampFilter?: boolean;
  propertyValueFilter?: boolean;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
      propertyTimestampFilter: 'PropertyTimestampFilter',
      propertyValueFilter: 'PropertyValueFilter',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      productKey: 'string',
      propertyTimestampFilter: 'boolean',
      propertyValueFilter: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProductFilterConfigResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProductFilterConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: UpdateProductFilterConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: UpdateProductFilterConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProductTagsRequest extends $tea.Model {
  iotInstanceId?: string;
  productKey?: string;
  productTag?: UpdateProductTagsRequestProductTag[];
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
      productTag: 'ProductTag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      productKey: 'string',
      productTag: { 'type': 'array', 'itemType': UpdateProductTagsRequestProductTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProductTagsResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  invalidProductTags?: UpdateProductTagsResponseBodyInvalidProductTags;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      invalidProductTags: 'InvalidProductTags',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      invalidProductTags: UpdateProductTagsResponseBodyInvalidProductTags,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProductTagsResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: UpdateProductTagsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: UpdateProductTagsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProductTopicRequest extends $tea.Model {
  desc?: string;
  iotInstanceId?: string;
  operation?: string;
  topicId?: string;
  topicShortName?: string;
  static names(): { [key: string]: string } {
    return {
      desc: 'Desc',
      iotInstanceId: 'IotInstanceId',
      operation: 'Operation',
      topicId: 'TopicId',
      topicShortName: 'TopicShortName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      desc: 'string',
      iotInstanceId: 'string',
      operation: 'string',
      topicId: 'string',
      topicShortName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProductTopicResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProductTopicResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: UpdateProductTopicResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: UpdateProductTopicResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRuleRequest extends $tea.Model {
  iotInstanceId?: string;
  name?: string;
  productKey?: string;
  ruleDesc?: string;
  ruleId?: number;
  select?: string;
  shortTopic?: string;
  topic?: string;
  topicType?: number;
  where?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      name: 'Name',
      productKey: 'ProductKey',
      ruleDesc: 'RuleDesc',
      ruleId: 'RuleId',
      select: 'Select',
      shortTopic: 'ShortTopic',
      topic: 'Topic',
      topicType: 'TopicType',
      where: 'Where',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      name: 'string',
      productKey: 'string',
      ruleDesc: 'string',
      ruleId: 'number',
      select: 'string',
      shortTopic: 'string',
      topic: 'string',
      topicType: 'number',
      where: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRuleResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRuleResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: UpdateRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: UpdateRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRuleActionRequest extends $tea.Model {
  actionId?: number;
  configuration?: string;
  iotInstanceId?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      actionId: 'ActionId',
      configuration: 'Configuration',
      iotInstanceId: 'IotInstanceId',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actionId: 'number',
      configuration: 'string',
      iotInstanceId: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRuleActionResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRuleActionResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: UpdateRuleActionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: UpdateRuleActionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSceneRuleRequest extends $tea.Model {
  iotInstanceId?: string;
  ruleContent?: string;
  ruleDescription?: string;
  ruleId?: string;
  ruleName?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      ruleContent: 'RuleContent',
      ruleDescription: 'RuleDescription',
      ruleId: 'RuleId',
      ruleName: 'RuleName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      ruleContent: 'string',
      ruleDescription: 'string',
      ruleId: 'string',
      ruleName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSceneRuleResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSceneRuleResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: UpdateSceneRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: UpdateSceneRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSpeechRequest extends $tea.Model {
  iotInstanceId?: string;
  projectCode?: string;
  speechCode?: string;
  speechRate?: number;
  voice?: string;
  volume?: number;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      projectCode: 'ProjectCode',
      speechCode: 'SpeechCode',
      speechRate: 'SpeechRate',
      voice: 'Voice',
      volume: 'Volume',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      projectCode: 'string',
      speechCode: 'string',
      speechRate: 'number',
      voice: 'string',
      volume: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSpeechResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSpeechResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: UpdateSpeechResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: UpdateSpeechResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSubscribeRelationRequest extends $tea.Model {
  consumerGroupIds?: string[];
  deviceDataFlag?: boolean;
  deviceLifeCycleFlag?: boolean;
  deviceStatusChangeFlag?: boolean;
  deviceTagFlag?: boolean;
  deviceTopoLifeCycleFlag?: boolean;
  foundDeviceListFlag?: boolean;
  iotInstanceId?: string;
  mnsConfiguration?: string;
  otaEventFlag?: boolean;
  otaJobFlag?: boolean;
  otaVersionFlag?: boolean;
  productKey?: string;
  thingHistoryFlag?: boolean;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      consumerGroupIds: 'ConsumerGroupIds',
      deviceDataFlag: 'DeviceDataFlag',
      deviceLifeCycleFlag: 'DeviceLifeCycleFlag',
      deviceStatusChangeFlag: 'DeviceStatusChangeFlag',
      deviceTagFlag: 'DeviceTagFlag',
      deviceTopoLifeCycleFlag: 'DeviceTopoLifeCycleFlag',
      foundDeviceListFlag: 'FoundDeviceListFlag',
      iotInstanceId: 'IotInstanceId',
      mnsConfiguration: 'MnsConfiguration',
      otaEventFlag: 'OtaEventFlag',
      otaJobFlag: 'OtaJobFlag',
      otaVersionFlag: 'OtaVersionFlag',
      productKey: 'ProductKey',
      thingHistoryFlag: 'ThingHistoryFlag',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consumerGroupIds: { 'type': 'array', 'itemType': 'string' },
      deviceDataFlag: 'boolean',
      deviceLifeCycleFlag: 'boolean',
      deviceStatusChangeFlag: 'boolean',
      deviceTagFlag: 'boolean',
      deviceTopoLifeCycleFlag: 'boolean',
      foundDeviceListFlag: 'boolean',
      iotInstanceId: 'string',
      mnsConfiguration: 'string',
      otaEventFlag: 'boolean',
      otaJobFlag: 'boolean',
      otaVersionFlag: 'boolean',
      productKey: 'string',
      thingHistoryFlag: 'boolean',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSubscribeRelationResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSubscribeRelationResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: UpdateSubscribeRelationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: UpdateSubscribeRelationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateThingModelRequest extends $tea.Model {
  functionBlockId?: string;
  functionBlockName?: string;
  identifier?: string;
  iotInstanceId?: string;
  productKey?: string;
  thingModelJson?: string;
  static names(): { [key: string]: string } {
    return {
      functionBlockId: 'FunctionBlockId',
      functionBlockName: 'FunctionBlockName',
      identifier: 'Identifier',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
      thingModelJson: 'ThingModelJson',
    };
  }

  static types(): { [key: string]: any } {
    return {
      functionBlockId: 'string',
      functionBlockName: 'string',
      identifier: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
      thingModelJson: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateThingModelResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateThingModelResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: UpdateThingModelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: UpdateThingModelResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateThingModelValidationConfigRequest extends $tea.Model {
  iotInstanceId?: string;
  productKey?: string;
  validateType?: number;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
      validateType: 'ValidateType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      productKey: 'string',
      validateType: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateThingModelValidationConfigResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateThingModelValidationConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: UpdateThingModelValidationConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: UpdateThingModelValidationConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateThingScriptRequest extends $tea.Model {
  iotInstanceId?: string;
  productKey?: string;
  scriptContent?: string;
  scriptType?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
      scriptContent: 'ScriptContent',
      scriptType: 'ScriptType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      productKey: 'string',
      scriptContent: 'string',
      scriptType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateThingScriptResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateThingScriptResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: UpdateThingScriptResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: UpdateThingScriptResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchAddDeviceGroupRelationsRequestDevice extends $tea.Model {
  deviceName?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchAddThingTopoRequestTopoAddItem extends $tea.Model {
  clientId?: string;
  deviceName?: string;
  productKey?: string;
  sign?: string;
  signMethod?: string;
  timestamp?: string;
  static names(): { [key: string]: string } {
    return {
      clientId: 'ClientId',
      deviceName: 'DeviceName',
      productKey: 'ProductKey',
      sign: 'Sign',
      signMethod: 'SignMethod',
      timestamp: 'Timestamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clientId: 'string',
      deviceName: 'string',
      productKey: 'string',
      sign: 'string',
      signMethod: 'string',
      timestamp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchBindDevicesIntoProjectRequestDevices extends $tea.Model {
  deviceName?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCheckDeviceNamesRequestDeviceNameList extends $tea.Model {
  deviceName?: string;
  deviceNickname?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      deviceNickname: 'DeviceNickname',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      deviceNickname: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCheckDeviceNamesResponseBodyDataInvalidDeviceNameList extends $tea.Model {
  invalidDeviceName?: string[];
  static names(): { [key: string]: string } {
    return {
      invalidDeviceName: 'InvalidDeviceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      invalidDeviceName: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCheckDeviceNamesResponseBodyDataInvalidDeviceNicknameList extends $tea.Model {
  invalidDeviceNickname?: string[];
  static names(): { [key: string]: string } {
    return {
      invalidDeviceNickname: 'InvalidDeviceNickname',
    };
  }

  static types(): { [key: string]: any } {
    return {
      invalidDeviceNickname: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCheckDeviceNamesResponseBodyData extends $tea.Model {
  applyId?: number;
  invalidDeviceNameList?: BatchCheckDeviceNamesResponseBodyDataInvalidDeviceNameList;
  invalidDeviceNicknameList?: BatchCheckDeviceNamesResponseBodyDataInvalidDeviceNicknameList;
  static names(): { [key: string]: string } {
    return {
      applyId: 'ApplyId',
      invalidDeviceNameList: 'InvalidDeviceNameList',
      invalidDeviceNicknameList: 'InvalidDeviceNicknameList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applyId: 'number',
      invalidDeviceNameList: BatchCheckDeviceNamesResponseBodyDataInvalidDeviceNameList,
      invalidDeviceNicknameList: BatchCheckDeviceNamesResponseBodyDataInvalidDeviceNicknameList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchDeleteDeviceGroupRelationsRequestDevice extends $tea.Model {
  deviceName?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetDeviceBindStatusResponseBodyData extends $tea.Model {
  bindStatus?: number;
  iotId?: string;
  static names(): { [key: string]: string } {
    return {
      bindStatus: 'BindStatus',
      iotId: 'IotId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bindStatus: 'number',
      iotId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetDeviceStateResponseBodyDeviceStatusListDeviceStatus extends $tea.Model {
  asAddress?: string;
  deviceId?: string;
  deviceName?: string;
  iotId?: string;
  lastOnlineTime?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      asAddress: 'AsAddress',
      deviceId: 'DeviceId',
      deviceName: 'DeviceName',
      iotId: 'IotId',
      lastOnlineTime: 'LastOnlineTime',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      asAddress: 'string',
      deviceId: 'string',
      deviceName: 'string',
      iotId: 'string',
      lastOnlineTime: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetDeviceStateResponseBodyDeviceStatusList extends $tea.Model {
  deviceStatus?: BatchGetDeviceStateResponseBodyDeviceStatusListDeviceStatus[];
  static names(): { [key: string]: string } {
    return {
      deviceStatus: 'DeviceStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceStatus: { 'type': 'array', 'itemType': BatchGetDeviceStateResponseBodyDeviceStatusListDeviceStatus },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeDriverResponseBodyDriverList extends $tea.Model {
  cpuArch?: string;
  driverId?: string;
  driverName?: string;
  driverProtocol?: string;
  gmtCreateTimestamp?: number;
  gmtModifiedTimestamp?: number;
  isBuiltIn?: boolean;
  runtime?: string;
  type?: number;
  static names(): { [key: string]: string } {
    return {
      cpuArch: 'CpuArch',
      driverId: 'DriverId',
      driverName: 'DriverName',
      driverProtocol: 'DriverProtocol',
      gmtCreateTimestamp: 'GmtCreateTimestamp',
      gmtModifiedTimestamp: 'GmtModifiedTimestamp',
      isBuiltIn: 'IsBuiltIn',
      runtime: 'Runtime',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cpuArch: 'string',
      driverId: 'string',
      driverName: 'string',
      driverProtocol: 'string',
      gmtCreateTimestamp: 'number',
      gmtModifiedTimestamp: 'number',
      isBuiltIn: 'boolean',
      runtime: 'string',
      type: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeInstanceChannelResponseBodyDataChannelConfigListConfig extends $tea.Model {
  configId?: string;
  content?: string;
  format?: string;
  key?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      content: 'Content',
      format: 'Format',
      key: 'Key',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'string',
      content: 'string',
      format: 'string',
      key: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeInstanceChannelResponseBodyDataChannelConfigList extends $tea.Model {
  config?: BatchGetEdgeInstanceChannelResponseBodyDataChannelConfigListConfig[];
  static names(): { [key: string]: string } {
    return {
      config: 'Config',
    };
  }

  static types(): { [key: string]: any } {
    return {
      config: { 'type': 'array', 'itemType': BatchGetEdgeInstanceChannelResponseBodyDataChannelConfigListConfig },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeInstanceChannelResponseBodyDataChannel extends $tea.Model {
  channelId?: string;
  channelName?: string;
  configList?: BatchGetEdgeInstanceChannelResponseBodyDataChannelConfigList;
  static names(): { [key: string]: string } {
    return {
      channelId: 'ChannelId',
      channelName: 'ChannelName',
      configList: 'ConfigList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelId: 'string',
      channelName: 'string',
      configList: BatchGetEdgeInstanceChannelResponseBodyDataChannelConfigList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeInstanceChannelResponseBodyData extends $tea.Model {
  channel?: BatchGetEdgeInstanceChannelResponseBodyDataChannel[];
  static names(): { [key: string]: string } {
    return {
      channel: 'Channel',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channel: { 'type': 'array', 'itemType': BatchGetEdgeInstanceChannelResponseBodyDataChannel },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeInstanceDeviceChannelResponseBodyDeviceChannelList extends $tea.Model {
  channelId?: string;
  channelName?: string;
  iotId?: string;
  static names(): { [key: string]: string } {
    return {
      channelId: 'ChannelId',
      channelName: 'ChannelName',
      iotId: 'IotId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelId: 'string',
      channelName: 'string',
      iotId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeInstanceDeviceConfigResponseBodyDeviceConfigListConfig extends $tea.Model {
  content?: string;
  format?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      format: 'Format',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      format: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeInstanceDeviceConfigResponseBodyDeviceConfigList extends $tea.Model {
  config?: BatchGetEdgeInstanceDeviceConfigResponseBodyDeviceConfigListConfig;
  iotId?: string;
  static names(): { [key: string]: string } {
    return {
      config: 'Config',
      iotId: 'IotId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      config: BatchGetEdgeInstanceDeviceConfigResponseBodyDeviceConfigListConfig,
      iotId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeInstanceDeviceDriverResponseBodyDeviceDriverList extends $tea.Model {
  driverId?: string;
  iotId?: string;
  static names(): { [key: string]: string } {
    return {
      driverId: 'DriverId',
      iotId: 'IotId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      driverId: 'string',
      iotId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigListConfigList extends $tea.Model {
  configId?: string;
  content?: string;
  format?: string;
  key?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      content: 'Content',
      format: 'Format',
      key: 'Key',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'string',
      content: 'string',
      format: 'string',
      key: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigList extends $tea.Model {
  configList?: BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigListConfigList[];
  driverId?: string;
  static names(): { [key: string]: string } {
    return {
      configList: 'ConfigList',
      driverId: 'DriverId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configList: { 'type': 'array', 'itemType': BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigListConfigList },
      driverId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchQueryDeviceDetailResponseBodyDataData extends $tea.Model {
  deviceName?: string;
  deviceSecret?: string;
  firmwareVersion?: string;
  gmtActive?: string;
  gmtCreate?: string;
  iotId?: string;
  nickname?: string;
  nodeType?: number;
  productKey?: string;
  productName?: string;
  region?: string;
  status?: string;
  utcActive?: string;
  utcCreate?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      deviceSecret: 'DeviceSecret',
      firmwareVersion: 'FirmwareVersion',
      gmtActive: 'GmtActive',
      gmtCreate: 'GmtCreate',
      iotId: 'IotId',
      nickname: 'Nickname',
      nodeType: 'NodeType',
      productKey: 'ProductKey',
      productName: 'ProductName',
      region: 'Region',
      status: 'Status',
      utcActive: 'UtcActive',
      utcCreate: 'UtcCreate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      deviceSecret: 'string',
      firmwareVersion: 'string',
      gmtActive: 'string',
      gmtCreate: 'string',
      iotId: 'string',
      nickname: 'string',
      nodeType: 'number',
      productKey: 'string',
      productName: 'string',
      region: 'string',
      status: 'string',
      utcActive: 'string',
      utcCreate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchQueryDeviceDetailResponseBodyData extends $tea.Model {
  data?: BatchQueryDeviceDetailResponseBodyDataData[];
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': BatchQueryDeviceDetailResponseBodyDataData },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchRegisterDeviceResponseBodyData extends $tea.Model {
  applyId?: number;
  static names(): { [key: string]: string } {
    return {
      applyId: 'ApplyId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applyId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchRegisterDeviceWithApplyIdResponseBodyData extends $tea.Model {
  applyId?: number;
  static names(): { [key: string]: string } {
    return {
      applyId: 'ApplyId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applyId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchSetEdgeInstanceDeviceConfigRequestDeviceConfigs extends $tea.Model {
  content?: string;
  iotId?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      iotId: 'IotId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      iotId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchUnbindProjectDevicesRequestDevices extends $tea.Model {
  deviceName?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchUpdateDeviceNicknameRequestDeviceNicknameInfo extends $tea.Model {
  deviceName?: string;
  iotId?: string;
  nickname?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      nickname: 'Nickname',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      nickname: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataAPIServiceRequestRequestParam extends $tea.Model {
  desc?: string;
  example?: string;
  name?: string;
  required?: boolean;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      desc: 'Desc',
      example: 'Example',
      name: 'Name',
      required: 'Required',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      desc: 'string',
      example: 'string',
      name: 'string',
      required: 'boolean',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataAPIServiceRequestResponseParam extends $tea.Model {
  desc?: string;
  example?: string;
  name?: string;
  required?: boolean;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      desc: 'Desc',
      example: 'Example',
      name: 'Name',
      required: 'Required',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      desc: 'string',
      example: 'string',
      name: 'string',
      required: 'boolean',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataAPIServiceResponseBodyData extends $tea.Model {
  apiSrn?: string;
  createTime?: number;
  lastUpdateTime?: number;
  static names(): { [key: string]: string } {
    return {
      apiSrn: 'ApiSrn',
      createTime: 'CreateTime',
      lastUpdateTime: 'LastUpdateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiSrn: 'string',
      createTime: 'number',
      lastUpdateTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDeviceDistributeJobRequestTargetInstanceConfig extends $tea.Model {
  targetInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      targetInstanceId: 'TargetInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      targetInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDeviceGroupResponseBodyData extends $tea.Model {
  groupDesc?: string;
  groupId?: string;
  groupName?: string;
  utcCreate?: string;
  static names(): { [key: string]: string } {
    return {
      groupDesc: 'GroupDesc',
      groupId: 'GroupId',
      groupName: 'GroupName',
      utcCreate: 'UtcCreate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupDesc: 'string',
      groupId: 'string',
      groupName: 'string',
      utcCreate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeInstanceChannelRequestConfigs extends $tea.Model {
  content?: string;
  format?: string;
  key?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      format: 'Format',
      key: 'Key',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      format: 'string',
      key: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeOssPreSignedAddressResponseBodyData extends $tea.Model {
  ossAddress?: string;
  ossPreSignedAddress?: string;
  static names(): { [key: string]: string } {
    return {
      ossAddress: 'OssAddress',
      ossPreSignedAddress: 'OssPreSignedAddress',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ossAddress: 'string',
      ossPreSignedAddress: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLoRaNodesTaskRequestDeviceInfo extends $tea.Model {
  devEui?: string;
  pinCode?: string;
  static names(): { [key: string]: string } {
    return {
      devEui: 'DevEui',
      pinCode: 'PinCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      devEui: 'string',
      pinCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOTADynamicUpgradeJobRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOTADynamicUpgradeJobResponseBodyData extends $tea.Model {
  jobId?: string;
  utcCreate?: string;
  static names(): { [key: string]: string } {
    return {
      jobId: 'JobId',
      utcCreate: 'UtcCreate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      jobId: 'string',
      utcCreate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOTAFirmwareResponseBodyData extends $tea.Model {
  firmwareId?: string;
  utcCreate?: string;
  static names(): { [key: string]: string } {
    return {
      firmwareId: 'FirmwareId',
      utcCreate: 'UtcCreate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      firmwareId: 'string',
      utcCreate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOTAStaticUpgradeJobRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOTAStaticUpgradeJobResponseBodyData extends $tea.Model {
  jobId?: string;
  utcCreate?: string;
  static names(): { [key: string]: string } {
    return {
      jobId: 'JobId',
      utcCreate: 'UtcCreate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      jobId: 'string',
      utcCreate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOTAVerifyJobResponseBodyData extends $tea.Model {
  jobId?: string;
  utcCreate?: string;
  static names(): { [key: string]: string } {
    return {
      jobId: 'JobId',
      utcCreate: 'UtcCreate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      jobId: 'string',
      utcCreate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProductResponseBodyData extends $tea.Model {
  aliyunCommodityCode?: string;
  authType?: string;
  dataFormat?: number;
  description?: string;
  id2?: boolean;
  nodeType?: number;
  productKey?: string;
  productName?: string;
  productSecret?: string;
  protocolType?: string;
  static names(): { [key: string]: string } {
    return {
      aliyunCommodityCode: 'AliyunCommodityCode',
      authType: 'AuthType',
      dataFormat: 'DataFormat',
      description: 'Description',
      id2: 'Id2',
      nodeType: 'NodeType',
      productKey: 'ProductKey',
      productName: 'ProductName',
      productSecret: 'ProductSecret',
      protocolType: 'ProtocolType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunCommodityCode: 'string',
      authType: 'string',
      dataFormat: 'number',
      description: 'string',
      id2: 'boolean',
      nodeType: 'number',
      productKey: 'string',
      productName: 'string',
      productSecret: 'string',
      protocolType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProductTagsRequestProductTag extends $tea.Model {
  tagKey?: string;
  tagValue?: string;
  static names(): { [key: string]: string } {
    return {
      tagKey: 'TagKey',
      tagValue: 'TagValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagKey: 'string',
      tagValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProductTagsResponseBodyInvalidProductTagsProductTag extends $tea.Model {
  tagKey?: string;
  tagValue?: string;
  static names(): { [key: string]: string } {
    return {
      tagKey: 'TagKey',
      tagValue: 'TagValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagKey: 'string',
      tagValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProductTagsResponseBodyInvalidProductTags extends $tea.Model {
  productTag?: CreateProductTagsResponseBodyInvalidProductTagsProductTag[];
  static names(): { [key: string]: string } {
    return {
      productTag: 'ProductTag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      productTag: { 'type': 'array', 'itemType': CreateProductTagsResponseBodyInvalidProductTagsProductTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateStudioAppDomainOpenResponseBodyData extends $tea.Model {
  appId?: string;
  host?: string;
  id?: number;
  isBeian?: string;
  projectId?: string;
  protocol?: string;
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      host: 'Host',
      id: 'Id',
      isBeian: 'IsBeian',
      projectId: 'ProjectId',
      protocol: 'Protocol',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      host: 'string',
      id: 'number',
      isBeian: 'string',
      projectId: 'string',
      protocol: 'string',
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTopicRouteTableResponseBodyFailureTopics extends $tea.Model {
  topic?: { [key: string]: string }[];
  static names(): { [key: string]: string } {
    return {
      topic: 'Topic',
    };
  }

  static types(): { [key: string]: any } {
    return {
      topic: { 'type': 'array', 'itemType': { 'type': 'map', 'keyType': 'string', 'valueType': 'string' } },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTopicRouteTableResponseBodyFailureTopics extends $tea.Model {
  topic?: { [key: string]: string }[];
  static names(): { [key: string]: string } {
    return {
      topic: 'Topic',
    };
  }

  static types(): { [key: string]: any } {
    return {
      topic: { 'type': 'array', 'itemType': { 'type': 'map', 'keyType': 'string', 'valueType': 'string' } },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GenerateDeviceNameListURLResponseBodyData extends $tea.Model {
  accessKeyId?: string;
  fileUrl?: string;
  host?: string;
  key?: string;
  objectStorage?: string;
  policy?: string;
  signature?: string;
  utcCreate?: string;
  static names(): { [key: string]: string } {
    return {
      accessKeyId: 'AccessKeyId',
      fileUrl: 'FileUrl',
      host: 'Host',
      key: 'Key',
      objectStorage: 'ObjectStorage',
      policy: 'Policy',
      signature: 'Signature',
      utcCreate: 'UtcCreate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessKeyId: 'string',
      fileUrl: 'string',
      host: 'string',
      key: 'string',
      objectStorage: 'string',
      policy: 'string',
      signature: 'string',
      utcCreate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GenerateFileUploadURLResponseBodyData extends $tea.Model {
  host?: string;
  key?: string;
  objectStorage?: string;
  ossAccessKeyId?: string;
  policy?: string;
  signature?: string;
  static names(): { [key: string]: string } {
    return {
      host: 'Host',
      key: 'Key',
      objectStorage: 'ObjectStorage',
      ossAccessKeyId: 'OssAccessKeyId',
      policy: 'Policy',
      signature: 'Signature',
    };
  }

  static types(): { [key: string]: any } {
    return {
      host: 'string',
      key: 'string',
      objectStorage: 'string',
      ossAccessKeyId: 'string',
      policy: 'string',
      signature: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GenerateOTAUploadURLResponseBodyData extends $tea.Model {
  firmwareUrl?: string;
  host?: string;
  key?: string;
  OSSAccessKeyId?: string;
  objectStorage?: string;
  policy?: string;
  signature?: string;
  utcCreate?: string;
  static names(): { [key: string]: string } {
    return {
      firmwareUrl: 'FirmwareUrl',
      host: 'Host',
      key: 'Key',
      OSSAccessKeyId: 'OSSAccessKeyId',
      objectStorage: 'ObjectStorage',
      policy: 'Policy',
      signature: 'Signature',
      utcCreate: 'UtcCreate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      firmwareUrl: 'string',
      host: 'string',
      key: 'string',
      OSSAccessKeyId: 'string',
      objectStorage: 'string',
      policy: 'string',
      signature: 'string',
      utcCreate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParamsRequestParams extends $tea.Model {
  desc?: string;
  example?: string;
  name?: string;
  required?: boolean;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      desc: 'Desc',
      example: 'Example',
      name: 'Name',
      required: 'Required',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      desc: 'string',
      example: 'string',
      name: 'string',
      required: 'boolean',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParams extends $tea.Model {
  requestParams?: GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParamsRequestParams[];
  static names(): { [key: string]: string } {
    return {
      requestParams: 'RequestParams',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestParams: { 'type': 'array', 'itemType': GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParamsRequestParams },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParamsResponseParams extends $tea.Model {
  desc?: string;
  example?: string;
  name?: string;
  required?: boolean;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      desc: 'Desc',
      example: 'Example',
      name: 'Name',
      required: 'Required',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      desc: 'string',
      example: 'string',
      name: 'string',
      required: 'boolean',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParams extends $tea.Model {
  responseParams?: GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParamsResponseParams[];
  static names(): { [key: string]: string } {
    return {
      responseParams: 'ResponseParams',
    };
  }

  static types(): { [key: string]: any } {
    return {
      responseParams: { 'type': 'array', 'itemType': GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParamsResponseParams },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTO extends $tea.Model {
  originSql?: string;
  requestParams?: GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParams;
  responseParams?: GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParams;
  templateSql?: string;
  static names(): { [key: string]: string } {
    return {
      originSql: 'OriginSql',
      requestParams: 'RequestParams',
      responseParams: 'ResponseParams',
      templateSql: 'TemplateSql',
    };
  }

  static types(): { [key: string]: any } {
    return {
      originSql: 'string',
      requestParams: GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParams,
      responseParams: GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParams,
      templateSql: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataAPIServiceDetailResponseBodyData extends $tea.Model {
  apiPath?: string;
  apiSrn?: string;
  createTime?: number;
  dateFormat?: string;
  description?: string;
  displayName?: string;
  lastUpdateTime?: number;
  requestMethod?: string;
  requestProtocol?: string;
  sqlTemplateDTO?: GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTO;
  status?: number;
  static names(): { [key: string]: string } {
    return {
      apiPath: 'ApiPath',
      apiSrn: 'ApiSrn',
      createTime: 'CreateTime',
      dateFormat: 'DateFormat',
      description: 'Description',
      displayName: 'DisplayName',
      lastUpdateTime: 'LastUpdateTime',
      requestMethod: 'RequestMethod',
      requestProtocol: 'RequestProtocol',
      sqlTemplateDTO: 'SqlTemplateDTO',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiPath: 'string',
      apiSrn: 'string',
      createTime: 'number',
      dateFormat: 'string',
      description: 'string',
      displayName: 'string',
      lastUpdateTime: 'number',
      requestMethod: 'string',
      requestProtocol: 'string',
      sqlTemplateDTO: GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTO,
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDeviceStatusResponseBodyData extends $tea.Model {
  status?: string;
  timestamp?: number;
  static names(): { [key: string]: string } {
    return {
      status: 'Status',
      timestamp: 'Timestamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      status: 'string',
      timestamp: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDeviceTunnelShareStatusResponseBodyData extends $tea.Model {
  gmtOpened?: number;
  isOpen?: boolean;
  password?: string;
  shareId?: string;
  static names(): { [key: string]: string } {
    return {
      gmtOpened: 'GmtOpened',
      isOpen: 'IsOpen',
      password: 'Password',
      shareId: 'ShareId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gmtOpened: 'number',
      isOpen: 'boolean',
      password: 'string',
      shareId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeDriverVersionResponseBodyData extends $tea.Model {
  argument?: string;
  configCheckRule?: string;
  containerConfig?: string;
  description?: string;
  driverConfig?: string;
  driverId?: string;
  driverVersion?: string;
  edgeVersion?: string;
  gmtCreateTimestamp?: number;
  gmtModifiedTimestamp?: number;
  sourceConfig?: string;
  versionState?: string;
  static names(): { [key: string]: string } {
    return {
      argument: 'Argument',
      configCheckRule: 'ConfigCheckRule',
      containerConfig: 'ContainerConfig',
      description: 'Description',
      driverConfig: 'DriverConfig',
      driverId: 'DriverId',
      driverVersion: 'DriverVersion',
      edgeVersion: 'EdgeVersion',
      gmtCreateTimestamp: 'GmtCreateTimestamp',
      gmtModifiedTimestamp: 'GmtModifiedTimestamp',
      sourceConfig: 'SourceConfig',
      versionState: 'VersionState',
    };
  }

  static types(): { [key: string]: any } {
    return {
      argument: 'string',
      configCheckRule: 'string',
      containerConfig: 'string',
      description: 'string',
      driverConfig: 'string',
      driverId: 'string',
      driverVersion: 'string',
      edgeVersion: 'string',
      gmtCreateTimestamp: 'number',
      gmtModifiedTimestamp: 'number',
      sourceConfig: 'string',
      versionState: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeInstanceResponseBodyData extends $tea.Model {
  bizEnable?: boolean;
  gmtCreate?: string;
  gmtCreateTimestamp?: number;
  gmtModified?: string;
  gmtModifiedTimestamp?: number;
  instanceId?: string;
  latestDeploymentStatus?: number;
  latestDeploymentType?: string;
  name?: string;
  roleArn?: string;
  roleAttachTime?: string;
  roleAttachTimestamp?: number;
  roleName?: string;
  spec?: number;
  tags?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      bizEnable: 'BizEnable',
      gmtCreate: 'GmtCreate',
      gmtCreateTimestamp: 'GmtCreateTimestamp',
      gmtModified: 'GmtModified',
      gmtModifiedTimestamp: 'GmtModifiedTimestamp',
      instanceId: 'InstanceId',
      latestDeploymentStatus: 'LatestDeploymentStatus',
      latestDeploymentType: 'LatestDeploymentType',
      name: 'Name',
      roleArn: 'RoleArn',
      roleAttachTime: 'RoleAttachTime',
      roleAttachTimestamp: 'RoleAttachTimestamp',
      roleName: 'RoleName',
      spec: 'Spec',
      tags: 'Tags',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizEnable: 'boolean',
      gmtCreate: 'string',
      gmtCreateTimestamp: 'number',
      gmtModified: 'string',
      gmtModifiedTimestamp: 'number',
      instanceId: 'string',
      latestDeploymentStatus: 'number',
      latestDeploymentType: 'string',
      name: 'string',
      roleArn: 'string',
      roleAttachTime: 'string',
      roleAttachTimestamp: 'number',
      roleName: 'string',
      spec: 'number',
      tags: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeInstanceDeploymentResponseBodyDataTaskListResourceSnapshotList extends $tea.Model {
  gmtCompleted?: string;
  gmtCompletedTimestamp?: number;
  gmtCreate?: string;
  gmtCreateTimestamp?: number;
  gmtModified?: string;
  gmtModifiedTimestamp?: number;
  log?: string;
  operateType?: number;
  resourceId?: string;
  resourceName?: string;
  resourceType?: string;
  snapshotId?: string;
  stage?: number;
  status?: number;
  static names(): { [key: string]: string } {
    return {
      gmtCompleted: 'GmtCompleted',
      gmtCompletedTimestamp: 'GmtCompletedTimestamp',
      gmtCreate: 'GmtCreate',
      gmtCreateTimestamp: 'GmtCreateTimestamp',
      gmtModified: 'GmtModified',
      gmtModifiedTimestamp: 'GmtModifiedTimestamp',
      log: 'Log',
      operateType: 'OperateType',
      resourceId: 'ResourceId',
      resourceName: 'ResourceName',
      resourceType: 'ResourceType',
      snapshotId: 'SnapshotId',
      stage: 'Stage',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gmtCompleted: 'string',
      gmtCompletedTimestamp: 'number',
      gmtCreate: 'string',
      gmtCreateTimestamp: 'number',
      gmtModified: 'string',
      gmtModifiedTimestamp: 'number',
      log: 'string',
      operateType: 'number',
      resourceId: 'string',
      resourceName: 'string',
      resourceType: 'string',
      snapshotId: 'string',
      stage: 'number',
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeInstanceDeploymentResponseBodyDataTaskList extends $tea.Model {
  gatewayId?: string;
  gmtCompleted?: string;
  gmtCompletedTimestamp?: number;
  gmtCreate?: string;
  gmtCreateTimestamp?: number;
  gmtModified?: string;
  gmtModifiedTimestamp?: number;
  resourceSnapshotList?: GetEdgeInstanceDeploymentResponseBodyDataTaskListResourceSnapshotList[];
  stage?: number;
  status?: number;
  taskId?: string;
  static names(): { [key: string]: string } {
    return {
      gatewayId: 'GatewayId',
      gmtCompleted: 'GmtCompleted',
      gmtCompletedTimestamp: 'GmtCompletedTimestamp',
      gmtCreate: 'GmtCreate',
      gmtCreateTimestamp: 'GmtCreateTimestamp',
      gmtModified: 'GmtModified',
      gmtModifiedTimestamp: 'GmtModifiedTimestamp',
      resourceSnapshotList: 'ResourceSnapshotList',
      stage: 'Stage',
      status: 'Status',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gatewayId: 'string',
      gmtCompleted: 'string',
      gmtCompletedTimestamp: 'number',
      gmtCreate: 'string',
      gmtCreateTimestamp: 'number',
      gmtModified: 'string',
      gmtModifiedTimestamp: 'number',
      resourceSnapshotList: { 'type': 'array', 'itemType': GetEdgeInstanceDeploymentResponseBodyDataTaskListResourceSnapshotList },
      stage: 'number',
      status: 'number',
      taskId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeInstanceDeploymentResponseBodyData extends $tea.Model {
  deploymentId?: string;
  description?: string;
  gmtCompleted?: string;
  gmtCompletedTimestamp?: number;
  gmtCreate?: string;
  gmtCreateTimestamp?: number;
  gmtModified?: string;
  gmtModifiedTimestamp?: number;
  status?: number;
  taskList?: GetEdgeInstanceDeploymentResponseBodyDataTaskList[];
  type?: string;
  static names(): { [key: string]: string } {
    return {
      deploymentId: 'DeploymentId',
      description: 'Description',
      gmtCompleted: 'GmtCompleted',
      gmtCompletedTimestamp: 'GmtCompletedTimestamp',
      gmtCreate: 'GmtCreate',
      gmtCreateTimestamp: 'GmtCreateTimestamp',
      gmtModified: 'GmtModified',
      gmtModifiedTimestamp: 'GmtModifiedTimestamp',
      status: 'Status',
      taskList: 'TaskList',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deploymentId: 'string',
      description: 'string',
      gmtCompleted: 'string',
      gmtCompletedTimestamp: 'number',
      gmtCreate: 'string',
      gmtCreateTimestamp: 'number',
      gmtModified: 'string',
      gmtModifiedTimestamp: 'number',
      status: 'number',
      taskList: { 'type': 'array', 'itemType': GetEdgeInstanceDeploymentResponseBodyDataTaskList },
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeInstanceMessageRoutingResponseBodyDataRouteContext extends $tea.Model {
  qos?: string;
  sourceApplicationName?: string;
  sourceFcFunctionName?: string;
  sourceFcServiceName?: string;
  targetApplicationName?: string;
  targetFcFunctionName?: string;
  targetFcServiceName?: string;
  static names(): { [key: string]: string } {
    return {
      qos: 'Qos',
      sourceApplicationName: 'SourceApplicationName',
      sourceFcFunctionName: 'SourceFcFunctionName',
      sourceFcServiceName: 'SourceFcServiceName',
      targetApplicationName: 'TargetApplicationName',
      targetFcFunctionName: 'TargetFcFunctionName',
      targetFcServiceName: 'TargetFcServiceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      qos: 'string',
      sourceApplicationName: 'string',
      sourceFcFunctionName: 'string',
      sourceFcServiceName: 'string',
      targetApplicationName: 'string',
      targetFcFunctionName: 'string',
      targetFcServiceName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeInstanceMessageRoutingResponseBodyData extends $tea.Model {
  gmtCreate?: string;
  gmtCreateTimestamp?: number;
  gmtModified?: string;
  gmtModifiedTimestamp?: number;
  name?: string;
  routeContext?: GetEdgeInstanceMessageRoutingResponseBodyDataRouteContext;
  sourceData?: string;
  sourceType?: string;
  targetData?: string;
  targetType?: string;
  topicFilter?: string;
  static names(): { [key: string]: string } {
    return {
      gmtCreate: 'GmtCreate',
      gmtCreateTimestamp: 'GmtCreateTimestamp',
      gmtModified: 'GmtModified',
      gmtModifiedTimestamp: 'GmtModifiedTimestamp',
      name: 'Name',
      routeContext: 'RouteContext',
      sourceData: 'SourceData',
      sourceType: 'SourceType',
      targetData: 'TargetData',
      targetType: 'TargetType',
      topicFilter: 'TopicFilter',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gmtCreate: 'string',
      gmtCreateTimestamp: 'number',
      gmtModified: 'string',
      gmtModifiedTimestamp: 'number',
      name: 'string',
      routeContext: GetEdgeInstanceMessageRoutingResponseBodyDataRouteContext,
      sourceData: 'string',
      sourceType: 'string',
      targetData: 'string',
      targetType: 'string',
      topicFilter: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayBySubDeviceResponseBodyData extends $tea.Model {
  deviceName?: string;
  deviceSecret?: string;
  firmwareVersion?: string;
  gmtActive?: string;
  gmtCreate?: string;
  gmtOnline?: string;
  ipAddress?: string;
  nodeType?: string;
  productKey?: string;
  productName?: string;
  status?: string;
  utcActive?: string;
  utcCreate?: string;
  utcOnline?: string;
  iotId?: string;
  region?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      deviceSecret: 'DeviceSecret',
      firmwareVersion: 'FirmwareVersion',
      gmtActive: 'GmtActive',
      gmtCreate: 'GmtCreate',
      gmtOnline: 'GmtOnline',
      ipAddress: 'IpAddress',
      nodeType: 'NodeType',
      productKey: 'ProductKey',
      productName: 'ProductName',
      status: 'Status',
      utcActive: 'UtcActive',
      utcCreate: 'UtcCreate',
      utcOnline: 'UtcOnline',
      iotId: 'iotId',
      region: 'region',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      deviceSecret: 'string',
      firmwareVersion: 'string',
      gmtActive: 'string',
      gmtCreate: 'string',
      gmtOnline: 'string',
      ipAddress: 'string',
      nodeType: 'string',
      productKey: 'string',
      productName: 'string',
      status: 'string',
      utcActive: 'string',
      utcCreate: 'string',
      utcOnline: 'string',
      iotId: 'string',
      region: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetLoraNodesTaskResponseBodySuccessDevEuis extends $tea.Model {
  successDevEui?: string[];
  static names(): { [key: string]: string } {
    return {
      successDevEui: 'SuccessDevEui',
    };
  }

  static types(): { [key: string]: any } {
    return {
      successDevEui: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNodesAddingTaskResponseBodySuccessDevEuis extends $tea.Model {
  successDevEui?: string[];
  static names(): { [key: string]: string } {
    return {
      successDevEui: 'SuccessDevEui',
    };
  }

  static types(): { [key: string]: any } {
    return {
      successDevEui: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRuleResponseBodyRuleInfo extends $tea.Model {
  createUserId?: number;
  created?: string;
  dataType?: string;
  id?: number;
  modified?: string;
  name?: string;
  productKey?: string;
  ruleDesc?: string;
  select?: string;
  shortTopic?: string;
  status?: string;
  topic?: string;
  topicType?: number;
  utcCreated?: string;
  utcModified?: string;
  where?: string;
  static names(): { [key: string]: string } {
    return {
      createUserId: 'CreateUserId',
      created: 'Created',
      dataType: 'DataType',
      id: 'Id',
      modified: 'Modified',
      name: 'Name',
      productKey: 'ProductKey',
      ruleDesc: 'RuleDesc',
      select: 'Select',
      shortTopic: 'ShortTopic',
      status: 'Status',
      topic: 'Topic',
      topicType: 'TopicType',
      utcCreated: 'UtcCreated',
      utcModified: 'UtcModified',
      where: 'Where',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createUserId: 'number',
      created: 'string',
      dataType: 'string',
      id: 'number',
      modified: 'string',
      name: 'string',
      productKey: 'string',
      ruleDesc: 'string',
      select: 'string',
      shortTopic: 'string',
      status: 'string',
      topic: 'string',
      topicType: 'number',
      utcCreated: 'string',
      utcModified: 'string',
      where: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRuleActionResponseBodyRuleActionInfo extends $tea.Model {
  configuration?: string;
  errorActionFlag?: boolean;
  id?: number;
  ruleId?: number;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      configuration: 'Configuration',
      errorActionFlag: 'ErrorActionFlag',
      id: 'Id',
      ruleId: 'RuleId',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configuration: 'string',
      errorActionFlag: 'boolean',
      id: 'number',
      ruleId: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSceneRuleResponseBodyData extends $tea.Model {
  gmtCreate?: number;
  gmtModified?: number;
  ruleContent?: string;
  ruleDescription?: string;
  ruleName?: string;
  ruleStatus?: number;
  static names(): { [key: string]: string } {
    return {
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      ruleContent: 'RuleContent',
      ruleDescription: 'RuleDescription',
      ruleName: 'RuleName',
      ruleStatus: 'RuleStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gmtCreate: 'number',
      gmtModified: 'number',
      ruleContent: 'string',
      ruleDescription: 'string',
      ruleName: 'string',
      ruleStatus: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSpeechVoiceResponseBodyDataItemsVoiceListItems extends $tea.Model {
  label?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      label: 'Label',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      label: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSpeechVoiceResponseBodyDataItemsVoiceList extends $tea.Model {
  items?: GetSpeechVoiceResponseBodyDataItemsVoiceListItems[];
  static names(): { [key: string]: string } {
    return {
      items: 'Items',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: { 'type': 'array', 'itemType': GetSpeechVoiceResponseBodyDataItemsVoiceListItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSpeechVoiceResponseBodyDataItems extends $tea.Model {
  label?: string;
  value?: string;
  voiceList?: GetSpeechVoiceResponseBodyDataItemsVoiceList;
  static names(): { [key: string]: string } {
    return {
      label: 'Label',
      value: 'Value',
      voiceList: 'VoiceList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      label: 'string',
      value: 'string',
      voiceList: GetSpeechVoiceResponseBodyDataItemsVoiceList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSpeechVoiceResponseBodyData extends $tea.Model {
  items?: GetSpeechVoiceResponseBodyDataItems[];
  static names(): { [key: string]: string } {
    return {
      items: 'Items',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: { 'type': 'array', 'itemType': GetSpeechVoiceResponseBodyDataItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStudioAppTokenOpenResponseBodyData extends $tea.Model {
  bizId?: string;
  bizType?: string;
  isEnable?: string;
  token?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      bizId: 'BizId',
      bizType: 'BizType',
      isEnable: 'IsEnable',
      token: 'Token',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizId: 'string',
      bizType: 'string',
      isEnable: 'string',
      token: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetThingModelTslResponseBodyData extends $tea.Model {
  tslStr?: string;
  tslUri?: string;
  static names(): { [key: string]: string } {
    return {
      tslStr: 'TslStr',
      tslUri: 'TslUri',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tslStr: 'string',
      tslUri: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetThingModelTslPublishedResponseBodyData extends $tea.Model {
  tslStr?: string;
  tslUri?: string;
  static names(): { [key: string]: string } {
    return {
      tslStr: 'TslStr',
      tslUri: 'TslUri',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tslStr: 'string',
      tslUri: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetThingScriptResponseBodyData extends $tea.Model {
  scriptType?: string;
  scriptUrl?: string;
  static names(): { [key: string]: string } {
    return {
      scriptType: 'ScriptType',
      scriptUrl: 'ScriptUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      scriptType: 'string',
      scriptUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetThingTopoResponseBodyDataListDeviceInfo extends $tea.Model {
  deviceName?: string;
  iotId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetThingTopoResponseBodyDataList extends $tea.Model {
  deviceInfo?: GetThingTopoResponseBodyDataListDeviceInfo[];
  static names(): { [key: string]: string } {
    return {
      deviceInfo: 'deviceInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceInfo: { 'type': 'array', 'itemType': GetThingTopoResponseBodyDataListDeviceInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetThingTopoResponseBodyData extends $tea.Model {
  currentPage?: number;
  list?: GetThingTopoResponseBodyDataList;
  pageCount?: number;
  pageSize?: number;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      list: 'List',
      pageCount: 'PageCount',
      pageSize: 'PageSize',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      list: GetThingTopoResponseBodyDataList,
      pageCount: 'number',
      pageSize: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InvokeDataAPIServiceRequestParam extends $tea.Model {
  listParamType?: string;
  listParamValue?: string[];
  paramName?: string;
  paramType?: string;
  paramValue?: string;
  static names(): { [key: string]: string } {
    return {
      listParamType: 'ListParamType',
      listParamValue: 'ListParamValue',
      paramName: 'ParamName',
      paramType: 'ParamType',
      paramValue: 'ParamValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      listParamType: 'string',
      listParamValue: { 'type': 'array', 'itemType': 'string' },
      paramName: 'string',
      paramType: 'string',
      paramValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InvokeDataAPIServiceResponseBodyDataFieldNameList extends $tea.Model {
  fieldNameList?: string[];
  static names(): { [key: string]: string } {
    return {
      fieldNameList: 'FieldNameList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fieldNameList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InvokeDataAPIServiceResponseBodyDataResultList extends $tea.Model {
  resultList?: { [key: string]: string }[];
  static names(): { [key: string]: string } {
    return {
      resultList: 'ResultList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resultList: { 'type': 'array', 'itemType': { 'type': 'map', 'keyType': 'string', 'valueType': 'string' } },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InvokeDataAPIServiceResponseBodyData extends $tea.Model {
  apiSrn?: string;
  fieldNameList?: InvokeDataAPIServiceResponseBodyDataFieldNameList;
  pageNo?: number;
  pageSize?: number;
  resultList?: InvokeDataAPIServiceResponseBodyDataResultList;
  static names(): { [key: string]: string } {
    return {
      apiSrn: 'ApiSrn',
      fieldNameList: 'FieldNameList',
      pageNo: 'PageNo',
      pageSize: 'PageSize',
      resultList: 'ResultList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiSrn: 'string',
      fieldNameList: InvokeDataAPIServiceResponseBodyDataFieldNameList,
      pageNo: 'number',
      pageSize: 'number',
      resultList: InvokeDataAPIServiceResponseBodyDataResultList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InvokeThingServiceResponseBodyData extends $tea.Model {
  messageId?: string;
  result?: string;
  static names(): { [key: string]: string } {
    return {
      messageId: 'MessageId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      messageId: 'string',
      result: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAnalyticsDataRequestCondition extends $tea.Model {
  betweenEnd?: string;
  betweenStart?: string;
  fieldName?: string;
  operate?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      betweenEnd: 'BetweenEnd',
      betweenStart: 'BetweenStart',
      fieldName: 'FieldName',
      operate: 'Operate',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      betweenEnd: 'string',
      betweenStart: 'string',
      fieldName: 'string',
      operate: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAnalyticsDataResponseBodyData extends $tea.Model {
  count?: number;
  hasNext?: boolean;
  pageNum?: number;
  pageSize?: number;
  resultJson?: string;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      hasNext: 'HasNext',
      pageNum: 'PageNum',
      pageSize: 'PageSize',
      resultJson: 'ResultJson',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      hasNext: 'boolean',
      pageNum: 'number',
      pageSize: 'number',
      resultJson: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDeviceDistributeJobResponseBodyDataJobInfoItemsTargetInstanceConfigsTargetInstanceConfigs extends $tea.Model {
  targetInstanceId?: string;
  targetInstanceName?: string;
  targetRegion?: string;
  static names(): { [key: string]: string } {
    return {
      targetInstanceId: 'TargetInstanceId',
      targetInstanceName: 'TargetInstanceName',
      targetRegion: 'TargetRegion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      targetInstanceId: 'string',
      targetInstanceName: 'string',
      targetRegion: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDeviceDistributeJobResponseBodyDataJobInfoItemsTargetInstanceConfigs extends $tea.Model {
  targetInstanceConfigs?: ListDeviceDistributeJobResponseBodyDataJobInfoItemsTargetInstanceConfigsTargetInstanceConfigs[];
  static names(): { [key: string]: string } {
    return {
      targetInstanceConfigs: 'targetInstanceConfigs',
    };
  }

  static types(): { [key: string]: any } {
    return {
      targetInstanceConfigs: { 'type': 'array', 'itemType': ListDeviceDistributeJobResponseBodyDataJobInfoItemsTargetInstanceConfigsTargetInstanceConfigs },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDeviceDistributeJobResponseBodyDataJobInfoItems extends $tea.Model {
  gmtCreate?: number;
  jobId?: string;
  productKey?: string;
  sourceInstanceId?: string;
  sourceInstanceName?: string;
  sourceRegion?: string;
  sourceUid?: string;
  status?: number;
  strategy?: number;
  targetInstanceConfigs?: ListDeviceDistributeJobResponseBodyDataJobInfoItemsTargetInstanceConfigs;
  targetUid?: string;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      gmtCreate: 'GmtCreate',
      jobId: 'JobId',
      productKey: 'ProductKey',
      sourceInstanceId: 'SourceInstanceId',
      sourceInstanceName: 'SourceInstanceName',
      sourceRegion: 'SourceRegion',
      sourceUid: 'SourceUid',
      status: 'Status',
      strategy: 'Strategy',
      targetInstanceConfigs: 'TargetInstanceConfigs',
      targetUid: 'TargetUid',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gmtCreate: 'number',
      jobId: 'string',
      productKey: 'string',
      sourceInstanceId: 'string',
      sourceInstanceName: 'string',
      sourceRegion: 'string',
      sourceUid: 'string',
      status: 'number',
      strategy: 'number',
      targetInstanceConfigs: ListDeviceDistributeJobResponseBodyDataJobInfoItemsTargetInstanceConfigs,
      targetUid: 'string',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDeviceDistributeJobResponseBodyDataJobInfo extends $tea.Model {
  items?: ListDeviceDistributeJobResponseBodyDataJobInfoItems[];
  static names(): { [key: string]: string } {
    return {
      items: 'items',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: { 'type': 'array', 'itemType': ListDeviceDistributeJobResponseBodyDataJobInfoItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDeviceDistributeJobResponseBodyData extends $tea.Model {
  jobInfo?: ListDeviceDistributeJobResponseBodyDataJobInfo;
  nextToken?: string;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      jobInfo: 'JobInfo',
      nextToken: 'NextToken',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      jobInfo: ListDeviceDistributeJobResponseBodyDataJobInfo,
      nextToken: 'string',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDistributedDeviceResponseBodyDataInfoItems extends $tea.Model {
  deviceName?: string;
  gmtCreate?: number;
  gmtModified?: number;
  productKey?: string;
  sourceInstanceId?: string;
  sourceInstanceName?: string;
  sourceRegion?: string;
  sourceUid?: string;
  targetAliyunId?: string;
  targetInstanceId?: string;
  targetInstanceName?: string;
  targetRegion?: string;
  targetUid?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      productKey: 'ProductKey',
      sourceInstanceId: 'SourceInstanceId',
      sourceInstanceName: 'SourceInstanceName',
      sourceRegion: 'SourceRegion',
      sourceUid: 'SourceUid',
      targetAliyunId: 'TargetAliyunId',
      targetInstanceId: 'TargetInstanceId',
      targetInstanceName: 'TargetInstanceName',
      targetRegion: 'TargetRegion',
      targetUid: 'TargetUid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      gmtCreate: 'number',
      gmtModified: 'number',
      productKey: 'string',
      sourceInstanceId: 'string',
      sourceInstanceName: 'string',
      sourceRegion: 'string',
      sourceUid: 'string',
      targetAliyunId: 'string',
      targetInstanceId: 'string',
      targetInstanceName: 'string',
      targetRegion: 'string',
      targetUid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDistributedDeviceResponseBodyDataInfo extends $tea.Model {
  items?: ListDistributedDeviceResponseBodyDataInfoItems[];
  static names(): { [key: string]: string } {
    return {
      items: 'items',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: { 'type': 'array', 'itemType': ListDistributedDeviceResponseBodyDataInfoItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDistributedDeviceResponseBodyData extends $tea.Model {
  info?: ListDistributedDeviceResponseBodyDataInfo;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      info: 'Info',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      info: ListDistributedDeviceResponseBodyDataInfo,
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDistributedProductResponseBodyDataInfoItems extends $tea.Model {
  gmtCreate?: number;
  productKey?: string;
  sourceInstanceId?: string;
  sourceInstanceName?: string;
  sourceRegion?: string;
  sourceUid?: string;
  targetAliyunId?: string;
  targetInstanceId?: string;
  targetInstanceName?: string;
  targetRegion?: string;
  targetUid?: string;
  static names(): { [key: string]: string } {
    return {
      gmtCreate: 'GmtCreate',
      productKey: 'ProductKey',
      sourceInstanceId: 'SourceInstanceId',
      sourceInstanceName: 'SourceInstanceName',
      sourceRegion: 'SourceRegion',
      sourceUid: 'SourceUid',
      targetAliyunId: 'TargetAliyunId',
      targetInstanceId: 'TargetInstanceId',
      targetInstanceName: 'TargetInstanceName',
      targetRegion: 'TargetRegion',
      targetUid: 'TargetUid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gmtCreate: 'number',
      productKey: 'string',
      sourceInstanceId: 'string',
      sourceInstanceName: 'string',
      sourceRegion: 'string',
      sourceUid: 'string',
      targetAliyunId: 'string',
      targetInstanceId: 'string',
      targetInstanceName: 'string',
      targetRegion: 'string',
      targetUid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDistributedProductResponseBodyDataInfo extends $tea.Model {
  items?: ListDistributedProductResponseBodyDataInfoItems[];
  static names(): { [key: string]: string } {
    return {
      items: 'items',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: { 'type': 'array', 'itemType': ListDistributedProductResponseBodyDataInfoItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDistributedProductResponseBodyData extends $tea.Model {
  info?: ListDistributedProductResponseBodyDataInfo;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      info: 'Info',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      info: ListDistributedProductResponseBodyDataInfo,
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobResponseBodyDataData extends $tea.Model {
  description?: string;
  jobId?: string;
  jobName?: string;
  scheduledTime?: number;
  status?: string;
  type?: string;
  utcCreate?: string;
  utcModified?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      jobId: 'JobId',
      jobName: 'JobName',
      scheduledTime: 'ScheduledTime',
      status: 'Status',
      type: 'Type',
      utcCreate: 'UtcCreate',
      utcModified: 'UtcModified',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      jobId: 'string',
      jobName: 'string',
      scheduledTime: 'number',
      status: 'string',
      type: 'string',
      utcCreate: 'string',
      utcModified: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobResponseBodyData extends $tea.Model {
  data?: ListJobResponseBodyDataData[];
  static names(): { [key: string]: string } {
    return {
      data: 'data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': ListJobResponseBodyDataData },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAFirmwareResponseBodyFirmwareInfoSimpleFirmwareInfo extends $tea.Model {
  destVersion?: string;
  firmwareDesc?: string;
  firmwareId?: string;
  firmwareName?: string;
  firmwareSign?: string;
  firmwareSize?: number;
  moduleName?: string;
  productKey?: string;
  productName?: string;
  signMethod?: string;
  srcVersion?: string;
  status?: number;
  type?: number;
  utcCreate?: string;
  utcModified?: string;
  static names(): { [key: string]: string } {
    return {
      destVersion: 'DestVersion',
      firmwareDesc: 'FirmwareDesc',
      firmwareId: 'FirmwareId',
      firmwareName: 'FirmwareName',
      firmwareSign: 'FirmwareSign',
      firmwareSize: 'FirmwareSize',
      moduleName: 'ModuleName',
      productKey: 'ProductKey',
      productName: 'ProductName',
      signMethod: 'SignMethod',
      srcVersion: 'SrcVersion',
      status: 'Status',
      type: 'Type',
      utcCreate: 'UtcCreate',
      utcModified: 'UtcModified',
    };
  }

  static types(): { [key: string]: any } {
    return {
      destVersion: 'string',
      firmwareDesc: 'string',
      firmwareId: 'string',
      firmwareName: 'string',
      firmwareSign: 'string',
      firmwareSize: 'number',
      moduleName: 'string',
      productKey: 'string',
      productName: 'string',
      signMethod: 'string',
      srcVersion: 'string',
      status: 'number',
      type: 'number',
      utcCreate: 'string',
      utcModified: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAFirmwareResponseBodyFirmwareInfo extends $tea.Model {
  simpleFirmwareInfo?: ListOTAFirmwareResponseBodyFirmwareInfoSimpleFirmwareInfo[];
  static names(): { [key: string]: string } {
    return {
      simpleFirmwareInfo: 'SimpleFirmwareInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      simpleFirmwareInfo: { 'type': 'array', 'itemType': ListOTAFirmwareResponseBodyFirmwareInfoSimpleFirmwareInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfoTagsOtaTagDTO extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfoTags extends $tea.Model {
  otaTagDTO?: ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfoTagsOtaTagDTO[];
  static names(): { [key: string]: string } {
    return {
      otaTagDTO: 'OtaTagDTO',
    };
  }

  static types(): { [key: string]: any } {
    return {
      otaTagDTO: { 'type': 'array', 'itemType': ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfoTagsOtaTagDTO },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfo extends $tea.Model {
  firmwareId?: string;
  jobId?: string;
  jobStatus?: string;
  jobType?: string;
  productKey?: string;
  selectionType?: string;
  tags?: ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfoTags;
  targetSelection?: string;
  utcCreate?: string;
  utcEndTime?: string;
  utcModified?: string;
  utcStartTime?: string;
  static names(): { [key: string]: string } {
    return {
      firmwareId: 'FirmwareId',
      jobId: 'JobId',
      jobStatus: 'JobStatus',
      jobType: 'JobType',
      productKey: 'ProductKey',
      selectionType: 'SelectionType',
      tags: 'Tags',
      targetSelection: 'TargetSelection',
      utcCreate: 'UtcCreate',
      utcEndTime: 'UtcEndTime',
      utcModified: 'UtcModified',
      utcStartTime: 'UtcStartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      firmwareId: 'string',
      jobId: 'string',
      jobStatus: 'string',
      jobType: 'string',
      productKey: 'string',
      selectionType: 'string',
      tags: ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfoTags,
      targetSelection: 'string',
      utcCreate: 'string',
      utcEndTime: 'string',
      utcModified: 'string',
      utcStartTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAJobByDeviceResponseBodyData extends $tea.Model {
  simpleOTAJobInfo?: ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfo[];
  static names(): { [key: string]: string } {
    return {
      simpleOTAJobInfo: 'SimpleOTAJobInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      simpleOTAJobInfo: { 'type': 'array', 'itemType': ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfoTagsOtaTagDTO extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfoTags extends $tea.Model {
  otaTagDTO?: ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfoTagsOtaTagDTO[];
  static names(): { [key: string]: string } {
    return {
      otaTagDTO: 'OtaTagDTO',
    };
  }

  static types(): { [key: string]: any } {
    return {
      otaTagDTO: { 'type': 'array', 'itemType': ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfoTagsOtaTagDTO },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfo extends $tea.Model {
  firmwareId?: string;
  jobId?: string;
  jobStatus?: string;
  jobType?: string;
  productKey?: string;
  selectionType?: string;
  tags?: ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfoTags;
  targetSelection?: string;
  utcCreate?: string;
  utcEndTime?: string;
  utcModified?: string;
  utcStartTime?: string;
  static names(): { [key: string]: string } {
    return {
      firmwareId: 'FirmwareId',
      jobId: 'JobId',
      jobStatus: 'JobStatus',
      jobType: 'JobType',
      productKey: 'ProductKey',
      selectionType: 'SelectionType',
      tags: 'Tags',
      targetSelection: 'TargetSelection',
      utcCreate: 'UtcCreate',
      utcEndTime: 'UtcEndTime',
      utcModified: 'UtcModified',
      utcStartTime: 'UtcStartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      firmwareId: 'string',
      jobId: 'string',
      jobStatus: 'string',
      jobType: 'string',
      productKey: 'string',
      selectionType: 'string',
      tags: ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfoTags,
      targetSelection: 'string',
      utcCreate: 'string',
      utcEndTime: 'string',
      utcModified: 'string',
      utcStartTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAJobByFirmwareResponseBodyData extends $tea.Model {
  simpleOTAJobInfo?: ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfo[];
  static names(): { [key: string]: string } {
    return {
      simpleOTAJobInfo: 'SimpleOTAJobInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      simpleOTAJobInfo: { 'type': 'array', 'itemType': ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAModuleByProductResponseBodyData extends $tea.Model {
  aliasName?: string;
  desc?: string;
  gmtCreate?: string;
  gmtModified?: string;
  moduleName?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      aliasName: 'AliasName',
      desc: 'Desc',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      moduleName: 'ModuleName',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliasName: 'string',
      desc: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      moduleName: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAModuleVersionsByDeviceResponseBodyDataSimpleOTAModuleInfo extends $tea.Model {
  deviceName?: string;
  iotId?: string;
  moduleName?: string;
  moduleVersion?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      moduleName: 'ModuleName',
      moduleVersion: 'ModuleVersion',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      moduleName: 'string',
      moduleVersion: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAModuleVersionsByDeviceResponseBodyData extends $tea.Model {
  simpleOTAModuleInfo?: ListOTAModuleVersionsByDeviceResponseBodyDataSimpleOTAModuleInfo[];
  static names(): { [key: string]: string } {
    return {
      simpleOTAModuleInfo: 'SimpleOTAModuleInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      simpleOTAModuleInfo: { 'type': 'array', 'itemType': ListOTAModuleVersionsByDeviceResponseBodyDataSimpleOTAModuleInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTATaskByJobResponseBodyDataSimpleOTATaskInfo extends $tea.Model {
  destVersion?: string;
  deviceName?: string;
  firmwareId?: string;
  iotId?: string;
  jobId?: string;
  productKey?: string;
  productName?: string;
  progress?: string;
  srcVersion?: string;
  taskDesc?: string;
  taskId?: string;
  taskStatus?: string;
  timeout?: string;
  utcCreate?: string;
  utcModified?: string;
  static names(): { [key: string]: string } {
    return {
      destVersion: 'DestVersion',
      deviceName: 'DeviceName',
      firmwareId: 'FirmwareId',
      iotId: 'IotId',
      jobId: 'JobId',
      productKey: 'ProductKey',
      productName: 'ProductName',
      progress: 'Progress',
      srcVersion: 'SrcVersion',
      taskDesc: 'TaskDesc',
      taskId: 'TaskId',
      taskStatus: 'TaskStatus',
      timeout: 'Timeout',
      utcCreate: 'UtcCreate',
      utcModified: 'UtcModified',
    };
  }

  static types(): { [key: string]: any } {
    return {
      destVersion: 'string',
      deviceName: 'string',
      firmwareId: 'string',
      iotId: 'string',
      jobId: 'string',
      productKey: 'string',
      productName: 'string',
      progress: 'string',
      srcVersion: 'string',
      taskDesc: 'string',
      taskId: 'string',
      taskStatus: 'string',
      timeout: 'string',
      utcCreate: 'string',
      utcModified: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTATaskByJobResponseBodyData extends $tea.Model {
  simpleOTATaskInfo?: ListOTATaskByJobResponseBodyDataSimpleOTATaskInfo[];
  static names(): { [key: string]: string } {
    return {
      simpleOTATaskInfo: 'SimpleOTATaskInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      simpleOTATaskInfo: { 'type': 'array', 'itemType': ListOTATaskByJobResponseBodyDataSimpleOTATaskInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAUnfinishedTaskByDeviceResponseBodyDataSimpleOTATaskInfo extends $tea.Model {
  destVersion?: string;
  deviceName?: string;
  firmwareId?: string;
  iotId?: string;
  jobId?: string;
  moduleName?: string;
  productKey?: string;
  productName?: string;
  srcVersion?: string;
  taskId?: string;
  taskStatus?: string;
  utcCreate?: string;
  utcModified?: string;
  static names(): { [key: string]: string } {
    return {
      destVersion: 'DestVersion',
      deviceName: 'DeviceName',
      firmwareId: 'FirmwareId',
      iotId: 'IotId',
      jobId: 'JobId',
      moduleName: 'ModuleName',
      productKey: 'ProductKey',
      productName: 'ProductName',
      srcVersion: 'SrcVersion',
      taskId: 'TaskId',
      taskStatus: 'TaskStatus',
      utcCreate: 'UtcCreate',
      utcModified: 'UtcModified',
    };
  }

  static types(): { [key: string]: any } {
    return {
      destVersion: 'string',
      deviceName: 'string',
      firmwareId: 'string',
      iotId: 'string',
      jobId: 'string',
      moduleName: 'string',
      productKey: 'string',
      productName: 'string',
      srcVersion: 'string',
      taskId: 'string',
      taskStatus: 'string',
      utcCreate: 'string',
      utcModified: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAUnfinishedTaskByDeviceResponseBodyData extends $tea.Model {
  simpleOTATaskInfo?: ListOTAUnfinishedTaskByDeviceResponseBodyDataSimpleOTATaskInfo[];
  static names(): { [key: string]: string } {
    return {
      simpleOTATaskInfo: 'SimpleOTATaskInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      simpleOTATaskInfo: { 'type': 'array', 'itemType': ListOTAUnfinishedTaskByDeviceResponseBodyDataSimpleOTATaskInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProductByTagsRequestProductTag extends $tea.Model {
  tagKey?: string;
  tagValue?: string;
  static names(): { [key: string]: string } {
    return {
      tagKey: 'TagKey',
      tagValue: 'TagValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagKey: 'string',
      tagValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProductByTagsResponseBodyProductInfosProductInfo extends $tea.Model {
  createTime?: number;
  description?: string;
  nodeType?: number;
  productKey?: string;
  productName?: string;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      description: 'Description',
      nodeType: 'NodeType',
      productKey: 'ProductKey',
      productName: 'ProductName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'number',
      description: 'string',
      nodeType: 'number',
      productKey: 'string',
      productName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProductByTagsResponseBodyProductInfos extends $tea.Model {
  productInfo?: ListProductByTagsResponseBodyProductInfosProductInfo[];
  static names(): { [key: string]: string } {
    return {
      productInfo: 'ProductInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      productInfo: { 'type': 'array', 'itemType': ListProductByTagsResponseBodyProductInfosProductInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProductTagsResponseBodyDataProductTag extends $tea.Model {
  tagKey?: string;
  tagValue?: string;
  static names(): { [key: string]: string } {
    return {
      tagKey: 'TagKey',
      tagValue: 'TagValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagKey: 'string',
      tagValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProductTagsResponseBodyData extends $tea.Model {
  productTag?: ListProductTagsResponseBodyDataProductTag[];
  static names(): { [key: string]: string } {
    return {
      productTag: 'ProductTag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      productTag: { 'type': 'array', 'itemType': ListProductTagsResponseBodyDataProductTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRuleResponseBodyDataRuleInfo extends $tea.Model {
  createUserId?: number;
  created?: string;
  dataType?: string;
  id?: number;
  modified?: string;
  name?: string;
  productKey?: string;
  ruleDesc?: string;
  select?: string;
  shortTopic?: string;
  status?: string;
  topic?: string;
  utcCreated?: string;
  utcModified?: string;
  where?: string;
  static names(): { [key: string]: string } {
    return {
      createUserId: 'CreateUserId',
      created: 'Created',
      dataType: 'DataType',
      id: 'Id',
      modified: 'Modified',
      name: 'Name',
      productKey: 'ProductKey',
      ruleDesc: 'RuleDesc',
      select: 'Select',
      shortTopic: 'ShortTopic',
      status: 'Status',
      topic: 'Topic',
      utcCreated: 'UtcCreated',
      utcModified: 'UtcModified',
      where: 'Where',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createUserId: 'number',
      created: 'string',
      dataType: 'string',
      id: 'number',
      modified: 'string',
      name: 'string',
      productKey: 'string',
      ruleDesc: 'string',
      select: 'string',
      shortTopic: 'string',
      status: 'string',
      topic: 'string',
      utcCreated: 'string',
      utcModified: 'string',
      where: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRuleResponseBodyData extends $tea.Model {
  ruleInfo?: ListRuleResponseBodyDataRuleInfo[];
  static names(): { [key: string]: string } {
    return {
      ruleInfo: 'RuleInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ruleInfo: { 'type': 'array', 'itemType': ListRuleResponseBodyDataRuleInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRuleActionsResponseBodyRuleActionListRuleActionInfo extends $tea.Model {
  configuration?: string;
  errorActionFlag?: boolean;
  id?: number;
  ruleId?: number;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      configuration: 'Configuration',
      errorActionFlag: 'ErrorActionFlag',
      id: 'Id',
      ruleId: 'RuleId',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configuration: 'string',
      errorActionFlag: 'boolean',
      id: 'number',
      ruleId: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRuleActionsResponseBodyRuleActionList extends $tea.Model {
  ruleActionInfo?: ListRuleActionsResponseBodyRuleActionListRuleActionInfo[];
  static names(): { [key: string]: string } {
    return {
      ruleActionInfo: 'RuleActionInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ruleActionInfo: { 'type': 'array', 'itemType': ListRuleActionsResponseBodyRuleActionListRuleActionInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskResponseBodyDataData extends $tea.Model {
  deviceName?: string;
  iotId?: string;
  jobId?: string;
  jobName?: string;
  productKey?: string;
  progress?: string;
  status?: string;
  taskId?: string;
  utcModified?: string;
  utcQueueTime?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      jobId: 'JobId',
      jobName: 'JobName',
      productKey: 'ProductKey',
      progress: 'Progress',
      status: 'Status',
      taskId: 'TaskId',
      utcModified: 'UtcModified',
      utcQueueTime: 'UtcQueueTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      jobId: 'string',
      jobName: 'string',
      productKey: 'string',
      progress: 'string',
      status: 'string',
      taskId: 'string',
      utcModified: 'string',
      utcQueueTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskResponseBodyData extends $tea.Model {
  data?: ListTaskResponseBodyDataData[];
  static names(): { [key: string]: string } {
    return {
      data: 'data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': ListTaskResponseBodyDataData },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskByPageResponseBodyDataData extends $tea.Model {
  deviceName?: string;
  iotId?: string;
  jobId?: string;
  jobName?: string;
  productKey?: string;
  productName?: string;
  progress?: number;
  status?: string;
  statusDetail?: string;
  taskId?: string;
  utcModified?: string;
  utcQueueTime?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      jobId: 'JobId',
      jobName: 'JobName',
      productKey: 'ProductKey',
      productName: 'ProductName',
      progress: 'Progress',
      status: 'Status',
      statusDetail: 'StatusDetail',
      taskId: 'TaskId',
      utcModified: 'UtcModified',
      utcQueueTime: 'UtcQueueTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      jobId: 'string',
      jobName: 'string',
      productKey: 'string',
      productName: 'string',
      progress: 'number',
      status: 'string',
      statusDetail: 'string',
      taskId: 'string',
      utcModified: 'string',
      utcQueueTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskByPageResponseBodyData extends $tea.Model {
  data?: ListTaskByPageResponseBodyDataData[];
  static names(): { [key: string]: string } {
    return {
      data: 'data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': ListTaskByPageResponseBodyDataData },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListThingModelVersionResponseBodyDataModelVersions extends $tea.Model {
  description?: string;
  gmtCreate?: number;
  modelVersion?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      gmtCreate: 'GmtCreate',
      modelVersion: 'ModelVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      gmtCreate: 'number',
      modelVersion: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListThingModelVersionResponseBodyData extends $tea.Model {
  modelVersions?: ListThingModelVersionResponseBodyDataModelVersions[];
  static names(): { [key: string]: string } {
    return {
      modelVersions: 'ModelVersions',
    };
  }

  static types(): { [key: string]: any } {
    return {
      modelVersions: { 'type': 'array', 'itemType': ListThingModelVersionResponseBodyDataModelVersions },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListThingTemplatesResponseBodyData extends $tea.Model {
  categoryKey?: string;
  categoryName?: string;
  static names(): { [key: string]: string } {
    return {
      categoryKey: 'CategoryKey',
      categoryName: 'CategoryName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      categoryKey: 'string',
      categoryName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class NotifyAddThingTopoResponseBodyData extends $tea.Model {
  messageId?: string;
  static names(): { [key: string]: string } {
    return {
      messageId: 'MessageId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      messageId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PrintByTemplateResponseBodyData extends $tea.Model {
  deviceErrorCode?: string;
  deviceErrorMessage?: string;
  id?: string;
  maxRetryCount?: number;
  retryCount?: number;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      deviceErrorCode: 'DeviceErrorCode',
      deviceErrorMessage: 'DeviceErrorMessage',
      id: 'Id',
      maxRetryCount: 'MaxRetryCount',
      retryCount: 'RetryCount',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceErrorCode: 'string',
      deviceErrorMessage: 'string',
      id: 'string',
      maxRetryCount: 'number',
      retryCount: 'number',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PubRequestUserProp extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAppDeviceListRequestTagList extends $tea.Model {
  tagName?: string;
  tagValue?: string;
  static names(): { [key: string]: string } {
    return {
      tagName: 'TagName',
      tagValue: 'TagValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagName: 'string',
      tagValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAppDeviceListResponseBodyDataData extends $tea.Model {
  activeTime?: string;
  childDeviceCount?: number;
  createTime?: string;
  deviceName?: string;
  lastOnlineTime?: string;
  nodeType?: number;
  productKey?: string;
  productName?: string;
  status?: string;
  utcActiveTime?: string;
  utcCreateTime?: string;
  utcLastOnlineTime?: string;
  static names(): { [key: string]: string } {
    return {
      activeTime: 'ActiveTime',
      childDeviceCount: 'ChildDeviceCount',
      createTime: 'CreateTime',
      deviceName: 'DeviceName',
      lastOnlineTime: 'LastOnlineTime',
      nodeType: 'NodeType',
      productKey: 'ProductKey',
      productName: 'ProductName',
      status: 'Status',
      utcActiveTime: 'UtcActiveTime',
      utcCreateTime: 'UtcCreateTime',
      utcLastOnlineTime: 'UtcLastOnlineTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      activeTime: 'string',
      childDeviceCount: 'number',
      createTime: 'string',
      deviceName: 'string',
      lastOnlineTime: 'string',
      nodeType: 'number',
      productKey: 'string',
      productName: 'string',
      status: 'string',
      utcActiveTime: 'string',
      utcCreateTime: 'string',
      utcLastOnlineTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAppDeviceListResponseBodyData extends $tea.Model {
  data?: QueryAppDeviceListResponseBodyDataData[];
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': QueryAppDeviceListResponseBodyDataData },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryBatchRegisterDeviceStatusResponseBodyDataInvalidList extends $tea.Model {
  name?: string[];
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryBatchRegisterDeviceStatusResponseBodyDataValidList extends $tea.Model {
  name?: string[];
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryBatchRegisterDeviceStatusResponseBodyData extends $tea.Model {
  invalidList?: QueryBatchRegisterDeviceStatusResponseBodyDataInvalidList;
  status?: string;
  validList?: QueryBatchRegisterDeviceStatusResponseBodyDataValidList;
  static names(): { [key: string]: string } {
    return {
      invalidList: 'InvalidList',
      status: 'Status',
      validList: 'ValidList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      invalidList: QueryBatchRegisterDeviceStatusResponseBodyDataInvalidList,
      status: 'string',
      validList: QueryBatchRegisterDeviceStatusResponseBodyDataValidList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryConsumerGroupByGroupIdResponseBodyData extends $tea.Model {
  createTime?: string;
  groupId?: string;
  groupName?: string;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      groupId: 'GroupId',
      groupName: 'GroupName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'string',
      groupId: 'string',
      groupName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryConsumerGroupListResponseBodyDataConsumerGroupDTO extends $tea.Model {
  createTime?: string;
  groupId?: string;
  groupName?: string;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      groupId: 'GroupId',
      groupName: 'GroupName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'string',
      groupId: 'string',
      groupName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryConsumerGroupListResponseBodyData extends $tea.Model {
  consumerGroupDTO?: QueryConsumerGroupListResponseBodyDataConsumerGroupDTO[];
  static names(): { [key: string]: string } {
    return {
      consumerGroupDTO: 'ConsumerGroupDTO',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consumerGroupDTO: { 'type': 'array', 'itemType': QueryConsumerGroupListResponseBodyDataConsumerGroupDTO },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryConsumerGroupStatusResponseBodyClientConnectionStatusListConsumerGroupClientConnectionInfo extends $tea.Model {
  accumulatedConsumeCountPerMinute?: number;
  clientId?: string;
  clientIpPort?: string;
  onlineTime?: number;
  realTimeConsumeCountPerMinute?: number;
  static names(): { [key: string]: string } {
    return {
      accumulatedConsumeCountPerMinute: 'AccumulatedConsumeCountPerMinute',
      clientId: 'ClientId',
      clientIpPort: 'ClientIpPort',
      onlineTime: 'OnlineTime',
      realTimeConsumeCountPerMinute: 'RealTimeConsumeCountPerMinute',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accumulatedConsumeCountPerMinute: 'number',
      clientId: 'string',
      clientIpPort: 'string',
      onlineTime: 'number',
      realTimeConsumeCountPerMinute: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryConsumerGroupStatusResponseBodyClientConnectionStatusList extends $tea.Model {
  consumerGroupClientConnectionInfo?: QueryConsumerGroupStatusResponseBodyClientConnectionStatusListConsumerGroupClientConnectionInfo[];
  static names(): { [key: string]: string } {
    return {
      consumerGroupClientConnectionInfo: 'ConsumerGroupClientConnectionInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consumerGroupClientConnectionInfo: { 'type': 'array', 'itemType': QueryConsumerGroupStatusResponseBodyClientConnectionStatusListConsumerGroupClientConnectionInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDetailSceneRuleLogResponseBodyDataLogList extends $tea.Model {
  code?: string;
  message?: string;
  pkDn?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      pkDn: 'PkDn',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      pkDn: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDetailSceneRuleLogResponseBodyData extends $tea.Model {
  currentPage?: number;
  logList?: QueryDetailSceneRuleLogResponseBodyDataLogList[];
  pageSize?: number;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      logList: 'LogList',
      pageSize: 'PageSize',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      logList: { 'type': 'array', 'itemType': QueryDetailSceneRuleLogResponseBodyDataLogList },
      pageSize: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceResponseBodyDataDeviceInfo extends $tea.Model {
  deviceId?: string;
  deviceName?: string;
  deviceSecret?: string;
  deviceStatus?: string;
  deviceType?: string;
  gmtCreate?: string;
  gmtModified?: string;
  iotId?: string;
  nickname?: string;
  productKey?: string;
  utcCreate?: string;
  utcModified?: string;
  static names(): { [key: string]: string } {
    return {
      deviceId: 'DeviceId',
      deviceName: 'DeviceName',
      deviceSecret: 'DeviceSecret',
      deviceStatus: 'DeviceStatus',
      deviceType: 'DeviceType',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      iotId: 'IotId',
      nickname: 'Nickname',
      productKey: 'ProductKey',
      utcCreate: 'UtcCreate',
      utcModified: 'UtcModified',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceId: 'string',
      deviceName: 'string',
      deviceSecret: 'string',
      deviceStatus: 'string',
      deviceType: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      iotId: 'string',
      nickname: 'string',
      productKey: 'string',
      utcCreate: 'string',
      utcModified: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceResponseBodyData extends $tea.Model {
  deviceInfo?: QueryDeviceResponseBodyDataDeviceInfo[];
  static names(): { [key: string]: string } {
    return {
      deviceInfo: 'DeviceInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceInfo: { 'type': 'array', 'itemType': QueryDeviceResponseBodyDataDeviceInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceBySQLResponseBodyDataGroups extends $tea.Model {
  groupId?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceBySQLResponseBodyDataOTAModules extends $tea.Model {
  firmwareVersion?: string;
  moduleName?: string;
  static names(): { [key: string]: string } {
    return {
      firmwareVersion: 'FirmwareVersion',
      moduleName: 'ModuleName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      firmwareVersion: 'string',
      moduleName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceBySQLResponseBodyDataTags extends $tea.Model {
  tagName?: string;
  tagValue?: string;
  static names(): { [key: string]: string } {
    return {
      tagName: 'TagName',
      tagValue: 'TagValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagName: 'string',
      tagValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceBySQLResponseBodyData extends $tea.Model {
  activeTime?: string;
  deviceName?: string;
  gmtCreate?: string;
  gmtModified?: string;
  groups?: QueryDeviceBySQLResponseBodyDataGroups[];
  iotId?: string;
  nickname?: string;
  OTAModules?: QueryDeviceBySQLResponseBodyDataOTAModules[];
  productKey?: string;
  status?: string;
  tags?: QueryDeviceBySQLResponseBodyDataTags[];
  static names(): { [key: string]: string } {
    return {
      activeTime: 'ActiveTime',
      deviceName: 'DeviceName',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      groups: 'Groups',
      iotId: 'IotId',
      nickname: 'Nickname',
      OTAModules: 'OTAModules',
      productKey: 'ProductKey',
      status: 'Status',
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      activeTime: 'string',
      deviceName: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      groups: { 'type': 'array', 'itemType': QueryDeviceBySQLResponseBodyDataGroups },
      iotId: 'string',
      nickname: 'string',
      OTAModules: { 'type': 'array', 'itemType': QueryDeviceBySQLResponseBodyDataOTAModules },
      productKey: 'string',
      status: 'string',
      tags: { 'type': 'array', 'itemType': QueryDeviceBySQLResponseBodyDataTags },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceByStatusResponseBodyDataSimpleDeviceInfo extends $tea.Model {
  deviceName?: string;
  deviceSecret?: string;
  gmtCreate?: string;
  gmtModified?: string;
  iotId?: string;
  nickname?: string;
  productKey?: string;
  status?: string;
  utcCreate?: string;
  utcModified?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      deviceSecret: 'DeviceSecret',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      iotId: 'IotId',
      nickname: 'Nickname',
      productKey: 'ProductKey',
      status: 'Status',
      utcCreate: 'UtcCreate',
      utcModified: 'UtcModified',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      deviceSecret: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      iotId: 'string',
      nickname: 'string',
      productKey: 'string',
      status: 'string',
      utcCreate: 'string',
      utcModified: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceByStatusResponseBodyData extends $tea.Model {
  simpleDeviceInfo?: QueryDeviceByStatusResponseBodyDataSimpleDeviceInfo[];
  static names(): { [key: string]: string } {
    return {
      simpleDeviceInfo: 'SimpleDeviceInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      simpleDeviceInfo: { 'type': 'array', 'itemType': QueryDeviceByStatusResponseBodyDataSimpleDeviceInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceByTagsRequestTag extends $tea.Model {
  tagKey?: string;
  tagValue?: string;
  static names(): { [key: string]: string } {
    return {
      tagKey: 'TagKey',
      tagValue: 'TagValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagKey: 'string',
      tagValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceByTagsResponseBodyDataSimpleDeviceInfo extends $tea.Model {
  deviceName?: string;
  iotId?: string;
  productKey?: string;
  productName?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      productKey: 'ProductKey',
      productName: 'ProductName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      productKey: 'string',
      productName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceByTagsResponseBodyData extends $tea.Model {
  simpleDeviceInfo?: QueryDeviceByTagsResponseBodyDataSimpleDeviceInfo[];
  static names(): { [key: string]: string } {
    return {
      simpleDeviceInfo: 'SimpleDeviceInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      simpleDeviceInfo: { 'type': 'array', 'itemType': QueryDeviceByTagsResponseBodyDataSimpleDeviceInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceCertResponseBodyDeviceCertInfo extends $tea.Model {
  certSN?: string;
  certificate?: string;
  privateKey?: string;
  status?: number;
  static names(): { [key: string]: string } {
    return {
      certSN: 'CertSN',
      certificate: 'Certificate',
      privateKey: 'PrivateKey',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      certSN: 'string',
      certificate: 'string',
      privateKey: 'string',
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceDesiredPropertyResponseBodyDataListDesiredPropertyInfo extends $tea.Model {
  dataType?: string;
  identifier?: string;
  name?: string;
  time?: string;
  unit?: string;
  value?: string;
  version?: number;
  static names(): { [key: string]: string } {
    return {
      dataType: 'DataType',
      identifier: 'Identifier',
      name: 'Name',
      time: 'Time',
      unit: 'Unit',
      value: 'Value',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataType: 'string',
      identifier: 'string',
      name: 'string',
      time: 'string',
      unit: 'string',
      value: 'string',
      version: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceDesiredPropertyResponseBodyDataList extends $tea.Model {
  desiredPropertyInfo?: QueryDeviceDesiredPropertyResponseBodyDataListDesiredPropertyInfo[];
  static names(): { [key: string]: string } {
    return {
      desiredPropertyInfo: 'DesiredPropertyInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      desiredPropertyInfo: { 'type': 'array', 'itemType': QueryDeviceDesiredPropertyResponseBodyDataListDesiredPropertyInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceDesiredPropertyResponseBodyData extends $tea.Model {
  list?: QueryDeviceDesiredPropertyResponseBodyDataList;
  static names(): { [key: string]: string } {
    return {
      list: 'List',
    };
  }

  static types(): { [key: string]: any } {
    return {
      list: QueryDeviceDesiredPropertyResponseBodyDataList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceDetailResponseBodyData extends $tea.Model {
  deviceName?: string;
  deviceSecret?: string;
  firmwareVersion?: string;
  gmtActive?: string;
  gmtCreate?: string;
  gmtOnline?: string;
  iotId?: string;
  ipAddress?: string;
  nickname?: string;
  nodeType?: number;
  owner?: boolean;
  productKey?: string;
  productName?: string;
  region?: string;
  status?: string;
  utcActive?: string;
  utcCreate?: string;
  utcOnline?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      deviceSecret: 'DeviceSecret',
      firmwareVersion: 'FirmwareVersion',
      gmtActive: 'GmtActive',
      gmtCreate: 'GmtCreate',
      gmtOnline: 'GmtOnline',
      iotId: 'IotId',
      ipAddress: 'IpAddress',
      nickname: 'Nickname',
      nodeType: 'NodeType',
      owner: 'Owner',
      productKey: 'ProductKey',
      productName: 'ProductName',
      region: 'Region',
      status: 'Status',
      utcActive: 'UtcActive',
      utcCreate: 'UtcCreate',
      utcOnline: 'UtcOnline',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      deviceSecret: 'string',
      firmwareVersion: 'string',
      gmtActive: 'string',
      gmtCreate: 'string',
      gmtOnline: 'string',
      iotId: 'string',
      ipAddress: 'string',
      nickname: 'string',
      nodeType: 'number',
      owner: 'boolean',
      productKey: 'string',
      productName: 'string',
      region: 'string',
      status: 'string',
      utcActive: 'string',
      utcCreate: 'string',
      utcOnline: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceDistributeJobResponseBodyDataTargetInstanceConfigsTargetInstanceConfigs extends $tea.Model {
  targetInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      targetInstanceId: 'TargetInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      targetInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceDistributeJobResponseBodyDataTargetInstanceConfigs extends $tea.Model {
  targetInstanceConfigs?: QueryDeviceDistributeJobResponseBodyDataTargetInstanceConfigsTargetInstanceConfigs[];
  static names(): { [key: string]: string } {
    return {
      targetInstanceConfigs: 'targetInstanceConfigs',
    };
  }

  static types(): { [key: string]: any } {
    return {
      targetInstanceConfigs: { 'type': 'array', 'itemType': QueryDeviceDistributeJobResponseBodyDataTargetInstanceConfigsTargetInstanceConfigs },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceDistributeJobResponseBodyData extends $tea.Model {
  gmtCreate?: number;
  jobId?: string;
  productKey?: string;
  sourceInstanceId?: string;
  sourceUid?: string;
  status?: number;
  strategy?: number;
  targetInstanceConfigs?: QueryDeviceDistributeJobResponseBodyDataTargetInstanceConfigs;
  targetUid?: string;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      gmtCreate: 'GmtCreate',
      jobId: 'JobId',
      productKey: 'ProductKey',
      sourceInstanceId: 'SourceInstanceId',
      sourceUid: 'SourceUid',
      status: 'Status',
      strategy: 'Strategy',
      targetInstanceConfigs: 'TargetInstanceConfigs',
      targetUid: 'TargetUid',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gmtCreate: 'number',
      jobId: 'string',
      productKey: 'string',
      sourceInstanceId: 'string',
      sourceUid: 'string',
      status: 'number',
      strategy: 'number',
      targetInstanceConfigs: QueryDeviceDistributeJobResponseBodyDataTargetInstanceConfigs,
      targetUid: 'string',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceEventDataResponseBodyDataListEventInfo extends $tea.Model {
  eventType?: string;
  identifier?: string;
  name?: string;
  outputData?: string;
  time?: string;
  static names(): { [key: string]: string } {
    return {
      eventType: 'EventType',
      identifier: 'Identifier',
      name: 'Name',
      outputData: 'OutputData',
      time: 'Time',
    };
  }

  static types(): { [key: string]: any } {
    return {
      eventType: 'string',
      identifier: 'string',
      name: 'string',
      outputData: 'string',
      time: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceEventDataResponseBodyDataList extends $tea.Model {
  eventInfo?: QueryDeviceEventDataResponseBodyDataListEventInfo[];
  static names(): { [key: string]: string } {
    return {
      eventInfo: 'EventInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      eventInfo: { 'type': 'array', 'itemType': QueryDeviceEventDataResponseBodyDataListEventInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceEventDataResponseBodyData extends $tea.Model {
  list?: QueryDeviceEventDataResponseBodyDataList;
  nextTime?: number;
  nextValid?: boolean;
  static names(): { [key: string]: string } {
    return {
      list: 'List',
      nextTime: 'NextTime',
      nextValid: 'NextValid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      list: QueryDeviceEventDataResponseBodyDataList,
      nextTime: 'number',
      nextValid: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceFileResponseBodyData extends $tea.Model {
  downloadUrl?: string;
  fileId?: string;
  name?: string;
  size?: string;
  utcCreatedOn?: string;
  static names(): { [key: string]: string } {
    return {
      downloadUrl: 'DownloadUrl',
      fileId: 'FileId',
      name: 'Name',
      size: 'Size',
      utcCreatedOn: 'UtcCreatedOn',
    };
  }

  static types(): { [key: string]: any } {
    return {
      downloadUrl: 'string',
      fileId: 'string',
      name: 'string',
      size: 'string',
      utcCreatedOn: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceFileListResponseBodyDataFileSummary extends $tea.Model {
  fileId?: string;
  name?: string;
  size?: string;
  utcCreatedOn?: string;
  static names(): { [key: string]: string } {
    return {
      fileId: 'FileId',
      name: 'Name',
      size: 'Size',
      utcCreatedOn: 'UtcCreatedOn',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fileId: 'string',
      name: 'string',
      size: 'string',
      utcCreatedOn: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceFileListResponseBodyData extends $tea.Model {
  fileSummary?: QueryDeviceFileListResponseBodyDataFileSummary[];
  static names(): { [key: string]: string } {
    return {
      fileSummary: 'FileSummary',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fileSummary: { 'type': 'array', 'itemType': QueryDeviceFileListResponseBodyDataFileSummary },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceGroupByDeviceResponseBodyGroupInfosGroupInfo extends $tea.Model {
  groupDesc?: string;
  groupId?: string;
  groupName?: string;
  utcCreate?: string;
  static names(): { [key: string]: string } {
    return {
      groupDesc: 'GroupDesc',
      groupId: 'GroupId',
      groupName: 'GroupName',
      utcCreate: 'UtcCreate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupDesc: 'string',
      groupId: 'string',
      groupName: 'string',
      utcCreate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceGroupByDeviceResponseBodyGroupInfos extends $tea.Model {
  groupInfo?: QueryDeviceGroupByDeviceResponseBodyGroupInfosGroupInfo[];
  static names(): { [key: string]: string } {
    return {
      groupInfo: 'GroupInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupInfo: { 'type': 'array', 'itemType': QueryDeviceGroupByDeviceResponseBodyGroupInfosGroupInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceGroupByTagsRequestTag extends $tea.Model {
  tagKey?: string;
  tagValue?: string;
  static names(): { [key: string]: string } {
    return {
      tagKey: 'TagKey',
      tagValue: 'TagValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagKey: 'string',
      tagValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceGroupByTagsResponseBodyDataDeviceGroup extends $tea.Model {
  groupId?: string;
  groupName?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      groupName: 'GroupName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      groupName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceGroupByTagsResponseBodyData extends $tea.Model {
  deviceGroup?: QueryDeviceGroupByTagsResponseBodyDataDeviceGroup[];
  static names(): { [key: string]: string } {
    return {
      deviceGroup: 'DeviceGroup',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceGroup: { 'type': 'array', 'itemType': QueryDeviceGroupByTagsResponseBodyDataDeviceGroup },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceGroupInfoResponseBodyData extends $tea.Model {
  deviceActive?: number;
  deviceCount?: number;
  deviceOnline?: number;
  groupDesc?: string;
  groupId?: string;
  groupName?: string;
  utcCreate?: string;
  static names(): { [key: string]: string } {
    return {
      deviceActive: 'DeviceActive',
      deviceCount: 'DeviceCount',
      deviceOnline: 'DeviceOnline',
      groupDesc: 'GroupDesc',
      groupId: 'GroupId',
      groupName: 'GroupName',
      utcCreate: 'UtcCreate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceActive: 'number',
      deviceCount: 'number',
      deviceOnline: 'number',
      groupDesc: 'string',
      groupId: 'string',
      groupName: 'string',
      utcCreate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceGroupListResponseBodyDataGroupInfo extends $tea.Model {
  groupDesc?: string;
  groupId?: string;
  groupName?: string;
  utcCreate?: string;
  static names(): { [key: string]: string } {
    return {
      groupDesc: 'GroupDesc',
      groupId: 'GroupId',
      groupName: 'GroupName',
      utcCreate: 'UtcCreate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupDesc: 'string',
      groupId: 'string',
      groupName: 'string',
      utcCreate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceGroupListResponseBodyData extends $tea.Model {
  groupInfo?: QueryDeviceGroupListResponseBodyDataGroupInfo[];
  static names(): { [key: string]: string } {
    return {
      groupInfo: 'GroupInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupInfo: { 'type': 'array', 'itemType': QueryDeviceGroupListResponseBodyDataGroupInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceGroupTagListResponseBodyDataGroupTagInfo extends $tea.Model {
  tagKey?: string;
  tagValue?: string;
  static names(): { [key: string]: string } {
    return {
      tagKey: 'TagKey',
      tagValue: 'TagValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagKey: 'string',
      tagValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceGroupTagListResponseBodyData extends $tea.Model {
  groupTagInfo?: QueryDeviceGroupTagListResponseBodyDataGroupTagInfo[];
  static names(): { [key: string]: string } {
    return {
      groupTagInfo: 'GroupTagInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupTagInfo: { 'type': 'array', 'itemType': QueryDeviceGroupTagListResponseBodyDataGroupTagInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceInfoResponseBodyData extends $tea.Model {
  deviceName?: string;
  deviceSecret?: string;
  iotId?: string;
  nickname?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      deviceSecret: 'DeviceSecret',
      iotId: 'IotId',
      nickname: 'Nickname',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      deviceSecret: 'string',
      iotId: 'string',
      nickname: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceListByDeviceGroupResponseBodyDataSimpleDeviceInfo extends $tea.Model {
  deviceName?: string;
  iotId?: string;
  productKey?: string;
  productName?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      productKey: 'ProductKey',
      productName: 'ProductName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      productKey: 'string',
      productName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceListByDeviceGroupResponseBodyData extends $tea.Model {
  simpleDeviceInfo?: QueryDeviceListByDeviceGroupResponseBodyDataSimpleDeviceInfo[];
  static names(): { [key: string]: string } {
    return {
      simpleDeviceInfo: 'SimpleDeviceInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      simpleDeviceInfo: { 'type': 'array', 'itemType': QueryDeviceListByDeviceGroupResponseBodyDataSimpleDeviceInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceOriginalEventDataResponseBodyDataListEventInfo extends $tea.Model {
  eventType?: string;
  identifier?: string;
  name?: string;
  outputData?: string;
  time?: string;
  static names(): { [key: string]: string } {
    return {
      eventType: 'EventType',
      identifier: 'Identifier',
      name: 'Name',
      outputData: 'OutputData',
      time: 'Time',
    };
  }

  static types(): { [key: string]: any } {
    return {
      eventType: 'string',
      identifier: 'string',
      name: 'string',
      outputData: 'string',
      time: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceOriginalEventDataResponseBodyDataList extends $tea.Model {
  eventInfo?: QueryDeviceOriginalEventDataResponseBodyDataListEventInfo[];
  static names(): { [key: string]: string } {
    return {
      eventInfo: 'EventInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      eventInfo: { 'type': 'array', 'itemType': QueryDeviceOriginalEventDataResponseBodyDataListEventInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceOriginalEventDataResponseBodyData extends $tea.Model {
  list?: QueryDeviceOriginalEventDataResponseBodyDataList;
  nextPageToken?: string;
  nextValid?: boolean;
  static names(): { [key: string]: string } {
    return {
      list: 'List',
      nextPageToken: 'NextPageToken',
      nextValid: 'NextValid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      list: QueryDeviceOriginalEventDataResponseBodyDataList,
      nextPageToken: 'string',
      nextValid: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceOriginalPropertyDataResponseBodyDataListPropertyInfo extends $tea.Model {
  time?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      time: 'Time',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      time: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceOriginalPropertyDataResponseBodyDataList extends $tea.Model {
  propertyInfo?: QueryDeviceOriginalPropertyDataResponseBodyDataListPropertyInfo[];
  static names(): { [key: string]: string } {
    return {
      propertyInfo: 'PropertyInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      propertyInfo: { 'type': 'array', 'itemType': QueryDeviceOriginalPropertyDataResponseBodyDataListPropertyInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceOriginalPropertyDataResponseBodyData extends $tea.Model {
  list?: QueryDeviceOriginalPropertyDataResponseBodyDataList;
  nextValid?: boolean;
  nextPageToken?: string;
  static names(): { [key: string]: string } {
    return {
      list: 'List',
      nextValid: 'NextValid',
      nextPageToken: 'nextPageToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      list: QueryDeviceOriginalPropertyDataResponseBodyDataList,
      nextValid: 'boolean',
      nextPageToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceOriginalPropertyStatusResponseBodyDataListPropertyStatusDataInfo extends $tea.Model {
  identifier?: string;
  time?: number;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      identifier: 'Identifier',
      time: 'Time',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      identifier: 'string',
      time: 'number',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceOriginalPropertyStatusResponseBodyDataList extends $tea.Model {
  propertyStatusDataInfo?: QueryDeviceOriginalPropertyStatusResponseBodyDataListPropertyStatusDataInfo[];
  static names(): { [key: string]: string } {
    return {
      propertyStatusDataInfo: 'PropertyStatusDataInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      propertyStatusDataInfo: { 'type': 'array', 'itemType': QueryDeviceOriginalPropertyStatusResponseBodyDataListPropertyStatusDataInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceOriginalPropertyStatusResponseBodyData extends $tea.Model {
  list?: QueryDeviceOriginalPropertyStatusResponseBodyDataList;
  nextPageToken?: string;
  nextValid?: boolean;
  static names(): { [key: string]: string } {
    return {
      list: 'List',
      nextPageToken: 'NextPageToken',
      nextValid: 'NextValid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      list: QueryDeviceOriginalPropertyStatusResponseBodyDataList,
      nextPageToken: 'string',
      nextValid: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceOriginalServiceDataResponseBodyDataListServiceInfo extends $tea.Model {
  identifier?: string;
  inputData?: string;
  name?: string;
  outputData?: string;
  time?: string;
  static names(): { [key: string]: string } {
    return {
      identifier: 'Identifier',
      inputData: 'InputData',
      name: 'Name',
      outputData: 'OutputData',
      time: 'Time',
    };
  }

  static types(): { [key: string]: any } {
    return {
      identifier: 'string',
      inputData: 'string',
      name: 'string',
      outputData: 'string',
      time: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceOriginalServiceDataResponseBodyDataList extends $tea.Model {
  serviceInfo?: QueryDeviceOriginalServiceDataResponseBodyDataListServiceInfo[];
  static names(): { [key: string]: string } {
    return {
      serviceInfo: 'ServiceInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      serviceInfo: { 'type': 'array', 'itemType': QueryDeviceOriginalServiceDataResponseBodyDataListServiceInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceOriginalServiceDataResponseBodyData extends $tea.Model {
  list?: QueryDeviceOriginalServiceDataResponseBodyDataList;
  nextPageToken?: string;
  nextValid?: boolean;
  static names(): { [key: string]: string } {
    return {
      list: 'List',
      nextPageToken: 'NextPageToken',
      nextValid: 'NextValid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      list: QueryDeviceOriginalServiceDataResponseBodyDataList,
      nextPageToken: 'string',
      nextValid: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfoListPropertyInfo extends $tea.Model {
  time?: number;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      time: 'Time',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      time: 'number',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfoList extends $tea.Model {
  propertyInfo?: QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfoListPropertyInfo[];
  static names(): { [key: string]: string } {
    return {
      propertyInfo: 'PropertyInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      propertyInfo: { 'type': 'array', 'itemType': QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfoListPropertyInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfo extends $tea.Model {
  identifier?: string;
  list?: QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfoList;
  static names(): { [key: string]: string } {
    return {
      identifier: 'Identifier',
      list: 'List',
    };
  }

  static types(): { [key: string]: any } {
    return {
      identifier: 'string',
      list: QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfoList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicePropertiesDataResponseBodyPropertyDataInfos extends $tea.Model {
  propertyDataInfo?: QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfo[];
  static names(): { [key: string]: string } {
    return {
      propertyDataInfo: 'PropertyDataInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      propertyDataInfo: { 'type': 'array', 'itemType': QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicePropertyDataResponseBodyDataListPropertyInfo extends $tea.Model {
  time?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      time: 'Time',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      time: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicePropertyDataResponseBodyDataList extends $tea.Model {
  propertyInfo?: QueryDevicePropertyDataResponseBodyDataListPropertyInfo[];
  static names(): { [key: string]: string } {
    return {
      propertyInfo: 'PropertyInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      propertyInfo: { 'type': 'array', 'itemType': QueryDevicePropertyDataResponseBodyDataListPropertyInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicePropertyDataResponseBodyData extends $tea.Model {
  list?: QueryDevicePropertyDataResponseBodyDataList;
  nextTime?: number;
  nextValid?: boolean;
  static names(): { [key: string]: string } {
    return {
      list: 'List',
      nextTime: 'NextTime',
      nextValid: 'NextValid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      list: QueryDevicePropertyDataResponseBodyDataList,
      nextTime: 'number',
      nextValid: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicePropertyStatusResponseBodyDataListPropertyStatusInfo extends $tea.Model {
  dataType?: string;
  identifier?: string;
  name?: string;
  time?: string;
  unit?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      dataType: 'DataType',
      identifier: 'Identifier',
      name: 'Name',
      time: 'Time',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataType: 'string',
      identifier: 'string',
      name: 'string',
      time: 'string',
      unit: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicePropertyStatusResponseBodyDataList extends $tea.Model {
  propertyStatusInfo?: QueryDevicePropertyStatusResponseBodyDataListPropertyStatusInfo[];
  static names(): { [key: string]: string } {
    return {
      propertyStatusInfo: 'PropertyStatusInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      propertyStatusInfo: { 'type': 'array', 'itemType': QueryDevicePropertyStatusResponseBodyDataListPropertyStatusInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicePropertyStatusResponseBodyData extends $tea.Model {
  list?: QueryDevicePropertyStatusResponseBodyDataList;
  static names(): { [key: string]: string } {
    return {
      list: 'List',
    };
  }

  static types(): { [key: string]: any } {
    return {
      list: QueryDevicePropertyStatusResponseBodyDataList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceServiceDataResponseBodyDataListServiceInfo extends $tea.Model {
  identifier?: string;
  inputData?: string;
  name?: string;
  outputData?: string;
  time?: string;
  static names(): { [key: string]: string } {
    return {
      identifier: 'Identifier',
      inputData: 'InputData',
      name: 'Name',
      outputData: 'OutputData',
      time: 'Time',
    };
  }

  static types(): { [key: string]: any } {
    return {
      identifier: 'string',
      inputData: 'string',
      name: 'string',
      outputData: 'string',
      time: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceServiceDataResponseBodyDataList extends $tea.Model {
  serviceInfo?: QueryDeviceServiceDataResponseBodyDataListServiceInfo[];
  static names(): { [key: string]: string } {
    return {
      serviceInfo: 'ServiceInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      serviceInfo: { 'type': 'array', 'itemType': QueryDeviceServiceDataResponseBodyDataListServiceInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceServiceDataResponseBodyData extends $tea.Model {
  list?: QueryDeviceServiceDataResponseBodyDataList;
  nextTime?: number;
  nextValid?: boolean;
  static names(): { [key: string]: string } {
    return {
      list: 'List',
      nextTime: 'NextTime',
      nextValid: 'NextValid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      list: QueryDeviceServiceDataResponseBodyDataList,
      nextTime: 'number',
      nextValid: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceStatisticsResponseBodyData extends $tea.Model {
  activeCount?: number;
  deviceCount?: number;
  onlineCount?: number;
  static names(): { [key: string]: string } {
    return {
      activeCount: 'activeCount',
      deviceCount: 'deviceCount',
      onlineCount: 'onlineCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      activeCount: 'number',
      deviceCount: 'number',
      onlineCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeDriverResponseBodyDataDriverList extends $tea.Model {
  cpuArch?: string;
  driverId?: string;
  driverName?: string;
  driverProtocol?: string;
  gmtCreateTimestamp?: number;
  gmtModifiedTimestamp?: number;
  isBuiltIn?: boolean;
  runtime?: string;
  type?: number;
  static names(): { [key: string]: string } {
    return {
      cpuArch: 'CpuArch',
      driverId: 'DriverId',
      driverName: 'DriverName',
      driverProtocol: 'DriverProtocol',
      gmtCreateTimestamp: 'GmtCreateTimestamp',
      gmtModifiedTimestamp: 'GmtModifiedTimestamp',
      isBuiltIn: 'IsBuiltIn',
      runtime: 'Runtime',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cpuArch: 'string',
      driverId: 'string',
      driverName: 'string',
      driverProtocol: 'string',
      gmtCreateTimestamp: 'number',
      gmtModifiedTimestamp: 'number',
      isBuiltIn: 'boolean',
      runtime: 'string',
      type: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeDriverResponseBodyData extends $tea.Model {
  currentPage?: number;
  driverList?: QueryEdgeDriverResponseBodyDataDriverList[];
  pageSize?: number;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      driverList: 'DriverList',
      pageSize: 'PageSize',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      driverList: { 'type': 'array', 'itemType': QueryEdgeDriverResponseBodyDataDriverList },
      pageSize: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeDriverVersionResponseBodyDataDriverVersionList extends $tea.Model {
  argument?: string;
  configCheckRule?: string;
  containerConfig?: string;
  description?: string;
  driverConfig?: string;
  driverId?: string;
  driverVersion?: string;
  edgeVersion?: string;
  gmtCreateTimestamp?: number;
  gmtModifiedTimestamp?: number;
  sourceConfig?: string;
  versionState?: string;
  static names(): { [key: string]: string } {
    return {
      argument: 'Argument',
      configCheckRule: 'ConfigCheckRule',
      containerConfig: 'ContainerConfig',
      description: 'Description',
      driverConfig: 'DriverConfig',
      driverId: 'DriverId',
      driverVersion: 'DriverVersion',
      edgeVersion: 'EdgeVersion',
      gmtCreateTimestamp: 'GmtCreateTimestamp',
      gmtModifiedTimestamp: 'GmtModifiedTimestamp',
      sourceConfig: 'SourceConfig',
      versionState: 'VersionState',
    };
  }

  static types(): { [key: string]: any } {
    return {
      argument: 'string',
      configCheckRule: 'string',
      containerConfig: 'string',
      description: 'string',
      driverConfig: 'string',
      driverId: 'string',
      driverVersion: 'string',
      edgeVersion: 'string',
      gmtCreateTimestamp: 'number',
      gmtModifiedTimestamp: 'number',
      sourceConfig: 'string',
      versionState: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeDriverVersionResponseBodyData extends $tea.Model {
  currentPage?: number;
  driverVersionList?: QueryEdgeDriverVersionResponseBodyDataDriverVersionList[];
  pageSize?: number;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      driverVersionList: 'DriverVersionList',
      pageSize: 'PageSize',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      driverVersionList: { 'type': 'array', 'itemType': QueryEdgeDriverVersionResponseBodyDataDriverVersionList },
      pageSize: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceResponseBodyDataInstanceList extends $tea.Model {
  bizEnable?: boolean;
  gmtCreate?: string;
  gmtCreateTimestamp?: number;
  gmtModified?: string;
  gmtModifiedTimestamp?: number;
  instanceId?: string;
  latestDeploymentStatus?: number;
  latestDeploymentType?: string;
  name?: string;
  roleArn?: string;
  roleAttachTime?: string;
  roleAttachTimestamp?: number;
  roleName?: string;
  spec?: number;
  tags?: string;
  type?: number;
  static names(): { [key: string]: string } {
    return {
      bizEnable: 'BizEnable',
      gmtCreate: 'GmtCreate',
      gmtCreateTimestamp: 'GmtCreateTimestamp',
      gmtModified: 'GmtModified',
      gmtModifiedTimestamp: 'GmtModifiedTimestamp',
      instanceId: 'InstanceId',
      latestDeploymentStatus: 'LatestDeploymentStatus',
      latestDeploymentType: 'LatestDeploymentType',
      name: 'Name',
      roleArn: 'RoleArn',
      roleAttachTime: 'RoleAttachTime',
      roleAttachTimestamp: 'RoleAttachTimestamp',
      roleName: 'RoleName',
      spec: 'Spec',
      tags: 'Tags',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizEnable: 'boolean',
      gmtCreate: 'string',
      gmtCreateTimestamp: 'number',
      gmtModified: 'string',
      gmtModifiedTimestamp: 'number',
      instanceId: 'string',
      latestDeploymentStatus: 'number',
      latestDeploymentType: 'string',
      name: 'string',
      roleArn: 'string',
      roleAttachTime: 'string',
      roleAttachTimestamp: 'number',
      roleName: 'string',
      spec: 'number',
      tags: 'string',
      type: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceResponseBodyData extends $tea.Model {
  currentPage?: number;
  instanceList?: QueryEdgeInstanceResponseBodyDataInstanceList[];
  pageSize?: number;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      instanceList: 'InstanceList',
      pageSize: 'PageSize',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      instanceList: { 'type': 'array', 'itemType': QueryEdgeInstanceResponseBodyDataInstanceList },
      pageSize: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceChannelResponseBodyDataChannelListChannelConfigListConfig extends $tea.Model {
  configId?: string;
  content?: string;
  format?: string;
  key?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      content: 'Content',
      format: 'Format',
      key: 'Key',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'string',
      content: 'string',
      format: 'string',
      key: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceChannelResponseBodyDataChannelListChannelConfigList extends $tea.Model {
  config?: QueryEdgeInstanceChannelResponseBodyDataChannelListChannelConfigListConfig[];
  static names(): { [key: string]: string } {
    return {
      config: 'Config',
    };
  }

  static types(): { [key: string]: any } {
    return {
      config: { 'type': 'array', 'itemType': QueryEdgeInstanceChannelResponseBodyDataChannelListChannelConfigListConfig },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceChannelResponseBodyDataChannelListChannel extends $tea.Model {
  channelId?: string;
  channelName?: string;
  configList?: QueryEdgeInstanceChannelResponseBodyDataChannelListChannelConfigList;
  gmtCreate?: string;
  gmtCreateTimestamp?: number;
  gmtModified?: string;
  gmtModifiedTimestamp?: number;
  static names(): { [key: string]: string } {
    return {
      channelId: 'ChannelId',
      channelName: 'ChannelName',
      configList: 'ConfigList',
      gmtCreate: 'GmtCreate',
      gmtCreateTimestamp: 'GmtCreateTimestamp',
      gmtModified: 'GmtModified',
      gmtModifiedTimestamp: 'GmtModifiedTimestamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelId: 'string',
      channelName: 'string',
      configList: QueryEdgeInstanceChannelResponseBodyDataChannelListChannelConfigList,
      gmtCreate: 'string',
      gmtCreateTimestamp: 'number',
      gmtModified: 'string',
      gmtModifiedTimestamp: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceChannelResponseBodyDataChannelList extends $tea.Model {
  channel?: QueryEdgeInstanceChannelResponseBodyDataChannelListChannel[];
  static names(): { [key: string]: string } {
    return {
      channel: 'Channel',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channel: { 'type': 'array', 'itemType': QueryEdgeInstanceChannelResponseBodyDataChannelListChannel },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceChannelResponseBodyData extends $tea.Model {
  channelList?: QueryEdgeInstanceChannelResponseBodyDataChannelList;
  currentPage?: number;
  pageSize?: number;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      channelList: 'ChannelList',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelList: QueryEdgeInstanceChannelResponseBodyDataChannelList,
      currentPage: 'number',
      pageSize: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceDeviceResponseBodyDataDeviceList extends $tea.Model {
  deviceName?: string;
  driverId?: string;
  iotId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      driverId: 'DriverId',
      iotId: 'IotId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      driverId: 'string',
      iotId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceDeviceResponseBodyData extends $tea.Model {
  currentPage?: number;
  deviceList?: QueryEdgeInstanceDeviceResponseBodyDataDeviceList[];
  pageSize?: number;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      deviceList: 'DeviceList',
      pageSize: 'PageSize',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      deviceList: { 'type': 'array', 'itemType': QueryEdgeInstanceDeviceResponseBodyDataDeviceList },
      pageSize: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceDeviceByDriverResponseBodyDataDeviceList extends $tea.Model {
  iotId?: string;
  static names(): { [key: string]: string } {
    return {
      iotId: 'IotId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceDeviceByDriverResponseBodyData extends $tea.Model {
  currentPage?: number;
  deviceList?: QueryEdgeInstanceDeviceByDriverResponseBodyDataDeviceList[];
  pageSize?: number;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      deviceList: 'DeviceList',
      pageSize: 'PageSize',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      deviceList: { 'type': 'array', 'itemType': QueryEdgeInstanceDeviceByDriverResponseBodyDataDeviceList },
      pageSize: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceDriverResponseBodyDataDriverList extends $tea.Model {
  driverId?: string;
  driverVersion?: string;
  gmtCreate?: string;
  gmtModified?: string;
  orderId?: string;
  static names(): { [key: string]: string } {
    return {
      driverId: 'DriverId',
      driverVersion: 'DriverVersion',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      orderId: 'OrderId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      driverId: 'string',
      driverVersion: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      orderId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceDriverResponseBodyData extends $tea.Model {
  currentPage?: number;
  driverList?: QueryEdgeInstanceDriverResponseBodyDataDriverList[];
  pageSize?: number;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      driverList: 'DriverList',
      pageSize: 'PageSize',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      driverList: { 'type': 'array', 'itemType': QueryEdgeInstanceDriverResponseBodyDataDriverList },
      pageSize: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceGatewayResponseBodyGatewayList extends $tea.Model {
  deviceName?: string;
  edgeVersion?: string;
  iotId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      edgeVersion: 'EdgeVersion',
      iotId: 'IotId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      edgeVersion: 'string',
      iotId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceHistoricDeploymentResponseBodyDataDeploymentList extends $tea.Model {
  deploymentId?: string;
  description?: string;
  gmtCompleted?: string;
  gmtCompletedTimestamp?: number;
  gmtCreate?: string;
  gmtCreateTimestamp?: number;
  gmtModified?: string;
  gmtModifiedTimestamp?: number;
  status?: number;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      deploymentId: 'DeploymentId',
      description: 'Description',
      gmtCompleted: 'GmtCompleted',
      gmtCompletedTimestamp: 'GmtCompletedTimestamp',
      gmtCreate: 'GmtCreate',
      gmtCreateTimestamp: 'GmtCreateTimestamp',
      gmtModified: 'GmtModified',
      gmtModifiedTimestamp: 'GmtModifiedTimestamp',
      status: 'Status',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deploymentId: 'string',
      description: 'string',
      gmtCompleted: 'string',
      gmtCompletedTimestamp: 'number',
      gmtCreate: 'string',
      gmtCreateTimestamp: 'number',
      gmtModified: 'string',
      gmtModifiedTimestamp: 'number',
      status: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceHistoricDeploymentResponseBodyData extends $tea.Model {
  currentPage?: number;
  deploymentList?: QueryEdgeInstanceHistoricDeploymentResponseBodyDataDeploymentList[];
  pageSize?: number;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      deploymentList: 'DeploymentList',
      pageSize: 'PageSize',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      deploymentList: { 'type': 'array', 'itemType': QueryEdgeInstanceHistoricDeploymentResponseBodyDataDeploymentList },
      pageSize: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRouteRouteContext extends $tea.Model {
  qos?: string;
  sourceApplicationName?: string;
  sourceFcFunctionName?: string;
  sourceFcServiceName?: string;
  targetApplicationName?: string;
  targetFcFunctionName?: string;
  targetFcServiceName?: string;
  static names(): { [key: string]: string } {
    return {
      qos: 'Qos',
      sourceApplicationName: 'SourceApplicationName',
      sourceFcFunctionName: 'SourceFcFunctionName',
      sourceFcServiceName: 'SourceFcServiceName',
      targetApplicationName: 'TargetApplicationName',
      targetFcFunctionName: 'TargetFcFunctionName',
      targetFcServiceName: 'TargetFcServiceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      qos: 'string',
      sourceApplicationName: 'string',
      sourceFcFunctionName: 'string',
      sourceFcServiceName: 'string',
      targetApplicationName: 'string',
      targetFcFunctionName: 'string',
      targetFcServiceName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRoute extends $tea.Model {
  gmtCreate?: string;
  gmtCreateTimestamp?: number;
  gmtModified?: string;
  gmtModifiedTimestamp?: number;
  name?: string;
  routeContext?: QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRouteRouteContext;
  routeId?: number;
  sourceData?: string;
  sourceType?: string;
  targetData?: string;
  targetType?: string;
  topicFilter?: string;
  static names(): { [key: string]: string } {
    return {
      gmtCreate: 'GmtCreate',
      gmtCreateTimestamp: 'GmtCreateTimestamp',
      gmtModified: 'GmtModified',
      gmtModifiedTimestamp: 'GmtModifiedTimestamp',
      name: 'Name',
      routeContext: 'RouteContext',
      routeId: 'RouteId',
      sourceData: 'SourceData',
      sourceType: 'SourceType',
      targetData: 'TargetData',
      targetType: 'TargetType',
      topicFilter: 'TopicFilter',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gmtCreate: 'string',
      gmtCreateTimestamp: 'number',
      gmtModified: 'string',
      gmtModifiedTimestamp: 'number',
      name: 'string',
      routeContext: QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRouteRouteContext,
      routeId: 'number',
      sourceData: 'string',
      sourceType: 'string',
      targetData: 'string',
      targetType: 'string',
      topicFilter: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteList extends $tea.Model {
  messageRoute?: QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRoute[];
  static names(): { [key: string]: string } {
    return {
      messageRoute: 'MessageRoute',
    };
  }

  static types(): { [key: string]: any } {
    return {
      messageRoute: { 'type': 'array', 'itemType': QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRoute },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceMessageRoutingResponseBodyData extends $tea.Model {
  currentPage?: number;
  messageRouteList?: QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteList;
  pageSize?: number;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      messageRouteList: 'MessageRouteList',
      pageSize: 'PageSize',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      messageRouteList: QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteList,
      pageSize: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceSceneRuleResponseBodyDataRuleList extends $tea.Model {
  gmtCreate?: number;
  isExisted?: number;
  ruleId?: string;
  ruleName?: string;
  status?: number;
  static names(): { [key: string]: string } {
    return {
      gmtCreate: 'GmtCreate',
      isExisted: 'IsExisted',
      ruleId: 'RuleId',
      ruleName: 'RuleName',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gmtCreate: 'number',
      isExisted: 'number',
      ruleId: 'string',
      ruleName: 'string',
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceSceneRuleResponseBodyData extends $tea.Model {
  currentPage?: number;
  pageSize?: number;
  ruleList?: QueryEdgeInstanceSceneRuleResponseBodyDataRuleList[];
  total?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      ruleList: 'RuleList',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      pageSize: 'number',
      ruleList: { 'type': 'array', 'itemType': QueryEdgeInstanceSceneRuleResponseBodyDataRuleList },
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobResponseBodyDataJobFile extends $tea.Model {
  fileUrl?: string;
  sign?: string;
  signMethod?: string;
  static names(): { [key: string]: string } {
    return {
      fileUrl: 'FileUrl',
      sign: 'Sign',
      signMethod: 'SignMethod',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fileUrl: 'string',
      sign: 'string',
      signMethod: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobResponseBodyDataRolloutConfig extends $tea.Model {
  maximumPerMinute?: number;
  static names(): { [key: string]: string } {
    return {
      maximumPerMinute: 'MaximumPerMinute',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maximumPerMinute: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobResponseBodyDataTargetConfigTargetDevicesTargetDevices extends $tea.Model {
  deviceName?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobResponseBodyDataTargetConfigTargetDevices extends $tea.Model {
  targetDevices?: QueryJobResponseBodyDataTargetConfigTargetDevicesTargetDevices[];
  static names(): { [key: string]: string } {
    return {
      targetDevices: 'targetDevices',
    };
  }

  static types(): { [key: string]: any } {
    return {
      targetDevices: { 'type': 'array', 'itemType': QueryJobResponseBodyDataTargetConfigTargetDevicesTargetDevices },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobResponseBodyDataTargetConfig extends $tea.Model {
  targetDevices?: QueryJobResponseBodyDataTargetConfigTargetDevices;
  targetGroup?: string;
  targetProduct?: string;
  targetType?: string;
  static names(): { [key: string]: string } {
    return {
      targetDevices: 'TargetDevices',
      targetGroup: 'TargetGroup',
      targetProduct: 'TargetProduct',
      targetType: 'TargetType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      targetDevices: QueryJobResponseBodyDataTargetConfigTargetDevices,
      targetGroup: 'string',
      targetProduct: 'string',
      targetType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobResponseBodyDataTimeoutConfig extends $tea.Model {
  inProgressTimeoutInMinutes?: number;
  static names(): { [key: string]: string } {
    return {
      inProgressTimeoutInMinutes: 'InProgressTimeoutInMinutes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      inProgressTimeoutInMinutes: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobResponseBodyData extends $tea.Model {
  description?: string;
  jobDocument?: string;
  jobFile?: QueryJobResponseBodyDataJobFile;
  jobId?: string;
  jobName?: string;
  rolloutConfig?: QueryJobResponseBodyDataRolloutConfig;
  scheduledTime?: number;
  status?: string;
  targetConfig?: QueryJobResponseBodyDataTargetConfig;
  timeoutConfig?: QueryJobResponseBodyDataTimeoutConfig;
  type?: string;
  utcCreate?: string;
  utcModified?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      jobDocument: 'JobDocument',
      jobFile: 'JobFile',
      jobId: 'JobId',
      jobName: 'JobName',
      rolloutConfig: 'RolloutConfig',
      scheduledTime: 'ScheduledTime',
      status: 'Status',
      targetConfig: 'TargetConfig',
      timeoutConfig: 'TimeoutConfig',
      type: 'Type',
      utcCreate: 'UtcCreate',
      utcModified: 'UtcModified',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      jobDocument: 'string',
      jobFile: QueryJobResponseBodyDataJobFile,
      jobId: 'string',
      jobName: 'string',
      rolloutConfig: QueryJobResponseBodyDataRolloutConfig,
      scheduledTime: 'number',
      status: 'string',
      targetConfig: QueryJobResponseBodyDataTargetConfig,
      timeoutConfig: QueryJobResponseBodyDataTimeoutConfig,
      type: 'string',
      utcCreate: 'string',
      utcModified: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobStatisticsResponseBodyData extends $tea.Model {
  cancelled?: number;
  failed?: number;
  inProgress?: number;
  queued?: number;
  rejected?: number;
  sent?: number;
  succeeded?: number;
  timeOut?: number;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      cancelled: 'Cancelled',
      failed: 'Failed',
      inProgress: 'InProgress',
      queued: 'Queued',
      rejected: 'Rejected',
      sent: 'Sent',
      succeeded: 'Succeeded',
      timeOut: 'TimeOut',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cancelled: 'number',
      failed: 'number',
      inProgress: 'number',
      queued: 'number',
      rejected: 'number',
      sent: 'number',
      succeeded: 'number',
      timeOut: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryLoRaJoinPermissionsResponseBodyJoinPermissionsJoinPermission extends $tea.Model {
  classMode?: string;
  enabled?: boolean;
  joinPermissionId?: string;
  joinPermissionName?: string;
  joinPermissionType?: string;
  ownerAliyunPk?: string;
  static names(): { [key: string]: string } {
    return {
      classMode: 'ClassMode',
      enabled: 'Enabled',
      joinPermissionId: 'JoinPermissionId',
      joinPermissionName: 'JoinPermissionName',
      joinPermissionType: 'JoinPermissionType',
      ownerAliyunPk: 'OwnerAliyunPk',
    };
  }

  static types(): { [key: string]: any } {
    return {
      classMode: 'string',
      enabled: 'boolean',
      joinPermissionId: 'string',
      joinPermissionName: 'string',
      joinPermissionType: 'string',
      ownerAliyunPk: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryLoRaJoinPermissionsResponseBodyJoinPermissions extends $tea.Model {
  joinPermission?: QueryLoRaJoinPermissionsResponseBodyJoinPermissionsJoinPermission[];
  static names(): { [key: string]: string } {
    return {
      joinPermission: 'JoinPermission',
    };
  }

  static types(): { [key: string]: any } {
    return {
      joinPermission: { 'type': 'array', 'itemType': QueryLoRaJoinPermissionsResponseBodyJoinPermissionsJoinPermission },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMessageInfoResponseBodyMessageUserProperties extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMessageInfoResponseBodyMessage extends $tea.Model {
  generateTime?: number;
  messageContent?: string;
  topicFullName?: string;
  uniMsgId?: string;
  userProperties?: QueryMessageInfoResponseBodyMessageUserProperties[];
  static names(): { [key: string]: string } {
    return {
      generateTime: 'GenerateTime',
      messageContent: 'MessageContent',
      topicFullName: 'TopicFullName',
      uniMsgId: 'UniMsgId',
      userProperties: 'UserProperties',
    };
  }

  static types(): { [key: string]: any } {
    return {
      generateTime: 'number',
      messageContent: 'string',
      topicFullName: 'string',
      uniMsgId: 'string',
      userProperties: { 'type': 'array', 'itemType': QueryMessageInfoResponseBodyMessageUserProperties },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryOTAFirmwareResponseBodyFirmwareInfo extends $tea.Model {
  destVersion?: string;
  firmwareDesc?: string;
  firmwareId?: string;
  firmwareName?: string;
  firmwareSign?: string;
  firmwareSize?: number;
  firmwareUrl?: string;
  moduleName?: string;
  productKey?: string;
  productName?: string;
  signMethod?: string;
  srcVersion?: string;
  status?: number;
  type?: number;
  udi?: string;
  utcCreate?: string;
  utcModified?: string;
  verifyProgress?: number;
  static names(): { [key: string]: string } {
    return {
      destVersion: 'DestVersion',
      firmwareDesc: 'FirmwareDesc',
      firmwareId: 'FirmwareId',
      firmwareName: 'FirmwareName',
      firmwareSign: 'FirmwareSign',
      firmwareSize: 'FirmwareSize',
      firmwareUrl: 'FirmwareUrl',
      moduleName: 'ModuleName',
      productKey: 'ProductKey',
      productName: 'ProductName',
      signMethod: 'SignMethod',
      srcVersion: 'SrcVersion',
      status: 'Status',
      type: 'Type',
      udi: 'Udi',
      utcCreate: 'UtcCreate',
      utcModified: 'UtcModified',
      verifyProgress: 'VerifyProgress',
    };
  }

  static types(): { [key: string]: any } {
    return {
      destVersion: 'string',
      firmwareDesc: 'string',
      firmwareId: 'string',
      firmwareName: 'string',
      firmwareSign: 'string',
      firmwareSize: 'number',
      firmwareUrl: 'string',
      moduleName: 'string',
      productKey: 'string',
      productName: 'string',
      signMethod: 'string',
      srcVersion: 'string',
      status: 'number',
      type: 'number',
      udi: 'string',
      utcCreate: 'string',
      utcModified: 'string',
      verifyProgress: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryOTAJobResponseBodyDataSrcVersions extends $tea.Model {
  srcVersion?: string[];
  static names(): { [key: string]: string } {
    return {
      srcVersion: 'SrcVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      srcVersion: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryOTAJobResponseBodyDataTagsOtaTagDTO extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryOTAJobResponseBodyDataTags extends $tea.Model {
  otaTagDTO?: QueryOTAJobResponseBodyDataTagsOtaTagDTO[];
  static names(): { [key: string]: string } {
    return {
      otaTagDTO: 'OtaTagDTO',
    };
  }

  static types(): { [key: string]: any } {
    return {
      otaTagDTO: { 'type': 'array', 'itemType': QueryOTAJobResponseBodyDataTagsOtaTagDTO },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryOTAJobResponseBodyData extends $tea.Model {
  destVersion?: string;
  dynamicMode?: number;
  firmwareId?: string;
  grayPercent?: string;
  jobDesc?: string;
  jobId?: string;
  jobStatus?: string;
  jobType?: string;
  maximumPerMinute?: number;
  name?: string;
  needConfirm?: boolean;
  needPush?: boolean;
  overwriteMode?: number;
  productKey?: string;
  retryCount?: number;
  retryInterval?: number;
  selectionType?: string;
  srcVersions?: QueryOTAJobResponseBodyDataSrcVersions;
  tags?: QueryOTAJobResponseBodyDataTags;
  targetSelection?: string;
  timeoutInMinutes?: number;
  utcCreate?: string;
  utcEndTime?: string;
  utcModified?: string;
  utcScheduleFinishTime?: string;
  utcScheduleTime?: string;
  utcStartTime?: string;
  static names(): { [key: string]: string } {
    return {
      destVersion: 'DestVersion',
      dynamicMode: 'DynamicMode',
      firmwareId: 'FirmwareId',
      grayPercent: 'GrayPercent',
      jobDesc: 'JobDesc',
      jobId: 'JobId',
      jobStatus: 'JobStatus',
      jobType: 'JobType',
      maximumPerMinute: 'MaximumPerMinute',
      name: 'Name',
      needConfirm: 'NeedConfirm',
      needPush: 'NeedPush',
      overwriteMode: 'OverwriteMode',
      productKey: 'ProductKey',
      retryCount: 'RetryCount',
      retryInterval: 'RetryInterval',
      selectionType: 'SelectionType',
      srcVersions: 'SrcVersions',
      tags: 'Tags',
      targetSelection: 'TargetSelection',
      timeoutInMinutes: 'TimeoutInMinutes',
      utcCreate: 'UtcCreate',
      utcEndTime: 'UtcEndTime',
      utcModified: 'UtcModified',
      utcScheduleFinishTime: 'UtcScheduleFinishTime',
      utcScheduleTime: 'UtcScheduleTime',
      utcStartTime: 'UtcStartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      destVersion: 'string',
      dynamicMode: 'number',
      firmwareId: 'string',
      grayPercent: 'string',
      jobDesc: 'string',
      jobId: 'string',
      jobStatus: 'string',
      jobType: 'string',
      maximumPerMinute: 'number',
      name: 'string',
      needConfirm: 'boolean',
      needPush: 'boolean',
      overwriteMode: 'number',
      productKey: 'string',
      retryCount: 'number',
      retryInterval: 'number',
      selectionType: 'string',
      srcVersions: QueryOTAJobResponseBodyDataSrcVersions,
      tags: QueryOTAJobResponseBodyDataTags,
      targetSelection: 'string',
      timeoutInMinutes: 'number',
      utcCreate: 'string',
      utcEndTime: 'string',
      utcModified: 'string',
      utcScheduleFinishTime: 'string',
      utcScheduleTime: 'string',
      utcStartTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryPageByApplyIdResponseBodyApplyDeviceListApplyDeviceInfo extends $tea.Model {
  deviceId?: string;
  deviceName?: string;
  deviceSecret?: string;
  iotId?: string;
  static names(): { [key: string]: string } {
    return {
      deviceId: 'DeviceId',
      deviceName: 'DeviceName',
      deviceSecret: 'DeviceSecret',
      iotId: 'IotId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceId: 'string',
      deviceName: 'string',
      deviceSecret: 'string',
      iotId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryPageByApplyIdResponseBodyApplyDeviceList extends $tea.Model {
  applyDeviceInfo?: QueryPageByApplyIdResponseBodyApplyDeviceListApplyDeviceInfo[];
  static names(): { [key: string]: string } {
    return {
      applyDeviceInfo: 'ApplyDeviceInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applyDeviceInfo: { 'type': 'array', 'itemType': QueryPageByApplyIdResponseBodyApplyDeviceListApplyDeviceInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryProductResponseBodyData extends $tea.Model {
  aliyunCommodityCode?: string;
  authType?: string;
  categoryKey?: string;
  categoryName?: string;
  dataFormat?: number;
  description?: string;
  deviceCount?: number;
  gmtCreate?: number;
  id2?: boolean;
  netType?: number;
  nodeType?: number;
  owner?: boolean;
  productKey?: string;
  productName?: string;
  productSecret?: string;
  productStatus?: string;
  protocolType?: string;
  validateType?: number;
  static names(): { [key: string]: string } {
    return {
      aliyunCommodityCode: 'AliyunCommodityCode',
      authType: 'AuthType',
      categoryKey: 'CategoryKey',
      categoryName: 'CategoryName',
      dataFormat: 'DataFormat',
      description: 'Description',
      deviceCount: 'DeviceCount',
      gmtCreate: 'GmtCreate',
      id2: 'Id2',
      netType: 'NetType',
      nodeType: 'NodeType',
      owner: 'Owner',
      productKey: 'ProductKey',
      productName: 'ProductName',
      productSecret: 'ProductSecret',
      productStatus: 'ProductStatus',
      protocolType: 'ProtocolType',
      validateType: 'ValidateType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunCommodityCode: 'string',
      authType: 'string',
      categoryKey: 'string',
      categoryName: 'string',
      dataFormat: 'number',
      description: 'string',
      deviceCount: 'number',
      gmtCreate: 'number',
      id2: 'boolean',
      netType: 'number',
      nodeType: 'number',
      owner: 'boolean',
      productKey: 'string',
      productName: 'string',
      productSecret: 'string',
      productStatus: 'string',
      protocolType: 'string',
      validateType: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryProductCertInfoResponseBodyProductCertInfo extends $tea.Model {
  issueModel?: number;
  static names(): { [key: string]: string } {
    return {
      issueModel: 'IssueModel',
    };
  }

  static types(): { [key: string]: any } {
    return {
      issueModel: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryProductListResponseBodyDataListProductInfo extends $tea.Model {
  authType?: string;
  dataFormat?: number;
  description?: string;
  deviceCount?: number;
  gmtCreate?: number;
  nodeType?: number;
  productKey?: string;
  productName?: string;
  static names(): { [key: string]: string } {
    return {
      authType: 'AuthType',
      dataFormat: 'DataFormat',
      description: 'Description',
      deviceCount: 'DeviceCount',
      gmtCreate: 'GmtCreate',
      nodeType: 'NodeType',
      productKey: 'ProductKey',
      productName: 'ProductName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authType: 'string',
      dataFormat: 'number',
      description: 'string',
      deviceCount: 'number',
      gmtCreate: 'number',
      nodeType: 'number',
      productKey: 'string',
      productName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryProductListResponseBodyDataList extends $tea.Model {
  productInfo?: QueryProductListResponseBodyDataListProductInfo[];
  static names(): { [key: string]: string } {
    return {
      productInfo: 'ProductInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      productInfo: { 'type': 'array', 'itemType': QueryProductListResponseBodyDataListProductInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryProductListResponseBodyData extends $tea.Model {
  currentPage?: number;
  list?: QueryProductListResponseBodyDataList;
  pageCount?: number;
  pageSize?: number;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      list: 'List',
      pageCount: 'PageCount',
      pageSize: 'PageSize',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      list: QueryProductListResponseBodyDataList,
      pageCount: 'number',
      pageSize: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryProductTopicResponseBodyDataProductTopicInfo extends $tea.Model {
  desc?: string;
  id?: string;
  operation?: string;
  productKey?: string;
  topicShortName?: string;
  static names(): { [key: string]: string } {
    return {
      desc: 'Desc',
      id: 'Id',
      operation: 'Operation',
      productKey: 'ProductKey',
      topicShortName: 'TopicShortName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      desc: 'string',
      id: 'string',
      operation: 'string',
      productKey: 'string',
      topicShortName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryProductTopicResponseBodyData extends $tea.Model {
  productTopicInfo?: QueryProductTopicResponseBodyDataProductTopicInfo[];
  static names(): { [key: string]: string } {
    return {
      productTopicInfo: 'ProductTopicInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      productTopicInfo: { 'type': 'array', 'itemType': QueryProductTopicResponseBodyDataProductTopicInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySceneRuleResponseBodyDataRuleList extends $tea.Model {
  gmtCreate?: number;
  gmtModified?: number;
  ruleDescription?: string;
  ruleId?: string;
  ruleName?: string;
  ruleStatus?: number;
  static names(): { [key: string]: string } {
    return {
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      ruleDescription: 'RuleDescription',
      ruleId: 'RuleId',
      ruleName: 'RuleName',
      ruleStatus: 'RuleStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gmtCreate: 'number',
      gmtModified: 'number',
      ruleDescription: 'string',
      ruleId: 'string',
      ruleName: 'string',
      ruleStatus: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySceneRuleResponseBodyData extends $tea.Model {
  currentPage?: number;
  pageSize?: number;
  ruleList?: QuerySceneRuleResponseBodyDataRuleList[];
  total?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      ruleList: 'RuleList',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      pageSize: 'number',
      ruleList: { 'type': 'array', 'itemType': QuerySceneRuleResponseBodyDataRuleList },
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySolutionDeviceGroupPageResponseBodyDataListItemName extends $tea.Model {
  deviceCount?: number;
  gmtCreate?: number;
  gmtModified?: number;
  groupDesc?: string;
  groupId?: string;
  groupName?: string;
  static names(): { [key: string]: string } {
    return {
      deviceCount: 'DeviceCount',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      groupDesc: 'GroupDesc',
      groupId: 'GroupId',
      groupName: 'GroupName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceCount: 'number',
      gmtCreate: 'number',
      gmtModified: 'number',
      groupDesc: 'string',
      groupId: 'string',
      groupName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySolutionDeviceGroupPageResponseBodyDataList extends $tea.Model {
  itemName?: QuerySolutionDeviceGroupPageResponseBodyDataListItemName[];
  static names(): { [key: string]: string } {
    return {
      itemName: 'itemName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      itemName: { 'type': 'array', 'itemType': QuerySolutionDeviceGroupPageResponseBodyDataListItemName },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySolutionDeviceGroupPageResponseBodyData extends $tea.Model {
  list?: QuerySolutionDeviceGroupPageResponseBodyDataList;
  pageId?: number;
  pageSize?: number;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      list: 'List',
      pageId: 'PageId',
      pageSize: 'PageSize',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      list: QuerySolutionDeviceGroupPageResponseBodyDataList,
      pageId: 'number',
      pageSize: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechResponseBodyData extends $tea.Model {
  audioFormat?: string;
  bizCode?: string;
  speechCode?: string;
  speechRate?: number;
  speechType?: string;
  text?: string;
  voice?: string;
  volume?: number;
  static names(): { [key: string]: string } {
    return {
      audioFormat: 'AudioFormat',
      bizCode: 'BizCode',
      speechCode: 'SpeechCode',
      speechRate: 'SpeechRate',
      speechType: 'SpeechType',
      text: 'Text',
      voice: 'Voice',
      volume: 'Volume',
    };
  }

  static types(): { [key: string]: any } {
    return {
      audioFormat: 'string',
      bizCode: 'string',
      speechCode: 'string',
      speechRate: 'number',
      speechType: 'string',
      text: 'string',
      voice: 'string',
      volume: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechListResponseBodyDataListItemsSpeechListItems extends $tea.Model {
  bizCode?: string;
  speechCode?: string;
  text?: string;
  voice?: string;
  static names(): { [key: string]: string } {
    return {
      bizCode: 'BizCode',
      speechCode: 'SpeechCode',
      text: 'Text',
      voice: 'Voice',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizCode: 'string',
      speechCode: 'string',
      text: 'string',
      voice: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechListResponseBodyDataListItemsSpeechList extends $tea.Model {
  items?: QuerySpeechListResponseBodyDataListItemsSpeechListItems[];
  static names(): { [key: string]: string } {
    return {
      items: 'Items',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: { 'type': 'array', 'itemType': QuerySpeechListResponseBodyDataListItemsSpeechListItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechListResponseBodyDataListItems extends $tea.Model {
  bizCode?: string;
  speechCode?: string;
  speechList?: QuerySpeechListResponseBodyDataListItemsSpeechList;
  speechType?: string;
  text?: string;
  voice?: string;
  static names(): { [key: string]: string } {
    return {
      bizCode: 'BizCode',
      speechCode: 'SpeechCode',
      speechList: 'SpeechList',
      speechType: 'SpeechType',
      text: 'Text',
      voice: 'Voice',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizCode: 'string',
      speechCode: 'string',
      speechList: QuerySpeechListResponseBodyDataListItemsSpeechList,
      speechType: 'string',
      text: 'string',
      voice: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechListResponseBodyDataList extends $tea.Model {
  items?: QuerySpeechListResponseBodyDataListItems[];
  static names(): { [key: string]: string } {
    return {
      items: 'Items',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: { 'type': 'array', 'itemType': QuerySpeechListResponseBodyDataListItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechListResponseBodyData extends $tea.Model {
  list?: QuerySpeechListResponseBodyDataList;
  pageId?: number;
  pageSize?: number;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      list: 'List',
      pageId: 'PageId',
      pageSize: 'PageSize',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      list: QuerySpeechListResponseBodyDataList,
      pageId: 'number',
      pageSize: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechPushJobResponseBodyDataListItems extends $tea.Model {
  code?: string;
  createdTime?: number;
  deviceName?: string;
  expiredTime?: number;
  failDeviceNum?: number;
  groupId?: string;
  groupName?: string;
  iotId?: string;
  productKey?: string;
  pushMode?: string;
  runningDeviceNum?: number;
  speechNum?: number;
  speechStatus?: boolean;
  status?: string;
  successDeviceNum?: number;
  totalDeviceNum?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      createdTime: 'CreatedTime',
      deviceName: 'DeviceName',
      expiredTime: 'ExpiredTime',
      failDeviceNum: 'FailDeviceNum',
      groupId: 'GroupId',
      groupName: 'GroupName',
      iotId: 'IotId',
      productKey: 'ProductKey',
      pushMode: 'PushMode',
      runningDeviceNum: 'RunningDeviceNum',
      speechNum: 'SpeechNum',
      speechStatus: 'SpeechStatus',
      status: 'Status',
      successDeviceNum: 'SuccessDeviceNum',
      totalDeviceNum: 'TotalDeviceNum',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      createdTime: 'number',
      deviceName: 'string',
      expiredTime: 'number',
      failDeviceNum: 'number',
      groupId: 'string',
      groupName: 'string',
      iotId: 'string',
      productKey: 'string',
      pushMode: 'string',
      runningDeviceNum: 'number',
      speechNum: 'number',
      speechStatus: 'boolean',
      status: 'string',
      successDeviceNum: 'number',
      totalDeviceNum: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechPushJobResponseBodyDataList extends $tea.Model {
  items?: QuerySpeechPushJobResponseBodyDataListItems[];
  static names(): { [key: string]: string } {
    return {
      items: 'Items',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: { 'type': 'array', 'itemType': QuerySpeechPushJobResponseBodyDataListItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechPushJobResponseBodyData extends $tea.Model {
  list?: QuerySpeechPushJobResponseBodyDataList;
  pageId?: number;
  pageSize?: number;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      list: 'List',
      pageId: 'PageId',
      pageSize: 'PageSize',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      list: QuerySpeechPushJobResponseBodyDataList,
      pageId: 'number',
      pageSize: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechPushJobDeviceResponseBodyDataListItems extends $tea.Model {
  deviceName?: string;
  errorCode?: string;
  errorMessage?: string;
  gmtModified?: number;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      gmtModified: 'GmtModified',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      errorCode: 'string',
      errorMessage: 'string',
      gmtModified: 'number',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechPushJobDeviceResponseBodyDataList extends $tea.Model {
  items?: QuerySpeechPushJobDeviceResponseBodyDataListItems[];
  static names(): { [key: string]: string } {
    return {
      items: 'Items',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: { 'type': 'array', 'itemType': QuerySpeechPushJobDeviceResponseBodyDataListItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechPushJobDeviceResponseBodyData extends $tea.Model {
  list?: QuerySpeechPushJobDeviceResponseBodyDataList;
  pageId?: number;
  pageSize?: number;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      list: 'List',
      pageId: 'PageId',
      pageSize: 'PageSize',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      list: QuerySpeechPushJobDeviceResponseBodyDataList,
      pageId: 'number',
      pageSize: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechPushJobSpeechResponseBodyDataListItemsSpeechListItems extends $tea.Model {
  bizCode?: string;
  text?: string;
  voice?: string;
  static names(): { [key: string]: string } {
    return {
      bizCode: 'BizCode',
      text: 'Text',
      voice: 'Voice',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizCode: 'string',
      text: 'string',
      voice: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechPushJobSpeechResponseBodyDataListItemsSpeechList extends $tea.Model {
  items?: QuerySpeechPushJobSpeechResponseBodyDataListItemsSpeechListItems[];
  static names(): { [key: string]: string } {
    return {
      items: 'Items',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: { 'type': 'array', 'itemType': QuerySpeechPushJobSpeechResponseBodyDataListItemsSpeechListItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechPushJobSpeechResponseBodyDataListItems extends $tea.Model {
  bizCode?: string;
  speechList?: QuerySpeechPushJobSpeechResponseBodyDataListItemsSpeechList;
  speechType?: string;
  text?: string;
  voice?: string;
  static names(): { [key: string]: string } {
    return {
      bizCode: 'BizCode',
      speechList: 'SpeechList',
      speechType: 'SpeechType',
      text: 'Text',
      voice: 'Voice',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizCode: 'string',
      speechList: QuerySpeechPushJobSpeechResponseBodyDataListItemsSpeechList,
      speechType: 'string',
      text: 'string',
      voice: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechPushJobSpeechResponseBodyDataList extends $tea.Model {
  items?: QuerySpeechPushJobSpeechResponseBodyDataListItems[];
  static names(): { [key: string]: string } {
    return {
      items: 'Items',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: { 'type': 'array', 'itemType': QuerySpeechPushJobSpeechResponseBodyDataListItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechPushJobSpeechResponseBodyData extends $tea.Model {
  list?: QuerySpeechPushJobSpeechResponseBodyDataList;
  pageId?: number;
  pageSize?: number;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      list: 'List',
      pageId: 'PageId',
      pageSize: 'PageSize',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      list: QuerySpeechPushJobSpeechResponseBodyDataList,
      pageId: 'number',
      pageSize: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryStudioAppDomainListOpenResponseBodyDataListDomainInfo extends $tea.Model {
  appId?: string;
  gmtCreate?: string;
  gmtModified?: string;
  host?: string;
  id?: number;
  isBeian?: string;
  projectId?: string;
  protocol?: string;
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      host: 'Host',
      id: 'Id',
      isBeian: 'IsBeian',
      projectId: 'ProjectId',
      protocol: 'Protocol',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      host: 'string',
      id: 'number',
      isBeian: 'string',
      projectId: 'string',
      protocol: 'string',
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryStudioAppDomainListOpenResponseBodyDataList extends $tea.Model {
  domainInfo?: QueryStudioAppDomainListOpenResponseBodyDataListDomainInfo[];
  static names(): { [key: string]: string } {
    return {
      domainInfo: 'DomainInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainInfo: { 'type': 'array', 'itemType': QueryStudioAppDomainListOpenResponseBodyDataListDomainInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryStudioAppDomainListOpenResponseBodyData extends $tea.Model {
  list?: QueryStudioAppDomainListOpenResponseBodyDataList;
  pageNo?: number;
  pageSize?: number;
  total?: number;
  totalPage?: number;
  static names(): { [key: string]: string } {
    return {
      list: 'List',
      pageNo: 'PageNo',
      pageSize: 'PageSize',
      total: 'Total',
      totalPage: 'TotalPage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      list: QueryStudioAppDomainListOpenResponseBodyDataList,
      pageNo: 'number',
      pageSize: 'number',
      total: 'number',
      totalPage: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryStudioAppListResponseBodyDataListAppInfo extends $tea.Model {
  appId?: string;
  appKey?: string;
  appSecret?: string;
  description?: string;
  gmtCreate?: string;
  gmtModified?: string;
  gmtRelease?: string;
  name?: string;
  projectId?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      appKey: 'AppKey',
      appSecret: 'AppSecret',
      description: 'Description',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      gmtRelease: 'GmtRelease',
      name: 'Name',
      projectId: 'ProjectId',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      appKey: 'string',
      appSecret: 'string',
      description: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      gmtRelease: 'string',
      name: 'string',
      projectId: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryStudioAppListResponseBodyDataList extends $tea.Model {
  appInfo?: QueryStudioAppListResponseBodyDataListAppInfo[];
  static names(): { [key: string]: string } {
    return {
      appInfo: 'AppInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appInfo: { 'type': 'array', 'itemType': QueryStudioAppListResponseBodyDataListAppInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryStudioAppListResponseBodyData extends $tea.Model {
  list?: QueryStudioAppListResponseBodyDataList;
  pageNo?: number;
  pageSize?: number;
  total?: number;
  totalPage?: number;
  static names(): { [key: string]: string } {
    return {
      list: 'List',
      pageNo: 'PageNo',
      pageSize: 'PageSize',
      total: 'Total',
      totalPage: 'TotalPage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      list: QueryStudioAppListResponseBodyDataList,
      pageNo: 'number',
      pageSize: 'number',
      total: 'number',
      totalPage: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryStudioAppPageListOpenResponseBodyDataListPageInfo extends $tea.Model {
  gmtCreate?: string;
  gmtModified?: string;
  id?: number;
  isHidden?: number;
  isHome?: number;
  isLoginPage?: number;
  name?: string;
  pageId?: string;
  path?: string;
  static names(): { [key: string]: string } {
    return {
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      id: 'Id',
      isHidden: 'IsHidden',
      isHome: 'IsHome',
      isLoginPage: 'IsLoginPage',
      name: 'Name',
      pageId: 'PageId',
      path: 'Path',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gmtCreate: 'string',
      gmtModified: 'string',
      id: 'number',
      isHidden: 'number',
      isHome: 'number',
      isLoginPage: 'number',
      name: 'string',
      pageId: 'string',
      path: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryStudioAppPageListOpenResponseBodyDataList extends $tea.Model {
  pageInfo?: QueryStudioAppPageListOpenResponseBodyDataListPageInfo[];
  static names(): { [key: string]: string } {
    return {
      pageInfo: 'PageInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageInfo: { 'type': 'array', 'itemType': QueryStudioAppPageListOpenResponseBodyDataListPageInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryStudioAppPageListOpenResponseBodyData extends $tea.Model {
  list?: QueryStudioAppPageListOpenResponseBodyDataList;
  pageNo?: number;
  pageSize?: number;
  total?: number;
  totalPage?: number;
  static names(): { [key: string]: string } {
    return {
      list: 'List',
      pageNo: 'PageNo',
      pageSize: 'PageSize',
      total: 'Total',
      totalPage: 'TotalPage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      list: QueryStudioAppPageListOpenResponseBodyDataList,
      pageNo: 'number',
      pageSize: 'number',
      total: 'number',
      totalPage: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryStudioProjectListResponseBodyDataListProjectInfo extends $tea.Model {
  description?: string;
  gmtCreate?: number;
  gmtModified?: number;
  name?: string;
  projectId?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      name: 'Name',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      gmtCreate: 'number',
      gmtModified: 'number',
      name: 'string',
      projectId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryStudioProjectListResponseBodyDataList extends $tea.Model {
  projectInfo?: QueryStudioProjectListResponseBodyDataListProjectInfo[];
  static names(): { [key: string]: string } {
    return {
      projectInfo: 'ProjectInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      projectInfo: { 'type': 'array', 'itemType': QueryStudioProjectListResponseBodyDataListProjectInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryStudioProjectListResponseBodyData extends $tea.Model {
  list?: QueryStudioProjectListResponseBodyDataList;
  pageNo?: number;
  pageSize?: number;
  total?: number;
  totalPage?: number;
  static names(): { [key: string]: string } {
    return {
      list: 'List',
      pageNo: 'PageNo',
      pageSize: 'PageSize',
      total: 'Total',
      totalPage: 'TotalPage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      list: QueryStudioProjectListResponseBodyDataList,
      pageNo: 'number',
      pageSize: 'number',
      total: 'number',
      totalPage: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySummarySceneRuleLogResponseBodyDataLogListLogInfo extends $tea.Model {
  logTime?: number;
  result?: string;
  traceId?: string;
  static names(): { [key: string]: string } {
    return {
      logTime: 'LogTime',
      result: 'Result',
      traceId: 'TraceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      logTime: 'number',
      result: 'string',
      traceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySummarySceneRuleLogResponseBodyDataLogList extends $tea.Model {
  logInfo?: QuerySummarySceneRuleLogResponseBodyDataLogListLogInfo[];
  static names(): { [key: string]: string } {
    return {
      logInfo: 'LogInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      logInfo: { 'type': 'array', 'itemType': QuerySummarySceneRuleLogResponseBodyDataLogListLogInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySummarySceneRuleLogResponseBodyData extends $tea.Model {
  currentPage?: number;
  logList?: QuerySummarySceneRuleLogResponseBodyDataLogList;
  pageSize?: number;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      logList: 'LogList',
      pageSize: 'PageSize',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      logList: QuerySummarySceneRuleLogResponseBodyDataLogList,
      pageSize: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySuperDeviceGroupResponseBodyDataGroupInfo extends $tea.Model {
  groupDesc?: string;
  groupId?: string;
  groupName?: string;
  static names(): { [key: string]: string } {
    return {
      groupDesc: 'GroupDesc',
      groupId: 'GroupId',
      groupName: 'GroupName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupDesc: 'string',
      groupId: 'string',
      groupName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySuperDeviceGroupResponseBodyData extends $tea.Model {
  groupInfo?: QuerySuperDeviceGroupResponseBodyDataGroupInfo[];
  static names(): { [key: string]: string } {
    return {
      groupInfo: 'GroupInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupInfo: { 'type': 'array', 'itemType': QuerySuperDeviceGroupResponseBodyDataGroupInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTaskResponseBodyData extends $tea.Model {
  deviceName?: string;
  iotId?: string;
  jobId?: string;
  jobName?: string;
  message?: string;
  productKey?: string;
  progress?: string;
  status?: string;
  statusDetail?: string;
  taskId?: string;
  utcModified?: string;
  utcQueueTime?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      jobId: 'JobId',
      jobName: 'JobName',
      message: 'Message',
      productKey: 'ProductKey',
      progress: 'Progress',
      status: 'Status',
      statusDetail: 'StatusDetail',
      taskId: 'TaskId',
      utcModified: 'UtcModified',
      utcQueueTime: 'UtcQueueTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      jobId: 'string',
      jobName: 'string',
      message: 'string',
      productKey: 'string',
      progress: 'string',
      status: 'string',
      statusDetail: 'string',
      taskId: 'string',
      utcModified: 'string',
      utcQueueTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryThingModelResponseBodyData extends $tea.Model {
  thingModelJson?: string;
  static names(): { [key: string]: string } {
    return {
      thingModelJson: 'ThingModelJson',
    };
  }

  static types(): { [key: string]: any } {
    return {
      thingModelJson: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryThingModelExtendConfigResponseBodyData extends $tea.Model {
  configuration?: string;
  static names(): { [key: string]: string } {
    return {
      configuration: 'Configuration',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configuration: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryThingModelExtendConfigPublishedResponseBodyData extends $tea.Model {
  configuration?: string;
  static names(): { [key: string]: string } {
    return {
      configuration: 'Configuration',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configuration: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryThingModelPublishedResponseBodyData extends $tea.Model {
  thingModelJson?: string;
  static names(): { [key: string]: string } {
    return {
      thingModelJson: 'ThingModelJson',
    };
  }

  static types(): { [key: string]: any } {
    return {
      thingModelJson: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTopicReverseRouteTableResponseBodySrcTopics extends $tea.Model {
  topic?: { [key: string]: string }[];
  static names(): { [key: string]: string } {
    return {
      topic: 'Topic',
    };
  }

  static types(): { [key: string]: any } {
    return {
      topic: { 'type': 'array', 'itemType': { 'type': 'map', 'keyType': 'string', 'valueType': 'string' } },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTopicRouteTableResponseBodyDstTopics extends $tea.Model {
  topic?: { [key: string]: string }[];
  static names(): { [key: string]: string } {
    return {
      topic: 'Topic',
    };
  }

  static types(): { [key: string]: any } {
    return {
      topic: { 'type': 'array', 'itemType': { 'type': 'map', 'keyType': 'string', 'valueType': 'string' } },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RefreshStudioAppTokenOpenResponseBodyData extends $tea.Model {
  bizId?: string;
  bizType?: string;
  isEnable?: string;
  token?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      bizId: 'BizId',
      bizType: 'BizType',
      isEnable: 'IsEnable',
      token: 'Token',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizId: 'string',
      bizType: 'string',
      isEnable: 'string',
      token: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RegisterDeviceResponseBodyData extends $tea.Model {
  devEui?: string;
  deviceName?: string;
  deviceSecret?: string;
  iotId?: string;
  joinEui?: string;
  nickname?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      devEui: 'DevEui',
      deviceName: 'DeviceName',
      deviceSecret: 'DeviceSecret',
      iotId: 'IotId',
      joinEui: 'JoinEui',
      nickname: 'Nickname',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      devEui: 'string',
      deviceName: 'string',
      deviceSecret: 'string',
      iotId: 'string',
      joinEui: 'string',
      nickname: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDeviceDesiredPropertyResponseBodyData extends $tea.Model {
  messageId?: string;
  versions?: string;
  static names(): { [key: string]: string } {
    return {
      messageId: 'MessageId',
      versions: 'Versions',
    };
  }

  static types(): { [key: string]: any } {
    return {
      messageId: 'string',
      versions: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDevicePropertyResponseBodyData extends $tea.Model {
  messageId?: string;
  static names(): { [key: string]: string } {
    return {
      messageId: 'MessageId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      messageId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetEdgeInstanceDriverConfigsRequestConfigs extends $tea.Model {
  content?: string;
  format?: string;
  key?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      format: 'Format',
      key: 'Key',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      format: 'string',
      key: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetupStudioAppAuthModeOpenResponseBodyDataTokenInfo extends $tea.Model {
  bizId?: string;
  bizType?: string;
  isEnable?: string;
  token?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      bizId: 'BizId',
      bizType: 'BizType',
      isEnable: 'IsEnable',
      token: 'Token',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizId: 'string',
      bizType: 'string',
      isEnable: 'string',
      token: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetupStudioAppAuthModeOpenResponseBodyData extends $tea.Model {
  authMode?: number;
  tokenInfo?: SetupStudioAppAuthModeOpenResponseBodyDataTokenInfo;
  static names(): { [key: string]: string } {
    return {
      authMode: 'AuthMode',
      tokenInfo: 'TokenInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authMode: 'number',
      tokenInfo: SetupStudioAppAuthModeOpenResponseBodyDataTokenInfo,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartCpuResponseBodyData extends $tea.Model {
  gmtCreate?: number;
  gmtModified?: number;
  iotInstanceId?: string;
  timeZone?: string;
  static names(): { [key: string]: string } {
    return {
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      iotInstanceId: 'IotInstanceId',
      timeZone: 'TimeZone',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gmtCreate: 'number',
      gmtModified: 'number',
      iotInstanceId: 'string',
      timeZone: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SyncSpeechByCombinationResponseBodyData extends $tea.Model {
  deviceErrorCode?: string;
  deviceErrorMessage?: string;
  id?: string;
  maxRetryCount?: number;
  retryCount?: number;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      deviceErrorCode: 'DeviceErrorCode',
      deviceErrorMessage: 'DeviceErrorMessage',
      id: 'Id',
      maxRetryCount: 'MaxRetryCount',
      retryCount: 'RetryCount',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceErrorCode: 'string',
      deviceErrorMessage: 'string',
      id: 'string',
      maxRetryCount: 'number',
      retryCount: 'number',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TestSpeechResponseBodyData extends $tea.Model {
  items?: string[];
  static names(): { [key: string]: string } {
    return {
      items: 'items',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateEdgeInstanceChannelRequestConfigs extends $tea.Model {
  content?: string;
  format?: string;
  key?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      format: 'Format',
      key: 'Key',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      format: 'string',
      key: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProductTagsRequestProductTag extends $tea.Model {
  tagKey?: string;
  tagValue?: string;
  static names(): { [key: string]: string } {
    return {
      tagKey: 'TagKey',
      tagValue: 'TagValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagKey: 'string',
      tagValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProductTagsResponseBodyInvalidProductTagsProductTag extends $tea.Model {
  tagKey?: string;
  tagValue?: string;
  static names(): { [key: string]: string } {
    return {
      tagKey: 'TagKey',
      tagValue: 'TagValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagKey: 'string',
      tagValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProductTagsResponseBodyInvalidProductTags extends $tea.Model {
  productTag?: UpdateProductTagsResponseBodyInvalidProductTagsProductTag[];
  static names(): { [key: string]: string } {
    return {
      productTag: 'ProductTag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      productTag: { 'type': 'array', 'itemType': UpdateProductTagsResponseBodyInvalidProductTagsProductTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}


export default class Client extends OpenApi {

  constructor(config: $OpenApi.Config) {
    super(config);
    this._endpointRule = "regional";
    this._endpointMap = {
      'ap-northeast-2-pop': "iot.aliyuncs.com",
      'ap-south-1': "iot.aliyuncs.com",
      'ap-southeast-2': "iot.aliyuncs.com",
      'ap-southeast-3': "iot.aliyuncs.com",
      'ap-southeast-5': "iot.aliyuncs.com",
      'cn-beijing-finance-1': "iot.aliyuncs.com",
      'cn-beijing-finance-pop': "iot.aliyuncs.com",
      'cn-beijing-gov-1': "iot.aliyuncs.com",
      'cn-beijing-nu16-b01': "iot.aliyuncs.com",
      'cn-chengdu': "iot.aliyuncs.com",
      'cn-edge-1': "iot.aliyuncs.com",
      'cn-fujian': "iot.aliyuncs.com",
      'cn-haidian-cm12-c01': "iot.aliyuncs.com",
      'cn-hangzhou-bj-b01': "iot.aliyuncs.com",
      'cn-hangzhou-finance': "iot.aliyuncs.com",
      'cn-hangzhou-internal-prod-1': "iot.aliyuncs.com",
      'cn-hangzhou-internal-test-1': "iot.aliyuncs.com",
      'cn-hangzhou-internal-test-2': "iot.aliyuncs.com",
      'cn-hangzhou-internal-test-3': "iot.aliyuncs.com",
      'cn-hangzhou-test-306': "iot.aliyuncs.com",
      'cn-hongkong': "iot.aliyuncs.com",
      'cn-hongkong-finance-pop': "iot.aliyuncs.com",
      'cn-huhehaote': "iot.aliyuncs.com",
      'cn-huhehaote-nebula-1': "iot.aliyuncs.com",
      'cn-qingdao': "iot.aliyuncs.com",
      'cn-qingdao-nebula': "iot.aliyuncs.com",
      'cn-shanghai-et15-b01': "iot.aliyuncs.com",
      'cn-shanghai-et2-b01': "iot.aliyuncs.com",
      'cn-shanghai-finance-1': "iot.aliyuncs.com",
      'cn-shanghai-inner': "iot.aliyuncs.com",
      'cn-shanghai-internal-test-1': "iot.aliyuncs.com",
      'cn-shenzhen-finance-1': "iot.aliyuncs.com",
      'cn-shenzhen-inner': "iot.aliyuncs.com",
      'cn-shenzhen-st4-d01': "iot.aliyuncs.com",
      'cn-shenzhen-su18-b01': "iot.aliyuncs.com",
      'cn-wuhan': "iot.aliyuncs.com",
      'cn-wulanchabu': "iot.aliyuncs.com",
      'cn-yushanfang': "iot.aliyuncs.com",
      'cn-zhangbei': "iot.aliyuncs.com",
      'cn-zhangbei-na61-b01': "iot.aliyuncs.com",
      'cn-zhangjiakou': "iot.aliyuncs.com",
      'cn-zhangjiakou-na62-a01': "iot.aliyuncs.com",
      'cn-zhengzhou-nebula-1': "iot.aliyuncs.com",
      'eu-west-1': "iot.aliyuncs.com",
      'eu-west-1-oxs': "iot.aliyuncs.com",
      'me-east-1': "iot.aliyuncs.com",
      'rus-west-1-pop': "iot.aliyuncs.com",
    };
    this.checkConfig(config);
    this._endpoint = this.getEndpoint("iot", this._regionId, this._endpointRule, this._network, this._suffix, this._endpointMap, this._endpoint);
  }


  getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: {[key: string ]: string}, endpoint: string): string {
    if (!Util.empty(endpoint)) {
      return endpoint;
    }

    if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
      return endpointMap[regionId];
    }

    return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
  }

  async addDataForApiSourceWithOptions(request: AddDataForApiSourceRequest, runtime: $Util.RuntimeOptions): Promise<AddDataForApiSourceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.apiId)) {
      query["ApiId"] = request.apiId;
    }

    if (!Util.isUnset(request.content)) {
      query["Content"] = request.content;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddDataForApiSource",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddDataForApiSourceResponse>(await this.callApi(params, req, runtime), new AddDataForApiSourceResponse({}));
  }

  async addDataForApiSource(request: AddDataForApiSourceRequest): Promise<AddDataForApiSourceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addDataForApiSourceWithOptions(request, runtime);
  }

  async batchAddDeviceGroupRelationsWithOptions(request: BatchAddDeviceGroupRelationsRequest, runtime: $Util.RuntimeOptions): Promise<BatchAddDeviceGroupRelationsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.device)) {
      query["Device"] = request.device;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BatchAddDeviceGroupRelations",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchAddDeviceGroupRelationsResponse>(await this.callApi(params, req, runtime), new BatchAddDeviceGroupRelationsResponse({}));
  }

  async batchAddDeviceGroupRelations(request: BatchAddDeviceGroupRelationsRequest): Promise<BatchAddDeviceGroupRelationsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchAddDeviceGroupRelationsWithOptions(request, runtime);
  }

  async batchAddThingTopoWithOptions(request: BatchAddThingTopoRequest, runtime: $Util.RuntimeOptions): Promise<BatchAddThingTopoResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.gwDeviceName)) {
      query["GwDeviceName"] = request.gwDeviceName;
    }

    if (!Util.isUnset(request.gwProductKey)) {
      query["GwProductKey"] = request.gwProductKey;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.topoAddItem)) {
      query["TopoAddItem"] = request.topoAddItem;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BatchAddThingTopo",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchAddThingTopoResponse>(await this.callApi(params, req, runtime), new BatchAddThingTopoResponse({}));
  }

  async batchAddThingTopo(request: BatchAddThingTopoRequest): Promise<BatchAddThingTopoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchAddThingTopoWithOptions(request, runtime);
  }

  async batchBindDeviceToEdgeInstanceWithDriverWithOptions(request: BatchBindDeviceToEdgeInstanceWithDriverRequest, runtime: $Util.RuntimeOptions): Promise<BatchBindDeviceToEdgeInstanceWithDriverResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.driverId)) {
      query["DriverId"] = request.driverId;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotIds)) {
      query["IotIds"] = request.iotIds;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BatchBindDeviceToEdgeInstanceWithDriver",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchBindDeviceToEdgeInstanceWithDriverResponse>(await this.callApi(params, req, runtime), new BatchBindDeviceToEdgeInstanceWithDriverResponse({}));
  }

  async batchBindDeviceToEdgeInstanceWithDriver(request: BatchBindDeviceToEdgeInstanceWithDriverRequest): Promise<BatchBindDeviceToEdgeInstanceWithDriverResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchBindDeviceToEdgeInstanceWithDriverWithOptions(request, runtime);
  }

  async batchBindDevicesIntoProjectWithOptions(request: BatchBindDevicesIntoProjectRequest, runtime: $Util.RuntimeOptions): Promise<BatchBindDevicesIntoProjectResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: request.devices,
    });
    let params = new $OpenApi.Params({
      action: "BatchBindDevicesIntoProject",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchBindDevicesIntoProjectResponse>(await this.callApi(params, req, runtime), new BatchBindDevicesIntoProjectResponse({}));
  }

  async batchBindDevicesIntoProject(request: BatchBindDevicesIntoProjectRequest): Promise<BatchBindDevicesIntoProjectResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchBindDevicesIntoProjectWithOptions(request, runtime);
  }

  async batchBindProductsIntoProjectWithOptions(request: BatchBindProductsIntoProjectRequest, runtime: $Util.RuntimeOptions): Promise<BatchBindProductsIntoProjectResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: request.iotInstanceId,
    });
    let params = new $OpenApi.Params({
      action: "BatchBindProductsIntoProject",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchBindProductsIntoProjectResponse>(await this.callApi(params, req, runtime), new BatchBindProductsIntoProjectResponse({}));
  }

  async batchBindProductsIntoProject(request: BatchBindProductsIntoProjectRequest): Promise<BatchBindProductsIntoProjectResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchBindProductsIntoProjectWithOptions(request, runtime);
  }

  async batchCheckDeviceNamesWithOptions(request: BatchCheckDeviceNamesRequest, runtime: $Util.RuntimeOptions): Promise<BatchCheckDeviceNamesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.deviceNameList)) {
      query["DeviceNameList"] = request.deviceNameList;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BatchCheckDeviceNames",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchCheckDeviceNamesResponse>(await this.callApi(params, req, runtime), new BatchCheckDeviceNamesResponse({}));
  }

  async batchCheckDeviceNames(request: BatchCheckDeviceNamesRequest): Promise<BatchCheckDeviceNamesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchCheckDeviceNamesWithOptions(request, runtime);
  }

  async batchClearEdgeInstanceDeviceConfigWithOptions(request: BatchClearEdgeInstanceDeviceConfigRequest, runtime: $Util.RuntimeOptions): Promise<BatchClearEdgeInstanceDeviceConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotIds)) {
      query["IotIds"] = request.iotIds;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BatchClearEdgeInstanceDeviceConfig",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchClearEdgeInstanceDeviceConfigResponse>(await this.callApi(params, req, runtime), new BatchClearEdgeInstanceDeviceConfigResponse({}));
  }

  async batchClearEdgeInstanceDeviceConfig(request: BatchClearEdgeInstanceDeviceConfigRequest): Promise<BatchClearEdgeInstanceDeviceConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchClearEdgeInstanceDeviceConfigWithOptions(request, runtime);
  }

  async batchDeleteDeviceGroupRelationsWithOptions(request: BatchDeleteDeviceGroupRelationsRequest, runtime: $Util.RuntimeOptions): Promise<BatchDeleteDeviceGroupRelationsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.device)) {
      query["Device"] = request.device;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BatchDeleteDeviceGroupRelations",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchDeleteDeviceGroupRelationsResponse>(await this.callApi(params, req, runtime), new BatchDeleteDeviceGroupRelationsResponse({}));
  }

  async batchDeleteDeviceGroupRelations(request: BatchDeleteDeviceGroupRelationsRequest): Promise<BatchDeleteDeviceGroupRelationsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchDeleteDeviceGroupRelationsWithOptions(request, runtime);
  }

  async batchDeleteEdgeInstanceChannelWithOptions(request: BatchDeleteEdgeInstanceChannelRequest, runtime: $Util.RuntimeOptions): Promise<BatchDeleteEdgeInstanceChannelResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.channelIds)) {
      query["ChannelIds"] = request.channelIds;
    }

    if (!Util.isUnset(request.driverId)) {
      query["DriverId"] = request.driverId;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BatchDeleteEdgeInstanceChannel",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchDeleteEdgeInstanceChannelResponse>(await this.callApi(params, req, runtime), new BatchDeleteEdgeInstanceChannelResponse({}));
  }

  async batchDeleteEdgeInstanceChannel(request: BatchDeleteEdgeInstanceChannelRequest): Promise<BatchDeleteEdgeInstanceChannelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchDeleteEdgeInstanceChannelWithOptions(request, runtime);
  }

  async batchGetDeviceBindStatusWithOptions(request: BatchGetDeviceBindStatusRequest, runtime: $Util.RuntimeOptions): Promise<BatchGetDeviceBindStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotIds)) {
      query["IotIds"] = request.iotIds;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BatchGetDeviceBindStatus",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchGetDeviceBindStatusResponse>(await this.callApi(params, req, runtime), new BatchGetDeviceBindStatusResponse({}));
  }

  async batchGetDeviceBindStatus(request: BatchGetDeviceBindStatusRequest): Promise<BatchGetDeviceBindStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchGetDeviceBindStatusWithOptions(request, runtime);
  }

  async batchGetDeviceStateWithOptions(request: BatchGetDeviceStateRequest, runtime: $Util.RuntimeOptions): Promise<BatchGetDeviceStateResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotId)) {
      query["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BatchGetDeviceState",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchGetDeviceStateResponse>(await this.callApi(params, req, runtime), new BatchGetDeviceStateResponse({}));
  }

  async batchGetDeviceState(request: BatchGetDeviceStateRequest): Promise<BatchGetDeviceStateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchGetDeviceStateWithOptions(request, runtime);
  }

  async batchGetEdgeDriverWithOptions(request: BatchGetEdgeDriverRequest, runtime: $Util.RuntimeOptions): Promise<BatchGetEdgeDriverResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.driverIds)) {
      query["DriverIds"] = request.driverIds;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BatchGetEdgeDriver",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchGetEdgeDriverResponse>(await this.callApi(params, req, runtime), new BatchGetEdgeDriverResponse({}));
  }

  async batchGetEdgeDriver(request: BatchGetEdgeDriverRequest): Promise<BatchGetEdgeDriverResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchGetEdgeDriverWithOptions(request, runtime);
  }

  async batchGetEdgeInstanceChannelWithOptions(request: BatchGetEdgeInstanceChannelRequest, runtime: $Util.RuntimeOptions): Promise<BatchGetEdgeInstanceChannelResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.channelIds)) {
      query["ChannelIds"] = request.channelIds;
    }

    if (!Util.isUnset(request.driverId)) {
      query["DriverId"] = request.driverId;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BatchGetEdgeInstanceChannel",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchGetEdgeInstanceChannelResponse>(await this.callApi(params, req, runtime), new BatchGetEdgeInstanceChannelResponse({}));
  }

  async batchGetEdgeInstanceChannel(request: BatchGetEdgeInstanceChannelRequest): Promise<BatchGetEdgeInstanceChannelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchGetEdgeInstanceChannelWithOptions(request, runtime);
  }

  async batchGetEdgeInstanceDeviceChannelWithOptions(request: BatchGetEdgeInstanceDeviceChannelRequest, runtime: $Util.RuntimeOptions): Promise<BatchGetEdgeInstanceDeviceChannelResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.driverId)) {
      query["DriverId"] = request.driverId;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotIds)) {
      query["IotIds"] = request.iotIds;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BatchGetEdgeInstanceDeviceChannel",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchGetEdgeInstanceDeviceChannelResponse>(await this.callApi(params, req, runtime), new BatchGetEdgeInstanceDeviceChannelResponse({}));
  }

  async batchGetEdgeInstanceDeviceChannel(request: BatchGetEdgeInstanceDeviceChannelRequest): Promise<BatchGetEdgeInstanceDeviceChannelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchGetEdgeInstanceDeviceChannelWithOptions(request, runtime);
  }

  async batchGetEdgeInstanceDeviceConfigWithOptions(request: BatchGetEdgeInstanceDeviceConfigRequest, runtime: $Util.RuntimeOptions): Promise<BatchGetEdgeInstanceDeviceConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotIds)) {
      query["IotIds"] = request.iotIds;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BatchGetEdgeInstanceDeviceConfig",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchGetEdgeInstanceDeviceConfigResponse>(await this.callApi(params, req, runtime), new BatchGetEdgeInstanceDeviceConfigResponse({}));
  }

  async batchGetEdgeInstanceDeviceConfig(request: BatchGetEdgeInstanceDeviceConfigRequest): Promise<BatchGetEdgeInstanceDeviceConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchGetEdgeInstanceDeviceConfigWithOptions(request, runtime);
  }

  async batchGetEdgeInstanceDeviceDriverWithOptions(request: BatchGetEdgeInstanceDeviceDriverRequest, runtime: $Util.RuntimeOptions): Promise<BatchGetEdgeInstanceDeviceDriverResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotIds)) {
      query["IotIds"] = request.iotIds;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BatchGetEdgeInstanceDeviceDriver",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchGetEdgeInstanceDeviceDriverResponse>(await this.callApi(params, req, runtime), new BatchGetEdgeInstanceDeviceDriverResponse({}));
  }

  async batchGetEdgeInstanceDeviceDriver(request: BatchGetEdgeInstanceDeviceDriverRequest): Promise<BatchGetEdgeInstanceDeviceDriverResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchGetEdgeInstanceDeviceDriverWithOptions(request, runtime);
  }

  async batchGetEdgeInstanceDriverConfigsWithOptions(request: BatchGetEdgeInstanceDriverConfigsRequest, runtime: $Util.RuntimeOptions): Promise<BatchGetEdgeInstanceDriverConfigsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.driverIds)) {
      query["DriverIds"] = request.driverIds;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BatchGetEdgeInstanceDriverConfigs",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchGetEdgeInstanceDriverConfigsResponse>(await this.callApi(params, req, runtime), new BatchGetEdgeInstanceDriverConfigsResponse({}));
  }

  async batchGetEdgeInstanceDriverConfigs(request: BatchGetEdgeInstanceDriverConfigsRequest): Promise<BatchGetEdgeInstanceDriverConfigsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchGetEdgeInstanceDriverConfigsWithOptions(request, runtime);
  }

  async batchPubWithOptions(request: BatchPubRequest, runtime: $Util.RuntimeOptions): Promise<BatchPubResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.messageContent)) {
      query["MessageContent"] = request.messageContent;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.qos)) {
      query["Qos"] = request.qos;
    }

    if (!Util.isUnset(request.topicShortName)) {
      query["TopicShortName"] = request.topicShortName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BatchPub",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchPubResponse>(await this.callApi(params, req, runtime), new BatchPubResponse({}));
  }

  async batchPub(request: BatchPubRequest): Promise<BatchPubResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchPubWithOptions(request, runtime);
  }

  async batchQueryDeviceDetailWithOptions(request: BatchQueryDeviceDetailRequest, runtime: $Util.RuntimeOptions): Promise<BatchQueryDeviceDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BatchQueryDeviceDetail",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchQueryDeviceDetailResponse>(await this.callApi(params, req, runtime), new BatchQueryDeviceDetailResponse({}));
  }

  async batchQueryDeviceDetail(request: BatchQueryDeviceDetailRequest): Promise<BatchQueryDeviceDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchQueryDeviceDetailWithOptions(request, runtime);
  }

  async batchRegisterDeviceWithOptions(request: BatchRegisterDeviceRequest, runtime: $Util.RuntimeOptions): Promise<BatchRegisterDeviceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.count)) {
      query["Count"] = request.count;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BatchRegisterDevice",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchRegisterDeviceResponse>(await this.callApi(params, req, runtime), new BatchRegisterDeviceResponse({}));
  }

  async batchRegisterDevice(request: BatchRegisterDeviceRequest): Promise<BatchRegisterDeviceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchRegisterDeviceWithOptions(request, runtime);
  }

  async batchRegisterDeviceWithApplyIdWithOptions(request: BatchRegisterDeviceWithApplyIdRequest, runtime: $Util.RuntimeOptions): Promise<BatchRegisterDeviceWithApplyIdResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.applyId)) {
      query["ApplyId"] = request.applyId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BatchRegisterDeviceWithApplyId",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchRegisterDeviceWithApplyIdResponse>(await this.callApi(params, req, runtime), new BatchRegisterDeviceWithApplyIdResponse({}));
  }

  async batchRegisterDeviceWithApplyId(request: BatchRegisterDeviceWithApplyIdRequest): Promise<BatchRegisterDeviceWithApplyIdResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchRegisterDeviceWithApplyIdWithOptions(request, runtime);
  }

  async batchSetEdgeInstanceDeviceChannelWithOptions(request: BatchSetEdgeInstanceDeviceChannelRequest, runtime: $Util.RuntimeOptions): Promise<BatchSetEdgeInstanceDeviceChannelResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.channelId)) {
      query["ChannelId"] = request.channelId;
    }

    if (!Util.isUnset(request.driverId)) {
      query["DriverId"] = request.driverId;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotIds)) {
      query["IotIds"] = request.iotIds;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BatchSetEdgeInstanceDeviceChannel",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchSetEdgeInstanceDeviceChannelResponse>(await this.callApi(params, req, runtime), new BatchSetEdgeInstanceDeviceChannelResponse({}));
  }

  async batchSetEdgeInstanceDeviceChannel(request: BatchSetEdgeInstanceDeviceChannelRequest): Promise<BatchSetEdgeInstanceDeviceChannelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchSetEdgeInstanceDeviceChannelWithOptions(request, runtime);
  }

  async batchSetEdgeInstanceDeviceConfigWithOptions(request: BatchSetEdgeInstanceDeviceConfigRequest, runtime: $Util.RuntimeOptions): Promise<BatchSetEdgeInstanceDeviceConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceConfigs)) {
      query["DeviceConfigs"] = request.deviceConfigs;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BatchSetEdgeInstanceDeviceConfig",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchSetEdgeInstanceDeviceConfigResponse>(await this.callApi(params, req, runtime), new BatchSetEdgeInstanceDeviceConfigResponse({}));
  }

  async batchSetEdgeInstanceDeviceConfig(request: BatchSetEdgeInstanceDeviceConfigRequest): Promise<BatchSetEdgeInstanceDeviceConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchSetEdgeInstanceDeviceConfigWithOptions(request, runtime);
  }

  async batchUnbindDeviceFromEdgeInstanceWithOptions(request: BatchUnbindDeviceFromEdgeInstanceRequest, runtime: $Util.RuntimeOptions): Promise<BatchUnbindDeviceFromEdgeInstanceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotIds)) {
      query["IotIds"] = request.iotIds;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BatchUnbindDeviceFromEdgeInstance",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchUnbindDeviceFromEdgeInstanceResponse>(await this.callApi(params, req, runtime), new BatchUnbindDeviceFromEdgeInstanceResponse({}));
  }

  async batchUnbindDeviceFromEdgeInstance(request: BatchUnbindDeviceFromEdgeInstanceRequest): Promise<BatchUnbindDeviceFromEdgeInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchUnbindDeviceFromEdgeInstanceWithOptions(request, runtime);
  }

  async batchUnbindProjectDevicesWithOptions(request: BatchUnbindProjectDevicesRequest, runtime: $Util.RuntimeOptions): Promise<BatchUnbindProjectDevicesResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: request.devices,
    });
    let params = new $OpenApi.Params({
      action: "BatchUnbindProjectDevices",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchUnbindProjectDevicesResponse>(await this.callApi(params, req, runtime), new BatchUnbindProjectDevicesResponse({}));
  }

  async batchUnbindProjectDevices(request: BatchUnbindProjectDevicesRequest): Promise<BatchUnbindProjectDevicesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchUnbindProjectDevicesWithOptions(request, runtime);
  }

  async batchUnbindProjectProductsWithOptions(request: BatchUnbindProjectProductsRequest, runtime: $Util.RuntimeOptions): Promise<BatchUnbindProjectProductsResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: request.iotInstanceId,
    });
    let params = new $OpenApi.Params({
      action: "BatchUnbindProjectProducts",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchUnbindProjectProductsResponse>(await this.callApi(params, req, runtime), new BatchUnbindProjectProductsResponse({}));
  }

  async batchUnbindProjectProducts(request: BatchUnbindProjectProductsRequest): Promise<BatchUnbindProjectProductsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchUnbindProjectProductsWithOptions(request, runtime);
  }

  async batchUpdateDeviceNicknameWithOptions(request: BatchUpdateDeviceNicknameRequest, runtime: $Util.RuntimeOptions): Promise<BatchUpdateDeviceNicknameResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceNicknameInfo)) {
      query["DeviceNicknameInfo"] = request.deviceNicknameInfo;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BatchUpdateDeviceNickname",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchUpdateDeviceNicknameResponse>(await this.callApi(params, req, runtime), new BatchUpdateDeviceNicknameResponse({}));
  }

  async batchUpdateDeviceNickname(request: BatchUpdateDeviceNicknameRequest): Promise<BatchUpdateDeviceNicknameResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchUpdateDeviceNicknameWithOptions(request, runtime);
  }

  async bindApplicationToEdgeInstanceWithOptions(request: BindApplicationToEdgeInstanceRequest, runtime: $Util.RuntimeOptions): Promise<BindApplicationToEdgeInstanceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.applicationId)) {
      query["ApplicationId"] = request.applicationId;
    }

    if (!Util.isUnset(request.applicationVersion)) {
      query["ApplicationVersion"] = request.applicationVersion;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BindApplicationToEdgeInstance",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BindApplicationToEdgeInstanceResponse>(await this.callApi(params, req, runtime), new BindApplicationToEdgeInstanceResponse({}));
  }

  async bindApplicationToEdgeInstance(request: BindApplicationToEdgeInstanceRequest): Promise<BindApplicationToEdgeInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.bindApplicationToEdgeInstanceWithOptions(request, runtime);
  }

  async bindDriverToEdgeInstanceWithOptions(request: BindDriverToEdgeInstanceRequest, runtime: $Util.RuntimeOptions): Promise<BindDriverToEdgeInstanceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.driverId)) {
      query["DriverId"] = request.driverId;
    }

    if (!Util.isUnset(request.driverVersion)) {
      query["DriverVersion"] = request.driverVersion;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BindDriverToEdgeInstance",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BindDriverToEdgeInstanceResponse>(await this.callApi(params, req, runtime), new BindDriverToEdgeInstanceResponse({}));
  }

  async bindDriverToEdgeInstance(request: BindDriverToEdgeInstanceRequest): Promise<BindDriverToEdgeInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.bindDriverToEdgeInstanceWithOptions(request, runtime);
  }

  async bindGatewayToEdgeInstanceWithOptions(request: BindGatewayToEdgeInstanceRequest, runtime: $Util.RuntimeOptions): Promise<BindGatewayToEdgeInstanceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotId)) {
      query["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BindGatewayToEdgeInstance",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BindGatewayToEdgeInstanceResponse>(await this.callApi(params, req, runtime), new BindGatewayToEdgeInstanceResponse({}));
  }

  async bindGatewayToEdgeInstance(request: BindGatewayToEdgeInstanceRequest): Promise<BindGatewayToEdgeInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.bindGatewayToEdgeInstanceWithOptions(request, runtime);
  }

  async bindRoleToEdgeInstanceWithOptions(request: BindRoleToEdgeInstanceRequest, runtime: $Util.RuntimeOptions): Promise<BindRoleToEdgeInstanceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.roleArn)) {
      query["RoleArn"] = request.roleArn;
    }

    if (!Util.isUnset(request.roleName)) {
      query["RoleName"] = request.roleName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BindRoleToEdgeInstance",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BindRoleToEdgeInstanceResponse>(await this.callApi(params, req, runtime), new BindRoleToEdgeInstanceResponse({}));
  }

  async bindRoleToEdgeInstance(request: BindRoleToEdgeInstanceRequest): Promise<BindRoleToEdgeInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.bindRoleToEdgeInstanceWithOptions(request, runtime);
  }

  async bindSceneRuleToEdgeInstanceWithOptions(request: BindSceneRuleToEdgeInstanceRequest, runtime: $Util.RuntimeOptions): Promise<BindSceneRuleToEdgeInstanceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.ruleId)) {
      query["RuleId"] = request.ruleId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BindSceneRuleToEdgeInstance",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BindSceneRuleToEdgeInstanceResponse>(await this.callApi(params, req, runtime), new BindSceneRuleToEdgeInstanceResponse({}));
  }

  async bindSceneRuleToEdgeInstance(request: BindSceneRuleToEdgeInstanceRequest): Promise<BindSceneRuleToEdgeInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.bindSceneRuleToEdgeInstanceWithOptions(request, runtime);
  }

  async cancelJobWithOptions(request: CancelJobRequest, runtime: $Util.RuntimeOptions): Promise<CancelJobResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.jobId)) {
      query["JobId"] = request.jobId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CancelJob",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CancelJobResponse>(await this.callApi(params, req, runtime), new CancelJobResponse({}));
  }

  async cancelJob(request: CancelJobRequest): Promise<CancelJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.cancelJobWithOptions(request, runtime);
  }

  async cancelOTAStrategyByJobWithOptions(request: CancelOTAStrategyByJobRequest, runtime: $Util.RuntimeOptions): Promise<CancelOTAStrategyByJobResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.jobId)) {
      query["JobId"] = request.jobId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CancelOTAStrategyByJob",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CancelOTAStrategyByJobResponse>(await this.callApi(params, req, runtime), new CancelOTAStrategyByJobResponse({}));
  }

  async cancelOTAStrategyByJob(request: CancelOTAStrategyByJobRequest): Promise<CancelOTAStrategyByJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.cancelOTAStrategyByJobWithOptions(request, runtime);
  }

  async cancelOTATaskByDeviceWithOptions(request: CancelOTATaskByDeviceRequest, runtime: $Util.RuntimeOptions): Promise<CancelOTATaskByDeviceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.firmwareId)) {
      query["FirmwareId"] = request.firmwareId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.jobId)) {
      query["JobId"] = request.jobId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CancelOTATaskByDevice",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CancelOTATaskByDeviceResponse>(await this.callApi(params, req, runtime), new CancelOTATaskByDeviceResponse({}));
  }

  async cancelOTATaskByDevice(request: CancelOTATaskByDeviceRequest): Promise<CancelOTATaskByDeviceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.cancelOTATaskByDeviceWithOptions(request, runtime);
  }

  async cancelOTATaskByJobWithOptions(request: CancelOTATaskByJobRequest, runtime: $Util.RuntimeOptions): Promise<CancelOTATaskByJobResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.cancelInProgressTask)) {
      query["CancelInProgressTask"] = request.cancelInProgressTask;
    }

    if (!Util.isUnset(request.cancelNotifiedTask)) {
      query["CancelNotifiedTask"] = request.cancelNotifiedTask;
    }

    if (!Util.isUnset(request.cancelQueuedTask)) {
      query["CancelQueuedTask"] = request.cancelQueuedTask;
    }

    if (!Util.isUnset(request.cancelScheduledTask)) {
      query["CancelScheduledTask"] = request.cancelScheduledTask;
    }

    if (!Util.isUnset(request.cancelUnconfirmedTask)) {
      query["CancelUnconfirmedTask"] = request.cancelUnconfirmedTask;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.jobId)) {
      query["JobId"] = request.jobId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CancelOTATaskByJob",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CancelOTATaskByJobResponse>(await this.callApi(params, req, runtime), new CancelOTATaskByJobResponse({}));
  }

  async cancelOTATaskByJob(request: CancelOTATaskByJobRequest): Promise<CancelOTATaskByJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.cancelOTATaskByJobWithOptions(request, runtime);
  }

  async cancelReleaseProductWithOptions(request: CancelReleaseProductRequest, runtime: $Util.RuntimeOptions): Promise<CancelReleaseProductResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CancelReleaseProduct",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CancelReleaseProductResponse>(await this.callApi(params, req, runtime), new CancelReleaseProductResponse({}));
  }

  async cancelReleaseProduct(request: CancelReleaseProductRequest): Promise<CancelReleaseProductResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.cancelReleaseProductWithOptions(request, runtime);
  }

  async clearEdgeInstanceDriverConfigsWithOptions(request: ClearEdgeInstanceDriverConfigsRequest, runtime: $Util.RuntimeOptions): Promise<ClearEdgeInstanceDriverConfigsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.driverId)) {
      query["DriverId"] = request.driverId;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ClearEdgeInstanceDriverConfigs",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ClearEdgeInstanceDriverConfigsResponse>(await this.callApi(params, req, runtime), new ClearEdgeInstanceDriverConfigsResponse({}));
  }

  async clearEdgeInstanceDriverConfigs(request: ClearEdgeInstanceDriverConfigsRequest): Promise<ClearEdgeInstanceDriverConfigsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.clearEdgeInstanceDriverConfigsWithOptions(request, runtime);
  }

  async closeEdgeInstanceDeploymentWithOptions(request: CloseEdgeInstanceDeploymentRequest, runtime: $Util.RuntimeOptions): Promise<CloseEdgeInstanceDeploymentResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CloseEdgeInstanceDeployment",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CloseEdgeInstanceDeploymentResponse>(await this.callApi(params, req, runtime), new CloseEdgeInstanceDeploymentResponse({}));
  }

  async closeEdgeInstanceDeployment(request: CloseEdgeInstanceDeploymentRequest): Promise<CloseEdgeInstanceDeploymentResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.closeEdgeInstanceDeploymentWithOptions(request, runtime);
  }

  async confirmOTATaskWithOptions(request: ConfirmOTATaskRequest, runtime: $Util.RuntimeOptions): Promise<ConfirmOTATaskResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.taskId)) {
      query["TaskId"] = request.taskId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ConfirmOTATask",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ConfirmOTATaskResponse>(await this.callApi(params, req, runtime), new ConfirmOTATaskResponse({}));
  }

  async confirmOTATask(request: ConfirmOTATaskRequest): Promise<ConfirmOTATaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.confirmOTATaskWithOptions(request, runtime);
  }

  async copyThingModelWithOptions(request: CopyThingModelRequest, runtime: $Util.RuntimeOptions): Promise<CopyThingModelResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.sourceModelVersion)) {
      query["SourceModelVersion"] = request.sourceModelVersion;
    }

    if (!Util.isUnset(request.sourceProductKey)) {
      query["SourceProductKey"] = request.sourceProductKey;
    }

    if (!Util.isUnset(request.targetProductKey)) {
      query["TargetProductKey"] = request.targetProductKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CopyThingModel",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CopyThingModelResponse>(await this.callApi(params, req, runtime), new CopyThingModelResponse({}));
  }

  async copyThingModel(request: CopyThingModelRequest): Promise<CopyThingModelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.copyThingModelWithOptions(request, runtime);
  }

  async createConsumerGroupWithOptions(request: CreateConsumerGroupRequest, runtime: $Util.RuntimeOptions): Promise<CreateConsumerGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupName)) {
      query["GroupName"] = request.groupName;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateConsumerGroup",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateConsumerGroupResponse>(await this.callApi(params, req, runtime), new CreateConsumerGroupResponse({}));
  }

  async createConsumerGroup(request: CreateConsumerGroupRequest): Promise<CreateConsumerGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createConsumerGroupWithOptions(request, runtime);
  }

  async createConsumerGroupSubscribeRelationWithOptions(request: CreateConsumerGroupSubscribeRelationRequest, runtime: $Util.RuntimeOptions): Promise<CreateConsumerGroupSubscribeRelationResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.consumerGroupId)) {
      query["ConsumerGroupId"] = request.consumerGroupId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateConsumerGroupSubscribeRelation",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateConsumerGroupSubscribeRelationResponse>(await this.callApi(params, req, runtime), new CreateConsumerGroupSubscribeRelationResponse({}));
  }

  async createConsumerGroupSubscribeRelation(request: CreateConsumerGroupSubscribeRelationRequest): Promise<CreateConsumerGroupSubscribeRelationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createConsumerGroupSubscribeRelationWithOptions(request, runtime);
  }

  async createDataAPIServiceWithOptions(request: CreateDataAPIServiceRequest, runtime: $Util.RuntimeOptions): Promise<CreateDataAPIServiceResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: request.apiPath,
    });
    let params = new $OpenApi.Params({
      action: "CreateDataAPIService",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateDataAPIServiceResponse>(await this.callApi(params, req, runtime), new CreateDataAPIServiceResponse({}));
  }

  async createDataAPIService(request: CreateDataAPIServiceRequest): Promise<CreateDataAPIServiceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createDataAPIServiceWithOptions(request, runtime);
  }

  async createDeviceDistributeJobWithOptions(request: CreateDeviceDistributeJobRequest, runtime: $Util.RuntimeOptions): Promise<CreateDeviceDistributeJobResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: request.deviceName,
    });
    let params = new $OpenApi.Params({
      action: "CreateDeviceDistributeJob",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateDeviceDistributeJobResponse>(await this.callApi(params, req, runtime), new CreateDeviceDistributeJobResponse({}));
  }

  async createDeviceDistributeJob(request: CreateDeviceDistributeJobRequest): Promise<CreateDeviceDistributeJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createDeviceDistributeJobWithOptions(request, runtime);
  }

  async createDeviceGroupWithOptions(request: CreateDeviceGroupRequest, runtime: $Util.RuntimeOptions): Promise<CreateDeviceGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupDesc)) {
      query["GroupDesc"] = request.groupDesc;
    }

    if (!Util.isUnset(request.groupName)) {
      query["GroupName"] = request.groupName;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.superGroupId)) {
      query["SuperGroupId"] = request.superGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateDeviceGroup",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateDeviceGroupResponse>(await this.callApi(params, req, runtime), new CreateDeviceGroupResponse({}));
  }

  async createDeviceGroup(request: CreateDeviceGroupRequest): Promise<CreateDeviceGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createDeviceGroupWithOptions(request, runtime);
  }

  async createEdgeDriverWithOptions(request: CreateEdgeDriverRequest, runtime: $Util.RuntimeOptions): Promise<CreateEdgeDriverResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.cpuArch)) {
      query["CpuArch"] = request.cpuArch;
    }

    if (!Util.isUnset(request.driverName)) {
      query["DriverName"] = request.driverName;
    }

    if (!Util.isUnset(request.driverProtocol)) {
      query["DriverProtocol"] = request.driverProtocol;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.isBuiltIn)) {
      query["IsBuiltIn"] = request.isBuiltIn;
    }

    if (!Util.isUnset(request.runtime)) {
      query["Runtime"] = request.runtime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateEdgeDriver",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateEdgeDriverResponse>(await this.callApi(params, req, runtime), new CreateEdgeDriverResponse({}));
  }

  async createEdgeDriver(request: CreateEdgeDriverRequest): Promise<CreateEdgeDriverResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createEdgeDriverWithOptions(request, runtime);
  }

  async createEdgeDriverVersionWithOptions(request: CreateEdgeDriverVersionRequest, runtime: $Util.RuntimeOptions): Promise<CreateEdgeDriverVersionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.argument)) {
      query["Argument"] = request.argument;
    }

    if (!Util.isUnset(request.configCheckRule)) {
      query["ConfigCheckRule"] = request.configCheckRule;
    }

    if (!Util.isUnset(request.containerConfig)) {
      query["ContainerConfig"] = request.containerConfig;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.driverConfig)) {
      query["DriverConfig"] = request.driverConfig;
    }

    if (!Util.isUnset(request.driverId)) {
      query["DriverId"] = request.driverId;
    }

    if (!Util.isUnset(request.driverVersion)) {
      query["DriverVersion"] = request.driverVersion;
    }

    if (!Util.isUnset(request.edgeVersion)) {
      query["EdgeVersion"] = request.edgeVersion;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.sourceConfig)) {
      query["SourceConfig"] = request.sourceConfig;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateEdgeDriverVersion",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateEdgeDriverVersionResponse>(await this.callApi(params, req, runtime), new CreateEdgeDriverVersionResponse({}));
  }

  async createEdgeDriverVersion(request: CreateEdgeDriverVersionRequest): Promise<CreateEdgeDriverVersionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createEdgeDriverVersionWithOptions(request, runtime);
  }

  async createEdgeInstanceWithOptions(request: CreateEdgeInstanceRequest, runtime: $Util.RuntimeOptions): Promise<CreateEdgeInstanceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.spec)) {
      query["Spec"] = request.spec;
    }

    if (!Util.isUnset(request.tags)) {
      query["Tags"] = request.tags;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateEdgeInstance",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateEdgeInstanceResponse>(await this.callApi(params, req, runtime), new CreateEdgeInstanceResponse({}));
  }

  async createEdgeInstance(request: CreateEdgeInstanceRequest): Promise<CreateEdgeInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createEdgeInstanceWithOptions(request, runtime);
  }

  async createEdgeInstanceChannelWithOptions(request: CreateEdgeInstanceChannelRequest, runtime: $Util.RuntimeOptions): Promise<CreateEdgeInstanceChannelResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.channelName)) {
      query["ChannelName"] = request.channelName;
    }

    if (!Util.isUnset(request.configs)) {
      query["Configs"] = request.configs;
    }

    if (!Util.isUnset(request.driverId)) {
      query["DriverId"] = request.driverId;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateEdgeInstanceChannel",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateEdgeInstanceChannelResponse>(await this.callApi(params, req, runtime), new CreateEdgeInstanceChannelResponse({}));
  }

  async createEdgeInstanceChannel(request: CreateEdgeInstanceChannelRequest): Promise<CreateEdgeInstanceChannelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createEdgeInstanceChannelWithOptions(request, runtime);
  }

  async createEdgeInstanceDeploymentWithOptions(request: CreateEdgeInstanceDeploymentRequest, runtime: $Util.RuntimeOptions): Promise<CreateEdgeInstanceDeploymentResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateEdgeInstanceDeployment",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateEdgeInstanceDeploymentResponse>(await this.callApi(params, req, runtime), new CreateEdgeInstanceDeploymentResponse({}));
  }

  async createEdgeInstanceDeployment(request: CreateEdgeInstanceDeploymentRequest): Promise<CreateEdgeInstanceDeploymentResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createEdgeInstanceDeploymentWithOptions(request, runtime);
  }

  async createEdgeInstanceMessageRoutingWithOptions(request: CreateEdgeInstanceMessageRoutingRequest, runtime: $Util.RuntimeOptions): Promise<CreateEdgeInstanceMessageRoutingResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.sourceData)) {
      query["SourceData"] = request.sourceData;
    }

    if (!Util.isUnset(request.sourceType)) {
      query["SourceType"] = request.sourceType;
    }

    if (!Util.isUnset(request.targetData)) {
      query["TargetData"] = request.targetData;
    }

    if (!Util.isUnset(request.targetIotHubQos)) {
      query["TargetIotHubQos"] = request.targetIotHubQos;
    }

    if (!Util.isUnset(request.targetType)) {
      query["TargetType"] = request.targetType;
    }

    if (!Util.isUnset(request.topicFilter)) {
      query["TopicFilter"] = request.topicFilter;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateEdgeInstanceMessageRouting",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateEdgeInstanceMessageRoutingResponse>(await this.callApi(params, req, runtime), new CreateEdgeInstanceMessageRoutingResponse({}));
  }

  async createEdgeInstanceMessageRouting(request: CreateEdgeInstanceMessageRoutingRequest): Promise<CreateEdgeInstanceMessageRoutingResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createEdgeInstanceMessageRoutingWithOptions(request, runtime);
  }

  async createEdgeOssPreSignedAddressWithOptions(request: CreateEdgeOssPreSignedAddressRequest, runtime: $Util.RuntimeOptions): Promise<CreateEdgeOssPreSignedAddressResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.fileName)) {
      query["FileName"] = request.fileName;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.resourceId)) {
      query["ResourceId"] = request.resourceId;
    }

    if (!Util.isUnset(request.resourceVersion)) {
      query["ResourceVersion"] = request.resourceVersion;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateEdgeOssPreSignedAddress",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateEdgeOssPreSignedAddressResponse>(await this.callApi(params, req, runtime), new CreateEdgeOssPreSignedAddressResponse({}));
  }

  async createEdgeOssPreSignedAddress(request: CreateEdgeOssPreSignedAddressRequest): Promise<CreateEdgeOssPreSignedAddressResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createEdgeOssPreSignedAddressWithOptions(request, runtime);
  }

  async createJobWithOptions(request: CreateJobRequest, runtime: $Util.RuntimeOptions): Promise<CreateJobResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.jobDocument)) {
      query["JobDocument"] = request.jobDocument;
    }

    if (!Util.isUnset(request.jobFile)) {
      query["JobFile"] = request.jobFile;
    }

    if (!Util.isUnset(request.jobName)) {
      query["JobName"] = request.jobName;
    }

    if (!Util.isUnset(request.rolloutConfig)) {
      query["RolloutConfig"] = request.rolloutConfig;
    }

    if (!Util.isUnset(request.scheduledTime)) {
      query["ScheduledTime"] = request.scheduledTime;
    }

    if (!Util.isUnset(request.targetConfig)) {
      query["TargetConfig"] = request.targetConfig;
    }

    if (!Util.isUnset(request.timeoutConfig)) {
      query["TimeoutConfig"] = request.timeoutConfig;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateJob",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateJobResponse>(await this.callApi(params, req, runtime), new CreateJobResponse({}));
  }

  async createJob(request: CreateJobRequest): Promise<CreateJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createJobWithOptions(request, runtime);
  }

  async createLoRaNodesTaskWithOptions(request: CreateLoRaNodesTaskRequest, runtime: $Util.RuntimeOptions): Promise<CreateLoRaNodesTaskResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceInfo)) {
      query["DeviceInfo"] = request.deviceInfo;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateLoRaNodesTask",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateLoRaNodesTaskResponse>(await this.callApi(params, req, runtime), new CreateLoRaNodesTaskResponse({}));
  }

  async createLoRaNodesTask(request: CreateLoRaNodesTaskRequest): Promise<CreateLoRaNodesTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createLoRaNodesTaskWithOptions(request, runtime);
  }

  async createOTADynamicUpgradeJobWithOptions(request: CreateOTADynamicUpgradeJobRequest, runtime: $Util.RuntimeOptions): Promise<CreateOTADynamicUpgradeJobResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dynamicMode)) {
      query["DynamicMode"] = request.dynamicMode;
    }

    if (!Util.isUnset(request.firmwareId)) {
      query["FirmwareId"] = request.firmwareId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.maximumPerMinute)) {
      query["MaximumPerMinute"] = request.maximumPerMinute;
    }

    if (!Util.isUnset(request.needConfirm)) {
      query["NeedConfirm"] = request.needConfirm;
    }

    if (!Util.isUnset(request.needPush)) {
      query["NeedPush"] = request.needPush;
    }

    if (!Util.isUnset(request.overwriteMode)) {
      query["OverwriteMode"] = request.overwriteMode;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.retryCount)) {
      query["RetryCount"] = request.retryCount;
    }

    if (!Util.isUnset(request.retryInterval)) {
      query["RetryInterval"] = request.retryInterval;
    }

    if (!Util.isUnset(request.srcVersion)) {
      query["SrcVersion"] = request.srcVersion;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    if (!Util.isUnset(request.timeoutInMinutes)) {
      query["TimeoutInMinutes"] = request.timeoutInMinutes;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateOTADynamicUpgradeJob",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateOTADynamicUpgradeJobResponse>(await this.callApi(params, req, runtime), new CreateOTADynamicUpgradeJobResponse({}));
  }

  async createOTADynamicUpgradeJob(request: CreateOTADynamicUpgradeJobRequest): Promise<CreateOTADynamicUpgradeJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createOTADynamicUpgradeJobWithOptions(request, runtime);
  }

  async createOTAFirmwareWithOptions(request: CreateOTAFirmwareRequest, runtime: $Util.RuntimeOptions): Promise<CreateOTAFirmwareResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.destVersion)) {
      query["DestVersion"] = request.destVersion;
    }

    if (!Util.isUnset(request.firmwareDesc)) {
      query["FirmwareDesc"] = request.firmwareDesc;
    }

    if (!Util.isUnset(request.firmwareName)) {
      query["FirmwareName"] = request.firmwareName;
    }

    if (!Util.isUnset(request.firmwareSign)) {
      query["FirmwareSign"] = request.firmwareSign;
    }

    if (!Util.isUnset(request.firmwareSize)) {
      query["FirmwareSize"] = request.firmwareSize;
    }

    if (!Util.isUnset(request.firmwareUrl)) {
      query["FirmwareUrl"] = request.firmwareUrl;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.moduleName)) {
      query["ModuleName"] = request.moduleName;
    }

    if (!Util.isUnset(request.needToVerify)) {
      query["NeedToVerify"] = request.needToVerify;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.signMethod)) {
      query["SignMethod"] = request.signMethod;
    }

    if (!Util.isUnset(request.srcVersion)) {
      query["SrcVersion"] = request.srcVersion;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    if (!Util.isUnset(request.udi)) {
      query["Udi"] = request.udi;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateOTAFirmware",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateOTAFirmwareResponse>(await this.callApi(params, req, runtime), new CreateOTAFirmwareResponse({}));
  }

  async createOTAFirmware(request: CreateOTAFirmwareRequest): Promise<CreateOTAFirmwareResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createOTAFirmwareWithOptions(request, runtime);
  }

  async createOTAModuleWithOptions(request: CreateOTAModuleRequest, runtime: $Util.RuntimeOptions): Promise<CreateOTAModuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.aliasName)) {
      query["AliasName"] = request.aliasName;
    }

    if (!Util.isUnset(request.desc)) {
      query["Desc"] = request.desc;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.moduleName)) {
      query["ModuleName"] = request.moduleName;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateOTAModule",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateOTAModuleResponse>(await this.callApi(params, req, runtime), new CreateOTAModuleResponse({}));
  }

  async createOTAModule(request: CreateOTAModuleRequest): Promise<CreateOTAModuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createOTAModuleWithOptions(request, runtime);
  }

  async createOTAStaticUpgradeJobWithOptions(request: CreateOTAStaticUpgradeJobRequest, runtime: $Util.RuntimeOptions): Promise<CreateOTAStaticUpgradeJobResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dnListFileUrl)) {
      query["DnListFileUrl"] = request.dnListFileUrl;
    }

    if (!Util.isUnset(request.firmwareId)) {
      query["FirmwareId"] = request.firmwareId;
    }

    if (!Util.isUnset(request.grayPercent)) {
      query["GrayPercent"] = request.grayPercent;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.maximumPerMinute)) {
      query["MaximumPerMinute"] = request.maximumPerMinute;
    }

    if (!Util.isUnset(request.needConfirm)) {
      query["NeedConfirm"] = request.needConfirm;
    }

    if (!Util.isUnset(request.needPush)) {
      query["NeedPush"] = request.needPush;
    }

    if (!Util.isUnset(request.overwriteMode)) {
      query["OverwriteMode"] = request.overwriteMode;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.retryCount)) {
      query["RetryCount"] = request.retryCount;
    }

    if (!Util.isUnset(request.retryInterval)) {
      query["RetryInterval"] = request.retryInterval;
    }

    if (!Util.isUnset(request.scheduleFinishTime)) {
      query["ScheduleFinishTime"] = request.scheduleFinishTime;
    }

    if (!Util.isUnset(request.scheduleTime)) {
      query["ScheduleTime"] = request.scheduleTime;
    }

    if (!Util.isUnset(request.srcVersion)) {
      query["SrcVersion"] = request.srcVersion;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    if (!Util.isUnset(request.targetDeviceName)) {
      query["TargetDeviceName"] = request.targetDeviceName;
    }

    if (!Util.isUnset(request.targetSelection)) {
      query["TargetSelection"] = request.targetSelection;
    }

    if (!Util.isUnset(request.timeoutInMinutes)) {
      query["TimeoutInMinutes"] = request.timeoutInMinutes;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateOTAStaticUpgradeJob",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateOTAStaticUpgradeJobResponse>(await this.callApi(params, req, runtime), new CreateOTAStaticUpgradeJobResponse({}));
  }

  async createOTAStaticUpgradeJob(request: CreateOTAStaticUpgradeJobRequest): Promise<CreateOTAStaticUpgradeJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createOTAStaticUpgradeJobWithOptions(request, runtime);
  }

  async createOTAVerifyJobWithOptions(request: CreateOTAVerifyJobRequest, runtime: $Util.RuntimeOptions): Promise<CreateOTAVerifyJobResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.firmwareId)) {
      query["FirmwareId"] = request.firmwareId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.needConfirm)) {
      query["NeedConfirm"] = request.needConfirm;
    }

    if (!Util.isUnset(request.needPush)) {
      query["NeedPush"] = request.needPush;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.targetDeviceName)) {
      query["TargetDeviceName"] = request.targetDeviceName;
    }

    if (!Util.isUnset(request.timeoutInMinutes)) {
      query["TimeoutInMinutes"] = request.timeoutInMinutes;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateOTAVerifyJob",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateOTAVerifyJobResponse>(await this.callApi(params, req, runtime), new CreateOTAVerifyJobResponse({}));
  }

  async createOTAVerifyJob(request: CreateOTAVerifyJobRequest): Promise<CreateOTAVerifyJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createOTAVerifyJobWithOptions(request, runtime);
  }

  async createProductWithOptions(request: CreateProductRequest, runtime: $Util.RuntimeOptions): Promise<CreateProductResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.aliyunCommodityCode)) {
      query["AliyunCommodityCode"] = request.aliyunCommodityCode;
    }

    if (!Util.isUnset(request.authType)) {
      query["AuthType"] = request.authType;
    }

    if (!Util.isUnset(request.categoryKey)) {
      query["CategoryKey"] = request.categoryKey;
    }

    if (!Util.isUnset(request.dataFormat)) {
      query["DataFormat"] = request.dataFormat;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.id2)) {
      query["Id2"] = request.id2;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.joinPermissionId)) {
      query["JoinPermissionId"] = request.joinPermissionId;
    }

    if (!Util.isUnset(request.netType)) {
      query["NetType"] = request.netType;
    }

    if (!Util.isUnset(request.nodeType)) {
      query["NodeType"] = request.nodeType;
    }

    if (!Util.isUnset(request.productName)) {
      query["ProductName"] = request.productName;
    }

    if (!Util.isUnset(request.protocolType)) {
      query["ProtocolType"] = request.protocolType;
    }

    if (!Util.isUnset(request.publishAuto)) {
      query["PublishAuto"] = request.publishAuto;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.validateType)) {
      query["ValidateType"] = request.validateType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateProduct",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateProductResponse>(await this.callApi(params, req, runtime), new CreateProductResponse({}));
  }

  async createProduct(request: CreateProductRequest): Promise<CreateProductResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createProductWithOptions(request, runtime);
  }

  async createProductDistributeJobWithOptions(request: CreateProductDistributeJobRequest, runtime: $Util.RuntimeOptions): Promise<CreateProductDistributeJobResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.sourceInstanceId)) {
      query["SourceInstanceId"] = request.sourceInstanceId;
    }

    if (!Util.isUnset(request.targetAliyunId)) {
      query["TargetAliyunId"] = request.targetAliyunId;
    }

    if (!Util.isUnset(request.targetInstanceId)) {
      query["TargetInstanceId"] = request.targetInstanceId;
    }

    if (!Util.isUnset(request.targetUid)) {
      query["TargetUid"] = request.targetUid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateProductDistributeJob",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateProductDistributeJobResponse>(await this.callApi(params, req, runtime), new CreateProductDistributeJobResponse({}));
  }

  async createProductDistributeJob(request: CreateProductDistributeJobRequest): Promise<CreateProductDistributeJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createProductDistributeJobWithOptions(request, runtime);
  }

  async createProductTagsWithOptions(request: CreateProductTagsRequest, runtime: $Util.RuntimeOptions): Promise<CreateProductTagsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.productTag)) {
      query["ProductTag"] = request.productTag;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateProductTags",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateProductTagsResponse>(await this.callApi(params, req, runtime), new CreateProductTagsResponse({}));
  }

  async createProductTags(request: CreateProductTagsRequest): Promise<CreateProductTagsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createProductTagsWithOptions(request, runtime);
  }

  async createProductTopicWithOptions(request: CreateProductTopicRequest, runtime: $Util.RuntimeOptions): Promise<CreateProductTopicResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.desc)) {
      query["Desc"] = request.desc;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.operation)) {
      query["Operation"] = request.operation;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.topicShortName)) {
      query["TopicShortName"] = request.topicShortName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateProductTopic",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateProductTopicResponse>(await this.callApi(params, req, runtime), new CreateProductTopicResponse({}));
  }

  async createProductTopic(request: CreateProductTopicRequest): Promise<CreateProductTopicResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createProductTopicWithOptions(request, runtime);
  }

  async createRuleWithOptions(request: CreateRuleRequest, runtime: $Util.RuntimeOptions): Promise<CreateRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dataType)) {
      query["DataType"] = request.dataType;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.ruleDesc)) {
      query["RuleDesc"] = request.ruleDesc;
    }

    if (!Util.isUnset(request.select)) {
      query["Select"] = request.select;
    }

    if (!Util.isUnset(request.shortTopic)) {
      query["ShortTopic"] = request.shortTopic;
    }

    if (!Util.isUnset(request.topic)) {
      query["Topic"] = request.topic;
    }

    if (!Util.isUnset(request.topicType)) {
      query["TopicType"] = request.topicType;
    }

    if (!Util.isUnset(request.where)) {
      query["Where"] = request.where;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateRule",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateRuleResponse>(await this.callApi(params, req, runtime), new CreateRuleResponse({}));
  }

  async createRule(request: CreateRuleRequest): Promise<CreateRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createRuleWithOptions(request, runtime);
  }

  async createRuleActionWithOptions(request: CreateRuleActionRequest, runtime: $Util.RuntimeOptions): Promise<CreateRuleActionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.configuration)) {
      query["Configuration"] = request.configuration;
    }

    if (!Util.isUnset(request.errorActionFlag)) {
      query["ErrorActionFlag"] = request.errorActionFlag;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.ruleId)) {
      query["RuleId"] = request.ruleId;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateRuleAction",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateRuleActionResponse>(await this.callApi(params, req, runtime), new CreateRuleActionResponse({}));
  }

  async createRuleAction(request: CreateRuleActionRequest): Promise<CreateRuleActionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createRuleActionWithOptions(request, runtime);
  }

  async createRulengDistributeJobWithOptions(request: CreateRulengDistributeJobRequest, runtime: $Util.RuntimeOptions): Promise<CreateRulengDistributeJobResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.sourceInstanceId)) {
      query["SourceInstanceId"] = request.sourceInstanceId;
    }

    if (!Util.isUnset(request.targetInstanceId)) {
      query["TargetInstanceId"] = request.targetInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateRulengDistributeJob",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateRulengDistributeJobResponse>(await this.callApi(params, req, runtime), new CreateRulengDistributeJobResponse({}));
  }

  async createRulengDistributeJob(request: CreateRulengDistributeJobRequest): Promise<CreateRulengDistributeJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createRulengDistributeJobWithOptions(request, runtime);
  }

  async createSceneRuleWithOptions(request: CreateSceneRuleRequest, runtime: $Util.RuntimeOptions): Promise<CreateSceneRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.ruleContent)) {
      query["RuleContent"] = request.ruleContent;
    }

    if (!Util.isUnset(request.ruleDescription)) {
      query["RuleDescription"] = request.ruleDescription;
    }

    if (!Util.isUnset(request.ruleName)) {
      query["RuleName"] = request.ruleName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateSceneRule",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateSceneRuleResponse>(await this.callApi(params, req, runtime), new CreateSceneRuleResponse({}));
  }

  async createSceneRule(request: CreateSceneRuleRequest): Promise<CreateSceneRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createSceneRuleWithOptions(request, runtime);
  }

  async createSpeechWithOptions(request: CreateSpeechRequest, runtime: $Util.RuntimeOptions): Promise<CreateSpeechResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: request.bizCode,
    });
    let params = new $OpenApi.Params({
      action: "CreateSpeech",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateSpeechResponse>(await this.callApi(params, req, runtime), new CreateSpeechResponse({}));
  }

  async createSpeech(request: CreateSpeechRequest): Promise<CreateSpeechResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createSpeechWithOptions(request, runtime);
  }

  async createStudioAppDomainOpenWithOptions(request: CreateStudioAppDomainOpenRequest, runtime: $Util.RuntimeOptions): Promise<CreateStudioAppDomainOpenResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: request.appId,
    });
    let params = new $OpenApi.Params({
      action: "CreateStudioAppDomainOpen",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateStudioAppDomainOpenResponse>(await this.callApi(params, req, runtime), new CreateStudioAppDomainOpenResponse({}));
  }

  async createStudioAppDomainOpen(request: CreateStudioAppDomainOpenRequest): Promise<CreateStudioAppDomainOpenResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createStudioAppDomainOpenWithOptions(request, runtime);
  }

  async createSubscribeRelationWithOptions(request: CreateSubscribeRelationRequest, runtime: $Util.RuntimeOptions): Promise<CreateSubscribeRelationResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.consumerGroupIds)) {
      query["ConsumerGroupIds"] = request.consumerGroupIds;
    }

    if (!Util.isUnset(request.deviceDataFlag)) {
      query["DeviceDataFlag"] = request.deviceDataFlag;
    }

    if (!Util.isUnset(request.deviceLifeCycleFlag)) {
      query["DeviceLifeCycleFlag"] = request.deviceLifeCycleFlag;
    }

    if (!Util.isUnset(request.deviceStatusChangeFlag)) {
      query["DeviceStatusChangeFlag"] = request.deviceStatusChangeFlag;
    }

    if (!Util.isUnset(request.deviceTagFlag)) {
      query["DeviceTagFlag"] = request.deviceTagFlag;
    }

    if (!Util.isUnset(request.deviceTopoLifeCycleFlag)) {
      query["DeviceTopoLifeCycleFlag"] = request.deviceTopoLifeCycleFlag;
    }

    if (!Util.isUnset(request.foundDeviceListFlag)) {
      query["FoundDeviceListFlag"] = request.foundDeviceListFlag;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.mnsConfiguration)) {
      query["MnsConfiguration"] = request.mnsConfiguration;
    }

    if (!Util.isUnset(request.otaEventFlag)) {
      query["OtaEventFlag"] = request.otaEventFlag;
    }

    if (!Util.isUnset(request.otaJobFlag)) {
      query["OtaJobFlag"] = request.otaJobFlag;
    }

    if (!Util.isUnset(request.otaVersionFlag)) {
      query["OtaVersionFlag"] = request.otaVersionFlag;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.thingHistoryFlag)) {
      query["ThingHistoryFlag"] = request.thingHistoryFlag;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateSubscribeRelation",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateSubscribeRelationResponse>(await this.callApi(params, req, runtime), new CreateSubscribeRelationResponse({}));
  }

  async createSubscribeRelation(request: CreateSubscribeRelationRequest): Promise<CreateSubscribeRelationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createSubscribeRelationWithOptions(request, runtime);
  }

  async createThingModelWithOptions(request: CreateThingModelRequest, runtime: $Util.RuntimeOptions): Promise<CreateThingModelResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.functionBlockId)) {
      query["FunctionBlockId"] = request.functionBlockId;
    }

    if (!Util.isUnset(request.functionBlockName)) {
      query["FunctionBlockName"] = request.functionBlockName;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.thingModelJson)) {
      query["ThingModelJson"] = request.thingModelJson;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateThingModel",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateThingModelResponse>(await this.callApi(params, req, runtime), new CreateThingModelResponse({}));
  }

  async createThingModel(request: CreateThingModelRequest): Promise<CreateThingModelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createThingModelWithOptions(request, runtime);
  }

  async createThingScriptWithOptions(request: CreateThingScriptRequest, runtime: $Util.RuntimeOptions): Promise<CreateThingScriptResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.scriptContent)) {
      query["ScriptContent"] = request.scriptContent;
    }

    if (!Util.isUnset(request.scriptType)) {
      query["ScriptType"] = request.scriptType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateThingScript",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateThingScriptResponse>(await this.callApi(params, req, runtime), new CreateThingScriptResponse({}));
  }

  async createThingScript(request: CreateThingScriptRequest): Promise<CreateThingScriptResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createThingScriptWithOptions(request, runtime);
  }

  async createTopicRouteTableWithOptions(request: CreateTopicRouteTableRequest, runtime: $Util.RuntimeOptions): Promise<CreateTopicRouteTableResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dstTopic)) {
      query["DstTopic"] = request.dstTopic;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.srcTopic)) {
      query["SrcTopic"] = request.srcTopic;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateTopicRouteTable",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateTopicRouteTableResponse>(await this.callApi(params, req, runtime), new CreateTopicRouteTableResponse({}));
  }

  async createTopicRouteTable(request: CreateTopicRouteTableRequest): Promise<CreateTopicRouteTableResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createTopicRouteTableWithOptions(request, runtime);
  }

  async deleteConsumerGroupWithOptions(request: DeleteConsumerGroupRequest, runtime: $Util.RuntimeOptions): Promise<DeleteConsumerGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteConsumerGroup",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteConsumerGroupResponse>(await this.callApi(params, req, runtime), new DeleteConsumerGroupResponse({}));
  }

  async deleteConsumerGroup(request: DeleteConsumerGroupRequest): Promise<DeleteConsumerGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteConsumerGroupWithOptions(request, runtime);
  }

  async deleteConsumerGroupSubscribeRelationWithOptions(request: DeleteConsumerGroupSubscribeRelationRequest, runtime: $Util.RuntimeOptions): Promise<DeleteConsumerGroupSubscribeRelationResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.consumerGroupId)) {
      query["ConsumerGroupId"] = request.consumerGroupId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteConsumerGroupSubscribeRelation",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteConsumerGroupSubscribeRelationResponse>(await this.callApi(params, req, runtime), new DeleteConsumerGroupSubscribeRelationResponse({}));
  }

  async deleteConsumerGroupSubscribeRelation(request: DeleteConsumerGroupSubscribeRelationRequest): Promise<DeleteConsumerGroupSubscribeRelationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteConsumerGroupSubscribeRelationWithOptions(request, runtime);
  }

  async deleteDeviceWithOptions(request: DeleteDeviceRequest, runtime: $Util.RuntimeOptions): Promise<DeleteDeviceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotId)) {
      query["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteDevice",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteDeviceResponse>(await this.callApi(params, req, runtime), new DeleteDeviceResponse({}));
  }

  async deleteDevice(request: DeleteDeviceRequest): Promise<DeleteDeviceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteDeviceWithOptions(request, runtime);
  }

  async deleteDeviceDistributeJobWithOptions(request: DeleteDeviceDistributeJobRequest, runtime: $Util.RuntimeOptions): Promise<DeleteDeviceDistributeJobResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.jobId)) {
      query["JobId"] = request.jobId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteDeviceDistributeJob",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteDeviceDistributeJobResponse>(await this.callApi(params, req, runtime), new DeleteDeviceDistributeJobResponse({}));
  }

  async deleteDeviceDistributeJob(request: DeleteDeviceDistributeJobRequest): Promise<DeleteDeviceDistributeJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteDeviceDistributeJobWithOptions(request, runtime);
  }

  async deleteDeviceFileWithOptions(request: DeleteDeviceFileRequest, runtime: $Util.RuntimeOptions): Promise<DeleteDeviceFileResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.fileId)) {
      query["FileId"] = request.fileId;
    }

    if (!Util.isUnset(request.iotId)) {
      query["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteDeviceFile",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteDeviceFileResponse>(await this.callApi(params, req, runtime), new DeleteDeviceFileResponse({}));
  }

  async deleteDeviceFile(request: DeleteDeviceFileRequest): Promise<DeleteDeviceFileResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteDeviceFileWithOptions(request, runtime);
  }

  async deleteDeviceGroupWithOptions(request: DeleteDeviceGroupRequest, runtime: $Util.RuntimeOptions): Promise<DeleteDeviceGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteDeviceGroup",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteDeviceGroupResponse>(await this.callApi(params, req, runtime), new DeleteDeviceGroupResponse({}));
  }

  async deleteDeviceGroup(request: DeleteDeviceGroupRequest): Promise<DeleteDeviceGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteDeviceGroupWithOptions(request, runtime);
  }

  async deleteDevicePropWithOptions(request: DeleteDevicePropRequest, runtime: $Util.RuntimeOptions): Promise<DeleteDevicePropResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotId)) {
      query["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.propKey)) {
      query["PropKey"] = request.propKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteDeviceProp",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteDevicePropResponse>(await this.callApi(params, req, runtime), new DeleteDevicePropResponse({}));
  }

  async deleteDeviceProp(request: DeleteDevicePropRequest): Promise<DeleteDevicePropResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteDevicePropWithOptions(request, runtime);
  }

  async deleteEdgeDriverWithOptions(request: DeleteEdgeDriverRequest, runtime: $Util.RuntimeOptions): Promise<DeleteEdgeDriverResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.driverId)) {
      query["DriverId"] = request.driverId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteEdgeDriver",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteEdgeDriverResponse>(await this.callApi(params, req, runtime), new DeleteEdgeDriverResponse({}));
  }

  async deleteEdgeDriver(request: DeleteEdgeDriverRequest): Promise<DeleteEdgeDriverResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteEdgeDriverWithOptions(request, runtime);
  }

  async deleteEdgeDriverVersionWithOptions(request: DeleteEdgeDriverVersionRequest, runtime: $Util.RuntimeOptions): Promise<DeleteEdgeDriverVersionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.driverId)) {
      query["DriverId"] = request.driverId;
    }

    if (!Util.isUnset(request.driverVersion)) {
      query["DriverVersion"] = request.driverVersion;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteEdgeDriverVersion",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteEdgeDriverVersionResponse>(await this.callApi(params, req, runtime), new DeleteEdgeDriverVersionResponse({}));
  }

  async deleteEdgeDriverVersion(request: DeleteEdgeDriverVersionRequest): Promise<DeleteEdgeDriverVersionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteEdgeDriverVersionWithOptions(request, runtime);
  }

  async deleteEdgeInstanceWithOptions(request: DeleteEdgeInstanceRequest, runtime: $Util.RuntimeOptions): Promise<DeleteEdgeInstanceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteEdgeInstance",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteEdgeInstanceResponse>(await this.callApi(params, req, runtime), new DeleteEdgeInstanceResponse({}));
  }

  async deleteEdgeInstance(request: DeleteEdgeInstanceRequest): Promise<DeleteEdgeInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteEdgeInstanceWithOptions(request, runtime);
  }

  async deleteEdgeInstanceMessageRoutingWithOptions(request: DeleteEdgeInstanceMessageRoutingRequest, runtime: $Util.RuntimeOptions): Promise<DeleteEdgeInstanceMessageRoutingResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.routeId)) {
      query["RouteId"] = request.routeId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteEdgeInstanceMessageRouting",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteEdgeInstanceMessageRoutingResponse>(await this.callApi(params, req, runtime), new DeleteEdgeInstanceMessageRoutingResponse({}));
  }

  async deleteEdgeInstanceMessageRouting(request: DeleteEdgeInstanceMessageRoutingRequest): Promise<DeleteEdgeInstanceMessageRoutingResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteEdgeInstanceMessageRoutingWithOptions(request, runtime);
  }

  async deleteJobWithOptions(request: DeleteJobRequest, runtime: $Util.RuntimeOptions): Promise<DeleteJobResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.jobId)) {
      query["JobId"] = request.jobId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteJob",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteJobResponse>(await this.callApi(params, req, runtime), new DeleteJobResponse({}));
  }

  async deleteJob(request: DeleteJobRequest): Promise<DeleteJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteJobWithOptions(request, runtime);
  }

  async deleteOTAFirmwareWithOptions(request: DeleteOTAFirmwareRequest, runtime: $Util.RuntimeOptions): Promise<DeleteOTAFirmwareResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.firmwareId)) {
      query["FirmwareId"] = request.firmwareId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteOTAFirmware",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteOTAFirmwareResponse>(await this.callApi(params, req, runtime), new DeleteOTAFirmwareResponse({}));
  }

  async deleteOTAFirmware(request: DeleteOTAFirmwareRequest): Promise<DeleteOTAFirmwareResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteOTAFirmwareWithOptions(request, runtime);
  }

  async deleteOTAModuleWithOptions(request: DeleteOTAModuleRequest, runtime: $Util.RuntimeOptions): Promise<DeleteOTAModuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.moduleName)) {
      query["ModuleName"] = request.moduleName;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteOTAModule",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteOTAModuleResponse>(await this.callApi(params, req, runtime), new DeleteOTAModuleResponse({}));
  }

  async deleteOTAModule(request: DeleteOTAModuleRequest): Promise<DeleteOTAModuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteOTAModuleWithOptions(request, runtime);
  }

  async deleteProductWithOptions(request: DeleteProductRequest, runtime: $Util.RuntimeOptions): Promise<DeleteProductResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteProduct",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteProductResponse>(await this.callApi(params, req, runtime), new DeleteProductResponse({}));
  }

  async deleteProduct(request: DeleteProductRequest): Promise<DeleteProductResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteProductWithOptions(request, runtime);
  }

  async deleteProductTagsWithOptions(request: DeleteProductTagsRequest, runtime: $Util.RuntimeOptions): Promise<DeleteProductTagsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.productTagKey)) {
      query["ProductTagKey"] = request.productTagKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteProductTags",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteProductTagsResponse>(await this.callApi(params, req, runtime), new DeleteProductTagsResponse({}));
  }

  async deleteProductTags(request: DeleteProductTagsRequest): Promise<DeleteProductTagsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteProductTagsWithOptions(request, runtime);
  }

  async deleteProductTopicWithOptions(request: DeleteProductTopicRequest, runtime: $Util.RuntimeOptions): Promise<DeleteProductTopicResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.topicId)) {
      query["TopicId"] = request.topicId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteProductTopic",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteProductTopicResponse>(await this.callApi(params, req, runtime), new DeleteProductTopicResponse({}));
  }

  async deleteProductTopic(request: DeleteProductTopicRequest): Promise<DeleteProductTopicResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteProductTopicWithOptions(request, runtime);
  }

  async deleteRuleWithOptions(request: DeleteRuleRequest, runtime: $Util.RuntimeOptions): Promise<DeleteRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.ruleId)) {
      query["RuleId"] = request.ruleId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteRule",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteRuleResponse>(await this.callApi(params, req, runtime), new DeleteRuleResponse({}));
  }

  async deleteRule(request: DeleteRuleRequest): Promise<DeleteRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteRuleWithOptions(request, runtime);
  }

  async deleteRuleActionWithOptions(request: DeleteRuleActionRequest, runtime: $Util.RuntimeOptions): Promise<DeleteRuleActionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.actionId)) {
      query["ActionId"] = request.actionId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteRuleAction",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteRuleActionResponse>(await this.callApi(params, req, runtime), new DeleteRuleActionResponse({}));
  }

  async deleteRuleAction(request: DeleteRuleActionRequest): Promise<DeleteRuleActionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteRuleActionWithOptions(request, runtime);
  }

  async deleteSceneRuleWithOptions(request: DeleteSceneRuleRequest, runtime: $Util.RuntimeOptions): Promise<DeleteSceneRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.ruleId)) {
      query["RuleId"] = request.ruleId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteSceneRule",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteSceneRuleResponse>(await this.callApi(params, req, runtime), new DeleteSceneRuleResponse({}));
  }

  async deleteSceneRule(request: DeleteSceneRuleRequest): Promise<DeleteSceneRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteSceneRuleWithOptions(request, runtime);
  }

  async deleteSpeechWithOptions(request: DeleteSpeechRequest, runtime: $Util.RuntimeOptions): Promise<DeleteSpeechResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: request.iotInstanceId,
    });
    let params = new $OpenApi.Params({
      action: "DeleteSpeech",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteSpeechResponse>(await this.callApi(params, req, runtime), new DeleteSpeechResponse({}));
  }

  async deleteSpeech(request: DeleteSpeechRequest): Promise<DeleteSpeechResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteSpeechWithOptions(request, runtime);
  }

  async deleteStudioAppDomainOpenWithOptions(request: DeleteStudioAppDomainOpenRequest, runtime: $Util.RuntimeOptions): Promise<DeleteStudioAppDomainOpenResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: request.appId,
    });
    let params = new $OpenApi.Params({
      action: "DeleteStudioAppDomainOpen",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteStudioAppDomainOpenResponse>(await this.callApi(params, req, runtime), new DeleteStudioAppDomainOpenResponse({}));
  }

  async deleteStudioAppDomainOpen(request: DeleteStudioAppDomainOpenRequest): Promise<DeleteStudioAppDomainOpenResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteStudioAppDomainOpenWithOptions(request, runtime);
  }

  async deleteSubscribeRelationWithOptions(request: DeleteSubscribeRelationRequest, runtime: $Util.RuntimeOptions): Promise<DeleteSubscribeRelationResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteSubscribeRelation",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteSubscribeRelationResponse>(await this.callApi(params, req, runtime), new DeleteSubscribeRelationResponse({}));
  }

  async deleteSubscribeRelation(request: DeleteSubscribeRelationRequest): Promise<DeleteSubscribeRelationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteSubscribeRelationWithOptions(request, runtime);
  }

  async deleteThingModelWithOptions(request: DeleteThingModelRequest, runtime: $Util.RuntimeOptions): Promise<DeleteThingModelResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.eventIdentifier)) {
      query["EventIdentifier"] = request.eventIdentifier;
    }

    if (!Util.isUnset(request.functionBlockId)) {
      query["FunctionBlockId"] = request.functionBlockId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.propertyIdentifier)) {
      query["PropertyIdentifier"] = request.propertyIdentifier;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.serviceIdentifier)) {
      query["ServiceIdentifier"] = request.serviceIdentifier;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteThingModel",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteThingModelResponse>(await this.callApi(params, req, runtime), new DeleteThingModelResponse({}));
  }

  async deleteThingModel(request: DeleteThingModelRequest): Promise<DeleteThingModelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteThingModelWithOptions(request, runtime);
  }

  async deleteTopicRouteTableWithOptions(request: DeleteTopicRouteTableRequest, runtime: $Util.RuntimeOptions): Promise<DeleteTopicRouteTableResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dstTopic)) {
      query["DstTopic"] = request.dstTopic;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.srcTopic)) {
      query["SrcTopic"] = request.srcTopic;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteTopicRouteTable",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteTopicRouteTableResponse>(await this.callApi(params, req, runtime), new DeleteTopicRouteTableResponse({}));
  }

  async deleteTopicRouteTable(request: DeleteTopicRouteTableRequest): Promise<DeleteTopicRouteTableResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteTopicRouteTableWithOptions(request, runtime);
  }

  async disableDeviceTunnelWithOptions(request: DisableDeviceTunnelRequest, runtime: $Util.RuntimeOptions): Promise<DisableDeviceTunnelResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DisableDeviceTunnel",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DisableDeviceTunnelResponse>(await this.callApi(params, req, runtime), new DisableDeviceTunnelResponse({}));
  }

  async disableDeviceTunnel(request: DisableDeviceTunnelRequest): Promise<DisableDeviceTunnelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.disableDeviceTunnelWithOptions(request, runtime);
  }

  async disableDeviceTunnelShareWithOptions(request: DisableDeviceTunnelShareRequest, runtime: $Util.RuntimeOptions): Promise<DisableDeviceTunnelShareResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DisableDeviceTunnelShare",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DisableDeviceTunnelShareResponse>(await this.callApi(params, req, runtime), new DisableDeviceTunnelShareResponse({}));
  }

  async disableDeviceTunnelShare(request: DisableDeviceTunnelShareRequest): Promise<DisableDeviceTunnelShareResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.disableDeviceTunnelShareWithOptions(request, runtime);
  }

  async disableSceneRuleWithOptions(request: DisableSceneRuleRequest, runtime: $Util.RuntimeOptions): Promise<DisableSceneRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.ruleId)) {
      query["RuleId"] = request.ruleId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DisableSceneRule",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DisableSceneRuleResponse>(await this.callApi(params, req, runtime), new DisableSceneRuleResponse({}));
  }

  async disableSceneRule(request: DisableSceneRuleRequest): Promise<DisableSceneRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.disableSceneRuleWithOptions(request, runtime);
  }

  async disableThingWithOptions(request: DisableThingRequest, runtime: $Util.RuntimeOptions): Promise<DisableThingResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotId)) {
      query["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DisableThing",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DisableThingResponse>(await this.callApi(params, req, runtime), new DisableThingResponse({}));
  }

  async disableThing(request: DisableThingRequest): Promise<DisableThingResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.disableThingWithOptions(request, runtime);
  }

  async enableDeviceTunnelWithOptions(request: EnableDeviceTunnelRequest, runtime: $Util.RuntimeOptions): Promise<EnableDeviceTunnelResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "EnableDeviceTunnel",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<EnableDeviceTunnelResponse>(await this.callApi(params, req, runtime), new EnableDeviceTunnelResponse({}));
  }

  async enableDeviceTunnel(request: EnableDeviceTunnelRequest): Promise<EnableDeviceTunnelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.enableDeviceTunnelWithOptions(request, runtime);
  }

  async enableDeviceTunnelShareWithOptions(request: EnableDeviceTunnelShareRequest, runtime: $Util.RuntimeOptions): Promise<EnableDeviceTunnelShareResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "EnableDeviceTunnelShare",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<EnableDeviceTunnelShareResponse>(await this.callApi(params, req, runtime), new EnableDeviceTunnelShareResponse({}));
  }

  async enableDeviceTunnelShare(request: EnableDeviceTunnelShareRequest): Promise<EnableDeviceTunnelShareResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.enableDeviceTunnelShareWithOptions(request, runtime);
  }

  async enableSceneRuleWithOptions(request: EnableSceneRuleRequest, runtime: $Util.RuntimeOptions): Promise<EnableSceneRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.ruleId)) {
      query["RuleId"] = request.ruleId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "EnableSceneRule",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<EnableSceneRuleResponse>(await this.callApi(params, req, runtime), new EnableSceneRuleResponse({}));
  }

  async enableSceneRule(request: EnableSceneRuleRequest): Promise<EnableSceneRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.enableSceneRuleWithOptions(request, runtime);
  }

  async enableThingWithOptions(request: EnableThingRequest, runtime: $Util.RuntimeOptions): Promise<EnableThingResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotId)) {
      query["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "EnableThing",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<EnableThingResponse>(await this.callApi(params, req, runtime), new EnableThingResponse({}));
  }

  async enableThing(request: EnableThingRequest): Promise<EnableThingResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.enableThingWithOptions(request, runtime);
  }

  async generateDeviceNameListURLWithOptions(request: GenerateDeviceNameListURLRequest, runtime: $Util.RuntimeOptions): Promise<GenerateDeviceNameListURLResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GenerateDeviceNameListURL",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GenerateDeviceNameListURLResponse>(await this.callApi(params, req, runtime), new GenerateDeviceNameListURLResponse({}));
  }

  async generateDeviceNameListURL(request: GenerateDeviceNameListURLRequest): Promise<GenerateDeviceNameListURLResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.generateDeviceNameListURLWithOptions(request, runtime);
  }

  async generateFileUploadURLWithOptions(request: GenerateFileUploadURLRequest, runtime: $Util.RuntimeOptions): Promise<GenerateFileUploadURLResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.bizCode)) {
      query["BizCode"] = request.bizCode;
    }

    if (!Util.isUnset(request.fileName)) {
      query["FileName"] = request.fileName;
    }

    if (!Util.isUnset(request.fileSuffix)) {
      query["FileSuffix"] = request.fileSuffix;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GenerateFileUploadURL",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GenerateFileUploadURLResponse>(await this.callApi(params, req, runtime), new GenerateFileUploadURLResponse({}));
  }

  async generateFileUploadURL(request: GenerateFileUploadURLRequest): Promise<GenerateFileUploadURLResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.generateFileUploadURLWithOptions(request, runtime);
  }

  async generateOTAUploadURLWithOptions(request: GenerateOTAUploadURLRequest, runtime: $Util.RuntimeOptions): Promise<GenerateOTAUploadURLResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.fileSuffix)) {
      query["FileSuffix"] = request.fileSuffix;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GenerateOTAUploadURL",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GenerateOTAUploadURLResponse>(await this.callApi(params, req, runtime), new GenerateOTAUploadURLResponse({}));
  }

  async generateOTAUploadURL(request: GenerateOTAUploadURLRequest): Promise<GenerateOTAUploadURLResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.generateOTAUploadURLWithOptions(request, runtime);
  }

  async getDataAPIServiceDetailWithOptions(request: GetDataAPIServiceDetailRequest, runtime: $Util.RuntimeOptions): Promise<GetDataAPIServiceDetailResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: request.apiSrn,
    });
    let params = new $OpenApi.Params({
      action: "GetDataAPIServiceDetail",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDataAPIServiceDetailResponse>(await this.callApi(params, req, runtime), new GetDataAPIServiceDetailResponse({}));
  }

  async getDataAPIServiceDetail(request: GetDataAPIServiceDetailRequest): Promise<GetDataAPIServiceDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDataAPIServiceDetailWithOptions(request, runtime);
  }

  async getDeviceShadowWithOptions(request: GetDeviceShadowRequest, runtime: $Util.RuntimeOptions): Promise<GetDeviceShadowResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetDeviceShadow",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDeviceShadowResponse>(await this.callApi(params, req, runtime), new GetDeviceShadowResponse({}));
  }

  async getDeviceShadow(request: GetDeviceShadowRequest): Promise<GetDeviceShadowResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDeviceShadowWithOptions(request, runtime);
  }

  async getDeviceStatusWithOptions(request: GetDeviceStatusRequest, runtime: $Util.RuntimeOptions): Promise<GetDeviceStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotId)) {
      query["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetDeviceStatus",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDeviceStatusResponse>(await this.callApi(params, req, runtime), new GetDeviceStatusResponse({}));
  }

  async getDeviceStatus(request: GetDeviceStatusRequest): Promise<GetDeviceStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDeviceStatusWithOptions(request, runtime);
  }

  async getDeviceTunnelShareStatusWithOptions(request: GetDeviceTunnelShareStatusRequest, runtime: $Util.RuntimeOptions): Promise<GetDeviceTunnelShareStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetDeviceTunnelShareStatus",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDeviceTunnelShareStatusResponse>(await this.callApi(params, req, runtime), new GetDeviceTunnelShareStatusResponse({}));
  }

  async getDeviceTunnelShareStatus(request: GetDeviceTunnelShareStatusRequest): Promise<GetDeviceTunnelShareStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDeviceTunnelShareStatusWithOptions(request, runtime);
  }

  async getDeviceTunnelStatusWithOptions(request: GetDeviceTunnelStatusRequest, runtime: $Util.RuntimeOptions): Promise<GetDeviceTunnelStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetDeviceTunnelStatus",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDeviceTunnelStatusResponse>(await this.callApi(params, req, runtime), new GetDeviceTunnelStatusResponse({}));
  }

  async getDeviceTunnelStatus(request: GetDeviceTunnelStatusRequest): Promise<GetDeviceTunnelStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDeviceTunnelStatusWithOptions(request, runtime);
  }

  async getEdgeDriverVersionWithOptions(request: GetEdgeDriverVersionRequest, runtime: $Util.RuntimeOptions): Promise<GetEdgeDriverVersionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.driverId)) {
      query["DriverId"] = request.driverId;
    }

    if (!Util.isUnset(request.driverVersion)) {
      query["DriverVersion"] = request.driverVersion;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetEdgeDriverVersion",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetEdgeDriverVersionResponse>(await this.callApi(params, req, runtime), new GetEdgeDriverVersionResponse({}));
  }

  async getEdgeDriverVersion(request: GetEdgeDriverVersionRequest): Promise<GetEdgeDriverVersionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getEdgeDriverVersionWithOptions(request, runtime);
  }

  async getEdgeInstanceWithOptions(request: GetEdgeInstanceRequest, runtime: $Util.RuntimeOptions): Promise<GetEdgeInstanceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetEdgeInstance",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetEdgeInstanceResponse>(await this.callApi(params, req, runtime), new GetEdgeInstanceResponse({}));
  }

  async getEdgeInstance(request: GetEdgeInstanceRequest): Promise<GetEdgeInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getEdgeInstanceWithOptions(request, runtime);
  }

  async getEdgeInstanceDeploymentWithOptions(request: GetEdgeInstanceDeploymentRequest, runtime: $Util.RuntimeOptions): Promise<GetEdgeInstanceDeploymentResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deploymentId)) {
      query["DeploymentId"] = request.deploymentId;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetEdgeInstanceDeployment",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetEdgeInstanceDeploymentResponse>(await this.callApi(params, req, runtime), new GetEdgeInstanceDeploymentResponse({}));
  }

  async getEdgeInstanceDeployment(request: GetEdgeInstanceDeploymentRequest): Promise<GetEdgeInstanceDeploymentResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getEdgeInstanceDeploymentWithOptions(request, runtime);
  }

  async getEdgeInstanceMessageRoutingWithOptions(request: GetEdgeInstanceMessageRoutingRequest, runtime: $Util.RuntimeOptions): Promise<GetEdgeInstanceMessageRoutingResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.routeId)) {
      query["RouteId"] = request.routeId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetEdgeInstanceMessageRouting",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetEdgeInstanceMessageRoutingResponse>(await this.callApi(params, req, runtime), new GetEdgeInstanceMessageRoutingResponse({}));
  }

  async getEdgeInstanceMessageRouting(request: GetEdgeInstanceMessageRoutingRequest): Promise<GetEdgeInstanceMessageRoutingResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getEdgeInstanceMessageRoutingWithOptions(request, runtime);
  }

  async getGatewayBySubDeviceWithOptions(request: GetGatewayBySubDeviceRequest, runtime: $Util.RuntimeOptions): Promise<GetGatewayBySubDeviceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotId)) {
      query["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetGatewayBySubDevice",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetGatewayBySubDeviceResponse>(await this.callApi(params, req, runtime), new GetGatewayBySubDeviceResponse({}));
  }

  async getGatewayBySubDevice(request: GetGatewayBySubDeviceRequest): Promise<GetGatewayBySubDeviceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getGatewayBySubDeviceWithOptions(request, runtime);
  }

  async getLoraNodesTaskWithOptions(request: GetLoraNodesTaskRequest, runtime: $Util.RuntimeOptions): Promise<GetLoraNodesTaskResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.taskId)) {
      query["TaskId"] = request.taskId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetLoraNodesTask",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetLoraNodesTaskResponse>(await this.callApi(params, req, runtime), new GetLoraNodesTaskResponse({}));
  }

  async getLoraNodesTask(request: GetLoraNodesTaskRequest): Promise<GetLoraNodesTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getLoraNodesTaskWithOptions(request, runtime);
  }

  async getNodesAddingTaskWithOptions(request: GetNodesAddingTaskRequest, runtime: $Util.RuntimeOptions): Promise<GetNodesAddingTaskResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.taskId)) {
      query["TaskId"] = request.taskId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetNodesAddingTask",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetNodesAddingTaskResponse>(await this.callApi(params, req, runtime), new GetNodesAddingTaskResponse({}));
  }

  async getNodesAddingTask(request: GetNodesAddingTaskRequest): Promise<GetNodesAddingTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getNodesAddingTaskWithOptions(request, runtime);
  }

  async getRuleWithOptions(request: GetRuleRequest, runtime: $Util.RuntimeOptions): Promise<GetRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.ruleId)) {
      query["RuleId"] = request.ruleId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetRule",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetRuleResponse>(await this.callApi(params, req, runtime), new GetRuleResponse({}));
  }

  async getRule(request: GetRuleRequest): Promise<GetRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getRuleWithOptions(request, runtime);
  }

  async getRuleActionWithOptions(request: GetRuleActionRequest, runtime: $Util.RuntimeOptions): Promise<GetRuleActionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.actionId)) {
      query["ActionId"] = request.actionId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetRuleAction",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetRuleActionResponse>(await this.callApi(params, req, runtime), new GetRuleActionResponse({}));
  }

  async getRuleAction(request: GetRuleActionRequest): Promise<GetRuleActionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getRuleActionWithOptions(request, runtime);
  }

  async getSceneRuleWithOptions(request: GetSceneRuleRequest, runtime: $Util.RuntimeOptions): Promise<GetSceneRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.ruleId)) {
      query["RuleId"] = request.ruleId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetSceneRule",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetSceneRuleResponse>(await this.callApi(params, req, runtime), new GetSceneRuleResponse({}));
  }

  async getSceneRule(request: GetSceneRuleRequest): Promise<GetSceneRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getSceneRuleWithOptions(request, runtime);
  }

  async getSpeechVoiceWithOptions(runtime: $Util.RuntimeOptions): Promise<GetSpeechVoiceResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "GetSpeechVoice",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetSpeechVoiceResponse>(await this.callApi(params, req, runtime), new GetSpeechVoiceResponse({}));
  }

  async getSpeechVoice(): Promise<GetSpeechVoiceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getSpeechVoiceWithOptions(runtime);
  }

  async getStudioAppTokenOpenWithOptions(request: GetStudioAppTokenOpenRequest, runtime: $Util.RuntimeOptions): Promise<GetStudioAppTokenOpenResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: request.appId,
    });
    let params = new $OpenApi.Params({
      action: "GetStudioAppTokenOpen",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetStudioAppTokenOpenResponse>(await this.callApi(params, req, runtime), new GetStudioAppTokenOpenResponse({}));
  }

  async getStudioAppTokenOpen(request: GetStudioAppTokenOpenRequest): Promise<GetStudioAppTokenOpenResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getStudioAppTokenOpenWithOptions(request, runtime);
  }

  async getThingModelTslWithOptions(request: GetThingModelTslRequest, runtime: $Util.RuntimeOptions): Promise<GetThingModelTslResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.functionBlockId)) {
      query["FunctionBlockId"] = request.functionBlockId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.modelVersion)) {
      query["ModelVersion"] = request.modelVersion;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.simple)) {
      query["Simple"] = request.simple;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetThingModelTsl",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetThingModelTslResponse>(await this.callApi(params, req, runtime), new GetThingModelTslResponse({}));
  }

  async getThingModelTsl(request: GetThingModelTslRequest): Promise<GetThingModelTslResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getThingModelTslWithOptions(request, runtime);
  }

  async getThingModelTslPublishedWithOptions(request: GetThingModelTslPublishedRequest, runtime: $Util.RuntimeOptions): Promise<GetThingModelTslPublishedResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.functionBlockId)) {
      query["FunctionBlockId"] = request.functionBlockId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.modelVersion)) {
      query["ModelVersion"] = request.modelVersion;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.simple)) {
      query["Simple"] = request.simple;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetThingModelTslPublished",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetThingModelTslPublishedResponse>(await this.callApi(params, req, runtime), new GetThingModelTslPublishedResponse({}));
  }

  async getThingModelTslPublished(request: GetThingModelTslPublishedRequest): Promise<GetThingModelTslPublishedResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getThingModelTslPublishedWithOptions(request, runtime);
  }

  async getThingScriptWithOptions(request: GetThingScriptRequest, runtime: $Util.RuntimeOptions): Promise<GetThingScriptResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetThingScript",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetThingScriptResponse>(await this.callApi(params, req, runtime), new GetThingScriptResponse({}));
  }

  async getThingScript(request: GetThingScriptRequest): Promise<GetThingScriptResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getThingScriptWithOptions(request, runtime);
  }

  async getThingTemplateWithOptions(request: GetThingTemplateRequest, runtime: $Util.RuntimeOptions): Promise<GetThingTemplateResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.categoryKey)) {
      query["CategoryKey"] = request.categoryKey;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetThingTemplate",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetThingTemplateResponse>(await this.callApi(params, req, runtime), new GetThingTemplateResponse({}));
  }

  async getThingTemplate(request: GetThingTemplateRequest): Promise<GetThingTemplateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getThingTemplateWithOptions(request, runtime);
  }

  async getThingTopoWithOptions(request: GetThingTopoRequest, runtime: $Util.RuntimeOptions): Promise<GetThingTopoResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotId)) {
      query["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageNo)) {
      query["PageNo"] = request.pageNo;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetThingTopo",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetThingTopoResponse>(await this.callApi(params, req, runtime), new GetThingTopoResponse({}));
  }

  async getThingTopo(request: GetThingTopoRequest): Promise<GetThingTopoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getThingTopoWithOptions(request, runtime);
  }

  async importThingModelTslWithOptions(request: ImportThingModelTslRequest, runtime: $Util.RuntimeOptions): Promise<ImportThingModelTslResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.functionBlockId)) {
      query["FunctionBlockId"] = request.functionBlockId;
    }

    if (!Util.isUnset(request.functionBlockName)) {
      query["FunctionBlockName"] = request.functionBlockName;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.tslStr)) {
      query["TslStr"] = request.tslStr;
    }

    if (!Util.isUnset(request.tslUrl)) {
      query["TslUrl"] = request.tslUrl;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ImportThingModelTsl",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ImportThingModelTslResponse>(await this.callApi(params, req, runtime), new ImportThingModelTslResponse({}));
  }

  async importThingModelTsl(request: ImportThingModelTslRequest): Promise<ImportThingModelTslResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.importThingModelTslWithOptions(request, runtime);
  }

  async invokeDataAPIServiceWithOptions(request: InvokeDataAPIServiceRequest, runtime: $Util.RuntimeOptions): Promise<InvokeDataAPIServiceResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: Util.toArray(request.apiSrn),
    });
    let params = new $OpenApi.Params({
      action: "InvokeDataAPIService",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<InvokeDataAPIServiceResponse>(await this.callApi(params, req, runtime), new InvokeDataAPIServiceResponse({}));
  }

  async invokeDataAPIService(request: InvokeDataAPIServiceRequest): Promise<InvokeDataAPIServiceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.invokeDataAPIServiceWithOptions(request, runtime);
  }

  async invokeThingServiceWithOptions(request: InvokeThingServiceRequest, runtime: $Util.RuntimeOptions): Promise<InvokeThingServiceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.args)) {
      query["Args"] = request.args;
    }

    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.identifier)) {
      query["Identifier"] = request.identifier;
    }

    if (!Util.isUnset(request.iotId)) {
      query["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "InvokeThingService",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<InvokeThingServiceResponse>(await this.callApi(params, req, runtime), new InvokeThingServiceResponse({}));
  }

  async invokeThingService(request: InvokeThingServiceRequest): Promise<InvokeThingServiceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.invokeThingServiceWithOptions(request, runtime);
  }

  async invokeThingsServiceWithOptions(request: InvokeThingsServiceRequest, runtime: $Util.RuntimeOptions): Promise<InvokeThingsServiceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.args)) {
      query["Args"] = request.args;
    }

    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.identifier)) {
      query["Identifier"] = request.identifier;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "InvokeThingsService",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<InvokeThingsServiceResponse>(await this.callApi(params, req, runtime), new InvokeThingsServiceResponse({}));
  }

  async invokeThingsService(request: InvokeThingsServiceRequest): Promise<InvokeThingsServiceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.invokeThingsServiceWithOptions(request, runtime);
  }

  async listAnalyticsDataWithOptions(request: ListAnalyticsDataRequest, runtime: $Util.RuntimeOptions): Promise<ListAnalyticsDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.apiPath)) {
      query["ApiPath"] = request.apiPath;
    }

    if (!Util.isUnset(request.condition)) {
      query["Condition"] = request.condition;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.isoId)) {
      query["IsoId"] = request.isoId;
    }

    if (!Util.isUnset(request.pageNum)) {
      query["PageNum"] = request.pageNum;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListAnalyticsData",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListAnalyticsDataResponse>(await this.callApi(params, req, runtime), new ListAnalyticsDataResponse({}));
  }

  async listAnalyticsData(request: ListAnalyticsDataRequest): Promise<ListAnalyticsDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listAnalyticsDataWithOptions(request, runtime);
  }

  async listDeviceDistributeJobWithOptions(request: ListDeviceDistributeJobRequest, runtime: $Util.RuntimeOptions): Promise<ListDeviceDistributeJobResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    if (!Util.isUnset(request.targetUid)) {
      query["TargetUid"] = request.targetUid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: request.jobId,
    });
    let params = new $OpenApi.Params({
      action: "ListDeviceDistributeJob",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListDeviceDistributeJobResponse>(await this.callApi(params, req, runtime), new ListDeviceDistributeJobResponse({}));
  }

  async listDeviceDistributeJob(request: ListDeviceDistributeJobRequest): Promise<ListDeviceDistributeJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listDeviceDistributeJobWithOptions(request, runtime);
  }

  async listDistributedDeviceWithOptions(request: ListDistributedDeviceRequest, runtime: $Util.RuntimeOptions): Promise<ListDistributedDeviceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.sourceInstanceId)) {
      query["SourceInstanceId"] = request.sourceInstanceId;
    }

    if (!Util.isUnset(request.targetUid)) {
      query["TargetUid"] = request.targetUid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListDistributedDevice",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListDistributedDeviceResponse>(await this.callApi(params, req, runtime), new ListDistributedDeviceResponse({}));
  }

  async listDistributedDevice(request: ListDistributedDeviceRequest): Promise<ListDistributedDeviceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listDistributedDeviceWithOptions(request, runtime);
  }

  async listDistributedProductWithOptions(request: ListDistributedProductRequest, runtime: $Util.RuntimeOptions): Promise<ListDistributedProductResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.sourceInstanceId)) {
      query["SourceInstanceId"] = request.sourceInstanceId;
    }

    if (!Util.isUnset(request.targetInstanceId)) {
      query["TargetInstanceId"] = request.targetInstanceId;
    }

    if (!Util.isUnset(request.targetUid)) {
      query["TargetUid"] = request.targetUid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListDistributedProduct",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListDistributedProductResponse>(await this.callApi(params, req, runtime), new ListDistributedProductResponse({}));
  }

  async listDistributedProduct(request: ListDistributedProductRequest): Promise<ListDistributedProductResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listDistributedProductWithOptions(request, runtime);
  }

  async listJobWithOptions(request: ListJobRequest, runtime: $Util.RuntimeOptions): Promise<ListJobResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListJob",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListJobResponse>(await this.callApi(params, req, runtime), new ListJobResponse({}));
  }

  async listJob(request: ListJobRequest): Promise<ListJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listJobWithOptions(request, runtime);
  }

  async listOTAFirmwareWithOptions(request: ListOTAFirmwareRequest, runtime: $Util.RuntimeOptions): Promise<ListOTAFirmwareResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.destVersion)) {
      query["DestVersion"] = request.destVersion;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListOTAFirmware",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListOTAFirmwareResponse>(await this.callApi(params, req, runtime), new ListOTAFirmwareResponse({}));
  }

  async listOTAFirmware(request: ListOTAFirmwareRequest): Promise<ListOTAFirmwareResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listOTAFirmwareWithOptions(request, runtime);
  }

  async listOTAJobByDeviceWithOptions(request: ListOTAJobByDeviceRequest, runtime: $Util.RuntimeOptions): Promise<ListOTAJobByDeviceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.firmwareId)) {
      query["FirmwareId"] = request.firmwareId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListOTAJobByDevice",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListOTAJobByDeviceResponse>(await this.callApi(params, req, runtime), new ListOTAJobByDeviceResponse({}));
  }

  async listOTAJobByDevice(request: ListOTAJobByDeviceRequest): Promise<ListOTAJobByDeviceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listOTAJobByDeviceWithOptions(request, runtime);
  }

  async listOTAJobByFirmwareWithOptions(request: ListOTAJobByFirmwareRequest, runtime: $Util.RuntimeOptions): Promise<ListOTAJobByFirmwareResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.firmwareId)) {
      query["FirmwareId"] = request.firmwareId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListOTAJobByFirmware",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListOTAJobByFirmwareResponse>(await this.callApi(params, req, runtime), new ListOTAJobByFirmwareResponse({}));
  }

  async listOTAJobByFirmware(request: ListOTAJobByFirmwareRequest): Promise<ListOTAJobByFirmwareResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listOTAJobByFirmwareWithOptions(request, runtime);
  }

  async listOTAModuleByProductWithOptions(request: ListOTAModuleByProductRequest, runtime: $Util.RuntimeOptions): Promise<ListOTAModuleByProductResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListOTAModuleByProduct",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListOTAModuleByProductResponse>(await this.callApi(params, req, runtime), new ListOTAModuleByProductResponse({}));
  }

  async listOTAModuleByProduct(request: ListOTAModuleByProductRequest): Promise<ListOTAModuleByProductResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listOTAModuleByProductWithOptions(request, runtime);
  }

  async listOTAModuleVersionsByDeviceWithOptions(request: ListOTAModuleVersionsByDeviceRequest, runtime: $Util.RuntimeOptions): Promise<ListOTAModuleVersionsByDeviceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotId)) {
      query["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListOTAModuleVersionsByDevice",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListOTAModuleVersionsByDeviceResponse>(await this.callApi(params, req, runtime), new ListOTAModuleVersionsByDeviceResponse({}));
  }

  async listOTAModuleVersionsByDevice(request: ListOTAModuleVersionsByDeviceRequest): Promise<ListOTAModuleVersionsByDeviceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listOTAModuleVersionsByDeviceWithOptions(request, runtime);
  }

  async listOTATaskByJobWithOptions(request: ListOTATaskByJobRequest, runtime: $Util.RuntimeOptions): Promise<ListOTATaskByJobResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.deviceNames)) {
      query["DeviceNames"] = request.deviceNames;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.jobId)) {
      query["JobId"] = request.jobId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.taskStatus)) {
      query["TaskStatus"] = request.taskStatus;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListOTATaskByJob",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListOTATaskByJobResponse>(await this.callApi(params, req, runtime), new ListOTATaskByJobResponse({}));
  }

  async listOTATaskByJob(request: ListOTATaskByJobRequest): Promise<ListOTATaskByJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listOTATaskByJobWithOptions(request, runtime);
  }

  async listOTAUnfinishedTaskByDeviceWithOptions(request: ListOTAUnfinishedTaskByDeviceRequest, runtime: $Util.RuntimeOptions): Promise<ListOTAUnfinishedTaskByDeviceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotId)) {
      query["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.moduleName)) {
      query["ModuleName"] = request.moduleName;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.taskStatus)) {
      query["TaskStatus"] = request.taskStatus;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListOTAUnfinishedTaskByDevice",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListOTAUnfinishedTaskByDeviceResponse>(await this.callApi(params, req, runtime), new ListOTAUnfinishedTaskByDeviceResponse({}));
  }

  async listOTAUnfinishedTaskByDevice(request: ListOTAUnfinishedTaskByDeviceRequest): Promise<ListOTAUnfinishedTaskByDeviceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listOTAUnfinishedTaskByDeviceWithOptions(request, runtime);
  }

  async listProductByTagsWithOptions(request: ListProductByTagsRequest, runtime: $Util.RuntimeOptions): Promise<ListProductByTagsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.productTag)) {
      query["ProductTag"] = request.productTag;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListProductByTags",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListProductByTagsResponse>(await this.callApi(params, req, runtime), new ListProductByTagsResponse({}));
  }

  async listProductByTags(request: ListProductByTagsRequest): Promise<ListProductByTagsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listProductByTagsWithOptions(request, runtime);
  }

  async listProductTagsWithOptions(request: ListProductTagsRequest, runtime: $Util.RuntimeOptions): Promise<ListProductTagsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListProductTags",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListProductTagsResponse>(await this.callApi(params, req, runtime), new ListProductTagsResponse({}));
  }

  async listProductTags(request: ListProductTagsRequest): Promise<ListProductTagsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listProductTagsWithOptions(request, runtime);
  }

  async listRuleWithOptions(request: ListRuleRequest, runtime: $Util.RuntimeOptions): Promise<ListRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListRule",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListRuleResponse>(await this.callApi(params, req, runtime), new ListRuleResponse({}));
  }

  async listRule(request: ListRuleRequest): Promise<ListRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listRuleWithOptions(request, runtime);
  }

  async listRuleActionsWithOptions(request: ListRuleActionsRequest, runtime: $Util.RuntimeOptions): Promise<ListRuleActionsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.ruleId)) {
      query["RuleId"] = request.ruleId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListRuleActions",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListRuleActionsResponse>(await this.callApi(params, req, runtime), new ListRuleActionsResponse({}));
  }

  async listRuleActions(request: ListRuleActionsRequest): Promise<ListRuleActionsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listRuleActionsWithOptions(request, runtime);
  }

  async listTaskWithOptions(request: ListTaskRequest, runtime: $Util.RuntimeOptions): Promise<ListTaskResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.device)) {
      query["Device"] = request.device;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.jobId)) {
      query["JobId"] = request.jobId;
    }

    if (!Util.isUnset(request.limit)) {
      query["Limit"] = request.limit;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListTask",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListTaskResponse>(await this.callApi(params, req, runtime), new ListTaskResponse({}));
  }

  async listTask(request: ListTaskRequest): Promise<ListTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listTaskWithOptions(request, runtime);
  }

  async listTaskByPageWithOptions(request: ListTaskByPageRequest, runtime: $Util.RuntimeOptions): Promise<ListTaskByPageResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.device)) {
      query["Device"] = request.device;
    }

    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.jobId)) {
      query["JobId"] = request.jobId;
    }

    if (!Util.isUnset(request.jobName)) {
      query["JobName"] = request.jobName;
    }

    if (!Util.isUnset(request.pageNo)) {
      query["PageNo"] = request.pageNo;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListTaskByPage",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListTaskByPageResponse>(await this.callApi(params, req, runtime), new ListTaskByPageResponse({}));
  }

  async listTaskByPage(request: ListTaskByPageRequest): Promise<ListTaskByPageResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listTaskByPageWithOptions(request, runtime);
  }

  async listThingModelVersionWithOptions(request: ListThingModelVersionRequest, runtime: $Util.RuntimeOptions): Promise<ListThingModelVersionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListThingModelVersion",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListThingModelVersionResponse>(await this.callApi(params, req, runtime), new ListThingModelVersionResponse({}));
  }

  async listThingModelVersion(request: ListThingModelVersionRequest): Promise<ListThingModelVersionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listThingModelVersionWithOptions(request, runtime);
  }

  async listThingTemplatesWithOptions(request: ListThingTemplatesRequest, runtime: $Util.RuntimeOptions): Promise<ListThingTemplatesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListThingTemplates",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListThingTemplatesResponse>(await this.callApi(params, req, runtime), new ListThingTemplatesResponse({}));
  }

  async listThingTemplates(request: ListThingTemplatesRequest): Promise<ListThingTemplatesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listThingTemplatesWithOptions(request, runtime);
  }

  async notifyAddThingTopoWithOptions(request: NotifyAddThingTopoRequest, runtime: $Util.RuntimeOptions): Promise<NotifyAddThingTopoResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceListStr)) {
      query["DeviceListStr"] = request.deviceListStr;
    }

    if (!Util.isUnset(request.gwDeviceName)) {
      query["GwDeviceName"] = request.gwDeviceName;
    }

    if (!Util.isUnset(request.gwIotId)) {
      query["GwIotId"] = request.gwIotId;
    }

    if (!Util.isUnset(request.gwProductKey)) {
      query["GwProductKey"] = request.gwProductKey;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "NotifyAddThingTopo",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<NotifyAddThingTopoResponse>(await this.callApi(params, req, runtime), new NotifyAddThingTopoResponse({}));
  }

  async notifyAddThingTopo(request: NotifyAddThingTopoRequest): Promise<NotifyAddThingTopoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.notifyAddThingTopoWithOptions(request, runtime);
  }

  async openIotServiceWithOptions(request: OpenIotServiceRequest, runtime: $Util.RuntimeOptions): Promise<OpenIotServiceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "OpenIotService",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<OpenIotServiceResponse>(await this.callApi(params, req, runtime), new OpenIotServiceResponse({}));
  }

  async openIotService(request: OpenIotServiceRequest): Promise<OpenIotServiceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.openIotServiceWithOptions(request, runtime);
  }

  async printByTemplateWithOptions(request: PrintByTemplateRequest, runtime: $Util.RuntimeOptions): Promise<PrintByTemplateResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: request.deviceName,
    });
    let params = new $OpenApi.Params({
      action: "PrintByTemplate",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<PrintByTemplateResponse>(await this.callApi(params, req, runtime), new PrintByTemplateResponse({}));
  }

  async printByTemplate(request: PrintByTemplateRequest): Promise<PrintByTemplateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.printByTemplateWithOptions(request, runtime);
  }

  async pubWithOptions(request: PubRequest, runtime: $Util.RuntimeOptions): Promise<PubResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.correlationData)) {
      query["CorrelationData"] = request.correlationData;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.messageContent)) {
      query["MessageContent"] = request.messageContent;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.qos)) {
      query["Qos"] = request.qos;
    }

    if (!Util.isUnset(request.responseTopic)) {
      query["ResponseTopic"] = request.responseTopic;
    }

    if (!Util.isUnset(request.topicFullName)) {
      query["TopicFullName"] = request.topicFullName;
    }

    if (!Util.isUnset(request.userProp)) {
      query["UserProp"] = request.userProp;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "Pub",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<PubResponse>(await this.callApi(params, req, runtime), new PubResponse({}));
  }

  async pub(request: PubRequest): Promise<PubResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.pubWithOptions(request, runtime);
  }

  async pubBroadcastWithOptions(request: PubBroadcastRequest, runtime: $Util.RuntimeOptions): Promise<PubBroadcastResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.messageContent)) {
      query["MessageContent"] = request.messageContent;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.topicFullName)) {
      query["TopicFullName"] = request.topicFullName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "PubBroadcast",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<PubBroadcastResponse>(await this.callApi(params, req, runtime), new PubBroadcastResponse({}));
  }

  async pubBroadcast(request: PubBroadcastRequest): Promise<PubBroadcastResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.pubBroadcastWithOptions(request, runtime);
  }

  async publishStudioAppWithOptions(request: PublishStudioAppRequest, runtime: $Util.RuntimeOptions): Promise<PublishStudioAppResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: request.appId,
    });
    let params = new $OpenApi.Params({
      action: "PublishStudioApp",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<PublishStudioAppResponse>(await this.callApi(params, req, runtime), new PublishStudioAppResponse({}));
  }

  async publishStudioApp(request: PublishStudioAppRequest): Promise<PublishStudioAppResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.publishStudioAppWithOptions(request, runtime);
  }

  async publishThingModelWithOptions(request: PublishThingModelRequest, runtime: $Util.RuntimeOptions): Promise<PublishThingModelResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.modelVersion)) {
      query["ModelVersion"] = request.modelVersion;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "PublishThingModel",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<PublishThingModelResponse>(await this.callApi(params, req, runtime), new PublishThingModelResponse({}));
  }

  async publishThingModel(request: PublishThingModelRequest): Promise<PublishThingModelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.publishThingModelWithOptions(request, runtime);
  }

  async pushSpeechWithOptions(request: PushSpeechRequest, runtime: $Util.RuntimeOptions): Promise<PushSpeechResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: request.deviceName,
    });
    let params = new $OpenApi.Params({
      action: "PushSpeech",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<PushSpeechResponse>(await this.callApi(params, req, runtime), new PushSpeechResponse({}));
  }

  async pushSpeech(request: PushSpeechRequest): Promise<PushSpeechResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.pushSpeechWithOptions(request, runtime);
  }

  async queryAppDeviceListWithOptions(request: QueryAppDeviceListRequest, runtime: $Util.RuntimeOptions): Promise<QueryAppDeviceListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appKey)) {
      query["AppKey"] = request.appKey;
    }

    if (!Util.isUnset(request.categoryKeyList)) {
      query["CategoryKeyList"] = request.categoryKeyList;
    }

    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.productKeyList)) {
      query["ProductKeyList"] = request.productKeyList;
    }

    if (!Util.isUnset(request.tagList)) {
      query["TagList"] = request.tagList;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryAppDeviceList",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryAppDeviceListResponse>(await this.callApi(params, req, runtime), new QueryAppDeviceListResponse({}));
  }

  async queryAppDeviceList(request: QueryAppDeviceListRequest): Promise<QueryAppDeviceListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryAppDeviceListWithOptions(request, runtime);
  }

  async queryBatchRegisterDeviceStatusWithOptions(request: QueryBatchRegisterDeviceStatusRequest, runtime: $Util.RuntimeOptions): Promise<QueryBatchRegisterDeviceStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.applyId)) {
      query["ApplyId"] = request.applyId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryBatchRegisterDeviceStatus",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryBatchRegisterDeviceStatusResponse>(await this.callApi(params, req, runtime), new QueryBatchRegisterDeviceStatusResponse({}));
  }

  async queryBatchRegisterDeviceStatus(request: QueryBatchRegisterDeviceStatusRequest): Promise<QueryBatchRegisterDeviceStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryBatchRegisterDeviceStatusWithOptions(request, runtime);
  }

  async queryCertUrlByApplyIdWithOptions(request: QueryCertUrlByApplyIdRequest, runtime: $Util.RuntimeOptions): Promise<QueryCertUrlByApplyIdResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.applyId)) {
      query["ApplyId"] = request.applyId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryCertUrlByApplyId",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryCertUrlByApplyIdResponse>(await this.callApi(params, req, runtime), new QueryCertUrlByApplyIdResponse({}));
  }

  async queryCertUrlByApplyId(request: QueryCertUrlByApplyIdRequest): Promise<QueryCertUrlByApplyIdResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryCertUrlByApplyIdWithOptions(request, runtime);
  }

  async queryConsumerGroupByGroupIdWithOptions(request: QueryConsumerGroupByGroupIdRequest, runtime: $Util.RuntimeOptions): Promise<QueryConsumerGroupByGroupIdResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryConsumerGroupByGroupId",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryConsumerGroupByGroupIdResponse>(await this.callApi(params, req, runtime), new QueryConsumerGroupByGroupIdResponse({}));
  }

  async queryConsumerGroupByGroupId(request: QueryConsumerGroupByGroupIdRequest): Promise<QueryConsumerGroupByGroupIdResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryConsumerGroupByGroupIdWithOptions(request, runtime);
  }

  async queryConsumerGroupListWithOptions(request: QueryConsumerGroupListRequest, runtime: $Util.RuntimeOptions): Promise<QueryConsumerGroupListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.fuzzy)) {
      query["Fuzzy"] = request.fuzzy;
    }

    if (!Util.isUnset(request.groupName)) {
      query["GroupName"] = request.groupName;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryConsumerGroupList",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryConsumerGroupListResponse>(await this.callApi(params, req, runtime), new QueryConsumerGroupListResponse({}));
  }

  async queryConsumerGroupList(request: QueryConsumerGroupListRequest): Promise<QueryConsumerGroupListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryConsumerGroupListWithOptions(request, runtime);
  }

  async queryConsumerGroupStatusWithOptions(request: QueryConsumerGroupStatusRequest, runtime: $Util.RuntimeOptions): Promise<QueryConsumerGroupStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryConsumerGroupStatus",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryConsumerGroupStatusResponse>(await this.callApi(params, req, runtime), new QueryConsumerGroupStatusResponse({}));
  }

  async queryConsumerGroupStatus(request: QueryConsumerGroupStatusRequest): Promise<QueryConsumerGroupStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryConsumerGroupStatusWithOptions(request, runtime);
  }

  async queryDetailSceneRuleLogWithOptions(request: QueryDetailSceneRuleLogRequest, runtime: $Util.RuntimeOptions): Promise<QueryDetailSceneRuleLogResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.ruleId)) {
      query["RuleId"] = request.ruleId;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.traceId)) {
      query["TraceId"] = request.traceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryDetailSceneRuleLog",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryDetailSceneRuleLogResponse>(await this.callApi(params, req, runtime), new QueryDetailSceneRuleLogResponse({}));
  }

  async queryDetailSceneRuleLog(request: QueryDetailSceneRuleLogRequest): Promise<QueryDetailSceneRuleLogResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDetailSceneRuleLogWithOptions(request, runtime);
  }

  async queryDeviceWithOptions(request: QueryDeviceRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryDevice",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryDeviceResponse>(await this.callApi(params, req, runtime), new QueryDeviceResponse({}));
  }

  async queryDevice(request: QueryDeviceRequest): Promise<QueryDeviceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceWithOptions(request, runtime);
  }

  async queryDeviceBySQLWithOptions(request: QueryDeviceBySQLRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceBySQLResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.SQL)) {
      query["SQL"] = request.SQL;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryDeviceBySQL",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryDeviceBySQLResponse>(await this.callApi(params, req, runtime), new QueryDeviceBySQLResponse({}));
  }

  async queryDeviceBySQL(request: QueryDeviceBySQLRequest): Promise<QueryDeviceBySQLResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceBySQLWithOptions(request, runtime);
  }

  async queryDeviceByStatusWithOptions(request: QueryDeviceByStatusRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceByStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryDeviceByStatus",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryDeviceByStatusResponse>(await this.callApi(params, req, runtime), new QueryDeviceByStatusResponse({}));
  }

  async queryDeviceByStatus(request: QueryDeviceByStatusRequest): Promise<QueryDeviceByStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceByStatusWithOptions(request, runtime);
  }

  async queryDeviceByTagsWithOptions(request: QueryDeviceByTagsRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceByTagsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryDeviceByTags",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryDeviceByTagsResponse>(await this.callApi(params, req, runtime), new QueryDeviceByTagsResponse({}));
  }

  async queryDeviceByTags(request: QueryDeviceByTagsRequest): Promise<QueryDeviceByTagsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceByTagsWithOptions(request, runtime);
  }

  async queryDeviceCertWithOptions(request: QueryDeviceCertRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceCertResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryDeviceCert",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryDeviceCertResponse>(await this.callApi(params, req, runtime), new QueryDeviceCertResponse({}));
  }

  async queryDeviceCert(request: QueryDeviceCertRequest): Promise<QueryDeviceCertResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceCertWithOptions(request, runtime);
  }

  async queryDeviceDesiredPropertyWithOptions(request: QueryDeviceDesiredPropertyRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceDesiredPropertyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.functionBlockId)) {
      query["FunctionBlockId"] = request.functionBlockId;
    }

    if (!Util.isUnset(request.identifier)) {
      query["Identifier"] = request.identifier;
    }

    if (!Util.isUnset(request.iotId)) {
      query["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryDeviceDesiredProperty",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryDeviceDesiredPropertyResponse>(await this.callApi(params, req, runtime), new QueryDeviceDesiredPropertyResponse({}));
  }

  async queryDeviceDesiredProperty(request: QueryDeviceDesiredPropertyRequest): Promise<QueryDeviceDesiredPropertyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceDesiredPropertyWithOptions(request, runtime);
  }

  async queryDeviceDetailWithOptions(request: QueryDeviceDetailRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotId)) {
      query["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryDeviceDetail",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryDeviceDetailResponse>(await this.callApi(params, req, runtime), new QueryDeviceDetailResponse({}));
  }

  async queryDeviceDetail(request: QueryDeviceDetailRequest): Promise<QueryDeviceDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceDetailWithOptions(request, runtime);
  }

  async queryDeviceDistributeDetailWithOptions(request: QueryDeviceDistributeDetailRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceDistributeDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.jobId)) {
      query["JobId"] = request.jobId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryDeviceDistributeDetail",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryDeviceDistributeDetailResponse>(await this.callApi(params, req, runtime), new QueryDeviceDistributeDetailResponse({}));
  }

  async queryDeviceDistributeDetail(request: QueryDeviceDistributeDetailRequest): Promise<QueryDeviceDistributeDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceDistributeDetailWithOptions(request, runtime);
  }

  async queryDeviceDistributeJobWithOptions(request: QueryDeviceDistributeJobRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceDistributeJobResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.jobId)) {
      query["JobId"] = request.jobId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryDeviceDistributeJob",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryDeviceDistributeJobResponse>(await this.callApi(params, req, runtime), new QueryDeviceDistributeJobResponse({}));
  }

  async queryDeviceDistributeJob(request: QueryDeviceDistributeJobRequest): Promise<QueryDeviceDistributeJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceDistributeJobWithOptions(request, runtime);
  }

  async queryDeviceEventDataWithOptions(request: QueryDeviceEventDataRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceEventDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.asc)) {
      query["Asc"] = request.asc;
    }

    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.eventType)) {
      query["EventType"] = request.eventType;
    }

    if (!Util.isUnset(request.identifier)) {
      query["Identifier"] = request.identifier;
    }

    if (!Util.isUnset(request.iotId)) {
      query["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryDeviceEventData",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryDeviceEventDataResponse>(await this.callApi(params, req, runtime), new QueryDeviceEventDataResponse({}));
  }

  async queryDeviceEventData(request: QueryDeviceEventDataRequest): Promise<QueryDeviceEventDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceEventDataWithOptions(request, runtime);
  }

  async queryDeviceFileWithOptions(request: QueryDeviceFileRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceFileResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.fileId)) {
      query["FileId"] = request.fileId;
    }

    if (!Util.isUnset(request.iotId)) {
      query["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryDeviceFile",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryDeviceFileResponse>(await this.callApi(params, req, runtime), new QueryDeviceFileResponse({}));
  }

  async queryDeviceFile(request: QueryDeviceFileRequest): Promise<QueryDeviceFileResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceFileWithOptions(request, runtime);
  }

  async queryDeviceFileListWithOptions(request: QueryDeviceFileListRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceFileListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotId)) {
      query["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryDeviceFileList",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryDeviceFileListResponse>(await this.callApi(params, req, runtime), new QueryDeviceFileListResponse({}));
  }

  async queryDeviceFileList(request: QueryDeviceFileListRequest): Promise<QueryDeviceFileListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceFileListWithOptions(request, runtime);
  }

  async queryDeviceGroupByDeviceWithOptions(request: QueryDeviceGroupByDeviceRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceGroupByDeviceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryDeviceGroupByDevice",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryDeviceGroupByDeviceResponse>(await this.callApi(params, req, runtime), new QueryDeviceGroupByDeviceResponse({}));
  }

  async queryDeviceGroupByDevice(request: QueryDeviceGroupByDeviceRequest): Promise<QueryDeviceGroupByDeviceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceGroupByDeviceWithOptions(request, runtime);
  }

  async queryDeviceGroupByTagsWithOptions(request: QueryDeviceGroupByTagsRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceGroupByTagsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryDeviceGroupByTags",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryDeviceGroupByTagsResponse>(await this.callApi(params, req, runtime), new QueryDeviceGroupByTagsResponse({}));
  }

  async queryDeviceGroupByTags(request: QueryDeviceGroupByTagsRequest): Promise<QueryDeviceGroupByTagsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceGroupByTagsWithOptions(request, runtime);
  }

  async queryDeviceGroupInfoWithOptions(request: QueryDeviceGroupInfoRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceGroupInfoResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryDeviceGroupInfo",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryDeviceGroupInfoResponse>(await this.callApi(params, req, runtime), new QueryDeviceGroupInfoResponse({}));
  }

  async queryDeviceGroupInfo(request: QueryDeviceGroupInfoRequest): Promise<QueryDeviceGroupInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceGroupInfoWithOptions(request, runtime);
  }

  async queryDeviceGroupListWithOptions(request: QueryDeviceGroupListRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceGroupListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.groupName)) {
      query["GroupName"] = request.groupName;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.superGroupId)) {
      query["SuperGroupId"] = request.superGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryDeviceGroupList",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryDeviceGroupListResponse>(await this.callApi(params, req, runtime), new QueryDeviceGroupListResponse({}));
  }

  async queryDeviceGroupList(request: QueryDeviceGroupListRequest): Promise<QueryDeviceGroupListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceGroupListWithOptions(request, runtime);
  }

  async queryDeviceGroupTagListWithOptions(request: QueryDeviceGroupTagListRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceGroupTagListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryDeviceGroupTagList",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryDeviceGroupTagListResponse>(await this.callApi(params, req, runtime), new QueryDeviceGroupTagListResponse({}));
  }

  async queryDeviceGroupTagList(request: QueryDeviceGroupTagListRequest): Promise<QueryDeviceGroupTagListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceGroupTagListWithOptions(request, runtime);
  }

  async queryDeviceInfoWithOptions(request: QueryDeviceInfoRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceInfoResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotId)) {
      query["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryDeviceInfo",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryDeviceInfoResponse>(await this.callApi(params, req, runtime), new QueryDeviceInfoResponse({}));
  }

  async queryDeviceInfo(request: QueryDeviceInfoRequest): Promise<QueryDeviceInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceInfoWithOptions(request, runtime);
  }

  async queryDeviceListByDeviceGroupWithOptions(request: QueryDeviceListByDeviceGroupRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceListByDeviceGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryDeviceListByDeviceGroup",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryDeviceListByDeviceGroupResponse>(await this.callApi(params, req, runtime), new QueryDeviceListByDeviceGroupResponse({}));
  }

  async queryDeviceListByDeviceGroup(request: QueryDeviceListByDeviceGroupRequest): Promise<QueryDeviceListByDeviceGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceListByDeviceGroupWithOptions(request, runtime);
  }

  async queryDeviceOriginalEventDataWithOptions(request: QueryDeviceOriginalEventDataRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceOriginalEventDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.asc)) {
      query["Asc"] = request.asc;
    }

    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.identifier)) {
      query["Identifier"] = request.identifier;
    }

    if (!Util.isUnset(request.iotId)) {
      query["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.nextPageToken)) {
      query["NextPageToken"] = request.nextPageToken;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryDeviceOriginalEventData",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryDeviceOriginalEventDataResponse>(await this.callApi(params, req, runtime), new QueryDeviceOriginalEventDataResponse({}));
  }

  async queryDeviceOriginalEventData(request: QueryDeviceOriginalEventDataRequest): Promise<QueryDeviceOriginalEventDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceOriginalEventDataWithOptions(request, runtime);
  }

  async queryDeviceOriginalPropertyDataWithOptions(request: QueryDeviceOriginalPropertyDataRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceOriginalPropertyDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.asc)) {
      query["Asc"] = request.asc;
    }

    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.identifier)) {
      query["Identifier"] = request.identifier;
    }

    if (!Util.isUnset(request.iotId)) {
      query["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.nextPageToken)) {
      query["NextPageToken"] = request.nextPageToken;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryDeviceOriginalPropertyData",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryDeviceOriginalPropertyDataResponse>(await this.callApi(params, req, runtime), new QueryDeviceOriginalPropertyDataResponse({}));
  }

  async queryDeviceOriginalPropertyData(request: QueryDeviceOriginalPropertyDataRequest): Promise<QueryDeviceOriginalPropertyDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceOriginalPropertyDataWithOptions(request, runtime);
  }

  async queryDeviceOriginalPropertyStatusWithOptions(request: QueryDeviceOriginalPropertyStatusRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceOriginalPropertyStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.asc)) {
      query["Asc"] = request.asc;
    }

    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotId)) {
      query["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.nextPageToken)) {
      query["NextPageToken"] = request.nextPageToken;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryDeviceOriginalPropertyStatus",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryDeviceOriginalPropertyStatusResponse>(await this.callApi(params, req, runtime), new QueryDeviceOriginalPropertyStatusResponse({}));
  }

  async queryDeviceOriginalPropertyStatus(request: QueryDeviceOriginalPropertyStatusRequest): Promise<QueryDeviceOriginalPropertyStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceOriginalPropertyStatusWithOptions(request, runtime);
  }

  async queryDeviceOriginalServiceDataWithOptions(request: QueryDeviceOriginalServiceDataRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceOriginalServiceDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.asc)) {
      query["Asc"] = request.asc;
    }

    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.identifier)) {
      query["Identifier"] = request.identifier;
    }

    if (!Util.isUnset(request.iotId)) {
      query["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.nextPageToken)) {
      query["NextPageToken"] = request.nextPageToken;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryDeviceOriginalServiceData",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryDeviceOriginalServiceDataResponse>(await this.callApi(params, req, runtime), new QueryDeviceOriginalServiceDataResponse({}));
  }

  async queryDeviceOriginalServiceData(request: QueryDeviceOriginalServiceDataRequest): Promise<QueryDeviceOriginalServiceDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceOriginalServiceDataWithOptions(request, runtime);
  }

  async queryDevicePropWithOptions(request: QueryDevicePropRequest, runtime: $Util.RuntimeOptions): Promise<QueryDevicePropResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotId)) {
      query["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryDeviceProp",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryDevicePropResponse>(await this.callApi(params, req, runtime), new QueryDevicePropResponse({}));
  }

  async queryDeviceProp(request: QueryDevicePropRequest): Promise<QueryDevicePropResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDevicePropWithOptions(request, runtime);
  }

  async queryDevicePropertiesDataWithOptions(request: QueryDevicePropertiesDataRequest, runtime: $Util.RuntimeOptions): Promise<QueryDevicePropertiesDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.asc)) {
      query["Asc"] = request.asc;
    }

    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.identifier)) {
      query["Identifier"] = request.identifier;
    }

    if (!Util.isUnset(request.iotId)) {
      query["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryDevicePropertiesData",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryDevicePropertiesDataResponse>(await this.callApi(params, req, runtime), new QueryDevicePropertiesDataResponse({}));
  }

  async queryDevicePropertiesData(request: QueryDevicePropertiesDataRequest): Promise<QueryDevicePropertiesDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDevicePropertiesDataWithOptions(request, runtime);
  }

  async queryDevicePropertyDataWithOptions(request: QueryDevicePropertyDataRequest, runtime: $Util.RuntimeOptions): Promise<QueryDevicePropertyDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.asc)) {
      query["Asc"] = request.asc;
    }

    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.identifier)) {
      query["Identifier"] = request.identifier;
    }

    if (!Util.isUnset(request.iotId)) {
      query["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryDevicePropertyData",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryDevicePropertyDataResponse>(await this.callApi(params, req, runtime), new QueryDevicePropertyDataResponse({}));
  }

  async queryDevicePropertyData(request: QueryDevicePropertyDataRequest): Promise<QueryDevicePropertyDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDevicePropertyDataWithOptions(request, runtime);
  }

  async queryDevicePropertyStatusWithOptions(request: QueryDevicePropertyStatusRequest, runtime: $Util.RuntimeOptions): Promise<QueryDevicePropertyStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.functionBlockId)) {
      query["FunctionBlockId"] = request.functionBlockId;
    }

    if (!Util.isUnset(request.iotId)) {
      query["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryDevicePropertyStatus",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryDevicePropertyStatusResponse>(await this.callApi(params, req, runtime), new QueryDevicePropertyStatusResponse({}));
  }

  async queryDevicePropertyStatus(request: QueryDevicePropertyStatusRequest): Promise<QueryDevicePropertyStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDevicePropertyStatusWithOptions(request, runtime);
  }

  async queryDeviceServiceDataWithOptions(request: QueryDeviceServiceDataRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceServiceDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.asc)) {
      query["Asc"] = request.asc;
    }

    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.identifier)) {
      query["Identifier"] = request.identifier;
    }

    if (!Util.isUnset(request.iotId)) {
      query["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryDeviceServiceData",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryDeviceServiceDataResponse>(await this.callApi(params, req, runtime), new QueryDeviceServiceDataResponse({}));
  }

  async queryDeviceServiceData(request: QueryDeviceServiceDataRequest): Promise<QueryDeviceServiceDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceServiceDataWithOptions(request, runtime);
  }

  async queryDeviceStatisticsWithOptions(request: QueryDeviceStatisticsRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceStatisticsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryDeviceStatistics",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryDeviceStatisticsResponse>(await this.callApi(params, req, runtime), new QueryDeviceStatisticsResponse({}));
  }

  async queryDeviceStatistics(request: QueryDeviceStatisticsRequest): Promise<QueryDeviceStatisticsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceStatisticsWithOptions(request, runtime);
  }

  async queryEdgeDriverWithOptions(request: QueryEdgeDriverRequest, runtime: $Util.RuntimeOptions): Promise<QueryEdgeDriverResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.driverName)) {
      query["DriverName"] = request.driverName;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryEdgeDriver",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryEdgeDriverResponse>(await this.callApi(params, req, runtime), new QueryEdgeDriverResponse({}));
  }

  async queryEdgeDriver(request: QueryEdgeDriverRequest): Promise<QueryEdgeDriverResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryEdgeDriverWithOptions(request, runtime);
  }

  async queryEdgeDriverVersionWithOptions(request: QueryEdgeDriverVersionRequest, runtime: $Util.RuntimeOptions): Promise<QueryEdgeDriverVersionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.driverId)) {
      query["DriverId"] = request.driverId;
    }

    if (!Util.isUnset(request.driverVersion)) {
      query["DriverVersion"] = request.driverVersion;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.versionState)) {
      query["VersionState"] = request.versionState;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryEdgeDriverVersion",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryEdgeDriverVersionResponse>(await this.callApi(params, req, runtime), new QueryEdgeDriverVersionResponse({}));
  }

  async queryEdgeDriverVersion(request: QueryEdgeDriverVersionRequest): Promise<QueryEdgeDriverVersionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryEdgeDriverVersionWithOptions(request, runtime);
  }

  async queryEdgeInstanceWithOptions(request: QueryEdgeInstanceRequest, runtime: $Util.RuntimeOptions): Promise<QueryEdgeInstanceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryEdgeInstance",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryEdgeInstanceResponse>(await this.callApi(params, req, runtime), new QueryEdgeInstanceResponse({}));
  }

  async queryEdgeInstance(request: QueryEdgeInstanceRequest): Promise<QueryEdgeInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryEdgeInstanceWithOptions(request, runtime);
  }

  async queryEdgeInstanceChannelWithOptions(request: QueryEdgeInstanceChannelRequest, runtime: $Util.RuntimeOptions): Promise<QueryEdgeInstanceChannelResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.channelName)) {
      query["ChannelName"] = request.channelName;
    }

    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.driverId)) {
      query["DriverId"] = request.driverId;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryEdgeInstanceChannel",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryEdgeInstanceChannelResponse>(await this.callApi(params, req, runtime), new QueryEdgeInstanceChannelResponse({}));
  }

  async queryEdgeInstanceChannel(request: QueryEdgeInstanceChannelRequest): Promise<QueryEdgeInstanceChannelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryEdgeInstanceChannelWithOptions(request, runtime);
  }

  async queryEdgeInstanceDeviceWithOptions(request: QueryEdgeInstanceDeviceRequest, runtime: $Util.RuntimeOptions): Promise<QueryEdgeInstanceDeviceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryEdgeInstanceDevice",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryEdgeInstanceDeviceResponse>(await this.callApi(params, req, runtime), new QueryEdgeInstanceDeviceResponse({}));
  }

  async queryEdgeInstanceDevice(request: QueryEdgeInstanceDeviceRequest): Promise<QueryEdgeInstanceDeviceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryEdgeInstanceDeviceWithOptions(request, runtime);
  }

  async queryEdgeInstanceDeviceByDriverWithOptions(request: QueryEdgeInstanceDeviceByDriverRequest, runtime: $Util.RuntimeOptions): Promise<QueryEdgeInstanceDeviceByDriverResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.channelId)) {
      query["ChannelId"] = request.channelId;
    }

    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.driverId)) {
      query["DriverId"] = request.driverId;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryEdgeInstanceDeviceByDriver",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryEdgeInstanceDeviceByDriverResponse>(await this.callApi(params, req, runtime), new QueryEdgeInstanceDeviceByDriverResponse({}));
  }

  async queryEdgeInstanceDeviceByDriver(request: QueryEdgeInstanceDeviceByDriverRequest): Promise<QueryEdgeInstanceDeviceByDriverResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryEdgeInstanceDeviceByDriverWithOptions(request, runtime);
  }

  async queryEdgeInstanceDriverWithOptions(request: QueryEdgeInstanceDriverRequest, runtime: $Util.RuntimeOptions): Promise<QueryEdgeInstanceDriverResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryEdgeInstanceDriver",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryEdgeInstanceDriverResponse>(await this.callApi(params, req, runtime), new QueryEdgeInstanceDriverResponse({}));
  }

  async queryEdgeInstanceDriver(request: QueryEdgeInstanceDriverRequest): Promise<QueryEdgeInstanceDriverResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryEdgeInstanceDriverWithOptions(request, runtime);
  }

  async queryEdgeInstanceGatewayWithOptions(request: QueryEdgeInstanceGatewayRequest, runtime: $Util.RuntimeOptions): Promise<QueryEdgeInstanceGatewayResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryEdgeInstanceGateway",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryEdgeInstanceGatewayResponse>(await this.callApi(params, req, runtime), new QueryEdgeInstanceGatewayResponse({}));
  }

  async queryEdgeInstanceGateway(request: QueryEdgeInstanceGatewayRequest): Promise<QueryEdgeInstanceGatewayResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryEdgeInstanceGatewayWithOptions(request, runtime);
  }

  async queryEdgeInstanceHistoricDeploymentWithOptions(request: QueryEdgeInstanceHistoricDeploymentRequest, runtime: $Util.RuntimeOptions): Promise<QueryEdgeInstanceHistoricDeploymentResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryEdgeInstanceHistoricDeployment",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryEdgeInstanceHistoricDeploymentResponse>(await this.callApi(params, req, runtime), new QueryEdgeInstanceHistoricDeploymentResponse({}));
  }

  async queryEdgeInstanceHistoricDeployment(request: QueryEdgeInstanceHistoricDeploymentRequest): Promise<QueryEdgeInstanceHistoricDeploymentResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryEdgeInstanceHistoricDeploymentWithOptions(request, runtime);
  }

  async queryEdgeInstanceMessageRoutingWithOptions(request: QueryEdgeInstanceMessageRoutingRequest, runtime: $Util.RuntimeOptions): Promise<QueryEdgeInstanceMessageRoutingResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryEdgeInstanceMessageRouting",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryEdgeInstanceMessageRoutingResponse>(await this.callApi(params, req, runtime), new QueryEdgeInstanceMessageRoutingResponse({}));
  }

  async queryEdgeInstanceMessageRouting(request: QueryEdgeInstanceMessageRoutingRequest): Promise<QueryEdgeInstanceMessageRoutingResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryEdgeInstanceMessageRoutingWithOptions(request, runtime);
  }

  async queryEdgeInstanceSceneRuleWithOptions(request: QueryEdgeInstanceSceneRuleRequest, runtime: $Util.RuntimeOptions): Promise<QueryEdgeInstanceSceneRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryEdgeInstanceSceneRule",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryEdgeInstanceSceneRuleResponse>(await this.callApi(params, req, runtime), new QueryEdgeInstanceSceneRuleResponse({}));
  }

  async queryEdgeInstanceSceneRule(request: QueryEdgeInstanceSceneRuleRequest): Promise<QueryEdgeInstanceSceneRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryEdgeInstanceSceneRuleWithOptions(request, runtime);
  }

  async queryJobWithOptions(request: QueryJobRequest, runtime: $Util.RuntimeOptions): Promise<QueryJobResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.jobId)) {
      query["JobId"] = request.jobId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryJob",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryJobResponse>(await this.callApi(params, req, runtime), new QueryJobResponse({}));
  }

  async queryJob(request: QueryJobRequest): Promise<QueryJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryJobWithOptions(request, runtime);
  }

  async queryJobStatisticsWithOptions(request: QueryJobStatisticsRequest, runtime: $Util.RuntimeOptions): Promise<QueryJobStatisticsResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryJobStatistics",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryJobStatisticsResponse>(await this.callApi(params, req, runtime), new QueryJobStatisticsResponse({}));
  }

  async queryJobStatistics(request: QueryJobStatisticsRequest): Promise<QueryJobStatisticsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryJobStatisticsWithOptions(request, runtime);
  }

  async queryLoRaJoinPermissionsWithOptions(request: QueryLoRaJoinPermissionsRequest, runtime: $Util.RuntimeOptions): Promise<QueryLoRaJoinPermissionsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryLoRaJoinPermissions",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryLoRaJoinPermissionsResponse>(await this.callApi(params, req, runtime), new QueryLoRaJoinPermissionsResponse({}));
  }

  async queryLoRaJoinPermissions(request: QueryLoRaJoinPermissionsRequest): Promise<QueryLoRaJoinPermissionsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryLoRaJoinPermissionsWithOptions(request, runtime);
  }

  async queryMessageInfoWithOptions(request: QueryMessageInfoRequest, runtime: $Util.RuntimeOptions): Promise<QueryMessageInfoResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.uniMsgId)) {
      query["UniMsgId"] = request.uniMsgId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryMessageInfo",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryMessageInfoResponse>(await this.callApi(params, req, runtime), new QueryMessageInfoResponse({}));
  }

  async queryMessageInfo(request: QueryMessageInfoRequest): Promise<QueryMessageInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryMessageInfoWithOptions(request, runtime);
  }

  async queryOTAFirmwareWithOptions(request: QueryOTAFirmwareRequest, runtime: $Util.RuntimeOptions): Promise<QueryOTAFirmwareResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.firmwareId)) {
      query["FirmwareId"] = request.firmwareId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryOTAFirmware",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryOTAFirmwareResponse>(await this.callApi(params, req, runtime), new QueryOTAFirmwareResponse({}));
  }

  async queryOTAFirmware(request: QueryOTAFirmwareRequest): Promise<QueryOTAFirmwareResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryOTAFirmwareWithOptions(request, runtime);
  }

  async queryOTAJobWithOptions(request: QueryOTAJobRequest, runtime: $Util.RuntimeOptions): Promise<QueryOTAJobResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.jobId)) {
      query["JobId"] = request.jobId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryOTAJob",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryOTAJobResponse>(await this.callApi(params, req, runtime), new QueryOTAJobResponse({}));
  }

  async queryOTAJob(request: QueryOTAJobRequest): Promise<QueryOTAJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryOTAJobWithOptions(request, runtime);
  }

  async queryPageByApplyIdWithOptions(request: QueryPageByApplyIdRequest, runtime: $Util.RuntimeOptions): Promise<QueryPageByApplyIdResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.applyId)) {
      query["ApplyId"] = request.applyId;
    }

    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryPageByApplyId",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryPageByApplyIdResponse>(await this.callApi(params, req, runtime), new QueryPageByApplyIdResponse({}));
  }

  async queryPageByApplyId(request: QueryPageByApplyIdRequest): Promise<QueryPageByApplyIdResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryPageByApplyIdWithOptions(request, runtime);
  }

  async queryProductWithOptions(request: QueryProductRequest, runtime: $Util.RuntimeOptions): Promise<QueryProductResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryProduct",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryProductResponse>(await this.callApi(params, req, runtime), new QueryProductResponse({}));
  }

  async queryProduct(request: QueryProductRequest): Promise<QueryProductResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryProductWithOptions(request, runtime);
  }

  async queryProductCertInfoWithOptions(request: QueryProductCertInfoRequest, runtime: $Util.RuntimeOptions): Promise<QueryProductCertInfoResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryProductCertInfo",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryProductCertInfoResponse>(await this.callApi(params, req, runtime), new QueryProductCertInfoResponse({}));
  }

  async queryProductCertInfo(request: QueryProductCertInfoRequest): Promise<QueryProductCertInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryProductCertInfoWithOptions(request, runtime);
  }

  async queryProductListWithOptions(request: QueryProductListRequest, runtime: $Util.RuntimeOptions): Promise<QueryProductListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.aliyunCommodityCode)) {
      query["AliyunCommodityCode"] = request.aliyunCommodityCode;
    }

    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryProductList",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryProductListResponse>(await this.callApi(params, req, runtime), new QueryProductListResponse({}));
  }

  async queryProductList(request: QueryProductListRequest): Promise<QueryProductListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryProductListWithOptions(request, runtime);
  }

  async queryProductTopicWithOptions(request: QueryProductTopicRequest, runtime: $Util.RuntimeOptions): Promise<QueryProductTopicResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryProductTopic",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryProductTopicResponse>(await this.callApi(params, req, runtime), new QueryProductTopicResponse({}));
  }

  async queryProductTopic(request: QueryProductTopicRequest): Promise<QueryProductTopicResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryProductTopicWithOptions(request, runtime);
  }

  async querySceneRuleWithOptions(request: QuerySceneRuleRequest, runtime: $Util.RuntimeOptions): Promise<QuerySceneRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.ruleName)) {
      query["RuleName"] = request.ruleName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QuerySceneRule",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QuerySceneRuleResponse>(await this.callApi(params, req, runtime), new QuerySceneRuleResponse({}));
  }

  async querySceneRule(request: QuerySceneRuleRequest): Promise<QuerySceneRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.querySceneRuleWithOptions(request, runtime);
  }

  async querySolutionDeviceGroupPageWithOptions(request: QuerySolutionDeviceGroupPageRequest, runtime: $Util.RuntimeOptions): Promise<QuerySolutionDeviceGroupPageResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.fuzzyGroupName)) {
      query["FuzzyGroupName"] = request.fuzzyGroupName;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageId)) {
      query["PageId"] = request.pageId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.projectCode)) {
      query["ProjectCode"] = request.projectCode;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QuerySolutionDeviceGroupPage",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QuerySolutionDeviceGroupPageResponse>(await this.callApi(params, req, runtime), new QuerySolutionDeviceGroupPageResponse({}));
  }

  async querySolutionDeviceGroupPage(request: QuerySolutionDeviceGroupPageRequest): Promise<QuerySolutionDeviceGroupPageResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.querySolutionDeviceGroupPageWithOptions(request, runtime);
  }

  async querySpeechWithOptions(request: QuerySpeechRequest, runtime: $Util.RuntimeOptions): Promise<QuerySpeechResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: request.iotInstanceId,
    });
    let params = new $OpenApi.Params({
      action: "QuerySpeech",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QuerySpeechResponse>(await this.callApi(params, req, runtime), new QuerySpeechResponse({}));
  }

  async querySpeech(request: QuerySpeechRequest): Promise<QuerySpeechResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.querySpeechWithOptions(request, runtime);
  }

  async querySpeechListWithOptions(request: QuerySpeechListRequest, runtime: $Util.RuntimeOptions): Promise<QuerySpeechListResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: request.iotInstanceId,
    });
    let params = new $OpenApi.Params({
      action: "QuerySpeechList",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QuerySpeechListResponse>(await this.callApi(params, req, runtime), new QuerySpeechListResponse({}));
  }

  async querySpeechList(request: QuerySpeechListRequest): Promise<QuerySpeechListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.querySpeechListWithOptions(request, runtime);
  }

  async querySpeechPushJobWithOptions(request: QuerySpeechPushJobRequest, runtime: $Util.RuntimeOptions): Promise<QuerySpeechPushJobResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.jobCode)) {
      query["JobCode"] = request.jobCode;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: request.iotInstanceId,
    });
    let params = new $OpenApi.Params({
      action: "QuerySpeechPushJob",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QuerySpeechPushJobResponse>(await this.callApi(params, req, runtime), new QuerySpeechPushJobResponse({}));
  }

  async querySpeechPushJob(request: QuerySpeechPushJobRequest): Promise<QuerySpeechPushJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.querySpeechPushJobWithOptions(request, runtime);
  }

  async querySpeechPushJobDeviceWithOptions(request: QuerySpeechPushJobDeviceRequest, runtime: $Util.RuntimeOptions): Promise<QuerySpeechPushJobDeviceResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: request.deviceName,
    });
    let params = new $OpenApi.Params({
      action: "QuerySpeechPushJobDevice",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QuerySpeechPushJobDeviceResponse>(await this.callApi(params, req, runtime), new QuerySpeechPushJobDeviceResponse({}));
  }

  async querySpeechPushJobDevice(request: QuerySpeechPushJobDeviceRequest): Promise<QuerySpeechPushJobDeviceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.querySpeechPushJobDeviceWithOptions(request, runtime);
  }

  async querySpeechPushJobSpeechWithOptions(request: QuerySpeechPushJobSpeechRequest, runtime: $Util.RuntimeOptions): Promise<QuerySpeechPushJobSpeechResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: request.iotInstanceId,
    });
    let params = new $OpenApi.Params({
      action: "QuerySpeechPushJobSpeech",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QuerySpeechPushJobSpeechResponse>(await this.callApi(params, req, runtime), new QuerySpeechPushJobSpeechResponse({}));
  }

  async querySpeechPushJobSpeech(request: QuerySpeechPushJobSpeechRequest): Promise<QuerySpeechPushJobSpeechResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.querySpeechPushJobSpeechWithOptions(request, runtime);
  }

  async queryStudioAppDomainListOpenWithOptions(request: QueryStudioAppDomainListOpenRequest, runtime: $Util.RuntimeOptions): Promise<QueryStudioAppDomainListOpenResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: request.appId,
    });
    let params = new $OpenApi.Params({
      action: "QueryStudioAppDomainListOpen",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryStudioAppDomainListOpenResponse>(await this.callApi(params, req, runtime), new QueryStudioAppDomainListOpenResponse({}));
  }

  async queryStudioAppDomainListOpen(request: QueryStudioAppDomainListOpenRequest): Promise<QueryStudioAppDomainListOpenResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryStudioAppDomainListOpenWithOptions(request, runtime);
  }

  async queryStudioAppListWithOptions(request: QueryStudioAppListRequest, runtime: $Util.RuntimeOptions): Promise<QueryStudioAppListResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: request.fuzzyName,
    });
    let params = new $OpenApi.Params({
      action: "QueryStudioAppList",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryStudioAppListResponse>(await this.callApi(params, req, runtime), new QueryStudioAppListResponse({}));
  }

  async queryStudioAppList(request: QueryStudioAppListRequest): Promise<QueryStudioAppListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryStudioAppListWithOptions(request, runtime);
  }

  async queryStudioAppPageListOpenWithOptions(request: QueryStudioAppPageListOpenRequest, runtime: $Util.RuntimeOptions): Promise<QueryStudioAppPageListOpenResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: request.appId,
    });
    let params = new $OpenApi.Params({
      action: "QueryStudioAppPageListOpen",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryStudioAppPageListOpenResponse>(await this.callApi(params, req, runtime), new QueryStudioAppPageListOpenResponse({}));
  }

  async queryStudioAppPageListOpen(request: QueryStudioAppPageListOpenRequest): Promise<QueryStudioAppPageListOpenResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryStudioAppPageListOpenWithOptions(request, runtime);
  }

  async queryStudioProjectListWithOptions(request: QueryStudioProjectListRequest, runtime: $Util.RuntimeOptions): Promise<QueryStudioProjectListResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: request.iotInstanceId,
    });
    let params = new $OpenApi.Params({
      action: "QueryStudioProjectList",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryStudioProjectListResponse>(await this.callApi(params, req, runtime), new QueryStudioProjectListResponse({}));
  }

  async queryStudioProjectList(request: QueryStudioProjectListRequest): Promise<QueryStudioProjectListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryStudioProjectListWithOptions(request, runtime);
  }

  async querySubscribeRelationWithOptions(request: QuerySubscribeRelationRequest, runtime: $Util.RuntimeOptions): Promise<QuerySubscribeRelationResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QuerySubscribeRelation",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QuerySubscribeRelationResponse>(await this.callApi(params, req, runtime), new QuerySubscribeRelationResponse({}));
  }

  async querySubscribeRelation(request: QuerySubscribeRelationRequest): Promise<QuerySubscribeRelationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.querySubscribeRelationWithOptions(request, runtime);
  }

  async querySummarySceneRuleLogWithOptions(request: QuerySummarySceneRuleLogRequest, runtime: $Util.RuntimeOptions): Promise<QuerySummarySceneRuleLogResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.ruleId)) {
      query["RuleId"] = request.ruleId;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QuerySummarySceneRuleLog",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QuerySummarySceneRuleLogResponse>(await this.callApi(params, req, runtime), new QuerySummarySceneRuleLogResponse({}));
  }

  async querySummarySceneRuleLog(request: QuerySummarySceneRuleLogRequest): Promise<QuerySummarySceneRuleLogResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.querySummarySceneRuleLogWithOptions(request, runtime);
  }

  async querySuperDeviceGroupWithOptions(request: QuerySuperDeviceGroupRequest, runtime: $Util.RuntimeOptions): Promise<QuerySuperDeviceGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QuerySuperDeviceGroup",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QuerySuperDeviceGroupResponse>(await this.callApi(params, req, runtime), new QuerySuperDeviceGroupResponse({}));
  }

  async querySuperDeviceGroup(request: QuerySuperDeviceGroupRequest): Promise<QuerySuperDeviceGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.querySuperDeviceGroupWithOptions(request, runtime);
  }

  async queryTaskWithOptions(request: QueryTaskRequest, runtime: $Util.RuntimeOptions): Promise<QueryTaskResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.taskId)) {
      query["TaskId"] = request.taskId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryTask",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryTaskResponse>(await this.callApi(params, req, runtime), new QueryTaskResponse({}));
  }

  async queryTask(request: QueryTaskRequest): Promise<QueryTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryTaskWithOptions(request, runtime);
  }

  async queryThingModelWithOptions(request: QueryThingModelRequest, runtime: $Util.RuntimeOptions): Promise<QueryThingModelResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.functionBlockId)) {
      query["FunctionBlockId"] = request.functionBlockId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.modelVersion)) {
      query["ModelVersion"] = request.modelVersion;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryThingModel",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryThingModelResponse>(await this.callApi(params, req, runtime), new QueryThingModelResponse({}));
  }

  async queryThingModel(request: QueryThingModelRequest): Promise<QueryThingModelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryThingModelWithOptions(request, runtime);
  }

  async queryThingModelExtendConfigWithOptions(request: QueryThingModelExtendConfigRequest, runtime: $Util.RuntimeOptions): Promise<QueryThingModelExtendConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.functionBlockId)) {
      query["FunctionBlockId"] = request.functionBlockId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.modelVersion)) {
      query["ModelVersion"] = request.modelVersion;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryThingModelExtendConfig",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryThingModelExtendConfigResponse>(await this.callApi(params, req, runtime), new QueryThingModelExtendConfigResponse({}));
  }

  async queryThingModelExtendConfig(request: QueryThingModelExtendConfigRequest): Promise<QueryThingModelExtendConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryThingModelExtendConfigWithOptions(request, runtime);
  }

  async queryThingModelExtendConfigPublishedWithOptions(request: QueryThingModelExtendConfigPublishedRequest, runtime: $Util.RuntimeOptions): Promise<QueryThingModelExtendConfigPublishedResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.functionBlockId)) {
      query["FunctionBlockId"] = request.functionBlockId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.modelVersion)) {
      query["ModelVersion"] = request.modelVersion;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryThingModelExtendConfigPublished",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryThingModelExtendConfigPublishedResponse>(await this.callApi(params, req, runtime), new QueryThingModelExtendConfigPublishedResponse({}));
  }

  async queryThingModelExtendConfigPublished(request: QueryThingModelExtendConfigPublishedRequest): Promise<QueryThingModelExtendConfigPublishedResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryThingModelExtendConfigPublishedWithOptions(request, runtime);
  }

  async queryThingModelPublishedWithOptions(request: QueryThingModelPublishedRequest, runtime: $Util.RuntimeOptions): Promise<QueryThingModelPublishedResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.functionBlockId)) {
      query["FunctionBlockId"] = request.functionBlockId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.modelVersion)) {
      query["ModelVersion"] = request.modelVersion;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryThingModelPublished",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryThingModelPublishedResponse>(await this.callApi(params, req, runtime), new QueryThingModelPublishedResponse({}));
  }

  async queryThingModelPublished(request: QueryThingModelPublishedRequest): Promise<QueryThingModelPublishedResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryThingModelPublishedWithOptions(request, runtime);
  }

  async queryTopicReverseRouteTableWithOptions(request: QueryTopicReverseRouteTableRequest, runtime: $Util.RuntimeOptions): Promise<QueryTopicReverseRouteTableResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.topic)) {
      query["Topic"] = request.topic;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryTopicReverseRouteTable",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryTopicReverseRouteTableResponse>(await this.callApi(params, req, runtime), new QueryTopicReverseRouteTableResponse({}));
  }

  async queryTopicReverseRouteTable(request: QueryTopicReverseRouteTableRequest): Promise<QueryTopicReverseRouteTableResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryTopicReverseRouteTableWithOptions(request, runtime);
  }

  async queryTopicRouteTableWithOptions(request: QueryTopicRouteTableRequest, runtime: $Util.RuntimeOptions): Promise<QueryTopicRouteTableResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.topic)) {
      query["Topic"] = request.topic;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryTopicRouteTable",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryTopicRouteTableResponse>(await this.callApi(params, req, runtime), new QueryTopicRouteTableResponse({}));
  }

  async queryTopicRouteTable(request: QueryTopicRouteTableRequest): Promise<QueryTopicRouteTableResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryTopicRouteTableWithOptions(request, runtime);
  }

  async rRpcWithOptions(request: RRpcRequest, runtime: $Util.RuntimeOptions): Promise<RRpcResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.requestBase64Byte)) {
      query["RequestBase64Byte"] = request.requestBase64Byte;
    }

    if (!Util.isUnset(request.timeout)) {
      query["Timeout"] = request.timeout;
    }

    if (!Util.isUnset(request.topic)) {
      query["Topic"] = request.topic;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "RRpc",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RRpcResponse>(await this.callApi(params, req, runtime), new RRpcResponse({}));
  }

  async rRpc(request: RRpcRequest): Promise<RRpcResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.rRpcWithOptions(request, runtime);
  }

  async refreshDeviceTunnelSharePasswordWithOptions(request: RefreshDeviceTunnelSharePasswordRequest, runtime: $Util.RuntimeOptions): Promise<RefreshDeviceTunnelSharePasswordResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "RefreshDeviceTunnelSharePassword",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RefreshDeviceTunnelSharePasswordResponse>(await this.callApi(params, req, runtime), new RefreshDeviceTunnelSharePasswordResponse({}));
  }

  async refreshDeviceTunnelSharePassword(request: RefreshDeviceTunnelSharePasswordRequest): Promise<RefreshDeviceTunnelSharePasswordResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.refreshDeviceTunnelSharePasswordWithOptions(request, runtime);
  }

  async refreshStudioAppTokenOpenWithOptions(request: RefreshStudioAppTokenOpenRequest, runtime: $Util.RuntimeOptions): Promise<RefreshStudioAppTokenOpenResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: request.appId,
    });
    let params = new $OpenApi.Params({
      action: "RefreshStudioAppTokenOpen",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RefreshStudioAppTokenOpenResponse>(await this.callApi(params, req, runtime), new RefreshStudioAppTokenOpenResponse({}));
  }

  async refreshStudioAppTokenOpen(request: RefreshStudioAppTokenOpenRequest): Promise<RefreshStudioAppTokenOpenResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.refreshStudioAppTokenOpenWithOptions(request, runtime);
  }

  async registerDeviceWithOptions(request: RegisterDeviceRequest, runtime: $Util.RuntimeOptions): Promise<RegisterDeviceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appKey)) {
      query["AppKey"] = request.appKey;
    }

    if (!Util.isUnset(request.devEui)) {
      query["DevEui"] = request.devEui;
    }

    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.joinEui)) {
      query["JoinEui"] = request.joinEui;
    }

    if (!Util.isUnset(request.loraNodeType)) {
      query["LoraNodeType"] = request.loraNodeType;
    }

    if (!Util.isUnset(request.nickname)) {
      query["Nickname"] = request.nickname;
    }

    if (!Util.isUnset(request.pinCode)) {
      query["PinCode"] = request.pinCode;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "RegisterDevice",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RegisterDeviceResponse>(await this.callApi(params, req, runtime), new RegisterDeviceResponse({}));
  }

  async registerDevice(request: RegisterDeviceRequest): Promise<RegisterDeviceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.registerDeviceWithOptions(request, runtime);
  }

  async releaseEdgeDriverVersionWithOptions(request: ReleaseEdgeDriverVersionRequest, runtime: $Util.RuntimeOptions): Promise<ReleaseEdgeDriverVersionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.driverId)) {
      query["DriverId"] = request.driverId;
    }

    if (!Util.isUnset(request.driverVersion)) {
      query["DriverVersion"] = request.driverVersion;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ReleaseEdgeDriverVersion",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ReleaseEdgeDriverVersionResponse>(await this.callApi(params, req, runtime), new ReleaseEdgeDriverVersionResponse({}));
  }

  async releaseEdgeDriverVersion(request: ReleaseEdgeDriverVersionRequest): Promise<ReleaseEdgeDriverVersionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.releaseEdgeDriverVersionWithOptions(request, runtime);
  }

  async releaseProductWithOptions(request: ReleaseProductRequest, runtime: $Util.RuntimeOptions): Promise<ReleaseProductResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ReleaseProduct",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ReleaseProductResponse>(await this.callApi(params, req, runtime), new ReleaseProductResponse({}));
  }

  async releaseProduct(request: ReleaseProductRequest): Promise<ReleaseProductResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.releaseProductWithOptions(request, runtime);
  }

  async removeThingTopoWithOptions(request: RemoveThingTopoRequest, runtime: $Util.RuntimeOptions): Promise<RemoveThingTopoResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotId)) {
      query["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "RemoveThingTopo",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RemoveThingTopoResponse>(await this.callApi(params, req, runtime), new RemoveThingTopoResponse({}));
  }

  async removeThingTopo(request: RemoveThingTopoRequest): Promise<RemoveThingTopoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.removeThingTopoWithOptions(request, runtime);
  }

  async replaceEdgeInstanceGatewayWithOptions(request: ReplaceEdgeInstanceGatewayRequest, runtime: $Util.RuntimeOptions): Promise<ReplaceEdgeInstanceGatewayResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentGatewayId)) {
      query["CurrentGatewayId"] = request.currentGatewayId;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.newGatewayId)) {
      query["NewGatewayId"] = request.newGatewayId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ReplaceEdgeInstanceGateway",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ReplaceEdgeInstanceGatewayResponse>(await this.callApi(params, req, runtime), new ReplaceEdgeInstanceGatewayResponse({}));
  }

  async replaceEdgeInstanceGateway(request: ReplaceEdgeInstanceGatewayRequest): Promise<ReplaceEdgeInstanceGatewayResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.replaceEdgeInstanceGatewayWithOptions(request, runtime);
  }

  async rerunJobWithOptions(request: RerunJobRequest, runtime: $Util.RuntimeOptions): Promise<RerunJobResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.jobId)) {
      query["JobId"] = request.jobId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "RerunJob",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RerunJobResponse>(await this.callApi(params, req, runtime), new RerunJobResponse({}));
  }

  async rerunJob(request: RerunJobRequest): Promise<RerunJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.rerunJobWithOptions(request, runtime);
  }

  async resetConsumerGroupPositionWithOptions(request: ResetConsumerGroupPositionRequest, runtime: $Util.RuntimeOptions): Promise<ResetConsumerGroupPositionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ResetConsumerGroupPosition",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ResetConsumerGroupPositionResponse>(await this.callApi(params, req, runtime), new ResetConsumerGroupPositionResponse({}));
  }

  async resetConsumerGroupPosition(request: ResetConsumerGroupPositionRequest): Promise<ResetConsumerGroupPositionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.resetConsumerGroupPositionWithOptions(request, runtime);
  }

  async resetThingWithOptions(request: ResetThingRequest, runtime: $Util.RuntimeOptions): Promise<ResetThingResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotId)) {
      query["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ResetThing",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ResetThingResponse>(await this.callApi(params, req, runtime), new ResetThingResponse({}));
  }

  async resetThing(request: ResetThingRequest): Promise<ResetThingResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.resetThingWithOptions(request, runtime);
  }

  async saveDevicePropWithOptions(request: SaveDevicePropRequest, runtime: $Util.RuntimeOptions): Promise<SaveDevicePropResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotId)) {
      query["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.props)) {
      query["Props"] = request.props;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SaveDeviceProp",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SaveDevicePropResponse>(await this.callApi(params, req, runtime), new SaveDevicePropResponse({}));
  }

  async saveDeviceProp(request: SaveDevicePropRequest): Promise<SaveDevicePropResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.saveDevicePropWithOptions(request, runtime);
  }

  async setDeviceDesiredPropertyWithOptions(request: SetDeviceDesiredPropertyRequest, runtime: $Util.RuntimeOptions): Promise<SetDeviceDesiredPropertyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotId)) {
      query["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.items)) {
      query["Items"] = request.items;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.versions)) {
      query["Versions"] = request.versions;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SetDeviceDesiredProperty",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SetDeviceDesiredPropertyResponse>(await this.callApi(params, req, runtime), new SetDeviceDesiredPropertyResponse({}));
  }

  async setDeviceDesiredProperty(request: SetDeviceDesiredPropertyRequest): Promise<SetDeviceDesiredPropertyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setDeviceDesiredPropertyWithOptions(request, runtime);
  }

  async setDeviceGroupTagsWithOptions(request: SetDeviceGroupTagsRequest, runtime: $Util.RuntimeOptions): Promise<SetDeviceGroupTagsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.tagString)) {
      query["TagString"] = request.tagString;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SetDeviceGroupTags",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SetDeviceGroupTagsResponse>(await this.callApi(params, req, runtime), new SetDeviceGroupTagsResponse({}));
  }

  async setDeviceGroupTags(request: SetDeviceGroupTagsRequest): Promise<SetDeviceGroupTagsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setDeviceGroupTagsWithOptions(request, runtime);
  }

  async setDevicePropertyWithOptions(request: SetDevicePropertyRequest, runtime: $Util.RuntimeOptions): Promise<SetDevicePropertyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotId)) {
      query["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.items)) {
      query["Items"] = request.items;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SetDeviceProperty",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SetDevicePropertyResponse>(await this.callApi(params, req, runtime), new SetDevicePropertyResponse({}));
  }

  async setDeviceProperty(request: SetDevicePropertyRequest): Promise<SetDevicePropertyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setDevicePropertyWithOptions(request, runtime);
  }

  async setDevicesPropertyWithOptions(request: SetDevicesPropertyRequest, runtime: $Util.RuntimeOptions): Promise<SetDevicesPropertyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.items)) {
      query["Items"] = request.items;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SetDevicesProperty",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SetDevicesPropertyResponse>(await this.callApi(params, req, runtime), new SetDevicesPropertyResponse({}));
  }

  async setDevicesProperty(request: SetDevicesPropertyRequest): Promise<SetDevicesPropertyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setDevicesPropertyWithOptions(request, runtime);
  }

  async setEdgeInstanceDriverConfigsWithOptions(request: SetEdgeInstanceDriverConfigsRequest, runtime: $Util.RuntimeOptions): Promise<SetEdgeInstanceDriverConfigsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.configs)) {
      query["Configs"] = request.configs;
    }

    if (!Util.isUnset(request.driverId)) {
      query["DriverId"] = request.driverId;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SetEdgeInstanceDriverConfigs",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SetEdgeInstanceDriverConfigsResponse>(await this.callApi(params, req, runtime), new SetEdgeInstanceDriverConfigsResponse({}));
  }

  async setEdgeInstanceDriverConfigs(request: SetEdgeInstanceDriverConfigsRequest): Promise<SetEdgeInstanceDriverConfigsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setEdgeInstanceDriverConfigsWithOptions(request, runtime);
  }

  async setProductCertInfoWithOptions(request: SetProductCertInfoRequest, runtime: $Util.RuntimeOptions): Promise<SetProductCertInfoResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.issueModel)) {
      query["IssueModel"] = request.issueModel;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SetProductCertInfo",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SetProductCertInfoResponse>(await this.callApi(params, req, runtime), new SetProductCertInfoResponse({}));
  }

  async setProductCertInfo(request: SetProductCertInfoRequest): Promise<SetProductCertInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setProductCertInfoWithOptions(request, runtime);
  }

  async setStudioProjectCooperationWithOptions(request: SetStudioProjectCooperationRequest, runtime: $Util.RuntimeOptions): Promise<SetStudioProjectCooperationResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: request.iotInstanceId,
    });
    let params = new $OpenApi.Params({
      action: "SetStudioProjectCooperation",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SetStudioProjectCooperationResponse>(await this.callApi(params, req, runtime), new SetStudioProjectCooperationResponse({}));
  }

  async setStudioProjectCooperation(request: SetStudioProjectCooperationRequest): Promise<SetStudioProjectCooperationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setStudioProjectCooperationWithOptions(request, runtime);
  }

  async setupStudioAppAuthModeOpenWithOptions(request: SetupStudioAppAuthModeOpenRequest, runtime: $Util.RuntimeOptions): Promise<SetupStudioAppAuthModeOpenResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: request.appId,
    });
    let params = new $OpenApi.Params({
      action: "SetupStudioAppAuthModeOpen",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SetupStudioAppAuthModeOpenResponse>(await this.callApi(params, req, runtime), new SetupStudioAppAuthModeOpenResponse({}));
  }

  async setupStudioAppAuthModeOpen(request: SetupStudioAppAuthModeOpenRequest): Promise<SetupStudioAppAuthModeOpenResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setupStudioAppAuthModeOpenWithOptions(request, runtime);
  }

  async speechByCombinationWithOptions(request: SpeechByCombinationRequest, runtime: $Util.RuntimeOptions): Promise<SpeechByCombinationResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: request.combinationList,
    });
    let params = new $OpenApi.Params({
      action: "SpeechByCombination",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SpeechByCombinationResponse>(await this.callApi(params, req, runtime), new SpeechByCombinationResponse({}));
  }

  async speechByCombination(request: SpeechByCombinationRequest): Promise<SpeechByCombinationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.speechByCombinationWithOptions(request, runtime);
  }

  async startCpuWithOptions(request: StartCpuRequest, runtime: $Util.RuntimeOptions): Promise<StartCpuResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotId)) {
      query["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.targetValue)) {
      query["TargetValue"] = request.targetValue;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "StartCpu",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<StartCpuResponse>(await this.callApi(params, req, runtime), new StartCpuResponse({}));
  }

  async startCpu(request: StartCpuRequest): Promise<StartCpuResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.startCpuWithOptions(request, runtime);
  }

  async startRuleWithOptions(request: StartRuleRequest, runtime: $Util.RuntimeOptions): Promise<StartRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.ruleId)) {
      query["RuleId"] = request.ruleId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "StartRule",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<StartRuleResponse>(await this.callApi(params, req, runtime), new StartRuleResponse({}));
  }

  async startRule(request: StartRuleRequest): Promise<StartRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.startRuleWithOptions(request, runtime);
  }

  async stopRuleWithOptions(request: StopRuleRequest, runtime: $Util.RuntimeOptions): Promise<StopRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.ruleId)) {
      query["RuleId"] = request.ruleId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "StopRule",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<StopRuleResponse>(await this.callApi(params, req, runtime), new StopRuleResponse({}));
  }

  async stopRule(request: StopRuleRequest): Promise<StopRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.stopRuleWithOptions(request, runtime);
  }

  async syncSpeechByCombinationWithOptions(request: SyncSpeechByCombinationRequest, runtime: $Util.RuntimeOptions): Promise<SyncSpeechByCombinationResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: request.combinationList,
    });
    let params = new $OpenApi.Params({
      action: "SyncSpeechByCombination",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SyncSpeechByCombinationResponse>(await this.callApi(params, req, runtime), new SyncSpeechByCombinationResponse({}));
  }

  async syncSpeechByCombination(request: SyncSpeechByCombinationRequest): Promise<SyncSpeechByCombinationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.syncSpeechByCombinationWithOptions(request, runtime);
  }

  async testSpeechWithOptions(request: TestSpeechRequest, runtime: $Util.RuntimeOptions): Promise<TestSpeechResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: request.iotInstanceId,
    });
    let params = new $OpenApi.Params({
      action: "TestSpeech",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<TestSpeechResponse>(await this.callApi(params, req, runtime), new TestSpeechResponse({}));
  }

  async testSpeech(request: TestSpeechRequest): Promise<TestSpeechResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.testSpeechWithOptions(request, runtime);
  }

  async triggerSceneRuleWithOptions(request: TriggerSceneRuleRequest, runtime: $Util.RuntimeOptions): Promise<TriggerSceneRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.ruleId)) {
      query["RuleId"] = request.ruleId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "TriggerSceneRule",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<TriggerSceneRuleResponse>(await this.callApi(params, req, runtime), new TriggerSceneRuleResponse({}));
  }

  async triggerSceneRule(request: TriggerSceneRuleRequest): Promise<TriggerSceneRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.triggerSceneRuleWithOptions(request, runtime);
  }

  async unbindApplicationFromEdgeInstanceWithOptions(request: UnbindApplicationFromEdgeInstanceRequest, runtime: $Util.RuntimeOptions): Promise<UnbindApplicationFromEdgeInstanceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.applicationId)) {
      query["ApplicationId"] = request.applicationId;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UnbindApplicationFromEdgeInstance",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UnbindApplicationFromEdgeInstanceResponse>(await this.callApi(params, req, runtime), new UnbindApplicationFromEdgeInstanceResponse({}));
  }

  async unbindApplicationFromEdgeInstance(request: UnbindApplicationFromEdgeInstanceRequest): Promise<UnbindApplicationFromEdgeInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.unbindApplicationFromEdgeInstanceWithOptions(request, runtime);
  }

  async unbindDriverFromEdgeInstanceWithOptions(request: UnbindDriverFromEdgeInstanceRequest, runtime: $Util.RuntimeOptions): Promise<UnbindDriverFromEdgeInstanceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.driverId)) {
      query["DriverId"] = request.driverId;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UnbindDriverFromEdgeInstance",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UnbindDriverFromEdgeInstanceResponse>(await this.callApi(params, req, runtime), new UnbindDriverFromEdgeInstanceResponse({}));
  }

  async unbindDriverFromEdgeInstance(request: UnbindDriverFromEdgeInstanceRequest): Promise<UnbindDriverFromEdgeInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.unbindDriverFromEdgeInstanceWithOptions(request, runtime);
  }

  async unbindRoleFromEdgeInstanceWithOptions(request: UnbindRoleFromEdgeInstanceRequest, runtime: $Util.RuntimeOptions): Promise<UnbindRoleFromEdgeInstanceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UnbindRoleFromEdgeInstance",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UnbindRoleFromEdgeInstanceResponse>(await this.callApi(params, req, runtime), new UnbindRoleFromEdgeInstanceResponse({}));
  }

  async unbindRoleFromEdgeInstance(request: UnbindRoleFromEdgeInstanceRequest): Promise<UnbindRoleFromEdgeInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.unbindRoleFromEdgeInstanceWithOptions(request, runtime);
  }

  async unbindSceneRuleFromEdgeInstanceWithOptions(request: UnbindSceneRuleFromEdgeInstanceRequest, runtime: $Util.RuntimeOptions): Promise<UnbindSceneRuleFromEdgeInstanceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.ruleId)) {
      query["RuleId"] = request.ruleId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UnbindSceneRuleFromEdgeInstance",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UnbindSceneRuleFromEdgeInstanceResponse>(await this.callApi(params, req, runtime), new UnbindSceneRuleFromEdgeInstanceResponse({}));
  }

  async unbindSceneRuleFromEdgeInstance(request: UnbindSceneRuleFromEdgeInstanceRequest): Promise<UnbindSceneRuleFromEdgeInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.unbindSceneRuleFromEdgeInstanceWithOptions(request, runtime);
  }

  async updateConsumerGroupWithOptions(request: UpdateConsumerGroupRequest, runtime: $Util.RuntimeOptions): Promise<UpdateConsumerGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.newGroupName)) {
      query["NewGroupName"] = request.newGroupName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateConsumerGroup",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateConsumerGroupResponse>(await this.callApi(params, req, runtime), new UpdateConsumerGroupResponse({}));
  }

  async updateConsumerGroup(request: UpdateConsumerGroupRequest): Promise<UpdateConsumerGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateConsumerGroupWithOptions(request, runtime);
  }

  async updateDeviceGroupWithOptions(request: UpdateDeviceGroupRequest, runtime: $Util.RuntimeOptions): Promise<UpdateDeviceGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupDesc)) {
      query["GroupDesc"] = request.groupDesc;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateDeviceGroup",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateDeviceGroupResponse>(await this.callApi(params, req, runtime), new UpdateDeviceGroupResponse({}));
  }

  async updateDeviceGroup(request: UpdateDeviceGroupRequest): Promise<UpdateDeviceGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateDeviceGroupWithOptions(request, runtime);
  }

  async updateDeviceShadowWithOptions(request: UpdateDeviceShadowRequest, runtime: $Util.RuntimeOptions): Promise<UpdateDeviceShadowResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deltaUpdate)) {
      query["DeltaUpdate"] = request.deltaUpdate;
    }

    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.shadowMessage)) {
      query["ShadowMessage"] = request.shadowMessage;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateDeviceShadow",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateDeviceShadowResponse>(await this.callApi(params, req, runtime), new UpdateDeviceShadowResponse({}));
  }

  async updateDeviceShadow(request: UpdateDeviceShadowRequest): Promise<UpdateDeviceShadowResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateDeviceShadowWithOptions(request, runtime);
  }

  async updateEdgeDriverVersionWithOptions(request: UpdateEdgeDriverVersionRequest, runtime: $Util.RuntimeOptions): Promise<UpdateEdgeDriverVersionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.argument)) {
      query["Argument"] = request.argument;
    }

    if (!Util.isUnset(request.configCheckRule)) {
      query["ConfigCheckRule"] = request.configCheckRule;
    }

    if (!Util.isUnset(request.containerConfig)) {
      query["ContainerConfig"] = request.containerConfig;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.driverConfig)) {
      query["DriverConfig"] = request.driverConfig;
    }

    if (!Util.isUnset(request.driverId)) {
      query["DriverId"] = request.driverId;
    }

    if (!Util.isUnset(request.driverVersion)) {
      query["DriverVersion"] = request.driverVersion;
    }

    if (!Util.isUnset(request.edgeVersion)) {
      query["EdgeVersion"] = request.edgeVersion;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.sourceConfig)) {
      query["SourceConfig"] = request.sourceConfig;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateEdgeDriverVersion",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateEdgeDriverVersionResponse>(await this.callApi(params, req, runtime), new UpdateEdgeDriverVersionResponse({}));
  }

  async updateEdgeDriverVersion(request: UpdateEdgeDriverVersionRequest): Promise<UpdateEdgeDriverVersionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateEdgeDriverVersionWithOptions(request, runtime);
  }

  async updateEdgeInstanceWithOptions(request: UpdateEdgeInstanceRequest, runtime: $Util.RuntimeOptions): Promise<UpdateEdgeInstanceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.bizEnable)) {
      query["BizEnable"] = request.bizEnable;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.spec)) {
      query["Spec"] = request.spec;
    }

    if (!Util.isUnset(request.tags)) {
      query["Tags"] = request.tags;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateEdgeInstance",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateEdgeInstanceResponse>(await this.callApi(params, req, runtime), new UpdateEdgeInstanceResponse({}));
  }

  async updateEdgeInstance(request: UpdateEdgeInstanceRequest): Promise<UpdateEdgeInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateEdgeInstanceWithOptions(request, runtime);
  }

  async updateEdgeInstanceChannelWithOptions(request: UpdateEdgeInstanceChannelRequest, runtime: $Util.RuntimeOptions): Promise<UpdateEdgeInstanceChannelResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.channelId)) {
      query["ChannelId"] = request.channelId;
    }

    if (!Util.isUnset(request.channelName)) {
      query["ChannelName"] = request.channelName;
    }

    if (!Util.isUnset(request.configs)) {
      query["Configs"] = request.configs;
    }

    if (!Util.isUnset(request.driverId)) {
      query["DriverId"] = request.driverId;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateEdgeInstanceChannel",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateEdgeInstanceChannelResponse>(await this.callApi(params, req, runtime), new UpdateEdgeInstanceChannelResponse({}));
  }

  async updateEdgeInstanceChannel(request: UpdateEdgeInstanceChannelRequest): Promise<UpdateEdgeInstanceChannelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateEdgeInstanceChannelWithOptions(request, runtime);
  }

  async updateEdgeInstanceMessageRoutingWithOptions(request: UpdateEdgeInstanceMessageRoutingRequest, runtime: $Util.RuntimeOptions): Promise<UpdateEdgeInstanceMessageRoutingResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.routeId)) {
      query["RouteId"] = request.routeId;
    }

    if (!Util.isUnset(request.sourceData)) {
      query["SourceData"] = request.sourceData;
    }

    if (!Util.isUnset(request.sourceType)) {
      query["SourceType"] = request.sourceType;
    }

    if (!Util.isUnset(request.targetData)) {
      query["TargetData"] = request.targetData;
    }

    if (!Util.isUnset(request.targetIotHubQos)) {
      query["TargetIotHubQos"] = request.targetIotHubQos;
    }

    if (!Util.isUnset(request.targetType)) {
      query["TargetType"] = request.targetType;
    }

    if (!Util.isUnset(request.topicFilter)) {
      query["TopicFilter"] = request.topicFilter;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateEdgeInstanceMessageRouting",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateEdgeInstanceMessageRoutingResponse>(await this.callApi(params, req, runtime), new UpdateEdgeInstanceMessageRoutingResponse({}));
  }

  async updateEdgeInstanceMessageRouting(request: UpdateEdgeInstanceMessageRoutingRequest): Promise<UpdateEdgeInstanceMessageRoutingResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateEdgeInstanceMessageRoutingWithOptions(request, runtime);
  }

  async updateJobWithOptions(request: UpdateJobRequest, runtime: $Util.RuntimeOptions): Promise<UpdateJobResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.jobId)) {
      query["JobId"] = request.jobId;
    }

    if (!Util.isUnset(request.rolloutConfig)) {
      query["RolloutConfig"] = request.rolloutConfig;
    }

    if (!Util.isUnset(request.timeoutConfig)) {
      query["TimeoutConfig"] = request.timeoutConfig;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateJob",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateJobResponse>(await this.callApi(params, req, runtime), new UpdateJobResponse({}));
  }

  async updateJob(request: UpdateJobRequest): Promise<UpdateJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateJobWithOptions(request, runtime);
  }

  async updateOTAModuleWithOptions(request: UpdateOTAModuleRequest, runtime: $Util.RuntimeOptions): Promise<UpdateOTAModuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.aliasName)) {
      query["AliasName"] = request.aliasName;
    }

    if (!Util.isUnset(request.desc)) {
      query["Desc"] = request.desc;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.moduleName)) {
      query["ModuleName"] = request.moduleName;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateOTAModule",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateOTAModuleResponse>(await this.callApi(params, req, runtime), new UpdateOTAModuleResponse({}));
  }

  async updateOTAModule(request: UpdateOTAModuleRequest): Promise<UpdateOTAModuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateOTAModuleWithOptions(request, runtime);
  }

  async updateProductWithOptions(request: UpdateProductRequest, runtime: $Util.RuntimeOptions): Promise<UpdateProductResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.productName)) {
      query["ProductName"] = request.productName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateProduct",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateProductResponse>(await this.callApi(params, req, runtime), new UpdateProductResponse({}));
  }

  async updateProduct(request: UpdateProductRequest): Promise<UpdateProductResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateProductWithOptions(request, runtime);
  }

  async updateProductFilterConfigWithOptions(request: UpdateProductFilterConfigRequest, runtime: $Util.RuntimeOptions): Promise<UpdateProductFilterConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.propertyTimestampFilter)) {
      query["PropertyTimestampFilter"] = request.propertyTimestampFilter;
    }

    if (!Util.isUnset(request.propertyValueFilter)) {
      query["PropertyValueFilter"] = request.propertyValueFilter;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateProductFilterConfig",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateProductFilterConfigResponse>(await this.callApi(params, req, runtime), new UpdateProductFilterConfigResponse({}));
  }

  async updateProductFilterConfig(request: UpdateProductFilterConfigRequest): Promise<UpdateProductFilterConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateProductFilterConfigWithOptions(request, runtime);
  }

  async updateProductTagsWithOptions(request: UpdateProductTagsRequest, runtime: $Util.RuntimeOptions): Promise<UpdateProductTagsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.productTag)) {
      query["ProductTag"] = request.productTag;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateProductTags",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateProductTagsResponse>(await this.callApi(params, req, runtime), new UpdateProductTagsResponse({}));
  }

  async updateProductTags(request: UpdateProductTagsRequest): Promise<UpdateProductTagsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateProductTagsWithOptions(request, runtime);
  }

  async updateProductTopicWithOptions(request: UpdateProductTopicRequest, runtime: $Util.RuntimeOptions): Promise<UpdateProductTopicResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.desc)) {
      query["Desc"] = request.desc;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.operation)) {
      query["Operation"] = request.operation;
    }

    if (!Util.isUnset(request.topicId)) {
      query["TopicId"] = request.topicId;
    }

    if (!Util.isUnset(request.topicShortName)) {
      query["TopicShortName"] = request.topicShortName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateProductTopic",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateProductTopicResponse>(await this.callApi(params, req, runtime), new UpdateProductTopicResponse({}));
  }

  async updateProductTopic(request: UpdateProductTopicRequest): Promise<UpdateProductTopicResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateProductTopicWithOptions(request, runtime);
  }

  async updateRuleWithOptions(request: UpdateRuleRequest, runtime: $Util.RuntimeOptions): Promise<UpdateRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.ruleDesc)) {
      query["RuleDesc"] = request.ruleDesc;
    }

    if (!Util.isUnset(request.ruleId)) {
      query["RuleId"] = request.ruleId;
    }

    if (!Util.isUnset(request.select)) {
      query["Select"] = request.select;
    }

    if (!Util.isUnset(request.shortTopic)) {
      query["ShortTopic"] = request.shortTopic;
    }

    if (!Util.isUnset(request.topic)) {
      query["Topic"] = request.topic;
    }

    if (!Util.isUnset(request.topicType)) {
      query["TopicType"] = request.topicType;
    }

    if (!Util.isUnset(request.where)) {
      query["Where"] = request.where;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateRule",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateRuleResponse>(await this.callApi(params, req, runtime), new UpdateRuleResponse({}));
  }

  async updateRule(request: UpdateRuleRequest): Promise<UpdateRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateRuleWithOptions(request, runtime);
  }

  async updateRuleActionWithOptions(request: UpdateRuleActionRequest, runtime: $Util.RuntimeOptions): Promise<UpdateRuleActionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.actionId)) {
      query["ActionId"] = request.actionId;
    }

    if (!Util.isUnset(request.configuration)) {
      query["Configuration"] = request.configuration;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateRuleAction",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateRuleActionResponse>(await this.callApi(params, req, runtime), new UpdateRuleActionResponse({}));
  }

  async updateRuleAction(request: UpdateRuleActionRequest): Promise<UpdateRuleActionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateRuleActionWithOptions(request, runtime);
  }

  async updateSceneRuleWithOptions(request: UpdateSceneRuleRequest, runtime: $Util.RuntimeOptions): Promise<UpdateSceneRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.ruleContent)) {
      query["RuleContent"] = request.ruleContent;
    }

    if (!Util.isUnset(request.ruleDescription)) {
      query["RuleDescription"] = request.ruleDescription;
    }

    if (!Util.isUnset(request.ruleId)) {
      query["RuleId"] = request.ruleId;
    }

    if (!Util.isUnset(request.ruleName)) {
      query["RuleName"] = request.ruleName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateSceneRule",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateSceneRuleResponse>(await this.callApi(params, req, runtime), new UpdateSceneRuleResponse({}));
  }

  async updateSceneRule(request: UpdateSceneRuleRequest): Promise<UpdateSceneRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateSceneRuleWithOptions(request, runtime);
  }

  async updateSpeechWithOptions(request: UpdateSpeechRequest, runtime: $Util.RuntimeOptions): Promise<UpdateSpeechResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({
      body: request.iotInstanceId,
    });
    let params = new $OpenApi.Params({
      action: "UpdateSpeech",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateSpeechResponse>(await this.callApi(params, req, runtime), new UpdateSpeechResponse({}));
  }

  async updateSpeech(request: UpdateSpeechRequest): Promise<UpdateSpeechResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateSpeechWithOptions(request, runtime);
  }

  async updateSubscribeRelationWithOptions(request: UpdateSubscribeRelationRequest, runtime: $Util.RuntimeOptions): Promise<UpdateSubscribeRelationResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.consumerGroupIds)) {
      query["ConsumerGroupIds"] = request.consumerGroupIds;
    }

    if (!Util.isUnset(request.deviceDataFlag)) {
      query["DeviceDataFlag"] = request.deviceDataFlag;
    }

    if (!Util.isUnset(request.deviceLifeCycleFlag)) {
      query["DeviceLifeCycleFlag"] = request.deviceLifeCycleFlag;
    }

    if (!Util.isUnset(request.deviceStatusChangeFlag)) {
      query["DeviceStatusChangeFlag"] = request.deviceStatusChangeFlag;
    }

    if (!Util.isUnset(request.deviceTagFlag)) {
      query["DeviceTagFlag"] = request.deviceTagFlag;
    }

    if (!Util.isUnset(request.deviceTopoLifeCycleFlag)) {
      query["DeviceTopoLifeCycleFlag"] = request.deviceTopoLifeCycleFlag;
    }

    if (!Util.isUnset(request.foundDeviceListFlag)) {
      query["FoundDeviceListFlag"] = request.foundDeviceListFlag;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.mnsConfiguration)) {
      query["MnsConfiguration"] = request.mnsConfiguration;
    }

    if (!Util.isUnset(request.otaEventFlag)) {
      query["OtaEventFlag"] = request.otaEventFlag;
    }

    if (!Util.isUnset(request.otaJobFlag)) {
      query["OtaJobFlag"] = request.otaJobFlag;
    }

    if (!Util.isUnset(request.otaVersionFlag)) {
      query["OtaVersionFlag"] = request.otaVersionFlag;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.thingHistoryFlag)) {
      query["ThingHistoryFlag"] = request.thingHistoryFlag;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateSubscribeRelation",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateSubscribeRelationResponse>(await this.callApi(params, req, runtime), new UpdateSubscribeRelationResponse({}));
  }

  async updateSubscribeRelation(request: UpdateSubscribeRelationRequest): Promise<UpdateSubscribeRelationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateSubscribeRelationWithOptions(request, runtime);
  }

  async updateThingModelWithOptions(request: UpdateThingModelRequest, runtime: $Util.RuntimeOptions): Promise<UpdateThingModelResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.functionBlockId)) {
      query["FunctionBlockId"] = request.functionBlockId;
    }

    if (!Util.isUnset(request.functionBlockName)) {
      query["FunctionBlockName"] = request.functionBlockName;
    }

    if (!Util.isUnset(request.identifier)) {
      query["Identifier"] = request.identifier;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.thingModelJson)) {
      query["ThingModelJson"] = request.thingModelJson;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateThingModel",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateThingModelResponse>(await this.callApi(params, req, runtime), new UpdateThingModelResponse({}));
  }

  async updateThingModel(request: UpdateThingModelRequest): Promise<UpdateThingModelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateThingModelWithOptions(request, runtime);
  }

  async updateThingModelValidationConfigWithOptions(request: UpdateThingModelValidationConfigRequest, runtime: $Util.RuntimeOptions): Promise<UpdateThingModelValidationConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.validateType)) {
      query["ValidateType"] = request.validateType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateThingModelValidationConfig",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateThingModelValidationConfigResponse>(await this.callApi(params, req, runtime), new UpdateThingModelValidationConfigResponse({}));
  }

  async updateThingModelValidationConfig(request: UpdateThingModelValidationConfigRequest): Promise<UpdateThingModelValidationConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateThingModelValidationConfigWithOptions(request, runtime);
  }

  async updateThingScriptWithOptions(request: UpdateThingScriptRequest, runtime: $Util.RuntimeOptions): Promise<UpdateThingScriptResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.scriptContent)) {
      query["ScriptContent"] = request.scriptContent;
    }

    if (!Util.isUnset(request.scriptType)) {
      query["ScriptType"] = request.scriptType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateThingScript",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateThingScriptResponse>(await this.callApi(params, req, runtime), new UpdateThingScriptResponse({}));
  }

  async updateThingScript(request: UpdateThingScriptRequest): Promise<UpdateThingScriptResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateThingScriptWithOptions(request, runtime);
  }

}
