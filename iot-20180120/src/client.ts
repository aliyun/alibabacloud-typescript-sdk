// This file is auto-generated, don't edit it
/**
 *
 */
import Util, * as $Util from '@alicloud/tea-util';
import OpenApi, * as $OpenApi from '@alicloud/openapi-client';
import OpenApiUtil from '@alicloud/openapi-util';
import EndpointUtil from '@alicloud/endpoint-util';
import * as $tea from '@alicloud/tea-typescript';

export class AddDataForApiSourceRequest extends $tea.Model {
  apiId?: string;
  content?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      content: 'Content',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'string',
      content: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddDataForApiSourceResponseBody extends $tea.Model {
  code?: string;
  data?: number;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'number',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddDataForApiSourceResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: AddDataForApiSourceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddDataForApiSourceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddShareTaskDeviceRequest extends $tea.Model {
  iotIdList?: string[];
  iotInstanceId?: string;
  productKey?: string;
  shareTaskId?: string;
  static names(): { [key: string]: string } {
    return {
      iotIdList: 'IotIdList',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
      shareTaskId: 'ShareTaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotIdList: { 'type': 'array', 'itemType': 'string' },
      iotInstanceId: 'string',
      productKey: 'string',
      shareTaskId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddShareTaskDeviceResponseBody extends $tea.Model {
  code?: string;
  data?: AddShareTaskDeviceResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: AddShareTaskDeviceResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddShareTaskDeviceResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: AddShareTaskDeviceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddShareTaskDeviceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AsyncRRpcRequest extends $tea.Model {
  deviceName?: string;
  extInfo?: string;
  iotInstanceId?: string;
  messageContent?: string;
  productKey?: string;
  topicFullName?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      extInfo: 'ExtInfo',
      iotInstanceId: 'IotInstanceId',
      messageContent: 'MessageContent',
      productKey: 'ProductKey',
      topicFullName: 'TopicFullName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      extInfo: 'string',
      iotInstanceId: 'string',
      messageContent: 'string',
      productKey: 'string',
      topicFullName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AsyncRRpcResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  messageId?: number;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      messageId: 'MessageId',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      messageId: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AsyncRRpcResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: AsyncRRpcResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AsyncRRpcResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AttachDestinationRequest extends $tea.Model {
  destinationId?: number;
  iotInstanceId?: string;
  isFailover?: boolean;
  parserId?: number;
  static names(): { [key: string]: string } {
    return {
      destinationId: 'DestinationId',
      iotInstanceId: 'IotInstanceId',
      isFailover: 'IsFailover',
      parserId: 'ParserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      destinationId: 'number',
      iotInstanceId: 'string',
      isFailover: 'boolean',
      parserId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AttachDestinationResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AttachDestinationResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: AttachDestinationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AttachDestinationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AttachParserDataSourceRequest extends $tea.Model {
  dataSourceId?: number;
  iotInstanceId?: string;
  parserId?: number;
  static names(): { [key: string]: string } {
    return {
      dataSourceId: 'DataSourceId',
      iotInstanceId: 'IotInstanceId',
      parserId: 'ParserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataSourceId: 'number',
      iotInstanceId: 'string',
      parserId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AttachParserDataSourceResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AttachParserDataSourceResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: AttachParserDataSourceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AttachParserDataSourceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchAddDataForApiSourceRequest extends $tea.Model {
  apiId?: string;
  contentList?: { [key: string]: any };
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      contentList: 'ContentList',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'string',
      contentList: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchAddDataForApiSourceShrinkRequest extends $tea.Model {
  apiId?: string;
  contentListShrink?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      contentListShrink: 'ContentList',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'string',
      contentListShrink: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchAddDataForApiSourceResponseBody extends $tea.Model {
  code?: string;
  data?: { [key: string]: any };
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchAddDataForApiSourceResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: BatchAddDataForApiSourceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchAddDataForApiSourceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchAddDeviceGroupRelationsRequest extends $tea.Model {
  device?: BatchAddDeviceGroupRelationsRequestDevice[];
  groupId?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      device: 'Device',
      groupId: 'GroupId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      device: { 'type': 'array', 'itemType': BatchAddDeviceGroupRelationsRequestDevice },
      groupId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchAddDeviceGroupRelationsResponseBody extends $tea.Model {
  alreadyRelatedGroupDeviceCount?: number;
  code?: string;
  errorMessage?: string;
  exceedTenGroupDeviceCount?: number;
  requestId?: string;
  success?: boolean;
  successAddedDeviceCount?: number;
  validDeviceCount?: number;
  static names(): { [key: string]: string } {
    return {
      alreadyRelatedGroupDeviceCount: 'AlreadyRelatedGroupDeviceCount',
      code: 'Code',
      errorMessage: 'ErrorMessage',
      exceedTenGroupDeviceCount: 'ExceedTenGroupDeviceCount',
      requestId: 'RequestId',
      success: 'Success',
      successAddedDeviceCount: 'SuccessAddedDeviceCount',
      validDeviceCount: 'ValidDeviceCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alreadyRelatedGroupDeviceCount: 'number',
      code: 'string',
      errorMessage: 'string',
      exceedTenGroupDeviceCount: 'number',
      requestId: 'string',
      success: 'boolean',
      successAddedDeviceCount: 'number',
      validDeviceCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchAddDeviceGroupRelationsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: BatchAddDeviceGroupRelationsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchAddDeviceGroupRelationsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchAddThingTopoRequest extends $tea.Model {
  gwDeviceName?: string;
  gwProductKey?: string;
  iotInstanceId?: string;
  topoAddItem?: BatchAddThingTopoRequestTopoAddItem[];
  static names(): { [key: string]: string } {
    return {
      gwDeviceName: 'GwDeviceName',
      gwProductKey: 'GwProductKey',
      iotInstanceId: 'IotInstanceId',
      topoAddItem: 'TopoAddItem',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gwDeviceName: 'string',
      gwProductKey: 'string',
      iotInstanceId: 'string',
      topoAddItem: { 'type': 'array', 'itemType': BatchAddThingTopoRequestTopoAddItem },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchAddThingTopoResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchAddThingTopoResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: BatchAddThingTopoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchAddThingTopoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchBindDeviceToEdgeInstanceWithDriverRequest extends $tea.Model {
  driverId?: string;
  instanceId?: string;
  iotIds?: string[];
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      driverId: 'DriverId',
      instanceId: 'InstanceId',
      iotIds: 'IotIds',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      driverId: 'string',
      instanceId: 'string',
      iotIds: { 'type': 'array', 'itemType': 'string' },
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchBindDeviceToEdgeInstanceWithDriverResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchBindDeviceToEdgeInstanceWithDriverResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: BatchBindDeviceToEdgeInstanceWithDriverResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchBindDeviceToEdgeInstanceWithDriverResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchBindDevicesIntoProjectRequest extends $tea.Model {
  devices?: BatchBindDevicesIntoProjectRequestDevices[];
  iotInstanceId?: string;
  projectId?: string;
  static names(): { [key: string]: string } {
    return {
      devices: 'Devices',
      iotInstanceId: 'IotInstanceId',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      devices: { 'type': 'array', 'itemType': BatchBindDevicesIntoProjectRequestDevices },
      iotInstanceId: 'string',
      projectId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchBindDevicesIntoProjectResponseBody extends $tea.Model {
  code?: string;
  data?: boolean;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'boolean',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchBindDevicesIntoProjectResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: BatchBindDevicesIntoProjectResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchBindDevicesIntoProjectResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchBindProductsIntoProjectRequest extends $tea.Model {
  iotInstanceId?: string;
  productKeys?: string[];
  projectId?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      productKeys: 'ProductKeys',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      productKeys: { 'type': 'array', 'itemType': 'string' },
      projectId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchBindProductsIntoProjectResponseBody extends $tea.Model {
  code?: string;
  data?: boolean;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'boolean',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchBindProductsIntoProjectResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: BatchBindProductsIntoProjectResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchBindProductsIntoProjectResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCheckDeviceNamesRequest extends $tea.Model {
  deviceName?: string[];
  deviceNameList?: BatchCheckDeviceNamesRequestDeviceNameList[];
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      deviceNameList: 'DeviceNameList',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: { 'type': 'array', 'itemType': 'string' },
      deviceNameList: { 'type': 'array', 'itemType': BatchCheckDeviceNamesRequestDeviceNameList },
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCheckDeviceNamesResponseBody extends $tea.Model {
  code?: string;
  data?: BatchCheckDeviceNamesResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: BatchCheckDeviceNamesResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCheckDeviceNamesResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: BatchCheckDeviceNamesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchCheckDeviceNamesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCheckImportDeviceRequest extends $tea.Model {
  deviceList?: BatchCheckImportDeviceRequestDeviceList[];
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceList: 'DeviceList',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceList: { 'type': 'array', 'itemType': BatchCheckImportDeviceRequestDeviceList },
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCheckImportDeviceResponseBody extends $tea.Model {
  code?: string;
  data?: BatchCheckImportDeviceResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: BatchCheckImportDeviceResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCheckImportDeviceResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: BatchCheckImportDeviceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchCheckImportDeviceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCheckVehicleDeviceRequest extends $tea.Model {
  deviceList?: BatchCheckVehicleDeviceRequestDeviceList[];
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceList: 'DeviceList',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceList: { 'type': 'array', 'itemType': BatchCheckVehicleDeviceRequestDeviceList },
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCheckVehicleDeviceResponseBody extends $tea.Model {
  code?: string;
  data?: BatchCheckVehicleDeviceResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: BatchCheckVehicleDeviceResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCheckVehicleDeviceResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: BatchCheckVehicleDeviceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchCheckVehicleDeviceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchClearEdgeInstanceDeviceConfigRequest extends $tea.Model {
  instanceId?: string;
  iotIds?: string[];
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      iotIds: 'IotIds',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      iotIds: { 'type': 'array', 'itemType': 'string' },
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchClearEdgeInstanceDeviceConfigResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchClearEdgeInstanceDeviceConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: BatchClearEdgeInstanceDeviceConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchClearEdgeInstanceDeviceConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCreateSoundCodeLabelRequest extends $tea.Model {
  description?: string;
  iotInstanceId?: string;
  scheduleCode?: string;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      iotInstanceId: 'IotInstanceId',
      scheduleCode: 'ScheduleCode',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      iotInstanceId: 'string',
      scheduleCode: 'string',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCreateSoundCodeLabelResponseBody extends $tea.Model {
  code?: string;
  data?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCreateSoundCodeLabelResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: BatchCreateSoundCodeLabelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchCreateSoundCodeLabelResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCreateSoundCodeLabelWithLabelsRequest extends $tea.Model {
  description?: string;
  iotInstanceId?: string;
  labels?: string[];
  scheduleCode?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      iotInstanceId: 'IotInstanceId',
      labels: 'Labels',
      scheduleCode: 'ScheduleCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      iotInstanceId: 'string',
      labels: { 'type': 'array', 'itemType': 'string' },
      scheduleCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCreateSoundCodeLabelWithLabelsResponseBody extends $tea.Model {
  code?: string;
  data?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCreateSoundCodeLabelWithLabelsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: BatchCreateSoundCodeLabelWithLabelsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchCreateSoundCodeLabelWithLabelsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchDeleteDeviceGroupRelationsRequest extends $tea.Model {
  device?: BatchDeleteDeviceGroupRelationsRequestDevice[];
  groupId?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      device: 'Device',
      groupId: 'GroupId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      device: { 'type': 'array', 'itemType': BatchDeleteDeviceGroupRelationsRequestDevice },
      groupId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchDeleteDeviceGroupRelationsResponseBody extends $tea.Model {
  alreadyRelatedGroupDeviceCount?: number;
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  successDeviceCount?: number;
  validDeviceCount?: number;
  static names(): { [key: string]: string } {
    return {
      alreadyRelatedGroupDeviceCount: 'AlreadyRelatedGroupDeviceCount',
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      successDeviceCount: 'SuccessDeviceCount',
      validDeviceCount: 'ValidDeviceCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alreadyRelatedGroupDeviceCount: 'number',
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      successDeviceCount: 'number',
      validDeviceCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchDeleteDeviceGroupRelationsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: BatchDeleteDeviceGroupRelationsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchDeleteDeviceGroupRelationsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchDeleteEdgeInstanceChannelRequest extends $tea.Model {
  channelIds?: string[];
  driverId?: string;
  instanceId?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      channelIds: 'ChannelIds',
      driverId: 'DriverId',
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelIds: { 'type': 'array', 'itemType': 'string' },
      driverId: 'string',
      instanceId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchDeleteEdgeInstanceChannelResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchDeleteEdgeInstanceChannelResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: BatchDeleteEdgeInstanceChannelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchDeleteEdgeInstanceChannelResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetDeviceBindStatusRequest extends $tea.Model {
  iotIds?: string[];
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      iotIds: 'IotIds',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotIds: { 'type': 'array', 'itemType': 'string' },
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetDeviceBindStatusResponseBody extends $tea.Model {
  code?: string;
  data?: BatchGetDeviceBindStatusResponseBodyData[];
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: { 'type': 'array', 'itemType': BatchGetDeviceBindStatusResponseBodyData },
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetDeviceBindStatusResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: BatchGetDeviceBindStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchGetDeviceBindStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetDeviceStateRequest extends $tea.Model {
  deviceName?: string[];
  iotId?: string[];
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: { 'type': 'array', 'itemType': 'string' },
      iotId: { 'type': 'array', 'itemType': 'string' },
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetDeviceStateResponseBody extends $tea.Model {
  code?: string;
  deviceStatusList?: BatchGetDeviceStateResponseBodyDeviceStatusList;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      deviceStatusList: 'DeviceStatusList',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      deviceStatusList: BatchGetDeviceStateResponseBodyDeviceStatusList,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetDeviceStateResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: BatchGetDeviceStateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchGetDeviceStateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeDriverRequest extends $tea.Model {
  driverIds?: string[];
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      driverIds: 'DriverIds',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      driverIds: { 'type': 'array', 'itemType': 'string' },
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeDriverResponseBody extends $tea.Model {
  code?: string;
  driverList?: BatchGetEdgeDriverResponseBodyDriverList[];
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      driverList: 'DriverList',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      driverList: { 'type': 'array', 'itemType': BatchGetEdgeDriverResponseBodyDriverList },
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeDriverResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: BatchGetEdgeDriverResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchGetEdgeDriverResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeInstanceChannelRequest extends $tea.Model {
  channelIds?: string[];
  driverId?: string;
  instanceId?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      channelIds: 'ChannelIds',
      driverId: 'DriverId',
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelIds: { 'type': 'array', 'itemType': 'string' },
      driverId: 'string',
      instanceId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeInstanceChannelResponseBody extends $tea.Model {
  code?: string;
  data?: BatchGetEdgeInstanceChannelResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: BatchGetEdgeInstanceChannelResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeInstanceChannelResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: BatchGetEdgeInstanceChannelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchGetEdgeInstanceChannelResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeInstanceDeviceChannelRequest extends $tea.Model {
  driverId?: string;
  instanceId?: string;
  iotIds?: string[];
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      driverId: 'DriverId',
      instanceId: 'InstanceId',
      iotIds: 'IotIds',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      driverId: 'string',
      instanceId: 'string',
      iotIds: { 'type': 'array', 'itemType': 'string' },
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeInstanceDeviceChannelResponseBody extends $tea.Model {
  code?: string;
  deviceChannelList?: BatchGetEdgeInstanceDeviceChannelResponseBodyDeviceChannelList[];
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      deviceChannelList: 'DeviceChannelList',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      deviceChannelList: { 'type': 'array', 'itemType': BatchGetEdgeInstanceDeviceChannelResponseBodyDeviceChannelList },
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeInstanceDeviceChannelResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: BatchGetEdgeInstanceDeviceChannelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchGetEdgeInstanceDeviceChannelResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeInstanceDeviceConfigRequest extends $tea.Model {
  instanceId?: string;
  iotIds?: string[];
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      iotIds: 'IotIds',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      iotIds: { 'type': 'array', 'itemType': 'string' },
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeInstanceDeviceConfigResponseBody extends $tea.Model {
  code?: string;
  deviceConfigList?: BatchGetEdgeInstanceDeviceConfigResponseBodyDeviceConfigList[];
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      deviceConfigList: 'DeviceConfigList',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      deviceConfigList: { 'type': 'array', 'itemType': BatchGetEdgeInstanceDeviceConfigResponseBodyDeviceConfigList },
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeInstanceDeviceConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: BatchGetEdgeInstanceDeviceConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchGetEdgeInstanceDeviceConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeInstanceDeviceDriverRequest extends $tea.Model {
  instanceId?: string;
  iotIds?: string[];
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      iotIds: 'IotIds',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      iotIds: { 'type': 'array', 'itemType': 'string' },
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeInstanceDeviceDriverResponseBody extends $tea.Model {
  code?: string;
  deviceDriverList?: BatchGetEdgeInstanceDeviceDriverResponseBodyDeviceDriverList[];
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      deviceDriverList: 'DeviceDriverList',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      deviceDriverList: { 'type': 'array', 'itemType': BatchGetEdgeInstanceDeviceDriverResponseBodyDeviceDriverList },
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeInstanceDeviceDriverResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: BatchGetEdgeInstanceDeviceDriverResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchGetEdgeInstanceDeviceDriverResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeInstanceDriverConfigsRequest extends $tea.Model {
  driverIds?: string[];
  instanceId?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      driverIds: 'DriverIds',
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      driverIds: { 'type': 'array', 'itemType': 'string' },
      instanceId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeInstanceDriverConfigsResponseBody extends $tea.Model {
  code?: string;
  driverConfigList?: BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigList[];
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      driverConfigList: 'DriverConfigList',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      driverConfigList: { 'type': 'array', 'itemType': BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigList },
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeInstanceDriverConfigsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: BatchGetEdgeInstanceDriverConfigsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchGetEdgeInstanceDriverConfigsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGrayMigrationDeviceRequest extends $tea.Model {
  deviceNames?: string[];
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceNames: 'DeviceNames',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceNames: { 'type': 'array', 'itemType': 'string' },
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGrayMigrationDeviceResponseBody extends $tea.Model {
  code?: string;
  data?: BatchGrayMigrationDeviceResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: BatchGrayMigrationDeviceResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGrayMigrationDeviceResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: BatchGrayMigrationDeviceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchGrayMigrationDeviceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchImportDeviceRequest extends $tea.Model {
  deviceList?: BatchImportDeviceRequestDeviceList[];
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceList: 'DeviceList',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceList: { 'type': 'array', 'itemType': BatchImportDeviceRequestDeviceList },
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchImportDeviceResponseBody extends $tea.Model {
  code?: string;
  data?: BatchImportDeviceResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: BatchImportDeviceResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchImportDeviceResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: BatchImportDeviceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchImportDeviceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchImportVehicleDeviceRequest extends $tea.Model {
  deviceList?: BatchImportVehicleDeviceRequestDeviceList[];
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceList: 'DeviceList',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceList: { 'type': 'array', 'itemType': BatchImportVehicleDeviceRequestDeviceList },
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchImportVehicleDeviceResponseBody extends $tea.Model {
  code?: string;
  data?: BatchImportVehicleDeviceResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: BatchImportVehicleDeviceResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchImportVehicleDeviceResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: BatchImportVehicleDeviceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchImportVehicleDeviceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchPubRequest extends $tea.Model {
  deviceName?: string[];
  iotInstanceId?: string;
  messageContent?: string;
  productKey?: string;
  qos?: number;
  topicShortName?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotInstanceId: 'IotInstanceId',
      messageContent: 'MessageContent',
      productKey: 'ProductKey',
      qos: 'Qos',
      topicShortName: 'TopicShortName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: { 'type': 'array', 'itemType': 'string' },
      iotInstanceId: 'string',
      messageContent: 'string',
      productKey: 'string',
      qos: 'number',
      topicShortName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchPubResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchPubResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: BatchPubResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchPubResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchQueryDeviceDetailRequest extends $tea.Model {
  deviceName?: string[];
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: { 'type': 'array', 'itemType': 'string' },
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchQueryDeviceDetailResponseBody extends $tea.Model {
  code?: string;
  data?: BatchQueryDeviceDetailResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: BatchQueryDeviceDetailResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchQueryDeviceDetailResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: BatchQueryDeviceDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchQueryDeviceDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchRegisterDeviceRequest extends $tea.Model {
  count?: number;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchRegisterDeviceResponseBody extends $tea.Model {
  code?: string;
  data?: BatchRegisterDeviceResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: BatchRegisterDeviceResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchRegisterDeviceResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: BatchRegisterDeviceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchRegisterDeviceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchRegisterDeviceWithApplyIdRequest extends $tea.Model {
  applyId?: number;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      applyId: 'ApplyId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applyId: 'number',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchRegisterDeviceWithApplyIdResponseBody extends $tea.Model {
  code?: string;
  data?: BatchRegisterDeviceWithApplyIdResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: BatchRegisterDeviceWithApplyIdResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchRegisterDeviceWithApplyIdResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: BatchRegisterDeviceWithApplyIdResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchRegisterDeviceWithApplyIdResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchSetEdgeInstanceDeviceChannelRequest extends $tea.Model {
  channelId?: string;
  driverId?: string;
  instanceId?: string;
  iotIds?: string[];
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      channelId: 'ChannelId',
      driverId: 'DriverId',
      instanceId: 'InstanceId',
      iotIds: 'IotIds',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelId: 'string',
      driverId: 'string',
      instanceId: 'string',
      iotIds: { 'type': 'array', 'itemType': 'string' },
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchSetEdgeInstanceDeviceChannelResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchSetEdgeInstanceDeviceChannelResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: BatchSetEdgeInstanceDeviceChannelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchSetEdgeInstanceDeviceChannelResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchSetEdgeInstanceDeviceConfigRequest extends $tea.Model {
  deviceConfigs?: BatchSetEdgeInstanceDeviceConfigRequestDeviceConfigs[];
  instanceId?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      deviceConfigs: 'DeviceConfigs',
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceConfigs: { 'type': 'array', 'itemType': BatchSetEdgeInstanceDeviceConfigRequestDeviceConfigs },
      instanceId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchSetEdgeInstanceDeviceConfigResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchSetEdgeInstanceDeviceConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: BatchSetEdgeInstanceDeviceConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchSetEdgeInstanceDeviceConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchUnbindDeviceFromEdgeInstanceRequest extends $tea.Model {
  instanceId?: string;
  iotIds?: string[];
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      iotIds: 'IotIds',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      iotIds: { 'type': 'array', 'itemType': 'string' },
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchUnbindDeviceFromEdgeInstanceResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchUnbindDeviceFromEdgeInstanceResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: BatchUnbindDeviceFromEdgeInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchUnbindDeviceFromEdgeInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchUnbindProjectDevicesRequest extends $tea.Model {
  devices?: BatchUnbindProjectDevicesRequestDevices[];
  iotInstanceId?: string;
  projectId?: string;
  static names(): { [key: string]: string } {
    return {
      devices: 'Devices',
      iotInstanceId: 'IotInstanceId',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      devices: { 'type': 'array', 'itemType': BatchUnbindProjectDevicesRequestDevices },
      iotInstanceId: 'string',
      projectId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchUnbindProjectDevicesResponseBody extends $tea.Model {
  code?: string;
  data?: boolean;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'boolean',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchUnbindProjectDevicesResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: BatchUnbindProjectDevicesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchUnbindProjectDevicesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchUnbindProjectProductsRequest extends $tea.Model {
  iotInstanceId?: string;
  productKeys?: string[];
  projectId?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      productKeys: 'ProductKeys',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      productKeys: { 'type': 'array', 'itemType': 'string' },
      projectId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchUnbindProjectProductsResponseBody extends $tea.Model {
  code?: string;
  data?: boolean;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'boolean',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchUnbindProjectProductsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: BatchUnbindProjectProductsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchUnbindProjectProductsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchUpdateDeviceNicknameRequest extends $tea.Model {
  deviceNicknameInfo?: BatchUpdateDeviceNicknameRequestDeviceNicknameInfo[];
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      deviceNicknameInfo: 'DeviceNicknameInfo',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceNicknameInfo: { 'type': 'array', 'itemType': BatchUpdateDeviceNicknameRequestDeviceNicknameInfo },
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchUpdateDeviceNicknameResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchUpdateDeviceNicknameResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: BatchUpdateDeviceNicknameResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchUpdateDeviceNicknameResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BindApplicationToEdgeInstanceRequest extends $tea.Model {
  applicationId?: string;
  applicationVersion?: string;
  instanceId?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      applicationId: 'ApplicationId',
      applicationVersion: 'ApplicationVersion',
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applicationId: 'string',
      applicationVersion: 'string',
      instanceId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BindApplicationToEdgeInstanceResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BindApplicationToEdgeInstanceResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: BindApplicationToEdgeInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BindApplicationToEdgeInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BindDriverToEdgeInstanceRequest extends $tea.Model {
  driverId?: string;
  driverVersion?: string;
  instanceId?: string;
  iotInstanceId?: string;
  orderId?: string;
  static names(): { [key: string]: string } {
    return {
      driverId: 'DriverId',
      driverVersion: 'DriverVersion',
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
      orderId: 'OrderId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      driverId: 'string',
      driverVersion: 'string',
      instanceId: 'string',
      iotInstanceId: 'string',
      orderId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BindDriverToEdgeInstanceResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BindDriverToEdgeInstanceResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: BindDriverToEdgeInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BindDriverToEdgeInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BindGatewayToEdgeInstanceRequest extends $tea.Model {
  deviceName?: string;
  instanceId?: string;
  iotId?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      instanceId: 'InstanceId',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      instanceId: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BindGatewayToEdgeInstanceResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BindGatewayToEdgeInstanceResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: BindGatewayToEdgeInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BindGatewayToEdgeInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BindLicenseDeviceRequest extends $tea.Model {
  deviceNameList?: string[];
  iotIdList?: string[];
  iotInstanceId?: string;
  licenseCode?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceNameList: 'DeviceNameList',
      iotIdList: 'IotIdList',
      iotInstanceId: 'IotInstanceId',
      licenseCode: 'LicenseCode',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceNameList: { 'type': 'array', 'itemType': 'string' },
      iotIdList: { 'type': 'array', 'itemType': 'string' },
      iotInstanceId: 'string',
      licenseCode: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BindLicenseDeviceResponseBody extends $tea.Model {
  code?: string;
  data?: BindLicenseDeviceResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: BindLicenseDeviceResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BindLicenseDeviceResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: BindLicenseDeviceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BindLicenseDeviceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BindLicenseProductRequest extends $tea.Model {
  iotInstanceId?: string;
  licenseCode?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      licenseCode: 'LicenseCode',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      licenseCode: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BindLicenseProductResponseBody extends $tea.Model {
  code?: string;
  data?: boolean;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'boolean',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BindLicenseProductResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: BindLicenseProductResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BindLicenseProductResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BindRoleToEdgeInstanceRequest extends $tea.Model {
  instanceId?: string;
  iotInstanceId?: string;
  roleArn?: string;
  roleName?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
      roleArn: 'RoleArn',
      roleName: 'RoleName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      iotInstanceId: 'string',
      roleArn: 'string',
      roleName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BindRoleToEdgeInstanceResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BindRoleToEdgeInstanceResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: BindRoleToEdgeInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BindRoleToEdgeInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BindSceneRuleToEdgeInstanceRequest extends $tea.Model {
  instanceId?: string;
  iotInstanceId?: string;
  ruleId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
      ruleId: 'RuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      iotInstanceId: 'string',
      ruleId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BindSceneRuleToEdgeInstanceResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BindSceneRuleToEdgeInstanceResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: BindSceneRuleToEdgeInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BindSceneRuleToEdgeInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelJobRequest extends $tea.Model {
  iotInstanceId?: string;
  jobId?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      jobId: 'JobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      jobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelJobResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CancelJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CancelJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelOTAStrategyByJobRequest extends $tea.Model {
  iotInstanceId?: string;
  jobId?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      jobId: 'JobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      jobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelOTAStrategyByJobResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelOTAStrategyByJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CancelOTAStrategyByJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CancelOTAStrategyByJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelOTATaskByDeviceRequest extends $tea.Model {
  deviceName?: string[];
  firmwareId?: string;
  iotInstanceId?: string;
  jobId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      firmwareId: 'FirmwareId',
      iotInstanceId: 'IotInstanceId',
      jobId: 'JobId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: { 'type': 'array', 'itemType': 'string' },
      firmwareId: 'string',
      iotInstanceId: 'string',
      jobId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelOTATaskByDeviceResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelOTATaskByDeviceResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CancelOTATaskByDeviceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CancelOTATaskByDeviceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelOTATaskByJobRequest extends $tea.Model {
  cancelInProgressTask?: boolean;
  cancelNotifiedTask?: boolean;
  cancelQueuedTask?: boolean;
  cancelScheduledTask?: boolean;
  cancelUnconfirmedTask?: boolean;
  iotInstanceId?: string;
  jobId?: string;
  static names(): { [key: string]: string } {
    return {
      cancelInProgressTask: 'CancelInProgressTask',
      cancelNotifiedTask: 'CancelNotifiedTask',
      cancelQueuedTask: 'CancelQueuedTask',
      cancelScheduledTask: 'CancelScheduledTask',
      cancelUnconfirmedTask: 'CancelUnconfirmedTask',
      iotInstanceId: 'IotInstanceId',
      jobId: 'JobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cancelInProgressTask: 'boolean',
      cancelNotifiedTask: 'boolean',
      cancelQueuedTask: 'boolean',
      cancelScheduledTask: 'boolean',
      cancelUnconfirmedTask: 'boolean',
      iotInstanceId: 'string',
      jobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelOTATaskByJobResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelOTATaskByJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CancelOTATaskByJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CancelOTATaskByJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelReleaseProductRequest extends $tea.Model {
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelReleaseProductResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelReleaseProductResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CancelReleaseProductResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CancelReleaseProductResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CheckBindLicenseDeviceProgressRequest extends $tea.Model {
  checkProgressId?: string;
  iotInstanceId?: string;
  licenseCode?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      checkProgressId: 'CheckProgressId',
      iotInstanceId: 'IotInstanceId',
      licenseCode: 'LicenseCode',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkProgressId: 'string',
      iotInstanceId: 'string',
      licenseCode: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CheckBindLicenseDeviceProgressResponseBody extends $tea.Model {
  code?: string;
  data?: CheckBindLicenseDeviceProgressResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: CheckBindLicenseDeviceProgressResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CheckBindLicenseDeviceProgressResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CheckBindLicenseDeviceProgressResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CheckBindLicenseDeviceProgressResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ClearDeviceDesiredPropertyRequest extends $tea.Model {
  deviceName?: string;
  identifies?: string[];
  iotId?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      identifies: 'Identifies',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      identifies: { 'type': 'array', 'itemType': 'string' },
      iotId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ClearDeviceDesiredPropertyResponseBody extends $tea.Model {
  code?: string;
  data?: ClearDeviceDesiredPropertyResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: ClearDeviceDesiredPropertyResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ClearDeviceDesiredPropertyResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ClearDeviceDesiredPropertyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ClearDeviceDesiredPropertyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ClearEdgeInstanceDriverConfigsRequest extends $tea.Model {
  driverId?: string;
  instanceId?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      driverId: 'DriverId',
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      driverId: 'string',
      instanceId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ClearEdgeInstanceDriverConfigsResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ClearEdgeInstanceDriverConfigsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ClearEdgeInstanceDriverConfigsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ClearEdgeInstanceDriverConfigsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CloseDeviceTunnelRequest extends $tea.Model {
  iotInstanceId?: string;
  tunnelId?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      tunnelId: 'TunnelId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      tunnelId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CloseDeviceTunnelResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CloseDeviceTunnelResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CloseDeviceTunnelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CloseDeviceTunnelResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CloseEdgeInstanceDeploymentRequest extends $tea.Model {
  instanceId?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CloseEdgeInstanceDeploymentResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CloseEdgeInstanceDeploymentResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CloseEdgeInstanceDeploymentResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CloseEdgeInstanceDeploymentResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ConfirmOTATaskRequest extends $tea.Model {
  iotInstanceId?: string;
  taskId?: string[];
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      taskId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ConfirmOTATaskResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ConfirmOTATaskResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ConfirmOTATaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ConfirmOTATaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CopyThingModelRequest extends $tea.Model {
  iotInstanceId?: string;
  resourceGroupId?: string;
  sourceModelVersion?: string;
  sourceProductKey?: string;
  targetProductKey?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      resourceGroupId: 'ResourceGroupId',
      sourceModelVersion: 'SourceModelVersion',
      sourceProductKey: 'SourceProductKey',
      targetProductKey: 'TargetProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      resourceGroupId: 'string',
      sourceModelVersion: 'string',
      sourceProductKey: 'string',
      targetProductKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CopyThingModelResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CopyThingModelResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CopyThingModelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CopyThingModelResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CountSpeechBroadcastHourRequest extends $tea.Model {
  iotInstanceId?: string;
  queryDateTimeHour?: string;
  shareTaskCode?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      queryDateTimeHour: 'QueryDateTimeHour',
      shareTaskCode: 'ShareTaskCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      queryDateTimeHour: 'string',
      shareTaskCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CountSpeechBroadcastHourResponseBody extends $tea.Model {
  code?: string;
  data?: number;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'number',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CountSpeechBroadcastHourResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CountSpeechBroadcastHourResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CountSpeechBroadcastHourResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateConsumerGroupRequest extends $tea.Model {
  groupName?: string;
  iotInstanceId?: string;
  subBizCode?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      groupName: 'GroupName',
      iotInstanceId: 'IotInstanceId',
      subBizCode: 'SubBizCode',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupName: 'string',
      iotInstanceId: 'string',
      subBizCode: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateConsumerGroupResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  groupId?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      groupId: 'GroupId',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      groupId: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateConsumerGroupResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateConsumerGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateConsumerGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateConsumerGroupSubscribeRelationRequest extends $tea.Model {
  consumerGroupId?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      consumerGroupId: 'ConsumerGroupId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consumerGroupId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateConsumerGroupSubscribeRelationResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateConsumerGroupSubscribeRelationResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateConsumerGroupSubscribeRelationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateConsumerGroupSubscribeRelationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataAPIServiceRequest extends $tea.Model {
  apiPath?: string;
  desc?: string;
  displayName?: string;
  iotInstanceId?: string;
  originSql?: string;
  requestParam?: CreateDataAPIServiceRequestRequestParam[];
  responseParam?: CreateDataAPIServiceRequestResponseParam[];
  templateSql?: string;
  static names(): { [key: string]: string } {
    return {
      apiPath: 'ApiPath',
      desc: 'Desc',
      displayName: 'DisplayName',
      iotInstanceId: 'IotInstanceId',
      originSql: 'OriginSql',
      requestParam: 'RequestParam',
      responseParam: 'ResponseParam',
      templateSql: 'TemplateSql',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiPath: 'string',
      desc: 'string',
      displayName: 'string',
      iotInstanceId: 'string',
      originSql: 'string',
      requestParam: { 'type': 'array', 'itemType': CreateDataAPIServiceRequestRequestParam },
      responseParam: { 'type': 'array', 'itemType': CreateDataAPIServiceRequestResponseParam },
      templateSql: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataAPIServiceResponseBody extends $tea.Model {
  code?: string;
  data?: CreateDataAPIServiceResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: CreateDataAPIServiceResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataAPIServiceResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateDataAPIServiceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateDataAPIServiceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataSourceItemRequest extends $tea.Model {
  dataSourceId?: number;
  deviceName?: string;
  iotInstanceId?: string;
  productKey?: string;
  scopeType?: string;
  topic?: string;
  static names(): { [key: string]: string } {
    return {
      dataSourceId: 'DataSourceId',
      deviceName: 'DeviceName',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
      scopeType: 'ScopeType',
      topic: 'Topic',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataSourceId: 'number',
      deviceName: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
      scopeType: 'string',
      topic: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataSourceItemResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataSourceItemResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateDataSourceItemResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateDataSourceItemResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDestinationRequest extends $tea.Model {
  configuration?: string;
  description?: string;
  iotInstanceId?: string;
  name?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      configuration: 'Configuration',
      description: 'Description',
      iotInstanceId: 'IotInstanceId',
      name: 'Name',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configuration: 'string',
      description: 'string',
      iotInstanceId: 'string',
      name: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDestinationResponseBody extends $tea.Model {
  code?: string;
  destination?: CreateDestinationResponseBodyDestination;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      destination: 'Destination',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      destination: CreateDestinationResponseBodyDestination,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDestinationResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateDestinationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateDestinationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDeviceDistributeJobRequest extends $tea.Model {
  deviceName?: string[];
  productKey?: string;
  sourceInstanceId?: string;
  strategy?: number;
  targetAliyunId?: string;
  targetInstanceConfig?: CreateDeviceDistributeJobRequestTargetInstanceConfig[];
  targetUid?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      productKey: 'ProductKey',
      sourceInstanceId: 'SourceInstanceId',
      strategy: 'Strategy',
      targetAliyunId: 'TargetAliyunId',
      targetInstanceConfig: 'TargetInstanceConfig',
      targetUid: 'TargetUid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: { 'type': 'array', 'itemType': 'string' },
      productKey: 'string',
      sourceInstanceId: 'string',
      strategy: 'number',
      targetAliyunId: 'string',
      targetInstanceConfig: { 'type': 'array', 'itemType': CreateDeviceDistributeJobRequestTargetInstanceConfig },
      targetUid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDeviceDistributeJobResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  jobId?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      jobId: 'JobId',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      jobId: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDeviceDistributeJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateDeviceDistributeJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateDeviceDistributeJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDeviceDynamicGroupRequest extends $tea.Model {
  dynamicGroupExpression?: string;
  groupDesc?: string;
  groupName?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      dynamicGroupExpression: 'DynamicGroupExpression',
      groupDesc: 'GroupDesc',
      groupName: 'GroupName',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dynamicGroupExpression: 'string',
      groupDesc: 'string',
      groupName: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDeviceDynamicGroupResponseBody extends $tea.Model {
  code?: string;
  data?: CreateDeviceDynamicGroupResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: CreateDeviceDynamicGroupResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDeviceDynamicGroupResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateDeviceDynamicGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateDeviceDynamicGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDeviceGroupRequest extends $tea.Model {
  groupDesc?: string;
  groupName?: string;
  iotInstanceId?: string;
  superGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      groupDesc: 'GroupDesc',
      groupName: 'GroupName',
      iotInstanceId: 'IotInstanceId',
      superGroupId: 'SuperGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupDesc: 'string',
      groupName: 'string',
      iotInstanceId: 'string',
      superGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDeviceGroupResponseBody extends $tea.Model {
  code?: string;
  data?: CreateDeviceGroupResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: CreateDeviceGroupResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDeviceGroupResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateDeviceGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateDeviceGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDeviceTunnelRequest extends $tea.Model {
  description?: string;
  deviceName?: string;
  iotId?: string;
  iotInstanceId?: string;
  productKey?: string;
  udi?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      deviceName: 'DeviceName',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
      udi: 'Udi',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      deviceName: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
      udi: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDeviceTunnelResponseBody extends $tea.Model {
  code?: string;
  data?: CreateDeviceTunnelResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: CreateDeviceTunnelResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDeviceTunnelResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateDeviceTunnelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateDeviceTunnelResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDownloadDataJobRequest extends $tea.Model {
  downloadDataType?: string;
  endTime?: number;
  fileConfig?: { [key: string]: any };
  iotInstanceId?: string;
  startTime?: number;
  tableName?: string;
  static names(): { [key: string]: string } {
    return {
      downloadDataType: 'DownloadDataType',
      endTime: 'EndTime',
      fileConfig: 'FileConfig',
      iotInstanceId: 'IotInstanceId',
      startTime: 'StartTime',
      tableName: 'TableName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      downloadDataType: 'string',
      endTime: 'number',
      fileConfig: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      iotInstanceId: 'string',
      startTime: 'number',
      tableName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDownloadDataJobShrinkRequest extends $tea.Model {
  downloadDataType?: string;
  endTime?: number;
  fileConfigShrink?: string;
  iotInstanceId?: string;
  startTime?: number;
  tableName?: string;
  static names(): { [key: string]: string } {
    return {
      downloadDataType: 'DownloadDataType',
      endTime: 'EndTime',
      fileConfigShrink: 'FileConfig',
      iotInstanceId: 'IotInstanceId',
      startTime: 'StartTime',
      tableName: 'TableName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      downloadDataType: 'string',
      endTime: 'number',
      fileConfigShrink: 'string',
      iotInstanceId: 'string',
      startTime: 'number',
      tableName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDownloadDataJobResponseBody extends $tea.Model {
  code?: string;
  data?: CreateDownloadDataJobResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: CreateDownloadDataJobResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDownloadDataJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateDownloadDataJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateDownloadDataJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeDriverRequest extends $tea.Model {
  cpuArch?: string;
  driverName?: string;
  driverProtocol?: string;
  iotInstanceId?: string;
  isBuiltIn?: boolean;
  runtime?: string;
  static names(): { [key: string]: string } {
    return {
      cpuArch: 'CpuArch',
      driverName: 'DriverName',
      driverProtocol: 'DriverProtocol',
      iotInstanceId: 'IotInstanceId',
      isBuiltIn: 'IsBuiltIn',
      runtime: 'Runtime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cpuArch: 'string',
      driverName: 'string',
      driverProtocol: 'string',
      iotInstanceId: 'string',
      isBuiltIn: 'boolean',
      runtime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeDriverResponseBody extends $tea.Model {
  code?: string;
  driverId?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      driverId: 'DriverId',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      driverId: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeDriverResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateEdgeDriverResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateEdgeDriverResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeDriverVersionRequest extends $tea.Model {
  argument?: string;
  configCheckRule?: string;
  containerConfig?: string;
  description?: string;
  driverConfig?: string;
  driverId?: string;
  driverVersion?: string;
  edgeVersion?: string;
  iotInstanceId?: string;
  sourceConfig?: string;
  static names(): { [key: string]: string } {
    return {
      argument: 'Argument',
      configCheckRule: 'ConfigCheckRule',
      containerConfig: 'ContainerConfig',
      description: 'Description',
      driverConfig: 'DriverConfig',
      driverId: 'DriverId',
      driverVersion: 'DriverVersion',
      edgeVersion: 'EdgeVersion',
      iotInstanceId: 'IotInstanceId',
      sourceConfig: 'SourceConfig',
    };
  }

  static types(): { [key: string]: any } {
    return {
      argument: 'string',
      configCheckRule: 'string',
      containerConfig: 'string',
      description: 'string',
      driverConfig: 'string',
      driverId: 'string',
      driverVersion: 'string',
      edgeVersion: 'string',
      iotInstanceId: 'string',
      sourceConfig: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeDriverVersionResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeDriverVersionResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateEdgeDriverVersionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateEdgeDriverVersionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeInstanceRequest extends $tea.Model {
  iotInstanceId?: string;
  name?: string;
  spec?: number;
  tags?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      name: 'Name',
      spec: 'Spec',
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      name: 'string',
      spec: 'number',
      tags: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeInstanceResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  instanceId?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      instanceId: 'InstanceId',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      instanceId: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeInstanceResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateEdgeInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateEdgeInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeInstanceChannelRequest extends $tea.Model {
  channelName?: string;
  configs?: CreateEdgeInstanceChannelRequestConfigs[];
  driverId?: string;
  instanceId?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      channelName: 'ChannelName',
      configs: 'Configs',
      driverId: 'DriverId',
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelName: 'string',
      configs: { 'type': 'array', 'itemType': CreateEdgeInstanceChannelRequestConfigs },
      driverId: 'string',
      instanceId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeInstanceChannelResponseBody extends $tea.Model {
  code?: string;
  data?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeInstanceChannelResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateEdgeInstanceChannelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateEdgeInstanceChannelResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeInstanceDeploymentRequest extends $tea.Model {
  instanceId?: string;
  iotInstanceId?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      iotInstanceId: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeInstanceDeploymentResponseBody extends $tea.Model {
  code?: string;
  deploymentId?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      deploymentId: 'DeploymentId',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      deploymentId: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeInstanceDeploymentResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateEdgeInstanceDeploymentResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateEdgeInstanceDeploymentResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeInstanceMessageRoutingRequest extends $tea.Model {
  instanceId?: string;
  iotInstanceId?: string;
  name?: string;
  sourceData?: string;
  sourceType?: string;
  targetData?: string;
  targetIotHubQos?: number;
  targetType?: string;
  topicFilter?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
      name: 'Name',
      sourceData: 'SourceData',
      sourceType: 'SourceType',
      targetData: 'TargetData',
      targetIotHubQos: 'TargetIotHubQos',
      targetType: 'TargetType',
      topicFilter: 'TopicFilter',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      iotInstanceId: 'string',
      name: 'string',
      sourceData: 'string',
      sourceType: 'string',
      targetData: 'string',
      targetIotHubQos: 'number',
      targetType: 'string',
      topicFilter: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeInstanceMessageRoutingResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  routeId?: number;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      routeId: 'RouteId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      routeId: 'number',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeInstanceMessageRoutingResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateEdgeInstanceMessageRoutingResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateEdgeInstanceMessageRoutingResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeOssPreSignedAddressRequest extends $tea.Model {
  fileName?: string;
  instanceId?: string;
  iotInstanceId?: string;
  resourceId?: string;
  resourceVersion?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      fileName: 'FileName',
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
      resourceId: 'ResourceId',
      resourceVersion: 'ResourceVersion',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fileName: 'string',
      instanceId: 'string',
      iotInstanceId: 'string',
      resourceId: 'string',
      resourceVersion: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeOssPreSignedAddressResponseBody extends $tea.Model {
  code?: string;
  data?: CreateEdgeOssPreSignedAddressResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: CreateEdgeOssPreSignedAddressResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeOssPreSignedAddressResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateEdgeOssPreSignedAddressResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateEdgeOssPreSignedAddressResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateJobRequest extends $tea.Model {
  description?: string;
  iotInstanceId?: string;
  jobDocument?: string;
  jobFile?: { [key: string]: any };
  jobName?: string;
  rolloutConfig?: { [key: string]: any };
  scheduledTime?: number;
  targetConfig?: { [key: string]: any };
  timeoutConfig?: { [key: string]: any };
  type?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      iotInstanceId: 'IotInstanceId',
      jobDocument: 'JobDocument',
      jobFile: 'JobFile',
      jobName: 'JobName',
      rolloutConfig: 'RolloutConfig',
      scheduledTime: 'ScheduledTime',
      targetConfig: 'TargetConfig',
      timeoutConfig: 'TimeoutConfig',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      iotInstanceId: 'string',
      jobDocument: 'string',
      jobFile: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      jobName: 'string',
      rolloutConfig: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      scheduledTime: 'number',
      targetConfig: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      timeoutConfig: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateJobShrinkRequest extends $tea.Model {
  description?: string;
  iotInstanceId?: string;
  jobDocument?: string;
  jobFileShrink?: string;
  jobName?: string;
  rolloutConfigShrink?: string;
  scheduledTime?: number;
  targetConfigShrink?: string;
  timeoutConfigShrink?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      iotInstanceId: 'IotInstanceId',
      jobDocument: 'JobDocument',
      jobFileShrink: 'JobFile',
      jobName: 'JobName',
      rolloutConfigShrink: 'RolloutConfig',
      scheduledTime: 'ScheduledTime',
      targetConfigShrink: 'TargetConfig',
      timeoutConfigShrink: 'TimeoutConfig',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      iotInstanceId: 'string',
      jobDocument: 'string',
      jobFileShrink: 'string',
      jobName: 'string',
      rolloutConfigShrink: 'string',
      scheduledTime: 'number',
      targetConfigShrink: 'string',
      timeoutConfigShrink: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateJobResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  jobId?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      jobId: 'JobId',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      jobId: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLoRaNodesTaskRequest extends $tea.Model {
  deviceInfo?: CreateLoRaNodesTaskRequestDeviceInfo[];
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceInfo: 'DeviceInfo',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceInfo: { 'type': 'array', 'itemType': CreateLoRaNodesTaskRequestDeviceInfo },
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLoRaNodesTaskResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  taskId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      taskId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLoRaNodesTaskResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateLoRaNodesTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateLoRaNodesTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOTADynamicUpgradeJobRequest extends $tea.Model {
  downloadProtocol?: string;
  dynamicMode?: number;
  firmwareId?: string;
  groupId?: string;
  groupType?: string;
  iotInstanceId?: string;
  maximumPerMinute?: number;
  multiModuleMode?: boolean;
  needConfirm?: boolean;
  needPush?: boolean;
  overwriteMode?: number;
  productKey?: string;
  retryCount?: number;
  retryInterval?: number;
  srcVersion?: string[];
  tag?: CreateOTADynamicUpgradeJobRequestTag[];
  timeoutInMinutes?: number;
  static names(): { [key: string]: string } {
    return {
      downloadProtocol: 'DownloadProtocol',
      dynamicMode: 'DynamicMode',
      firmwareId: 'FirmwareId',
      groupId: 'GroupId',
      groupType: 'GroupType',
      iotInstanceId: 'IotInstanceId',
      maximumPerMinute: 'MaximumPerMinute',
      multiModuleMode: 'MultiModuleMode',
      needConfirm: 'NeedConfirm',
      needPush: 'NeedPush',
      overwriteMode: 'OverwriteMode',
      productKey: 'ProductKey',
      retryCount: 'RetryCount',
      retryInterval: 'RetryInterval',
      srcVersion: 'SrcVersion',
      tag: 'Tag',
      timeoutInMinutes: 'TimeoutInMinutes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      downloadProtocol: 'string',
      dynamicMode: 'number',
      firmwareId: 'string',
      groupId: 'string',
      groupType: 'string',
      iotInstanceId: 'string',
      maximumPerMinute: 'number',
      multiModuleMode: 'boolean',
      needConfirm: 'boolean',
      needPush: 'boolean',
      overwriteMode: 'number',
      productKey: 'string',
      retryCount: 'number',
      retryInterval: 'number',
      srcVersion: { 'type': 'array', 'itemType': 'string' },
      tag: { 'type': 'array', 'itemType': CreateOTADynamicUpgradeJobRequestTag },
      timeoutInMinutes: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOTADynamicUpgradeJobResponseBody extends $tea.Model {
  code?: string;
  data?: CreateOTADynamicUpgradeJobResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: CreateOTADynamicUpgradeJobResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOTADynamicUpgradeJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateOTADynamicUpgradeJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateOTADynamicUpgradeJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOTAFirmwareRequest extends $tea.Model {
  destVersion?: string;
  firmwareDesc?: string;
  firmwareName?: string;
  firmwareSign?: string;
  firmwareSize?: number;
  firmwareUrl?: string;
  iotInstanceId?: string;
  moduleName?: string;
  multiFiles?: CreateOTAFirmwareRequestMultiFiles[];
  needToVerify?: boolean;
  productKey?: string;
  signMethod?: string;
  srcVersion?: string;
  type?: number;
  udi?: string;
  static names(): { [key: string]: string } {
    return {
      destVersion: 'DestVersion',
      firmwareDesc: 'FirmwareDesc',
      firmwareName: 'FirmwareName',
      firmwareSign: 'FirmwareSign',
      firmwareSize: 'FirmwareSize',
      firmwareUrl: 'FirmwareUrl',
      iotInstanceId: 'IotInstanceId',
      moduleName: 'ModuleName',
      multiFiles: 'MultiFiles',
      needToVerify: 'NeedToVerify',
      productKey: 'ProductKey',
      signMethod: 'SignMethod',
      srcVersion: 'SrcVersion',
      type: 'Type',
      udi: 'Udi',
    };
  }

  static types(): { [key: string]: any } {
    return {
      destVersion: 'string',
      firmwareDesc: 'string',
      firmwareName: 'string',
      firmwareSign: 'string',
      firmwareSize: 'number',
      firmwareUrl: 'string',
      iotInstanceId: 'string',
      moduleName: 'string',
      multiFiles: { 'type': 'array', 'itemType': CreateOTAFirmwareRequestMultiFiles },
      needToVerify: 'boolean',
      productKey: 'string',
      signMethod: 'string',
      srcVersion: 'string',
      type: 'number',
      udi: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOTAFirmwareResponseBody extends $tea.Model {
  code?: string;
  data?: CreateOTAFirmwareResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: CreateOTAFirmwareResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOTAFirmwareResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateOTAFirmwareResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateOTAFirmwareResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOTAModuleRequest extends $tea.Model {
  aliasName?: string;
  desc?: string;
  iotInstanceId?: string;
  moduleName?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      aliasName: 'AliasName',
      desc: 'Desc',
      iotInstanceId: 'IotInstanceId',
      moduleName: 'ModuleName',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliasName: 'string',
      desc: 'string',
      iotInstanceId: 'string',
      moduleName: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOTAModuleResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOTAModuleResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateOTAModuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateOTAModuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOTAStaticUpgradeJobRequest extends $tea.Model {
  dnListFileUrl?: string;
  downloadProtocol?: string;
  firmwareId?: string;
  grayPercent?: string;
  groupId?: string;
  groupType?: string;
  iotInstanceId?: string;
  maximumPerMinute?: number;
  multiModuleMode?: boolean;
  needConfirm?: boolean;
  needPush?: boolean;
  overwriteMode?: number;
  productKey?: string;
  retryCount?: number;
  retryInterval?: number;
  scheduleFinishTime?: number;
  scheduleTime?: number;
  srcVersion?: string[];
  tag?: CreateOTAStaticUpgradeJobRequestTag[];
  targetDeviceName?: string[];
  targetSelection?: string;
  timeoutInMinutes?: number;
  static names(): { [key: string]: string } {
    return {
      dnListFileUrl: 'DnListFileUrl',
      downloadProtocol: 'DownloadProtocol',
      firmwareId: 'FirmwareId',
      grayPercent: 'GrayPercent',
      groupId: 'GroupId',
      groupType: 'GroupType',
      iotInstanceId: 'IotInstanceId',
      maximumPerMinute: 'MaximumPerMinute',
      multiModuleMode: 'MultiModuleMode',
      needConfirm: 'NeedConfirm',
      needPush: 'NeedPush',
      overwriteMode: 'OverwriteMode',
      productKey: 'ProductKey',
      retryCount: 'RetryCount',
      retryInterval: 'RetryInterval',
      scheduleFinishTime: 'ScheduleFinishTime',
      scheduleTime: 'ScheduleTime',
      srcVersion: 'SrcVersion',
      tag: 'Tag',
      targetDeviceName: 'TargetDeviceName',
      targetSelection: 'TargetSelection',
      timeoutInMinutes: 'TimeoutInMinutes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dnListFileUrl: 'string',
      downloadProtocol: 'string',
      firmwareId: 'string',
      grayPercent: 'string',
      groupId: 'string',
      groupType: 'string',
      iotInstanceId: 'string',
      maximumPerMinute: 'number',
      multiModuleMode: 'boolean',
      needConfirm: 'boolean',
      needPush: 'boolean',
      overwriteMode: 'number',
      productKey: 'string',
      retryCount: 'number',
      retryInterval: 'number',
      scheduleFinishTime: 'number',
      scheduleTime: 'number',
      srcVersion: { 'type': 'array', 'itemType': 'string' },
      tag: { 'type': 'array', 'itemType': CreateOTAStaticUpgradeJobRequestTag },
      targetDeviceName: { 'type': 'array', 'itemType': 'string' },
      targetSelection: 'string',
      timeoutInMinutes: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOTAStaticUpgradeJobResponseBody extends $tea.Model {
  code?: string;
  data?: CreateOTAStaticUpgradeJobResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: CreateOTAStaticUpgradeJobResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOTAStaticUpgradeJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateOTAStaticUpgradeJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateOTAStaticUpgradeJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOTAVerifyJobRequest extends $tea.Model {
  downloadProtocol?: string;
  firmwareId?: string;
  iotInstanceId?: string;
  needConfirm?: boolean;
  needPush?: boolean;
  productKey?: string;
  tag?: CreateOTAVerifyJobRequestTag[];
  targetDeviceName?: string[];
  timeoutInMinutes?: number;
  static names(): { [key: string]: string } {
    return {
      downloadProtocol: 'DownloadProtocol',
      firmwareId: 'FirmwareId',
      iotInstanceId: 'IotInstanceId',
      needConfirm: 'NeedConfirm',
      needPush: 'NeedPush',
      productKey: 'ProductKey',
      tag: 'Tag',
      targetDeviceName: 'TargetDeviceName',
      timeoutInMinutes: 'TimeoutInMinutes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      downloadProtocol: 'string',
      firmwareId: 'string',
      iotInstanceId: 'string',
      needConfirm: 'boolean',
      needPush: 'boolean',
      productKey: 'string',
      tag: { 'type': 'array', 'itemType': CreateOTAVerifyJobRequestTag },
      targetDeviceName: { 'type': 'array', 'itemType': 'string' },
      timeoutInMinutes: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOTAVerifyJobResponseBody extends $tea.Model {
  code?: string;
  data?: CreateOTAVerifyJobResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: CreateOTAVerifyJobResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOTAVerifyJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateOTAVerifyJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateOTAVerifyJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateParserRequest extends $tea.Model {
  description?: string;
  iotInstanceId?: string;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      iotInstanceId: 'IotInstanceId',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      iotInstanceId: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateParserResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  parserId?: number;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      parserId: 'ParserId',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      parserId: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateParserResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateParserResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateParserResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateParserDataSourceRequest extends $tea.Model {
  description?: string;
  iotInstanceId?: string;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      iotInstanceId: 'IotInstanceId',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      iotInstanceId: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateParserDataSourceResponseBody extends $tea.Model {
  code?: string;
  dataSource?: CreateParserDataSourceResponseBodyDataSource;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      dataSource: 'DataSource',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      dataSource: CreateParserDataSourceResponseBodyDataSource,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateParserDataSourceResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateParserDataSourceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateParserDataSourceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProductRequest extends $tea.Model {
  aliyunCommodityCode?: string;
  authType?: string;
  categoryKey?: string;
  dataFormat?: number;
  description?: string;
  id2?: boolean;
  iotInstanceId?: string;
  joinPermissionId?: string;
  netType?: string;
  nodeType?: number;
  productName?: string;
  protocolType?: string;
  publishAuto?: boolean;
  resourceGroupId?: string;
  validateType?: number;
  static names(): { [key: string]: string } {
    return {
      aliyunCommodityCode: 'AliyunCommodityCode',
      authType: 'AuthType',
      categoryKey: 'CategoryKey',
      dataFormat: 'DataFormat',
      description: 'Description',
      id2: 'Id2',
      iotInstanceId: 'IotInstanceId',
      joinPermissionId: 'JoinPermissionId',
      netType: 'NetType',
      nodeType: 'NodeType',
      productName: 'ProductName',
      protocolType: 'ProtocolType',
      publishAuto: 'PublishAuto',
      resourceGroupId: 'ResourceGroupId',
      validateType: 'ValidateType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunCommodityCode: 'string',
      authType: 'string',
      categoryKey: 'string',
      dataFormat: 'number',
      description: 'string',
      id2: 'boolean',
      iotInstanceId: 'string',
      joinPermissionId: 'string',
      netType: 'string',
      nodeType: 'number',
      productName: 'string',
      protocolType: 'string',
      publishAuto: 'boolean',
      resourceGroupId: 'string',
      validateType: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProductResponseBody extends $tea.Model {
  code?: string;
  data?: CreateProductResponseBodyData;
  errorMessage?: string;
  productKey?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      productKey: 'ProductKey',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: CreateProductResponseBodyData,
      errorMessage: 'string',
      productKey: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProductResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateProductResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateProductResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProductDistributeJobRequest extends $tea.Model {
  productKey?: string;
  sourceInstanceId?: string;
  targetAliyunId?: string;
  targetInstanceId?: string;
  targetUid?: string;
  static names(): { [key: string]: string } {
    return {
      productKey: 'ProductKey',
      sourceInstanceId: 'SourceInstanceId',
      targetAliyunId: 'TargetAliyunId',
      targetInstanceId: 'TargetInstanceId',
      targetUid: 'TargetUid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      productKey: 'string',
      sourceInstanceId: 'string',
      targetAliyunId: 'string',
      targetInstanceId: 'string',
      targetUid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProductDistributeJobResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  jobId?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      jobId: 'JobId',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      jobId: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProductDistributeJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateProductDistributeJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateProductDistributeJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProductTagsRequest extends $tea.Model {
  iotInstanceId?: string;
  productKey?: string;
  productTag?: CreateProductTagsRequestProductTag[];
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
      productTag: 'ProductTag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      productKey: 'string',
      productTag: { 'type': 'array', 'itemType': CreateProductTagsRequestProductTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProductTagsResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  invalidProductTags?: CreateProductTagsResponseBodyInvalidProductTags;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      invalidProductTags: 'InvalidProductTags',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      invalidProductTags: CreateProductTagsResponseBodyInvalidProductTags,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProductTagsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateProductTagsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateProductTagsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProductTopicRequest extends $tea.Model {
  codec?: string;
  desc?: string;
  enableProxySubscribe?: boolean;
  iotInstanceId?: string;
  operation?: string;
  productKey?: string;
  topicShortName?: string;
  static names(): { [key: string]: string } {
    return {
      codec: 'Codec',
      desc: 'Desc',
      enableProxySubscribe: 'EnableProxySubscribe',
      iotInstanceId: 'IotInstanceId',
      operation: 'Operation',
      productKey: 'ProductKey',
      topicShortName: 'TopicShortName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      codec: 'string',
      desc: 'string',
      enableProxySubscribe: 'boolean',
      iotInstanceId: 'string',
      operation: 'string',
      productKey: 'string',
      topicShortName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProductTopicResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  topicId?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      topicId: 'TopicId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      topicId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProductTopicResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateProductTopicResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateProductTopicResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRuleRequest extends $tea.Model {
  dataType?: string;
  iotInstanceId?: string;
  name?: string;
  productKey?: string;
  resourceGroupId?: string;
  ruleDesc?: string;
  select?: string;
  shortTopic?: string;
  topic?: string;
  topicType?: number;
  where?: string;
  static names(): { [key: string]: string } {
    return {
      dataType: 'DataType',
      iotInstanceId: 'IotInstanceId',
      name: 'Name',
      productKey: 'ProductKey',
      resourceGroupId: 'ResourceGroupId',
      ruleDesc: 'RuleDesc',
      select: 'Select',
      shortTopic: 'ShortTopic',
      topic: 'Topic',
      topicType: 'TopicType',
      where: 'Where',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataType: 'string',
      iotInstanceId: 'string',
      name: 'string',
      productKey: 'string',
      resourceGroupId: 'string',
      ruleDesc: 'string',
      select: 'string',
      shortTopic: 'string',
      topic: 'string',
      topicType: 'number',
      where: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRuleResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  ruleId?: number;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      ruleId: 'RuleId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      ruleId: 'number',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRuleResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRuleActionRequest extends $tea.Model {
  configuration?: string;
  errorActionFlag?: boolean;
  iotInstanceId?: string;
  ruleId?: number;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      configuration: 'Configuration',
      errorActionFlag: 'ErrorActionFlag',
      iotInstanceId: 'IotInstanceId',
      ruleId: 'RuleId',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configuration: 'string',
      errorActionFlag: 'boolean',
      iotInstanceId: 'string',
      ruleId: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRuleActionResponseBody extends $tea.Model {
  actionId?: number;
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      actionId: 'ActionId',
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actionId: 'number',
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRuleActionResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateRuleActionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateRuleActionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSceneRuleRequest extends $tea.Model {
  iotInstanceId?: string;
  ruleContent?: string;
  ruleDescription?: string;
  ruleName?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      ruleContent: 'RuleContent',
      ruleDescription: 'RuleDescription',
      ruleName: 'RuleName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      ruleContent: 'string',
      ruleDescription: 'string',
      ruleName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSceneRuleResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  ruleId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      ruleId: 'RuleId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      ruleId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSceneRuleResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateSceneRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateSceneRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSchedulePeriodRequest extends $tea.Model {
  description?: string;
  endTime?: string;
  iotInstanceId?: string;
  scheduleCode?: string;
  soundCodeContent?: string;
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      endTime: 'EndTime',
      iotInstanceId: 'IotInstanceId',
      scheduleCode: 'ScheduleCode',
      soundCodeContent: 'SoundCodeContent',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      endTime: 'string',
      iotInstanceId: 'string',
      scheduleCode: 'string',
      soundCodeContent: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSchedulePeriodResponseBody extends $tea.Model {
  code?: string;
  data?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSchedulePeriodResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateSchedulePeriodResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateSchedulePeriodResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSoundCodeRequest extends $tea.Model {
  duration?: number;
  iotInstanceId?: string;
  name?: string;
  openType?: string;
  soundCodeContent?: string;
  static names(): { [key: string]: string } {
    return {
      duration: 'Duration',
      iotInstanceId: 'IotInstanceId',
      name: 'Name',
      openType: 'OpenType',
      soundCodeContent: 'SoundCodeContent',
    };
  }

  static types(): { [key: string]: any } {
    return {
      duration: 'number',
      iotInstanceId: 'string',
      name: 'string',
      openType: 'string',
      soundCodeContent: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSoundCodeResponseBody extends $tea.Model {
  code?: string;
  data?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSoundCodeResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateSoundCodeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateSoundCodeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSoundCodeLabelRequest extends $tea.Model {
  iotInstanceId?: string;
  label?: string;
  scheduleCode?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      label: 'Label',
      scheduleCode: 'ScheduleCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      label: 'string',
      scheduleCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSoundCodeLabelResponseBody extends $tea.Model {
  code?: string;
  data?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSoundCodeLabelResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateSoundCodeLabelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateSoundCodeLabelResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSoundCodeScheduleRequest extends $tea.Model {
  description?: string;
  endDate?: string;
  iotInstanceId?: string;
  name?: string;
  openType?: string;
  startDate?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      endDate: 'EndDate',
      iotInstanceId: 'IotInstanceId',
      name: 'Name',
      openType: 'OpenType',
      startDate: 'StartDate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      endDate: 'string',
      iotInstanceId: 'string',
      name: 'string',
      openType: 'string',
      startDate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSoundCodeScheduleResponseBody extends $tea.Model {
  code?: string;
  data?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSoundCodeScheduleResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateSoundCodeScheduleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateSoundCodeScheduleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSpeechRequest extends $tea.Model {
  audioFormat?: string;
  bizCode?: string;
  enableSoundCode?: boolean;
  iotInstanceId?: string;
  projectCode?: string;
  soundCodeConfig?: { [key: string]: any };
  speechRate?: number;
  speechType?: string;
  text?: string;
  voice?: string;
  volume?: number;
  static names(): { [key: string]: string } {
    return {
      audioFormat: 'AudioFormat',
      bizCode: 'BizCode',
      enableSoundCode: 'EnableSoundCode',
      iotInstanceId: 'IotInstanceId',
      projectCode: 'ProjectCode',
      soundCodeConfig: 'SoundCodeConfig',
      speechRate: 'SpeechRate',
      speechType: 'SpeechType',
      text: 'Text',
      voice: 'Voice',
      volume: 'Volume',
    };
  }

  static types(): { [key: string]: any } {
    return {
      audioFormat: 'string',
      bizCode: 'string',
      enableSoundCode: 'boolean',
      iotInstanceId: 'string',
      projectCode: 'string',
      soundCodeConfig: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      speechRate: 'number',
      speechType: 'string',
      text: 'string',
      voice: 'string',
      volume: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSpeechShrinkRequest extends $tea.Model {
  audioFormat?: string;
  bizCode?: string;
  enableSoundCode?: boolean;
  iotInstanceId?: string;
  projectCode?: string;
  soundCodeConfigShrink?: string;
  speechRate?: number;
  speechType?: string;
  text?: string;
  voice?: string;
  volume?: number;
  static names(): { [key: string]: string } {
    return {
      audioFormat: 'AudioFormat',
      bizCode: 'BizCode',
      enableSoundCode: 'EnableSoundCode',
      iotInstanceId: 'IotInstanceId',
      projectCode: 'ProjectCode',
      soundCodeConfigShrink: 'SoundCodeConfig',
      speechRate: 'SpeechRate',
      speechType: 'SpeechType',
      text: 'Text',
      voice: 'Voice',
      volume: 'Volume',
    };
  }

  static types(): { [key: string]: any } {
    return {
      audioFormat: 'string',
      bizCode: 'string',
      enableSoundCode: 'boolean',
      iotInstanceId: 'string',
      projectCode: 'string',
      soundCodeConfigShrink: 'string',
      speechRate: 'number',
      speechType: 'string',
      text: 'string',
      voice: 'string',
      volume: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSpeechResponseBody extends $tea.Model {
  code?: string;
  data?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSpeechResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateSpeechResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateSpeechResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateStudioAppDomainOpenRequest extends $tea.Model {
  appId?: string;
  host?: string;
  iotInstanceId?: string;
  projectId?: string;
  protocol?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      host: 'Host',
      iotInstanceId: 'IotInstanceId',
      projectId: 'ProjectId',
      protocol: 'Protocol',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      host: 'string',
      iotInstanceId: 'string',
      projectId: 'string',
      protocol: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateStudioAppDomainOpenResponseBody extends $tea.Model {
  code?: string;
  data?: CreateStudioAppDomainOpenResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: CreateStudioAppDomainOpenResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateStudioAppDomainOpenResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateStudioAppDomainOpenResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateStudioAppDomainOpenResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSubscribeRelationRequest extends $tea.Model {
  consumerGroupIds?: string[];
  deviceDataFlag?: boolean;
  deviceLifeCycleFlag?: boolean;
  deviceStatusChangeFlag?: boolean;
  deviceTagFlag?: boolean;
  deviceTopoLifeCycleFlag?: boolean;
  foundDeviceListFlag?: boolean;
  iotInstanceId?: string;
  mnsConfiguration?: string;
  otaEventFlag?: boolean;
  otaJobFlag?: boolean;
  otaVersionFlag?: boolean;
  productKey?: string;
  subscribeFlags?: string;
  thingHistoryFlag?: boolean;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      consumerGroupIds: 'ConsumerGroupIds',
      deviceDataFlag: 'DeviceDataFlag',
      deviceLifeCycleFlag: 'DeviceLifeCycleFlag',
      deviceStatusChangeFlag: 'DeviceStatusChangeFlag',
      deviceTagFlag: 'DeviceTagFlag',
      deviceTopoLifeCycleFlag: 'DeviceTopoLifeCycleFlag',
      foundDeviceListFlag: 'FoundDeviceListFlag',
      iotInstanceId: 'IotInstanceId',
      mnsConfiguration: 'MnsConfiguration',
      otaEventFlag: 'OtaEventFlag',
      otaJobFlag: 'OtaJobFlag',
      otaVersionFlag: 'OtaVersionFlag',
      productKey: 'ProductKey',
      subscribeFlags: 'SubscribeFlags',
      thingHistoryFlag: 'ThingHistoryFlag',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consumerGroupIds: { 'type': 'array', 'itemType': 'string' },
      deviceDataFlag: 'boolean',
      deviceLifeCycleFlag: 'boolean',
      deviceStatusChangeFlag: 'boolean',
      deviceTagFlag: 'boolean',
      deviceTopoLifeCycleFlag: 'boolean',
      foundDeviceListFlag: 'boolean',
      iotInstanceId: 'string',
      mnsConfiguration: 'string',
      otaEventFlag: 'boolean',
      otaJobFlag: 'boolean',
      otaVersionFlag: 'boolean',
      productKey: 'string',
      subscribeFlags: 'string',
      thingHistoryFlag: 'boolean',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSubscribeRelationResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSubscribeRelationResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateSubscribeRelationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateSubscribeRelationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateThingModelRequest extends $tea.Model {
  functionBlockId?: string;
  functionBlockName?: string;
  iotInstanceId?: string;
  productKey?: string;
  thingModelJson?: string;
  static names(): { [key: string]: string } {
    return {
      functionBlockId: 'FunctionBlockId',
      functionBlockName: 'FunctionBlockName',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
      thingModelJson: 'ThingModelJson',
    };
  }

  static types(): { [key: string]: any } {
    return {
      functionBlockId: 'string',
      functionBlockName: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
      thingModelJson: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateThingModelResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateThingModelResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateThingModelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateThingModelResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateThingScriptRequest extends $tea.Model {
  iotInstanceId?: string;
  productKey?: string;
  scriptContent?: string;
  scriptType?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
      scriptContent: 'ScriptContent',
      scriptType: 'ScriptType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      productKey: 'string',
      scriptContent: 'string',
      scriptType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateThingScriptResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateThingScriptResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateThingScriptResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateThingScriptResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTopicConfigRequest extends $tea.Model {
  codec?: string;
  description?: string;
  enableBroadcast?: boolean;
  enableProxySubscribe?: boolean;
  iotInstanceId?: string;
  operation?: string;
  productKey?: string;
  topicFullName?: string;
  static names(): { [key: string]: string } {
    return {
      codec: 'Codec',
      description: 'Description',
      enableBroadcast: 'EnableBroadcast',
      enableProxySubscribe: 'EnableProxySubscribe',
      iotInstanceId: 'IotInstanceId',
      operation: 'Operation',
      productKey: 'ProductKey',
      topicFullName: 'TopicFullName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      codec: 'string',
      description: 'string',
      enableBroadcast: 'boolean',
      enableProxySubscribe: 'boolean',
      iotInstanceId: 'string',
      operation: 'string',
      productKey: 'string',
      topicFullName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTopicConfigResponseBody extends $tea.Model {
  code?: string;
  message?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTopicConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateTopicConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateTopicConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTopicRouteTableRequest extends $tea.Model {
  dstTopic?: string[];
  iotInstanceId?: string;
  srcTopic?: string;
  static names(): { [key: string]: string } {
    return {
      dstTopic: 'DstTopic',
      iotInstanceId: 'IotInstanceId',
      srcTopic: 'SrcTopic',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dstTopic: { 'type': 'array', 'itemType': 'string' },
      iotInstanceId: 'string',
      srcTopic: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTopicRouteTableResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  failureTopics?: CreateTopicRouteTableResponseBodyFailureTopics;
  isAllSucceed?: boolean;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      failureTopics: 'FailureTopics',
      isAllSucceed: 'IsAllSucceed',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      failureTopics: CreateTopicRouteTableResponseBodyFailureTopics,
      isAllSucceed: 'boolean',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTopicRouteTableResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateTopicRouteTableResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateTopicRouteTableResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteClientIdsRequest extends $tea.Model {
  iotId?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteClientIdsResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteClientIdsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteClientIdsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteClientIdsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteConsumerGroupRequest extends $tea.Model {
  groupId?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteConsumerGroupResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteConsumerGroupResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteConsumerGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteConsumerGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteConsumerGroupSubscribeRelationRequest extends $tea.Model {
  consumerGroupId?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      consumerGroupId: 'ConsumerGroupId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consumerGroupId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteConsumerGroupSubscribeRelationResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteConsumerGroupSubscribeRelationResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteConsumerGroupSubscribeRelationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteConsumerGroupSubscribeRelationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDataSourceItemRequest extends $tea.Model {
  dataSourceId?: number;
  dataSourceItemId?: number;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      dataSourceId: 'DataSourceId',
      dataSourceItemId: 'DataSourceItemId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataSourceId: 'number',
      dataSourceItemId: 'number',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDataSourceItemResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDataSourceItemResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteDataSourceItemResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteDataSourceItemResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDestinationRequest extends $tea.Model {
  destinationId?: number;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      destinationId: 'DestinationId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      destinationId: 'number',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDestinationResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDestinationResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteDestinationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteDestinationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDeviceRequest extends $tea.Model {
  deviceName?: string;
  iotId?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDeviceResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDeviceResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteDeviceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteDeviceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDeviceDistributeJobRequest extends $tea.Model {
  jobId?: string;
  static names(): { [key: string]: string } {
    return {
      jobId: 'JobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      jobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDeviceDistributeJobResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDeviceDistributeJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteDeviceDistributeJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteDeviceDistributeJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDeviceDynamicGroupRequest extends $tea.Model {
  groupId?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDeviceDynamicGroupResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDeviceDynamicGroupResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteDeviceDynamicGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteDeviceDynamicGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDeviceFileRequest extends $tea.Model {
  deviceName?: string;
  fileId?: string;
  iotId?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      fileId: 'FileId',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      fileId: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDeviceFileResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDeviceFileResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteDeviceFileResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteDeviceFileResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDeviceGroupRequest extends $tea.Model {
  groupId?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDeviceGroupResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDeviceGroupResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteDeviceGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteDeviceGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDevicePropRequest extends $tea.Model {
  deviceName?: string;
  iotId?: string;
  iotInstanceId?: string;
  productKey?: string;
  propKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
      propKey: 'PropKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
      propKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDevicePropResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDevicePropResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteDevicePropResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteDevicePropResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDeviceSpeechRequest extends $tea.Model {
  deviceSpeechList?: DeleteDeviceSpeechRequestDeviceSpeechList[];
  iotId?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      deviceSpeechList: 'DeviceSpeechList',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceSpeechList: { 'type': 'array', 'itemType': DeleteDeviceSpeechRequestDeviceSpeechList },
      iotId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDeviceSpeechResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDeviceSpeechResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteDeviceSpeechResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteDeviceSpeechResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDeviceTunnelRequest extends $tea.Model {
  iotInstanceId?: string;
  tunnelId?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      tunnelId: 'TunnelId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      tunnelId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDeviceTunnelResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDeviceTunnelResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteDeviceTunnelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteDeviceTunnelResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEdgeDriverRequest extends $tea.Model {
  driverId?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      driverId: 'DriverId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      driverId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEdgeDriverResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEdgeDriverResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteEdgeDriverResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteEdgeDriverResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEdgeDriverVersionRequest extends $tea.Model {
  driverId?: string;
  driverVersion?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      driverId: 'DriverId',
      driverVersion: 'DriverVersion',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      driverId: 'string',
      driverVersion: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEdgeDriverVersionResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEdgeDriverVersionResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteEdgeDriverVersionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteEdgeDriverVersionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEdgeInstanceRequest extends $tea.Model {
  instanceId?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEdgeInstanceResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEdgeInstanceResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteEdgeInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteEdgeInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEdgeInstanceMessageRoutingRequest extends $tea.Model {
  instanceId?: string;
  iotInstanceId?: string;
  routeId?: number;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
      routeId: 'RouteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      iotInstanceId: 'string',
      routeId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEdgeInstanceMessageRoutingResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEdgeInstanceMessageRoutingResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteEdgeInstanceMessageRoutingResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteEdgeInstanceMessageRoutingResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteJobRequest extends $tea.Model {
  iotInstanceId?: string;
  jobId?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      jobId: 'JobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      jobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteJobResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteOTAFirmwareRequest extends $tea.Model {
  firmwareId?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      firmwareId: 'FirmwareId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      firmwareId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteOTAFirmwareResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteOTAFirmwareResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteOTAFirmwareResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteOTAFirmwareResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteOTAModuleRequest extends $tea.Model {
  iotInstanceId?: string;
  moduleName?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      moduleName: 'ModuleName',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      moduleName: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteOTAModuleResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteOTAModuleResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteOTAModuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteOTAModuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteParserRequest extends $tea.Model {
  iotInstanceId?: string;
  parserId?: number;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      parserId: 'ParserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      parserId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteParserResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteParserResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteParserResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteParserResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteParserDataSourceRequest extends $tea.Model {
  dataSourceId?: number;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      dataSourceId: 'DataSourceId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataSourceId: 'number',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteParserDataSourceResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteParserDataSourceResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteParserDataSourceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteParserDataSourceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteProductRequest extends $tea.Model {
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteProductResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteProductResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteProductResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteProductResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteProductTagsRequest extends $tea.Model {
  iotInstanceId?: string;
  productKey?: string;
  productTagKey?: string[];
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
      productTagKey: 'ProductTagKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      productKey: 'string',
      productTagKey: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteProductTagsResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteProductTagsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteProductTagsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteProductTagsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteProductTopicRequest extends $tea.Model {
  iotInstanceId?: string;
  topicId?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      topicId: 'TopicId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      topicId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteProductTopicResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteProductTopicResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteProductTopicResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteProductTopicResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRuleRequest extends $tea.Model {
  iotInstanceId?: string;
  ruleId?: number;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      ruleId: 'RuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      ruleId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRuleResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRuleResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRuleActionRequest extends $tea.Model {
  actionId?: number;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      actionId: 'ActionId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actionId: 'number',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRuleActionResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRuleActionResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteRuleActionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteRuleActionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSceneRuleRequest extends $tea.Model {
  iotInstanceId?: string;
  ruleId?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      ruleId: 'RuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      ruleId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSceneRuleResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSceneRuleResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteSceneRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteSceneRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSchedulePeriodRequest extends $tea.Model {
  iotInstanceId?: string;
  periodCode?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      periodCode: 'PeriodCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      periodCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSchedulePeriodResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSchedulePeriodResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteSchedulePeriodResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteSchedulePeriodResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteShareTaskDeviceRequest extends $tea.Model {
  iotIdList?: string[];
  iotInstanceId?: string;
  shareTaskId?: string;
  static names(): { [key: string]: string } {
    return {
      iotIdList: 'IotIdList',
      iotInstanceId: 'IotInstanceId',
      shareTaskId: 'ShareTaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotIdList: { 'type': 'array', 'itemType': 'string' },
      iotInstanceId: 'string',
      shareTaskId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteShareTaskDeviceResponseBody extends $tea.Model {
  code?: string;
  data?: DeleteShareTaskDeviceResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: DeleteShareTaskDeviceResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteShareTaskDeviceResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteShareTaskDeviceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteShareTaskDeviceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSoundCodeRequest extends $tea.Model {
  iotInstanceId?: string;
  soundCode?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      soundCode: 'SoundCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      soundCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSoundCodeResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSoundCodeResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteSoundCodeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteSoundCodeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSoundCodeLabelRequest extends $tea.Model {
  iotInstanceId?: string;
  soundCode?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      soundCode: 'SoundCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      soundCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSoundCodeLabelResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSoundCodeLabelResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteSoundCodeLabelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteSoundCodeLabelResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSoundCodeScheduleRequest extends $tea.Model {
  iotInstanceId?: string;
  scheduleCode?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      scheduleCode: 'ScheduleCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      scheduleCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSoundCodeScheduleResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSoundCodeScheduleResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteSoundCodeScheduleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteSoundCodeScheduleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSpeechRequest extends $tea.Model {
  iotInstanceId?: string;
  speechCodeList?: string[];
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      speechCodeList: 'SpeechCodeList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      speechCodeList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSpeechResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSpeechResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteSpeechResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteSpeechResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteStudioAppDomainOpenRequest extends $tea.Model {
  appId?: string;
  domainId?: number;
  iotInstanceId?: string;
  projectId?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      domainId: 'DomainId',
      iotInstanceId: 'IotInstanceId',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      domainId: 'number',
      iotInstanceId: 'string',
      projectId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteStudioAppDomainOpenResponseBody extends $tea.Model {
  code?: string;
  data?: boolean;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'boolean',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteStudioAppDomainOpenResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteStudioAppDomainOpenResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteStudioAppDomainOpenResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSubscribeRelationRequest extends $tea.Model {
  iotInstanceId?: string;
  productKey?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      productKey: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSubscribeRelationResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSubscribeRelationResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteSubscribeRelationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteSubscribeRelationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteThingModelRequest extends $tea.Model {
  eventIdentifier?: string[];
  functionBlockId?: string;
  iotInstanceId?: string;
  productKey?: string;
  propertyIdentifier?: string[];
  resourceGroupId?: string;
  serviceIdentifier?: string[];
  static names(): { [key: string]: string } {
    return {
      eventIdentifier: 'EventIdentifier',
      functionBlockId: 'FunctionBlockId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
      propertyIdentifier: 'PropertyIdentifier',
      resourceGroupId: 'ResourceGroupId',
      serviceIdentifier: 'ServiceIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      eventIdentifier: { 'type': 'array', 'itemType': 'string' },
      functionBlockId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
      propertyIdentifier: { 'type': 'array', 'itemType': 'string' },
      resourceGroupId: 'string',
      serviceIdentifier: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteThingModelResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteThingModelResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteThingModelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteThingModelResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTopicConfigRequest extends $tea.Model {
  iotInstanceId?: string;
  productKey?: string;
  topicFullName?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
      topicFullName: 'TopicFullName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      productKey: 'string',
      topicFullName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTopicConfigResponseBody extends $tea.Model {
  code?: string;
  message?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTopicConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteTopicConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteTopicConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTopicRouteTableRequest extends $tea.Model {
  dstTopic?: string[];
  iotInstanceId?: string;
  srcTopic?: string;
  static names(): { [key: string]: string } {
    return {
      dstTopic: 'DstTopic',
      iotInstanceId: 'IotInstanceId',
      srcTopic: 'SrcTopic',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dstTopic: { 'type': 'array', 'itemType': 'string' },
      iotInstanceId: 'string',
      srcTopic: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTopicRouteTableResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  failureTopics?: DeleteTopicRouteTableResponseBodyFailureTopics;
  isAllSucceed?: boolean;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      failureTopics: 'FailureTopics',
      isAllSucceed: 'IsAllSucceed',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      failureTopics: DeleteTopicRouteTableResponseBodyFailureTopics,
      isAllSucceed: 'boolean',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTopicRouteTableResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteTopicRouteTableResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteTopicRouteTableResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DetachDestinationRequest extends $tea.Model {
  destinationId?: number;
  iotInstanceId?: string;
  parserId?: number;
  static names(): { [key: string]: string } {
    return {
      destinationId: 'DestinationId',
      iotInstanceId: 'IotInstanceId',
      parserId: 'ParserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      destinationId: 'number',
      iotInstanceId: 'string',
      parserId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DetachDestinationResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DetachDestinationResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DetachDestinationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DetachDestinationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DetachParserDataSourceRequest extends $tea.Model {
  dataSourceId?: number;
  iotInstanceId?: string;
  parserId?: number;
  static names(): { [key: string]: string } {
    return {
      dataSourceId: 'DataSourceId',
      iotInstanceId: 'IotInstanceId',
      parserId: 'ParserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataSourceId: 'number',
      iotInstanceId: 'string',
      parserId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DetachParserDataSourceResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DetachParserDataSourceResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DetachParserDataSourceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DetachParserDataSourceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableDeviceTunnelRequest extends $tea.Model {
  deviceName?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableDeviceTunnelResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableDeviceTunnelResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DisableDeviceTunnelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DisableDeviceTunnelResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableDeviceTunnelShareRequest extends $tea.Model {
  deviceName?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableDeviceTunnelShareResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableDeviceTunnelShareResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DisableDeviceTunnelShareResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DisableDeviceTunnelShareResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableSceneRuleRequest extends $tea.Model {
  iotInstanceId?: string;
  ruleId?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      ruleId: 'RuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      ruleId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableSceneRuleResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableSceneRuleResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DisableSceneRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DisableSceneRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableThingRequest extends $tea.Model {
  deviceName?: string;
  iotId?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableThingResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableThingResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DisableThingResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DisableThingResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableDeviceTunnelRequest extends $tea.Model {
  deviceName?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableDeviceTunnelResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableDeviceTunnelResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: EnableDeviceTunnelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: EnableDeviceTunnelResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableDeviceTunnelShareRequest extends $tea.Model {
  deviceName?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableDeviceTunnelShareResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableDeviceTunnelShareResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: EnableDeviceTunnelShareResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: EnableDeviceTunnelShareResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableSceneRuleRequest extends $tea.Model {
  iotInstanceId?: string;
  ruleId?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      ruleId: 'RuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      ruleId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableSceneRuleResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableSceneRuleResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: EnableSceneRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: EnableSceneRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableThingRequest extends $tea.Model {
  deviceName?: string;
  iotId?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableThingResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableThingResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: EnableThingResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: EnableThingResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GenerateDeviceNameListURLRequest extends $tea.Model {
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GenerateDeviceNameListURLResponseBody extends $tea.Model {
  code?: string;
  data?: GenerateDeviceNameListURLResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: GenerateDeviceNameListURLResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GenerateDeviceNameListURLResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GenerateDeviceNameListURLResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GenerateDeviceNameListURLResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GenerateFileUploadURLRequest extends $tea.Model {
  bizCode?: string;
  fileName?: string;
  fileSuffix?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      bizCode: 'BizCode',
      fileName: 'FileName',
      fileSuffix: 'FileSuffix',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizCode: 'string',
      fileName: 'string',
      fileSuffix: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GenerateFileUploadURLResponseBody extends $tea.Model {
  code?: string;
  data?: GenerateFileUploadURLResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: GenerateFileUploadURLResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GenerateFileUploadURLResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GenerateFileUploadURLResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GenerateFileUploadURLResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GenerateOTAUploadURLRequest extends $tea.Model {
  fileSuffix?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      fileSuffix: 'FileSuffix',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fileSuffix: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GenerateOTAUploadURLResponseBody extends $tea.Model {
  code?: string;
  data?: GenerateOTAUploadURLResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: GenerateOTAUploadURLResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GenerateOTAUploadURLResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GenerateOTAUploadURLResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GenerateOTAUploadURLResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataAPIServiceDetailRequest extends $tea.Model {
  apiSrn?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      apiSrn: 'ApiSrn',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiSrn: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataAPIServiceDetailResponseBody extends $tea.Model {
  code?: string;
  data?: GetDataAPIServiceDetailResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: GetDataAPIServiceDetailResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataAPIServiceDetailResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetDataAPIServiceDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDataAPIServiceDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDestinationRequest extends $tea.Model {
  destinationId?: number;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      destinationId: 'DestinationId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      destinationId: 'number',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDestinationResponseBody extends $tea.Model {
  code?: string;
  destination?: GetDestinationResponseBodyDestination;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      destination: 'Destination',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      destination: GetDestinationResponseBodyDestination,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDestinationResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetDestinationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDestinationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDeviceShadowRequest extends $tea.Model {
  deviceName?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDeviceShadowResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  shadowMessage?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      shadowMessage: 'ShadowMessage',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      shadowMessage: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDeviceShadowResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetDeviceShadowResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDeviceShadowResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDeviceStatusRequest extends $tea.Model {
  deviceName?: string;
  iotId?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDeviceStatusResponseBody extends $tea.Model {
  code?: string;
  data?: GetDeviceStatusResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: GetDeviceStatusResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDeviceStatusResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetDeviceStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDeviceStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDeviceTunnelShareStatusRequest extends $tea.Model {
  deviceName?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDeviceTunnelShareStatusResponseBody extends $tea.Model {
  code?: string;
  data?: GetDeviceTunnelShareStatusResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: GetDeviceTunnelShareStatusResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDeviceTunnelShareStatusResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetDeviceTunnelShareStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDeviceTunnelShareStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDeviceTunnelStatusRequest extends $tea.Model {
  deviceName?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDeviceTunnelStatusResponseBody extends $tea.Model {
  code?: string;
  data?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDeviceTunnelStatusResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetDeviceTunnelStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDeviceTunnelStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDownloadFileRequest extends $tea.Model {
  context?: { [key: string]: any };
  iotInstanceId?: string;
  longJobId?: string;
  static names(): { [key: string]: string } {
    return {
      context: 'Context',
      iotInstanceId: 'IotInstanceId',
      longJobId: 'LongJobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      context: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      iotInstanceId: 'string',
      longJobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDownloadFileShrinkRequest extends $tea.Model {
  contextShrink?: string;
  iotInstanceId?: string;
  longJobId?: string;
  static names(): { [key: string]: string } {
    return {
      contextShrink: 'Context',
      iotInstanceId: 'IotInstanceId',
      longJobId: 'LongJobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contextShrink: 'string',
      iotInstanceId: 'string',
      longJobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDownloadFileResponseBody extends $tea.Model {
  code?: string;
  data?: GetDownloadFileResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: GetDownloadFileResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDownloadFileResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetDownloadFileResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDownloadFileResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeDriverVersionRequest extends $tea.Model {
  driverId?: string;
  driverVersion?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      driverId: 'DriverId',
      driverVersion: 'DriverVersion',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      driverId: 'string',
      driverVersion: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeDriverVersionResponseBody extends $tea.Model {
  code?: string;
  data?: GetEdgeDriverVersionResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: GetEdgeDriverVersionResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeDriverVersionResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetEdgeDriverVersionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetEdgeDriverVersionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeInstanceRequest extends $tea.Model {
  instanceId?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeInstanceResponseBody extends $tea.Model {
  code?: string;
  data?: GetEdgeInstanceResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: GetEdgeInstanceResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeInstanceResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetEdgeInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetEdgeInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeInstanceDeploymentRequest extends $tea.Model {
  deploymentId?: string;
  instanceId?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      deploymentId: 'DeploymentId',
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deploymentId: 'string',
      instanceId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeInstanceDeploymentResponseBody extends $tea.Model {
  code?: string;
  data?: GetEdgeInstanceDeploymentResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: GetEdgeInstanceDeploymentResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeInstanceDeploymentResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetEdgeInstanceDeploymentResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetEdgeInstanceDeploymentResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeInstanceMessageRoutingRequest extends $tea.Model {
  instanceId?: string;
  iotInstanceId?: string;
  routeId?: number;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
      routeId: 'RouteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      iotInstanceId: 'string',
      routeId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeInstanceMessageRoutingResponseBody extends $tea.Model {
  code?: string;
  data?: GetEdgeInstanceMessageRoutingResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: GetEdgeInstanceMessageRoutingResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeInstanceMessageRoutingResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetEdgeInstanceMessageRoutingResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetEdgeInstanceMessageRoutingResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayBySubDeviceRequest extends $tea.Model {
  deviceName?: string;
  iotId?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayBySubDeviceResponseBody extends $tea.Model {
  code?: string;
  data?: GetGatewayBySubDeviceResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: GetGatewayBySubDeviceResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayBySubDeviceResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetGatewayBySubDeviceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetGatewayBySubDeviceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetLoraNodesTaskRequest extends $tea.Model {
  iotInstanceId?: string;
  taskId?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      taskId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetLoraNodesTaskResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  successCount?: number;
  successDevEuis?: GetLoraNodesTaskResponseBodySuccessDevEuis;
  taskId?: string;
  taskState?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      successCount: 'SuccessCount',
      successDevEuis: 'SuccessDevEuis',
      taskId: 'TaskId',
      taskState: 'TaskState',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      successCount: 'number',
      successDevEuis: GetLoraNodesTaskResponseBodySuccessDevEuis,
      taskId: 'string',
      taskState: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetLoraNodesTaskResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetLoraNodesTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetLoraNodesTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetParserRequest extends $tea.Model {
  iotInstanceId?: string;
  parserId?: number;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      parserId: 'ParserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      parserId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetParserResponseBody extends $tea.Model {
  code?: string;
  data?: GetParserResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: GetParserResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetParserResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetParserResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetParserResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetParserDataSourceRequest extends $tea.Model {
  dataSourceId?: number;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      dataSourceId: 'DataSourceId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataSourceId: 'number',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetParserDataSourceResponseBody extends $tea.Model {
  code?: string;
  dataSource?: GetParserDataSourceResponseBodyDataSource;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      dataSource: 'DataSource',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      dataSource: GetParserDataSourceResponseBodyDataSource,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetParserDataSourceResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetParserDataSourceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetParserDataSourceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRuleRequest extends $tea.Model {
  iotInstanceId?: string;
  ruleId?: number;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      ruleId: 'RuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      ruleId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRuleResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  ruleInfo?: GetRuleResponseBodyRuleInfo;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      ruleInfo: 'RuleInfo',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      ruleInfo: GetRuleResponseBodyRuleInfo,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRuleResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRuleActionRequest extends $tea.Model {
  actionId?: number;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      actionId: 'ActionId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actionId: 'number',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRuleActionResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  ruleActionInfo?: GetRuleActionResponseBodyRuleActionInfo;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      ruleActionInfo: 'RuleActionInfo',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      ruleActionInfo: GetRuleActionResponseBodyRuleActionInfo,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRuleActionResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetRuleActionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetRuleActionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSceneRuleRequest extends $tea.Model {
  iotInstanceId?: string;
  ruleId?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      ruleId: 'RuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      ruleId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSceneRuleResponseBody extends $tea.Model {
  code?: string;
  data?: GetSceneRuleResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: GetSceneRuleResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSceneRuleResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetSceneRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetSceneRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetShareSpeechModelAudioRequest extends $tea.Model {
  iotInstanceId?: string;
  shareTaskId?: string;
  speechModelCodeList?: string[];
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      shareTaskId: 'ShareTaskId',
      speechModelCodeList: 'SpeechModelCodeList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      shareTaskId: 'string',
      speechModelCodeList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetShareSpeechModelAudioResponseBody extends $tea.Model {
  code?: string;
  data?: GetShareSpeechModelAudioResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: GetShareSpeechModelAudioResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetShareSpeechModelAudioResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetShareSpeechModelAudioResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetShareSpeechModelAudioResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetShareTaskByDeviceOpenRequest extends $tea.Model {
  deviceName?: string;
  iotId?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetShareTaskByDeviceOpenResponseBody extends $tea.Model {
  code?: string;
  data?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetShareTaskByDeviceOpenResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetShareTaskByDeviceOpenResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetShareTaskByDeviceOpenResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSoundCodeAudioRequest extends $tea.Model {
  iotInstanceId?: string;
  soundCodeList?: string[];
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      soundCodeList: 'SoundCodeList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      soundCodeList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSoundCodeAudioResponseBody extends $tea.Model {
  code?: string;
  data?: GetSoundCodeAudioResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: GetSoundCodeAudioResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSoundCodeAudioResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetSoundCodeAudioResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetSoundCodeAudioResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSoundCodeScheduleRequest extends $tea.Model {
  iotInstanceId?: string;
  scheduleCode?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      scheduleCode: 'ScheduleCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      scheduleCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSoundCodeScheduleResponseBody extends $tea.Model {
  code?: string;
  data?: GetSoundCodeScheduleResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: GetSoundCodeScheduleResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSoundCodeScheduleResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetSoundCodeScheduleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetSoundCodeScheduleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSpeechDeviceDetailRequest extends $tea.Model {
  iotId?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSpeechDeviceDetailResponseBody extends $tea.Model {
  code?: string;
  data?: GetSpeechDeviceDetailResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: GetSpeechDeviceDetailResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSpeechDeviceDetailResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetSpeechDeviceDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetSpeechDeviceDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSpeechLicenseDeviceStatisticsRequest extends $tea.Model {
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSpeechLicenseDeviceStatisticsResponseBody extends $tea.Model {
  code?: string;
  data?: GetSpeechLicenseDeviceStatisticsResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: GetSpeechLicenseDeviceStatisticsResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSpeechLicenseDeviceStatisticsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetSpeechLicenseDeviceStatisticsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetSpeechLicenseDeviceStatisticsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSpeechVoiceResponseBody extends $tea.Model {
  code?: string;
  data?: GetSpeechVoiceResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: GetSpeechVoiceResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSpeechVoiceResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetSpeechVoiceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetSpeechVoiceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStudioAppTokenOpenRequest extends $tea.Model {
  appId?: string;
  iotInstanceId?: string;
  projectId?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      iotInstanceId: 'IotInstanceId',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      iotInstanceId: 'string',
      projectId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStudioAppTokenOpenResponseBody extends $tea.Model {
  code?: string;
  data?: GetStudioAppTokenOpenResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: GetStudioAppTokenOpenResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStudioAppTokenOpenResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetStudioAppTokenOpenResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetStudioAppTokenOpenResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetThingModelTslRequest extends $tea.Model {
  functionBlockId?: string;
  iotInstanceId?: string;
  modelVersion?: string;
  productKey?: string;
  simple?: boolean;
  static names(): { [key: string]: string } {
    return {
      functionBlockId: 'FunctionBlockId',
      iotInstanceId: 'IotInstanceId',
      modelVersion: 'ModelVersion',
      productKey: 'ProductKey',
      simple: 'Simple',
    };
  }

  static types(): { [key: string]: any } {
    return {
      functionBlockId: 'string',
      iotInstanceId: 'string',
      modelVersion: 'string',
      productKey: 'string',
      simple: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetThingModelTslResponseBody extends $tea.Model {
  code?: string;
  data?: GetThingModelTslResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: GetThingModelTslResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetThingModelTslResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetThingModelTslResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetThingModelTslResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetThingModelTslPublishedRequest extends $tea.Model {
  functionBlockId?: string;
  iotInstanceId?: string;
  modelVersion?: string;
  productKey?: string;
  resourceGroupId?: string;
  simple?: boolean;
  static names(): { [key: string]: string } {
    return {
      functionBlockId: 'FunctionBlockId',
      iotInstanceId: 'IotInstanceId',
      modelVersion: 'ModelVersion',
      productKey: 'ProductKey',
      resourceGroupId: 'ResourceGroupId',
      simple: 'Simple',
    };
  }

  static types(): { [key: string]: any } {
    return {
      functionBlockId: 'string',
      iotInstanceId: 'string',
      modelVersion: 'string',
      productKey: 'string',
      resourceGroupId: 'string',
      simple: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetThingModelTslPublishedResponseBody extends $tea.Model {
  code?: string;
  data?: GetThingModelTslPublishedResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: GetThingModelTslPublishedResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetThingModelTslPublishedResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetThingModelTslPublishedResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetThingModelTslPublishedResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetThingScriptRequest extends $tea.Model {
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetThingScriptResponseBody extends $tea.Model {
  code?: string;
  data?: GetThingScriptResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: GetThingScriptResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetThingScriptResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetThingScriptResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetThingScriptResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetThingTemplateRequest extends $tea.Model {
  categoryKey?: string;
  iotInstanceId?: string;
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      categoryKey: 'CategoryKey',
      iotInstanceId: 'IotInstanceId',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      categoryKey: 'string',
      iotInstanceId: 'string',
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetThingTemplateResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  thingModelJSON?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      thingModelJSON: 'ThingModelJSON',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      thingModelJSON: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetThingTemplateResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetThingTemplateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetThingTemplateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetThingTopoRequest extends $tea.Model {
  deviceName?: string;
  iotId?: string;
  iotInstanceId?: string;
  pageNo?: number;
  pageSize?: number;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      pageNo: 'PageNo',
      pageSize: 'PageSize',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      pageNo: 'number',
      pageSize: 'number',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetThingTopoResponseBody extends $tea.Model {
  code?: string;
  data?: GetThingTopoResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: GetThingTopoResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetThingTopoResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetThingTopoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetThingTopoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GisQueryDeviceLocationRequest extends $tea.Model {
  iotInstanceId?: string;
  thingList?: GisQueryDeviceLocationRequestThingList[];
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      thingList: 'ThingList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      thingList: { 'type': 'array', 'itemType': GisQueryDeviceLocationRequestThingList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GisQueryDeviceLocationResponseBody extends $tea.Model {
  code?: string;
  data?: GisQueryDeviceLocationResponseBodyData[];
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: { 'type': 'array', 'itemType': GisQueryDeviceLocationResponseBodyData },
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GisQueryDeviceLocationResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GisQueryDeviceLocationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GisQueryDeviceLocationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GisSearchDeviceTraceRequest extends $tea.Model {
  deviceName?: string;
  endTime?: number;
  iotInstanceId?: string;
  mapMatch?: number;
  productKey?: string;
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      endTime: 'EndTime',
      iotInstanceId: 'IotInstanceId',
      mapMatch: 'MapMatch',
      productKey: 'ProductKey',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      endTime: 'number',
      iotInstanceId: 'string',
      mapMatch: 'number',
      productKey: 'string',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GisSearchDeviceTraceResponseBody extends $tea.Model {
  code?: string;
  data?: GisSearchDeviceTraceResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: GisSearchDeviceTraceResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GisSearchDeviceTraceResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GisSearchDeviceTraceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GisSearchDeviceTraceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportDTDataRequest extends $tea.Model {
  DTInstanceId?: string;
  iotInstanceId?: string;
  items?: ImportDTDataRequestItems[];
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      DTInstanceId: 'DTInstanceId',
      iotInstanceId: 'IotInstanceId',
      items: 'Items',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      DTInstanceId: 'string',
      iotInstanceId: 'string',
      items: { 'type': 'array', 'itemType': ImportDTDataRequestItems },
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportDTDataResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportDTDataResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ImportDTDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ImportDTDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportDeviceRequest extends $tea.Model {
  deviceName?: string;
  deviceSecret?: string;
  iotInstanceId?: string;
  nickname?: string;
  productKey?: string;
  sn?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      deviceSecret: 'DeviceSecret',
      iotInstanceId: 'IotInstanceId',
      nickname: 'Nickname',
      productKey: 'ProductKey',
      sn: 'Sn',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      deviceSecret: 'string',
      iotInstanceId: 'string',
      nickname: 'string',
      productKey: 'string',
      sn: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportDeviceResponseBody extends $tea.Model {
  code?: string;
  data?: ImportDeviceResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: ImportDeviceResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportDeviceResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ImportDeviceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ImportDeviceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportThingModelTslRequest extends $tea.Model {
  functionBlockId?: string;
  functionBlockName?: string;
  iotInstanceId?: string;
  productKey?: string;
  resourceGroupId?: string;
  tslStr?: string;
  tslUrl?: string;
  static names(): { [key: string]: string } {
    return {
      functionBlockId: 'FunctionBlockId',
      functionBlockName: 'FunctionBlockName',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
      resourceGroupId: 'ResourceGroupId',
      tslStr: 'TslStr',
      tslUrl: 'TslUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      functionBlockId: 'string',
      functionBlockName: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
      resourceGroupId: 'string',
      tslStr: 'string',
      tslUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportThingModelTslResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportThingModelTslResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ImportThingModelTslResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ImportThingModelTslResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InvokeDataAPIServiceRequest extends $tea.Model {
  apiSrn?: string;
  iotInstanceId?: string;
  param?: InvokeDataAPIServiceRequestParam[];
  static names(): { [key: string]: string } {
    return {
      apiSrn: 'ApiSrn',
      iotInstanceId: 'IotInstanceId',
      param: 'Param',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiSrn: 'string',
      iotInstanceId: 'string',
      param: { 'type': 'array', 'itemType': InvokeDataAPIServiceRequestParam },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InvokeDataAPIServiceResponseBody extends $tea.Model {
  code?: string;
  data?: InvokeDataAPIServiceResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: InvokeDataAPIServiceResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InvokeDataAPIServiceResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: InvokeDataAPIServiceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: InvokeDataAPIServiceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InvokeThingServiceRequest extends $tea.Model {
  args?: string;
  deviceName?: string;
  identifier?: string;
  iotId?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      args: 'Args',
      deviceName: 'DeviceName',
      identifier: 'Identifier',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      args: 'string',
      deviceName: 'string',
      identifier: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InvokeThingServiceResponseBody extends $tea.Model {
  code?: string;
  data?: InvokeThingServiceResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: InvokeThingServiceResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InvokeThingServiceResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: InvokeThingServiceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: InvokeThingServiceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InvokeThingsServiceRequest extends $tea.Model {
  args?: string;
  deviceName?: string[];
  identifier?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      args: 'Args',
      deviceName: 'DeviceName',
      identifier: 'Identifier',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      args: 'string',
      deviceName: { 'type': 'array', 'itemType': 'string' },
      identifier: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InvokeThingsServiceResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InvokeThingsServiceResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: InvokeThingsServiceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: InvokeThingsServiceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAnalyticsDataRequest extends $tea.Model {
  apiPath?: string;
  condition?: ListAnalyticsDataRequestCondition[];
  iotInstanceId?: string;
  isoId?: string;
  pageNum?: number;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      apiPath: 'ApiPath',
      condition: 'Condition',
      iotInstanceId: 'IotInstanceId',
      isoId: 'IsoId',
      pageNum: 'PageNum',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiPath: 'string',
      condition: { 'type': 'array', 'itemType': ListAnalyticsDataRequestCondition },
      iotInstanceId: 'string',
      isoId: 'string',
      pageNum: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAnalyticsDataResponseBody extends $tea.Model {
  code?: string;
  data?: ListAnalyticsDataResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: ListAnalyticsDataResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAnalyticsDataResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListAnalyticsDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListAnalyticsDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataSourceItemRequest extends $tea.Model {
  dataSourceId?: number;
  iotInstanceId?: string;
  page?: number;
  pageSize?: number;
  searchName?: string;
  static names(): { [key: string]: string } {
    return {
      dataSourceId: 'DataSourceId',
      iotInstanceId: 'IotInstanceId',
      page: 'Page',
      pageSize: 'PageSize',
      searchName: 'SearchName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataSourceId: 'number',
      iotInstanceId: 'string',
      page: 'number',
      pageSize: 'number',
      searchName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataSourceItemResponseBody extends $tea.Model {
  code?: string;
  dataSourceItems?: ListDataSourceItemResponseBodyDataSourceItems;
  errorMessage?: string;
  page?: number;
  pageSize?: number;
  requestId?: string;
  success?: boolean;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      dataSourceItems: 'DataSourceItems',
      errorMessage: 'ErrorMessage',
      page: 'Page',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      dataSourceItems: ListDataSourceItemResponseBodyDataSourceItems,
      errorMessage: 'string',
      page: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataSourceItemResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListDataSourceItemResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListDataSourceItemResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDestinationRequest extends $tea.Model {
  iotInstanceId?: string;
  page?: number;
  pageSize?: number;
  searchName?: string;
  types?: string[];
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      page: 'Page',
      pageSize: 'PageSize',
      searchName: 'SearchName',
      types: 'Types',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      page: 'number',
      pageSize: 'number',
      searchName: 'string',
      types: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDestinationResponseBody extends $tea.Model {
  code?: string;
  destinations?: ListDestinationResponseBodyDestinations;
  errorMessage?: string;
  page?: number;
  pageSize?: number;
  requestId?: string;
  success?: boolean;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      destinations: 'Destinations',
      errorMessage: 'ErrorMessage',
      page: 'Page',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      destinations: ListDestinationResponseBodyDestinations,
      errorMessage: 'string',
      page: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDestinationResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListDestinationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListDestinationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDeviceDistributeJobRequest extends $tea.Model {
  currentPage?: number;
  jobId?: string;
  nextToken?: string;
  pageSize?: number;
  productKey?: string;
  status?: number;
  targetUid?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      jobId: 'JobId',
      nextToken: 'NextToken',
      pageSize: 'PageSize',
      productKey: 'ProductKey',
      status: 'Status',
      targetUid: 'TargetUid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      jobId: 'string',
      nextToken: 'string',
      pageSize: 'number',
      productKey: 'string',
      status: 'number',
      targetUid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDeviceDistributeJobResponseBody extends $tea.Model {
  code?: string;
  data?: ListDeviceDistributeJobResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: ListDeviceDistributeJobResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDeviceDistributeJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListDeviceDistributeJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListDeviceDistributeJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDistributedDeviceRequest extends $tea.Model {
  currentPage?: number;
  deviceName?: string;
  pageSize?: number;
  productKey?: string;
  sourceInstanceId?: string;
  targetUid?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      deviceName: 'DeviceName',
      pageSize: 'PageSize',
      productKey: 'ProductKey',
      sourceInstanceId: 'SourceInstanceId',
      targetUid: 'TargetUid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      deviceName: 'string',
      pageSize: 'number',
      productKey: 'string',
      sourceInstanceId: 'string',
      targetUid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDistributedDeviceResponseBody extends $tea.Model {
  code?: string;
  data?: ListDistributedDeviceResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: ListDistributedDeviceResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDistributedDeviceResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListDistributedDeviceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListDistributedDeviceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDistributedProductRequest extends $tea.Model {
  currentPage?: number;
  pageSize?: number;
  productKey?: string;
  sourceInstanceId?: string;
  targetInstanceId?: string;
  targetUid?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      productKey: 'ProductKey',
      sourceInstanceId: 'SourceInstanceId',
      targetInstanceId: 'TargetInstanceId',
      targetUid: 'TargetUid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      pageSize: 'number',
      productKey: 'string',
      sourceInstanceId: 'string',
      targetInstanceId: 'string',
      targetUid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDistributedProductResponseBody extends $tea.Model {
  code?: string;
  data?: ListDistributedProductResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: ListDistributedProductResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDistributedProductResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListDistributedProductResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListDistributedProductResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobRequest extends $tea.Model {
  currentPage?: number;
  iotInstanceId?: string;
  pageSize?: number;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      iotInstanceId: 'string',
      pageSize: 'number',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobResponseBody extends $tea.Model {
  code?: string;
  data?: ListJobResponseBodyData;
  errorMessage?: string;
  page?: number;
  pageSize?: number;
  requestId?: string;
  success?: boolean;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      page: 'Page',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: ListJobResponseBodyData,
      errorMessage: 'string',
      page: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAFirmwareRequest extends $tea.Model {
  currentPage?: number;
  destVersion?: string;
  iotInstanceId?: string;
  pageSize?: number;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      destVersion: 'DestVersion',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      destVersion: 'string',
      iotInstanceId: 'string',
      pageSize: 'number',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAFirmwareResponseBody extends $tea.Model {
  code?: string;
  currentPage?: number;
  errorMessage?: string;
  firmwareInfo?: ListOTAFirmwareResponseBodyFirmwareInfo;
  pageCount?: number;
  pageSize?: number;
  requestId?: string;
  success?: boolean;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      currentPage: 'CurrentPage',
      errorMessage: 'ErrorMessage',
      firmwareInfo: 'FirmwareInfo',
      pageCount: 'PageCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      currentPage: 'number',
      errorMessage: 'string',
      firmwareInfo: ListOTAFirmwareResponseBodyFirmwareInfo,
      pageCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAFirmwareResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListOTAFirmwareResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListOTAFirmwareResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAJobByDeviceRequest extends $tea.Model {
  currentPage?: number;
  deviceName?: string;
  firmwareId?: string;
  iotInstanceId?: string;
  pageSize?: number;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      deviceName: 'DeviceName',
      firmwareId: 'FirmwareId',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      deviceName: 'string',
      firmwareId: 'string',
      iotInstanceId: 'string',
      pageSize: 'number',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAJobByDeviceResponseBody extends $tea.Model {
  code?: string;
  currentPage?: number;
  data?: ListOTAJobByDeviceResponseBodyData;
  errorMessage?: string;
  pageCount?: number;
  pageSize?: number;
  requestId?: string;
  success?: boolean;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      currentPage: 'CurrentPage',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      pageCount: 'PageCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      currentPage: 'number',
      data: ListOTAJobByDeviceResponseBodyData,
      errorMessage: 'string',
      pageCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAJobByDeviceResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListOTAJobByDeviceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListOTAJobByDeviceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAJobByFirmwareRequest extends $tea.Model {
  currentPage?: number;
  firmwareId?: string;
  iotInstanceId?: string;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      firmwareId: 'FirmwareId',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      firmwareId: 'string',
      iotInstanceId: 'string',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAJobByFirmwareResponseBody extends $tea.Model {
  code?: string;
  currentPage?: number;
  data?: ListOTAJobByFirmwareResponseBodyData;
  errorMessage?: string;
  pageCount?: number;
  pageSize?: number;
  requestId?: string;
  success?: boolean;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      currentPage: 'CurrentPage',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      pageCount: 'PageCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      currentPage: 'number',
      data: ListOTAJobByFirmwareResponseBodyData,
      errorMessage: 'string',
      pageCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAJobByFirmwareResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListOTAJobByFirmwareResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListOTAJobByFirmwareResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAModuleByProductRequest extends $tea.Model {
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAModuleByProductResponseBody extends $tea.Model {
  code?: string;
  data?: ListOTAModuleByProductResponseBodyData[];
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: { 'type': 'array', 'itemType': ListOTAModuleByProductResponseBodyData },
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAModuleByProductResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListOTAModuleByProductResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListOTAModuleByProductResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAModuleVersionsByDeviceRequest extends $tea.Model {
  currentPage?: number;
  deviceName?: string;
  iotId?: string;
  iotInstanceId?: string;
  pageSize?: number;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      deviceName: 'DeviceName',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      deviceName: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      pageSize: 'number',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAModuleVersionsByDeviceResponseBody extends $tea.Model {
  code?: string;
  currentPage?: number;
  data?: ListOTAModuleVersionsByDeviceResponseBodyData;
  errorMessage?: string;
  pageCount?: number;
  pageSize?: number;
  requestId?: string;
  success?: boolean;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      currentPage: 'CurrentPage',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      pageCount: 'PageCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      currentPage: 'number',
      data: ListOTAModuleVersionsByDeviceResponseBodyData,
      errorMessage: 'string',
      pageCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAModuleVersionsByDeviceResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListOTAModuleVersionsByDeviceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListOTAModuleVersionsByDeviceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTATaskByJobRequest extends $tea.Model {
  currentPage?: number;
  deviceNames?: string[];
  iotInstanceId?: string;
  jobId?: string;
  pageSize?: number;
  taskStatus?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      deviceNames: 'DeviceNames',
      iotInstanceId: 'IotInstanceId',
      jobId: 'JobId',
      pageSize: 'PageSize',
      taskStatus: 'TaskStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      deviceNames: { 'type': 'array', 'itemType': 'string' },
      iotInstanceId: 'string',
      jobId: 'string',
      pageSize: 'number',
      taskStatus: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTATaskByJobResponseBody extends $tea.Model {
  code?: string;
  currentPage?: number;
  data?: ListOTATaskByJobResponseBodyData;
  errorMessage?: string;
  pageCount?: number;
  pageSize?: number;
  requestId?: string;
  success?: boolean;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      currentPage: 'CurrentPage',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      pageCount: 'PageCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      currentPage: 'number',
      data: ListOTATaskByJobResponseBodyData,
      errorMessage: 'string',
      pageCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTATaskByJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListOTATaskByJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListOTATaskByJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAUnfinishedTaskByDeviceRequest extends $tea.Model {
  deviceName?: string;
  iotId?: string;
  iotInstanceId?: string;
  moduleName?: string;
  productKey?: string;
  taskStatus?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      moduleName: 'ModuleName',
      productKey: 'ProductKey',
      taskStatus: 'TaskStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      moduleName: 'string',
      productKey: 'string',
      taskStatus: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAUnfinishedTaskByDeviceResponseBody extends $tea.Model {
  code?: string;
  data?: ListOTAUnfinishedTaskByDeviceResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: ListOTAUnfinishedTaskByDeviceResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAUnfinishedTaskByDeviceResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListOTAUnfinishedTaskByDeviceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListOTAUnfinishedTaskByDeviceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListParserRequest extends $tea.Model {
  currentPage?: number;
  iotInstanceId?: string;
  pageSize?: number;
  searchName?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
      searchName: 'SearchName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      iotInstanceId: 'string',
      pageSize: 'number',
      searchName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListParserResponseBody extends $tea.Model {
  code?: string;
  data?: ListParserResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: ListParserResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListParserResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListParserResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListParserResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListParserDataSourceRequest extends $tea.Model {
  iotInstanceId?: string;
  page?: number;
  pageSize?: number;
  searchName?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      page: 'Page',
      pageSize: 'PageSize',
      searchName: 'SearchName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      page: 'number',
      pageSize: 'number',
      searchName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListParserDataSourceResponseBody extends $tea.Model {
  code?: string;
  data?: ListParserDataSourceResponseBodyData;
  errorMessage?: string;
  page?: number;
  pageSize?: number;
  requestId?: string;
  success?: boolean;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      page: 'Page',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: ListParserDataSourceResponseBodyData,
      errorMessage: 'string',
      page: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListParserDataSourceResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListParserDataSourceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListParserDataSourceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListParserDestinationRequest extends $tea.Model {
  iotInstanceId?: string;
  isFailover?: boolean;
  parserId?: number;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      isFailover: 'IsFailover',
      parserId: 'ParserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      isFailover: 'boolean',
      parserId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListParserDestinationResponseBody extends $tea.Model {
  code?: string;
  data?: ListParserDestinationResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: ListParserDestinationResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListParserDestinationResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListParserDestinationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListParserDestinationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProductByTagsRequest extends $tea.Model {
  currentPage?: number;
  iotInstanceId?: string;
  pageSize?: number;
  productTag?: ListProductByTagsRequestProductTag[];
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
      productTag: 'ProductTag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      iotInstanceId: 'string',
      pageSize: 'number',
      productTag: { 'type': 'array', 'itemType': ListProductByTagsRequestProductTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProductByTagsResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  productInfos?: ListProductByTagsResponseBodyProductInfos;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      productInfos: 'ProductInfos',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      productInfos: ListProductByTagsResponseBodyProductInfos,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProductByTagsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListProductByTagsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListProductByTagsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProductTagsRequest extends $tea.Model {
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProductTagsResponseBody extends $tea.Model {
  code?: string;
  data?: ListProductTagsResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: ListProductTagsResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProductTagsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListProductTagsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListProductTagsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRuleRequest extends $tea.Model {
  currentPage?: number;
  iotInstanceId?: string;
  pageSize?: number;
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      iotInstanceId: 'string',
      pageSize: 'number',
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRuleResponseBody extends $tea.Model {
  code?: string;
  data?: ListRuleResponseBodyData;
  errorMessage?: string;
  page?: number;
  pageSize?: number;
  requestId?: string;
  success?: boolean;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      page: 'Page',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: ListRuleResponseBodyData,
      errorMessage: 'string',
      page: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRuleResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRuleActionsRequest extends $tea.Model {
  iotInstanceId?: string;
  ruleId?: number;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      ruleId: 'RuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      ruleId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRuleActionsResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  ruleActionList?: ListRuleActionsResponseBodyRuleActionList;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      ruleActionList: 'RuleActionList',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      ruleActionList: ListRuleActionsResponseBodyRuleActionList,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRuleActionsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListRuleActionsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListRuleActionsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskRequest extends $tea.Model {
  device?: { [key: string]: any };
  iotInstanceId?: string;
  jobId?: string;
  limit?: number;
  nextToken?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      device: 'Device',
      iotInstanceId: 'IotInstanceId',
      jobId: 'JobId',
      limit: 'Limit',
      nextToken: 'NextToken',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      device: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      iotInstanceId: 'string',
      jobId: 'string',
      limit: 'number',
      nextToken: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskShrinkRequest extends $tea.Model {
  deviceShrink?: string;
  iotInstanceId?: string;
  jobId?: string;
  limit?: number;
  nextToken?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      deviceShrink: 'Device',
      iotInstanceId: 'IotInstanceId',
      jobId: 'JobId',
      limit: 'Limit',
      nextToken: 'NextToken',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceShrink: 'string',
      iotInstanceId: 'string',
      jobId: 'string',
      limit: 'number',
      nextToken: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskResponseBody extends $tea.Model {
  code?: string;
  data?: ListTaskResponseBodyData;
  errorMessage?: string;
  nextToken?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      nextToken: 'NextToken',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: ListTaskResponseBodyData,
      errorMessage: 'string',
      nextToken: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListThingModelVersionRequest extends $tea.Model {
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListThingModelVersionResponseBody extends $tea.Model {
  code?: string;
  data?: ListThingModelVersionResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: ListThingModelVersionResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListThingModelVersionResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListThingModelVersionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListThingModelVersionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListThingTemplatesRequest extends $tea.Model {
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListThingTemplatesResponseBody extends $tea.Model {
  code?: string;
  data?: ListThingTemplatesResponseBodyData[];
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: { 'type': 'array', 'itemType': ListThingTemplatesResponseBodyData },
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListThingTemplatesResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListThingTemplatesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListThingTemplatesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class NotifyAddThingTopoRequest extends $tea.Model {
  deviceListStr?: string;
  gwDeviceName?: string;
  gwIotId?: string;
  gwProductKey?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      deviceListStr: 'DeviceListStr',
      gwDeviceName: 'GwDeviceName',
      gwIotId: 'GwIotId',
      gwProductKey: 'GwProductKey',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceListStr: 'string',
      gwDeviceName: 'string',
      gwIotId: 'string',
      gwProductKey: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class NotifyAddThingTopoResponseBody extends $tea.Model {
  code?: string;
  data?: NotifyAddThingTopoResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: NotifyAddThingTopoResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class NotifyAddThingTopoResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: NotifyAddThingTopoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: NotifyAddThingTopoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OpenIotServiceRequest extends $tea.Model {
  ownerId?: number;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OpenIotServiceResponseBody extends $tea.Model {
  orderId?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OpenIotServiceResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: OpenIotServiceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: OpenIotServiceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PackageSoundCodeLabelBatchAudioRequest extends $tea.Model {
  batchCode?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      batchCode: 'BatchCode',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      batchCode: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PackageSoundCodeLabelBatchAudioResponseBody extends $tea.Model {
  code?: string;
  data?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PackageSoundCodeLabelBatchAudioResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: PackageSoundCodeLabelBatchAudioResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: PackageSoundCodeLabelBatchAudioResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PageQuerySharedSpeechOpenRequest extends $tea.Model {
  deviceName?: string;
  iotId?: string;
  iotInstanceId?: string;
  pageId?: number;
  pageSize?: number;
  productKey?: string;
  shareTaskCode?: string;
  status?: number;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      pageId: 'PageId',
      pageSize: 'PageSize',
      productKey: 'ProductKey',
      shareTaskCode: 'ShareTaskCode',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      pageId: 'number',
      pageSize: 'number',
      productKey: 'string',
      shareTaskCode: 'string',
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PageQuerySharedSpeechOpenResponseBody extends $tea.Model {
  code?: string;
  data?: PageQuerySharedSpeechOpenResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: PageQuerySharedSpeechOpenResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PageQuerySharedSpeechOpenResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: PageQuerySharedSpeechOpenResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: PageQuerySharedSpeechOpenResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PageQuerySpeechBroadcastHourRequest extends $tea.Model {
  iotInstanceId?: string;
  pageSize?: number;
  pageToken?: string;
  queryDateTimeHour?: string;
  shareTaskCode?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
      pageToken: 'PageToken',
      queryDateTimeHour: 'QueryDateTimeHour',
      shareTaskCode: 'ShareTaskCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      pageSize: 'number',
      pageToken: 'string',
      queryDateTimeHour: 'string',
      shareTaskCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PageQuerySpeechBroadcastHourResponseBody extends $tea.Model {
  code?: string;
  data?: PageQuerySpeechBroadcastHourResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: PageQuerySpeechBroadcastHourResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PageQuerySpeechBroadcastHourResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: PageQuerySpeechBroadcastHourResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: PageQuerySpeechBroadcastHourResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PrintByTemplateRequest extends $tea.Model {
  deviceName?: string;
  historyPrintTopic?: boolean;
  iotId?: string;
  iotInstanceId?: string;
  paramsJsonString?: string;
  productKey?: string;
  templateBizCode?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      historyPrintTopic: 'HistoryPrintTopic',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      paramsJsonString: 'ParamsJsonString',
      productKey: 'ProductKey',
      templateBizCode: 'TemplateBizCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      historyPrintTopic: 'boolean',
      iotId: 'string',
      iotInstanceId: 'string',
      paramsJsonString: 'string',
      productKey: 'string',
      templateBizCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PrintByTemplateResponseBody extends $tea.Model {
  code?: string;
  data?: PrintByTemplateResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: PrintByTemplateResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PrintByTemplateResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: PrintByTemplateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: PrintByTemplateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PubRequest extends $tea.Model {
  contentType?: string;
  correlationData?: string;
  deviceName?: string;
  iotInstanceId?: string;
  messageContent?: string;
  messageExpiryInterval?: number;
  payloadFormatIndicator?: number;
  productKey?: string;
  qos?: number;
  responseTopic?: string;
  retained?: boolean;
  topicFullName?: string;
  userProp?: PubRequestUserProp[];
  static names(): { [key: string]: string } {
    return {
      contentType: 'ContentType',
      correlationData: 'CorrelationData',
      deviceName: 'DeviceName',
      iotInstanceId: 'IotInstanceId',
      messageContent: 'MessageContent',
      messageExpiryInterval: 'MessageExpiryInterval',
      payloadFormatIndicator: 'PayloadFormatIndicator',
      productKey: 'ProductKey',
      qos: 'Qos',
      responseTopic: 'ResponseTopic',
      retained: 'Retained',
      topicFullName: 'TopicFullName',
      userProp: 'UserProp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contentType: 'string',
      correlationData: 'string',
      deviceName: 'string',
      iotInstanceId: 'string',
      messageContent: 'string',
      messageExpiryInterval: 'number',
      payloadFormatIndicator: 'number',
      productKey: 'string',
      qos: 'number',
      responseTopic: 'string',
      retained: 'boolean',
      topicFullName: 'string',
      userProp: { 'type': 'array', 'itemType': PubRequestUserProp },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PubResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  messageId?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      messageId: 'MessageId',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      messageId: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PubResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: PubResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: PubResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PubBroadcastRequest extends $tea.Model {
  iotInstanceId?: string;
  messageContent?: string;
  productKey?: string;
  topicFullName?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      messageContent: 'MessageContent',
      productKey: 'ProductKey',
      topicFullName: 'TopicFullName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      messageContent: 'string',
      productKey: 'string',
      topicFullName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PubBroadcastResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  messageId?: number;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      messageId: 'MessageId',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      messageId: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PubBroadcastResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: PubBroadcastResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: PubBroadcastResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PublishScriptRequest extends $tea.Model {
  iotInstanceId?: string;
  parserId?: number;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      parserId: 'ParserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      parserId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PublishScriptResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  syntaxErrorMsg?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      syntaxErrorMsg: 'SyntaxErrorMsg',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      syntaxErrorMsg: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PublishScriptResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: PublishScriptResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: PublishScriptResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PublishStudioAppRequest extends $tea.Model {
  appId?: string;
  description?: string;
  iotInstanceId?: string;
  projectId?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      description: 'Description',
      iotInstanceId: 'IotInstanceId',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      description: 'string',
      iotInstanceId: 'string',
      projectId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PublishStudioAppResponseBody extends $tea.Model {
  code?: string;
  data?: boolean;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'boolean',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PublishStudioAppResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: PublishStudioAppResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: PublishStudioAppResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PublishThingModelRequest extends $tea.Model {
  description?: string;
  iotInstanceId?: string;
  modelVersion?: string;
  productKey?: string;
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      iotInstanceId: 'IotInstanceId',
      modelVersion: 'ModelVersion',
      productKey: 'ProductKey',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      iotInstanceId: 'string',
      modelVersion: 'string',
      productKey: 'string',
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PublishThingModelResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PublishThingModelResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: PublishThingModelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: PublishThingModelResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PushSpeechRequest extends $tea.Model {
  deviceName?: string;
  groupId?: string;
  iotId?: string;
  iotInstanceId?: string;
  productKey?: string;
  projectCode?: string;
  pushMode?: string;
  speechCodeList?: string[];
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      groupId: 'GroupId',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
      projectCode: 'ProjectCode',
      pushMode: 'PushMode',
      speechCodeList: 'SpeechCodeList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      groupId: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
      projectCode: 'string',
      pushMode: 'string',
      speechCodeList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PushSpeechResponseBody extends $tea.Model {
  code?: string;
  data?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PushSpeechResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: PushSpeechResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: PushSpeechResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryBatchRegisterDeviceStatusRequest extends $tea.Model {
  applyId?: number;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      applyId: 'ApplyId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applyId: 'number',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryBatchRegisterDeviceStatusResponseBody extends $tea.Model {
  code?: string;
  data?: QueryBatchRegisterDeviceStatusResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryBatchRegisterDeviceStatusResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryBatchRegisterDeviceStatusResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryBatchRegisterDeviceStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryBatchRegisterDeviceStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCertUrlByApplyIdRequest extends $tea.Model {
  applyId?: number;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      applyId: 'ApplyId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applyId: 'number',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCertUrlByApplyIdResponseBody extends $tea.Model {
  certUrl?: string;
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      certUrl: 'CertUrl',
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      certUrl: 'string',
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCertUrlByApplyIdResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryCertUrlByApplyIdResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryCertUrlByApplyIdResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryClientIdsRequest extends $tea.Model {
  iotId?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryClientIdsResponseBody extends $tea.Model {
  code?: string;
  data?: QueryClientIdsResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryClientIdsResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryClientIdsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryClientIdsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryClientIdsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryConsumerGroupByGroupIdRequest extends $tea.Model {
  groupId?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryConsumerGroupByGroupIdResponseBody extends $tea.Model {
  code?: string;
  data?: QueryConsumerGroupByGroupIdResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryConsumerGroupByGroupIdResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryConsumerGroupByGroupIdResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryConsumerGroupByGroupIdResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryConsumerGroupByGroupIdResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryConsumerGroupListRequest extends $tea.Model {
  currentPage?: number;
  fuzzy?: boolean;
  groupName?: string;
  iotInstanceId?: string;
  pageSize?: number;
  subBizCode?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      fuzzy: 'Fuzzy',
      groupName: 'GroupName',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
      subBizCode: 'SubBizCode',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      fuzzy: 'boolean',
      groupName: 'string',
      iotInstanceId: 'string',
      pageSize: 'number',
      subBizCode: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryConsumerGroupListResponseBody extends $tea.Model {
  code?: string;
  currentPage?: number;
  data?: QueryConsumerGroupListResponseBodyData;
  errorMessage?: string;
  pageCount?: number;
  pageSize?: number;
  requestId?: string;
  success?: boolean;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      currentPage: 'CurrentPage',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      pageCount: 'PageCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      currentPage: 'number',
      data: QueryConsumerGroupListResponseBodyData,
      errorMessage: 'string',
      pageCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryConsumerGroupListResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryConsumerGroupListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryConsumerGroupListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryConsumerGroupStatusRequest extends $tea.Model {
  groupId?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryConsumerGroupStatusResponseBody extends $tea.Model {
  accumulatedConsumeCountPerMinute?: number;
  accumulationCount?: number;
  clientConnectionStatusList?: QueryConsumerGroupStatusResponseBodyClientConnectionStatusList;
  code?: string;
  consumerSpeed?: number;
  errorMessage?: string;
  lastConsumerTime?: string;
  realTimeConsumeCountPerMinute?: number;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      accumulatedConsumeCountPerMinute: 'AccumulatedConsumeCountPerMinute',
      accumulationCount: 'AccumulationCount',
      clientConnectionStatusList: 'ClientConnectionStatusList',
      code: 'Code',
      consumerSpeed: 'ConsumerSpeed',
      errorMessage: 'ErrorMessage',
      lastConsumerTime: 'LastConsumerTime',
      realTimeConsumeCountPerMinute: 'RealTimeConsumeCountPerMinute',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accumulatedConsumeCountPerMinute: 'number',
      accumulationCount: 'number',
      clientConnectionStatusList: QueryConsumerGroupStatusResponseBodyClientConnectionStatusList,
      code: 'string',
      consumerSpeed: 'number',
      errorMessage: 'string',
      lastConsumerTime: 'string',
      realTimeConsumeCountPerMinute: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryConsumerGroupStatusResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryConsumerGroupStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryConsumerGroupStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDetailSceneRuleLogRequest extends $tea.Model {
  currentPage?: number;
  endTime?: number;
  iotInstanceId?: string;
  pageSize?: number;
  ruleId?: string;
  startTime?: number;
  traceId?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      endTime: 'EndTime',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
      ruleId: 'RuleId',
      startTime: 'StartTime',
      traceId: 'TraceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      endTime: 'number',
      iotInstanceId: 'string',
      pageSize: 'number',
      ruleId: 'string',
      startTime: 'number',
      traceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDetailSceneRuleLogResponseBody extends $tea.Model {
  code?: string;
  data?: QueryDetailSceneRuleLogResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryDetailSceneRuleLogResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDetailSceneRuleLogResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryDetailSceneRuleLogResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryDetailSceneRuleLogResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceRequest extends $tea.Model {
  currentPage?: number;
  iotInstanceId?: string;
  nextToken?: string;
  pageSize?: number;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      iotInstanceId: 'IotInstanceId',
      nextToken: 'NextToken',
      pageSize: 'PageSize',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      iotInstanceId: 'string',
      nextToken: 'string',
      pageSize: 'number',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceResponseBody extends $tea.Model {
  code?: string;
  data?: QueryDeviceResponseBodyData;
  errorMessage?: string;
  nextToken?: string;
  page?: number;
  pageCount?: number;
  pageSize?: number;
  requestId?: string;
  success?: boolean;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      nextToken: 'NextToken',
      page: 'Page',
      pageCount: 'PageCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryDeviceResponseBodyData,
      errorMessage: 'string',
      nextToken: 'string',
      page: 'number',
      pageCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryDeviceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryDeviceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceBySQLRequest extends $tea.Model {
  iotInstanceId?: string;
  SQL?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      SQL: 'SQL',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      SQL: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceBySQLResponseBody extends $tea.Model {
  code?: string;
  data?: QueryDeviceBySQLResponseBodyData[];
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: { 'type': 'array', 'itemType': QueryDeviceBySQLResponseBodyData },
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceBySQLResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryDeviceBySQLResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryDeviceBySQLResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceByStatusRequest extends $tea.Model {
  currentPage?: number;
  iotInstanceId?: string;
  pageSize?: number;
  productKey?: string;
  resourceGroupId?: string;
  status?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
      productKey: 'ProductKey',
      resourceGroupId: 'ResourceGroupId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      iotInstanceId: 'string',
      pageSize: 'number',
      productKey: 'string',
      resourceGroupId: 'string',
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceByStatusResponseBody extends $tea.Model {
  code?: string;
  data?: QueryDeviceByStatusResponseBodyData;
  errorMessage?: string;
  page?: number;
  pageCount?: number;
  pageSize?: number;
  requestId?: string;
  success?: boolean;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      page: 'Page',
      pageCount: 'PageCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryDeviceByStatusResponseBodyData,
      errorMessage: 'string',
      page: 'number',
      pageCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceByStatusResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryDeviceByStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryDeviceByStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceByTagsRequest extends $tea.Model {
  currentPage?: number;
  iotInstanceId?: string;
  pageSize?: number;
  tag?: QueryDeviceByTagsRequestTag[];
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      iotInstanceId: 'string',
      pageSize: 'number',
      tag: { 'type': 'array', 'itemType': QueryDeviceByTagsRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceByTagsResponseBody extends $tea.Model {
  code?: string;
  data?: QueryDeviceByTagsResponseBodyData;
  errorMessage?: string;
  page?: number;
  pageCount?: number;
  pageSize?: number;
  requestId?: string;
  success?: boolean;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      page: 'Page',
      pageCount: 'PageCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryDeviceByTagsResponseBodyData,
      errorMessage: 'string',
      page: 'number',
      pageCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceByTagsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryDeviceByTagsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryDeviceByTagsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceCertRequest extends $tea.Model {
  deviceName?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceCertResponseBody extends $tea.Model {
  code?: string;
  deviceCertInfo?: QueryDeviceCertResponseBodyDeviceCertInfo;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      deviceCertInfo: 'DeviceCertInfo',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      deviceCertInfo: QueryDeviceCertResponseBodyDeviceCertInfo,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceCertResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryDeviceCertResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryDeviceCertResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceDesiredPropertyRequest extends $tea.Model {
  deviceName?: string;
  functionBlockId?: string;
  identifier?: string[];
  iotId?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      functionBlockId: 'FunctionBlockId',
      identifier: 'Identifier',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      functionBlockId: 'string',
      identifier: { 'type': 'array', 'itemType': 'string' },
      iotId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceDesiredPropertyResponseBody extends $tea.Model {
  code?: string;
  data?: QueryDeviceDesiredPropertyResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryDeviceDesiredPropertyResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceDesiredPropertyResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryDeviceDesiredPropertyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryDeviceDesiredPropertyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceDetailRequest extends $tea.Model {
  deviceName?: string;
  iotId?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceDetailResponseBody extends $tea.Model {
  code?: string;
  data?: QueryDeviceDetailResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryDeviceDetailResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceDetailResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryDeviceDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryDeviceDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceDistributeDetailRequest extends $tea.Model {
  jobId?: string;
  static names(): { [key: string]: string } {
    return {
      jobId: 'JobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      jobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceDistributeDetailResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  file?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      file: 'File',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      file: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceDistributeDetailResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryDeviceDistributeDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryDeviceDistributeDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceDistributeJobRequest extends $tea.Model {
  jobId?: string;
  static names(): { [key: string]: string } {
    return {
      jobId: 'JobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      jobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceDistributeJobResponseBody extends $tea.Model {
  code?: string;
  data?: QueryDeviceDistributeJobResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryDeviceDistributeJobResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceDistributeJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryDeviceDistributeJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryDeviceDistributeJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceEventDataRequest extends $tea.Model {
  asc?: number;
  deviceName?: string;
  endTime?: number;
  eventType?: string;
  identifier?: string;
  iotId?: string;
  iotInstanceId?: string;
  pageSize?: number;
  productKey?: string;
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      asc: 'Asc',
      deviceName: 'DeviceName',
      endTime: 'EndTime',
      eventType: 'EventType',
      identifier: 'Identifier',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
      productKey: 'ProductKey',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      asc: 'number',
      deviceName: 'string',
      endTime: 'number',
      eventType: 'string',
      identifier: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      pageSize: 'number',
      productKey: 'string',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceEventDataResponseBody extends $tea.Model {
  code?: string;
  data?: QueryDeviceEventDataResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryDeviceEventDataResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceEventDataResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryDeviceEventDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryDeviceEventDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceFileRequest extends $tea.Model {
  deviceName?: string;
  fileId?: string;
  iotId?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      fileId: 'FileId',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      fileId: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceFileResponseBody extends $tea.Model {
  code?: string;
  data?: QueryDeviceFileResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryDeviceFileResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceFileResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryDeviceFileResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryDeviceFileResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceFileListRequest extends $tea.Model {
  currentPage?: number;
  deviceName?: string;
  iotId?: string;
  iotInstanceId?: string;
  pageSize?: number;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      deviceName: 'DeviceName',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      deviceName: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      pageSize: 'number',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceFileListResponseBody extends $tea.Model {
  code?: string;
  currentPage?: number;
  data?: QueryDeviceFileListResponseBodyData;
  errorMessage?: string;
  pageCount?: number;
  pageSize?: number;
  requestId?: string;
  success?: boolean;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      currentPage: 'CurrentPage',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      pageCount: 'PageCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      currentPage: 'number',
      data: QueryDeviceFileListResponseBodyData,
      errorMessage: 'string',
      pageCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceFileListResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryDeviceFileListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryDeviceFileListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceGroupByDeviceRequest extends $tea.Model {
  deviceName?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceGroupByDeviceResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  groupInfos?: QueryDeviceGroupByDeviceResponseBodyGroupInfos;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      groupInfos: 'GroupInfos',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      groupInfos: QueryDeviceGroupByDeviceResponseBodyGroupInfos,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceGroupByDeviceResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryDeviceGroupByDeviceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryDeviceGroupByDeviceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceGroupByTagsRequest extends $tea.Model {
  currentPage?: number;
  iotInstanceId?: string;
  pageSize?: number;
  tag?: QueryDeviceGroupByTagsRequestTag[];
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      iotInstanceId: 'string',
      pageSize: 'number',
      tag: { 'type': 'array', 'itemType': QueryDeviceGroupByTagsRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceGroupByTagsResponseBody extends $tea.Model {
  code?: string;
  data?: QueryDeviceGroupByTagsResponseBodyData;
  errorMessage?: string;
  page?: number;
  pageCount?: number;
  pageSize?: number;
  requestId?: string;
  success?: boolean;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      page: 'Page',
      pageCount: 'PageCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryDeviceGroupByTagsResponseBodyData,
      errorMessage: 'string',
      page: 'number',
      pageCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceGroupByTagsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryDeviceGroupByTagsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryDeviceGroupByTagsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceGroupInfoRequest extends $tea.Model {
  groupId?: string;
  groupType?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      groupType: 'GroupType',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      groupType: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceGroupInfoResponseBody extends $tea.Model {
  code?: string;
  data?: QueryDeviceGroupInfoResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryDeviceGroupInfoResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceGroupInfoResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryDeviceGroupInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryDeviceGroupInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceGroupListRequest extends $tea.Model {
  currentPage?: number;
  groupName?: string;
  groupTypes?: string[];
  iotInstanceId?: string;
  pageSize?: number;
  superGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      groupName: 'GroupName',
      groupTypes: 'GroupTypes',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
      superGroupId: 'SuperGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      groupName: 'string',
      groupTypes: { 'type': 'array', 'itemType': 'string' },
      iotInstanceId: 'string',
      pageSize: 'number',
      superGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceGroupListResponseBody extends $tea.Model {
  code?: string;
  currentPage?: number;
  data?: QueryDeviceGroupListResponseBodyData;
  errorMessage?: string;
  pageCount?: number;
  pageSize?: number;
  requestId?: string;
  success?: boolean;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      currentPage: 'CurrentPage',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      pageCount: 'PageCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      currentPage: 'number',
      data: QueryDeviceGroupListResponseBodyData,
      errorMessage: 'string',
      pageCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceGroupListResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryDeviceGroupListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryDeviceGroupListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceGroupTagListRequest extends $tea.Model {
  groupId?: string;
  groupType?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      groupType: 'GroupType',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      groupType: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceGroupTagListResponseBody extends $tea.Model {
  code?: string;
  data?: QueryDeviceGroupTagListResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryDeviceGroupTagListResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceGroupTagListResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryDeviceGroupTagListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryDeviceGroupTagListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceInfoRequest extends $tea.Model {
  deviceName?: string;
  iotId?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceInfoResponseBody extends $tea.Model {
  code?: string;
  data?: QueryDeviceInfoResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryDeviceInfoResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceInfoResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryDeviceInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryDeviceInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceListByDeviceGroupRequest extends $tea.Model {
  currentPage?: number;
  groupId?: string;
  iotInstanceId?: string;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      groupId: 'GroupId',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      groupId: 'string',
      iotInstanceId: 'string',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceListByDeviceGroupResponseBody extends $tea.Model {
  code?: string;
  data?: QueryDeviceListByDeviceGroupResponseBodyData;
  errorMessage?: string;
  page?: number;
  pageCount?: number;
  pageSize?: number;
  requestId?: string;
  success?: boolean;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      page: 'Page',
      pageCount: 'PageCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryDeviceListByDeviceGroupResponseBodyData,
      errorMessage: 'string',
      page: 'number',
      pageCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceListByDeviceGroupResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryDeviceListByDeviceGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryDeviceListByDeviceGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceOriginalEventDataRequest extends $tea.Model {
  asc?: number;
  deviceName?: string;
  endTime?: number;
  identifier?: string;
  iotId?: string;
  iotInstanceId?: string;
  nextPageToken?: string;
  pageSize?: number;
  productKey?: string;
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      asc: 'Asc',
      deviceName: 'DeviceName',
      endTime: 'EndTime',
      identifier: 'Identifier',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      nextPageToken: 'NextPageToken',
      pageSize: 'PageSize',
      productKey: 'ProductKey',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      asc: 'number',
      deviceName: 'string',
      endTime: 'number',
      identifier: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      nextPageToken: 'string',
      pageSize: 'number',
      productKey: 'string',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceOriginalEventDataResponseBody extends $tea.Model {
  code?: string;
  data?: QueryDeviceOriginalEventDataResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryDeviceOriginalEventDataResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceOriginalEventDataResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryDeviceOriginalEventDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryDeviceOriginalEventDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceOriginalPropertyDataRequest extends $tea.Model {
  asc?: number;
  deviceName?: string;
  endTime?: number;
  identifier?: string;
  iotId?: string;
  iotInstanceId?: string;
  nextPageToken?: string;
  pageSize?: number;
  productKey?: string;
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      asc: 'Asc',
      deviceName: 'DeviceName',
      endTime: 'EndTime',
      identifier: 'Identifier',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      nextPageToken: 'NextPageToken',
      pageSize: 'PageSize',
      productKey: 'ProductKey',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      asc: 'number',
      deviceName: 'string',
      endTime: 'number',
      identifier: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      nextPageToken: 'string',
      pageSize: 'number',
      productKey: 'string',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceOriginalPropertyDataResponseBody extends $tea.Model {
  code?: string;
  data?: QueryDeviceOriginalPropertyDataResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryDeviceOriginalPropertyDataResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceOriginalPropertyDataResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryDeviceOriginalPropertyDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryDeviceOriginalPropertyDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceOriginalPropertyStatusRequest extends $tea.Model {
  asc?: number;
  deviceName?: string;
  iotId?: string;
  iotInstanceId?: string;
  nextPageToken?: string;
  pageSize?: number;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      asc: 'Asc',
      deviceName: 'DeviceName',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      nextPageToken: 'NextPageToken',
      pageSize: 'PageSize',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      asc: 'number',
      deviceName: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      nextPageToken: 'string',
      pageSize: 'number',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceOriginalPropertyStatusResponseBody extends $tea.Model {
  code?: string;
  data?: QueryDeviceOriginalPropertyStatusResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryDeviceOriginalPropertyStatusResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceOriginalPropertyStatusResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryDeviceOriginalPropertyStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryDeviceOriginalPropertyStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceOriginalServiceDataRequest extends $tea.Model {
  asc?: number;
  deviceName?: string;
  endTime?: number;
  identifier?: string;
  iotId?: string;
  iotInstanceId?: string;
  nextPageToken?: string;
  pageSize?: number;
  productKey?: string;
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      asc: 'Asc',
      deviceName: 'DeviceName',
      endTime: 'EndTime',
      identifier: 'Identifier',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      nextPageToken: 'NextPageToken',
      pageSize: 'PageSize',
      productKey: 'ProductKey',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      asc: 'number',
      deviceName: 'string',
      endTime: 'number',
      identifier: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      nextPageToken: 'string',
      pageSize: 'number',
      productKey: 'string',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceOriginalServiceDataResponseBody extends $tea.Model {
  code?: string;
  data?: QueryDeviceOriginalServiceDataResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryDeviceOriginalServiceDataResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceOriginalServiceDataResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryDeviceOriginalServiceDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryDeviceOriginalServiceDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicePropRequest extends $tea.Model {
  deviceName?: string;
  iotId?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicePropResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  props?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      props: 'Props',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      props: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicePropResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryDevicePropResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryDevicePropResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicePropertiesDataRequest extends $tea.Model {
  asc?: number;
  deviceName?: string;
  endTime?: number;
  identifier?: string[];
  iotId?: string;
  iotInstanceId?: string;
  pageSize?: number;
  productKey?: string;
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      asc: 'Asc',
      deviceName: 'DeviceName',
      endTime: 'EndTime',
      identifier: 'Identifier',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
      productKey: 'ProductKey',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      asc: 'number',
      deviceName: 'string',
      endTime: 'number',
      identifier: { 'type': 'array', 'itemType': 'string' },
      iotId: 'string',
      iotInstanceId: 'string',
      pageSize: 'number',
      productKey: 'string',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicePropertiesDataResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  nextTime?: number;
  nextValid?: boolean;
  propertyDataInfos?: QueryDevicePropertiesDataResponseBodyPropertyDataInfos;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      nextTime: 'NextTime',
      nextValid: 'NextValid',
      propertyDataInfos: 'PropertyDataInfos',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      nextTime: 'number',
      nextValid: 'boolean',
      propertyDataInfos: QueryDevicePropertiesDataResponseBodyPropertyDataInfos,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicePropertiesDataResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryDevicePropertiesDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryDevicePropertiesDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicePropertyDataRequest extends $tea.Model {
  asc?: number;
  deviceName?: string;
  endTime?: number;
  identifier?: string;
  iotId?: string;
  iotInstanceId?: string;
  pageSize?: number;
  productKey?: string;
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      asc: 'Asc',
      deviceName: 'DeviceName',
      endTime: 'EndTime',
      identifier: 'Identifier',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
      productKey: 'ProductKey',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      asc: 'number',
      deviceName: 'string',
      endTime: 'number',
      identifier: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      pageSize: 'number',
      productKey: 'string',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicePropertyDataResponseBody extends $tea.Model {
  code?: string;
  data?: QueryDevicePropertyDataResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryDevicePropertyDataResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicePropertyDataResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryDevicePropertyDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryDevicePropertyDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicePropertyStatusRequest extends $tea.Model {
  deviceName?: string;
  functionBlockId?: string;
  iotId?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      functionBlockId: 'FunctionBlockId',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      functionBlockId: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicePropertyStatusResponseBody extends $tea.Model {
  code?: string;
  data?: QueryDevicePropertyStatusResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryDevicePropertyStatusResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicePropertyStatusResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryDevicePropertyStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryDevicePropertyStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceProvisioningRequest extends $tea.Model {
  deviceName?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceProvisioningResponseBody extends $tea.Model {
  code?: string;
  data?: QueryDeviceProvisioningResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryDeviceProvisioningResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceProvisioningResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryDeviceProvisioningResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryDeviceProvisioningResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceServiceDataRequest extends $tea.Model {
  asc?: number;
  deviceName?: string;
  endTime?: number;
  identifier?: string;
  iotId?: string;
  iotInstanceId?: string;
  pageSize?: number;
  productKey?: string;
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      asc: 'Asc',
      deviceName: 'DeviceName',
      endTime: 'EndTime',
      identifier: 'Identifier',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
      productKey: 'ProductKey',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      asc: 'number',
      deviceName: 'string',
      endTime: 'number',
      identifier: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      pageSize: 'number',
      productKey: 'string',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceServiceDataResponseBody extends $tea.Model {
  code?: string;
  data?: QueryDeviceServiceDataResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryDeviceServiceDataResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceServiceDataResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryDeviceServiceDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryDeviceServiceDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceSpeechRequest extends $tea.Model {
  iotId?: string;
  iotInstanceId?: string;
  pageId?: number;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      pageId: 'PageId',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotId: 'string',
      iotInstanceId: 'string',
      pageId: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceSpeechResponseBody extends $tea.Model {
  code?: string;
  data?: QueryDeviceSpeechResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryDeviceSpeechResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceSpeechResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryDeviceSpeechResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryDeviceSpeechResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceStatisticsRequest extends $tea.Model {
  groupId?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceStatisticsResponseBody extends $tea.Model {
  code?: string;
  data?: QueryDeviceStatisticsResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryDeviceStatisticsResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceStatisticsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryDeviceStatisticsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryDeviceStatisticsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceSubTopicRequest extends $tea.Model {
  deviceName?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceSubTopicResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  topicList?: QueryDeviceSubTopicResponseBodyTopicList[];
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      topicList: 'TopicList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      topicList: { 'type': 'array', 'itemType': QueryDeviceSubTopicResponseBodyTopicList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceSubTopicResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryDeviceSubTopicResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryDeviceSubTopicResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceTunnelRequest extends $tea.Model {
  iotInstanceId?: string;
  tunnelId?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      tunnelId: 'TunnelId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      tunnelId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceTunnelResponseBody extends $tea.Model {
  code?: string;
  data?: QueryDeviceTunnelResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryDeviceTunnelResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceTunnelResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryDeviceTunnelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryDeviceTunnelResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicesHotStorageDataRequest extends $tea.Model {
  asc?: number;
  deviceName?: string;
  endTime?: number;
  identifier?: string;
  iotId?: string;
  iotInstanceId?: string;
  nextPageToken?: string;
  pageSize?: number;
  productKey?: string;
  startTime?: number;
  userTopic?: string;
  static names(): { [key: string]: string } {
    return {
      asc: 'Asc',
      deviceName: 'DeviceName',
      endTime: 'EndTime',
      identifier: 'Identifier',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      nextPageToken: 'NextPageToken',
      pageSize: 'PageSize',
      productKey: 'ProductKey',
      startTime: 'StartTime',
      userTopic: 'UserTopic',
    };
  }

  static types(): { [key: string]: any } {
    return {
      asc: 'number',
      deviceName: 'string',
      endTime: 'number',
      identifier: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      nextPageToken: 'string',
      pageSize: 'number',
      productKey: 'string',
      startTime: 'number',
      userTopic: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicesHotStorageDataResponseBody extends $tea.Model {
  code?: string;
  data?: QueryDevicesHotStorageDataResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryDevicesHotStorageDataResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicesHotStorageDataResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryDevicesHotStorageDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryDevicesHotStorageDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicesHotStorageDataStatusRequest extends $tea.Model {
  asc?: number;
  deviceName?: string;
  iotId?: string;
  iotInstanceId?: string;
  nextPageToken?: string;
  pageSize?: number;
  productKey?: string;
  userTopic?: string;
  static names(): { [key: string]: string } {
    return {
      asc: 'Asc',
      deviceName: 'DeviceName',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      nextPageToken: 'NextPageToken',
      pageSize: 'PageSize',
      productKey: 'ProductKey',
      userTopic: 'UserTopic',
    };
  }

  static types(): { [key: string]: any } {
    return {
      asc: 'number',
      deviceName: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      nextPageToken: 'string',
      pageSize: 'number',
      productKey: 'string',
      userTopic: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicesHotStorageDataStatusResponseBody extends $tea.Model {
  code?: string;
  data?: QueryDevicesHotStorageDataStatusResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryDevicesHotStorageDataStatusResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicesHotStorageDataStatusResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryDevicesHotStorageDataStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryDevicesHotStorageDataStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDynamicGroupDevicesRequest extends $tea.Model {
  currentPage?: number;
  deviceName?: string;
  fuzzyName?: boolean;
  groupId?: string;
  iotInstanceId?: string;
  nextToken?: string;
  pageSize?: number;
  productKey?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      deviceName: 'DeviceName',
      fuzzyName: 'FuzzyName',
      groupId: 'GroupId',
      iotInstanceId: 'IotInstanceId',
      nextToken: 'NextToken',
      pageSize: 'PageSize',
      productKey: 'ProductKey',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      deviceName: 'string',
      fuzzyName: 'boolean',
      groupId: 'string',
      iotInstanceId: 'string',
      nextToken: 'string',
      pageSize: 'number',
      productKey: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDynamicGroupDevicesResponseBody extends $tea.Model {
  code?: string;
  data?: QueryDynamicGroupDevicesResponseBodyData;
  errorMessage?: string;
  nextToken?: string;
  page?: number;
  pageCount?: number;
  pageSize?: number;
  requestId?: string;
  success?: boolean;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      nextToken: 'NextToken',
      page: 'Page',
      pageCount: 'PageCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryDynamicGroupDevicesResponseBodyData,
      errorMessage: 'string',
      nextToken: 'string',
      page: 'number',
      pageCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDynamicGroupDevicesResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryDynamicGroupDevicesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryDynamicGroupDevicesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeDriverRequest extends $tea.Model {
  currentPage?: number;
  driverName?: string;
  iotInstanceId?: string;
  pageSize?: number;
  type?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      driverName: 'DriverName',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      driverName: 'string',
      iotInstanceId: 'string',
      pageSize: 'number',
      type: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeDriverResponseBody extends $tea.Model {
  code?: string;
  data?: QueryEdgeDriverResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryEdgeDriverResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeDriverResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryEdgeDriverResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryEdgeDriverResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeDriverVersionRequest extends $tea.Model {
  currentPage?: number;
  driverId?: string;
  driverVersion?: string;
  iotInstanceId?: string;
  pageSize?: number;
  versionState?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      driverId: 'DriverId',
      driverVersion: 'DriverVersion',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
      versionState: 'VersionState',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      driverId: 'string',
      driverVersion: 'string',
      iotInstanceId: 'string',
      pageSize: 'number',
      versionState: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeDriverVersionResponseBody extends $tea.Model {
  code?: string;
  data?: QueryEdgeDriverVersionResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryEdgeDriverVersionResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeDriverVersionResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryEdgeDriverVersionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryEdgeDriverVersionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceRequest extends $tea.Model {
  currentPage?: number;
  iotInstanceId?: string;
  name?: string;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      iotInstanceId: 'IotInstanceId',
      name: 'Name',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      iotInstanceId: 'string',
      name: 'string',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceResponseBody extends $tea.Model {
  code?: string;
  data?: QueryEdgeInstanceResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryEdgeInstanceResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryEdgeInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryEdgeInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceChannelRequest extends $tea.Model {
  channelName?: string;
  currentPage?: number;
  driverId?: string;
  instanceId?: string;
  iotInstanceId?: string;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      channelName: 'ChannelName',
      currentPage: 'CurrentPage',
      driverId: 'DriverId',
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelName: 'string',
      currentPage: 'number',
      driverId: 'string',
      instanceId: 'string',
      iotInstanceId: 'string',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceChannelResponseBody extends $tea.Model {
  code?: string;
  data?: QueryEdgeInstanceChannelResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryEdgeInstanceChannelResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceChannelResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryEdgeInstanceChannelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryEdgeInstanceChannelResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceDeviceRequest extends $tea.Model {
  currentPage?: number;
  instanceId?: string;
  iotInstanceId?: string;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      instanceId: 'string',
      iotInstanceId: 'string',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceDeviceResponseBody extends $tea.Model {
  code?: string;
  data?: QueryEdgeInstanceDeviceResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryEdgeInstanceDeviceResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceDeviceResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryEdgeInstanceDeviceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryEdgeInstanceDeviceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceDeviceByDriverRequest extends $tea.Model {
  channelId?: string;
  currentPage?: number;
  driverId?: string;
  instanceId?: string;
  iotInstanceId?: string;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      channelId: 'ChannelId',
      currentPage: 'CurrentPage',
      driverId: 'DriverId',
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelId: 'string',
      currentPage: 'number',
      driverId: 'string',
      instanceId: 'string',
      iotInstanceId: 'string',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceDeviceByDriverResponseBody extends $tea.Model {
  code?: string;
  data?: QueryEdgeInstanceDeviceByDriverResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryEdgeInstanceDeviceByDriverResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceDeviceByDriverResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryEdgeInstanceDeviceByDriverResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryEdgeInstanceDeviceByDriverResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceDriverRequest extends $tea.Model {
  currentPage?: number;
  instanceId?: string;
  iotInstanceId?: string;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      instanceId: 'string',
      iotInstanceId: 'string',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceDriverResponseBody extends $tea.Model {
  code?: string;
  data?: QueryEdgeInstanceDriverResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryEdgeInstanceDriverResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceDriverResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryEdgeInstanceDriverResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryEdgeInstanceDriverResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceGatewayRequest extends $tea.Model {
  instanceId?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceGatewayResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  gatewayList?: QueryEdgeInstanceGatewayResponseBodyGatewayList[];
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      gatewayList: 'GatewayList',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      gatewayList: { 'type': 'array', 'itemType': QueryEdgeInstanceGatewayResponseBodyGatewayList },
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceGatewayResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryEdgeInstanceGatewayResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryEdgeInstanceGatewayResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceHistoricDeploymentRequest extends $tea.Model {
  currentPage?: number;
  endTime?: number;
  instanceId?: string;
  iotInstanceId?: string;
  pageSize?: number;
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      endTime: 'EndTime',
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      endTime: 'number',
      instanceId: 'string',
      iotInstanceId: 'string',
      pageSize: 'number',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceHistoricDeploymentResponseBody extends $tea.Model {
  code?: string;
  data?: QueryEdgeInstanceHistoricDeploymentResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryEdgeInstanceHistoricDeploymentResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceHistoricDeploymentResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryEdgeInstanceHistoricDeploymentResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryEdgeInstanceHistoricDeploymentResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceMessageRoutingRequest extends $tea.Model {
  currentPage?: number;
  instanceId?: string;
  iotInstanceId?: string;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      instanceId: 'string',
      iotInstanceId: 'string',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceMessageRoutingResponseBody extends $tea.Model {
  code?: string;
  data?: QueryEdgeInstanceMessageRoutingResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryEdgeInstanceMessageRoutingResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceMessageRoutingResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryEdgeInstanceMessageRoutingResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryEdgeInstanceMessageRoutingResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceSceneRuleRequest extends $tea.Model {
  currentPage?: number;
  instanceId?: string;
  iotInstanceId?: string;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      instanceId: 'string',
      iotInstanceId: 'string',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceSceneRuleResponseBody extends $tea.Model {
  code?: string;
  data?: QueryEdgeInstanceSceneRuleResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryEdgeInstanceSceneRuleResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceSceneRuleResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryEdgeInstanceSceneRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryEdgeInstanceSceneRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryImportedDeviceByApplyIdRequest extends $tea.Model {
  applyId?: number;
  iotInstanceId?: string;
  pageNo?: number;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      applyId: 'ApplyId',
      iotInstanceId: 'IotInstanceId',
      pageNo: 'PageNo',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applyId: 'number',
      iotInstanceId: 'string',
      pageNo: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryImportedDeviceByApplyIdResponseBody extends $tea.Model {
  code?: string;
  deviceList?: QueryImportedDeviceByApplyIdResponseBodyDeviceList;
  errorMessage?: string;
  pageNo?: number;
  pageSize?: number;
  productKey?: string;
  requestId?: string;
  success?: boolean;
  totalPage?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      deviceList: 'DeviceList',
      errorMessage: 'ErrorMessage',
      pageNo: 'PageNo',
      pageSize: 'PageSize',
      productKey: 'ProductKey',
      requestId: 'RequestId',
      success: 'Success',
      totalPage: 'TotalPage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      deviceList: QueryImportedDeviceByApplyIdResponseBodyDeviceList,
      errorMessage: 'string',
      pageNo: 'number',
      pageSize: 'number',
      productKey: 'string',
      requestId: 'string',
      success: 'boolean',
      totalPage: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryImportedDeviceByApplyIdResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryImportedDeviceByApplyIdResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryImportedDeviceByApplyIdResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobRequest extends $tea.Model {
  iotInstanceId?: string;
  jobId?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      jobId: 'JobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      jobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobResponseBody extends $tea.Model {
  code?: string;
  data?: QueryJobResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryJobResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobStatisticsRequest extends $tea.Model {
  iotInstanceId?: string;
  jobId?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      jobId: 'JobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      jobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobStatisticsResponseBody extends $tea.Model {
  code?: string;
  data?: QueryJobStatisticsResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryJobStatisticsResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobStatisticsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryJobStatisticsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryJobStatisticsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryLicenseDeviceListRequest extends $tea.Model {
  endTime?: number;
  iotId?: string;
  iotInstanceId?: string;
  licenseCode?: string;
  pageId?: number;
  pageSize?: number;
  productKey?: string;
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      licenseCode: 'LicenseCode',
      pageId: 'PageId',
      pageSize: 'PageSize',
      productKey: 'ProductKey',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'number',
      iotId: 'string',
      iotInstanceId: 'string',
      licenseCode: 'string',
      pageId: 'number',
      pageSize: 'number',
      productKey: 'string',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryLicenseDeviceListResponseBody extends $tea.Model {
  code?: string;
  data?: QueryLicenseDeviceListResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryLicenseDeviceListResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryLicenseDeviceListResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryLicenseDeviceListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryLicenseDeviceListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryLoRaJoinPermissionsRequest extends $tea.Model {
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryLoRaJoinPermissionsResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  joinPermissions?: QueryLoRaJoinPermissionsResponseBodyJoinPermissions;
  productKey?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      joinPermissions: 'JoinPermissions',
      productKey: 'ProductKey',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      joinPermissions: QueryLoRaJoinPermissionsResponseBodyJoinPermissions,
      productKey: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryLoRaJoinPermissionsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryLoRaJoinPermissionsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryLoRaJoinPermissionsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMessageInfoRequest extends $tea.Model {
  iotInstanceId?: string;
  uniMsgId?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      uniMsgId: 'UniMsgId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      uniMsgId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMessageInfoResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  message?: QueryMessageInfoResponseBodyMessage;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      message: QueryMessageInfoResponseBodyMessage,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMessageInfoResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryMessageInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryMessageInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryOTAFirmwareRequest extends $tea.Model {
  firmwareId?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      firmwareId: 'FirmwareId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      firmwareId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryOTAFirmwareResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  firmwareInfo?: QueryOTAFirmwareResponseBodyFirmwareInfo;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      firmwareInfo: 'FirmwareInfo',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      firmwareInfo: QueryOTAFirmwareResponseBodyFirmwareInfo,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryOTAFirmwareResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryOTAFirmwareResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryOTAFirmwareResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryOTAJobRequest extends $tea.Model {
  iotInstanceId?: string;
  jobId?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      jobId: 'JobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      jobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryOTAJobResponseBody extends $tea.Model {
  code?: string;
  data?: QueryOTAJobResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryOTAJobResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryOTAJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryOTAJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryOTAJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryPageByApplyIdRequest extends $tea.Model {
  applyId?: number;
  currentPage?: number;
  iotInstanceId?: string;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      applyId: 'ApplyId',
      currentPage: 'CurrentPage',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applyId: 'number',
      currentPage: 'number',
      iotInstanceId: 'string',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryPageByApplyIdResponseBody extends $tea.Model {
  applyDeviceList?: QueryPageByApplyIdResponseBodyApplyDeviceList;
  code?: string;
  errorMessage?: string;
  page?: number;
  pageCount?: number;
  pageSize?: number;
  requestId?: string;
  success?: boolean;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      applyDeviceList: 'ApplyDeviceList',
      code: 'Code',
      errorMessage: 'ErrorMessage',
      page: 'Page',
      pageCount: 'PageCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applyDeviceList: QueryPageByApplyIdResponseBodyApplyDeviceList,
      code: 'string',
      errorMessage: 'string',
      page: 'number',
      pageCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryPageByApplyIdResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryPageByApplyIdResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryPageByApplyIdResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryProductRequest extends $tea.Model {
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryProductResponseBody extends $tea.Model {
  code?: string;
  data?: QueryProductResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryProductResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryProductResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryProductResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryProductResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryProductCertInfoRequest extends $tea.Model {
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryProductCertInfoResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  productCertInfo?: QueryProductCertInfoResponseBodyProductCertInfo;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      productCertInfo: 'ProductCertInfo',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      productCertInfo: QueryProductCertInfoResponseBodyProductCertInfo,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryProductCertInfoResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryProductCertInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryProductCertInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryProductListRequest extends $tea.Model {
  aliyunCommodityCode?: string;
  currentPage?: number;
  iotInstanceId?: string;
  pageSize?: number;
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      aliyunCommodityCode: 'AliyunCommodityCode',
      currentPage: 'CurrentPage',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunCommodityCode: 'string',
      currentPage: 'number',
      iotInstanceId: 'string',
      pageSize: 'number',
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryProductListResponseBody extends $tea.Model {
  code?: string;
  data?: QueryProductListResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryProductListResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryProductListResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryProductListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryProductListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryProductTopicRequest extends $tea.Model {
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryProductTopicResponseBody extends $tea.Model {
  code?: string;
  data?: QueryProductTopicResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryProductTopicResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryProductTopicResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryProductTopicResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryProductTopicResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryProjectShareDeviceListRequest extends $tea.Model {
  deviceName?: string;
  iotInstanceId?: string;
  pageId?: number;
  pageSize?: number;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotInstanceId: 'IotInstanceId',
      pageId: 'PageId',
      pageSize: 'PageSize',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotInstanceId: 'string',
      pageId: 'number',
      pageSize: 'number',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryProjectShareDeviceListResponseBody extends $tea.Model {
  code?: string;
  data?: QueryProjectShareDeviceListResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryProjectShareDeviceListResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryProjectShareDeviceListResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryProjectShareDeviceListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryProjectShareDeviceListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySceneRuleRequest extends $tea.Model {
  currentPage?: number;
  iotInstanceId?: string;
  pageSize?: number;
  ruleName?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
      ruleName: 'RuleName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      iotInstanceId: 'string',
      pageSize: 'number',
      ruleName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySceneRuleResponseBody extends $tea.Model {
  code?: string;
  data?: QuerySceneRuleResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QuerySceneRuleResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySceneRuleResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QuerySceneRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QuerySceneRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySchedulePeriodListRequest extends $tea.Model {
  iotInstanceId?: string;
  pageId?: number;
  pageSize?: number;
  scheduleCode?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      pageId: 'PageId',
      pageSize: 'PageSize',
      scheduleCode: 'ScheduleCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      pageId: 'number',
      pageSize: 'number',
      scheduleCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySchedulePeriodListResponseBody extends $tea.Model {
  code?: string;
  data?: QuerySchedulePeriodListResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QuerySchedulePeriodListResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySchedulePeriodListResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QuerySchedulePeriodListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QuerySchedulePeriodListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryShareTaskDeviceListRequest extends $tea.Model {
  deviceName?: string;
  iotInstanceId?: string;
  pageId?: number;
  pageSize?: number;
  shareTaskId?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotInstanceId: 'IotInstanceId',
      pageId: 'PageId',
      pageSize: 'PageSize',
      shareTaskId: 'ShareTaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotInstanceId: 'string',
      pageId: 'number',
      pageSize: 'number',
      shareTaskId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryShareTaskDeviceListResponseBody extends $tea.Model {
  code?: string;
  data?: QueryShareTaskDeviceListResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryShareTaskDeviceListResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryShareTaskDeviceListResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryShareTaskDeviceListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryShareTaskDeviceListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySolutionDeviceGroupPageRequest extends $tea.Model {
  fuzzyGroupName?: string;
  iotInstanceId?: string;
  pageId?: number;
  pageSize?: number;
  projectCode?: string;
  static names(): { [key: string]: string } {
    return {
      fuzzyGroupName: 'FuzzyGroupName',
      iotInstanceId: 'IotInstanceId',
      pageId: 'PageId',
      pageSize: 'PageSize',
      projectCode: 'ProjectCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fuzzyGroupName: 'string',
      iotInstanceId: 'string',
      pageId: 'number',
      pageSize: 'number',
      projectCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySolutionDeviceGroupPageResponseBody extends $tea.Model {
  code?: string;
  data?: QuerySolutionDeviceGroupPageResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QuerySolutionDeviceGroupPageResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySolutionDeviceGroupPageResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QuerySolutionDeviceGroupPageResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QuerySolutionDeviceGroupPageResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySoundCodeLabelBatchFailedResultRequest extends $tea.Model {
  batchCode?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      batchCode: 'BatchCode',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      batchCode: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySoundCodeLabelBatchFailedResultResponseBody extends $tea.Model {
  code?: string;
  data?: QuerySoundCodeLabelBatchFailedResultResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QuerySoundCodeLabelBatchFailedResultResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySoundCodeLabelBatchFailedResultResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QuerySoundCodeLabelBatchFailedResultResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QuerySoundCodeLabelBatchFailedResultResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySoundCodeLabelBatchListRequest extends $tea.Model {
  iotInstanceId?: string;
  pageId?: number;
  pageSize?: number;
  scheduleCode?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      pageId: 'PageId',
      pageSize: 'PageSize',
      scheduleCode: 'ScheduleCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      pageId: 'number',
      pageSize: 'number',
      scheduleCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySoundCodeLabelBatchListResponseBody extends $tea.Model {
  code?: string;
  data?: QuerySoundCodeLabelBatchListResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QuerySoundCodeLabelBatchListResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySoundCodeLabelBatchListResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QuerySoundCodeLabelBatchListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QuerySoundCodeLabelBatchListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySoundCodeLabelListRequest extends $tea.Model {
  iotInstanceId?: string;
  pageId?: number;
  pageSize?: number;
  scheduleCode?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      pageId: 'PageId',
      pageSize: 'PageSize',
      scheduleCode: 'ScheduleCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      pageId: 'number',
      pageSize: 'number',
      scheduleCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySoundCodeLabelListResponseBody extends $tea.Model {
  code?: string;
  data?: QuerySoundCodeLabelListResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QuerySoundCodeLabelListResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySoundCodeLabelListResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QuerySoundCodeLabelListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QuerySoundCodeLabelListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySoundCodeListRequest extends $tea.Model {
  iotInstanceId?: string;
  pageId?: number;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      pageId: 'PageId',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      pageId: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySoundCodeListResponseBody extends $tea.Model {
  code?: string;
  data?: QuerySoundCodeListResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QuerySoundCodeListResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySoundCodeListResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QuerySoundCodeListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QuerySoundCodeListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySoundCodeScheduleListRequest extends $tea.Model {
  iotInstanceId?: string;
  pageId?: number;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      pageId: 'PageId',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      pageId: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySoundCodeScheduleListResponseBody extends $tea.Model {
  code?: string;
  data?: QuerySoundCodeScheduleListResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QuerySoundCodeScheduleListResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySoundCodeScheduleListResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QuerySoundCodeScheduleListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QuerySoundCodeScheduleListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechRequest extends $tea.Model {
  iotInstanceId?: string;
  speechCode?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      speechCode: 'SpeechCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      speechCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechResponseBody extends $tea.Model {
  code?: string;
  data?: QuerySpeechResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QuerySpeechResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QuerySpeechResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QuerySpeechResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechDeviceRequest extends $tea.Model {
  availableSpace?: string;
  availableSpaceScope?: string;
  deviceName?: string;
  iotInstanceId?: string;
  pageId?: number;
  pageSize?: number;
  projectCode?: string;
  static names(): { [key: string]: string } {
    return {
      availableSpace: 'AvailableSpace',
      availableSpaceScope: 'AvailableSpaceScope',
      deviceName: 'DeviceName',
      iotInstanceId: 'IotInstanceId',
      pageId: 'PageId',
      pageSize: 'PageSize',
      projectCode: 'ProjectCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      availableSpace: 'string',
      availableSpaceScope: 'string',
      deviceName: 'string',
      iotInstanceId: 'string',
      pageId: 'number',
      pageSize: 'number',
      projectCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechDeviceResponseBody extends $tea.Model {
  code?: string;
  data?: QuerySpeechDeviceResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QuerySpeechDeviceResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechDeviceResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QuerySpeechDeviceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QuerySpeechDeviceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechLicenseAvailableQuotaRequest extends $tea.Model {
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechLicenseAvailableQuotaResponseBody extends $tea.Model {
  code?: string;
  data?: number;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'number',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechLicenseAvailableQuotaResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QuerySpeechLicenseAvailableQuotaResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QuerySpeechLicenseAvailableQuotaResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechLicenseDeviceListRequest extends $tea.Model {
  checkGroupId?: string;
  deviceName?: string;
  iotInstanceId?: string;
  licenseStatusList?: string[];
  pageId?: number;
  pageSize?: number;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      checkGroupId: 'CheckGroupId',
      deviceName: 'DeviceName',
      iotInstanceId: 'IotInstanceId',
      licenseStatusList: 'LicenseStatusList',
      pageId: 'PageId',
      pageSize: 'PageSize',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkGroupId: 'string',
      deviceName: 'string',
      iotInstanceId: 'string',
      licenseStatusList: { 'type': 'array', 'itemType': 'string' },
      pageId: 'number',
      pageSize: 'number',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechLicenseDeviceListResponseBody extends $tea.Model {
  code?: string;
  data?: QuerySpeechLicenseDeviceListResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QuerySpeechLicenseDeviceListResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechLicenseDeviceListResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QuerySpeechLicenseDeviceListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QuerySpeechLicenseDeviceListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechListRequest extends $tea.Model {
  audioFormat?: string;
  iotInstanceId?: string;
  pageId?: number;
  pageSize?: number;
  projectCode?: string;
  static names(): { [key: string]: string } {
    return {
      audioFormat: 'AudioFormat',
      iotInstanceId: 'IotInstanceId',
      pageId: 'PageId',
      pageSize: 'PageSize',
      projectCode: 'ProjectCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      audioFormat: 'string',
      iotInstanceId: 'string',
      pageId: 'number',
      pageSize: 'number',
      projectCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechListResponseBody extends $tea.Model {
  code?: string;
  data?: QuerySpeechListResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QuerySpeechListResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechListResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QuerySpeechListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QuerySpeechListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechPushJobRequest extends $tea.Model {
  iotInstanceId?: string;
  jobCode?: string;
  pageId?: number;
  pageSize?: number;
  projectCode?: string;
  pushMode?: string;
  statusList?: string[];
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      jobCode: 'JobCode',
      pageId: 'PageId',
      pageSize: 'PageSize',
      projectCode: 'ProjectCode',
      pushMode: 'PushMode',
      statusList: 'StatusList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      jobCode: 'string',
      pageId: 'number',
      pageSize: 'number',
      projectCode: 'string',
      pushMode: 'string',
      statusList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechPushJobResponseBody extends $tea.Model {
  code?: string;
  data?: QuerySpeechPushJobResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QuerySpeechPushJobResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechPushJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QuerySpeechPushJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QuerySpeechPushJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechPushJobDeviceRequest extends $tea.Model {
  deviceName?: string;
  iotInstanceId?: string;
  jobCode?: string;
  pageId?: number;
  pageSize?: number;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotInstanceId: 'IotInstanceId',
      jobCode: 'JobCode',
      pageId: 'PageId',
      pageSize: 'PageSize',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotInstanceId: 'string',
      jobCode: 'string',
      pageId: 'number',
      pageSize: 'number',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechPushJobDeviceResponseBody extends $tea.Model {
  code?: string;
  data?: QuerySpeechPushJobDeviceResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QuerySpeechPushJobDeviceResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechPushJobDeviceResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QuerySpeechPushJobDeviceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QuerySpeechPushJobDeviceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechPushJobSpeechRequest extends $tea.Model {
  iotInstanceId?: string;
  jobCode?: string;
  pageId?: number;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      jobCode: 'JobCode',
      pageId: 'PageId',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      jobCode: 'string',
      pageId: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechPushJobSpeechResponseBody extends $tea.Model {
  code?: string;
  data?: QuerySpeechPushJobSpeechResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QuerySpeechPushJobSpeechResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechPushJobSpeechResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QuerySpeechPushJobSpeechResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QuerySpeechPushJobSpeechResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryStudioAppDomainListOpenRequest extends $tea.Model {
  appId?: string;
  iotInstanceId?: string;
  projectId?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      iotInstanceId: 'IotInstanceId',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      iotInstanceId: 'string',
      projectId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryStudioAppDomainListOpenResponseBody extends $tea.Model {
  code?: string;
  data?: QueryStudioAppDomainListOpenResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryStudioAppDomainListOpenResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryStudioAppDomainListOpenResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryStudioAppDomainListOpenResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryStudioAppDomainListOpenResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryStudioAppListRequest extends $tea.Model {
  fuzzyName?: string;
  iotInstanceId?: string;
  pageNo?: number;
  pageSize?: number;
  projectId?: string;
  types?: string[];
  static names(): { [key: string]: string } {
    return {
      fuzzyName: 'FuzzyName',
      iotInstanceId: 'IotInstanceId',
      pageNo: 'PageNo',
      pageSize: 'PageSize',
      projectId: 'ProjectId',
      types: 'Types',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fuzzyName: 'string',
      iotInstanceId: 'string',
      pageNo: 'number',
      pageSize: 'number',
      projectId: 'string',
      types: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryStudioAppListResponseBody extends $tea.Model {
  code?: string;
  data?: QueryStudioAppListResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryStudioAppListResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryStudioAppListResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryStudioAppListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryStudioAppListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryStudioAppPageListOpenRequest extends $tea.Model {
  appId?: string;
  iotInstanceId?: string;
  isRelease?: boolean;
  pageNo?: number;
  pageSize?: number;
  projectId?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      iotInstanceId: 'IotInstanceId',
      isRelease: 'IsRelease',
      pageNo: 'PageNo',
      pageSize: 'PageSize',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      iotInstanceId: 'string',
      isRelease: 'boolean',
      pageNo: 'number',
      pageSize: 'number',
      projectId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryStudioAppPageListOpenResponseBody extends $tea.Model {
  code?: string;
  data?: QueryStudioAppPageListOpenResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryStudioAppPageListOpenResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryStudioAppPageListOpenResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryStudioAppPageListOpenResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryStudioAppPageListOpenResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryStudioProjectListRequest extends $tea.Model {
  iotInstanceId?: string;
  name?: string;
  pageNo?: number;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      name: 'Name',
      pageNo: 'PageNo',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      name: 'string',
      pageNo: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryStudioProjectListResponseBody extends $tea.Model {
  code?: string;
  data?: QueryStudioProjectListResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryStudioProjectListResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryStudioProjectListResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryStudioProjectListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryStudioProjectListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySubscribeRelationRequest extends $tea.Model {
  iotInstanceId?: string;
  productKey?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      productKey: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySubscribeRelationResponseBody extends $tea.Model {
  code?: string;
  consumerGroupIds?: string[];
  deviceDataFlag?: boolean;
  deviceLifeCycleFlag?: boolean;
  deviceStatusChangeFlag?: boolean;
  deviceTagFlag?: boolean;
  deviceTopoLifeCycleFlag?: boolean;
  errorMessage?: string;
  foundDeviceListFlag?: boolean;
  mnsConfiguration?: string;
  otaEventFlag?: boolean;
  otaJobFlag?: boolean;
  otaVersionFlag?: boolean;
  productKey?: string;
  requestId?: string;
  subscribeFlags?: string;
  success?: boolean;
  thingHistoryFlag?: boolean;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      consumerGroupIds: 'ConsumerGroupIds',
      deviceDataFlag: 'DeviceDataFlag',
      deviceLifeCycleFlag: 'DeviceLifeCycleFlag',
      deviceStatusChangeFlag: 'DeviceStatusChangeFlag',
      deviceTagFlag: 'DeviceTagFlag',
      deviceTopoLifeCycleFlag: 'DeviceTopoLifeCycleFlag',
      errorMessage: 'ErrorMessage',
      foundDeviceListFlag: 'FoundDeviceListFlag',
      mnsConfiguration: 'MnsConfiguration',
      otaEventFlag: 'OtaEventFlag',
      otaJobFlag: 'OtaJobFlag',
      otaVersionFlag: 'OtaVersionFlag',
      productKey: 'ProductKey',
      requestId: 'RequestId',
      subscribeFlags: 'SubscribeFlags',
      success: 'Success',
      thingHistoryFlag: 'ThingHistoryFlag',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      consumerGroupIds: { 'type': 'array', 'itemType': 'string' },
      deviceDataFlag: 'boolean',
      deviceLifeCycleFlag: 'boolean',
      deviceStatusChangeFlag: 'boolean',
      deviceTagFlag: 'boolean',
      deviceTopoLifeCycleFlag: 'boolean',
      errorMessage: 'string',
      foundDeviceListFlag: 'boolean',
      mnsConfiguration: 'string',
      otaEventFlag: 'boolean',
      otaJobFlag: 'boolean',
      otaVersionFlag: 'boolean',
      productKey: 'string',
      requestId: 'string',
      subscribeFlags: 'string',
      success: 'boolean',
      thingHistoryFlag: 'boolean',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySubscribeRelationResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QuerySubscribeRelationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QuerySubscribeRelationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySummarySceneRuleLogRequest extends $tea.Model {
  currentPage?: number;
  endTime?: number;
  iotInstanceId?: string;
  pageSize?: number;
  ruleId?: string;
  startTime?: number;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      endTime: 'EndTime',
      iotInstanceId: 'IotInstanceId',
      pageSize: 'PageSize',
      ruleId: 'RuleId',
      startTime: 'StartTime',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      endTime: 'number',
      iotInstanceId: 'string',
      pageSize: 'number',
      ruleId: 'string',
      startTime: 'number',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySummarySceneRuleLogResponseBody extends $tea.Model {
  code?: string;
  data?: QuerySummarySceneRuleLogResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QuerySummarySceneRuleLogResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySummarySceneRuleLogResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QuerySummarySceneRuleLogResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QuerySummarySceneRuleLogResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySuperDeviceGroupRequest extends $tea.Model {
  groupId?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySuperDeviceGroupResponseBody extends $tea.Model {
  code?: string;
  data?: QuerySuperDeviceGroupResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QuerySuperDeviceGroupResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySuperDeviceGroupResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QuerySuperDeviceGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QuerySuperDeviceGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTaskRequest extends $tea.Model {
  iotInstanceId?: string;
  taskId?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      taskId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTaskResponseBody extends $tea.Model {
  code?: string;
  data?: QueryTaskResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryTaskResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTaskResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryThingModelRequest extends $tea.Model {
  functionBlockId?: string;
  iotInstanceId?: string;
  modelVersion?: string;
  productKey?: string;
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      functionBlockId: 'FunctionBlockId',
      iotInstanceId: 'IotInstanceId',
      modelVersion: 'ModelVersion',
      productKey: 'ProductKey',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      functionBlockId: 'string',
      iotInstanceId: 'string',
      modelVersion: 'string',
      productKey: 'string',
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryThingModelResponseBody extends $tea.Model {
  code?: string;
  data?: QueryThingModelResponseBodyData;
  errorMessage?: string;
  productKey?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      productKey: 'ProductKey',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryThingModelResponseBodyData,
      errorMessage: 'string',
      productKey: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryThingModelResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryThingModelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryThingModelResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryThingModelExtendConfigRequest extends $tea.Model {
  functionBlockId?: string;
  iotInstanceId?: string;
  modelVersion?: string;
  productKey?: string;
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      functionBlockId: 'FunctionBlockId',
      iotInstanceId: 'IotInstanceId',
      modelVersion: 'ModelVersion',
      productKey: 'ProductKey',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      functionBlockId: 'string',
      iotInstanceId: 'string',
      modelVersion: 'string',
      productKey: 'string',
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryThingModelExtendConfigResponseBody extends $tea.Model {
  code?: string;
  data?: QueryThingModelExtendConfigResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryThingModelExtendConfigResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryThingModelExtendConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryThingModelExtendConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryThingModelExtendConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryThingModelExtendConfigPublishedRequest extends $tea.Model {
  functionBlockId?: string;
  iotInstanceId?: string;
  modelVersion?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      functionBlockId: 'FunctionBlockId',
      iotInstanceId: 'IotInstanceId',
      modelVersion: 'ModelVersion',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      functionBlockId: 'string',
      iotInstanceId: 'string',
      modelVersion: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryThingModelExtendConfigPublishedResponseBody extends $tea.Model {
  code?: string;
  data?: QueryThingModelExtendConfigPublishedResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryThingModelExtendConfigPublishedResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryThingModelExtendConfigPublishedResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryThingModelExtendConfigPublishedResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryThingModelExtendConfigPublishedResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryThingModelPublishedRequest extends $tea.Model {
  functionBlockId?: string;
  iotInstanceId?: string;
  modelVersion?: string;
  productKey?: string;
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      functionBlockId: 'FunctionBlockId',
      iotInstanceId: 'IotInstanceId',
      modelVersion: 'ModelVersion',
      productKey: 'ProductKey',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      functionBlockId: 'string',
      iotInstanceId: 'string',
      modelVersion: 'string',
      productKey: 'string',
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryThingModelPublishedResponseBody extends $tea.Model {
  code?: string;
  data?: QueryThingModelPublishedResponseBodyData;
  errorMessage?: string;
  productKey?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      productKey: 'ProductKey',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryThingModelPublishedResponseBodyData,
      errorMessage: 'string',
      productKey: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryThingModelPublishedResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryThingModelPublishedResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryThingModelPublishedResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTopicConfigRequest extends $tea.Model {
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTopicConfigResponseBody extends $tea.Model {
  code?: string;
  data?: QueryTopicConfigResponseBodyData;
  message?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryTopicConfigResponseBodyData,
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTopicConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryTopicConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryTopicConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTopicReverseRouteTableRequest extends $tea.Model {
  iotInstanceId?: string;
  regionId?: string;
  topic?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      regionId: 'RegionId',
      topic: 'Topic',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      regionId: 'string',
      topic: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTopicReverseRouteTableResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  srcTopics?: QueryTopicReverseRouteTableResponseBodySrcTopics;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      srcTopics: 'SrcTopics',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      srcTopics: QueryTopicReverseRouteTableResponseBodySrcTopics,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTopicReverseRouteTableResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryTopicReverseRouteTableResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryTopicReverseRouteTableResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTopicRouteTableRequest extends $tea.Model {
  iotInstanceId?: string;
  topic?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      topic: 'Topic',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      topic: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTopicRouteTableResponseBody extends $tea.Model {
  code?: string;
  dstTopics?: QueryTopicRouteTableResponseBodyDstTopics;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      dstTopics: 'DstTopics',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      dstTopics: QueryTopicRouteTableResponseBodyDstTopics,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTopicRouteTableResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryTopicRouteTableResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryTopicRouteTableResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryVehicleDeviceRequest extends $tea.Model {
  deviceName?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryVehicleDeviceResponseBody extends $tea.Model {
  code?: string;
  data?: QueryVehicleDeviceResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryVehicleDeviceResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryVehicleDeviceResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryVehicleDeviceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryVehicleDeviceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RRpcRequest extends $tea.Model {
  contentType?: string;
  deviceName?: string;
  iotInstanceId?: string;
  productKey?: string;
  requestBase64Byte?: string;
  timeout?: number;
  topic?: string;
  static names(): { [key: string]: string } {
    return {
      contentType: 'ContentType',
      deviceName: 'DeviceName',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
      requestBase64Byte: 'RequestBase64Byte',
      timeout: 'Timeout',
      topic: 'Topic',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contentType: 'string',
      deviceName: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
      requestBase64Byte: 'string',
      timeout: 'number',
      topic: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RRpcResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  messageId?: number;
  payloadBase64Byte?: string;
  requestId?: string;
  rrpcCode?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      messageId: 'MessageId',
      payloadBase64Byte: 'PayloadBase64Byte',
      requestId: 'RequestId',
      rrpcCode: 'RrpcCode',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      messageId: 'number',
      payloadBase64Byte: 'string',
      requestId: 'string',
      rrpcCode: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RRpcResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: RRpcResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RRpcResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReBindLicenseDeviceRequest extends $tea.Model {
  deviceNameList?: string[];
  iotInstanceId?: string;
  licenseCode?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceNameList: 'DeviceNameList',
      iotInstanceId: 'IotInstanceId',
      licenseCode: 'LicenseCode',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceNameList: { 'type': 'array', 'itemType': 'string' },
      iotInstanceId: 'string',
      licenseCode: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReBindLicenseDeviceResponseBody extends $tea.Model {
  code?: string;
  data?: ReBindLicenseDeviceResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: ReBindLicenseDeviceResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReBindLicenseDeviceResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ReBindLicenseDeviceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ReBindLicenseDeviceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RecognizeCarNumRequest extends $tea.Model {
  url?: string;
  static names(): { [key: string]: string } {
    return {
      url: 'Url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      url: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RecognizeCarNumResponseBody extends $tea.Model {
  code?: string;
  data?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RecognizeCarNumResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: RecognizeCarNumResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RecognizeCarNumResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RecognizePictureGeneralRequest extends $tea.Model {
  url?: string;
  static names(): { [key: string]: string } {
    return {
      url: 'Url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      url: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RecognizePictureGeneralResponseBody extends $tea.Model {
  code?: string;
  data?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RecognizePictureGeneralResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: RecognizePictureGeneralResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RecognizePictureGeneralResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RefreshDeviceTunnelSharePasswordRequest extends $tea.Model {
  deviceName?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RefreshDeviceTunnelSharePasswordResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  password?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      password: 'Password',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      password: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RefreshDeviceTunnelSharePasswordResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: RefreshDeviceTunnelSharePasswordResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RefreshDeviceTunnelSharePasswordResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RefreshStudioAppTokenOpenRequest extends $tea.Model {
  appId?: string;
  iotInstanceId?: string;
  projectId?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      iotInstanceId: 'IotInstanceId',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      iotInstanceId: 'string',
      projectId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RefreshStudioAppTokenOpenResponseBody extends $tea.Model {
  code?: string;
  data?: RefreshStudioAppTokenOpenResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: RefreshStudioAppTokenOpenResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RefreshStudioAppTokenOpenResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: RefreshStudioAppTokenOpenResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RefreshStudioAppTokenOpenResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RegisterDeviceRequest extends $tea.Model {
  appKey?: string;
  devEui?: string;
  deviceName?: string;
  iotInstanceId?: string;
  joinEui?: string;
  loraNodeType?: string;
  nickname?: string;
  pinCode?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      appKey: 'AppKey',
      devEui: 'DevEui',
      deviceName: 'DeviceName',
      iotInstanceId: 'IotInstanceId',
      joinEui: 'JoinEui',
      loraNodeType: 'LoraNodeType',
      nickname: 'Nickname',
      pinCode: 'PinCode',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appKey: 'string',
      devEui: 'string',
      deviceName: 'string',
      iotInstanceId: 'string',
      joinEui: 'string',
      loraNodeType: 'string',
      nickname: 'string',
      pinCode: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RegisterDeviceResponseBody extends $tea.Model {
  code?: string;
  data?: RegisterDeviceResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: RegisterDeviceResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RegisterDeviceResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: RegisterDeviceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RegisterDeviceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReleaseEdgeDriverVersionRequest extends $tea.Model {
  driverId?: string;
  driverVersion?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      driverId: 'DriverId',
      driverVersion: 'DriverVersion',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      driverId: 'string',
      driverVersion: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReleaseEdgeDriverVersionResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReleaseEdgeDriverVersionResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ReleaseEdgeDriverVersionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ReleaseEdgeDriverVersionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReleaseProductRequest extends $tea.Model {
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReleaseProductResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReleaseProductResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ReleaseProductResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ReleaseProductResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveThingTopoRequest extends $tea.Model {
  deviceName?: string;
  iotId?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveThingTopoResponseBody extends $tea.Model {
  code?: string;
  data?: boolean;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'boolean',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveThingTopoResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: RemoveThingTopoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RemoveThingTopoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReplaceEdgeInstanceGatewayRequest extends $tea.Model {
  currentGatewayId?: string;
  instanceId?: string;
  iotInstanceId?: string;
  newGatewayId?: string;
  static names(): { [key: string]: string } {
    return {
      currentGatewayId: 'CurrentGatewayId',
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
      newGatewayId: 'NewGatewayId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentGatewayId: 'string',
      instanceId: 'string',
      iotInstanceId: 'string',
      newGatewayId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReplaceEdgeInstanceGatewayResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReplaceEdgeInstanceGatewayResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ReplaceEdgeInstanceGatewayResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ReplaceEdgeInstanceGatewayResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RerunJobRequest extends $tea.Model {
  iotInstanceId?: string;
  jobId?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      jobId: 'JobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      jobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RerunJobResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RerunJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: RerunJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RerunJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResetConsumerGroupPositionRequest extends $tea.Model {
  groupId?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResetConsumerGroupPositionResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResetConsumerGroupPositionResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ResetConsumerGroupPositionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ResetConsumerGroupPositionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResetThingRequest extends $tea.Model {
  deviceName?: string;
  iotId?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResetThingResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  jobId?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      jobId: 'JobId',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      jobId: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResetThingResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ResetThingResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ResetThingResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RetrySoundCodeLabelBatchRequest extends $tea.Model {
  batchCode?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      batchCode: 'BatchCode',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      batchCode: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RetrySoundCodeLabelBatchResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RetrySoundCodeLabelBatchResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: RetrySoundCodeLabelBatchResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RetrySoundCodeLabelBatchResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReupgradeOTATaskRequest extends $tea.Model {
  iotInstanceId?: string;
  jobId?: string;
  taskId?: string[];
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      jobId: 'JobId',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      jobId: 'string',
      taskId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReupgradeOTATaskResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReupgradeOTATaskResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ReupgradeOTATaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ReupgradeOTATaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SaveDevicePropRequest extends $tea.Model {
  deviceName?: string;
  iotId?: string;
  iotInstanceId?: string;
  productKey?: string;
  props?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
      props: 'Props',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
      props: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SaveDevicePropResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SaveDevicePropResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: SaveDevicePropResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SaveDevicePropResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SaveScriptRequest extends $tea.Model {
  iotInstanceId?: string;
  parserId?: number;
  scriptDraft?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      parserId: 'ParserId',
      scriptDraft: 'ScriptDraft',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      parserId: 'number',
      scriptDraft: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SaveScriptResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SaveScriptResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: SaveScriptResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SaveScriptResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDeviceDesiredPropertyRequest extends $tea.Model {
  deviceName?: string;
  iotId?: string;
  iotInstanceId?: string;
  items?: string;
  productKey?: string;
  versions?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      items: 'Items',
      productKey: 'ProductKey',
      versions: 'Versions',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      items: 'string',
      productKey: 'string',
      versions: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDeviceDesiredPropertyResponseBody extends $tea.Model {
  code?: string;
  data?: SetDeviceDesiredPropertyResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: SetDeviceDesiredPropertyResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDeviceDesiredPropertyResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: SetDeviceDesiredPropertyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SetDeviceDesiredPropertyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDeviceGroupTagsRequest extends $tea.Model {
  groupId?: string;
  groupType?: string;
  iotInstanceId?: string;
  tagString?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      groupType: 'GroupType',
      iotInstanceId: 'IotInstanceId',
      tagString: 'TagString',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      groupType: 'string',
      iotInstanceId: 'string',
      tagString: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDeviceGroupTagsResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDeviceGroupTagsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: SetDeviceGroupTagsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SetDeviceGroupTagsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDevicePropertyRequest extends $tea.Model {
  deviceName?: string;
  iotId?: string;
  iotInstanceId?: string;
  items?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      items: 'Items',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      items: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDevicePropertyResponseBody extends $tea.Model {
  code?: string;
  data?: SetDevicePropertyResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: SetDevicePropertyResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDevicePropertyResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: SetDevicePropertyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SetDevicePropertyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDevicesPropertyRequest extends $tea.Model {
  deviceName?: string[];
  iotInstanceId?: string;
  items?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotInstanceId: 'IotInstanceId',
      items: 'Items',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: { 'type': 'array', 'itemType': 'string' },
      iotInstanceId: 'string',
      items: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDevicesPropertyResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDevicesPropertyResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: SetDevicesPropertyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SetDevicesPropertyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetEdgeInstanceDriverConfigsRequest extends $tea.Model {
  configs?: SetEdgeInstanceDriverConfigsRequestConfigs[];
  driverId?: string;
  instanceId?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      configs: 'Configs',
      driverId: 'DriverId',
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configs: { 'type': 'array', 'itemType': SetEdgeInstanceDriverConfigsRequestConfigs },
      driverId: 'string',
      instanceId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetEdgeInstanceDriverConfigsResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetEdgeInstanceDriverConfigsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: SetEdgeInstanceDriverConfigsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SetEdgeInstanceDriverConfigsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetProductCertInfoRequest extends $tea.Model {
  iotInstanceId?: string;
  issueModel?: number;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      issueModel: 'IssueModel',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      issueModel: 'number',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetProductCertInfoResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetProductCertInfoResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: SetProductCertInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SetProductCertInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetStudioProjectCooperationRequest extends $tea.Model {
  iotInstanceId?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetStudioProjectCooperationResponseBody extends $tea.Model {
  code?: string;
  data?: boolean;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'boolean',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetStudioProjectCooperationResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: SetStudioProjectCooperationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SetStudioProjectCooperationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetupStudioAppAuthModeOpenRequest extends $tea.Model {
  appId?: string;
  authMode?: number;
  iotInstanceId?: string;
  projectId?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      authMode: 'AuthMode',
      iotInstanceId: 'IotInstanceId',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      authMode: 'number',
      iotInstanceId: 'string',
      projectId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetupStudioAppAuthModeOpenResponseBody extends $tea.Model {
  code?: string;
  data?: SetupStudioAppAuthModeOpenResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: SetupStudioAppAuthModeOpenResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetupStudioAppAuthModeOpenResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: SetupStudioAppAuthModeOpenResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SetupStudioAppAuthModeOpenResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ShareSpeechByCombinationRequest extends $tea.Model {
  audioFormat?: string;
  combinationList?: string[];
  deviceName?: string;
  iotId?: string;
  iotInstanceId?: string;
  productKey?: string;
  speechId?: string;
  static names(): { [key: string]: string } {
    return {
      audioFormat: 'AudioFormat',
      combinationList: 'CombinationList',
      deviceName: 'DeviceName',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
      speechId: 'SpeechId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      audioFormat: 'string',
      combinationList: { 'type': 'array', 'itemType': 'string' },
      deviceName: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
      speechId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ShareSpeechByCombinationResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ShareSpeechByCombinationResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ShareSpeechByCombinationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ShareSpeechByCombinationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SpeechByCombinationRequest extends $tea.Model {
  audioFormat?: string;
  combinationList?: string[];
  deviceName?: string;
  enforceFlag?: boolean;
  iotId?: string;
  iotInstanceId?: string;
  productKey?: string;
  speechId?: string;
  static names(): { [key: string]: string } {
    return {
      audioFormat: 'AudioFormat',
      combinationList: 'CombinationList',
      deviceName: 'DeviceName',
      enforceFlag: 'EnforceFlag',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
      speechId: 'SpeechId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      audioFormat: 'string',
      combinationList: { 'type': 'array', 'itemType': 'string' },
      deviceName: 'string',
      enforceFlag: 'boolean',
      iotId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
      speechId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SpeechByCombinationResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SpeechByCombinationResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: SpeechByCombinationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SpeechByCombinationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SpeechBySynthesisRequest extends $tea.Model {
  audioFormat?: string;
  deviceName?: string;
  iotId?: string;
  iotInstanceId?: string;
  productKey?: string;
  speechId?: string;
  speechRate?: number;
  text?: string;
  voice?: string;
  volume?: number;
  static names(): { [key: string]: string } {
    return {
      audioFormat: 'AudioFormat',
      deviceName: 'DeviceName',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
      speechId: 'SpeechId',
      speechRate: 'SpeechRate',
      text: 'Text',
      voice: 'Voice',
      volume: 'Volume',
    };
  }

  static types(): { [key: string]: any } {
    return {
      audioFormat: 'string',
      deviceName: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
      speechId: 'string',
      speechRate: 'number',
      text: 'string',
      voice: 'string',
      volume: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SpeechBySynthesisResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SpeechBySynthesisResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: SpeechBySynthesisResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SpeechBySynthesisResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartParserRequest extends $tea.Model {
  iotInstanceId?: string;
  parserId?: number;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      parserId: 'ParserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      parserId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartParserResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartParserResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: StartParserResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: StartParserResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartRuleRequest extends $tea.Model {
  iotInstanceId?: string;
  ruleId?: number;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      ruleId: 'RuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      ruleId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartRuleResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartRuleResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: StartRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: StartRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopParserRequest extends $tea.Model {
  iotInstanceId?: string;
  parserId?: number;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      parserId: 'ParserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      parserId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopParserResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopParserResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: StopParserResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: StopParserResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopRuleRequest extends $tea.Model {
  iotInstanceId?: string;
  ruleId?: number;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      ruleId: 'RuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      ruleId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopRuleResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopRuleResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: StopRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: StopRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubscribeTopicRequest extends $tea.Model {
  deviceName?: string;
  iotInstanceId?: string;
  productKey?: string;
  topic?: string[];
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
      topic: 'Topic',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
      topic: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubscribeTopicResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubscribeTopicResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: SubscribeTopicResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SubscribeTopicResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SyncSpeechByCombinationRequest extends $tea.Model {
  audioFormat?: string;
  combinationList?: string[];
  deviceName?: string;
  enforceFlag?: boolean;
  iotId?: string;
  iotInstanceId?: string;
  productKey?: string;
  speechId?: string;
  static names(): { [key: string]: string } {
    return {
      audioFormat: 'AudioFormat',
      combinationList: 'CombinationList',
      deviceName: 'DeviceName',
      enforceFlag: 'EnforceFlag',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
      speechId: 'SpeechId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      audioFormat: 'string',
      combinationList: { 'type': 'array', 'itemType': 'string' },
      deviceName: 'string',
      enforceFlag: 'boolean',
      iotId: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
      speechId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SyncSpeechByCombinationResponseBody extends $tea.Model {
  code?: string;
  data?: SyncSpeechByCombinationResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: SyncSpeechByCombinationResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SyncSpeechByCombinationResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: SyncSpeechByCombinationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SyncSpeechByCombinationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TestSpeechRequest extends $tea.Model {
  audioFormat?: string;
  enableSoundCode?: boolean;
  iotInstanceId?: string;
  projectCode?: string;
  soundCodeConfig?: { [key: string]: any };
  speechRate?: number;
  speechType?: string;
  text?: string;
  voice?: string;
  volume?: number;
  static names(): { [key: string]: string } {
    return {
      audioFormat: 'AudioFormat',
      enableSoundCode: 'EnableSoundCode',
      iotInstanceId: 'IotInstanceId',
      projectCode: 'ProjectCode',
      soundCodeConfig: 'SoundCodeConfig',
      speechRate: 'SpeechRate',
      speechType: 'SpeechType',
      text: 'Text',
      voice: 'Voice',
      volume: 'Volume',
    };
  }

  static types(): { [key: string]: any } {
    return {
      audioFormat: 'string',
      enableSoundCode: 'boolean',
      iotInstanceId: 'string',
      projectCode: 'string',
      soundCodeConfig: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      speechRate: 'number',
      speechType: 'string',
      text: 'string',
      voice: 'string',
      volume: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TestSpeechShrinkRequest extends $tea.Model {
  audioFormat?: string;
  enableSoundCode?: boolean;
  iotInstanceId?: string;
  projectCode?: string;
  soundCodeConfigShrink?: string;
  speechRate?: number;
  speechType?: string;
  text?: string;
  voice?: string;
  volume?: number;
  static names(): { [key: string]: string } {
    return {
      audioFormat: 'AudioFormat',
      enableSoundCode: 'EnableSoundCode',
      iotInstanceId: 'IotInstanceId',
      projectCode: 'ProjectCode',
      soundCodeConfigShrink: 'SoundCodeConfig',
      speechRate: 'SpeechRate',
      speechType: 'SpeechType',
      text: 'Text',
      voice: 'Voice',
      volume: 'Volume',
    };
  }

  static types(): { [key: string]: any } {
    return {
      audioFormat: 'string',
      enableSoundCode: 'boolean',
      iotInstanceId: 'string',
      projectCode: 'string',
      soundCodeConfigShrink: 'string',
      speechRate: 'number',
      speechType: 'string',
      text: 'string',
      voice: 'string',
      volume: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TestSpeechResponseBody extends $tea.Model {
  code?: string;
  data?: TestSpeechResponseBodyData;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: TestSpeechResponseBodyData,
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TestSpeechResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: TestSpeechResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: TestSpeechResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TestSwitchRequest extends $tea.Model {
  deviceName?: string;
  iotInstanceId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TestSwitchResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  iotId?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      iotId: 'IotId',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      iotId: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TestSwitchResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: TestSwitchResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: TestSwitchResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TransformClientIdRequest extends $tea.Model {
  clientId?: string;
  iotId?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      clientId: 'ClientId',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clientId: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TransformClientIdResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TransformClientIdResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: TransformClientIdResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: TransformClientIdResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TriggerSceneRuleRequest extends $tea.Model {
  instanceId?: string;
  iotInstanceId?: string;
  ruleId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
      ruleId: 'RuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      iotInstanceId: 'string',
      ruleId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TriggerSceneRuleResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TriggerSceneRuleResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: TriggerSceneRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: TriggerSceneRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnbindApplicationFromEdgeInstanceRequest extends $tea.Model {
  applicationId?: string;
  instanceId?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      applicationId: 'ApplicationId',
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applicationId: 'string',
      instanceId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnbindApplicationFromEdgeInstanceResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnbindApplicationFromEdgeInstanceResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: UnbindApplicationFromEdgeInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UnbindApplicationFromEdgeInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnbindDriverFromEdgeInstanceRequest extends $tea.Model {
  driverId?: string;
  instanceId?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      driverId: 'DriverId',
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      driverId: 'string',
      instanceId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnbindDriverFromEdgeInstanceResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnbindDriverFromEdgeInstanceResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: UnbindDriverFromEdgeInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UnbindDriverFromEdgeInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnbindLicenseProductRequest extends $tea.Model {
  iotInstanceId?: string;
  licenseCode?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      licenseCode: 'LicenseCode',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      licenseCode: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnbindLicenseProductResponseBody extends $tea.Model {
  code?: string;
  data?: boolean;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'boolean',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnbindLicenseProductResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: UnbindLicenseProductResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UnbindLicenseProductResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnbindRoleFromEdgeInstanceRequest extends $tea.Model {
  instanceId?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnbindRoleFromEdgeInstanceResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnbindRoleFromEdgeInstanceResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: UnbindRoleFromEdgeInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UnbindRoleFromEdgeInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnbindSceneRuleFromEdgeInstanceRequest extends $tea.Model {
  instanceId?: string;
  iotInstanceId?: string;
  ruleId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
      ruleId: 'RuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      iotInstanceId: 'string',
      ruleId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnbindSceneRuleFromEdgeInstanceResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnbindSceneRuleFromEdgeInstanceResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: UnbindSceneRuleFromEdgeInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UnbindSceneRuleFromEdgeInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateConsumerGroupRequest extends $tea.Model {
  groupId?: string;
  iotInstanceId?: string;
  newGroupName?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      iotInstanceId: 'IotInstanceId',
      newGroupName: 'NewGroupName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      iotInstanceId: 'string',
      newGroupName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateConsumerGroupResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateConsumerGroupResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: UpdateConsumerGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateConsumerGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDestinationRequest extends $tea.Model {
  configuration?: string;
  description?: string;
  destinationId?: number;
  iotInstanceId?: string;
  name?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      configuration: 'Configuration',
      description: 'Description',
      destinationId: 'DestinationId',
      iotInstanceId: 'IotInstanceId',
      name: 'Name',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configuration: 'string',
      description: 'string',
      destinationId: 'number',
      iotInstanceId: 'string',
      name: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDestinationResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDestinationResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: UpdateDestinationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateDestinationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDeviceGroupRequest extends $tea.Model {
  groupDesc?: string;
  groupId?: string;
  groupType?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      groupDesc: 'GroupDesc',
      groupId: 'GroupId',
      groupType: 'GroupType',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupDesc: 'string',
      groupId: 'string',
      groupType: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDeviceGroupResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDeviceGroupResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: UpdateDeviceGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateDeviceGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDeviceShadowRequest extends $tea.Model {
  deltaUpdate?: boolean;
  deviceName?: string;
  iotInstanceId?: string;
  productKey?: string;
  shadowMessage?: string;
  static names(): { [key: string]: string } {
    return {
      deltaUpdate: 'DeltaUpdate',
      deviceName: 'DeviceName',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
      shadowMessage: 'ShadowMessage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deltaUpdate: 'boolean',
      deviceName: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
      shadowMessage: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDeviceShadowResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDeviceShadowResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: UpdateDeviceShadowResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateDeviceShadowResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateEdgeDriverVersionRequest extends $tea.Model {
  argument?: string;
  configCheckRule?: string;
  containerConfig?: string;
  description?: string;
  driverConfig?: string;
  driverId?: string;
  driverVersion?: string;
  edgeVersion?: string;
  iotInstanceId?: string;
  sourceConfig?: string;
  static names(): { [key: string]: string } {
    return {
      argument: 'Argument',
      configCheckRule: 'ConfigCheckRule',
      containerConfig: 'ContainerConfig',
      description: 'Description',
      driverConfig: 'DriverConfig',
      driverId: 'DriverId',
      driverVersion: 'DriverVersion',
      edgeVersion: 'EdgeVersion',
      iotInstanceId: 'IotInstanceId',
      sourceConfig: 'SourceConfig',
    };
  }

  static types(): { [key: string]: any } {
    return {
      argument: 'string',
      configCheckRule: 'string',
      containerConfig: 'string',
      description: 'string',
      driverConfig: 'string',
      driverId: 'string',
      driverVersion: 'string',
      edgeVersion: 'string',
      iotInstanceId: 'string',
      sourceConfig: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateEdgeDriverVersionResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateEdgeDriverVersionResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: UpdateEdgeDriverVersionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateEdgeDriverVersionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateEdgeInstanceRequest extends $tea.Model {
  bizEnable?: boolean;
  instanceId?: string;
  iotInstanceId?: string;
  name?: string;
  spec?: number;
  tags?: string;
  static names(): { [key: string]: string } {
    return {
      bizEnable: 'BizEnable',
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
      name: 'Name',
      spec: 'Spec',
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizEnable: 'boolean',
      instanceId: 'string',
      iotInstanceId: 'string',
      name: 'string',
      spec: 'number',
      tags: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateEdgeInstanceResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateEdgeInstanceResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: UpdateEdgeInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateEdgeInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateEdgeInstanceChannelRequest extends $tea.Model {
  channelId?: string;
  channelName?: string;
  configs?: UpdateEdgeInstanceChannelRequestConfigs[];
  driverId?: string;
  instanceId?: string;
  iotInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      channelId: 'ChannelId',
      channelName: 'ChannelName',
      configs: 'Configs',
      driverId: 'DriverId',
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelId: 'string',
      channelName: 'string',
      configs: { 'type': 'array', 'itemType': UpdateEdgeInstanceChannelRequestConfigs },
      driverId: 'string',
      instanceId: 'string',
      iotInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateEdgeInstanceChannelResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateEdgeInstanceChannelResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: UpdateEdgeInstanceChannelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateEdgeInstanceChannelResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateEdgeInstanceMessageRoutingRequest extends $tea.Model {
  instanceId?: string;
  iotInstanceId?: string;
  name?: string;
  routeId?: number;
  sourceData?: string;
  sourceType?: string;
  targetData?: string;
  targetIotHubQos?: number;
  targetType?: string;
  topicFilter?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      iotInstanceId: 'IotInstanceId',
      name: 'Name',
      routeId: 'RouteId',
      sourceData: 'SourceData',
      sourceType: 'SourceType',
      targetData: 'TargetData',
      targetIotHubQos: 'TargetIotHubQos',
      targetType: 'TargetType',
      topicFilter: 'TopicFilter',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      iotInstanceId: 'string',
      name: 'string',
      routeId: 'number',
      sourceData: 'string',
      sourceType: 'string',
      targetData: 'string',
      targetIotHubQos: 'number',
      targetType: 'string',
      topicFilter: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateEdgeInstanceMessageRoutingResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateEdgeInstanceMessageRoutingResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: UpdateEdgeInstanceMessageRoutingResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateEdgeInstanceMessageRoutingResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateJobRequest extends $tea.Model {
  description?: string;
  iotInstanceId?: string;
  jobId?: string;
  rolloutConfig?: { [key: string]: any };
  timeoutConfig?: { [key: string]: any };
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      iotInstanceId: 'IotInstanceId',
      jobId: 'JobId',
      rolloutConfig: 'RolloutConfig',
      timeoutConfig: 'TimeoutConfig',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      iotInstanceId: 'string',
      jobId: 'string',
      rolloutConfig: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      timeoutConfig: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateJobShrinkRequest extends $tea.Model {
  description?: string;
  iotInstanceId?: string;
  jobId?: string;
  rolloutConfigShrink?: string;
  timeoutConfigShrink?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      iotInstanceId: 'IotInstanceId',
      jobId: 'JobId',
      rolloutConfigShrink: 'RolloutConfig',
      timeoutConfigShrink: 'TimeoutConfig',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      iotInstanceId: 'string',
      jobId: 'string',
      rolloutConfigShrink: 'string',
      timeoutConfigShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateJobResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: UpdateJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateOTAModuleRequest extends $tea.Model {
  aliasName?: string;
  desc?: string;
  iotInstanceId?: string;
  moduleName?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      aliasName: 'AliasName',
      desc: 'Desc',
      iotInstanceId: 'IotInstanceId',
      moduleName: 'ModuleName',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliasName: 'string',
      desc: 'string',
      iotInstanceId: 'string',
      moduleName: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateOTAModuleResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateOTAModuleResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: UpdateOTAModuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateOTAModuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateParserRequest extends $tea.Model {
  description?: string;
  iotInstanceId?: string;
  name?: string;
  parserId?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      iotInstanceId: 'IotInstanceId',
      name: 'Name',
      parserId: 'ParserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      iotInstanceId: 'string',
      name: 'string',
      parserId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateParserResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateParserResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: UpdateParserResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateParserResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateParserDataSourceRequest extends $tea.Model {
  dataSourceId?: number;
  description?: string;
  iotInstanceId?: string;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      dataSourceId: 'DataSourceId',
      description: 'Description',
      iotInstanceId: 'IotInstanceId',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataSourceId: 'number',
      description: 'string',
      iotInstanceId: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateParserDataSourceResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateParserDataSourceResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: UpdateParserDataSourceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateParserDataSourceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProductRequest extends $tea.Model {
  description?: string;
  iotInstanceId?: string;
  productKey?: string;
  productName?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
      productName: 'ProductName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
      productName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProductResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProductResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: UpdateProductResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateProductResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProductFilterConfigRequest extends $tea.Model {
  iotInstanceId?: string;
  productKey?: string;
  propertyTimestampFilter?: boolean;
  propertyValueFilter?: boolean;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
      propertyTimestampFilter: 'PropertyTimestampFilter',
      propertyValueFilter: 'PropertyValueFilter',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      productKey: 'string',
      propertyTimestampFilter: 'boolean',
      propertyValueFilter: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProductFilterConfigResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProductFilterConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: UpdateProductFilterConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateProductFilterConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProductTagsRequest extends $tea.Model {
  iotInstanceId?: string;
  productKey?: string;
  productTag?: UpdateProductTagsRequestProductTag[];
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
      productTag: 'ProductTag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      productKey: 'string',
      productTag: { 'type': 'array', 'itemType': UpdateProductTagsRequestProductTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProductTagsResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  invalidProductTags?: UpdateProductTagsResponseBodyInvalidProductTags;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      invalidProductTags: 'InvalidProductTags',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      invalidProductTags: UpdateProductTagsResponseBodyInvalidProductTags,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProductTagsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: UpdateProductTagsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateProductTagsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProductTopicRequest extends $tea.Model {
  codec?: string;
  desc?: string;
  enableProxySubscribe?: boolean;
  iotInstanceId?: string;
  operation?: string;
  topicId?: string;
  topicShortName?: string;
  static names(): { [key: string]: string } {
    return {
      codec: 'Codec',
      desc: 'Desc',
      enableProxySubscribe: 'EnableProxySubscribe',
      iotInstanceId: 'IotInstanceId',
      operation: 'Operation',
      topicId: 'TopicId',
      topicShortName: 'TopicShortName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      codec: 'string',
      desc: 'string',
      enableProxySubscribe: 'boolean',
      iotInstanceId: 'string',
      operation: 'string',
      topicId: 'string',
      topicShortName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProductTopicResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProductTopicResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: UpdateProductTopicResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateProductTopicResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRuleRequest extends $tea.Model {
  iotInstanceId?: string;
  name?: string;
  productKey?: string;
  ruleDesc?: string;
  ruleId?: number;
  select?: string;
  shortTopic?: string;
  topic?: string;
  topicType?: number;
  where?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      name: 'Name',
      productKey: 'ProductKey',
      ruleDesc: 'RuleDesc',
      ruleId: 'RuleId',
      select: 'Select',
      shortTopic: 'ShortTopic',
      topic: 'Topic',
      topicType: 'TopicType',
      where: 'Where',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      name: 'string',
      productKey: 'string',
      ruleDesc: 'string',
      ruleId: 'number',
      select: 'string',
      shortTopic: 'string',
      topic: 'string',
      topicType: 'number',
      where: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRuleResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRuleResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: UpdateRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRuleActionRequest extends $tea.Model {
  actionId?: number;
  configuration?: string;
  iotInstanceId?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      actionId: 'ActionId',
      configuration: 'Configuration',
      iotInstanceId: 'IotInstanceId',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actionId: 'number',
      configuration: 'string',
      iotInstanceId: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRuleActionResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRuleActionResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: UpdateRuleActionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateRuleActionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSceneRuleRequest extends $tea.Model {
  iotInstanceId?: string;
  ruleContent?: string;
  ruleDescription?: string;
  ruleId?: string;
  ruleName?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      ruleContent: 'RuleContent',
      ruleDescription: 'RuleDescription',
      ruleId: 'RuleId',
      ruleName: 'RuleName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      ruleContent: 'string',
      ruleDescription: 'string',
      ruleId: 'string',
      ruleName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSceneRuleResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSceneRuleResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: UpdateSceneRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateSceneRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSchedulePeriodRequest extends $tea.Model {
  description?: string;
  endTime?: string;
  iotInstanceId?: string;
  periodCode?: string;
  soundCodeContent?: string;
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      endTime: 'EndTime',
      iotInstanceId: 'IotInstanceId',
      periodCode: 'PeriodCode',
      soundCodeContent: 'SoundCodeContent',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      endTime: 'string',
      iotInstanceId: 'string',
      periodCode: 'string',
      soundCodeContent: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSchedulePeriodResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSchedulePeriodResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: UpdateSchedulePeriodResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateSchedulePeriodResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSoundCodeRequest extends $tea.Model {
  duration?: number;
  iotInstanceId?: string;
  name?: string;
  soundCode?: string;
  soundCodeContent?: string;
  static names(): { [key: string]: string } {
    return {
      duration: 'Duration',
      iotInstanceId: 'IotInstanceId',
      name: 'Name',
      soundCode: 'SoundCode',
      soundCodeContent: 'SoundCodeContent',
    };
  }

  static types(): { [key: string]: any } {
    return {
      duration: 'number',
      iotInstanceId: 'string',
      name: 'string',
      soundCode: 'string',
      soundCodeContent: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSoundCodeResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSoundCodeResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: UpdateSoundCodeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateSoundCodeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSoundCodeLabelRequest extends $tea.Model {
  iotInstanceId?: string;
  label?: string;
  soundCode?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      label: 'Label',
      soundCode: 'SoundCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      label: 'string',
      soundCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSoundCodeLabelResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSoundCodeLabelResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: UpdateSoundCodeLabelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateSoundCodeLabelResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSoundCodeScheduleRequest extends $tea.Model {
  description?: string;
  endDate?: string;
  endTime?: string;
  iotInstanceId?: string;
  name?: string;
  scheduleCode?: string;
  startDate?: string;
  startTime?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      endDate: 'EndDate',
      endTime: 'EndTime',
      iotInstanceId: 'IotInstanceId',
      name: 'Name',
      scheduleCode: 'ScheduleCode',
      startDate: 'StartDate',
      startTime: 'StartTime',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      endDate: 'string',
      endTime: 'string',
      iotInstanceId: 'string',
      name: 'string',
      scheduleCode: 'string',
      startDate: 'string',
      startTime: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSoundCodeScheduleResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSoundCodeScheduleResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: UpdateSoundCodeScheduleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateSoundCodeScheduleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSpeechRequest extends $tea.Model {
  enableSoundCode?: boolean;
  iotInstanceId?: string;
  projectCode?: string;
  soundCodeConfig?: { [key: string]: any };
  speechCode?: string;
  speechRate?: number;
  voice?: string;
  volume?: number;
  static names(): { [key: string]: string } {
    return {
      enableSoundCode: 'EnableSoundCode',
      iotInstanceId: 'IotInstanceId',
      projectCode: 'ProjectCode',
      soundCodeConfig: 'SoundCodeConfig',
      speechCode: 'SpeechCode',
      speechRate: 'SpeechRate',
      voice: 'Voice',
      volume: 'Volume',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enableSoundCode: 'boolean',
      iotInstanceId: 'string',
      projectCode: 'string',
      soundCodeConfig: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      speechCode: 'string',
      speechRate: 'number',
      voice: 'string',
      volume: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSpeechShrinkRequest extends $tea.Model {
  enableSoundCode?: boolean;
  iotInstanceId?: string;
  projectCode?: string;
  soundCodeConfigShrink?: string;
  speechCode?: string;
  speechRate?: number;
  voice?: string;
  volume?: number;
  static names(): { [key: string]: string } {
    return {
      enableSoundCode: 'EnableSoundCode',
      iotInstanceId: 'IotInstanceId',
      projectCode: 'ProjectCode',
      soundCodeConfigShrink: 'SoundCodeConfig',
      speechCode: 'SpeechCode',
      speechRate: 'SpeechRate',
      voice: 'Voice',
      volume: 'Volume',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enableSoundCode: 'boolean',
      iotInstanceId: 'string',
      projectCode: 'string',
      soundCodeConfigShrink: 'string',
      speechCode: 'string',
      speechRate: 'number',
      voice: 'string',
      volume: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSpeechResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSpeechResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: UpdateSpeechResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateSpeechResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSubscribeRelationRequest extends $tea.Model {
  consumerGroupIds?: string[];
  deviceDataFlag?: boolean;
  deviceLifeCycleFlag?: boolean;
  deviceStatusChangeFlag?: boolean;
  deviceTagFlag?: boolean;
  deviceTopoLifeCycleFlag?: boolean;
  foundDeviceListFlag?: boolean;
  iotInstanceId?: string;
  mnsConfiguration?: string;
  otaEventFlag?: boolean;
  otaJobFlag?: boolean;
  otaVersionFlag?: boolean;
  productKey?: string;
  subscribeFlags?: string;
  thingHistoryFlag?: boolean;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      consumerGroupIds: 'ConsumerGroupIds',
      deviceDataFlag: 'DeviceDataFlag',
      deviceLifeCycleFlag: 'DeviceLifeCycleFlag',
      deviceStatusChangeFlag: 'DeviceStatusChangeFlag',
      deviceTagFlag: 'DeviceTagFlag',
      deviceTopoLifeCycleFlag: 'DeviceTopoLifeCycleFlag',
      foundDeviceListFlag: 'FoundDeviceListFlag',
      iotInstanceId: 'IotInstanceId',
      mnsConfiguration: 'MnsConfiguration',
      otaEventFlag: 'OtaEventFlag',
      otaJobFlag: 'OtaJobFlag',
      otaVersionFlag: 'OtaVersionFlag',
      productKey: 'ProductKey',
      subscribeFlags: 'SubscribeFlags',
      thingHistoryFlag: 'ThingHistoryFlag',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consumerGroupIds: { 'type': 'array', 'itemType': 'string' },
      deviceDataFlag: 'boolean',
      deviceLifeCycleFlag: 'boolean',
      deviceStatusChangeFlag: 'boolean',
      deviceTagFlag: 'boolean',
      deviceTopoLifeCycleFlag: 'boolean',
      foundDeviceListFlag: 'boolean',
      iotInstanceId: 'string',
      mnsConfiguration: 'string',
      otaEventFlag: 'boolean',
      otaJobFlag: 'boolean',
      otaVersionFlag: 'boolean',
      productKey: 'string',
      subscribeFlags: 'string',
      thingHistoryFlag: 'boolean',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSubscribeRelationResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSubscribeRelationResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: UpdateSubscribeRelationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateSubscribeRelationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateThingModelRequest extends $tea.Model {
  functionBlockId?: string;
  functionBlockName?: string;
  identifier?: string;
  iotInstanceId?: string;
  productKey?: string;
  thingModelJson?: string;
  static names(): { [key: string]: string } {
    return {
      functionBlockId: 'FunctionBlockId',
      functionBlockName: 'FunctionBlockName',
      identifier: 'Identifier',
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
      thingModelJson: 'ThingModelJson',
    };
  }

  static types(): { [key: string]: any } {
    return {
      functionBlockId: 'string',
      functionBlockName: 'string',
      identifier: 'string',
      iotInstanceId: 'string',
      productKey: 'string',
      thingModelJson: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateThingModelResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateThingModelResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: UpdateThingModelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateThingModelResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateThingScriptRequest extends $tea.Model {
  iotInstanceId?: string;
  productKey?: string;
  scriptContent?: string;
  scriptType?: string;
  static names(): { [key: string]: string } {
    return {
      iotInstanceId: 'IotInstanceId',
      productKey: 'ProductKey',
      scriptContent: 'ScriptContent',
      scriptType: 'ScriptType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotInstanceId: 'string',
      productKey: 'string',
      scriptContent: 'string',
      scriptType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateThingScriptResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateThingScriptResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: UpdateThingScriptResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateThingScriptResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTopicConfigRequest extends $tea.Model {
  codec?: string;
  description?: string;
  enableBroadcast?: boolean;
  enableProxySubscribe?: boolean;
  iotInstanceId?: string;
  operation?: string;
  productKey?: string;
  topicFullName?: string;
  static names(): { [key: string]: string } {
    return {
      codec: 'Codec',
      description: 'Description',
      enableBroadcast: 'EnableBroadcast',
      enableProxySubscribe: 'EnableProxySubscribe',
      iotInstanceId: 'IotInstanceId',
      operation: 'Operation',
      productKey: 'ProductKey',
      topicFullName: 'TopicFullName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      codec: 'string',
      description: 'string',
      enableBroadcast: 'boolean',
      enableProxySubscribe: 'boolean',
      iotInstanceId: 'string',
      operation: 'string',
      productKey: 'string',
      topicFullName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTopicConfigResponseBody extends $tea.Model {
  code?: string;
  message?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTopicConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: UpdateTopicConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateTopicConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WriteDevicesHotStorageDataRequest extends $tea.Model {
  deviceName?: string;
  iotId?: string;
  iotInstanceId?: string;
  items?: string;
  productKey?: string;
  userTopic?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      iotInstanceId: 'IotInstanceId',
      items: 'Items',
      productKey: 'ProductKey',
      userTopic: 'UserTopic',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      iotInstanceId: 'string',
      items: 'string',
      productKey: 'string',
      userTopic: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WriteDevicesHotStorageDataResponseBody extends $tea.Model {
  code?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WriteDevicesHotStorageDataResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: WriteDevicesHotStorageDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: WriteDevicesHotStorageDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddShareTaskDeviceResponseBodyData extends $tea.Model {
  failSum?: number;
  failedResultCsvFile?: string;
  progress?: number;
  progressId?: string;
  successSum?: number;
  static names(): { [key: string]: string } {
    return {
      failSum: 'FailSum',
      failedResultCsvFile: 'FailedResultCsvFile',
      progress: 'Progress',
      progressId: 'ProgressId',
      successSum: 'SuccessSum',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failSum: 'number',
      failedResultCsvFile: 'string',
      progress: 'number',
      progressId: 'string',
      successSum: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchAddDeviceGroupRelationsRequestDevice extends $tea.Model {
  deviceName?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchAddThingTopoRequestTopoAddItem extends $tea.Model {
  clientId?: string;
  deviceName?: string;
  productKey?: string;
  sign?: string;
  signMethod?: string;
  timestamp?: string;
  static names(): { [key: string]: string } {
    return {
      clientId: 'ClientId',
      deviceName: 'DeviceName',
      productKey: 'ProductKey',
      sign: 'Sign',
      signMethod: 'SignMethod',
      timestamp: 'Timestamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clientId: 'string',
      deviceName: 'string',
      productKey: 'string',
      sign: 'string',
      signMethod: 'string',
      timestamp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchBindDevicesIntoProjectRequestDevices extends $tea.Model {
  deviceName?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCheckDeviceNamesRequestDeviceNameList extends $tea.Model {
  deviceName?: string;
  deviceNickname?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      deviceNickname: 'DeviceNickname',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      deviceNickname: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCheckDeviceNamesResponseBodyDataInvalidDetailListInvalidDetailList extends $tea.Model {
  deviceName?: string;
  errorMsg?: string;
  nickName?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      errorMsg: 'ErrorMsg',
      nickName: 'NickName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      errorMsg: 'string',
      nickName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCheckDeviceNamesResponseBodyDataInvalidDetailList extends $tea.Model {
  invalidDetailList?: BatchCheckDeviceNamesResponseBodyDataInvalidDetailListInvalidDetailList[];
  static names(): { [key: string]: string } {
    return {
      invalidDetailList: 'InvalidDetailList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      invalidDetailList: { 'type': 'array', 'itemType': BatchCheckDeviceNamesResponseBodyDataInvalidDetailListInvalidDetailList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCheckDeviceNamesResponseBodyDataInvalidDeviceNameList extends $tea.Model {
  invalidDeviceName?: string[];
  static names(): { [key: string]: string } {
    return {
      invalidDeviceName: 'InvalidDeviceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      invalidDeviceName: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCheckDeviceNamesResponseBodyDataInvalidDeviceNicknameList extends $tea.Model {
  invalidDeviceNickname?: string[];
  static names(): { [key: string]: string } {
    return {
      invalidDeviceNickname: 'InvalidDeviceNickname',
    };
  }

  static types(): { [key: string]: any } {
    return {
      invalidDeviceNickname: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCheckDeviceNamesResponseBodyDataRepeatedDeviceNameList extends $tea.Model {
  repeatDevieNameList?: string[];
  static names(): { [key: string]: string } {
    return {
      repeatDevieNameList: 'RepeatDevieNameList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      repeatDevieNameList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCheckDeviceNamesResponseBodyData extends $tea.Model {
  applyId?: number;
  invalidDetailList?: BatchCheckDeviceNamesResponseBodyDataInvalidDetailList;
  invalidDeviceNameList?: BatchCheckDeviceNamesResponseBodyDataInvalidDeviceNameList;
  invalidDeviceNicknameList?: BatchCheckDeviceNamesResponseBodyDataInvalidDeviceNicknameList;
  repeatedDeviceNameList?: BatchCheckDeviceNamesResponseBodyDataRepeatedDeviceNameList;
  static names(): { [key: string]: string } {
    return {
      applyId: 'ApplyId',
      invalidDetailList: 'InvalidDetailList',
      invalidDeviceNameList: 'InvalidDeviceNameList',
      invalidDeviceNicknameList: 'InvalidDeviceNicknameList',
      repeatedDeviceNameList: 'RepeatedDeviceNameList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applyId: 'number',
      invalidDetailList: BatchCheckDeviceNamesResponseBodyDataInvalidDetailList,
      invalidDeviceNameList: BatchCheckDeviceNamesResponseBodyDataInvalidDeviceNameList,
      invalidDeviceNicknameList: BatchCheckDeviceNamesResponseBodyDataInvalidDeviceNicknameList,
      repeatedDeviceNameList: BatchCheckDeviceNamesResponseBodyDataRepeatedDeviceNameList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCheckImportDeviceRequestDeviceList extends $tea.Model {
  deviceName?: string;
  deviceSecret?: string;
  sn?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      deviceSecret: 'DeviceSecret',
      sn: 'Sn',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      deviceSecret: 'string',
      sn: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCheckImportDeviceResponseBodyDataInvalidDetailList extends $tea.Model {
  deviceName?: string;
  deviceSecret?: string;
  errorMsg?: string;
  sn?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      deviceSecret: 'DeviceSecret',
      errorMsg: 'ErrorMsg',
      sn: 'Sn',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      deviceSecret: 'string',
      errorMsg: 'string',
      sn: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCheckImportDeviceResponseBodyData extends $tea.Model {
  invalidDetailList?: BatchCheckImportDeviceResponseBodyDataInvalidDetailList[];
  invalidDeviceNameList?: string[];
  invalidDeviceSecretList?: string[];
  invalidSnList?: string[];
  repeatedDeviceNameList?: string[];
  static names(): { [key: string]: string } {
    return {
      invalidDetailList: 'InvalidDetailList',
      invalidDeviceNameList: 'InvalidDeviceNameList',
      invalidDeviceSecretList: 'InvalidDeviceSecretList',
      invalidSnList: 'InvalidSnList',
      repeatedDeviceNameList: 'RepeatedDeviceNameList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      invalidDetailList: { 'type': 'array', 'itemType': BatchCheckImportDeviceResponseBodyDataInvalidDetailList },
      invalidDeviceNameList: { 'type': 'array', 'itemType': 'string' },
      invalidDeviceSecretList: { 'type': 'array', 'itemType': 'string' },
      invalidSnList: { 'type': 'array', 'itemType': 'string' },
      repeatedDeviceNameList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCheckVehicleDeviceRequestDeviceList extends $tea.Model {
  deviceId?: string;
  deviceModel?: string;
  deviceName?: string;
  manufacturer?: string;
  static names(): { [key: string]: string } {
    return {
      deviceId: 'DeviceId',
      deviceModel: 'DeviceModel',
      deviceName: 'DeviceName',
      manufacturer: 'Manufacturer',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceId: 'string',
      deviceModel: 'string',
      deviceName: 'string',
      manufacturer: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCheckVehicleDeviceResponseBodyDataInvalidDetailList extends $tea.Model {
  deviceId?: string;
  deviceModel?: string;
  deviceName?: string;
  errorMsg?: string;
  manufacturer?: string;
  static names(): { [key: string]: string } {
    return {
      deviceId: 'DeviceId',
      deviceModel: 'DeviceModel',
      deviceName: 'DeviceName',
      errorMsg: 'ErrorMsg',
      manufacturer: 'Manufacturer',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceId: 'string',
      deviceModel: 'string',
      deviceName: 'string',
      errorMsg: 'string',
      manufacturer: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCheckVehicleDeviceResponseBodyData extends $tea.Model {
  invalidDetailList?: BatchCheckVehicleDeviceResponseBodyDataInvalidDetailList[];
  invalidDeviceIdList?: string[];
  invalidDeviceModelList?: string[];
  invalidDeviceNameList?: string[];
  invalidManufacturerList?: string[];
  repeatedDeviceIdList?: string[];
  repeatedDeviceNameList?: string[];
  static names(): { [key: string]: string } {
    return {
      invalidDetailList: 'InvalidDetailList',
      invalidDeviceIdList: 'InvalidDeviceIdList',
      invalidDeviceModelList: 'InvalidDeviceModelList',
      invalidDeviceNameList: 'InvalidDeviceNameList',
      invalidManufacturerList: 'InvalidManufacturerList',
      repeatedDeviceIdList: 'RepeatedDeviceIdList',
      repeatedDeviceNameList: 'RepeatedDeviceNameList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      invalidDetailList: { 'type': 'array', 'itemType': BatchCheckVehicleDeviceResponseBodyDataInvalidDetailList },
      invalidDeviceIdList: { 'type': 'array', 'itemType': 'string' },
      invalidDeviceModelList: { 'type': 'array', 'itemType': 'string' },
      invalidDeviceNameList: { 'type': 'array', 'itemType': 'string' },
      invalidManufacturerList: { 'type': 'array', 'itemType': 'string' },
      repeatedDeviceIdList: { 'type': 'array', 'itemType': 'string' },
      repeatedDeviceNameList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchDeleteDeviceGroupRelationsRequestDevice extends $tea.Model {
  deviceName?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetDeviceBindStatusResponseBodyData extends $tea.Model {
  bindStatus?: number;
  instanceId?: string;
  iotId?: string;
  static names(): { [key: string]: string } {
    return {
      bindStatus: 'BindStatus',
      instanceId: 'InstanceId',
      iotId: 'IotId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bindStatus: 'number',
      instanceId: 'string',
      iotId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetDeviceStateResponseBodyDeviceStatusListDeviceStatus extends $tea.Model {
  asAddress?: string;
  deviceId?: string;
  deviceName?: string;
  iotId?: string;
  lastOnlineTime?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      asAddress: 'AsAddress',
      deviceId: 'DeviceId',
      deviceName: 'DeviceName',
      iotId: 'IotId',
      lastOnlineTime: 'LastOnlineTime',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      asAddress: 'string',
      deviceId: 'string',
      deviceName: 'string',
      iotId: 'string',
      lastOnlineTime: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetDeviceStateResponseBodyDeviceStatusList extends $tea.Model {
  deviceStatus?: BatchGetDeviceStateResponseBodyDeviceStatusListDeviceStatus[];
  static names(): { [key: string]: string } {
    return {
      deviceStatus: 'DeviceStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceStatus: { 'type': 'array', 'itemType': BatchGetDeviceStateResponseBodyDeviceStatusListDeviceStatus },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeDriverResponseBodyDriverList extends $tea.Model {
  cpuArch?: string;
  driverId?: string;
  driverName?: string;
  driverProtocol?: string;
  gmtCreateTimestamp?: number;
  gmtModifiedTimestamp?: number;
  isBuiltIn?: boolean;
  runtime?: string;
  type?: number;
  static names(): { [key: string]: string } {
    return {
      cpuArch: 'CpuArch',
      driverId: 'DriverId',
      driverName: 'DriverName',
      driverProtocol: 'DriverProtocol',
      gmtCreateTimestamp: 'GmtCreateTimestamp',
      gmtModifiedTimestamp: 'GmtModifiedTimestamp',
      isBuiltIn: 'IsBuiltIn',
      runtime: 'Runtime',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cpuArch: 'string',
      driverId: 'string',
      driverName: 'string',
      driverProtocol: 'string',
      gmtCreateTimestamp: 'number',
      gmtModifiedTimestamp: 'number',
      isBuiltIn: 'boolean',
      runtime: 'string',
      type: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeInstanceChannelResponseBodyDataChannelConfigListConfig extends $tea.Model {
  configId?: string;
  content?: string;
  format?: string;
  key?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      content: 'Content',
      format: 'Format',
      key: 'Key',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'string',
      content: 'string',
      format: 'string',
      key: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeInstanceChannelResponseBodyDataChannelConfigList extends $tea.Model {
  config?: BatchGetEdgeInstanceChannelResponseBodyDataChannelConfigListConfig[];
  static names(): { [key: string]: string } {
    return {
      config: 'Config',
    };
  }

  static types(): { [key: string]: any } {
    return {
      config: { 'type': 'array', 'itemType': BatchGetEdgeInstanceChannelResponseBodyDataChannelConfigListConfig },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeInstanceChannelResponseBodyDataChannel extends $tea.Model {
  channelId?: string;
  channelName?: string;
  configList?: BatchGetEdgeInstanceChannelResponseBodyDataChannelConfigList;
  static names(): { [key: string]: string } {
    return {
      channelId: 'ChannelId',
      channelName: 'ChannelName',
      configList: 'ConfigList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelId: 'string',
      channelName: 'string',
      configList: BatchGetEdgeInstanceChannelResponseBodyDataChannelConfigList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeInstanceChannelResponseBodyData extends $tea.Model {
  channel?: BatchGetEdgeInstanceChannelResponseBodyDataChannel[];
  static names(): { [key: string]: string } {
    return {
      channel: 'Channel',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channel: { 'type': 'array', 'itemType': BatchGetEdgeInstanceChannelResponseBodyDataChannel },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeInstanceDeviceChannelResponseBodyDeviceChannelList extends $tea.Model {
  channelId?: string;
  channelName?: string;
  iotId?: string;
  static names(): { [key: string]: string } {
    return {
      channelId: 'ChannelId',
      channelName: 'ChannelName',
      iotId: 'IotId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelId: 'string',
      channelName: 'string',
      iotId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeInstanceDeviceConfigResponseBodyDeviceConfigListConfig extends $tea.Model {
  content?: string;
  format?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      format: 'Format',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      format: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeInstanceDeviceConfigResponseBodyDeviceConfigList extends $tea.Model {
  config?: BatchGetEdgeInstanceDeviceConfigResponseBodyDeviceConfigListConfig;
  iotId?: string;
  static names(): { [key: string]: string } {
    return {
      config: 'Config',
      iotId: 'IotId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      config: BatchGetEdgeInstanceDeviceConfigResponseBodyDeviceConfigListConfig,
      iotId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeInstanceDeviceDriverResponseBodyDeviceDriverList extends $tea.Model {
  driverId?: string;
  iotId?: string;
  static names(): { [key: string]: string } {
    return {
      driverId: 'DriverId',
      iotId: 'IotId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      driverId: 'string',
      iotId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigListConfigList extends $tea.Model {
  configId?: string;
  content?: string;
  format?: string;
  key?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      content: 'Content',
      format: 'Format',
      key: 'Key',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'string',
      content: 'string',
      format: 'string',
      key: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigList extends $tea.Model {
  configList?: BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigListConfigList[];
  driverId?: string;
  static names(): { [key: string]: string } {
    return {
      configList: 'ConfigList',
      driverId: 'DriverId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configList: { 'type': 'array', 'itemType': BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigListConfigList },
      driverId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGrayMigrationDeviceResponseBodyDataDetailsItem extends $tea.Model {
  code?: number;
  deviceName?: string;
  message?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      deviceName: 'DeviceName',
      message: 'Message',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      deviceName: 'string',
      message: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGrayMigrationDeviceResponseBodyDataDetails extends $tea.Model {
  item?: BatchGrayMigrationDeviceResponseBodyDataDetailsItem[];
  static names(): { [key: string]: string } {
    return {
      item: 'item',
    };
  }

  static types(): { [key: string]: any } {
    return {
      item: { 'type': 'array', 'itemType': BatchGrayMigrationDeviceResponseBodyDataDetailsItem },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGrayMigrationDeviceResponseBodyData extends $tea.Model {
  details?: BatchGrayMigrationDeviceResponseBodyDataDetails;
  static names(): { [key: string]: string } {
    return {
      details: 'Details',
    };
  }

  static types(): { [key: string]: any } {
    return {
      details: BatchGrayMigrationDeviceResponseBodyDataDetails,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchImportDeviceRequestDeviceList extends $tea.Model {
  deviceName?: string;
  deviceSecret?: string;
  sn?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      deviceSecret: 'DeviceSecret',
      sn: 'Sn',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      deviceSecret: 'string',
      sn: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchImportDeviceResponseBodyDataInvalidDetailListInvalidDetailList extends $tea.Model {
  deviceName?: string;
  deviceSecret?: string;
  errorMsg?: string;
  sn?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      deviceSecret: 'DeviceSecret',
      errorMsg: 'ErrorMsg',
      sn: 'Sn',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      deviceSecret: 'string',
      errorMsg: 'string',
      sn: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchImportDeviceResponseBodyDataInvalidDetailList extends $tea.Model {
  invalidDetailList?: BatchImportDeviceResponseBodyDataInvalidDetailListInvalidDetailList[];
  static names(): { [key: string]: string } {
    return {
      invalidDetailList: 'InvalidDetailList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      invalidDetailList: { 'type': 'array', 'itemType': BatchImportDeviceResponseBodyDataInvalidDetailListInvalidDetailList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchImportDeviceResponseBodyDataInvalidDeviceNameList extends $tea.Model {
  invalidDeviceName?: string[];
  static names(): { [key: string]: string } {
    return {
      invalidDeviceName: 'invalidDeviceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      invalidDeviceName: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchImportDeviceResponseBodyDataInvalidDeviceSecretList extends $tea.Model {
  invalidDeviceSecret?: string[];
  static names(): { [key: string]: string } {
    return {
      invalidDeviceSecret: 'invalidDeviceSecret',
    };
  }

  static types(): { [key: string]: any } {
    return {
      invalidDeviceSecret: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchImportDeviceResponseBodyDataInvalidSnList extends $tea.Model {
  invalidSn?: string[];
  static names(): { [key: string]: string } {
    return {
      invalidSn: 'invalidSn',
    };
  }

  static types(): { [key: string]: any } {
    return {
      invalidSn: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchImportDeviceResponseBodyDataRepeatedDeviceNameList extends $tea.Model {
  repeatedDeviceName?: string[];
  static names(): { [key: string]: string } {
    return {
      repeatedDeviceName: 'repeatedDeviceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      repeatedDeviceName: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchImportDeviceResponseBodyData extends $tea.Model {
  applyId?: number;
  invalidDetailList?: BatchImportDeviceResponseBodyDataInvalidDetailList;
  invalidDeviceNameList?: BatchImportDeviceResponseBodyDataInvalidDeviceNameList;
  invalidDeviceSecretList?: BatchImportDeviceResponseBodyDataInvalidDeviceSecretList;
  invalidSnList?: BatchImportDeviceResponseBodyDataInvalidSnList;
  repeatedDeviceNameList?: BatchImportDeviceResponseBodyDataRepeatedDeviceNameList;
  static names(): { [key: string]: string } {
    return {
      applyId: 'ApplyId',
      invalidDetailList: 'InvalidDetailList',
      invalidDeviceNameList: 'InvalidDeviceNameList',
      invalidDeviceSecretList: 'InvalidDeviceSecretList',
      invalidSnList: 'InvalidSnList',
      repeatedDeviceNameList: 'RepeatedDeviceNameList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applyId: 'number',
      invalidDetailList: BatchImportDeviceResponseBodyDataInvalidDetailList,
      invalidDeviceNameList: BatchImportDeviceResponseBodyDataInvalidDeviceNameList,
      invalidDeviceSecretList: BatchImportDeviceResponseBodyDataInvalidDeviceSecretList,
      invalidSnList: BatchImportDeviceResponseBodyDataInvalidSnList,
      repeatedDeviceNameList: BatchImportDeviceResponseBodyDataRepeatedDeviceNameList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchImportVehicleDeviceRequestDeviceList extends $tea.Model {
  deviceId?: string;
  deviceModel?: string;
  deviceName?: string;
  manufacturer?: string;
  static names(): { [key: string]: string } {
    return {
      deviceId: 'DeviceId',
      deviceModel: 'DeviceModel',
      deviceName: 'DeviceName',
      manufacturer: 'Manufacturer',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceId: 'string',
      deviceModel: 'string',
      deviceName: 'string',
      manufacturer: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchImportVehicleDeviceResponseBodyDataInvalidDetailListInvalidDetailList extends $tea.Model {
  deviceId?: string;
  deviceModel?: string;
  deviceName?: string;
  errorMsg?: string;
  manufacturer?: string;
  static names(): { [key: string]: string } {
    return {
      deviceId: 'DeviceId',
      deviceModel: 'DeviceModel',
      deviceName: 'DeviceName',
      errorMsg: 'ErrorMsg',
      manufacturer: 'Manufacturer',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceId: 'string',
      deviceModel: 'string',
      deviceName: 'string',
      errorMsg: 'string',
      manufacturer: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchImportVehicleDeviceResponseBodyDataInvalidDetailList extends $tea.Model {
  invalidDetailList?: BatchImportVehicleDeviceResponseBodyDataInvalidDetailListInvalidDetailList[];
  static names(): { [key: string]: string } {
    return {
      invalidDetailList: 'InvalidDetailList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      invalidDetailList: { 'type': 'array', 'itemType': BatchImportVehicleDeviceResponseBodyDataInvalidDetailListInvalidDetailList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchImportVehicleDeviceResponseBodyDataInvalidDeviceIdList extends $tea.Model {
  invalidDeviceIdList?: string[];
  static names(): { [key: string]: string } {
    return {
      invalidDeviceIdList: 'invalidDeviceIdList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      invalidDeviceIdList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchImportVehicleDeviceResponseBodyDataInvalidDeviceModelList extends $tea.Model {
  invalidDeviceModelList?: string[];
  static names(): { [key: string]: string } {
    return {
      invalidDeviceModelList: 'invalidDeviceModelList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      invalidDeviceModelList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchImportVehicleDeviceResponseBodyDataInvalidDeviceNameList extends $tea.Model {
  invalidDeviceNameList?: string[];
  static names(): { [key: string]: string } {
    return {
      invalidDeviceNameList: 'InvalidDeviceNameList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      invalidDeviceNameList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchImportVehicleDeviceResponseBodyDataInvalidManufacturerList extends $tea.Model {
  invalidManufacturerList?: string[];
  static names(): { [key: string]: string } {
    return {
      invalidManufacturerList: 'invalidManufacturerList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      invalidManufacturerList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchImportVehicleDeviceResponseBodyDataRepeatedDeviceIdList extends $tea.Model {
  repeatedDeviceIdList?: string[];
  static names(): { [key: string]: string } {
    return {
      repeatedDeviceIdList: 'repeatedDeviceIdList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      repeatedDeviceIdList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchImportVehicleDeviceResponseBodyDataRepeatedDeviceNameList extends $tea.Model {
  repeatedDeviceNameList?: string[];
  static names(): { [key: string]: string } {
    return {
      repeatedDeviceNameList: 'RepeatedDeviceNameList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      repeatedDeviceNameList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchImportVehicleDeviceResponseBodyData extends $tea.Model {
  applyId?: number;
  invalidDetailList?: BatchImportVehicleDeviceResponseBodyDataInvalidDetailList;
  invalidDeviceIdList?: BatchImportVehicleDeviceResponseBodyDataInvalidDeviceIdList;
  invalidDeviceModelList?: BatchImportVehicleDeviceResponseBodyDataInvalidDeviceModelList;
  invalidDeviceNameList?: BatchImportVehicleDeviceResponseBodyDataInvalidDeviceNameList;
  invalidManufacturerList?: BatchImportVehicleDeviceResponseBodyDataInvalidManufacturerList;
  repeatedDeviceIdList?: BatchImportVehicleDeviceResponseBodyDataRepeatedDeviceIdList;
  repeatedDeviceNameList?: BatchImportVehicleDeviceResponseBodyDataRepeatedDeviceNameList;
  static names(): { [key: string]: string } {
    return {
      applyId: 'ApplyId',
      invalidDetailList: 'InvalidDetailList',
      invalidDeviceIdList: 'InvalidDeviceIdList',
      invalidDeviceModelList: 'InvalidDeviceModelList',
      invalidDeviceNameList: 'InvalidDeviceNameList',
      invalidManufacturerList: 'InvalidManufacturerList',
      repeatedDeviceIdList: 'RepeatedDeviceIdList',
      repeatedDeviceNameList: 'RepeatedDeviceNameList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applyId: 'number',
      invalidDetailList: BatchImportVehicleDeviceResponseBodyDataInvalidDetailList,
      invalidDeviceIdList: BatchImportVehicleDeviceResponseBodyDataInvalidDeviceIdList,
      invalidDeviceModelList: BatchImportVehicleDeviceResponseBodyDataInvalidDeviceModelList,
      invalidDeviceNameList: BatchImportVehicleDeviceResponseBodyDataInvalidDeviceNameList,
      invalidManufacturerList: BatchImportVehicleDeviceResponseBodyDataInvalidManufacturerList,
      repeatedDeviceIdList: BatchImportVehicleDeviceResponseBodyDataRepeatedDeviceIdList,
      repeatedDeviceNameList: BatchImportVehicleDeviceResponseBodyDataRepeatedDeviceNameList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchQueryDeviceDetailResponseBodyDataData extends $tea.Model {
  deviceName?: string;
  deviceSecret?: string;
  firmwareVersion?: string;
  gmtActive?: string;
  gmtCreate?: string;
  iotId?: string;
  nickname?: string;
  nodeType?: number;
  productKey?: string;
  productName?: string;
  region?: string;
  status?: string;
  utcActive?: string;
  utcCreate?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      deviceSecret: 'DeviceSecret',
      firmwareVersion: 'FirmwareVersion',
      gmtActive: 'GmtActive',
      gmtCreate: 'GmtCreate',
      iotId: 'IotId',
      nickname: 'Nickname',
      nodeType: 'NodeType',
      productKey: 'ProductKey',
      productName: 'ProductName',
      region: 'Region',
      status: 'Status',
      utcActive: 'UtcActive',
      utcCreate: 'UtcCreate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      deviceSecret: 'string',
      firmwareVersion: 'string',
      gmtActive: 'string',
      gmtCreate: 'string',
      iotId: 'string',
      nickname: 'string',
      nodeType: 'number',
      productKey: 'string',
      productName: 'string',
      region: 'string',
      status: 'string',
      utcActive: 'string',
      utcCreate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchQueryDeviceDetailResponseBodyData extends $tea.Model {
  data?: BatchQueryDeviceDetailResponseBodyDataData[];
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': BatchQueryDeviceDetailResponseBodyDataData },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchRegisterDeviceResponseBodyData extends $tea.Model {
  applyId?: number;
  static names(): { [key: string]: string } {
    return {
      applyId: 'ApplyId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applyId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchRegisterDeviceWithApplyIdResponseBodyData extends $tea.Model {
  applyId?: number;
  static names(): { [key: string]: string } {
    return {
      applyId: 'ApplyId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applyId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchSetEdgeInstanceDeviceConfigRequestDeviceConfigs extends $tea.Model {
  content?: string;
  iotId?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      iotId: 'IotId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      iotId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchUnbindProjectDevicesRequestDevices extends $tea.Model {
  deviceName?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchUpdateDeviceNicknameRequestDeviceNicknameInfo extends $tea.Model {
  deviceName?: string;
  iotId?: string;
  nickname?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      nickname: 'Nickname',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      nickname: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BindLicenseDeviceResponseBodyData extends $tea.Model {
  checkProgressId?: string;
  failSum?: number;
  progress?: number;
  resultCsvFile?: string;
  successSum?: number;
  static names(): { [key: string]: string } {
    return {
      checkProgressId: 'CheckProgressId',
      failSum: 'FailSum',
      progress: 'Progress',
      resultCsvFile: 'ResultCsvFile',
      successSum: 'SuccessSum',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkProgressId: 'string',
      failSum: 'number',
      progress: 'number',
      resultCsvFile: 'string',
      successSum: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CheckBindLicenseDeviceProgressResponseBodyData extends $tea.Model {
  failSum?: number;
  progress?: number;
  resultCsvFile?: string;
  successSum?: number;
  static names(): { [key: string]: string } {
    return {
      failSum: 'FailSum',
      progress: 'Progress',
      resultCsvFile: 'ResultCsvFile',
      successSum: 'SuccessSum',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failSum: 'number',
      progress: 'number',
      resultCsvFile: 'string',
      successSum: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ClearDeviceDesiredPropertyResponseBodyData extends $tea.Model {
  versions?: string;
  static names(): { [key: string]: string } {
    return {
      versions: 'Versions',
    };
  }

  static types(): { [key: string]: any } {
    return {
      versions: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataAPIServiceRequestRequestParam extends $tea.Model {
  desc?: string;
  example?: string;
  name?: string;
  required?: boolean;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      desc: 'Desc',
      example: 'Example',
      name: 'Name',
      required: 'Required',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      desc: 'string',
      example: 'string',
      name: 'string',
      required: 'boolean',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataAPIServiceRequestResponseParam extends $tea.Model {
  desc?: string;
  example?: string;
  name?: string;
  required?: boolean;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      desc: 'Desc',
      example: 'Example',
      name: 'Name',
      required: 'Required',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      desc: 'string',
      example: 'string',
      name: 'string',
      required: 'boolean',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataAPIServiceResponseBodyData extends $tea.Model {
  apiSrn?: string;
  createTime?: number;
  lastUpdateTime?: number;
  static names(): { [key: string]: string } {
    return {
      apiSrn: 'ApiSrn',
      createTime: 'CreateTime',
      lastUpdateTime: 'LastUpdateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiSrn: 'string',
      createTime: 'number',
      lastUpdateTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDestinationResponseBodyDestination extends $tea.Model {
  configuration?: string;
  destinationId?: number;
  isFailover?: boolean;
  name?: string;
  type?: string;
  utcCreated?: string;
  static names(): { [key: string]: string } {
    return {
      configuration: 'Configuration',
      destinationId: 'DestinationId',
      isFailover: 'IsFailover',
      name: 'Name',
      type: 'Type',
      utcCreated: 'UtcCreated',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configuration: 'string',
      destinationId: 'number',
      isFailover: 'boolean',
      name: 'string',
      type: 'string',
      utcCreated: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDeviceDistributeJobRequestTargetInstanceConfig extends $tea.Model {
  targetInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      targetInstanceId: 'TargetInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      targetInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDeviceDynamicGroupResponseBodyData extends $tea.Model {
  dynamicGroupExpression?: string;
  groupDesc?: string;
  groupId?: string;
  groupName?: string;
  utcCreate?: string;
  static names(): { [key: string]: string } {
    return {
      dynamicGroupExpression: 'DynamicGroupExpression',
      groupDesc: 'GroupDesc',
      groupId: 'GroupId',
      groupName: 'GroupName',
      utcCreate: 'UtcCreate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dynamicGroupExpression: 'string',
      groupDesc: 'string',
      groupId: 'string',
      groupName: 'string',
      utcCreate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDeviceGroupResponseBodyData extends $tea.Model {
  groupDesc?: string;
  groupId?: string;
  groupName?: string;
  utcCreate?: string;
  static names(): { [key: string]: string } {
    return {
      groupDesc: 'GroupDesc',
      groupId: 'GroupId',
      groupName: 'GroupName',
      utcCreate: 'UtcCreate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupDesc: 'string',
      groupId: 'string',
      groupName: 'string',
      utcCreate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDeviceTunnelResponseBodyData extends $tea.Model {
  sourceAccessToken?: string;
  sourceURI?: string;
  tunnelId?: string;
  static names(): { [key: string]: string } {
    return {
      sourceAccessToken: 'SourceAccessToken',
      sourceURI: 'SourceURI',
      tunnelId: 'TunnelId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      sourceAccessToken: 'string',
      sourceURI: 'string',
      tunnelId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDownloadDataJobResponseBodyData extends $tea.Model {
  asyncExecute?: boolean;
  csvFileName?: string;
  csvUrl?: string;
  longJobId?: string;
  status?: number;
  static names(): { [key: string]: string } {
    return {
      asyncExecute: 'AsyncExecute',
      csvFileName: 'CsvFileName',
      csvUrl: 'CsvUrl',
      longJobId: 'LongJobId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      asyncExecute: 'boolean',
      csvFileName: 'string',
      csvUrl: 'string',
      longJobId: 'string',
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeInstanceChannelRequestConfigs extends $tea.Model {
  content?: string;
  format?: string;
  key?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      format: 'Format',
      key: 'Key',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      format: 'string',
      key: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeOssPreSignedAddressResponseBodyData extends $tea.Model {
  ossAddress?: string;
  ossPreSignedAddress?: string;
  static names(): { [key: string]: string } {
    return {
      ossAddress: 'OssAddress',
      ossPreSignedAddress: 'OssPreSignedAddress',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ossAddress: 'string',
      ossPreSignedAddress: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLoRaNodesTaskRequestDeviceInfo extends $tea.Model {
  devEui?: string;
  pinCode?: string;
  static names(): { [key: string]: string } {
    return {
      devEui: 'DevEui',
      pinCode: 'PinCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      devEui: 'string',
      pinCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOTADynamicUpgradeJobRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOTADynamicUpgradeJobResponseBodyData extends $tea.Model {
  jobId?: string;
  utcCreate?: string;
  static names(): { [key: string]: string } {
    return {
      jobId: 'JobId',
      utcCreate: 'UtcCreate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      jobId: 'string',
      utcCreate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOTAFirmwareRequestMultiFiles extends $tea.Model {
  fileMd5?: string;
  name?: string;
  signValue?: string;
  size?: number;
  url?: string;
  static names(): { [key: string]: string } {
    return {
      fileMd5: 'FileMd5',
      name: 'Name',
      signValue: 'SignValue',
      size: 'Size',
      url: 'Url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fileMd5: 'string',
      name: 'string',
      signValue: 'string',
      size: 'number',
      url: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOTAFirmwareResponseBodyData extends $tea.Model {
  firmwareId?: string;
  utcCreate?: string;
  static names(): { [key: string]: string } {
    return {
      firmwareId: 'FirmwareId',
      utcCreate: 'UtcCreate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      firmwareId: 'string',
      utcCreate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOTAStaticUpgradeJobRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOTAStaticUpgradeJobResponseBodyData extends $tea.Model {
  jobId?: string;
  utcCreate?: string;
  static names(): { [key: string]: string } {
    return {
      jobId: 'JobId',
      utcCreate: 'UtcCreate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      jobId: 'string',
      utcCreate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOTAVerifyJobRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOTAVerifyJobResponseBodyData extends $tea.Model {
  jobId?: string;
  utcCreate?: string;
  static names(): { [key: string]: string } {
    return {
      jobId: 'JobId',
      utcCreate: 'UtcCreate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      jobId: 'string',
      utcCreate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateParserDataSourceResponseBodyDataSource extends $tea.Model {
  dataSourceId?: number;
  description?: string;
  name?: string;
  utcCreated?: string;
  static names(): { [key: string]: string } {
    return {
      dataSourceId: 'DataSourceId',
      description: 'Description',
      name: 'Name',
      utcCreated: 'UtcCreated',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataSourceId: 'number',
      description: 'string',
      name: 'string',
      utcCreated: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProductResponseBodyData extends $tea.Model {
  aliyunCommodityCode?: string;
  authType?: string;
  dataFormat?: number;
  description?: string;
  id2?: boolean;
  nodeType?: number;
  productKey?: string;
  productName?: string;
  productSecret?: string;
  protocolType?: string;
  static names(): { [key: string]: string } {
    return {
      aliyunCommodityCode: 'AliyunCommodityCode',
      authType: 'AuthType',
      dataFormat: 'DataFormat',
      description: 'Description',
      id2: 'Id2',
      nodeType: 'NodeType',
      productKey: 'ProductKey',
      productName: 'ProductName',
      productSecret: 'ProductSecret',
      protocolType: 'ProtocolType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunCommodityCode: 'string',
      authType: 'string',
      dataFormat: 'number',
      description: 'string',
      id2: 'boolean',
      nodeType: 'number',
      productKey: 'string',
      productName: 'string',
      productSecret: 'string',
      protocolType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProductTagsRequestProductTag extends $tea.Model {
  tagKey?: string;
  tagValue?: string;
  static names(): { [key: string]: string } {
    return {
      tagKey: 'TagKey',
      tagValue: 'TagValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagKey: 'string',
      tagValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProductTagsResponseBodyInvalidProductTagsProductTag extends $tea.Model {
  tagKey?: string;
  tagValue?: string;
  static names(): { [key: string]: string } {
    return {
      tagKey: 'TagKey',
      tagValue: 'TagValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagKey: 'string',
      tagValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProductTagsResponseBodyInvalidProductTags extends $tea.Model {
  productTag?: CreateProductTagsResponseBodyInvalidProductTagsProductTag[];
  static names(): { [key: string]: string } {
    return {
      productTag: 'ProductTag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      productTag: { 'type': 'array', 'itemType': CreateProductTagsResponseBodyInvalidProductTagsProductTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateStudioAppDomainOpenResponseBodyData extends $tea.Model {
  appId?: string;
  host?: string;
  id?: number;
  isBeian?: string;
  projectId?: string;
  protocol?: string;
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      host: 'Host',
      id: 'Id',
      isBeian: 'IsBeian',
      projectId: 'ProjectId',
      protocol: 'Protocol',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      host: 'string',
      id: 'number',
      isBeian: 'string',
      projectId: 'string',
      protocol: 'string',
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTopicRouteTableResponseBodyFailureTopics extends $tea.Model {
  topic?: { [key: string]: any }[];
  static names(): { [key: string]: string } {
    return {
      topic: 'Topic',
    };
  }

  static types(): { [key: string]: any } {
    return {
      topic: { 'type': 'array', 'itemType': { 'type': 'map', 'keyType': 'string', 'valueType': 'any' } },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDeviceSpeechRequestDeviceSpeechList extends $tea.Model {
  audioFormat?: string;
  bizCode?: string;
  static names(): { [key: string]: string } {
    return {
      audioFormat: 'AudioFormat',
      bizCode: 'BizCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      audioFormat: 'string',
      bizCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteShareTaskDeviceResponseBodyData extends $tea.Model {
  progress?: number;
  progressId?: string;
  static names(): { [key: string]: string } {
    return {
      progress: 'Progress',
      progressId: 'ProgressId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      progress: 'number',
      progressId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTopicRouteTableResponseBodyFailureTopics extends $tea.Model {
  topic?: { [key: string]: any }[];
  static names(): { [key: string]: string } {
    return {
      topic: 'Topic',
    };
  }

  static types(): { [key: string]: any } {
    return {
      topic: { 'type': 'array', 'itemType': { 'type': 'map', 'keyType': 'string', 'valueType': 'any' } },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GenerateDeviceNameListURLResponseBodyData extends $tea.Model {
  accessKeyId?: string;
  fileUrl?: string;
  host?: string;
  key?: string;
  objectStorage?: string;
  policy?: string;
  signature?: string;
  utcCreate?: string;
  static names(): { [key: string]: string } {
    return {
      accessKeyId: 'AccessKeyId',
      fileUrl: 'FileUrl',
      host: 'Host',
      key: 'Key',
      objectStorage: 'ObjectStorage',
      policy: 'Policy',
      signature: 'Signature',
      utcCreate: 'UtcCreate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessKeyId: 'string',
      fileUrl: 'string',
      host: 'string',
      key: 'string',
      objectStorage: 'string',
      policy: 'string',
      signature: 'string',
      utcCreate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GenerateFileUploadURLResponseBodyData extends $tea.Model {
  host?: string;
  key?: string;
  objectStorage?: string;
  ossAccessKeyId?: string;
  policy?: string;
  signature?: string;
  static names(): { [key: string]: string } {
    return {
      host: 'Host',
      key: 'Key',
      objectStorage: 'ObjectStorage',
      ossAccessKeyId: 'OssAccessKeyId',
      policy: 'Policy',
      signature: 'Signature',
    };
  }

  static types(): { [key: string]: any } {
    return {
      host: 'string',
      key: 'string',
      objectStorage: 'string',
      ossAccessKeyId: 'string',
      policy: 'string',
      signature: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GenerateOTAUploadURLResponseBodyData extends $tea.Model {
  firmwareUrl?: string;
  host?: string;
  key?: string;
  OSSAccessKeyId?: string;
  objectStorage?: string;
  policy?: string;
  signature?: string;
  utcCreate?: string;
  static names(): { [key: string]: string } {
    return {
      firmwareUrl: 'FirmwareUrl',
      host: 'Host',
      key: 'Key',
      OSSAccessKeyId: 'OSSAccessKeyId',
      objectStorage: 'ObjectStorage',
      policy: 'Policy',
      signature: 'Signature',
      utcCreate: 'UtcCreate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      firmwareUrl: 'string',
      host: 'string',
      key: 'string',
      OSSAccessKeyId: 'string',
      objectStorage: 'string',
      policy: 'string',
      signature: 'string',
      utcCreate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParamsRequestParams extends $tea.Model {
  desc?: string;
  example?: string;
  name?: string;
  required?: boolean;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      desc: 'Desc',
      example: 'Example',
      name: 'Name',
      required: 'Required',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      desc: 'string',
      example: 'string',
      name: 'string',
      required: 'boolean',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParams extends $tea.Model {
  requestParams?: GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParamsRequestParams[];
  static names(): { [key: string]: string } {
    return {
      requestParams: 'RequestParams',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestParams: { 'type': 'array', 'itemType': GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParamsRequestParams },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParamsResponseParams extends $tea.Model {
  desc?: string;
  example?: string;
  name?: string;
  required?: boolean;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      desc: 'Desc',
      example: 'Example',
      name: 'Name',
      required: 'Required',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      desc: 'string',
      example: 'string',
      name: 'string',
      required: 'boolean',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParams extends $tea.Model {
  responseParams?: GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParamsResponseParams[];
  static names(): { [key: string]: string } {
    return {
      responseParams: 'ResponseParams',
    };
  }

  static types(): { [key: string]: any } {
    return {
      responseParams: { 'type': 'array', 'itemType': GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParamsResponseParams },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTO extends $tea.Model {
  originSql?: string;
  requestParams?: GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParams;
  responseParams?: GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParams;
  templateSql?: string;
  static names(): { [key: string]: string } {
    return {
      originSql: 'OriginSql',
      requestParams: 'RequestParams',
      responseParams: 'ResponseParams',
      templateSql: 'TemplateSql',
    };
  }

  static types(): { [key: string]: any } {
    return {
      originSql: 'string',
      requestParams: GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParams,
      responseParams: GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParams,
      templateSql: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataAPIServiceDetailResponseBodyData extends $tea.Model {
  apiPath?: string;
  apiSrn?: string;
  createTime?: number;
  dateFormat?: string;
  description?: string;
  displayName?: string;
  lastUpdateTime?: number;
  requestMethod?: string;
  requestProtocol?: string;
  sqlTemplateDTO?: GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTO;
  status?: number;
  static names(): { [key: string]: string } {
    return {
      apiPath: 'ApiPath',
      apiSrn: 'ApiSrn',
      createTime: 'CreateTime',
      dateFormat: 'DateFormat',
      description: 'Description',
      displayName: 'DisplayName',
      lastUpdateTime: 'LastUpdateTime',
      requestMethod: 'RequestMethod',
      requestProtocol: 'RequestProtocol',
      sqlTemplateDTO: 'SqlTemplateDTO',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiPath: 'string',
      apiSrn: 'string',
      createTime: 'number',
      dateFormat: 'string',
      description: 'string',
      displayName: 'string',
      lastUpdateTime: 'number',
      requestMethod: 'string',
      requestProtocol: 'string',
      sqlTemplateDTO: GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTO,
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDestinationResponseBodyDestination extends $tea.Model {
  configuration?: string;
  destinationId?: string;
  isFailover?: boolean;
  name?: string;
  status?: string;
  type?: string;
  utcCreated?: string;
  static names(): { [key: string]: string } {
    return {
      configuration: 'Configuration',
      destinationId: 'DestinationId',
      isFailover: 'IsFailover',
      name: 'Name',
      status: 'Status',
      type: 'Type',
      utcCreated: 'UtcCreated',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configuration: 'string',
      destinationId: 'string',
      isFailover: 'boolean',
      name: 'string',
      status: 'string',
      type: 'string',
      utcCreated: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDeviceStatusResponseBodyData extends $tea.Model {
  status?: string;
  timestamp?: number;
  static names(): { [key: string]: string } {
    return {
      status: 'Status',
      timestamp: 'Timestamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      status: 'string',
      timestamp: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDeviceTunnelShareStatusResponseBodyData extends $tea.Model {
  gmtOpened?: number;
  isOpen?: boolean;
  password?: string;
  shareId?: string;
  static names(): { [key: string]: string } {
    return {
      gmtOpened: 'GmtOpened',
      isOpen: 'IsOpen',
      password: 'Password',
      shareId: 'ShareId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gmtOpened: 'number',
      isOpen: 'boolean',
      password: 'string',
      shareId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDownloadFileResponseBodyDataHeader extends $tea.Model {
  alias?: string;
  dimDateClass?: string;
  fieldName?: string;
  fieldType?: string;
  geoClass?: string;
  timeClass?: string;
  typeClass?: string;
  static names(): { [key: string]: string } {
    return {
      alias: 'Alias',
      dimDateClass: 'DimDateClass',
      fieldName: 'FieldName',
      fieldType: 'FieldType',
      geoClass: 'GeoClass',
      timeClass: 'TimeClass',
      typeClass: 'TypeClass',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alias: 'string',
      dimDateClass: 'string',
      fieldName: 'string',
      fieldType: 'string',
      geoClass: 'string',
      timeClass: 'string',
      typeClass: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDownloadFileResponseBodyDataQuerySettingAstExpr extends $tea.Model {
  expr?: string;
  exprType?: string;
  static names(): { [key: string]: string } {
    return {
      expr: 'Expr',
      exprType: 'ExprType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      expr: 'string',
      exprType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDownloadFileResponseBodyDataQuerySettingSelectedHeaders extends $tea.Model {
  alias?: string;
  dimDateClass?: string;
  fieldName?: string;
  fieldType?: string;
  geoClass?: string;
  timeClass?: string;
  static names(): { [key: string]: string } {
    return {
      alias: 'Alias',
      dimDateClass: 'DimDateClass',
      fieldName: 'FieldName',
      fieldType: 'FieldType',
      geoClass: 'GeoClass',
      timeClass: 'TimeClass',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alias: 'string',
      dimDateClass: 'string',
      fieldName: 'string',
      fieldType: 'string',
      geoClass: 'string',
      timeClass: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDownloadFileResponseBodyDataQuerySetting extends $tea.Model {
  astExpr?: GetDownloadFileResponseBodyDataQuerySettingAstExpr[];
  selectedHeaders?: GetDownloadFileResponseBodyDataQuerySettingSelectedHeaders[];
  static names(): { [key: string]: string } {
    return {
      astExpr: 'AstExpr',
      selectedHeaders: 'SelectedHeaders',
    };
  }

  static types(): { [key: string]: any } {
    return {
      astExpr: { 'type': 'array', 'itemType': GetDownloadFileResponseBodyDataQuerySettingAstExpr },
      selectedHeaders: { 'type': 'array', 'itemType': GetDownloadFileResponseBodyDataQuerySettingSelectedHeaders },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDownloadFileResponseBodyData extends $tea.Model {
  asyncExecute?: boolean;
  beginTime?: number;
  csvFileName?: string;
  csvUrl?: string;
  datasetId?: string;
  endTime?: number;
  header?: GetDownloadFileResponseBodyDataHeader[];
  longJobId?: string;
  pageNo?: number;
  pageSize?: number;
  previewSize?: number;
  querySetting?: GetDownloadFileResponseBodyDataQuerySetting;
  result?: { [key: string]: any }[];
  resultDataInString?: string;
  status?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      asyncExecute: 'AsyncExecute',
      beginTime: 'BeginTime',
      csvFileName: 'CsvFileName',
      csvUrl: 'CsvUrl',
      datasetId: 'DatasetId',
      endTime: 'EndTime',
      header: 'Header',
      longJobId: 'LongJobId',
      pageNo: 'PageNo',
      pageSize: 'PageSize',
      previewSize: 'PreviewSize',
      querySetting: 'QuerySetting',
      result: 'Result',
      resultDataInString: 'ResultDataInString',
      status: 'Status',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      asyncExecute: 'boolean',
      beginTime: 'number',
      csvFileName: 'string',
      csvUrl: 'string',
      datasetId: 'string',
      endTime: 'number',
      header: { 'type': 'array', 'itemType': GetDownloadFileResponseBodyDataHeader },
      longJobId: 'string',
      pageNo: 'number',
      pageSize: 'number',
      previewSize: 'number',
      querySetting: GetDownloadFileResponseBodyDataQuerySetting,
      result: { 'type': 'array', 'itemType': { 'type': 'map', 'keyType': 'string', 'valueType': 'any' } },
      resultDataInString: 'string',
      status: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeDriverVersionResponseBodyData extends $tea.Model {
  argument?: string;
  configCheckRule?: string;
  containerConfig?: string;
  description?: string;
  driverConfig?: string;
  driverId?: string;
  driverVersion?: string;
  edgeVersion?: string;
  gmtCreateTimestamp?: number;
  gmtModifiedTimestamp?: number;
  sourceConfig?: string;
  versionState?: string;
  static names(): { [key: string]: string } {
    return {
      argument: 'Argument',
      configCheckRule: 'ConfigCheckRule',
      containerConfig: 'ContainerConfig',
      description: 'Description',
      driverConfig: 'DriverConfig',
      driverId: 'DriverId',
      driverVersion: 'DriverVersion',
      edgeVersion: 'EdgeVersion',
      gmtCreateTimestamp: 'GmtCreateTimestamp',
      gmtModifiedTimestamp: 'GmtModifiedTimestamp',
      sourceConfig: 'SourceConfig',
      versionState: 'VersionState',
    };
  }

  static types(): { [key: string]: any } {
    return {
      argument: 'string',
      configCheckRule: 'string',
      containerConfig: 'string',
      description: 'string',
      driverConfig: 'string',
      driverId: 'string',
      driverVersion: 'string',
      edgeVersion: 'string',
      gmtCreateTimestamp: 'number',
      gmtModifiedTimestamp: 'number',
      sourceConfig: 'string',
      versionState: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeInstanceResponseBodyData extends $tea.Model {
  bizEnable?: boolean;
  gmtCreate?: string;
  gmtCreateTimestamp?: number;
  gmtModified?: string;
  gmtModifiedTimestamp?: number;
  instanceId?: string;
  latestDeploymentStatus?: number;
  latestDeploymentType?: string;
  name?: string;
  roleArn?: string;
  roleAttachTime?: string;
  roleAttachTimestamp?: number;
  roleName?: string;
  spec?: number;
  tags?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      bizEnable: 'BizEnable',
      gmtCreate: 'GmtCreate',
      gmtCreateTimestamp: 'GmtCreateTimestamp',
      gmtModified: 'GmtModified',
      gmtModifiedTimestamp: 'GmtModifiedTimestamp',
      instanceId: 'InstanceId',
      latestDeploymentStatus: 'LatestDeploymentStatus',
      latestDeploymentType: 'LatestDeploymentType',
      name: 'Name',
      roleArn: 'RoleArn',
      roleAttachTime: 'RoleAttachTime',
      roleAttachTimestamp: 'RoleAttachTimestamp',
      roleName: 'RoleName',
      spec: 'Spec',
      tags: 'Tags',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizEnable: 'boolean',
      gmtCreate: 'string',
      gmtCreateTimestamp: 'number',
      gmtModified: 'string',
      gmtModifiedTimestamp: 'number',
      instanceId: 'string',
      latestDeploymentStatus: 'number',
      latestDeploymentType: 'string',
      name: 'string',
      roleArn: 'string',
      roleAttachTime: 'string',
      roleAttachTimestamp: 'number',
      roleName: 'string',
      spec: 'number',
      tags: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeInstanceDeploymentResponseBodyDataTaskListResourceSnapshotList extends $tea.Model {
  gmtCompleted?: string;
  gmtCompletedTimestamp?: number;
  gmtCreate?: string;
  gmtCreateTimestamp?: number;
  gmtModified?: string;
  gmtModifiedTimestamp?: number;
  log?: string;
  operateType?: number;
  resourceId?: string;
  resourceName?: string;
  resourceType?: string;
  snapshotId?: string;
  stage?: number;
  status?: number;
  static names(): { [key: string]: string } {
    return {
      gmtCompleted: 'GmtCompleted',
      gmtCompletedTimestamp: 'GmtCompletedTimestamp',
      gmtCreate: 'GmtCreate',
      gmtCreateTimestamp: 'GmtCreateTimestamp',
      gmtModified: 'GmtModified',
      gmtModifiedTimestamp: 'GmtModifiedTimestamp',
      log: 'Log',
      operateType: 'OperateType',
      resourceId: 'ResourceId',
      resourceName: 'ResourceName',
      resourceType: 'ResourceType',
      snapshotId: 'SnapshotId',
      stage: 'Stage',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gmtCompleted: 'string',
      gmtCompletedTimestamp: 'number',
      gmtCreate: 'string',
      gmtCreateTimestamp: 'number',
      gmtModified: 'string',
      gmtModifiedTimestamp: 'number',
      log: 'string',
      operateType: 'number',
      resourceId: 'string',
      resourceName: 'string',
      resourceType: 'string',
      snapshotId: 'string',
      stage: 'number',
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeInstanceDeploymentResponseBodyDataTaskList extends $tea.Model {
  gatewayId?: string;
  gmtCompleted?: string;
  gmtCompletedTimestamp?: number;
  gmtCreate?: string;
  gmtCreateTimestamp?: number;
  gmtModified?: string;
  gmtModifiedTimestamp?: number;
  resourceSnapshotList?: GetEdgeInstanceDeploymentResponseBodyDataTaskListResourceSnapshotList[];
  stage?: number;
  status?: number;
  taskId?: string;
  static names(): { [key: string]: string } {
    return {
      gatewayId: 'GatewayId',
      gmtCompleted: 'GmtCompleted',
      gmtCompletedTimestamp: 'GmtCompletedTimestamp',
      gmtCreate: 'GmtCreate',
      gmtCreateTimestamp: 'GmtCreateTimestamp',
      gmtModified: 'GmtModified',
      gmtModifiedTimestamp: 'GmtModifiedTimestamp',
      resourceSnapshotList: 'ResourceSnapshotList',
      stage: 'Stage',
      status: 'Status',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gatewayId: 'string',
      gmtCompleted: 'string',
      gmtCompletedTimestamp: 'number',
      gmtCreate: 'string',
      gmtCreateTimestamp: 'number',
      gmtModified: 'string',
      gmtModifiedTimestamp: 'number',
      resourceSnapshotList: { 'type': 'array', 'itemType': GetEdgeInstanceDeploymentResponseBodyDataTaskListResourceSnapshotList },
      stage: 'number',
      status: 'number',
      taskId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeInstanceDeploymentResponseBodyData extends $tea.Model {
  deploymentId?: string;
  description?: string;
  gmtCompleted?: string;
  gmtCompletedTimestamp?: number;
  gmtCreate?: string;
  gmtCreateTimestamp?: number;
  gmtModified?: string;
  gmtModifiedTimestamp?: number;
  status?: number;
  taskList?: GetEdgeInstanceDeploymentResponseBodyDataTaskList[];
  type?: string;
  static names(): { [key: string]: string } {
    return {
      deploymentId: 'DeploymentId',
      description: 'Description',
      gmtCompleted: 'GmtCompleted',
      gmtCompletedTimestamp: 'GmtCompletedTimestamp',
      gmtCreate: 'GmtCreate',
      gmtCreateTimestamp: 'GmtCreateTimestamp',
      gmtModified: 'GmtModified',
      gmtModifiedTimestamp: 'GmtModifiedTimestamp',
      status: 'Status',
      taskList: 'TaskList',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deploymentId: 'string',
      description: 'string',
      gmtCompleted: 'string',
      gmtCompletedTimestamp: 'number',
      gmtCreate: 'string',
      gmtCreateTimestamp: 'number',
      gmtModified: 'string',
      gmtModifiedTimestamp: 'number',
      status: 'number',
      taskList: { 'type': 'array', 'itemType': GetEdgeInstanceDeploymentResponseBodyDataTaskList },
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeInstanceMessageRoutingResponseBodyDataRouteContext extends $tea.Model {
  qos?: string;
  sourceApplicationName?: string;
  sourceFcFunctionName?: string;
  sourceFcServiceName?: string;
  targetApplicationName?: string;
  targetFcFunctionName?: string;
  targetFcServiceName?: string;
  static names(): { [key: string]: string } {
    return {
      qos: 'Qos',
      sourceApplicationName: 'SourceApplicationName',
      sourceFcFunctionName: 'SourceFcFunctionName',
      sourceFcServiceName: 'SourceFcServiceName',
      targetApplicationName: 'TargetApplicationName',
      targetFcFunctionName: 'TargetFcFunctionName',
      targetFcServiceName: 'TargetFcServiceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      qos: 'string',
      sourceApplicationName: 'string',
      sourceFcFunctionName: 'string',
      sourceFcServiceName: 'string',
      targetApplicationName: 'string',
      targetFcFunctionName: 'string',
      targetFcServiceName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeInstanceMessageRoutingResponseBodyData extends $tea.Model {
  gmtCreate?: string;
  gmtCreateTimestamp?: number;
  gmtModified?: string;
  gmtModifiedTimestamp?: number;
  name?: string;
  routeContext?: GetEdgeInstanceMessageRoutingResponseBodyDataRouteContext;
  sourceData?: string;
  sourceType?: string;
  targetData?: string;
  targetType?: string;
  topicFilter?: string;
  static names(): { [key: string]: string } {
    return {
      gmtCreate: 'GmtCreate',
      gmtCreateTimestamp: 'GmtCreateTimestamp',
      gmtModified: 'GmtModified',
      gmtModifiedTimestamp: 'GmtModifiedTimestamp',
      name: 'Name',
      routeContext: 'RouteContext',
      sourceData: 'SourceData',
      sourceType: 'SourceType',
      targetData: 'TargetData',
      targetType: 'TargetType',
      topicFilter: 'TopicFilter',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gmtCreate: 'string',
      gmtCreateTimestamp: 'number',
      gmtModified: 'string',
      gmtModifiedTimestamp: 'number',
      name: 'string',
      routeContext: GetEdgeInstanceMessageRoutingResponseBodyDataRouteContext,
      sourceData: 'string',
      sourceType: 'string',
      targetData: 'string',
      targetType: 'string',
      topicFilter: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGatewayBySubDeviceResponseBodyData extends $tea.Model {
  deviceName?: string;
  deviceSecret?: string;
  firmwareVersion?: string;
  gmtActive?: string;
  gmtCreate?: string;
  gmtOnline?: string;
  ipAddress?: string;
  nodeType?: string;
  productKey?: string;
  productName?: string;
  status?: string;
  utcActive?: string;
  utcCreate?: string;
  utcOnline?: string;
  iotId?: string;
  region?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      deviceSecret: 'DeviceSecret',
      firmwareVersion: 'FirmwareVersion',
      gmtActive: 'GmtActive',
      gmtCreate: 'GmtCreate',
      gmtOnline: 'GmtOnline',
      ipAddress: 'IpAddress',
      nodeType: 'NodeType',
      productKey: 'ProductKey',
      productName: 'ProductName',
      status: 'Status',
      utcActive: 'UtcActive',
      utcCreate: 'UtcCreate',
      utcOnline: 'UtcOnline',
      iotId: 'iotId',
      region: 'region',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      deviceSecret: 'string',
      firmwareVersion: 'string',
      gmtActive: 'string',
      gmtCreate: 'string',
      gmtOnline: 'string',
      ipAddress: 'string',
      nodeType: 'string',
      productKey: 'string',
      productName: 'string',
      status: 'string',
      utcActive: 'string',
      utcCreate: 'string',
      utcOnline: 'string',
      iotId: 'string',
      region: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetLoraNodesTaskResponseBodySuccessDevEuis extends $tea.Model {
  successDevEui?: string[];
  static names(): { [key: string]: string } {
    return {
      successDevEui: 'SuccessDevEui',
    };
  }

  static types(): { [key: string]: any } {
    return {
      successDevEui: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetParserResponseBodyData extends $tea.Model {
  dataSourceId?: number;
  description?: string;
  name?: string;
  parserId?: number;
  script?: string;
  scriptDraft?: string;
  status?: string;
  utcCreated?: string;
  utcModified?: string;
  static names(): { [key: string]: string } {
    return {
      dataSourceId: 'DataSourceId',
      description: 'Description',
      name: 'Name',
      parserId: 'ParserId',
      script: 'Script',
      scriptDraft: 'ScriptDraft',
      status: 'Status',
      utcCreated: 'UtcCreated',
      utcModified: 'UtcModified',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataSourceId: 'number',
      description: 'string',
      name: 'string',
      parserId: 'number',
      script: 'string',
      scriptDraft: 'string',
      status: 'string',
      utcCreated: 'string',
      utcModified: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetParserDataSourceResponseBodyDataSource extends $tea.Model {
  createUserId?: number;
  dataSourceId?: number;
  description?: string;
  name?: string;
  utcCreated?: string;
  static names(): { [key: string]: string } {
    return {
      createUserId: 'CreateUserId',
      dataSourceId: 'DataSourceId',
      description: 'Description',
      name: 'Name',
      utcCreated: 'UtcCreated',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createUserId: 'number',
      dataSourceId: 'number',
      description: 'string',
      name: 'string',
      utcCreated: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRuleResponseBodyRuleInfo extends $tea.Model {
  createUserId?: number;
  created?: string;
  dataType?: string;
  id?: number;
  modified?: string;
  name?: string;
  productKey?: string;
  ruleDesc?: string;
  select?: string;
  shortTopic?: string;
  status?: string;
  topic?: string;
  topicType?: number;
  utcCreated?: string;
  utcModified?: string;
  where?: string;
  static names(): { [key: string]: string } {
    return {
      createUserId: 'CreateUserId',
      created: 'Created',
      dataType: 'DataType',
      id: 'Id',
      modified: 'Modified',
      name: 'Name',
      productKey: 'ProductKey',
      ruleDesc: 'RuleDesc',
      select: 'Select',
      shortTopic: 'ShortTopic',
      status: 'Status',
      topic: 'Topic',
      topicType: 'TopicType',
      utcCreated: 'UtcCreated',
      utcModified: 'UtcModified',
      where: 'Where',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createUserId: 'number',
      created: 'string',
      dataType: 'string',
      id: 'number',
      modified: 'string',
      name: 'string',
      productKey: 'string',
      ruleDesc: 'string',
      select: 'string',
      shortTopic: 'string',
      status: 'string',
      topic: 'string',
      topicType: 'number',
      utcCreated: 'string',
      utcModified: 'string',
      where: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRuleActionResponseBodyRuleActionInfo extends $tea.Model {
  configuration?: string;
  errorActionFlag?: boolean;
  id?: number;
  ruleId?: number;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      configuration: 'Configuration',
      errorActionFlag: 'ErrorActionFlag',
      id: 'Id',
      ruleId: 'RuleId',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configuration: 'string',
      errorActionFlag: 'boolean',
      id: 'number',
      ruleId: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSceneRuleResponseBodyData extends $tea.Model {
  gmtCreate?: number;
  gmtModified?: number;
  ruleContent?: string;
  ruleDescription?: string;
  ruleName?: string;
  ruleStatus?: number;
  static names(): { [key: string]: string } {
    return {
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      ruleContent: 'RuleContent',
      ruleDescription: 'RuleDescription',
      ruleName: 'RuleName',
      ruleStatus: 'RuleStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gmtCreate: 'number',
      gmtModified: 'number',
      ruleContent: 'string',
      ruleDescription: 'string',
      ruleName: 'string',
      ruleStatus: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetShareSpeechModelAudioResponseBodyData extends $tea.Model {
  data?: string[];
  static names(): { [key: string]: string } {
    return {
      data: 'data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSoundCodeAudioResponseBodyData extends $tea.Model {
  items?: string[];
  static names(): { [key: string]: string } {
    return {
      items: 'Items',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSoundCodeScheduleResponseBodyData extends $tea.Model {
  description?: string;
  endDate?: string;
  endTime?: string;
  gmtCreate?: number;
  name?: string;
  openType?: string;
  scheduleCode?: string;
  startDate?: string;
  startTime?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      endDate: 'EndDate',
      endTime: 'EndTime',
      gmtCreate: 'GmtCreate',
      name: 'Name',
      openType: 'OpenType',
      scheduleCode: 'ScheduleCode',
      startDate: 'StartDate',
      startTime: 'StartTime',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      endDate: 'string',
      endTime: 'string',
      gmtCreate: 'number',
      name: 'string',
      openType: 'string',
      scheduleCode: 'string',
      startDate: 'string',
      startTime: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSpeechDeviceDetailResponseBodyData extends $tea.Model {
  availableSpace?: number;
  deviceName?: string;
  iotId?: string;
  productKey?: string;
  speechListUpdateTime?: number;
  status?: string;
  totalSpace?: number;
  static names(): { [key: string]: string } {
    return {
      availableSpace: 'AvailableSpace',
      deviceName: 'DeviceName',
      iotId: 'IotId',
      productKey: 'ProductKey',
      speechListUpdateTime: 'SpeechListUpdateTime',
      status: 'Status',
      totalSpace: 'TotalSpace',
    };
  }

  static types(): { [key: string]: any } {
    return {
      availableSpace: 'number',
      deviceName: 'string',
      iotId: 'string',
      productKey: 'string',
      speechListUpdateTime: 'number',
      status: 'string',
      totalSpace: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSpeechLicenseDeviceStatisticsResponseBodyData extends $tea.Model {
  availableQuota?: number;
  expiredQuota?: number;
  expiringQuota?: number;
  static names(): { [key: string]: string } {
    return {
      availableQuota: 'AvailableQuota',
      expiredQuota: 'ExpiredQuota',
      expiringQuota: 'ExpiringQuota',
    };
  }

  static types(): { [key: string]: any } {
    return {
      availableQuota: 'number',
      expiredQuota: 'number',
      expiringQuota: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSpeechVoiceResponseBodyDataItemsVoiceListItems extends $tea.Model {
  label?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      label: 'Label',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      label: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSpeechVoiceResponseBodyDataItemsVoiceList extends $tea.Model {
  items?: GetSpeechVoiceResponseBodyDataItemsVoiceListItems[];
  static names(): { [key: string]: string } {
    return {
      items: 'Items',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: { 'type': 'array', 'itemType': GetSpeechVoiceResponseBodyDataItemsVoiceListItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSpeechVoiceResponseBodyDataItems extends $tea.Model {
  label?: string;
  value?: string;
  voiceList?: GetSpeechVoiceResponseBodyDataItemsVoiceList;
  static names(): { [key: string]: string } {
    return {
      label: 'Label',
      value: 'Value',
      voiceList: 'VoiceList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      label: 'string',
      value: 'string',
      voiceList: GetSpeechVoiceResponseBodyDataItemsVoiceList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSpeechVoiceResponseBodyData extends $tea.Model {
  items?: GetSpeechVoiceResponseBodyDataItems[];
  static names(): { [key: string]: string } {
    return {
      items: 'Items',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: { 'type': 'array', 'itemType': GetSpeechVoiceResponseBodyDataItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStudioAppTokenOpenResponseBodyData extends $tea.Model {
  bizId?: string;
  bizType?: string;
  isEnable?: string;
  token?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      bizId: 'BizId',
      bizType: 'BizType',
      isEnable: 'IsEnable',
      token: 'Token',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizId: 'string',
      bizType: 'string',
      isEnable: 'string',
      token: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetThingModelTslResponseBodyData extends $tea.Model {
  tslStr?: string;
  tslUri?: string;
  static names(): { [key: string]: string } {
    return {
      tslStr: 'TslStr',
      tslUri: 'TslUri',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tslStr: 'string',
      tslUri: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetThingModelTslPublishedResponseBodyData extends $tea.Model {
  tslStr?: string;
  tslUri?: string;
  static names(): { [key: string]: string } {
    return {
      tslStr: 'TslStr',
      tslUri: 'TslUri',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tslStr: 'string',
      tslUri: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetThingScriptResponseBodyData extends $tea.Model {
  scriptType?: string;
  scriptUrl?: string;
  static names(): { [key: string]: string } {
    return {
      scriptType: 'ScriptType',
      scriptUrl: 'ScriptUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      scriptType: 'string',
      scriptUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetThingTopoResponseBodyDataListDeviceInfo extends $tea.Model {
  deviceName?: string;
  iotId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetThingTopoResponseBodyDataList extends $tea.Model {
  deviceInfo?: GetThingTopoResponseBodyDataListDeviceInfo[];
  static names(): { [key: string]: string } {
    return {
      deviceInfo: 'deviceInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceInfo: { 'type': 'array', 'itemType': GetThingTopoResponseBodyDataListDeviceInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetThingTopoResponseBodyData extends $tea.Model {
  currentPage?: number;
  list?: GetThingTopoResponseBodyDataList;
  pageCount?: number;
  pageSize?: number;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      list: 'List',
      pageCount: 'PageCount',
      pageSize: 'PageSize',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      list: GetThingTopoResponseBodyDataList,
      pageCount: 'number',
      pageSize: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GisQueryDeviceLocationRequestThingList extends $tea.Model {
  deviceName?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GisQueryDeviceLocationResponseBodyData extends $tea.Model {
  adcode?: number;
  city?: string;
  coordinateSystem?: number;
  country?: string;
  deviceName?: string;
  ip?: string;
  latitude?: number;
  longitude?: number;
  productKey?: string;
  province?: string;
  static names(): { [key: string]: string } {
    return {
      adcode: 'Adcode',
      city: 'City',
      coordinateSystem: 'CoordinateSystem',
      country: 'Country',
      deviceName: 'DeviceName',
      ip: 'Ip',
      latitude: 'Latitude',
      longitude: 'Longitude',
      productKey: 'ProductKey',
      province: 'Province',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adcode: 'number',
      city: 'string',
      coordinateSystem: 'number',
      country: 'string',
      deviceName: 'string',
      ip: 'string',
      latitude: 'number',
      longitude: 'number',
      productKey: 'string',
      province: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GisSearchDeviceTraceResponseBodyDataPoints extends $tea.Model {
  locateTime?: number;
  location?: string;
  static names(): { [key: string]: string } {
    return {
      locateTime: 'LocateTime',
      location: 'Location',
    };
  }

  static types(): { [key: string]: any } {
    return {
      locateTime: 'number',
      location: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GisSearchDeviceTraceResponseBodyData extends $tea.Model {
  deviceName?: string;
  points?: GisSearchDeviceTraceResponseBodyDataPoints[];
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      points: 'Points',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      points: { 'type': 'array', 'itemType': GisSearchDeviceTraceResponseBodyDataPoints },
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportDTDataRequestItems extends $tea.Model {
  deviceName?: string;
  params?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      params: 'Params',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      params: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportDeviceResponseBodyData extends $tea.Model {
  deviceName?: string;
  deviceSecret?: string;
  iotId?: string;
  nickname?: string;
  productKey?: string;
  sn?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      deviceSecret: 'DeviceSecret',
      iotId: 'IotId',
      nickname: 'Nickname',
      productKey: 'ProductKey',
      sn: 'Sn',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      deviceSecret: 'string',
      iotId: 'string',
      nickname: 'string',
      productKey: 'string',
      sn: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InvokeDataAPIServiceRequestParam extends $tea.Model {
  listParamType?: string;
  listParamValue?: string[];
  paramName?: string;
  paramType?: string;
  paramValue?: string;
  static names(): { [key: string]: string } {
    return {
      listParamType: 'ListParamType',
      listParamValue: 'ListParamValue',
      paramName: 'ParamName',
      paramType: 'ParamType',
      paramValue: 'ParamValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      listParamType: 'string',
      listParamValue: { 'type': 'array', 'itemType': 'string' },
      paramName: 'string',
      paramType: 'string',
      paramValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InvokeDataAPIServiceResponseBodyDataFieldNameList extends $tea.Model {
  fieldNameList?: string[];
  static names(): { [key: string]: string } {
    return {
      fieldNameList: 'FieldNameList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fieldNameList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InvokeDataAPIServiceResponseBodyDataResultList extends $tea.Model {
  resultList?: { [key: string]: any }[];
  static names(): { [key: string]: string } {
    return {
      resultList: 'ResultList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resultList: { 'type': 'array', 'itemType': { 'type': 'map', 'keyType': 'string', 'valueType': 'any' } },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InvokeDataAPIServiceResponseBodyData extends $tea.Model {
  apiSrn?: string;
  fieldNameList?: InvokeDataAPIServiceResponseBodyDataFieldNameList;
  pageNo?: number;
  pageSize?: number;
  resultList?: InvokeDataAPIServiceResponseBodyDataResultList;
  totalSize?: number;
  static names(): { [key: string]: string } {
    return {
      apiSrn: 'ApiSrn',
      fieldNameList: 'FieldNameList',
      pageNo: 'PageNo',
      pageSize: 'PageSize',
      resultList: 'ResultList',
      totalSize: 'TotalSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiSrn: 'string',
      fieldNameList: InvokeDataAPIServiceResponseBodyDataFieldNameList,
      pageNo: 'number',
      pageSize: 'number',
      resultList: InvokeDataAPIServiceResponseBodyDataResultList,
      totalSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InvokeThingServiceResponseBodyData extends $tea.Model {
  messageId?: string;
  result?: string;
  static names(): { [key: string]: string } {
    return {
      messageId: 'MessageId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      messageId: 'string',
      result: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAnalyticsDataRequestCondition extends $tea.Model {
  betweenEnd?: string;
  betweenStart?: string;
  fieldName?: string;
  operate?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      betweenEnd: 'BetweenEnd',
      betweenStart: 'BetweenStart',
      fieldName: 'FieldName',
      operate: 'Operate',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      betweenEnd: 'string',
      betweenStart: 'string',
      fieldName: 'string',
      operate: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAnalyticsDataResponseBodyData extends $tea.Model {
  count?: number;
  hasNext?: boolean;
  pageNum?: number;
  pageSize?: number;
  resultJson?: string;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      hasNext: 'HasNext',
      pageNum: 'PageNum',
      pageSize: 'PageSize',
      resultJson: 'ResultJson',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      hasNext: 'boolean',
      pageNum: 'number',
      pageSize: 'number',
      resultJson: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataSourceItemResponseBodyDataSourceItemsDataSourceItem extends $tea.Model {
  dataSourceItemId?: number;
  deviceName?: string;
  productKey?: string;
  scopeType?: string;
  topic?: string;
  static names(): { [key: string]: string } {
    return {
      dataSourceItemId: 'DataSourceItemId',
      deviceName: 'DeviceName',
      productKey: 'ProductKey',
      scopeType: 'ScopeType',
      topic: 'Topic',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataSourceItemId: 'number',
      deviceName: 'string',
      productKey: 'string',
      scopeType: 'string',
      topic: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataSourceItemResponseBodyDataSourceItems extends $tea.Model {
  dataSourceItem?: ListDataSourceItemResponseBodyDataSourceItemsDataSourceItem[];
  static names(): { [key: string]: string } {
    return {
      dataSourceItem: 'dataSourceItem',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataSourceItem: { 'type': 'array', 'itemType': ListDataSourceItemResponseBodyDataSourceItemsDataSourceItem },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDestinationResponseBodyDestinationsDestinations extends $tea.Model {
  configuration?: string;
  description?: string;
  destinationId?: number;
  isFailover?: boolean;
  name?: string;
  status?: string;
  type?: string;
  utcCreated?: string;
  static names(): { [key: string]: string } {
    return {
      configuration: 'Configuration',
      description: 'Description',
      destinationId: 'DestinationId',
      isFailover: 'IsFailover',
      name: 'Name',
      status: 'Status',
      type: 'Type',
      utcCreated: 'UtcCreated',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configuration: 'string',
      description: 'string',
      destinationId: 'number',
      isFailover: 'boolean',
      name: 'string',
      status: 'string',
      type: 'string',
      utcCreated: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDestinationResponseBodyDestinations extends $tea.Model {
  destinations?: ListDestinationResponseBodyDestinationsDestinations[];
  static names(): { [key: string]: string } {
    return {
      destinations: 'destinations',
    };
  }

  static types(): { [key: string]: any } {
    return {
      destinations: { 'type': 'array', 'itemType': ListDestinationResponseBodyDestinationsDestinations },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDeviceDistributeJobResponseBodyDataJobInfoItemsTargetInstanceConfigsTargetInstanceConfigs extends $tea.Model {
  targetInstanceId?: string;
  targetInstanceName?: string;
  targetRegion?: string;
  static names(): { [key: string]: string } {
    return {
      targetInstanceId: 'TargetInstanceId',
      targetInstanceName: 'TargetInstanceName',
      targetRegion: 'TargetRegion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      targetInstanceId: 'string',
      targetInstanceName: 'string',
      targetRegion: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDeviceDistributeJobResponseBodyDataJobInfoItemsTargetInstanceConfigs extends $tea.Model {
  targetInstanceConfigs?: ListDeviceDistributeJobResponseBodyDataJobInfoItemsTargetInstanceConfigsTargetInstanceConfigs[];
  static names(): { [key: string]: string } {
    return {
      targetInstanceConfigs: 'targetInstanceConfigs',
    };
  }

  static types(): { [key: string]: any } {
    return {
      targetInstanceConfigs: { 'type': 'array', 'itemType': ListDeviceDistributeJobResponseBodyDataJobInfoItemsTargetInstanceConfigsTargetInstanceConfigs },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDeviceDistributeJobResponseBodyDataJobInfoItems extends $tea.Model {
  gmtCreate?: number;
  jobId?: string;
  productKey?: string;
  sourceInstanceId?: string;
  sourceInstanceName?: string;
  sourceRegion?: string;
  sourceUid?: string;
  status?: number;
  strategy?: number;
  targetInstanceConfigs?: ListDeviceDistributeJobResponseBodyDataJobInfoItemsTargetInstanceConfigs;
  targetUid?: string;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      gmtCreate: 'GmtCreate',
      jobId: 'JobId',
      productKey: 'ProductKey',
      sourceInstanceId: 'SourceInstanceId',
      sourceInstanceName: 'SourceInstanceName',
      sourceRegion: 'SourceRegion',
      sourceUid: 'SourceUid',
      status: 'Status',
      strategy: 'Strategy',
      targetInstanceConfigs: 'TargetInstanceConfigs',
      targetUid: 'TargetUid',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gmtCreate: 'number',
      jobId: 'string',
      productKey: 'string',
      sourceInstanceId: 'string',
      sourceInstanceName: 'string',
      sourceRegion: 'string',
      sourceUid: 'string',
      status: 'number',
      strategy: 'number',
      targetInstanceConfigs: ListDeviceDistributeJobResponseBodyDataJobInfoItemsTargetInstanceConfigs,
      targetUid: 'string',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDeviceDistributeJobResponseBodyDataJobInfo extends $tea.Model {
  items?: ListDeviceDistributeJobResponseBodyDataJobInfoItems[];
  static names(): { [key: string]: string } {
    return {
      items: 'items',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: { 'type': 'array', 'itemType': ListDeviceDistributeJobResponseBodyDataJobInfoItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDeviceDistributeJobResponseBodyData extends $tea.Model {
  jobInfo?: ListDeviceDistributeJobResponseBodyDataJobInfo;
  nextToken?: string;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      jobInfo: 'JobInfo',
      nextToken: 'NextToken',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      jobInfo: ListDeviceDistributeJobResponseBodyDataJobInfo,
      nextToken: 'string',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDistributedDeviceResponseBodyDataInfoItems extends $tea.Model {
  deviceName?: string;
  gmtCreate?: number;
  gmtModified?: number;
  productKey?: string;
  sourceInstanceId?: string;
  sourceInstanceName?: string;
  sourceRegion?: string;
  sourceUid?: string;
  targetAliyunId?: string;
  targetInstanceId?: string;
  targetInstanceName?: string;
  targetRegion?: string;
  targetUid?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      productKey: 'ProductKey',
      sourceInstanceId: 'SourceInstanceId',
      sourceInstanceName: 'SourceInstanceName',
      sourceRegion: 'SourceRegion',
      sourceUid: 'SourceUid',
      targetAliyunId: 'TargetAliyunId',
      targetInstanceId: 'TargetInstanceId',
      targetInstanceName: 'TargetInstanceName',
      targetRegion: 'TargetRegion',
      targetUid: 'TargetUid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      gmtCreate: 'number',
      gmtModified: 'number',
      productKey: 'string',
      sourceInstanceId: 'string',
      sourceInstanceName: 'string',
      sourceRegion: 'string',
      sourceUid: 'string',
      targetAliyunId: 'string',
      targetInstanceId: 'string',
      targetInstanceName: 'string',
      targetRegion: 'string',
      targetUid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDistributedDeviceResponseBodyDataInfo extends $tea.Model {
  items?: ListDistributedDeviceResponseBodyDataInfoItems[];
  static names(): { [key: string]: string } {
    return {
      items: 'items',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: { 'type': 'array', 'itemType': ListDistributedDeviceResponseBodyDataInfoItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDistributedDeviceResponseBodyData extends $tea.Model {
  info?: ListDistributedDeviceResponseBodyDataInfo;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      info: 'Info',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      info: ListDistributedDeviceResponseBodyDataInfo,
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDistributedProductResponseBodyDataInfoItems extends $tea.Model {
  gmtCreate?: number;
  productKey?: string;
  sourceInstanceId?: string;
  sourceInstanceName?: string;
  sourceRegion?: string;
  sourceUid?: string;
  targetAliyunId?: string;
  targetInstanceId?: string;
  targetInstanceName?: string;
  targetRegion?: string;
  targetUid?: string;
  static names(): { [key: string]: string } {
    return {
      gmtCreate: 'GmtCreate',
      productKey: 'ProductKey',
      sourceInstanceId: 'SourceInstanceId',
      sourceInstanceName: 'SourceInstanceName',
      sourceRegion: 'SourceRegion',
      sourceUid: 'SourceUid',
      targetAliyunId: 'TargetAliyunId',
      targetInstanceId: 'TargetInstanceId',
      targetInstanceName: 'TargetInstanceName',
      targetRegion: 'TargetRegion',
      targetUid: 'TargetUid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gmtCreate: 'number',
      productKey: 'string',
      sourceInstanceId: 'string',
      sourceInstanceName: 'string',
      sourceRegion: 'string',
      sourceUid: 'string',
      targetAliyunId: 'string',
      targetInstanceId: 'string',
      targetInstanceName: 'string',
      targetRegion: 'string',
      targetUid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDistributedProductResponseBodyDataInfo extends $tea.Model {
  items?: ListDistributedProductResponseBodyDataInfoItems[];
  static names(): { [key: string]: string } {
    return {
      items: 'items',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: { 'type': 'array', 'itemType': ListDistributedProductResponseBodyDataInfoItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDistributedProductResponseBodyData extends $tea.Model {
  info?: ListDistributedProductResponseBodyDataInfo;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      info: 'Info',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      info: ListDistributedProductResponseBodyDataInfo,
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobResponseBodyDataData extends $tea.Model {
  description?: string;
  jobId?: string;
  jobName?: string;
  scheduledTime?: number;
  status?: string;
  type?: string;
  utcCreate?: string;
  utcModified?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      jobId: 'JobId',
      jobName: 'JobName',
      scheduledTime: 'ScheduledTime',
      status: 'Status',
      type: 'Type',
      utcCreate: 'UtcCreate',
      utcModified: 'UtcModified',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      jobId: 'string',
      jobName: 'string',
      scheduledTime: 'number',
      status: 'string',
      type: 'string',
      utcCreate: 'string',
      utcModified: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobResponseBodyData extends $tea.Model {
  data?: ListJobResponseBodyDataData[];
  static names(): { [key: string]: string } {
    return {
      data: 'data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': ListJobResponseBodyDataData },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAFirmwareResponseBodyFirmwareInfoSimpleFirmwareInfo extends $tea.Model {
  destVersion?: string;
  firmwareDesc?: string;
  firmwareId?: string;
  firmwareName?: string;
  firmwareSign?: string;
  firmwareSize?: number;
  moduleName?: string;
  productKey?: string;
  productName?: string;
  signMethod?: string;
  srcVersion?: string;
  status?: number;
  type?: number;
  utcCreate?: string;
  utcModified?: string;
  static names(): { [key: string]: string } {
    return {
      destVersion: 'DestVersion',
      firmwareDesc: 'FirmwareDesc',
      firmwareId: 'FirmwareId',
      firmwareName: 'FirmwareName',
      firmwareSign: 'FirmwareSign',
      firmwareSize: 'FirmwareSize',
      moduleName: 'ModuleName',
      productKey: 'ProductKey',
      productName: 'ProductName',
      signMethod: 'SignMethod',
      srcVersion: 'SrcVersion',
      status: 'Status',
      type: 'Type',
      utcCreate: 'UtcCreate',
      utcModified: 'UtcModified',
    };
  }

  static types(): { [key: string]: any } {
    return {
      destVersion: 'string',
      firmwareDesc: 'string',
      firmwareId: 'string',
      firmwareName: 'string',
      firmwareSign: 'string',
      firmwareSize: 'number',
      moduleName: 'string',
      productKey: 'string',
      productName: 'string',
      signMethod: 'string',
      srcVersion: 'string',
      status: 'number',
      type: 'number',
      utcCreate: 'string',
      utcModified: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAFirmwareResponseBodyFirmwareInfo extends $tea.Model {
  simpleFirmwareInfo?: ListOTAFirmwareResponseBodyFirmwareInfoSimpleFirmwareInfo[];
  static names(): { [key: string]: string } {
    return {
      simpleFirmwareInfo: 'SimpleFirmwareInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      simpleFirmwareInfo: { 'type': 'array', 'itemType': ListOTAFirmwareResponseBodyFirmwareInfoSimpleFirmwareInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfoTagsOtaTagDTO extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfoTags extends $tea.Model {
  otaTagDTO?: ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfoTagsOtaTagDTO[];
  static names(): { [key: string]: string } {
    return {
      otaTagDTO: 'OtaTagDTO',
    };
  }

  static types(): { [key: string]: any } {
    return {
      otaTagDTO: { 'type': 'array', 'itemType': ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfoTagsOtaTagDTO },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfo extends $tea.Model {
  firmwareId?: string;
  jobId?: string;
  jobStatus?: string;
  jobType?: string;
  productKey?: string;
  selectionType?: string;
  tags?: ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfoTags;
  targetSelection?: string;
  utcCreate?: string;
  utcEndTime?: string;
  utcModified?: string;
  utcStartTime?: string;
  static names(): { [key: string]: string } {
    return {
      firmwareId: 'FirmwareId',
      jobId: 'JobId',
      jobStatus: 'JobStatus',
      jobType: 'JobType',
      productKey: 'ProductKey',
      selectionType: 'SelectionType',
      tags: 'Tags',
      targetSelection: 'TargetSelection',
      utcCreate: 'UtcCreate',
      utcEndTime: 'UtcEndTime',
      utcModified: 'UtcModified',
      utcStartTime: 'UtcStartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      firmwareId: 'string',
      jobId: 'string',
      jobStatus: 'string',
      jobType: 'string',
      productKey: 'string',
      selectionType: 'string',
      tags: ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfoTags,
      targetSelection: 'string',
      utcCreate: 'string',
      utcEndTime: 'string',
      utcModified: 'string',
      utcStartTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAJobByDeviceResponseBodyData extends $tea.Model {
  simpleOTAJobInfo?: ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfo[];
  static names(): { [key: string]: string } {
    return {
      simpleOTAJobInfo: 'SimpleOTAJobInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      simpleOTAJobInfo: { 'type': 'array', 'itemType': ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfoTagsOtaTagDTO extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfoTags extends $tea.Model {
  otaTagDTO?: ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfoTagsOtaTagDTO[];
  static names(): { [key: string]: string } {
    return {
      otaTagDTO: 'OtaTagDTO',
    };
  }

  static types(): { [key: string]: any } {
    return {
      otaTagDTO: { 'type': 'array', 'itemType': ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfoTagsOtaTagDTO },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfo extends $tea.Model {
  firmwareId?: string;
  jobId?: string;
  jobStatus?: string;
  jobType?: string;
  productKey?: string;
  selectionType?: string;
  tags?: ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfoTags;
  targetSelection?: string;
  utcCreate?: string;
  utcEndTime?: string;
  utcModified?: string;
  utcStartTime?: string;
  static names(): { [key: string]: string } {
    return {
      firmwareId: 'FirmwareId',
      jobId: 'JobId',
      jobStatus: 'JobStatus',
      jobType: 'JobType',
      productKey: 'ProductKey',
      selectionType: 'SelectionType',
      tags: 'Tags',
      targetSelection: 'TargetSelection',
      utcCreate: 'UtcCreate',
      utcEndTime: 'UtcEndTime',
      utcModified: 'UtcModified',
      utcStartTime: 'UtcStartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      firmwareId: 'string',
      jobId: 'string',
      jobStatus: 'string',
      jobType: 'string',
      productKey: 'string',
      selectionType: 'string',
      tags: ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfoTags,
      targetSelection: 'string',
      utcCreate: 'string',
      utcEndTime: 'string',
      utcModified: 'string',
      utcStartTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAJobByFirmwareResponseBodyData extends $tea.Model {
  simpleOTAJobInfo?: ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfo[];
  static names(): { [key: string]: string } {
    return {
      simpleOTAJobInfo: 'SimpleOTAJobInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      simpleOTAJobInfo: { 'type': 'array', 'itemType': ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAModuleByProductResponseBodyData extends $tea.Model {
  aliasName?: string;
  desc?: string;
  gmtCreate?: string;
  gmtModified?: string;
  moduleName?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      aliasName: 'AliasName',
      desc: 'Desc',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      moduleName: 'ModuleName',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliasName: 'string',
      desc: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      moduleName: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAModuleVersionsByDeviceResponseBodyDataSimpleOTAModuleInfo extends $tea.Model {
  deviceName?: string;
  iotId?: string;
  moduleName?: string;
  moduleVersion?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      moduleName: 'ModuleName',
      moduleVersion: 'ModuleVersion',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      moduleName: 'string',
      moduleVersion: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAModuleVersionsByDeviceResponseBodyData extends $tea.Model {
  simpleOTAModuleInfo?: ListOTAModuleVersionsByDeviceResponseBodyDataSimpleOTAModuleInfo[];
  static names(): { [key: string]: string } {
    return {
      simpleOTAModuleInfo: 'SimpleOTAModuleInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      simpleOTAModuleInfo: { 'type': 'array', 'itemType': ListOTAModuleVersionsByDeviceResponseBodyDataSimpleOTAModuleInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTATaskByJobResponseBodyDataSimpleOTATaskInfo extends $tea.Model {
  destVersion?: string;
  deviceName?: string;
  firmwareId?: string;
  iotId?: string;
  jobId?: string;
  productKey?: string;
  productName?: string;
  progress?: string;
  srcVersion?: string;
  taskDesc?: string;
  taskId?: string;
  taskStatus?: string;
  timeout?: string;
  utcCreate?: string;
  utcModified?: string;
  static names(): { [key: string]: string } {
    return {
      destVersion: 'DestVersion',
      deviceName: 'DeviceName',
      firmwareId: 'FirmwareId',
      iotId: 'IotId',
      jobId: 'JobId',
      productKey: 'ProductKey',
      productName: 'ProductName',
      progress: 'Progress',
      srcVersion: 'SrcVersion',
      taskDesc: 'TaskDesc',
      taskId: 'TaskId',
      taskStatus: 'TaskStatus',
      timeout: 'Timeout',
      utcCreate: 'UtcCreate',
      utcModified: 'UtcModified',
    };
  }

  static types(): { [key: string]: any } {
    return {
      destVersion: 'string',
      deviceName: 'string',
      firmwareId: 'string',
      iotId: 'string',
      jobId: 'string',
      productKey: 'string',
      productName: 'string',
      progress: 'string',
      srcVersion: 'string',
      taskDesc: 'string',
      taskId: 'string',
      taskStatus: 'string',
      timeout: 'string',
      utcCreate: 'string',
      utcModified: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTATaskByJobResponseBodyData extends $tea.Model {
  simpleOTATaskInfo?: ListOTATaskByJobResponseBodyDataSimpleOTATaskInfo[];
  static names(): { [key: string]: string } {
    return {
      simpleOTATaskInfo: 'SimpleOTATaskInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      simpleOTATaskInfo: { 'type': 'array', 'itemType': ListOTATaskByJobResponseBodyDataSimpleOTATaskInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAUnfinishedTaskByDeviceResponseBodyDataSimpleOTATaskInfo extends $tea.Model {
  destVersion?: string;
  deviceName?: string;
  firmwareId?: string;
  iotId?: string;
  jobId?: string;
  moduleName?: string;
  productKey?: string;
  productName?: string;
  srcVersion?: string;
  taskId?: string;
  taskStatus?: string;
  utcCreate?: string;
  utcModified?: string;
  static names(): { [key: string]: string } {
    return {
      destVersion: 'DestVersion',
      deviceName: 'DeviceName',
      firmwareId: 'FirmwareId',
      iotId: 'IotId',
      jobId: 'JobId',
      moduleName: 'ModuleName',
      productKey: 'ProductKey',
      productName: 'ProductName',
      srcVersion: 'SrcVersion',
      taskId: 'TaskId',
      taskStatus: 'TaskStatus',
      utcCreate: 'UtcCreate',
      utcModified: 'UtcModified',
    };
  }

  static types(): { [key: string]: any } {
    return {
      destVersion: 'string',
      deviceName: 'string',
      firmwareId: 'string',
      iotId: 'string',
      jobId: 'string',
      moduleName: 'string',
      productKey: 'string',
      productName: 'string',
      srcVersion: 'string',
      taskId: 'string',
      taskStatus: 'string',
      utcCreate: 'string',
      utcModified: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOTAUnfinishedTaskByDeviceResponseBodyData extends $tea.Model {
  simpleOTATaskInfo?: ListOTAUnfinishedTaskByDeviceResponseBodyDataSimpleOTATaskInfo[];
  static names(): { [key: string]: string } {
    return {
      simpleOTATaskInfo: 'SimpleOTATaskInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      simpleOTATaskInfo: { 'type': 'array', 'itemType': ListOTAUnfinishedTaskByDeviceResponseBodyDataSimpleOTATaskInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListParserResponseBodyDataParserList extends $tea.Model {
  description?: string;
  name?: string;
  parserId?: number;
  status?: string;
  utcCreated?: string;
  utcModified?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      parserId: 'ParserId',
      status: 'Status',
      utcCreated: 'UtcCreated',
      utcModified: 'UtcModified',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      parserId: 'number',
      status: 'string',
      utcCreated: 'string',
      utcModified: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListParserResponseBodyData extends $tea.Model {
  parserList?: ListParserResponseBodyDataParserList[];
  static names(): { [key: string]: string } {
    return {
      parserList: 'ParserList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      parserList: { 'type': 'array', 'itemType': ListParserResponseBodyDataParserList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListParserDataSourceResponseBodyDataDataSource extends $tea.Model {
  dataSourceId?: number;
  description?: string;
  name?: string;
  utcCreated?: string;
  static names(): { [key: string]: string } {
    return {
      dataSourceId: 'DataSourceId',
      description: 'Description',
      name: 'Name',
      utcCreated: 'UtcCreated',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataSourceId: 'number',
      description: 'string',
      name: 'string',
      utcCreated: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListParserDataSourceResponseBodyData extends $tea.Model {
  dataSource?: ListParserDataSourceResponseBodyDataDataSource[];
  static names(): { [key: string]: string } {
    return {
      dataSource: 'DataSource',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataSource: { 'type': 'array', 'itemType': ListParserDataSourceResponseBodyDataDataSource },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListParserDestinationResponseBodyDataDestinations extends $tea.Model {
  configuration?: string;
  destinationId?: number;
  isFailover?: boolean;
  name?: string;
  type?: string;
  utcCreated?: string;
  utcModified?: string;
  static names(): { [key: string]: string } {
    return {
      configuration: 'Configuration',
      destinationId: 'DestinationId',
      isFailover: 'IsFailover',
      name: 'Name',
      type: 'Type',
      utcCreated: 'UtcCreated',
      utcModified: 'UtcModified',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configuration: 'string',
      destinationId: 'number',
      isFailover: 'boolean',
      name: 'string',
      type: 'string',
      utcCreated: 'string',
      utcModified: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListParserDestinationResponseBodyData extends $tea.Model {
  destinations?: ListParserDestinationResponseBodyDataDestinations[];
  static names(): { [key: string]: string } {
    return {
      destinations: 'destinations',
    };
  }

  static types(): { [key: string]: any } {
    return {
      destinations: { 'type': 'array', 'itemType': ListParserDestinationResponseBodyDataDestinations },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProductByTagsRequestProductTag extends $tea.Model {
  tagKey?: string;
  tagValue?: string;
  static names(): { [key: string]: string } {
    return {
      tagKey: 'TagKey',
      tagValue: 'TagValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagKey: 'string',
      tagValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProductByTagsResponseBodyProductInfosProductInfo extends $tea.Model {
  createTime?: number;
  description?: string;
  nodeType?: number;
  productKey?: string;
  productName?: string;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      description: 'Description',
      nodeType: 'NodeType',
      productKey: 'ProductKey',
      productName: 'ProductName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'number',
      description: 'string',
      nodeType: 'number',
      productKey: 'string',
      productName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProductByTagsResponseBodyProductInfos extends $tea.Model {
  productInfo?: ListProductByTagsResponseBodyProductInfosProductInfo[];
  static names(): { [key: string]: string } {
    return {
      productInfo: 'ProductInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      productInfo: { 'type': 'array', 'itemType': ListProductByTagsResponseBodyProductInfosProductInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProductTagsResponseBodyDataProductTag extends $tea.Model {
  tagKey?: string;
  tagValue?: string;
  static names(): { [key: string]: string } {
    return {
      tagKey: 'TagKey',
      tagValue: 'TagValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagKey: 'string',
      tagValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProductTagsResponseBodyData extends $tea.Model {
  productTag?: ListProductTagsResponseBodyDataProductTag[];
  static names(): { [key: string]: string } {
    return {
      productTag: 'ProductTag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      productTag: { 'type': 'array', 'itemType': ListProductTagsResponseBodyDataProductTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRuleResponseBodyDataRuleInfo extends $tea.Model {
  createUserId?: number;
  created?: string;
  dataType?: string;
  id?: number;
  modified?: string;
  name?: string;
  productKey?: string;
  ruleDesc?: string;
  select?: string;
  shortTopic?: string;
  status?: string;
  topic?: string;
  utcCreated?: string;
  utcModified?: string;
  where?: string;
  static names(): { [key: string]: string } {
    return {
      createUserId: 'CreateUserId',
      created: 'Created',
      dataType: 'DataType',
      id: 'Id',
      modified: 'Modified',
      name: 'Name',
      productKey: 'ProductKey',
      ruleDesc: 'RuleDesc',
      select: 'Select',
      shortTopic: 'ShortTopic',
      status: 'Status',
      topic: 'Topic',
      utcCreated: 'UtcCreated',
      utcModified: 'UtcModified',
      where: 'Where',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createUserId: 'number',
      created: 'string',
      dataType: 'string',
      id: 'number',
      modified: 'string',
      name: 'string',
      productKey: 'string',
      ruleDesc: 'string',
      select: 'string',
      shortTopic: 'string',
      status: 'string',
      topic: 'string',
      utcCreated: 'string',
      utcModified: 'string',
      where: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRuleResponseBodyData extends $tea.Model {
  ruleInfo?: ListRuleResponseBodyDataRuleInfo[];
  static names(): { [key: string]: string } {
    return {
      ruleInfo: 'RuleInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ruleInfo: { 'type': 'array', 'itemType': ListRuleResponseBodyDataRuleInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRuleActionsResponseBodyRuleActionListRuleActionInfo extends $tea.Model {
  configuration?: string;
  errorActionFlag?: boolean;
  id?: number;
  ruleId?: number;
  status?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      configuration: 'Configuration',
      errorActionFlag: 'ErrorActionFlag',
      id: 'Id',
      ruleId: 'RuleId',
      status: 'Status',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configuration: 'string',
      errorActionFlag: 'boolean',
      id: 'number',
      ruleId: 'number',
      status: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRuleActionsResponseBodyRuleActionList extends $tea.Model {
  ruleActionInfo?: ListRuleActionsResponseBodyRuleActionListRuleActionInfo[];
  static names(): { [key: string]: string } {
    return {
      ruleActionInfo: 'RuleActionInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ruleActionInfo: { 'type': 'array', 'itemType': ListRuleActionsResponseBodyRuleActionListRuleActionInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskResponseBodyDataData extends $tea.Model {
  deviceName?: string;
  iotId?: string;
  jobId?: string;
  jobName?: string;
  productKey?: string;
  progress?: string;
  status?: string;
  taskId?: string;
  utcModified?: string;
  utcQueueTime?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      jobId: 'JobId',
      jobName: 'JobName',
      productKey: 'ProductKey',
      progress: 'Progress',
      status: 'Status',
      taskId: 'TaskId',
      utcModified: 'UtcModified',
      utcQueueTime: 'UtcQueueTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      jobId: 'string',
      jobName: 'string',
      productKey: 'string',
      progress: 'string',
      status: 'string',
      taskId: 'string',
      utcModified: 'string',
      utcQueueTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskResponseBodyData extends $tea.Model {
  data?: ListTaskResponseBodyDataData[];
  static names(): { [key: string]: string } {
    return {
      data: 'data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': ListTaskResponseBodyDataData },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListThingModelVersionResponseBodyDataModelVersions extends $tea.Model {
  description?: string;
  gmtCreate?: number;
  modelVersion?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      gmtCreate: 'GmtCreate',
      modelVersion: 'ModelVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      gmtCreate: 'number',
      modelVersion: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListThingModelVersionResponseBodyData extends $tea.Model {
  modelVersions?: ListThingModelVersionResponseBodyDataModelVersions[];
  static names(): { [key: string]: string } {
    return {
      modelVersions: 'ModelVersions',
    };
  }

  static types(): { [key: string]: any } {
    return {
      modelVersions: { 'type': 'array', 'itemType': ListThingModelVersionResponseBodyDataModelVersions },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListThingTemplatesResponseBodyData extends $tea.Model {
  categoryKey?: string;
  categoryName?: string;
  static names(): { [key: string]: string } {
    return {
      categoryKey: 'CategoryKey',
      categoryName: 'CategoryName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      categoryKey: 'string',
      categoryName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class NotifyAddThingTopoResponseBodyData extends $tea.Model {
  messageId?: string;
  static names(): { [key: string]: string } {
    return {
      messageId: 'MessageId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      messageId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PageQuerySharedSpeechOpenResponseBodyDataResultDataData extends $tea.Model {
  audioFormat?: string;
  bizCode?: string;
  code?: string;
  speechRate?: number;
  status?: number;
  text?: string;
  voice?: string;
  volume?: number;
  static names(): { [key: string]: string } {
    return {
      audioFormat: 'AudioFormat',
      bizCode: 'BizCode',
      code: 'Code',
      speechRate: 'SpeechRate',
      status: 'Status',
      text: 'Text',
      voice: 'Voice',
      volume: 'Volume',
    };
  }

  static types(): { [key: string]: any } {
    return {
      audioFormat: 'string',
      bizCode: 'string',
      code: 'string',
      speechRate: 'number',
      status: 'number',
      text: 'string',
      voice: 'string',
      volume: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PageQuerySharedSpeechOpenResponseBodyDataResultData extends $tea.Model {
  data?: PageQuerySharedSpeechOpenResponseBodyDataResultDataData[];
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': PageQuerySharedSpeechOpenResponseBodyDataResultDataData },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PageQuerySharedSpeechOpenResponseBodyData extends $tea.Model {
  pageId?: number;
  pageSize?: number;
  resultData?: PageQuerySharedSpeechOpenResponseBodyDataResultData;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      pageId: 'PageId',
      pageSize: 'PageSize',
      resultData: 'ResultData',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageId: 'number',
      pageSize: 'number',
      resultData: PageQuerySharedSpeechOpenResponseBodyDataResultData,
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PageQuerySpeechBroadcastHourResponseBodyDataResultDataData extends $tea.Model {
  code?: number;
  deviceName?: string;
  msg?: string;
  productKey?: string;
  shareTaskCode?: string;
  speechId?: string;
  speechs?: string;
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      deviceName: 'DeviceName',
      msg: 'Msg',
      productKey: 'ProductKey',
      shareTaskCode: 'ShareTaskCode',
      speechId: 'SpeechId',
      speechs: 'Speechs',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      deviceName: 'string',
      msg: 'string',
      productKey: 'string',
      shareTaskCode: 'string',
      speechId: 'string',
      speechs: 'string',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PageQuerySpeechBroadcastHourResponseBodyDataResultData extends $tea.Model {
  data?: PageQuerySpeechBroadcastHourResponseBodyDataResultDataData[];
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': PageQuerySpeechBroadcastHourResponseBodyDataResultDataData },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PageQuerySpeechBroadcastHourResponseBodyData extends $tea.Model {
  pageId?: number;
  pageSize?: number;
  pageToken?: string;
  resultData?: PageQuerySpeechBroadcastHourResponseBodyDataResultData;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      pageId: 'PageId',
      pageSize: 'PageSize',
      pageToken: 'PageToken',
      resultData: 'ResultData',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageId: 'number',
      pageSize: 'number',
      pageToken: 'string',
      resultData: PageQuerySpeechBroadcastHourResponseBodyDataResultData,
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PrintByTemplateResponseBodyData extends $tea.Model {
  deviceErrorCode?: string;
  deviceErrorMessage?: string;
  id?: string;
  maxRetryCount?: number;
  retryCount?: number;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      deviceErrorCode: 'DeviceErrorCode',
      deviceErrorMessage: 'DeviceErrorMessage',
      id: 'Id',
      maxRetryCount: 'MaxRetryCount',
      retryCount: 'RetryCount',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceErrorCode: 'string',
      deviceErrorMessage: 'string',
      id: 'string',
      maxRetryCount: 'number',
      retryCount: 'number',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PubRequestUserProp extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryBatchRegisterDeviceStatusResponseBodyDataInvalidDetailListInvalidDetailList extends $tea.Model {
  deviceName?: string;
  errorMsg?: string;
  nickName?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      errorMsg: 'ErrorMsg',
      nickName: 'NickName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      errorMsg: 'string',
      nickName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryBatchRegisterDeviceStatusResponseBodyDataInvalidDetailList extends $tea.Model {
  invalidDetailList?: QueryBatchRegisterDeviceStatusResponseBodyDataInvalidDetailListInvalidDetailList[];
  static names(): { [key: string]: string } {
    return {
      invalidDetailList: 'invalidDetailList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      invalidDetailList: { 'type': 'array', 'itemType': QueryBatchRegisterDeviceStatusResponseBodyDataInvalidDetailListInvalidDetailList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryBatchRegisterDeviceStatusResponseBodyDataInvalidList extends $tea.Model {
  name?: string[];
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryBatchRegisterDeviceStatusResponseBodyDataValidList extends $tea.Model {
  name?: string[];
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryBatchRegisterDeviceStatusResponseBodyData extends $tea.Model {
  invalidDetailList?: QueryBatchRegisterDeviceStatusResponseBodyDataInvalidDetailList;
  invalidList?: QueryBatchRegisterDeviceStatusResponseBodyDataInvalidList;
  status?: string;
  validList?: QueryBatchRegisterDeviceStatusResponseBodyDataValidList;
  static names(): { [key: string]: string } {
    return {
      invalidDetailList: 'InvalidDetailList',
      invalidList: 'InvalidList',
      status: 'Status',
      validList: 'ValidList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      invalidDetailList: QueryBatchRegisterDeviceStatusResponseBodyDataInvalidDetailList,
      invalidList: QueryBatchRegisterDeviceStatusResponseBodyDataInvalidList,
      status: 'string',
      validList: QueryBatchRegisterDeviceStatusResponseBodyDataValidList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryClientIdsResponseBodyDataDynamicRegClientIds extends $tea.Model {
  clientId?: string;
  createTime?: number;
  static names(): { [key: string]: string } {
    return {
      clientId: 'ClientId',
      createTime: 'CreateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clientId: 'string',
      createTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryClientIdsResponseBodyData extends $tea.Model {
  dynamicRegClientIds?: QueryClientIdsResponseBodyDataDynamicRegClientIds[];
  iotId?: string;
  static names(): { [key: string]: string } {
    return {
      dynamicRegClientIds: 'DynamicRegClientIds',
      iotId: 'IotId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dynamicRegClientIds: { 'type': 'array', 'itemType': QueryClientIdsResponseBodyDataDynamicRegClientIds },
      iotId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryConsumerGroupByGroupIdResponseBodyData extends $tea.Model {
  createTime?: string;
  groupId?: string;
  groupName?: string;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      groupId: 'GroupId',
      groupName: 'GroupName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'string',
      groupId: 'string',
      groupName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryConsumerGroupListResponseBodyDataConsumerGroupDTO extends $tea.Model {
  createTime?: string;
  groupId?: string;
  groupName?: string;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      groupId: 'GroupId',
      groupName: 'GroupName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'string',
      groupId: 'string',
      groupName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryConsumerGroupListResponseBodyData extends $tea.Model {
  consumerGroupDTO?: QueryConsumerGroupListResponseBodyDataConsumerGroupDTO[];
  static names(): { [key: string]: string } {
    return {
      consumerGroupDTO: 'ConsumerGroupDTO',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consumerGroupDTO: { 'type': 'array', 'itemType': QueryConsumerGroupListResponseBodyDataConsumerGroupDTO },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryConsumerGroupStatusResponseBodyClientConnectionStatusListConsumerGroupClientConnectionInfo extends $tea.Model {
  accumulatedConsumeCountPerMinute?: number;
  clientId?: string;
  clientIpPort?: string;
  onlineTime?: number;
  realTimeConsumeCountPerMinute?: number;
  static names(): { [key: string]: string } {
    return {
      accumulatedConsumeCountPerMinute: 'AccumulatedConsumeCountPerMinute',
      clientId: 'ClientId',
      clientIpPort: 'ClientIpPort',
      onlineTime: 'OnlineTime',
      realTimeConsumeCountPerMinute: 'RealTimeConsumeCountPerMinute',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accumulatedConsumeCountPerMinute: 'number',
      clientId: 'string',
      clientIpPort: 'string',
      onlineTime: 'number',
      realTimeConsumeCountPerMinute: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryConsumerGroupStatusResponseBodyClientConnectionStatusList extends $tea.Model {
  consumerGroupClientConnectionInfo?: QueryConsumerGroupStatusResponseBodyClientConnectionStatusListConsumerGroupClientConnectionInfo[];
  static names(): { [key: string]: string } {
    return {
      consumerGroupClientConnectionInfo: 'ConsumerGroupClientConnectionInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consumerGroupClientConnectionInfo: { 'type': 'array', 'itemType': QueryConsumerGroupStatusResponseBodyClientConnectionStatusListConsumerGroupClientConnectionInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDetailSceneRuleLogResponseBodyDataLogList extends $tea.Model {
  code?: string;
  message?: string;
  pkDn?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      pkDn: 'PkDn',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      pkDn: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDetailSceneRuleLogResponseBodyData extends $tea.Model {
  currentPage?: number;
  logList?: QueryDetailSceneRuleLogResponseBodyDataLogList[];
  pageSize?: number;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      logList: 'LogList',
      pageSize: 'PageSize',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      logList: { 'type': 'array', 'itemType': QueryDetailSceneRuleLogResponseBodyDataLogList },
      pageSize: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceResponseBodyDataDeviceInfo extends $tea.Model {
  deviceId?: string;
  deviceName?: string;
  deviceSecret?: string;
  deviceStatus?: string;
  deviceType?: string;
  gmtCreate?: string;
  gmtModified?: string;
  iotId?: string;
  nickname?: string;
  productKey?: string;
  utcCreate?: string;
  utcModified?: string;
  static names(): { [key: string]: string } {
    return {
      deviceId: 'DeviceId',
      deviceName: 'DeviceName',
      deviceSecret: 'DeviceSecret',
      deviceStatus: 'DeviceStatus',
      deviceType: 'DeviceType',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      iotId: 'IotId',
      nickname: 'Nickname',
      productKey: 'ProductKey',
      utcCreate: 'UtcCreate',
      utcModified: 'UtcModified',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceId: 'string',
      deviceName: 'string',
      deviceSecret: 'string',
      deviceStatus: 'string',
      deviceType: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      iotId: 'string',
      nickname: 'string',
      productKey: 'string',
      utcCreate: 'string',
      utcModified: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceResponseBodyData extends $tea.Model {
  deviceInfo?: QueryDeviceResponseBodyDataDeviceInfo[];
  static names(): { [key: string]: string } {
    return {
      deviceInfo: 'DeviceInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceInfo: { 'type': 'array', 'itemType': QueryDeviceResponseBodyDataDeviceInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceBySQLResponseBodyDataGroups extends $tea.Model {
  groupId?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceBySQLResponseBodyDataOTAModules extends $tea.Model {
  firmwareVersion?: string;
  moduleName?: string;
  static names(): { [key: string]: string } {
    return {
      firmwareVersion: 'FirmwareVersion',
      moduleName: 'ModuleName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      firmwareVersion: 'string',
      moduleName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceBySQLResponseBodyDataTags extends $tea.Model {
  tagName?: string;
  tagValue?: string;
  static names(): { [key: string]: string } {
    return {
      tagName: 'TagName',
      tagValue: 'TagValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagName: 'string',
      tagValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceBySQLResponseBodyData extends $tea.Model {
  activeTime?: string;
  deviceName?: string;
  gmtCreate?: string;
  gmtModified?: string;
  groups?: QueryDeviceBySQLResponseBodyDataGroups[];
  iotId?: string;
  nickname?: string;
  OTAModules?: QueryDeviceBySQLResponseBodyDataOTAModules[];
  productKey?: string;
  status?: string;
  tags?: QueryDeviceBySQLResponseBodyDataTags[];
  static names(): { [key: string]: string } {
    return {
      activeTime: 'ActiveTime',
      deviceName: 'DeviceName',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      groups: 'Groups',
      iotId: 'IotId',
      nickname: 'Nickname',
      OTAModules: 'OTAModules',
      productKey: 'ProductKey',
      status: 'Status',
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      activeTime: 'string',
      deviceName: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      groups: { 'type': 'array', 'itemType': QueryDeviceBySQLResponseBodyDataGroups },
      iotId: 'string',
      nickname: 'string',
      OTAModules: { 'type': 'array', 'itemType': QueryDeviceBySQLResponseBodyDataOTAModules },
      productKey: 'string',
      status: 'string',
      tags: { 'type': 'array', 'itemType': QueryDeviceBySQLResponseBodyDataTags },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceByStatusResponseBodyDataSimpleDeviceInfo extends $tea.Model {
  deviceName?: string;
  deviceSecret?: string;
  gmtCreate?: string;
  gmtModified?: string;
  iotId?: string;
  nickname?: string;
  productKey?: string;
  status?: string;
  utcCreate?: string;
  utcModified?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      deviceSecret: 'DeviceSecret',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      iotId: 'IotId',
      nickname: 'Nickname',
      productKey: 'ProductKey',
      status: 'Status',
      utcCreate: 'UtcCreate',
      utcModified: 'UtcModified',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      deviceSecret: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      iotId: 'string',
      nickname: 'string',
      productKey: 'string',
      status: 'string',
      utcCreate: 'string',
      utcModified: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceByStatusResponseBodyData extends $tea.Model {
  simpleDeviceInfo?: QueryDeviceByStatusResponseBodyDataSimpleDeviceInfo[];
  static names(): { [key: string]: string } {
    return {
      simpleDeviceInfo: 'SimpleDeviceInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      simpleDeviceInfo: { 'type': 'array', 'itemType': QueryDeviceByStatusResponseBodyDataSimpleDeviceInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceByTagsRequestTag extends $tea.Model {
  tagKey?: string;
  tagValue?: string;
  static names(): { [key: string]: string } {
    return {
      tagKey: 'TagKey',
      tagValue: 'TagValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagKey: 'string',
      tagValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceByTagsResponseBodyDataSimpleDeviceInfo extends $tea.Model {
  deviceName?: string;
  iotId?: string;
  productKey?: string;
  productName?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      productKey: 'ProductKey',
      productName: 'ProductName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      productKey: 'string',
      productName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceByTagsResponseBodyData extends $tea.Model {
  simpleDeviceInfo?: QueryDeviceByTagsResponseBodyDataSimpleDeviceInfo[];
  static names(): { [key: string]: string } {
    return {
      simpleDeviceInfo: 'SimpleDeviceInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      simpleDeviceInfo: { 'type': 'array', 'itemType': QueryDeviceByTagsResponseBodyDataSimpleDeviceInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceCertResponseBodyDeviceCertInfo extends $tea.Model {
  certSN?: string;
  certificate?: string;
  privateKey?: string;
  status?: number;
  static names(): { [key: string]: string } {
    return {
      certSN: 'CertSN',
      certificate: 'Certificate',
      privateKey: 'PrivateKey',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      certSN: 'string',
      certificate: 'string',
      privateKey: 'string',
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceDesiredPropertyResponseBodyDataListDesiredPropertyInfo extends $tea.Model {
  dataType?: string;
  identifier?: string;
  name?: string;
  time?: string;
  unit?: string;
  value?: string;
  version?: number;
  static names(): { [key: string]: string } {
    return {
      dataType: 'DataType',
      identifier: 'Identifier',
      name: 'Name',
      time: 'Time',
      unit: 'Unit',
      value: 'Value',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataType: 'string',
      identifier: 'string',
      name: 'string',
      time: 'string',
      unit: 'string',
      value: 'string',
      version: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceDesiredPropertyResponseBodyDataList extends $tea.Model {
  desiredPropertyInfo?: QueryDeviceDesiredPropertyResponseBodyDataListDesiredPropertyInfo[];
  static names(): { [key: string]: string } {
    return {
      desiredPropertyInfo: 'DesiredPropertyInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      desiredPropertyInfo: { 'type': 'array', 'itemType': QueryDeviceDesiredPropertyResponseBodyDataListDesiredPropertyInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceDesiredPropertyResponseBodyData extends $tea.Model {
  list?: QueryDeviceDesiredPropertyResponseBodyDataList;
  static names(): { [key: string]: string } {
    return {
      list: 'List',
    };
  }

  static types(): { [key: string]: any } {
    return {
      list: QueryDeviceDesiredPropertyResponseBodyDataList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceDetailResponseBodyData extends $tea.Model {
  deviceName?: string;
  deviceSecret?: string;
  firmwareVersion?: string;
  gmtActive?: string;
  gmtCreate?: string;
  gmtOnline?: string;
  iotId?: string;
  ipAddress?: string;
  nickname?: string;
  nodeType?: number;
  owner?: boolean;
  productKey?: string;
  productName?: string;
  region?: string;
  status?: string;
  utcActive?: string;
  utcCreate?: string;
  utcOnline?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      deviceSecret: 'DeviceSecret',
      firmwareVersion: 'FirmwareVersion',
      gmtActive: 'GmtActive',
      gmtCreate: 'GmtCreate',
      gmtOnline: 'GmtOnline',
      iotId: 'IotId',
      ipAddress: 'IpAddress',
      nickname: 'Nickname',
      nodeType: 'NodeType',
      owner: 'Owner',
      productKey: 'ProductKey',
      productName: 'ProductName',
      region: 'Region',
      status: 'Status',
      utcActive: 'UtcActive',
      utcCreate: 'UtcCreate',
      utcOnline: 'UtcOnline',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      deviceSecret: 'string',
      firmwareVersion: 'string',
      gmtActive: 'string',
      gmtCreate: 'string',
      gmtOnline: 'string',
      iotId: 'string',
      ipAddress: 'string',
      nickname: 'string',
      nodeType: 'number',
      owner: 'boolean',
      productKey: 'string',
      productName: 'string',
      region: 'string',
      status: 'string',
      utcActive: 'string',
      utcCreate: 'string',
      utcOnline: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceDistributeJobResponseBodyDataTargetInstanceConfigsTargetInstanceConfigs extends $tea.Model {
  targetInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      targetInstanceId: 'TargetInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      targetInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceDistributeJobResponseBodyDataTargetInstanceConfigs extends $tea.Model {
  targetInstanceConfigs?: QueryDeviceDistributeJobResponseBodyDataTargetInstanceConfigsTargetInstanceConfigs[];
  static names(): { [key: string]: string } {
    return {
      targetInstanceConfigs: 'targetInstanceConfigs',
    };
  }

  static types(): { [key: string]: any } {
    return {
      targetInstanceConfigs: { 'type': 'array', 'itemType': QueryDeviceDistributeJobResponseBodyDataTargetInstanceConfigsTargetInstanceConfigs },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceDistributeJobResponseBodyData extends $tea.Model {
  gmtCreate?: number;
  jobId?: string;
  productKey?: string;
  sourceInstanceId?: string;
  sourceUid?: string;
  status?: number;
  strategy?: number;
  targetInstanceConfigs?: QueryDeviceDistributeJobResponseBodyDataTargetInstanceConfigs;
  targetUid?: string;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      gmtCreate: 'GmtCreate',
      jobId: 'JobId',
      productKey: 'ProductKey',
      sourceInstanceId: 'SourceInstanceId',
      sourceUid: 'SourceUid',
      status: 'Status',
      strategy: 'Strategy',
      targetInstanceConfigs: 'TargetInstanceConfigs',
      targetUid: 'TargetUid',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gmtCreate: 'number',
      jobId: 'string',
      productKey: 'string',
      sourceInstanceId: 'string',
      sourceUid: 'string',
      status: 'number',
      strategy: 'number',
      targetInstanceConfigs: QueryDeviceDistributeJobResponseBodyDataTargetInstanceConfigs,
      targetUid: 'string',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceEventDataResponseBodyDataListEventInfo extends $tea.Model {
  eventType?: string;
  identifier?: string;
  name?: string;
  outputData?: string;
  time?: string;
  static names(): { [key: string]: string } {
    return {
      eventType: 'EventType',
      identifier: 'Identifier',
      name: 'Name',
      outputData: 'OutputData',
      time: 'Time',
    };
  }

  static types(): { [key: string]: any } {
    return {
      eventType: 'string',
      identifier: 'string',
      name: 'string',
      outputData: 'string',
      time: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceEventDataResponseBodyDataList extends $tea.Model {
  eventInfo?: QueryDeviceEventDataResponseBodyDataListEventInfo[];
  static names(): { [key: string]: string } {
    return {
      eventInfo: 'EventInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      eventInfo: { 'type': 'array', 'itemType': QueryDeviceEventDataResponseBodyDataListEventInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceEventDataResponseBodyData extends $tea.Model {
  list?: QueryDeviceEventDataResponseBodyDataList;
  nextTime?: number;
  nextValid?: boolean;
  static names(): { [key: string]: string } {
    return {
      list: 'List',
      nextTime: 'NextTime',
      nextValid: 'NextValid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      list: QueryDeviceEventDataResponseBodyDataList,
      nextTime: 'number',
      nextValid: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceFileResponseBodyData extends $tea.Model {
  downloadUrl?: string;
  fileId?: string;
  name?: string;
  size?: string;
  utcCreatedOn?: string;
  static names(): { [key: string]: string } {
    return {
      downloadUrl: 'DownloadUrl',
      fileId: 'FileId',
      name: 'Name',
      size: 'Size',
      utcCreatedOn: 'UtcCreatedOn',
    };
  }

  static types(): { [key: string]: any } {
    return {
      downloadUrl: 'string',
      fileId: 'string',
      name: 'string',
      size: 'string',
      utcCreatedOn: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceFileListResponseBodyDataFileSummary extends $tea.Model {
  fileId?: string;
  name?: string;
  size?: string;
  utcCreatedOn?: string;
  static names(): { [key: string]: string } {
    return {
      fileId: 'FileId',
      name: 'Name',
      size: 'Size',
      utcCreatedOn: 'UtcCreatedOn',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fileId: 'string',
      name: 'string',
      size: 'string',
      utcCreatedOn: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceFileListResponseBodyData extends $tea.Model {
  fileSummary?: QueryDeviceFileListResponseBodyDataFileSummary[];
  static names(): { [key: string]: string } {
    return {
      fileSummary: 'FileSummary',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fileSummary: { 'type': 'array', 'itemType': QueryDeviceFileListResponseBodyDataFileSummary },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceGroupByDeviceResponseBodyGroupInfosGroupInfo extends $tea.Model {
  groupDesc?: string;
  groupId?: string;
  groupName?: string;
  groupType?: string;
  utcCreate?: string;
  static names(): { [key: string]: string } {
    return {
      groupDesc: 'GroupDesc',
      groupId: 'GroupId',
      groupName: 'GroupName',
      groupType: 'GroupType',
      utcCreate: 'UtcCreate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupDesc: 'string',
      groupId: 'string',
      groupName: 'string',
      groupType: 'string',
      utcCreate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceGroupByDeviceResponseBodyGroupInfos extends $tea.Model {
  groupInfo?: QueryDeviceGroupByDeviceResponseBodyGroupInfosGroupInfo[];
  static names(): { [key: string]: string } {
    return {
      groupInfo: 'GroupInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupInfo: { 'type': 'array', 'itemType': QueryDeviceGroupByDeviceResponseBodyGroupInfosGroupInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceGroupByTagsRequestTag extends $tea.Model {
  tagKey?: string;
  tagValue?: string;
  static names(): { [key: string]: string } {
    return {
      tagKey: 'TagKey',
      tagValue: 'TagValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagKey: 'string',
      tagValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceGroupByTagsResponseBodyDataDeviceGroup extends $tea.Model {
  groupId?: string;
  groupName?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      groupName: 'GroupName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      groupName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceGroupByTagsResponseBodyData extends $tea.Model {
  deviceGroup?: QueryDeviceGroupByTagsResponseBodyDataDeviceGroup[];
  static names(): { [key: string]: string } {
    return {
      deviceGroup: 'DeviceGroup',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceGroup: { 'type': 'array', 'itemType': QueryDeviceGroupByTagsResponseBodyDataDeviceGroup },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceGroupInfoResponseBodyData extends $tea.Model {
  deviceActive?: number;
  deviceCount?: number;
  deviceOnline?: number;
  dynamicGroupExpression?: string;
  groupDesc?: string;
  groupId?: string;
  groupName?: string;
  utcCreate?: string;
  static names(): { [key: string]: string } {
    return {
      deviceActive: 'DeviceActive',
      deviceCount: 'DeviceCount',
      deviceOnline: 'DeviceOnline',
      dynamicGroupExpression: 'DynamicGroupExpression',
      groupDesc: 'GroupDesc',
      groupId: 'GroupId',
      groupName: 'GroupName',
      utcCreate: 'UtcCreate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceActive: 'number',
      deviceCount: 'number',
      deviceOnline: 'number',
      dynamicGroupExpression: 'string',
      groupDesc: 'string',
      groupId: 'string',
      groupName: 'string',
      utcCreate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceGroupListResponseBodyDataGroupInfo extends $tea.Model {
  groupDesc?: string;
  groupId?: string;
  groupName?: string;
  groupType?: string;
  utcCreate?: string;
  static names(): { [key: string]: string } {
    return {
      groupDesc: 'GroupDesc',
      groupId: 'GroupId',
      groupName: 'GroupName',
      groupType: 'GroupType',
      utcCreate: 'UtcCreate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupDesc: 'string',
      groupId: 'string',
      groupName: 'string',
      groupType: 'string',
      utcCreate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceGroupListResponseBodyData extends $tea.Model {
  groupInfo?: QueryDeviceGroupListResponseBodyDataGroupInfo[];
  static names(): { [key: string]: string } {
    return {
      groupInfo: 'GroupInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupInfo: { 'type': 'array', 'itemType': QueryDeviceGroupListResponseBodyDataGroupInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceGroupTagListResponseBodyDataGroupTagInfo extends $tea.Model {
  tagKey?: string;
  tagValue?: string;
  static names(): { [key: string]: string } {
    return {
      tagKey: 'TagKey',
      tagValue: 'TagValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagKey: 'string',
      tagValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceGroupTagListResponseBodyData extends $tea.Model {
  groupTagInfo?: QueryDeviceGroupTagListResponseBodyDataGroupTagInfo[];
  static names(): { [key: string]: string } {
    return {
      groupTagInfo: 'GroupTagInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupTagInfo: { 'type': 'array', 'itemType': QueryDeviceGroupTagListResponseBodyDataGroupTagInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceInfoResponseBodyData extends $tea.Model {
  deviceName?: string;
  deviceSecret?: string;
  iotId?: string;
  nickname?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      deviceSecret: 'DeviceSecret',
      iotId: 'IotId',
      nickname: 'Nickname',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      deviceSecret: 'string',
      iotId: 'string',
      nickname: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceListByDeviceGroupResponseBodyDataSimpleDeviceInfo extends $tea.Model {
  deviceName?: string;
  iotId?: string;
  productKey?: string;
  productName?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      productKey: 'ProductKey',
      productName: 'ProductName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      productKey: 'string',
      productName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceListByDeviceGroupResponseBodyData extends $tea.Model {
  simpleDeviceInfo?: QueryDeviceListByDeviceGroupResponseBodyDataSimpleDeviceInfo[];
  static names(): { [key: string]: string } {
    return {
      simpleDeviceInfo: 'SimpleDeviceInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      simpleDeviceInfo: { 'type': 'array', 'itemType': QueryDeviceListByDeviceGroupResponseBodyDataSimpleDeviceInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceOriginalEventDataResponseBodyDataListEventInfo extends $tea.Model {
  eventType?: string;
  identifier?: string;
  name?: string;
  outputData?: string;
  time?: string;
  static names(): { [key: string]: string } {
    return {
      eventType: 'EventType',
      identifier: 'Identifier',
      name: 'Name',
      outputData: 'OutputData',
      time: 'Time',
    };
  }

  static types(): { [key: string]: any } {
    return {
      eventType: 'string',
      identifier: 'string',
      name: 'string',
      outputData: 'string',
      time: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceOriginalEventDataResponseBodyDataList extends $tea.Model {
  eventInfo?: QueryDeviceOriginalEventDataResponseBodyDataListEventInfo[];
  static names(): { [key: string]: string } {
    return {
      eventInfo: 'EventInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      eventInfo: { 'type': 'array', 'itemType': QueryDeviceOriginalEventDataResponseBodyDataListEventInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceOriginalEventDataResponseBodyData extends $tea.Model {
  list?: QueryDeviceOriginalEventDataResponseBodyDataList;
  nextPageToken?: string;
  nextValid?: boolean;
  static names(): { [key: string]: string } {
    return {
      list: 'List',
      nextPageToken: 'NextPageToken',
      nextValid: 'NextValid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      list: QueryDeviceOriginalEventDataResponseBodyDataList,
      nextPageToken: 'string',
      nextValid: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceOriginalPropertyDataResponseBodyDataListPropertyInfo extends $tea.Model {
  time?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      time: 'Time',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      time: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceOriginalPropertyDataResponseBodyDataList extends $tea.Model {
  propertyInfo?: QueryDeviceOriginalPropertyDataResponseBodyDataListPropertyInfo[];
  static names(): { [key: string]: string } {
    return {
      propertyInfo: 'PropertyInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      propertyInfo: { 'type': 'array', 'itemType': QueryDeviceOriginalPropertyDataResponseBodyDataListPropertyInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceOriginalPropertyDataResponseBodyData extends $tea.Model {
  list?: QueryDeviceOriginalPropertyDataResponseBodyDataList;
  nextValid?: boolean;
  nextPageToken?: string;
  static names(): { [key: string]: string } {
    return {
      list: 'List',
      nextValid: 'NextValid',
      nextPageToken: 'nextPageToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      list: QueryDeviceOriginalPropertyDataResponseBodyDataList,
      nextValid: 'boolean',
      nextPageToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceOriginalPropertyStatusResponseBodyDataListPropertyStatusDataInfo extends $tea.Model {
  identifier?: string;
  time?: number;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      identifier: 'Identifier',
      time: 'Time',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      identifier: 'string',
      time: 'number',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceOriginalPropertyStatusResponseBodyDataList extends $tea.Model {
  propertyStatusDataInfo?: QueryDeviceOriginalPropertyStatusResponseBodyDataListPropertyStatusDataInfo[];
  static names(): { [key: string]: string } {
    return {
      propertyStatusDataInfo: 'PropertyStatusDataInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      propertyStatusDataInfo: { 'type': 'array', 'itemType': QueryDeviceOriginalPropertyStatusResponseBodyDataListPropertyStatusDataInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceOriginalPropertyStatusResponseBodyData extends $tea.Model {
  list?: QueryDeviceOriginalPropertyStatusResponseBodyDataList;
  nextPageToken?: string;
  nextValid?: boolean;
  static names(): { [key: string]: string } {
    return {
      list: 'List',
      nextPageToken: 'NextPageToken',
      nextValid: 'NextValid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      list: QueryDeviceOriginalPropertyStatusResponseBodyDataList,
      nextPageToken: 'string',
      nextValid: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceOriginalServiceDataResponseBodyDataListServiceInfo extends $tea.Model {
  identifier?: string;
  inputData?: string;
  name?: string;
  outputData?: string;
  time?: string;
  static names(): { [key: string]: string } {
    return {
      identifier: 'Identifier',
      inputData: 'InputData',
      name: 'Name',
      outputData: 'OutputData',
      time: 'Time',
    };
  }

  static types(): { [key: string]: any } {
    return {
      identifier: 'string',
      inputData: 'string',
      name: 'string',
      outputData: 'string',
      time: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceOriginalServiceDataResponseBodyDataList extends $tea.Model {
  serviceInfo?: QueryDeviceOriginalServiceDataResponseBodyDataListServiceInfo[];
  static names(): { [key: string]: string } {
    return {
      serviceInfo: 'ServiceInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      serviceInfo: { 'type': 'array', 'itemType': QueryDeviceOriginalServiceDataResponseBodyDataListServiceInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceOriginalServiceDataResponseBodyData extends $tea.Model {
  list?: QueryDeviceOriginalServiceDataResponseBodyDataList;
  nextPageToken?: string;
  nextValid?: boolean;
  static names(): { [key: string]: string } {
    return {
      list: 'List',
      nextPageToken: 'NextPageToken',
      nextValid: 'NextValid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      list: QueryDeviceOriginalServiceDataResponseBodyDataList,
      nextPageToken: 'string',
      nextValid: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfoListPropertyInfo extends $tea.Model {
  time?: number;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      time: 'Time',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      time: 'number',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfoList extends $tea.Model {
  propertyInfo?: QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfoListPropertyInfo[];
  static names(): { [key: string]: string } {
    return {
      propertyInfo: 'PropertyInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      propertyInfo: { 'type': 'array', 'itemType': QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfoListPropertyInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfo extends $tea.Model {
  identifier?: string;
  list?: QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfoList;
  static names(): { [key: string]: string } {
    return {
      identifier: 'Identifier',
      list: 'List',
    };
  }

  static types(): { [key: string]: any } {
    return {
      identifier: 'string',
      list: QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfoList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicePropertiesDataResponseBodyPropertyDataInfos extends $tea.Model {
  propertyDataInfo?: QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfo[];
  static names(): { [key: string]: string } {
    return {
      propertyDataInfo: 'PropertyDataInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      propertyDataInfo: { 'type': 'array', 'itemType': QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicePropertyDataResponseBodyDataListPropertyInfo extends $tea.Model {
  time?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      time: 'Time',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      time: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicePropertyDataResponseBodyDataList extends $tea.Model {
  propertyInfo?: QueryDevicePropertyDataResponseBodyDataListPropertyInfo[];
  static names(): { [key: string]: string } {
    return {
      propertyInfo: 'PropertyInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      propertyInfo: { 'type': 'array', 'itemType': QueryDevicePropertyDataResponseBodyDataListPropertyInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicePropertyDataResponseBodyData extends $tea.Model {
  list?: QueryDevicePropertyDataResponseBodyDataList;
  nextTime?: number;
  nextValid?: boolean;
  static names(): { [key: string]: string } {
    return {
      list: 'List',
      nextTime: 'NextTime',
      nextValid: 'NextValid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      list: QueryDevicePropertyDataResponseBodyDataList,
      nextTime: 'number',
      nextValid: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicePropertyStatusResponseBodyDataListPropertyStatusInfo extends $tea.Model {
  dataType?: string;
  identifier?: string;
  name?: string;
  time?: string;
  unit?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      dataType: 'DataType',
      identifier: 'Identifier',
      name: 'Name',
      time: 'Time',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataType: 'string',
      identifier: 'string',
      name: 'string',
      time: 'string',
      unit: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicePropertyStatusResponseBodyDataList extends $tea.Model {
  propertyStatusInfo?: QueryDevicePropertyStatusResponseBodyDataListPropertyStatusInfo[];
  static names(): { [key: string]: string } {
    return {
      propertyStatusInfo: 'PropertyStatusInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      propertyStatusInfo: { 'type': 'array', 'itemType': QueryDevicePropertyStatusResponseBodyDataListPropertyStatusInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicePropertyStatusResponseBodyData extends $tea.Model {
  list?: QueryDevicePropertyStatusResponseBodyDataList;
  static names(): { [key: string]: string } {
    return {
      list: 'List',
    };
  }

  static types(): { [key: string]: any } {
    return {
      list: QueryDevicePropertyStatusResponseBodyDataList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceProvisioningResponseBodyData extends $tea.Model {
  aliyunUid?: string;
  deviceName?: string;
  gmtCreate?: number;
  gmtModified?: number;
  productKey?: string;
  sourceIotInstanceId?: string;
  sourceRegion?: string;
  targetIotInstanceId?: string;
  targetRegion?: string;
  static names(): { [key: string]: string } {
    return {
      aliyunUid: 'AliyunUid',
      deviceName: 'DeviceName',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      productKey: 'ProductKey',
      sourceIotInstanceId: 'SourceIotInstanceId',
      sourceRegion: 'SourceRegion',
      targetIotInstanceId: 'TargetIotInstanceId',
      targetRegion: 'TargetRegion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunUid: 'string',
      deviceName: 'string',
      gmtCreate: 'number',
      gmtModified: 'number',
      productKey: 'string',
      sourceIotInstanceId: 'string',
      sourceRegion: 'string',
      targetIotInstanceId: 'string',
      targetRegion: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceServiceDataResponseBodyDataListServiceInfo extends $tea.Model {
  identifier?: string;
  inputData?: string;
  name?: string;
  outputData?: string;
  time?: string;
  static names(): { [key: string]: string } {
    return {
      identifier: 'Identifier',
      inputData: 'InputData',
      name: 'Name',
      outputData: 'OutputData',
      time: 'Time',
    };
  }

  static types(): { [key: string]: any } {
    return {
      identifier: 'string',
      inputData: 'string',
      name: 'string',
      outputData: 'string',
      time: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceServiceDataResponseBodyDataList extends $tea.Model {
  serviceInfo?: QueryDeviceServiceDataResponseBodyDataListServiceInfo[];
  static names(): { [key: string]: string } {
    return {
      serviceInfo: 'ServiceInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      serviceInfo: { 'type': 'array', 'itemType': QueryDeviceServiceDataResponseBodyDataListServiceInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceServiceDataResponseBodyData extends $tea.Model {
  list?: QueryDeviceServiceDataResponseBodyDataList;
  nextTime?: number;
  nextValid?: boolean;
  static names(): { [key: string]: string } {
    return {
      list: 'List',
      nextTime: 'NextTime',
      nextValid: 'NextValid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      list: QueryDeviceServiceDataResponseBodyDataList,
      nextTime: 'number',
      nextValid: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceSpeechResponseBodyDataListItems extends $tea.Model {
  audioFormat?: string;
  bizCode?: string;
  size?: number;
  static names(): { [key: string]: string } {
    return {
      audioFormat: 'AudioFormat',
      bizCode: 'BizCode',
      size: 'Size',
    };
  }

  static types(): { [key: string]: any } {
    return {
      audioFormat: 'string',
      bizCode: 'string',
      size: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceSpeechResponseBodyDataList extends $tea.Model {
  items?: QueryDeviceSpeechResponseBodyDataListItems[];
  static names(): { [key: string]: string } {
    return {
      items: 'Items',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: { 'type': 'array', 'itemType': QueryDeviceSpeechResponseBodyDataListItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceSpeechResponseBodyData extends $tea.Model {
  list?: QueryDeviceSpeechResponseBodyDataList;
  pageId?: number;
  pageSize?: number;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      list: 'List',
      pageId: 'PageId',
      pageSize: 'PageSize',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      list: QueryDeviceSpeechResponseBodyDataList,
      pageId: 'number',
      pageSize: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceStatisticsResponseBodyData extends $tea.Model {
  activeCount?: number;
  deviceCount?: number;
  onlineCount?: number;
  static names(): { [key: string]: string } {
    return {
      activeCount: 'activeCount',
      deviceCount: 'deviceCount',
      onlineCount: 'onlineCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      activeCount: 'number',
      deviceCount: 'number',
      onlineCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceSubTopicResponseBodyTopicList extends $tea.Model {
  timestamp?: number;
  topicName?: string;
  static names(): { [key: string]: string } {
    return {
      timestamp: 'Timestamp',
      topicName: 'TopicName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      timestamp: 'number',
      topicName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDeviceTunnelResponseBodyData extends $tea.Model {
  description?: string;
  deviceConnState?: string;
  deviceName?: string;
  iotId?: string;
  productKey?: string;
  productName?: string;
  sourceConnState?: string;
  tunnelId?: string;
  tunnelState?: string;
  udi?: string;
  utcClosed?: string;
  utcCreated?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      deviceConnState: 'DeviceConnState',
      deviceName: 'DeviceName',
      iotId: 'IotId',
      productKey: 'ProductKey',
      productName: 'ProductName',
      sourceConnState: 'SourceConnState',
      tunnelId: 'TunnelId',
      tunnelState: 'TunnelState',
      udi: 'Udi',
      utcClosed: 'UtcClosed',
      utcCreated: 'UtcCreated',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      deviceConnState: 'string',
      deviceName: 'string',
      iotId: 'string',
      productKey: 'string',
      productName: 'string',
      sourceConnState: 'string',
      tunnelId: 'string',
      tunnelState: 'string',
      udi: 'string',
      utcClosed: 'string',
      utcCreated: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicesHotStorageDataResponseBodyDataListPropertyInfo extends $tea.Model {
  time?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      time: 'Time',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      time: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicesHotStorageDataResponseBodyDataList extends $tea.Model {
  propertyInfo?: QueryDevicesHotStorageDataResponseBodyDataListPropertyInfo[];
  static names(): { [key: string]: string } {
    return {
      propertyInfo: 'PropertyInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      propertyInfo: { 'type': 'array', 'itemType': QueryDevicesHotStorageDataResponseBodyDataListPropertyInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicesHotStorageDataResponseBodyData extends $tea.Model {
  list?: QueryDevicesHotStorageDataResponseBodyDataList;
  nextValid?: boolean;
  nextPageToken?: string;
  static names(): { [key: string]: string } {
    return {
      list: 'List',
      nextValid: 'NextValid',
      nextPageToken: 'nextPageToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      list: QueryDevicesHotStorageDataResponseBodyDataList,
      nextValid: 'boolean',
      nextPageToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicesHotStorageDataStatusResponseBodyDataListPropertyStatusDataInfo extends $tea.Model {
  identifier?: string;
  time?: number;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      identifier: 'Identifier',
      time: 'Time',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      identifier: 'string',
      time: 'number',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicesHotStorageDataStatusResponseBodyDataList extends $tea.Model {
  propertyStatusDataInfo?: QueryDevicesHotStorageDataStatusResponseBodyDataListPropertyStatusDataInfo[];
  static names(): { [key: string]: string } {
    return {
      propertyStatusDataInfo: 'PropertyStatusDataInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      propertyStatusDataInfo: { 'type': 'array', 'itemType': QueryDevicesHotStorageDataStatusResponseBodyDataListPropertyStatusDataInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDevicesHotStorageDataStatusResponseBodyData extends $tea.Model {
  list?: QueryDevicesHotStorageDataStatusResponseBodyDataList;
  nextPageToken?: string;
  nextValid?: boolean;
  static names(): { [key: string]: string } {
    return {
      list: 'List',
      nextPageToken: 'NextPageToken',
      nextValid: 'NextValid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      list: QueryDevicesHotStorageDataStatusResponseBodyDataList,
      nextPageToken: 'string',
      nextValid: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDynamicGroupDevicesResponseBodyDataSimpleDeviceInfo extends $tea.Model {
  activeTime?: string;
  categoryKey?: string;
  deviceName?: string;
  iotId?: string;
  lastOnlineTime?: string;
  nickname?: string;
  nodeType?: number;
  productKey?: string;
  productName?: string;
  status?: string;
  utcActiveTime?: string;
  utcLastOnlineTime?: string;
  static names(): { [key: string]: string } {
    return {
      activeTime: 'ActiveTime',
      categoryKey: 'CategoryKey',
      deviceName: 'DeviceName',
      iotId: 'IotId',
      lastOnlineTime: 'LastOnlineTime',
      nickname: 'Nickname',
      nodeType: 'NodeType',
      productKey: 'ProductKey',
      productName: 'ProductName',
      status: 'Status',
      utcActiveTime: 'UtcActiveTime',
      utcLastOnlineTime: 'UtcLastOnlineTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      activeTime: 'string',
      categoryKey: 'string',
      deviceName: 'string',
      iotId: 'string',
      lastOnlineTime: 'string',
      nickname: 'string',
      nodeType: 'number',
      productKey: 'string',
      productName: 'string',
      status: 'string',
      utcActiveTime: 'string',
      utcLastOnlineTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDynamicGroupDevicesResponseBodyData extends $tea.Model {
  simpleDeviceInfo?: QueryDynamicGroupDevicesResponseBodyDataSimpleDeviceInfo[];
  static names(): { [key: string]: string } {
    return {
      simpleDeviceInfo: 'SimpleDeviceInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      simpleDeviceInfo: { 'type': 'array', 'itemType': QueryDynamicGroupDevicesResponseBodyDataSimpleDeviceInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeDriverResponseBodyDataDriverList extends $tea.Model {
  cpuArch?: string;
  driverId?: string;
  driverName?: string;
  driverProtocol?: string;
  gmtCreateTimestamp?: number;
  gmtModifiedTimestamp?: number;
  isApply?: boolean;
  isBuiltIn?: boolean;
  runtime?: string;
  type?: number;
  static names(): { [key: string]: string } {
    return {
      cpuArch: 'CpuArch',
      driverId: 'DriverId',
      driverName: 'DriverName',
      driverProtocol: 'DriverProtocol',
      gmtCreateTimestamp: 'GmtCreateTimestamp',
      gmtModifiedTimestamp: 'GmtModifiedTimestamp',
      isApply: 'IsApply',
      isBuiltIn: 'IsBuiltIn',
      runtime: 'Runtime',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cpuArch: 'string',
      driverId: 'string',
      driverName: 'string',
      driverProtocol: 'string',
      gmtCreateTimestamp: 'number',
      gmtModifiedTimestamp: 'number',
      isApply: 'boolean',
      isBuiltIn: 'boolean',
      runtime: 'string',
      type: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeDriverResponseBodyData extends $tea.Model {
  currentPage?: number;
  driverList?: QueryEdgeDriverResponseBodyDataDriverList[];
  pageSize?: number;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      driverList: 'DriverList',
      pageSize: 'PageSize',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      driverList: { 'type': 'array', 'itemType': QueryEdgeDriverResponseBodyDataDriverList },
      pageSize: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeDriverVersionResponseBodyDataDriverVersionList extends $tea.Model {
  argument?: string;
  configCheckRule?: string;
  containerConfig?: string;
  description?: string;
  driverConfig?: string;
  driverId?: string;
  driverVersion?: string;
  edgeVersion?: string;
  gmtCreateTimestamp?: number;
  gmtModifiedTimestamp?: number;
  sourceConfig?: string;
  versionState?: string;
  static names(): { [key: string]: string } {
    return {
      argument: 'Argument',
      configCheckRule: 'ConfigCheckRule',
      containerConfig: 'ContainerConfig',
      description: 'Description',
      driverConfig: 'DriverConfig',
      driverId: 'DriverId',
      driverVersion: 'DriverVersion',
      edgeVersion: 'EdgeVersion',
      gmtCreateTimestamp: 'GmtCreateTimestamp',
      gmtModifiedTimestamp: 'GmtModifiedTimestamp',
      sourceConfig: 'SourceConfig',
      versionState: 'VersionState',
    };
  }

  static types(): { [key: string]: any } {
    return {
      argument: 'string',
      configCheckRule: 'string',
      containerConfig: 'string',
      description: 'string',
      driverConfig: 'string',
      driverId: 'string',
      driverVersion: 'string',
      edgeVersion: 'string',
      gmtCreateTimestamp: 'number',
      gmtModifiedTimestamp: 'number',
      sourceConfig: 'string',
      versionState: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeDriverVersionResponseBodyData extends $tea.Model {
  currentPage?: number;
  driverVersionList?: QueryEdgeDriverVersionResponseBodyDataDriverVersionList[];
  pageSize?: number;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      driverVersionList: 'DriverVersionList',
      pageSize: 'PageSize',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      driverVersionList: { 'type': 'array', 'itemType': QueryEdgeDriverVersionResponseBodyDataDriverVersionList },
      pageSize: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceResponseBodyDataInstanceList extends $tea.Model {
  bizEnable?: boolean;
  gmtCreate?: string;
  gmtCreateTimestamp?: number;
  gmtModified?: string;
  gmtModifiedTimestamp?: number;
  instanceId?: string;
  latestDeploymentStatus?: number;
  latestDeploymentType?: string;
  name?: string;
  roleArn?: string;
  roleAttachTime?: string;
  roleAttachTimestamp?: number;
  roleName?: string;
  spec?: number;
  tags?: string;
  type?: number;
  static names(): { [key: string]: string } {
    return {
      bizEnable: 'BizEnable',
      gmtCreate: 'GmtCreate',
      gmtCreateTimestamp: 'GmtCreateTimestamp',
      gmtModified: 'GmtModified',
      gmtModifiedTimestamp: 'GmtModifiedTimestamp',
      instanceId: 'InstanceId',
      latestDeploymentStatus: 'LatestDeploymentStatus',
      latestDeploymentType: 'LatestDeploymentType',
      name: 'Name',
      roleArn: 'RoleArn',
      roleAttachTime: 'RoleAttachTime',
      roleAttachTimestamp: 'RoleAttachTimestamp',
      roleName: 'RoleName',
      spec: 'Spec',
      tags: 'Tags',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizEnable: 'boolean',
      gmtCreate: 'string',
      gmtCreateTimestamp: 'number',
      gmtModified: 'string',
      gmtModifiedTimestamp: 'number',
      instanceId: 'string',
      latestDeploymentStatus: 'number',
      latestDeploymentType: 'string',
      name: 'string',
      roleArn: 'string',
      roleAttachTime: 'string',
      roleAttachTimestamp: 'number',
      roleName: 'string',
      spec: 'number',
      tags: 'string',
      type: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceResponseBodyData extends $tea.Model {
  currentPage?: number;
  instanceList?: QueryEdgeInstanceResponseBodyDataInstanceList[];
  pageSize?: number;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      instanceList: 'InstanceList',
      pageSize: 'PageSize',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      instanceList: { 'type': 'array', 'itemType': QueryEdgeInstanceResponseBodyDataInstanceList },
      pageSize: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceChannelResponseBodyDataChannelListChannelConfigListConfig extends $tea.Model {
  configId?: string;
  content?: string;
  format?: string;
  key?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      content: 'Content',
      format: 'Format',
      key: 'Key',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'string',
      content: 'string',
      format: 'string',
      key: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceChannelResponseBodyDataChannelListChannelConfigList extends $tea.Model {
  config?: QueryEdgeInstanceChannelResponseBodyDataChannelListChannelConfigListConfig[];
  static names(): { [key: string]: string } {
    return {
      config: 'Config',
    };
  }

  static types(): { [key: string]: any } {
    return {
      config: { 'type': 'array', 'itemType': QueryEdgeInstanceChannelResponseBodyDataChannelListChannelConfigListConfig },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceChannelResponseBodyDataChannelListChannel extends $tea.Model {
  channelId?: string;
  channelName?: string;
  configList?: QueryEdgeInstanceChannelResponseBodyDataChannelListChannelConfigList;
  gmtCreate?: string;
  gmtCreateTimestamp?: number;
  gmtModified?: string;
  gmtModifiedTimestamp?: number;
  static names(): { [key: string]: string } {
    return {
      channelId: 'ChannelId',
      channelName: 'ChannelName',
      configList: 'ConfigList',
      gmtCreate: 'GmtCreate',
      gmtCreateTimestamp: 'GmtCreateTimestamp',
      gmtModified: 'GmtModified',
      gmtModifiedTimestamp: 'GmtModifiedTimestamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelId: 'string',
      channelName: 'string',
      configList: QueryEdgeInstanceChannelResponseBodyDataChannelListChannelConfigList,
      gmtCreate: 'string',
      gmtCreateTimestamp: 'number',
      gmtModified: 'string',
      gmtModifiedTimestamp: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceChannelResponseBodyDataChannelList extends $tea.Model {
  channel?: QueryEdgeInstanceChannelResponseBodyDataChannelListChannel[];
  static names(): { [key: string]: string } {
    return {
      channel: 'Channel',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channel: { 'type': 'array', 'itemType': QueryEdgeInstanceChannelResponseBodyDataChannelListChannel },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceChannelResponseBodyData extends $tea.Model {
  channelList?: QueryEdgeInstanceChannelResponseBodyDataChannelList;
  currentPage?: number;
  pageSize?: number;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      channelList: 'ChannelList',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelList: QueryEdgeInstanceChannelResponseBodyDataChannelList,
      currentPage: 'number',
      pageSize: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceDeviceResponseBodyDataDeviceList extends $tea.Model {
  deviceName?: string;
  driverId?: string;
  iotId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      driverId: 'DriverId',
      iotId: 'IotId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      driverId: 'string',
      iotId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceDeviceResponseBodyData extends $tea.Model {
  currentPage?: number;
  deviceList?: QueryEdgeInstanceDeviceResponseBodyDataDeviceList[];
  pageSize?: number;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      deviceList: 'DeviceList',
      pageSize: 'PageSize',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      deviceList: { 'type': 'array', 'itemType': QueryEdgeInstanceDeviceResponseBodyDataDeviceList },
      pageSize: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceDeviceByDriverResponseBodyDataDeviceList extends $tea.Model {
  iotId?: string;
  static names(): { [key: string]: string } {
    return {
      iotId: 'IotId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iotId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceDeviceByDriverResponseBodyData extends $tea.Model {
  currentPage?: number;
  deviceList?: QueryEdgeInstanceDeviceByDriverResponseBodyDataDeviceList[];
  pageSize?: number;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      deviceList: 'DeviceList',
      pageSize: 'PageSize',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      deviceList: { 'type': 'array', 'itemType': QueryEdgeInstanceDeviceByDriverResponseBodyDataDeviceList },
      pageSize: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceDriverResponseBodyDataDriverList extends $tea.Model {
  driverId?: string;
  driverVersion?: string;
  gmtCreate?: string;
  gmtModified?: string;
  orderId?: string;
  static names(): { [key: string]: string } {
    return {
      driverId: 'DriverId',
      driverVersion: 'DriverVersion',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      orderId: 'OrderId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      driverId: 'string',
      driverVersion: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      orderId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceDriverResponseBodyData extends $tea.Model {
  currentPage?: number;
  driverList?: QueryEdgeInstanceDriverResponseBodyDataDriverList[];
  pageSize?: number;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      driverList: 'DriverList',
      pageSize: 'PageSize',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      driverList: { 'type': 'array', 'itemType': QueryEdgeInstanceDriverResponseBodyDataDriverList },
      pageSize: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceGatewayResponseBodyGatewayList extends $tea.Model {
  deviceName?: string;
  edgeVersion?: string;
  iotId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      edgeVersion: 'EdgeVersion',
      iotId: 'IotId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      edgeVersion: 'string',
      iotId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceHistoricDeploymentResponseBodyDataDeploymentList extends $tea.Model {
  deploymentId?: string;
  description?: string;
  gmtCompleted?: string;
  gmtCompletedTimestamp?: number;
  gmtCreate?: string;
  gmtCreateTimestamp?: number;
  gmtModified?: string;
  gmtModifiedTimestamp?: number;
  status?: number;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      deploymentId: 'DeploymentId',
      description: 'Description',
      gmtCompleted: 'GmtCompleted',
      gmtCompletedTimestamp: 'GmtCompletedTimestamp',
      gmtCreate: 'GmtCreate',
      gmtCreateTimestamp: 'GmtCreateTimestamp',
      gmtModified: 'GmtModified',
      gmtModifiedTimestamp: 'GmtModifiedTimestamp',
      status: 'Status',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deploymentId: 'string',
      description: 'string',
      gmtCompleted: 'string',
      gmtCompletedTimestamp: 'number',
      gmtCreate: 'string',
      gmtCreateTimestamp: 'number',
      gmtModified: 'string',
      gmtModifiedTimestamp: 'number',
      status: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceHistoricDeploymentResponseBodyData extends $tea.Model {
  currentPage?: number;
  deploymentList?: QueryEdgeInstanceHistoricDeploymentResponseBodyDataDeploymentList[];
  pageSize?: number;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      deploymentList: 'DeploymentList',
      pageSize: 'PageSize',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      deploymentList: { 'type': 'array', 'itemType': QueryEdgeInstanceHistoricDeploymentResponseBodyDataDeploymentList },
      pageSize: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRouteRouteContext extends $tea.Model {
  qos?: string;
  sourceApplicationName?: string;
  sourceFcFunctionName?: string;
  sourceFcServiceName?: string;
  targetApplicationName?: string;
  targetFcFunctionName?: string;
  targetFcServiceName?: string;
  static names(): { [key: string]: string } {
    return {
      qos: 'Qos',
      sourceApplicationName: 'SourceApplicationName',
      sourceFcFunctionName: 'SourceFcFunctionName',
      sourceFcServiceName: 'SourceFcServiceName',
      targetApplicationName: 'TargetApplicationName',
      targetFcFunctionName: 'TargetFcFunctionName',
      targetFcServiceName: 'TargetFcServiceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      qos: 'string',
      sourceApplicationName: 'string',
      sourceFcFunctionName: 'string',
      sourceFcServiceName: 'string',
      targetApplicationName: 'string',
      targetFcFunctionName: 'string',
      targetFcServiceName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRoute extends $tea.Model {
  gmtCreate?: string;
  gmtCreateTimestamp?: number;
  gmtModified?: string;
  gmtModifiedTimestamp?: number;
  name?: string;
  routeContext?: QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRouteRouteContext;
  routeId?: number;
  sourceData?: string;
  sourceType?: string;
  targetData?: string;
  targetType?: string;
  topicFilter?: string;
  static names(): { [key: string]: string } {
    return {
      gmtCreate: 'GmtCreate',
      gmtCreateTimestamp: 'GmtCreateTimestamp',
      gmtModified: 'GmtModified',
      gmtModifiedTimestamp: 'GmtModifiedTimestamp',
      name: 'Name',
      routeContext: 'RouteContext',
      routeId: 'RouteId',
      sourceData: 'SourceData',
      sourceType: 'SourceType',
      targetData: 'TargetData',
      targetType: 'TargetType',
      topicFilter: 'TopicFilter',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gmtCreate: 'string',
      gmtCreateTimestamp: 'number',
      gmtModified: 'string',
      gmtModifiedTimestamp: 'number',
      name: 'string',
      routeContext: QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRouteRouteContext,
      routeId: 'number',
      sourceData: 'string',
      sourceType: 'string',
      targetData: 'string',
      targetType: 'string',
      topicFilter: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteList extends $tea.Model {
  messageRoute?: QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRoute[];
  static names(): { [key: string]: string } {
    return {
      messageRoute: 'MessageRoute',
    };
  }

  static types(): { [key: string]: any } {
    return {
      messageRoute: { 'type': 'array', 'itemType': QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRoute },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceMessageRoutingResponseBodyData extends $tea.Model {
  currentPage?: number;
  messageRouteList?: QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteList;
  pageSize?: number;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      messageRouteList: 'MessageRouteList',
      pageSize: 'PageSize',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      messageRouteList: QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteList,
      pageSize: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceSceneRuleResponseBodyDataRuleList extends $tea.Model {
  gmtCreate?: number;
  isExisted?: number;
  ruleId?: string;
  ruleName?: string;
  status?: number;
  static names(): { [key: string]: string } {
    return {
      gmtCreate: 'GmtCreate',
      isExisted: 'IsExisted',
      ruleId: 'RuleId',
      ruleName: 'RuleName',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gmtCreate: 'number',
      isExisted: 'number',
      ruleId: 'string',
      ruleName: 'string',
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEdgeInstanceSceneRuleResponseBodyData extends $tea.Model {
  currentPage?: number;
  pageSize?: number;
  ruleList?: QueryEdgeInstanceSceneRuleResponseBodyDataRuleList[];
  total?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      ruleList: 'RuleList',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      pageSize: 'number',
      ruleList: { 'type': 'array', 'itemType': QueryEdgeInstanceSceneRuleResponseBodyDataRuleList },
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryImportedDeviceByApplyIdResponseBodyDeviceListDevice extends $tea.Model {
  deviceName?: string;
  deviceSecret?: string;
  productKey?: string;
  sn?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      deviceSecret: 'DeviceSecret',
      productKey: 'ProductKey',
      sn: 'Sn',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      deviceSecret: 'string',
      productKey: 'string',
      sn: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryImportedDeviceByApplyIdResponseBodyDeviceList extends $tea.Model {
  device?: QueryImportedDeviceByApplyIdResponseBodyDeviceListDevice[];
  static names(): { [key: string]: string } {
    return {
      device: 'device',
    };
  }

  static types(): { [key: string]: any } {
    return {
      device: { 'type': 'array', 'itemType': QueryImportedDeviceByApplyIdResponseBodyDeviceListDevice },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobResponseBodyDataJobFile extends $tea.Model {
  fileUrl?: string;
  sign?: string;
  signMethod?: string;
  static names(): { [key: string]: string } {
    return {
      fileUrl: 'FileUrl',
      sign: 'Sign',
      signMethod: 'SignMethod',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fileUrl: 'string',
      sign: 'string',
      signMethod: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobResponseBodyDataRolloutConfig extends $tea.Model {
  maximumPerMinute?: number;
  messageQoS?: string;
  static names(): { [key: string]: string } {
    return {
      maximumPerMinute: 'MaximumPerMinute',
      messageQoS: 'MessageQoS',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maximumPerMinute: 'number',
      messageQoS: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobResponseBodyDataTargetConfigTargetDevicesTargetDevices extends $tea.Model {
  deviceName?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobResponseBodyDataTargetConfigTargetDevices extends $tea.Model {
  targetDevices?: QueryJobResponseBodyDataTargetConfigTargetDevicesTargetDevices[];
  static names(): { [key: string]: string } {
    return {
      targetDevices: 'targetDevices',
    };
  }

  static types(): { [key: string]: any } {
    return {
      targetDevices: { 'type': 'array', 'itemType': QueryJobResponseBodyDataTargetConfigTargetDevicesTargetDevices },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobResponseBodyDataTargetConfig extends $tea.Model {
  targetDevices?: QueryJobResponseBodyDataTargetConfigTargetDevices;
  targetGroup?: string;
  targetProduct?: string;
  targetType?: string;
  static names(): { [key: string]: string } {
    return {
      targetDevices: 'TargetDevices',
      targetGroup: 'TargetGroup',
      targetProduct: 'TargetProduct',
      targetType: 'TargetType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      targetDevices: QueryJobResponseBodyDataTargetConfigTargetDevices,
      targetGroup: 'string',
      targetProduct: 'string',
      targetType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobResponseBodyDataTimeoutConfig extends $tea.Model {
  inProgressTimeoutInMinutes?: number;
  static names(): { [key: string]: string } {
    return {
      inProgressTimeoutInMinutes: 'InProgressTimeoutInMinutes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      inProgressTimeoutInMinutes: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobResponseBodyData extends $tea.Model {
  description?: string;
  jobDocument?: string;
  jobFile?: QueryJobResponseBodyDataJobFile;
  jobId?: string;
  jobName?: string;
  rolloutConfig?: QueryJobResponseBodyDataRolloutConfig;
  scheduledTime?: number;
  status?: string;
  targetConfig?: QueryJobResponseBodyDataTargetConfig;
  timeoutConfig?: QueryJobResponseBodyDataTimeoutConfig;
  type?: string;
  utcCreate?: string;
  utcModified?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      jobDocument: 'JobDocument',
      jobFile: 'JobFile',
      jobId: 'JobId',
      jobName: 'JobName',
      rolloutConfig: 'RolloutConfig',
      scheduledTime: 'ScheduledTime',
      status: 'Status',
      targetConfig: 'TargetConfig',
      timeoutConfig: 'TimeoutConfig',
      type: 'Type',
      utcCreate: 'UtcCreate',
      utcModified: 'UtcModified',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      jobDocument: 'string',
      jobFile: QueryJobResponseBodyDataJobFile,
      jobId: 'string',
      jobName: 'string',
      rolloutConfig: QueryJobResponseBodyDataRolloutConfig,
      scheduledTime: 'number',
      status: 'string',
      targetConfig: QueryJobResponseBodyDataTargetConfig,
      timeoutConfig: QueryJobResponseBodyDataTimeoutConfig,
      type: 'string',
      utcCreate: 'string',
      utcModified: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJobStatisticsResponseBodyData extends $tea.Model {
  cancelled?: number;
  failed?: number;
  inProgress?: number;
  queued?: number;
  rejected?: number;
  sent?: number;
  succeeded?: number;
  timeOut?: number;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      cancelled: 'Cancelled',
      failed: 'Failed',
      inProgress: 'InProgress',
      queued: 'Queued',
      rejected: 'Rejected',
      sent: 'Sent',
      succeeded: 'Succeeded',
      timeOut: 'TimeOut',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cancelled: 'number',
      failed: 'number',
      inProgress: 'number',
      queued: 'number',
      rejected: 'number',
      sent: 'number',
      succeeded: 'number',
      timeOut: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryLicenseDeviceListResponseBodyDataDeviceListItem extends $tea.Model {
  deviceName?: string;
  expiryTime?: number;
  gmtCreate?: number;
  iotId?: string;
  licenseCode?: string;
  productKey?: string;
  productName?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      expiryTime: 'ExpiryTime',
      gmtCreate: 'GmtCreate',
      iotId: 'IotId',
      licenseCode: 'LicenseCode',
      productKey: 'ProductKey',
      productName: 'ProductName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      expiryTime: 'number',
      gmtCreate: 'number',
      iotId: 'string',
      licenseCode: 'string',
      productKey: 'string',
      productName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryLicenseDeviceListResponseBodyDataDeviceList extends $tea.Model {
  item?: QueryLicenseDeviceListResponseBodyDataDeviceListItem[];
  static names(): { [key: string]: string } {
    return {
      item: 'item',
    };
  }

  static types(): { [key: string]: any } {
    return {
      item: { 'type': 'array', 'itemType': QueryLicenseDeviceListResponseBodyDataDeviceListItem },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryLicenseDeviceListResponseBodyData extends $tea.Model {
  deviceList?: QueryLicenseDeviceListResponseBodyDataDeviceList;
  pageId?: number;
  pageSize?: number;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      deviceList: 'DeviceList',
      pageId: 'PageId',
      pageSize: 'PageSize',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceList: QueryLicenseDeviceListResponseBodyDataDeviceList,
      pageId: 'number',
      pageSize: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryLoRaJoinPermissionsResponseBodyJoinPermissionsJoinPermission extends $tea.Model {
  classMode?: string;
  enabled?: boolean;
  joinPermissionId?: string;
  joinPermissionName?: string;
  joinPermissionType?: string;
  ownerAliyunPk?: string;
  static names(): { [key: string]: string } {
    return {
      classMode: 'ClassMode',
      enabled: 'Enabled',
      joinPermissionId: 'JoinPermissionId',
      joinPermissionName: 'JoinPermissionName',
      joinPermissionType: 'JoinPermissionType',
      ownerAliyunPk: 'OwnerAliyunPk',
    };
  }

  static types(): { [key: string]: any } {
    return {
      classMode: 'string',
      enabled: 'boolean',
      joinPermissionId: 'string',
      joinPermissionName: 'string',
      joinPermissionType: 'string',
      ownerAliyunPk: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryLoRaJoinPermissionsResponseBodyJoinPermissions extends $tea.Model {
  joinPermission?: QueryLoRaJoinPermissionsResponseBodyJoinPermissionsJoinPermission[];
  static names(): { [key: string]: string } {
    return {
      joinPermission: 'JoinPermission',
    };
  }

  static types(): { [key: string]: any } {
    return {
      joinPermission: { 'type': 'array', 'itemType': QueryLoRaJoinPermissionsResponseBodyJoinPermissionsJoinPermission },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMessageInfoResponseBodyMessageUserProperties extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMessageInfoResponseBodyMessage extends $tea.Model {
  generateTime?: number;
  messageContent?: string;
  topicFullName?: string;
  uniMsgId?: string;
  userProperties?: QueryMessageInfoResponseBodyMessageUserProperties[];
  static names(): { [key: string]: string } {
    return {
      generateTime: 'GenerateTime',
      messageContent: 'MessageContent',
      topicFullName: 'TopicFullName',
      uniMsgId: 'UniMsgId',
      userProperties: 'UserProperties',
    };
  }

  static types(): { [key: string]: any } {
    return {
      generateTime: 'number',
      messageContent: 'string',
      topicFullName: 'string',
      uniMsgId: 'string',
      userProperties: { 'type': 'array', 'itemType': QueryMessageInfoResponseBodyMessageUserProperties },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryOTAFirmwareResponseBodyFirmwareInfoMultiFiles extends $tea.Model {
  fileMd5?: string;
  name?: string;
  signValue?: string;
  size?: number;
  url?: string;
  static names(): { [key: string]: string } {
    return {
      fileMd5: 'FileMd5',
      name: 'Name',
      signValue: 'SignValue',
      size: 'Size',
      url: 'Url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fileMd5: 'string',
      name: 'string',
      signValue: 'string',
      size: 'number',
      url: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryOTAFirmwareResponseBodyFirmwareInfo extends $tea.Model {
  destVersion?: string;
  firmwareDesc?: string;
  firmwareId?: string;
  firmwareName?: string;
  firmwareSign?: string;
  firmwareSize?: number;
  firmwareUrl?: string;
  moduleName?: string;
  multiFiles?: QueryOTAFirmwareResponseBodyFirmwareInfoMultiFiles[];
  productKey?: string;
  productName?: string;
  signMethod?: string;
  srcVersion?: string;
  status?: number;
  type?: number;
  udi?: string;
  utcCreate?: string;
  utcModified?: string;
  verifyProgress?: number;
  static names(): { [key: string]: string } {
    return {
      destVersion: 'DestVersion',
      firmwareDesc: 'FirmwareDesc',
      firmwareId: 'FirmwareId',
      firmwareName: 'FirmwareName',
      firmwareSign: 'FirmwareSign',
      firmwareSize: 'FirmwareSize',
      firmwareUrl: 'FirmwareUrl',
      moduleName: 'ModuleName',
      multiFiles: 'MultiFiles',
      productKey: 'ProductKey',
      productName: 'ProductName',
      signMethod: 'SignMethod',
      srcVersion: 'SrcVersion',
      status: 'Status',
      type: 'Type',
      udi: 'Udi',
      utcCreate: 'UtcCreate',
      utcModified: 'UtcModified',
      verifyProgress: 'VerifyProgress',
    };
  }

  static types(): { [key: string]: any } {
    return {
      destVersion: 'string',
      firmwareDesc: 'string',
      firmwareId: 'string',
      firmwareName: 'string',
      firmwareSign: 'string',
      firmwareSize: 'number',
      firmwareUrl: 'string',
      moduleName: 'string',
      multiFiles: { 'type': 'array', 'itemType': QueryOTAFirmwareResponseBodyFirmwareInfoMultiFiles },
      productKey: 'string',
      productName: 'string',
      signMethod: 'string',
      srcVersion: 'string',
      status: 'number',
      type: 'number',
      udi: 'string',
      utcCreate: 'string',
      utcModified: 'string',
      verifyProgress: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryOTAJobResponseBodyDataSrcVersions extends $tea.Model {
  srcVersion?: string[];
  static names(): { [key: string]: string } {
    return {
      srcVersion: 'SrcVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      srcVersion: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryOTAJobResponseBodyDataTagsOtaTagDTO extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryOTAJobResponseBodyDataTags extends $tea.Model {
  otaTagDTO?: QueryOTAJobResponseBodyDataTagsOtaTagDTO[];
  static names(): { [key: string]: string } {
    return {
      otaTagDTO: 'OtaTagDTO',
    };
  }

  static types(): { [key: string]: any } {
    return {
      otaTagDTO: { 'type': 'array', 'itemType': QueryOTAJobResponseBodyDataTagsOtaTagDTO },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryOTAJobResponseBodyData extends $tea.Model {
  destVersion?: string;
  downloadProtocol?: string;
  dynamicMode?: number;
  firmwareId?: string;
  grayPercent?: string;
  groupId?: string;
  groupName?: string;
  jobDesc?: string;
  jobId?: string;
  jobStatus?: string;
  jobType?: string;
  maximumPerMinute?: number;
  multiModuleMode?: boolean;
  name?: string;
  needConfirm?: boolean;
  needPush?: boolean;
  overwriteMode?: number;
  productKey?: string;
  retryCount?: number;
  retryInterval?: number;
  selectionType?: string;
  srcVersions?: QueryOTAJobResponseBodyDataSrcVersions;
  tags?: QueryOTAJobResponseBodyDataTags;
  targetSelection?: string;
  timeoutInMinutes?: number;
  utcCreate?: string;
  utcEndTime?: string;
  utcModified?: string;
  utcScheduleFinishTime?: string;
  utcScheduleTime?: string;
  utcStartTime?: string;
  static names(): { [key: string]: string } {
    return {
      destVersion: 'DestVersion',
      downloadProtocol: 'DownloadProtocol',
      dynamicMode: 'DynamicMode',
      firmwareId: 'FirmwareId',
      grayPercent: 'GrayPercent',
      groupId: 'GroupId',
      groupName: 'GroupName',
      jobDesc: 'JobDesc',
      jobId: 'JobId',
      jobStatus: 'JobStatus',
      jobType: 'JobType',
      maximumPerMinute: 'MaximumPerMinute',
      multiModuleMode: 'MultiModuleMode',
      name: 'Name',
      needConfirm: 'NeedConfirm',
      needPush: 'NeedPush',
      overwriteMode: 'OverwriteMode',
      productKey: 'ProductKey',
      retryCount: 'RetryCount',
      retryInterval: 'RetryInterval',
      selectionType: 'SelectionType',
      srcVersions: 'SrcVersions',
      tags: 'Tags',
      targetSelection: 'TargetSelection',
      timeoutInMinutes: 'TimeoutInMinutes',
      utcCreate: 'UtcCreate',
      utcEndTime: 'UtcEndTime',
      utcModified: 'UtcModified',
      utcScheduleFinishTime: 'UtcScheduleFinishTime',
      utcScheduleTime: 'UtcScheduleTime',
      utcStartTime: 'UtcStartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      destVersion: 'string',
      downloadProtocol: 'string',
      dynamicMode: 'number',
      firmwareId: 'string',
      grayPercent: 'string',
      groupId: 'string',
      groupName: 'string',
      jobDesc: 'string',
      jobId: 'string',
      jobStatus: 'string',
      jobType: 'string',
      maximumPerMinute: 'number',
      multiModuleMode: 'boolean',
      name: 'string',
      needConfirm: 'boolean',
      needPush: 'boolean',
      overwriteMode: 'number',
      productKey: 'string',
      retryCount: 'number',
      retryInterval: 'number',
      selectionType: 'string',
      srcVersions: QueryOTAJobResponseBodyDataSrcVersions,
      tags: QueryOTAJobResponseBodyDataTags,
      targetSelection: 'string',
      timeoutInMinutes: 'number',
      utcCreate: 'string',
      utcEndTime: 'string',
      utcModified: 'string',
      utcScheduleFinishTime: 'string',
      utcScheduleTime: 'string',
      utcStartTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryPageByApplyIdResponseBodyApplyDeviceListApplyDeviceInfo extends $tea.Model {
  deviceId?: string;
  deviceName?: string;
  deviceSecret?: string;
  iotId?: string;
  static names(): { [key: string]: string } {
    return {
      deviceId: 'DeviceId',
      deviceName: 'DeviceName',
      deviceSecret: 'DeviceSecret',
      iotId: 'IotId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceId: 'string',
      deviceName: 'string',
      deviceSecret: 'string',
      iotId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryPageByApplyIdResponseBodyApplyDeviceList extends $tea.Model {
  applyDeviceInfo?: QueryPageByApplyIdResponseBodyApplyDeviceListApplyDeviceInfo[];
  static names(): { [key: string]: string } {
    return {
      applyDeviceInfo: 'ApplyDeviceInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applyDeviceInfo: { 'type': 'array', 'itemType': QueryPageByApplyIdResponseBodyApplyDeviceListApplyDeviceInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryProductResponseBodyData extends $tea.Model {
  aliyunCommodityCode?: string;
  authType?: string;
  categoryKey?: string;
  categoryName?: string;
  dataFormat?: number;
  description?: string;
  deviceCount?: number;
  gmtCreate?: number;
  id2?: boolean;
  netType?: number;
  nodeType?: number;
  owner?: boolean;
  productKey?: string;
  productName?: string;
  productSecret?: string;
  productStatus?: string;
  protocolType?: string;
  validateType?: number;
  static names(): { [key: string]: string } {
    return {
      aliyunCommodityCode: 'AliyunCommodityCode',
      authType: 'AuthType',
      categoryKey: 'CategoryKey',
      categoryName: 'CategoryName',
      dataFormat: 'DataFormat',
      description: 'Description',
      deviceCount: 'DeviceCount',
      gmtCreate: 'GmtCreate',
      id2: 'Id2',
      netType: 'NetType',
      nodeType: 'NodeType',
      owner: 'Owner',
      productKey: 'ProductKey',
      productName: 'ProductName',
      productSecret: 'ProductSecret',
      productStatus: 'ProductStatus',
      protocolType: 'ProtocolType',
      validateType: 'ValidateType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunCommodityCode: 'string',
      authType: 'string',
      categoryKey: 'string',
      categoryName: 'string',
      dataFormat: 'number',
      description: 'string',
      deviceCount: 'number',
      gmtCreate: 'number',
      id2: 'boolean',
      netType: 'number',
      nodeType: 'number',
      owner: 'boolean',
      productKey: 'string',
      productName: 'string',
      productSecret: 'string',
      productStatus: 'string',
      protocolType: 'string',
      validateType: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryProductCertInfoResponseBodyProductCertInfo extends $tea.Model {
  issueModel?: number;
  static names(): { [key: string]: string } {
    return {
      issueModel: 'IssueModel',
    };
  }

  static types(): { [key: string]: any } {
    return {
      issueModel: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryProductListResponseBodyDataListProductInfo extends $tea.Model {
  authType?: string;
  dataFormat?: number;
  description?: string;
  deviceCount?: number;
  gmtCreate?: number;
  nodeType?: number;
  productKey?: string;
  productName?: string;
  static names(): { [key: string]: string } {
    return {
      authType: 'AuthType',
      dataFormat: 'DataFormat',
      description: 'Description',
      deviceCount: 'DeviceCount',
      gmtCreate: 'GmtCreate',
      nodeType: 'NodeType',
      productKey: 'ProductKey',
      productName: 'ProductName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authType: 'string',
      dataFormat: 'number',
      description: 'string',
      deviceCount: 'number',
      gmtCreate: 'number',
      nodeType: 'number',
      productKey: 'string',
      productName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryProductListResponseBodyDataList extends $tea.Model {
  productInfo?: QueryProductListResponseBodyDataListProductInfo[];
  static names(): { [key: string]: string } {
    return {
      productInfo: 'ProductInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      productInfo: { 'type': 'array', 'itemType': QueryProductListResponseBodyDataListProductInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryProductListResponseBodyData extends $tea.Model {
  currentPage?: number;
  list?: QueryProductListResponseBodyDataList;
  pageCount?: number;
  pageSize?: number;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      list: 'List',
      pageCount: 'PageCount',
      pageSize: 'PageSize',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      list: QueryProductListResponseBodyDataList,
      pageCount: 'number',
      pageSize: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryProductTopicResponseBodyDataProductTopicInfo extends $tea.Model {
  codec?: string;
  desc?: string;
  enableProxySubscribe?: boolean;
  id?: string;
  operation?: string;
  productKey?: string;
  topicShortName?: string;
  static names(): { [key: string]: string } {
    return {
      codec: 'Codec',
      desc: 'Desc',
      enableProxySubscribe: 'EnableProxySubscribe',
      id: 'Id',
      operation: 'Operation',
      productKey: 'ProductKey',
      topicShortName: 'TopicShortName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      codec: 'string',
      desc: 'string',
      enableProxySubscribe: 'boolean',
      id: 'string',
      operation: 'string',
      productKey: 'string',
      topicShortName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryProductTopicResponseBodyData extends $tea.Model {
  productTopicInfo?: QueryProductTopicResponseBodyDataProductTopicInfo[];
  static names(): { [key: string]: string } {
    return {
      productTopicInfo: 'ProductTopicInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      productTopicInfo: { 'type': 'array', 'itemType': QueryProductTopicResponseBodyDataProductTopicInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryProjectShareDeviceListResponseBodyDataDeviceListItems extends $tea.Model {
  deviceName?: string;
  iotId?: string;
  productKey?: string;
  sharable?: number;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      productKey: 'ProductKey',
      sharable: 'Sharable',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      productKey: 'string',
      sharable: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryProjectShareDeviceListResponseBodyDataDeviceList extends $tea.Model {
  items?: QueryProjectShareDeviceListResponseBodyDataDeviceListItems[];
  static names(): { [key: string]: string } {
    return {
      items: 'items',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: { 'type': 'array', 'itemType': QueryProjectShareDeviceListResponseBodyDataDeviceListItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryProjectShareDeviceListResponseBodyData extends $tea.Model {
  deviceList?: QueryProjectShareDeviceListResponseBodyDataDeviceList;
  pageId?: number;
  pageSize?: number;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      deviceList: 'DeviceList',
      pageId: 'PageId',
      pageSize: 'PageSize',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceList: QueryProjectShareDeviceListResponseBodyDataDeviceList,
      pageId: 'number',
      pageSize: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySceneRuleResponseBodyDataRuleList extends $tea.Model {
  gmtCreate?: number;
  gmtModified?: number;
  ruleDescription?: string;
  ruleId?: string;
  ruleName?: string;
  ruleStatus?: number;
  static names(): { [key: string]: string } {
    return {
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      ruleDescription: 'RuleDescription',
      ruleId: 'RuleId',
      ruleName: 'RuleName',
      ruleStatus: 'RuleStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gmtCreate: 'number',
      gmtModified: 'number',
      ruleDescription: 'string',
      ruleId: 'string',
      ruleName: 'string',
      ruleStatus: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySceneRuleResponseBodyData extends $tea.Model {
  currentPage?: number;
  pageSize?: number;
  ruleList?: QuerySceneRuleResponseBodyDataRuleList[];
  total?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      ruleList: 'RuleList',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      pageSize: 'number',
      ruleList: { 'type': 'array', 'itemType': QuerySceneRuleResponseBodyDataRuleList },
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySchedulePeriodListResponseBodyDataListItems extends $tea.Model {
  description?: string;
  endTime?: string;
  periodCode?: string;
  soundCodeContent?: string;
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      endTime: 'EndTime',
      periodCode: 'PeriodCode',
      soundCodeContent: 'SoundCodeContent',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      endTime: 'string',
      periodCode: 'string',
      soundCodeContent: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySchedulePeriodListResponseBodyDataList extends $tea.Model {
  items?: QuerySchedulePeriodListResponseBodyDataListItems[];
  static names(): { [key: string]: string } {
    return {
      items: 'Items',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: { 'type': 'array', 'itemType': QuerySchedulePeriodListResponseBodyDataListItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySchedulePeriodListResponseBodyData extends $tea.Model {
  list?: QuerySchedulePeriodListResponseBodyDataList;
  pageId?: number;
  pageSize?: number;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      list: 'List',
      pageId: 'PageId',
      pageSize: 'PageSize',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      list: QuerySchedulePeriodListResponseBodyDataList,
      pageId: 'number',
      pageSize: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryShareTaskDeviceListResponseBodyDataDeviceListItems extends $tea.Model {
  deviceName?: string;
  gmtAdded?: number;
  iotId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      gmtAdded: 'GmtAdded',
      iotId: 'IotId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      gmtAdded: 'number',
      iotId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryShareTaskDeviceListResponseBodyDataDeviceList extends $tea.Model {
  items?: QueryShareTaskDeviceListResponseBodyDataDeviceListItems[];
  static names(): { [key: string]: string } {
    return {
      items: 'items',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: { 'type': 'array', 'itemType': QueryShareTaskDeviceListResponseBodyDataDeviceListItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryShareTaskDeviceListResponseBodyData extends $tea.Model {
  deviceList?: QueryShareTaskDeviceListResponseBodyDataDeviceList;
  pageId?: number;
  pageSize?: number;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      deviceList: 'DeviceList',
      pageId: 'PageId',
      pageSize: 'PageSize',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceList: QueryShareTaskDeviceListResponseBodyDataDeviceList,
      pageId: 'number',
      pageSize: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySolutionDeviceGroupPageResponseBodyDataListItemName extends $tea.Model {
  deviceCount?: number;
  gmtCreate?: number;
  gmtModified?: number;
  groupDesc?: string;
  groupId?: string;
  groupName?: string;
  static names(): { [key: string]: string } {
    return {
      deviceCount: 'DeviceCount',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      groupDesc: 'GroupDesc',
      groupId: 'GroupId',
      groupName: 'GroupName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceCount: 'number',
      gmtCreate: 'number',
      gmtModified: 'number',
      groupDesc: 'string',
      groupId: 'string',
      groupName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySolutionDeviceGroupPageResponseBodyDataList extends $tea.Model {
  itemName?: QuerySolutionDeviceGroupPageResponseBodyDataListItemName[];
  static names(): { [key: string]: string } {
    return {
      itemName: 'itemName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      itemName: { 'type': 'array', 'itemType': QuerySolutionDeviceGroupPageResponseBodyDataListItemName },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySolutionDeviceGroupPageResponseBodyData extends $tea.Model {
  list?: QuerySolutionDeviceGroupPageResponseBodyDataList;
  pageId?: number;
  pageSize?: number;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      list: 'List',
      pageId: 'PageId',
      pageSize: 'PageSize',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      list: QuerySolutionDeviceGroupPageResponseBodyDataList,
      pageId: 'number',
      pageSize: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySoundCodeLabelBatchFailedResultResponseBodyDataItems extends $tea.Model {
  errorMessage?: string;
  label?: string;
  resultCode?: string;
  static names(): { [key: string]: string } {
    return {
      errorMessage: 'ErrorMessage',
      label: 'Label',
      resultCode: 'ResultCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorMessage: 'string',
      label: 'string',
      resultCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySoundCodeLabelBatchFailedResultResponseBodyData extends $tea.Model {
  items?: QuerySoundCodeLabelBatchFailedResultResponseBodyDataItems[];
  static names(): { [key: string]: string } {
    return {
      items: 'Items',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: { 'type': 'array', 'itemType': QuerySoundCodeLabelBatchFailedResultResponseBodyDataItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySoundCodeLabelBatchListResponseBodyDataListItems extends $tea.Model {
  batchCode?: string;
  description?: string;
  gmtCreate?: number;
  status?: string;
  successNum?: number;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      batchCode: 'BatchCode',
      description: 'Description',
      gmtCreate: 'GmtCreate',
      status: 'Status',
      successNum: 'SuccessNum',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      batchCode: 'string',
      description: 'string',
      gmtCreate: 'number',
      status: 'string',
      successNum: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySoundCodeLabelBatchListResponseBodyDataList extends $tea.Model {
  items?: QuerySoundCodeLabelBatchListResponseBodyDataListItems[];
  static names(): { [key: string]: string } {
    return {
      items: 'Items',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: { 'type': 'array', 'itemType': QuerySoundCodeLabelBatchListResponseBodyDataListItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySoundCodeLabelBatchListResponseBodyData extends $tea.Model {
  list?: QuerySoundCodeLabelBatchListResponseBodyDataList;
  pageId?: number;
  pageSize?: number;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      list: 'List',
      pageId: 'PageId',
      pageSize: 'PageSize',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      list: QuerySoundCodeLabelBatchListResponseBodyDataList,
      pageId: 'number',
      pageSize: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySoundCodeLabelListResponseBodyDataListItems extends $tea.Model {
  label?: string;
  soundCode?: string;
  static names(): { [key: string]: string } {
    return {
      label: 'Label',
      soundCode: 'SoundCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      label: 'string',
      soundCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySoundCodeLabelListResponseBodyDataList extends $tea.Model {
  items?: QuerySoundCodeLabelListResponseBodyDataListItems[];
  static names(): { [key: string]: string } {
    return {
      items: 'Items',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: { 'type': 'array', 'itemType': QuerySoundCodeLabelListResponseBodyDataListItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySoundCodeLabelListResponseBodyData extends $tea.Model {
  list?: QuerySoundCodeLabelListResponseBodyDataList;
  pageId?: number;
  pageSize?: number;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      list: 'List',
      pageId: 'PageId',
      pageSize: 'PageSize',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      list: QuerySoundCodeLabelListResponseBodyDataList,
      pageId: 'number',
      pageSize: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySoundCodeListResponseBodyDataListItems extends $tea.Model {
  duration?: number;
  gmtCreate?: number;
  name?: string;
  openType?: string;
  soundCode?: string;
  soundCodeContent?: string;
  static names(): { [key: string]: string } {
    return {
      duration: 'Duration',
      gmtCreate: 'GmtCreate',
      name: 'Name',
      openType: 'OpenType',
      soundCode: 'SoundCode',
      soundCodeContent: 'SoundCodeContent',
    };
  }

  static types(): { [key: string]: any } {
    return {
      duration: 'number',
      gmtCreate: 'number',
      name: 'string',
      openType: 'string',
      soundCode: 'string',
      soundCodeContent: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySoundCodeListResponseBodyDataList extends $tea.Model {
  items?: QuerySoundCodeListResponseBodyDataListItems[];
  static names(): { [key: string]: string } {
    return {
      items: 'Items',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: { 'type': 'array', 'itemType': QuerySoundCodeListResponseBodyDataListItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySoundCodeListResponseBodyData extends $tea.Model {
  list?: QuerySoundCodeListResponseBodyDataList;
  pageId?: number;
  pageSize?: number;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      list: 'List',
      pageId: 'PageId',
      pageSize: 'PageSize',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      list: QuerySoundCodeListResponseBodyDataList,
      pageId: 'number',
      pageSize: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySoundCodeScheduleListResponseBodyDataListItems extends $tea.Model {
  description?: string;
  endDate?: string;
  endTime?: string;
  gmtCreate?: number;
  name?: string;
  openType?: string;
  scheduleCode?: string;
  startDate?: string;
  startTime?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      endDate: 'EndDate',
      endTime: 'EndTime',
      gmtCreate: 'GmtCreate',
      name: 'Name',
      openType: 'OpenType',
      scheduleCode: 'ScheduleCode',
      startDate: 'StartDate',
      startTime: 'StartTime',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      endDate: 'string',
      endTime: 'string',
      gmtCreate: 'number',
      name: 'string',
      openType: 'string',
      scheduleCode: 'string',
      startDate: 'string',
      startTime: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySoundCodeScheduleListResponseBodyDataList extends $tea.Model {
  items?: QuerySoundCodeScheduleListResponseBodyDataListItems[];
  static names(): { [key: string]: string } {
    return {
      items: 'Items',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: { 'type': 'array', 'itemType': QuerySoundCodeScheduleListResponseBodyDataListItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySoundCodeScheduleListResponseBodyData extends $tea.Model {
  list?: QuerySoundCodeScheduleListResponseBodyDataList;
  pageId?: number;
  pageSize?: number;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      list: 'List',
      pageId: 'PageId',
      pageSize: 'PageSize',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      list: QuerySoundCodeScheduleListResponseBodyDataList,
      pageId: 'number',
      pageSize: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechResponseBodyDataSoundCodeConfig extends $tea.Model {
  additionalDuration?: number;
  soundCodeContent?: string;
  static names(): { [key: string]: string } {
    return {
      additionalDuration: 'AdditionalDuration',
      soundCodeContent: 'SoundCodeContent',
    };
  }

  static types(): { [key: string]: any } {
    return {
      additionalDuration: 'number',
      soundCodeContent: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechResponseBodyData extends $tea.Model {
  audioFormat?: string;
  bizCode?: string;
  enableSoundCode?: boolean;
  soundCodeConfig?: QuerySpeechResponseBodyDataSoundCodeConfig;
  speechCode?: string;
  speechRate?: number;
  speechType?: string;
  text?: string;
  voice?: string;
  volume?: number;
  static names(): { [key: string]: string } {
    return {
      audioFormat: 'AudioFormat',
      bizCode: 'BizCode',
      enableSoundCode: 'EnableSoundCode',
      soundCodeConfig: 'SoundCodeConfig',
      speechCode: 'SpeechCode',
      speechRate: 'SpeechRate',
      speechType: 'SpeechType',
      text: 'Text',
      voice: 'Voice',
      volume: 'Volume',
    };
  }

  static types(): { [key: string]: any } {
    return {
      audioFormat: 'string',
      bizCode: 'string',
      enableSoundCode: 'boolean',
      soundCodeConfig: QuerySpeechResponseBodyDataSoundCodeConfig,
      speechCode: 'string',
      speechRate: 'number',
      speechType: 'string',
      text: 'string',
      voice: 'string',
      volume: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechDeviceResponseBodyDataListItems extends $tea.Model {
  availableSpace?: number;
  deviceName?: string;
  iotId?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      availableSpace: 'AvailableSpace',
      deviceName: 'DeviceName',
      iotId: 'IotId',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      availableSpace: 'number',
      deviceName: 'string',
      iotId: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechDeviceResponseBodyDataList extends $tea.Model {
  items?: QuerySpeechDeviceResponseBodyDataListItems[];
  static names(): { [key: string]: string } {
    return {
      items: 'Items',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: { 'type': 'array', 'itemType': QuerySpeechDeviceResponseBodyDataListItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechDeviceResponseBodyData extends $tea.Model {
  list?: QuerySpeechDeviceResponseBodyDataList;
  pageId?: number;
  pageSize?: number;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      list: 'List',
      pageId: 'PageId',
      pageSize: 'PageSize',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      list: QuerySpeechDeviceResponseBodyDataList,
      pageId: 'number',
      pageSize: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechLicenseDeviceListResponseBodyDataDeviceListItem extends $tea.Model {
  deviceName?: string;
  deviceStatus?: string;
  expiryTime?: number;
  inSpecifiedGroup?: boolean;
  iotId?: string;
  licenseStatus?: string;
  productKey?: string;
  productName?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      deviceStatus: 'DeviceStatus',
      expiryTime: 'ExpiryTime',
      inSpecifiedGroup: 'InSpecifiedGroup',
      iotId: 'IotId',
      licenseStatus: 'LicenseStatus',
      productKey: 'ProductKey',
      productName: 'ProductName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      deviceStatus: 'string',
      expiryTime: 'number',
      inSpecifiedGroup: 'boolean',
      iotId: 'string',
      licenseStatus: 'string',
      productKey: 'string',
      productName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechLicenseDeviceListResponseBodyDataDeviceList extends $tea.Model {
  item?: QuerySpeechLicenseDeviceListResponseBodyDataDeviceListItem[];
  static names(): { [key: string]: string } {
    return {
      item: 'item',
    };
  }

  static types(): { [key: string]: any } {
    return {
      item: { 'type': 'array', 'itemType': QuerySpeechLicenseDeviceListResponseBodyDataDeviceListItem },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechLicenseDeviceListResponseBodyData extends $tea.Model {
  deviceList?: QuerySpeechLicenseDeviceListResponseBodyDataDeviceList;
  pageId?: number;
  pageSize?: number;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      deviceList: 'DeviceList',
      pageId: 'PageId',
      pageSize: 'PageSize',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceList: QuerySpeechLicenseDeviceListResponseBodyDataDeviceList,
      pageId: 'number',
      pageSize: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechListResponseBodyDataListItemsSpeechListItems extends $tea.Model {
  bizCode?: string;
  speechCode?: string;
  text?: string;
  voice?: string;
  static names(): { [key: string]: string } {
    return {
      bizCode: 'BizCode',
      speechCode: 'SpeechCode',
      text: 'Text',
      voice: 'Voice',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizCode: 'string',
      speechCode: 'string',
      text: 'string',
      voice: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechListResponseBodyDataListItemsSpeechList extends $tea.Model {
  items?: QuerySpeechListResponseBodyDataListItemsSpeechListItems[];
  static names(): { [key: string]: string } {
    return {
      items: 'Items',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: { 'type': 'array', 'itemType': QuerySpeechListResponseBodyDataListItemsSpeechListItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechListResponseBodyDataListItems extends $tea.Model {
  audioFormat?: string;
  bizCode?: string;
  speechCode?: string;
  speechList?: QuerySpeechListResponseBodyDataListItemsSpeechList;
  speechType?: string;
  text?: string;
  voice?: string;
  static names(): { [key: string]: string } {
    return {
      audioFormat: 'AudioFormat',
      bizCode: 'BizCode',
      speechCode: 'SpeechCode',
      speechList: 'SpeechList',
      speechType: 'SpeechType',
      text: 'Text',
      voice: 'Voice',
    };
  }

  static types(): { [key: string]: any } {
    return {
      audioFormat: 'string',
      bizCode: 'string',
      speechCode: 'string',
      speechList: QuerySpeechListResponseBodyDataListItemsSpeechList,
      speechType: 'string',
      text: 'string',
      voice: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechListResponseBodyDataList extends $tea.Model {
  items?: QuerySpeechListResponseBodyDataListItems[];
  static names(): { [key: string]: string } {
    return {
      items: 'Items',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: { 'type': 'array', 'itemType': QuerySpeechListResponseBodyDataListItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechListResponseBodyData extends $tea.Model {
  list?: QuerySpeechListResponseBodyDataList;
  pageId?: number;
  pageSize?: number;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      list: 'List',
      pageId: 'PageId',
      pageSize: 'PageSize',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      list: QuerySpeechListResponseBodyDataList,
      pageId: 'number',
      pageSize: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechPushJobResponseBodyDataListItems extends $tea.Model {
  code?: string;
  createdTime?: number;
  deviceName?: string;
  expiredTime?: number;
  failDeviceNum?: number;
  groupId?: string;
  groupName?: string;
  iotId?: string;
  productKey?: string;
  pushMode?: string;
  runningDeviceNum?: number;
  speechNum?: number;
  speechStatus?: boolean;
  status?: string;
  successDeviceNum?: number;
  totalDeviceNum?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      createdTime: 'CreatedTime',
      deviceName: 'DeviceName',
      expiredTime: 'ExpiredTime',
      failDeviceNum: 'FailDeviceNum',
      groupId: 'GroupId',
      groupName: 'GroupName',
      iotId: 'IotId',
      productKey: 'ProductKey',
      pushMode: 'PushMode',
      runningDeviceNum: 'RunningDeviceNum',
      speechNum: 'SpeechNum',
      speechStatus: 'SpeechStatus',
      status: 'Status',
      successDeviceNum: 'SuccessDeviceNum',
      totalDeviceNum: 'TotalDeviceNum',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      createdTime: 'number',
      deviceName: 'string',
      expiredTime: 'number',
      failDeviceNum: 'number',
      groupId: 'string',
      groupName: 'string',
      iotId: 'string',
      productKey: 'string',
      pushMode: 'string',
      runningDeviceNum: 'number',
      speechNum: 'number',
      speechStatus: 'boolean',
      status: 'string',
      successDeviceNum: 'number',
      totalDeviceNum: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechPushJobResponseBodyDataList extends $tea.Model {
  items?: QuerySpeechPushJobResponseBodyDataListItems[];
  static names(): { [key: string]: string } {
    return {
      items: 'Items',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: { 'type': 'array', 'itemType': QuerySpeechPushJobResponseBodyDataListItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechPushJobResponseBodyData extends $tea.Model {
  list?: QuerySpeechPushJobResponseBodyDataList;
  pageId?: number;
  pageSize?: number;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      list: 'List',
      pageId: 'PageId',
      pageSize: 'PageSize',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      list: QuerySpeechPushJobResponseBodyDataList,
      pageId: 'number',
      pageSize: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechPushJobDeviceResponseBodyDataListItems extends $tea.Model {
  deviceName?: string;
  errorCode?: string;
  errorMessage?: string;
  gmtModified?: number;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      gmtModified: 'GmtModified',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      errorCode: 'string',
      errorMessage: 'string',
      gmtModified: 'number',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechPushJobDeviceResponseBodyDataList extends $tea.Model {
  items?: QuerySpeechPushJobDeviceResponseBodyDataListItems[];
  static names(): { [key: string]: string } {
    return {
      items: 'Items',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: { 'type': 'array', 'itemType': QuerySpeechPushJobDeviceResponseBodyDataListItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechPushJobDeviceResponseBodyData extends $tea.Model {
  list?: QuerySpeechPushJobDeviceResponseBodyDataList;
  pageId?: number;
  pageSize?: number;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      list: 'List',
      pageId: 'PageId',
      pageSize: 'PageSize',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      list: QuerySpeechPushJobDeviceResponseBodyDataList,
      pageId: 'number',
      pageSize: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechPushJobSpeechResponseBodyDataListItemsSpeechListItems extends $tea.Model {
  bizCode?: string;
  text?: string;
  voice?: string;
  static names(): { [key: string]: string } {
    return {
      bizCode: 'BizCode',
      text: 'Text',
      voice: 'Voice',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizCode: 'string',
      text: 'string',
      voice: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechPushJobSpeechResponseBodyDataListItemsSpeechList extends $tea.Model {
  items?: QuerySpeechPushJobSpeechResponseBodyDataListItemsSpeechListItems[];
  static names(): { [key: string]: string } {
    return {
      items: 'Items',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: { 'type': 'array', 'itemType': QuerySpeechPushJobSpeechResponseBodyDataListItemsSpeechListItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechPushJobSpeechResponseBodyDataListItems extends $tea.Model {
  bizCode?: string;
  speechList?: QuerySpeechPushJobSpeechResponseBodyDataListItemsSpeechList;
  speechType?: string;
  text?: string;
  voice?: string;
  static names(): { [key: string]: string } {
    return {
      bizCode: 'BizCode',
      speechList: 'SpeechList',
      speechType: 'SpeechType',
      text: 'Text',
      voice: 'Voice',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizCode: 'string',
      speechList: QuerySpeechPushJobSpeechResponseBodyDataListItemsSpeechList,
      speechType: 'string',
      text: 'string',
      voice: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechPushJobSpeechResponseBodyDataList extends $tea.Model {
  items?: QuerySpeechPushJobSpeechResponseBodyDataListItems[];
  static names(): { [key: string]: string } {
    return {
      items: 'Items',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: { 'type': 'array', 'itemType': QuerySpeechPushJobSpeechResponseBodyDataListItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySpeechPushJobSpeechResponseBodyData extends $tea.Model {
  list?: QuerySpeechPushJobSpeechResponseBodyDataList;
  pageId?: number;
  pageSize?: number;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      list: 'List',
      pageId: 'PageId',
      pageSize: 'PageSize',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      list: QuerySpeechPushJobSpeechResponseBodyDataList,
      pageId: 'number',
      pageSize: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryStudioAppDomainListOpenResponseBodyDataListDomainInfo extends $tea.Model {
  appId?: string;
  gmtCreate?: string;
  gmtModified?: string;
  host?: string;
  id?: number;
  isBeian?: string;
  projectId?: string;
  protocol?: string;
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      host: 'Host',
      id: 'Id',
      isBeian: 'IsBeian',
      projectId: 'ProjectId',
      protocol: 'Protocol',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      host: 'string',
      id: 'number',
      isBeian: 'string',
      projectId: 'string',
      protocol: 'string',
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryStudioAppDomainListOpenResponseBodyDataList extends $tea.Model {
  domainInfo?: QueryStudioAppDomainListOpenResponseBodyDataListDomainInfo[];
  static names(): { [key: string]: string } {
    return {
      domainInfo: 'DomainInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainInfo: { 'type': 'array', 'itemType': QueryStudioAppDomainListOpenResponseBodyDataListDomainInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryStudioAppDomainListOpenResponseBodyData extends $tea.Model {
  list?: QueryStudioAppDomainListOpenResponseBodyDataList;
  pageNo?: number;
  pageSize?: number;
  total?: number;
  totalPage?: number;
  static names(): { [key: string]: string } {
    return {
      list: 'List',
      pageNo: 'PageNo',
      pageSize: 'PageSize',
      total: 'Total',
      totalPage: 'TotalPage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      list: QueryStudioAppDomainListOpenResponseBodyDataList,
      pageNo: 'number',
      pageSize: 'number',
      total: 'number',
      totalPage: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryStudioAppListResponseBodyDataListAppInfo extends $tea.Model {
  appId?: string;
  appKey?: string;
  appSecret?: string;
  description?: string;
  gmtCreate?: string;
  gmtModified?: string;
  gmtRelease?: string;
  name?: string;
  projectId?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      appKey: 'AppKey',
      appSecret: 'AppSecret',
      description: 'Description',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      gmtRelease: 'GmtRelease',
      name: 'Name',
      projectId: 'ProjectId',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      appKey: 'string',
      appSecret: 'string',
      description: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      gmtRelease: 'string',
      name: 'string',
      projectId: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryStudioAppListResponseBodyDataList extends $tea.Model {
  appInfo?: QueryStudioAppListResponseBodyDataListAppInfo[];
  static names(): { [key: string]: string } {
    return {
      appInfo: 'AppInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appInfo: { 'type': 'array', 'itemType': QueryStudioAppListResponseBodyDataListAppInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryStudioAppListResponseBodyData extends $tea.Model {
  list?: QueryStudioAppListResponseBodyDataList;
  pageNo?: number;
  pageSize?: number;
  total?: number;
  totalPage?: number;
  static names(): { [key: string]: string } {
    return {
      list: 'List',
      pageNo: 'PageNo',
      pageSize: 'PageSize',
      total: 'Total',
      totalPage: 'TotalPage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      list: QueryStudioAppListResponseBodyDataList,
      pageNo: 'number',
      pageSize: 'number',
      total: 'number',
      totalPage: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryStudioAppPageListOpenResponseBodyDataListPageInfo extends $tea.Model {
  gmtCreate?: string;
  gmtModified?: string;
  id?: number;
  isHidden?: number;
  isHome?: number;
  isLoginPage?: number;
  name?: string;
  pageId?: string;
  path?: string;
  static names(): { [key: string]: string } {
    return {
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      id: 'Id',
      isHidden: 'IsHidden',
      isHome: 'IsHome',
      isLoginPage: 'IsLoginPage',
      name: 'Name',
      pageId: 'PageId',
      path: 'Path',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gmtCreate: 'string',
      gmtModified: 'string',
      id: 'number',
      isHidden: 'number',
      isHome: 'number',
      isLoginPage: 'number',
      name: 'string',
      pageId: 'string',
      path: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryStudioAppPageListOpenResponseBodyDataList extends $tea.Model {
  pageInfo?: QueryStudioAppPageListOpenResponseBodyDataListPageInfo[];
  static names(): { [key: string]: string } {
    return {
      pageInfo: 'PageInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageInfo: { 'type': 'array', 'itemType': QueryStudioAppPageListOpenResponseBodyDataListPageInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryStudioAppPageListOpenResponseBodyData extends $tea.Model {
  list?: QueryStudioAppPageListOpenResponseBodyDataList;
  pageNo?: number;
  pageSize?: number;
  total?: number;
  totalPage?: number;
  static names(): { [key: string]: string } {
    return {
      list: 'List',
      pageNo: 'PageNo',
      pageSize: 'PageSize',
      total: 'Total',
      totalPage: 'TotalPage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      list: QueryStudioAppPageListOpenResponseBodyDataList,
      pageNo: 'number',
      pageSize: 'number',
      total: 'number',
      totalPage: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryStudioProjectListResponseBodyDataListProjectInfo extends $tea.Model {
  description?: string;
  gmtCreate?: number;
  gmtModified?: number;
  name?: string;
  projectId?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      name: 'Name',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      gmtCreate: 'number',
      gmtModified: 'number',
      name: 'string',
      projectId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryStudioProjectListResponseBodyDataList extends $tea.Model {
  projectInfo?: QueryStudioProjectListResponseBodyDataListProjectInfo[];
  static names(): { [key: string]: string } {
    return {
      projectInfo: 'ProjectInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      projectInfo: { 'type': 'array', 'itemType': QueryStudioProjectListResponseBodyDataListProjectInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryStudioProjectListResponseBodyData extends $tea.Model {
  list?: QueryStudioProjectListResponseBodyDataList;
  pageNo?: number;
  pageSize?: number;
  total?: number;
  totalPage?: number;
  static names(): { [key: string]: string } {
    return {
      list: 'List',
      pageNo: 'PageNo',
      pageSize: 'PageSize',
      total: 'Total',
      totalPage: 'TotalPage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      list: QueryStudioProjectListResponseBodyDataList,
      pageNo: 'number',
      pageSize: 'number',
      total: 'number',
      totalPage: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySummarySceneRuleLogResponseBodyDataLogListLogInfo extends $tea.Model {
  logTime?: number;
  result?: string;
  traceId?: string;
  static names(): { [key: string]: string } {
    return {
      logTime: 'LogTime',
      result: 'Result',
      traceId: 'TraceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      logTime: 'number',
      result: 'string',
      traceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySummarySceneRuleLogResponseBodyDataLogList extends $tea.Model {
  logInfo?: QuerySummarySceneRuleLogResponseBodyDataLogListLogInfo[];
  static names(): { [key: string]: string } {
    return {
      logInfo: 'LogInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      logInfo: { 'type': 'array', 'itemType': QuerySummarySceneRuleLogResponseBodyDataLogListLogInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySummarySceneRuleLogResponseBodyData extends $tea.Model {
  currentPage?: number;
  logList?: QuerySummarySceneRuleLogResponseBodyDataLogList;
  pageSize?: number;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      logList: 'LogList',
      pageSize: 'PageSize',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      logList: QuerySummarySceneRuleLogResponseBodyDataLogList,
      pageSize: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySuperDeviceGroupResponseBodyDataGroupInfo extends $tea.Model {
  groupDesc?: string;
  groupId?: string;
  groupName?: string;
  static names(): { [key: string]: string } {
    return {
      groupDesc: 'GroupDesc',
      groupId: 'GroupId',
      groupName: 'GroupName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupDesc: 'string',
      groupId: 'string',
      groupName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySuperDeviceGroupResponseBodyData extends $tea.Model {
  groupInfo?: QuerySuperDeviceGroupResponseBodyDataGroupInfo[];
  static names(): { [key: string]: string } {
    return {
      groupInfo: 'GroupInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupInfo: { 'type': 'array', 'itemType': QuerySuperDeviceGroupResponseBodyDataGroupInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTaskResponseBodyData extends $tea.Model {
  deviceName?: string;
  iotId?: string;
  jobId?: string;
  jobName?: string;
  message?: string;
  productKey?: string;
  progress?: string;
  status?: string;
  statusDetail?: string;
  taskId?: string;
  utcModified?: string;
  utcQueueTime?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      iotId: 'IotId',
      jobId: 'JobId',
      jobName: 'JobName',
      message: 'Message',
      productKey: 'ProductKey',
      progress: 'Progress',
      status: 'Status',
      statusDetail: 'StatusDetail',
      taskId: 'TaskId',
      utcModified: 'UtcModified',
      utcQueueTime: 'UtcQueueTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      iotId: 'string',
      jobId: 'string',
      jobName: 'string',
      message: 'string',
      productKey: 'string',
      progress: 'string',
      status: 'string',
      statusDetail: 'string',
      taskId: 'string',
      utcModified: 'string',
      utcQueueTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryThingModelResponseBodyData extends $tea.Model {
  thingModelJson?: string;
  static names(): { [key: string]: string } {
    return {
      thingModelJson: 'ThingModelJson',
    };
  }

  static types(): { [key: string]: any } {
    return {
      thingModelJson: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryThingModelExtendConfigResponseBodyData extends $tea.Model {
  configuration?: string;
  static names(): { [key: string]: string } {
    return {
      configuration: 'Configuration',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configuration: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryThingModelExtendConfigPublishedResponseBodyData extends $tea.Model {
  configuration?: string;
  static names(): { [key: string]: string } {
    return {
      configuration: 'Configuration',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configuration: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryThingModelPublishedResponseBodyData extends $tea.Model {
  thingModelJson?: string;
  static names(): { [key: string]: string } {
    return {
      thingModelJson: 'ThingModelJson',
    };
  }

  static types(): { [key: string]: any } {
    return {
      thingModelJson: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTopicConfigResponseBodyDataTopicConfigInfo extends $tea.Model {
  codec?: string;
  description?: string;
  enableBroadcast?: boolean;
  enableProxySubscribe?: boolean;
  operation?: string;
  productKey?: string;
  topicFullName?: string;
  static names(): { [key: string]: string } {
    return {
      codec: 'Codec',
      description: 'Description',
      enableBroadcast: 'EnableBroadcast',
      enableProxySubscribe: 'EnableProxySubscribe',
      operation: 'Operation',
      productKey: 'ProductKey',
      topicFullName: 'TopicFullName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      codec: 'string',
      description: 'string',
      enableBroadcast: 'boolean',
      enableProxySubscribe: 'boolean',
      operation: 'string',
      productKey: 'string',
      topicFullName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTopicConfigResponseBodyData extends $tea.Model {
  topicConfigInfo?: QueryTopicConfigResponseBodyDataTopicConfigInfo[];
  static names(): { [key: string]: string } {
    return {
      topicConfigInfo: 'TopicConfigInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      topicConfigInfo: { 'type': 'array', 'itemType': QueryTopicConfigResponseBodyDataTopicConfigInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTopicReverseRouteTableResponseBodySrcTopics extends $tea.Model {
  topic?: { [key: string]: any }[];
  static names(): { [key: string]: string } {
    return {
      topic: 'Topic',
    };
  }

  static types(): { [key: string]: any } {
    return {
      topic: { 'type': 'array', 'itemType': { 'type': 'map', 'keyType': 'string', 'valueType': 'any' } },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTopicRouteTableResponseBodyDstTopics extends $tea.Model {
  topic?: { [key: string]: any }[];
  static names(): { [key: string]: string } {
    return {
      topic: 'Topic',
    };
  }

  static types(): { [key: string]: any } {
    return {
      topic: { 'type': 'array', 'itemType': { 'type': 'map', 'keyType': 'string', 'valueType': 'any' } },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryVehicleDeviceResponseBodyDataJtProtocolDeviceData extends $tea.Model {
  authCode?: string;
  city?: string;
  deviceId?: string;
  deviceModel?: string;
  manufacturer?: string;
  province?: string;
  registerTime?: string;
  status?: string;
  vehicleColour?: string;
  vehicleNumber?: string;
  static names(): { [key: string]: string } {
    return {
      authCode: 'AuthCode',
      city: 'City',
      deviceId: 'DeviceId',
      deviceModel: 'DeviceModel',
      manufacturer: 'Manufacturer',
      province: 'Province',
      registerTime: 'RegisterTime',
      status: 'Status',
      vehicleColour: 'VehicleColour',
      vehicleNumber: 'VehicleNumber',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authCode: 'string',
      city: 'string',
      deviceId: 'string',
      deviceModel: 'string',
      manufacturer: 'string',
      province: 'string',
      registerTime: 'string',
      status: 'string',
      vehicleColour: 'string',
      vehicleNumber: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryVehicleDeviceResponseBodyData extends $tea.Model {
  createTime?: number;
  deviceName?: string;
  iotId?: string;
  jtProtocolDeviceData?: QueryVehicleDeviceResponseBodyDataJtProtocolDeviceData;
  modifiedTime?: number;
  productKey?: string;
  protocol?: string;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      deviceName: 'DeviceName',
      iotId: 'IotId',
      jtProtocolDeviceData: 'JtProtocolDeviceData',
      modifiedTime: 'ModifiedTime',
      productKey: 'ProductKey',
      protocol: 'Protocol',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'number',
      deviceName: 'string',
      iotId: 'string',
      jtProtocolDeviceData: QueryVehicleDeviceResponseBodyDataJtProtocolDeviceData,
      modifiedTime: 'number',
      productKey: 'string',
      protocol: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReBindLicenseDeviceResponseBodyData extends $tea.Model {
  checkProgressId?: string;
  failSum?: number;
  progress?: number;
  resultCsvFile?: string;
  successSum?: number;
  static names(): { [key: string]: string } {
    return {
      checkProgressId: 'CheckProgressId',
      failSum: 'FailSum',
      progress: 'Progress',
      resultCsvFile: 'ResultCsvFile',
      successSum: 'SuccessSum',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkProgressId: 'string',
      failSum: 'number',
      progress: 'number',
      resultCsvFile: 'string',
      successSum: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RefreshStudioAppTokenOpenResponseBodyData extends $tea.Model {
  bizId?: string;
  bizType?: string;
  isEnable?: string;
  token?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      bizId: 'BizId',
      bizType: 'BizType',
      isEnable: 'IsEnable',
      token: 'Token',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizId: 'string',
      bizType: 'string',
      isEnable: 'string',
      token: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RegisterDeviceResponseBodyData extends $tea.Model {
  devEui?: string;
  deviceName?: string;
  deviceSecret?: string;
  iotId?: string;
  joinEui?: string;
  nickname?: string;
  productKey?: string;
  static names(): { [key: string]: string } {
    return {
      devEui: 'DevEui',
      deviceName: 'DeviceName',
      deviceSecret: 'DeviceSecret',
      iotId: 'IotId',
      joinEui: 'JoinEui',
      nickname: 'Nickname',
      productKey: 'ProductKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      devEui: 'string',
      deviceName: 'string',
      deviceSecret: 'string',
      iotId: 'string',
      joinEui: 'string',
      nickname: 'string',
      productKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDeviceDesiredPropertyResponseBodyData extends $tea.Model {
  messageId?: string;
  versions?: string;
  static names(): { [key: string]: string } {
    return {
      messageId: 'MessageId',
      versions: 'Versions',
    };
  }

  static types(): { [key: string]: any } {
    return {
      messageId: 'string',
      versions: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDevicePropertyResponseBodyData extends $tea.Model {
  messageId?: string;
  static names(): { [key: string]: string } {
    return {
      messageId: 'MessageId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      messageId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetEdgeInstanceDriverConfigsRequestConfigs extends $tea.Model {
  content?: string;
  format?: string;
  key?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      format: 'Format',
      key: 'Key',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      format: 'string',
      key: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetupStudioAppAuthModeOpenResponseBodyDataTokenInfo extends $tea.Model {
  bizId?: string;
  bizType?: string;
  isEnable?: string;
  token?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      bizId: 'BizId',
      bizType: 'BizType',
      isEnable: 'IsEnable',
      token: 'Token',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizId: 'string',
      bizType: 'string',
      isEnable: 'string',
      token: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetupStudioAppAuthModeOpenResponseBodyData extends $tea.Model {
  authMode?: number;
  tokenInfo?: SetupStudioAppAuthModeOpenResponseBodyDataTokenInfo;
  static names(): { [key: string]: string } {
    return {
      authMode: 'AuthMode',
      tokenInfo: 'TokenInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authMode: 'number',
      tokenInfo: SetupStudioAppAuthModeOpenResponseBodyDataTokenInfo,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SyncSpeechByCombinationResponseBodyData extends $tea.Model {
  detail?: string;
  deviceErrorCode?: string;
  deviceErrorMessage?: string;
  id?: string;
  maxRetryCount?: number;
  retryCount?: number;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      detail: 'Detail',
      deviceErrorCode: 'DeviceErrorCode',
      deviceErrorMessage: 'DeviceErrorMessage',
      id: 'Id',
      maxRetryCount: 'MaxRetryCount',
      retryCount: 'RetryCount',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      detail: 'string',
      deviceErrorCode: 'string',
      deviceErrorMessage: 'string',
      id: 'string',
      maxRetryCount: 'number',
      retryCount: 'number',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TestSpeechResponseBodyData extends $tea.Model {
  items?: string[];
  static names(): { [key: string]: string } {
    return {
      items: 'items',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateEdgeInstanceChannelRequestConfigs extends $tea.Model {
  content?: string;
  format?: string;
  key?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      format: 'Format',
      key: 'Key',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      format: 'string',
      key: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProductTagsRequestProductTag extends $tea.Model {
  tagKey?: string;
  tagValue?: string;
  static names(): { [key: string]: string } {
    return {
      tagKey: 'TagKey',
      tagValue: 'TagValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagKey: 'string',
      tagValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProductTagsResponseBodyInvalidProductTagsProductTag extends $tea.Model {
  tagKey?: string;
  tagValue?: string;
  static names(): { [key: string]: string } {
    return {
      tagKey: 'TagKey',
      tagValue: 'TagValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagKey: 'string',
      tagValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProductTagsResponseBodyInvalidProductTags extends $tea.Model {
  productTag?: UpdateProductTagsResponseBodyInvalidProductTagsProductTag[];
  static names(): { [key: string]: string } {
    return {
      productTag: 'ProductTag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      productTag: { 'type': 'array', 'itemType': UpdateProductTagsResponseBodyInvalidProductTagsProductTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}


export default class Client extends OpenApi {

  constructor(config: $OpenApi.Config) {
    super(config);
    this._endpointRule = "regional";
    this._endpointMap = {
      'ap-northeast-2-pop': "iot.aliyuncs.com",
      'ap-south-1': "iot.aliyuncs.com",
      'ap-southeast-2': "iot.aliyuncs.com",
      'ap-southeast-3': "iot.aliyuncs.com",
      'ap-southeast-5': "iot.aliyuncs.com",
      'cn-beijing-finance-1': "iot.aliyuncs.com",
      'cn-beijing-finance-pop': "iot.aliyuncs.com",
      'cn-beijing-gov-1': "iot.aliyuncs.com",
      'cn-beijing-nu16-b01': "iot.aliyuncs.com",
      'cn-chengdu': "iot.aliyuncs.com",
      'cn-edge-1': "iot.aliyuncs.com",
      'cn-fujian': "iot.aliyuncs.com",
      'cn-haidian-cm12-c01': "iot.aliyuncs.com",
      'cn-hangzhou-bj-b01': "iot.aliyuncs.com",
      'cn-hangzhou-finance': "iot.aliyuncs.com",
      'cn-hangzhou-internal-prod-1': "iot.aliyuncs.com",
      'cn-hangzhou-internal-test-1': "iot.aliyuncs.com",
      'cn-hangzhou-internal-test-2': "iot.aliyuncs.com",
      'cn-hangzhou-internal-test-3': "iot.aliyuncs.com",
      'cn-hangzhou-test-306': "iot.aliyuncs.com",
      'cn-hongkong': "iot.aliyuncs.com",
      'cn-hongkong-finance-pop': "iot.aliyuncs.com",
      'cn-huhehaote': "iot.aliyuncs.com",
      'cn-huhehaote-nebula-1': "iot.aliyuncs.com",
      'cn-qingdao': "iot.aliyuncs.com",
      'cn-qingdao-nebula': "iot.aliyuncs.com",
      'cn-shanghai-et15-b01': "iot.aliyuncs.com",
      'cn-shanghai-et2-b01': "iot.aliyuncs.com",
      'cn-shanghai-finance-1': "iot.aliyuncs.com",
      'cn-shanghai-inner': "iot.aliyuncs.com",
      'cn-shanghai-internal-test-1': "iot.aliyuncs.com",
      'cn-shenzhen-finance-1': "iot.aliyuncs.com",
      'cn-shenzhen-inner': "iot.aliyuncs.com",
      'cn-shenzhen-st4-d01': "iot.aliyuncs.com",
      'cn-shenzhen-su18-b01': "iot.aliyuncs.com",
      'cn-wuhan': "iot.aliyuncs.com",
      'cn-wulanchabu': "iot.aliyuncs.com",
      'cn-yushanfang': "iot.aliyuncs.com",
      'cn-zhangbei': "iot.aliyuncs.com",
      'cn-zhangbei-na61-b01': "iot.aliyuncs.com",
      'cn-zhangjiakou': "iot.aliyuncs.com",
      'cn-zhangjiakou-na62-a01': "iot.aliyuncs.com",
      'cn-zhengzhou-nebula-1': "iot.aliyuncs.com",
      'eu-west-1': "iot.aliyuncs.com",
      'eu-west-1-oxs': "iot.aliyuncs.com",
      'me-east-1': "iot.aliyuncs.com",
      'rus-west-1-pop': "iot.aliyuncs.com",
    };
    this.checkConfig(config);
    this._endpoint = this.getEndpoint("iot", this._regionId, this._endpointRule, this._network, this._suffix, this._endpointMap, this._endpoint);
  }


  getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: {[key: string ]: string}, endpoint: string): string {
    if (!Util.empty(endpoint)) {
      return endpoint;
    }

    if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
      return endpointMap[regionId];
    }

    return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
  }

  async addDataForApiSourceWithOptions(request: AddDataForApiSourceRequest, runtime: $Util.RuntimeOptions): Promise<AddDataForApiSourceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.apiId)) {
      query["ApiId"] = request.apiId;
    }

    if (!Util.isUnset(request.content)) {
      query["Content"] = request.content;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddDataForApiSource",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddDataForApiSourceResponse>(await this.callApi(params, req, runtime), new AddDataForApiSourceResponse({}));
  }

  async addDataForApiSource(request: AddDataForApiSourceRequest): Promise<AddDataForApiSourceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addDataForApiSourceWithOptions(request, runtime);
  }

  async addShareTaskDeviceWithOptions(request: AddShareTaskDeviceRequest, runtime: $Util.RuntimeOptions): Promise<AddShareTaskDeviceResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.iotIdList)) {
      body["IotIdList"] = request.iotIdList;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      body["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      body["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.shareTaskId)) {
      body["ShareTaskId"] = request.shareTaskId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "AddShareTaskDevice",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddShareTaskDeviceResponse>(await this.callApi(params, req, runtime), new AddShareTaskDeviceResponse({}));
  }

  async addShareTaskDevice(request: AddShareTaskDeviceRequest): Promise<AddShareTaskDeviceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addShareTaskDeviceWithOptions(request, runtime);
  }

  async asyncRRpcWithOptions(request: AsyncRRpcRequest, runtime: $Util.RuntimeOptions): Promise<AsyncRRpcResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.extInfo)) {
      query["ExtInfo"] = request.extInfo;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.topicFullName)) {
      query["TopicFullName"] = request.topicFullName;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.messageContent)) {
      body["MessageContent"] = request.messageContent;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "AsyncRRpc",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AsyncRRpcResponse>(await this.callApi(params, req, runtime), new AsyncRRpcResponse({}));
  }

  async asyncRRpc(request: AsyncRRpcRequest): Promise<AsyncRRpcResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.asyncRRpcWithOptions(request, runtime);
  }

  async attachDestinationWithOptions(request: AttachDestinationRequest, runtime: $Util.RuntimeOptions): Promise<AttachDestinationResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.destinationId)) {
      query["DestinationId"] = request.destinationId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.isFailover)) {
      query["IsFailover"] = request.isFailover;
    }

    if (!Util.isUnset(request.parserId)) {
      query["ParserId"] = request.parserId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AttachDestination",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AttachDestinationResponse>(await this.callApi(params, req, runtime), new AttachDestinationResponse({}));
  }

  async attachDestination(request: AttachDestinationRequest): Promise<AttachDestinationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.attachDestinationWithOptions(request, runtime);
  }

  async attachParserDataSourceWithOptions(request: AttachParserDataSourceRequest, runtime: $Util.RuntimeOptions): Promise<AttachParserDataSourceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dataSourceId)) {
      query["DataSourceId"] = request.dataSourceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.parserId)) {
      query["ParserId"] = request.parserId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AttachParserDataSource",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AttachParserDataSourceResponse>(await this.callApi(params, req, runtime), new AttachParserDataSourceResponse({}));
  }

  async attachParserDataSource(request: AttachParserDataSourceRequest): Promise<AttachParserDataSourceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.attachParserDataSourceWithOptions(request, runtime);
  }

  async batchAddDataForApiSourceWithOptions(tmpReq: BatchAddDataForApiSourceRequest, runtime: $Util.RuntimeOptions): Promise<BatchAddDataForApiSourceResponse> {
    Util.validateModel(tmpReq);
    let request = new BatchAddDataForApiSourceShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.contentList)) {
      request.contentListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.contentList, "ContentList", "json");
    }

    let query = { };
    if (!Util.isUnset(request.apiId)) {
      query["ApiId"] = request.apiId;
    }

    if (!Util.isUnset(request.contentListShrink)) {
      query["ContentList"] = request.contentListShrink;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BatchAddDataForApiSource",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchAddDataForApiSourceResponse>(await this.callApi(params, req, runtime), new BatchAddDataForApiSourceResponse({}));
  }

  async batchAddDataForApiSource(request: BatchAddDataForApiSourceRequest): Promise<BatchAddDataForApiSourceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchAddDataForApiSourceWithOptions(request, runtime);
  }

  /**
    * In addition to the preceding operation-specific request parameters, you must specify common request parameters when you call this operation. For more information, see [Common request parameters](~~30561~~).
    *
    * @param request BatchAddDeviceGroupRelationsRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return BatchAddDeviceGroupRelationsResponse
   */
  async batchAddDeviceGroupRelationsWithOptions(request: BatchAddDeviceGroupRelationsRequest, runtime: $Util.RuntimeOptions): Promise<BatchAddDeviceGroupRelationsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.device)) {
      query["Device"] = request.device;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BatchAddDeviceGroupRelations",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchAddDeviceGroupRelationsResponse>(await this.callApi(params, req, runtime), new BatchAddDeviceGroupRelationsResponse({}));
  }

  /**
    * In addition to the preceding operation-specific request parameters, you must specify common request parameters when you call this operation. For more information, see [Common request parameters](~~30561~~).
    *
    * @param request BatchAddDeviceGroupRelationsRequest
    * @return BatchAddDeviceGroupRelationsResponse
   */
  async batchAddDeviceGroupRelations(request: BatchAddDeviceGroupRelationsRequest): Promise<BatchAddDeviceGroupRelationsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchAddDeviceGroupRelationsWithOptions(request, runtime);
  }

  /**
    * *   You can attach up to 10 sub-devices to a gateway in a single call.
    * *   The API operation caller must be the gateway owner.
    * *   If you specify a sub-device that is already attached to a gateway, the original gateway is replaced with the specified gateway.
    * *   If one of the specified sub-devices fails to establish a topological relationship with the gateway, the system rolls back, and all specified sub-devices fail to establish topological relationships with the gateway.
    * *   After you call this operation to establish topological relationships between sub-devices and the gateway, IoT Platform uses the `/sys/${productKey}/${deviceName}/thing/topo/change` topic to push information that includes the result of this operation to the gateway. For more information, see [Notify gateways of changes of topological relationships](~~89299~~).
    * ## QPS limits
    * You can call this API operation up to 10 times per second per Alibaba Cloud account. 
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request BatchAddThingTopoRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return BatchAddThingTopoResponse
   */
  async batchAddThingTopoWithOptions(request: BatchAddThingTopoRequest, runtime: $Util.RuntimeOptions): Promise<BatchAddThingTopoResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.gwDeviceName)) {
      query["GwDeviceName"] = request.gwDeviceName;
    }

    if (!Util.isUnset(request.gwProductKey)) {
      query["GwProductKey"] = request.gwProductKey;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.topoAddItem)) {
      query["TopoAddItem"] = request.topoAddItem;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BatchAddThingTopo",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchAddThingTopoResponse>(await this.callApi(params, req, runtime), new BatchAddThingTopoResponse({}));
  }

  /**
    * *   You can attach up to 10 sub-devices to a gateway in a single call.
    * *   The API operation caller must be the gateway owner.
    * *   If you specify a sub-device that is already attached to a gateway, the original gateway is replaced with the specified gateway.
    * *   If one of the specified sub-devices fails to establish a topological relationship with the gateway, the system rolls back, and all specified sub-devices fail to establish topological relationships with the gateway.
    * *   After you call this operation to establish topological relationships between sub-devices and the gateway, IoT Platform uses the `/sys/${productKey}/${deviceName}/thing/topo/change` topic to push information that includes the result of this operation to the gateway. For more information, see [Notify gateways of changes of topological relationships](~~89299~~).
    * ## QPS limits
    * You can call this API operation up to 10 times per second per Alibaba Cloud account. 
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request BatchAddThingTopoRequest
    * @return BatchAddThingTopoResponse
   */
  async batchAddThingTopo(request: BatchAddThingTopoRequest): Promise<BatchAddThingTopoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchAddThingTopoWithOptions(request, runtime);
  }

  /**
    * In addition to the preceding operation-specific request parameters, you must specify common request parameters when you call this operation. For more information about common request parameters, see [Common parameters](~~30561~~).
    *
    * @param request BatchBindDeviceToEdgeInstanceWithDriverRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return BatchBindDeviceToEdgeInstanceWithDriverResponse
   */
  async batchBindDeviceToEdgeInstanceWithDriverWithOptions(request: BatchBindDeviceToEdgeInstanceWithDriverRequest, runtime: $Util.RuntimeOptions): Promise<BatchBindDeviceToEdgeInstanceWithDriverResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.driverId)) {
      query["DriverId"] = request.driverId;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotIds)) {
      query["IotIds"] = request.iotIds;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BatchBindDeviceToEdgeInstanceWithDriver",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchBindDeviceToEdgeInstanceWithDriverResponse>(await this.callApi(params, req, runtime), new BatchBindDeviceToEdgeInstanceWithDriverResponse({}));
  }

  /**
    * In addition to the preceding operation-specific request parameters, you must specify common request parameters when you call this operation. For more information about common request parameters, see [Common parameters](~~30561~~).
    *
    * @param request BatchBindDeviceToEdgeInstanceWithDriverRequest
    * @return BatchBindDeviceToEdgeInstanceWithDriverResponse
   */
  async batchBindDeviceToEdgeInstanceWithDriver(request: BatchBindDeviceToEdgeInstanceWithDriverRequest): Promise<BatchBindDeviceToEdgeInstanceWithDriverResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchBindDeviceToEdgeInstanceWithDriverWithOptions(request, runtime);
  }

  async batchBindDevicesIntoProjectWithOptions(request: BatchBindDevicesIntoProjectRequest, runtime: $Util.RuntimeOptions): Promise<BatchBindDevicesIntoProjectResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.devices)) {
      body["Devices"] = request.devices;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      body["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "BatchBindDevicesIntoProject",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchBindDevicesIntoProjectResponse>(await this.callApi(params, req, runtime), new BatchBindDevicesIntoProjectResponse({}));
  }

  async batchBindDevicesIntoProject(request: BatchBindDevicesIntoProjectRequest): Promise<BatchBindDevicesIntoProjectResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchBindDevicesIntoProjectWithOptions(request, runtime);
  }

  async batchBindProductsIntoProjectWithOptions(request: BatchBindProductsIntoProjectRequest, runtime: $Util.RuntimeOptions): Promise<BatchBindProductsIntoProjectResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      body["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKeys)) {
      body["ProductKeys"] = request.productKeys;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "BatchBindProductsIntoProject",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchBindProductsIntoProjectResponse>(await this.callApi(params, req, runtime), new BatchBindProductsIntoProjectResponse({}));
  }

  async batchBindProductsIntoProject(request: BatchBindProductsIntoProjectRequest): Promise<BatchBindProductsIntoProjectResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchBindProductsIntoProjectWithOptions(request, runtime);
  }

  /**
    * You can call this operation with the **BatchRegisterDeviceWithApplyId** operation to register multiple devices under a product. Each device carries a unique DeviceName.
    * Procedure:
    * 1\\. Call this operation to specify the DeviceNames of the devices to be registered. IoT Platform returns an application ID (**ApplyId**). A successful response indicates that the request to verify the DeviceNames is submitted. The actual registration process is asynchronously implemented and takes some minutes.
    * 2\\. Call the [QueryBatchRegisterDeviceStatus](~~69483~~) operation to query the name setting result.
    * 3\\. Call the [BatchRegisterDeviceWithApplyId](~~69514~~) operation to register multiple devices.
    * 4\\. Optional. Call the [QueryBatchRegisterDeviceStatus](~~69483~~) operation to view the registration result.
    * 5\\. Call the [QueryPageByApplyId](~~69518~~) operation to query the information about the registered devices.
    * ## Limits
    * - You can specify a maximum of 10,000 DeviceNames in a single call.
    * - Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).  >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request BatchCheckDeviceNamesRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return BatchCheckDeviceNamesResponse
   */
  async batchCheckDeviceNamesWithOptions(request: BatchCheckDeviceNamesRequest, runtime: $Util.RuntimeOptions): Promise<BatchCheckDeviceNamesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.deviceName)) {
      body["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.deviceNameList)) {
      body["DeviceNameList"] = request.deviceNameList;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "BatchCheckDeviceNames",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchCheckDeviceNamesResponse>(await this.callApi(params, req, runtime), new BatchCheckDeviceNamesResponse({}));
  }

  /**
    * You can call this operation with the **BatchRegisterDeviceWithApplyId** operation to register multiple devices under a product. Each device carries a unique DeviceName.
    * Procedure:
    * 1\\. Call this operation to specify the DeviceNames of the devices to be registered. IoT Platform returns an application ID (**ApplyId**). A successful response indicates that the request to verify the DeviceNames is submitted. The actual registration process is asynchronously implemented and takes some minutes.
    * 2\\. Call the [QueryBatchRegisterDeviceStatus](~~69483~~) operation to query the name setting result.
    * 3\\. Call the [BatchRegisterDeviceWithApplyId](~~69514~~) operation to register multiple devices.
    * 4\\. Optional. Call the [QueryBatchRegisterDeviceStatus](~~69483~~) operation to view the registration result.
    * 5\\. Call the [QueryPageByApplyId](~~69518~~) operation to query the information about the registered devices.
    * ## Limits
    * - You can specify a maximum of 10,000 DeviceNames in a single call.
    * - Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).  >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request BatchCheckDeviceNamesRequest
    * @return BatchCheckDeviceNamesResponse
   */
  async batchCheckDeviceNames(request: BatchCheckDeviceNamesRequest): Promise<BatchCheckDeviceNamesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchCheckDeviceNamesWithOptions(request, runtime);
  }

  async batchCheckImportDeviceWithOptions(request: BatchCheckImportDeviceRequest, runtime: $Util.RuntimeOptions): Promise<BatchCheckImportDeviceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.deviceList)) {
      body["DeviceList"] = request.deviceList;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "BatchCheckImportDevice",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchCheckImportDeviceResponse>(await this.callApi(params, req, runtime), new BatchCheckImportDeviceResponse({}));
  }

  async batchCheckImportDevice(request: BatchCheckImportDeviceRequest): Promise<BatchCheckImportDeviceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchCheckImportDeviceWithOptions(request, runtime);
  }

  /**
    * The invalid device models returned if the call fails.
    *
    * @param request BatchCheckVehicleDeviceRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return BatchCheckVehicleDeviceResponse
   */
  async batchCheckVehicleDeviceWithOptions(request: BatchCheckVehicleDeviceRequest, runtime: $Util.RuntimeOptions): Promise<BatchCheckVehicleDeviceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.deviceList)) {
      body["DeviceList"] = request.deviceList;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "BatchCheckVehicleDevice",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchCheckVehicleDeviceResponse>(await this.callApi(params, req, runtime), new BatchCheckVehicleDeviceResponse({}));
  }

  /**
    * The invalid device models returned if the call fails.
    *
    * @param request BatchCheckVehicleDeviceRequest
    * @return BatchCheckVehicleDeviceResponse
   */
  async batchCheckVehicleDevice(request: BatchCheckVehicleDeviceRequest): Promise<BatchCheckVehicleDeviceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchCheckVehicleDeviceWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of five queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request BatchClearEdgeInstanceDeviceConfigRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return BatchClearEdgeInstanceDeviceConfigResponse
   */
  async batchClearEdgeInstanceDeviceConfigWithOptions(request: BatchClearEdgeInstanceDeviceConfigRequest, runtime: $Util.RuntimeOptions): Promise<BatchClearEdgeInstanceDeviceConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotIds)) {
      query["IotIds"] = request.iotIds;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BatchClearEdgeInstanceDeviceConfig",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchClearEdgeInstanceDeviceConfigResponse>(await this.callApi(params, req, runtime), new BatchClearEdgeInstanceDeviceConfigResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of five queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request BatchClearEdgeInstanceDeviceConfigRequest
    * @return BatchClearEdgeInstanceDeviceConfigResponse
   */
  async batchClearEdgeInstanceDeviceConfig(request: BatchClearEdgeInstanceDeviceConfigRequest): Promise<BatchClearEdgeInstanceDeviceConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchClearEdgeInstanceDeviceConfigWithOptions(request, runtime);
  }

  async batchCreateSoundCodeLabelWithOptions(request: BatchCreateSoundCodeLabelRequest, runtime: $Util.RuntimeOptions): Promise<BatchCreateSoundCodeLabelResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.description)) {
      body["Description"] = request.description;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      body["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.scheduleCode)) {
      body["ScheduleCode"] = request.scheduleCode;
    }

    if (!Util.isUnset(request.total)) {
      body["Total"] = request.total;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "BatchCreateSoundCodeLabel",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchCreateSoundCodeLabelResponse>(await this.callApi(params, req, runtime), new BatchCreateSoundCodeLabelResponse({}));
  }

  async batchCreateSoundCodeLabel(request: BatchCreateSoundCodeLabelRequest): Promise<BatchCreateSoundCodeLabelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchCreateSoundCodeLabelWithOptions(request, runtime);
  }

  async batchCreateSoundCodeLabelWithLabelsWithOptions(request: BatchCreateSoundCodeLabelWithLabelsRequest, runtime: $Util.RuntimeOptions): Promise<BatchCreateSoundCodeLabelWithLabelsResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.description)) {
      body["Description"] = request.description;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      body["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.labels)) {
      body["Labels"] = request.labels;
    }

    if (!Util.isUnset(request.scheduleCode)) {
      body["ScheduleCode"] = request.scheduleCode;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "BatchCreateSoundCodeLabelWithLabels",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchCreateSoundCodeLabelWithLabelsResponse>(await this.callApi(params, req, runtime), new BatchCreateSoundCodeLabelWithLabelsResponse({}));
  }

  async batchCreateSoundCodeLabelWithLabels(request: BatchCreateSoundCodeLabelWithLabelsRequest): Promise<BatchCreateSoundCodeLabelWithLabelsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchCreateSoundCodeLabelWithLabelsWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request BatchDeleteDeviceGroupRelationsRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return BatchDeleteDeviceGroupRelationsResponse
   */
  async batchDeleteDeviceGroupRelationsWithOptions(request: BatchDeleteDeviceGroupRelationsRequest, runtime: $Util.RuntimeOptions): Promise<BatchDeleteDeviceGroupRelationsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.device)) {
      query["Device"] = request.device;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BatchDeleteDeviceGroupRelations",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchDeleteDeviceGroupRelationsResponse>(await this.callApi(params, req, runtime), new BatchDeleteDeviceGroupRelationsResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request BatchDeleteDeviceGroupRelationsRequest
    * @return BatchDeleteDeviceGroupRelationsResponse
   */
  async batchDeleteDeviceGroupRelations(request: BatchDeleteDeviceGroupRelationsRequest): Promise<BatchDeleteDeviceGroupRelationsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchDeleteDeviceGroupRelationsWithOptions(request, runtime);
  }

  async batchDeleteEdgeInstanceChannelWithOptions(request: BatchDeleteEdgeInstanceChannelRequest, runtime: $Util.RuntimeOptions): Promise<BatchDeleteEdgeInstanceChannelResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.channelIds)) {
      query["ChannelIds"] = request.channelIds;
    }

    if (!Util.isUnset(request.driverId)) {
      query["DriverId"] = request.driverId;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BatchDeleteEdgeInstanceChannel",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchDeleteEdgeInstanceChannelResponse>(await this.callApi(params, req, runtime), new BatchDeleteEdgeInstanceChannelResponse({}));
  }

  async batchDeleteEdgeInstanceChannel(request: BatchDeleteEdgeInstanceChannelRequest): Promise<BatchDeleteEdgeInstanceChannelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchDeleteEdgeInstanceChannelWithOptions(request, runtime);
  }

  async batchGetDeviceBindStatusWithOptions(request: BatchGetDeviceBindStatusRequest, runtime: $Util.RuntimeOptions): Promise<BatchGetDeviceBindStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotIds)) {
      query["IotIds"] = request.iotIds;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BatchGetDeviceBindStatus",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchGetDeviceBindStatusResponse>(await this.callApi(params, req, runtime), new BatchGetDeviceBindStatusResponse({}));
  }

  async batchGetDeviceBindStatus(request: BatchGetDeviceBindStatusRequest): Promise<BatchGetDeviceBindStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchGetDeviceBindStatusWithOptions(request, runtime);
  }

  /**
    * When you call this operation, you can perform the following operations:
    * *   You can specify a value for the **ProductKey** parameter and multiple values for the **DeviceName** parameter to query the status of devices that belong to a product.
    * *   You can specify multiple values for the **IotId** parameter to query the status of devices that belong to different products.****
    * >You can query the status of up to 50 devices in a call.
    * ## QPS limits
    * Each Alibaba Cloud account can run up to 50 queries per second (QPS). 
    * >  The RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request BatchGetDeviceStateRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return BatchGetDeviceStateResponse
   */
  async batchGetDeviceStateWithOptions(request: BatchGetDeviceStateRequest, runtime: $Util.RuntimeOptions): Promise<BatchGetDeviceStateResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotId)) {
      query["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BatchGetDeviceState",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchGetDeviceStateResponse>(await this.callApi(params, req, runtime), new BatchGetDeviceStateResponse({}));
  }

  /**
    * When you call this operation, you can perform the following operations:
    * *   You can specify a value for the **ProductKey** parameter and multiple values for the **DeviceName** parameter to query the status of devices that belong to a product.
    * *   You can specify multiple values for the **IotId** parameter to query the status of devices that belong to different products.****
    * >You can query the status of up to 50 devices in a call.
    * ## QPS limits
    * Each Alibaba Cloud account can run up to 50 queries per second (QPS). 
    * >  The RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request BatchGetDeviceStateRequest
    * @return BatchGetDeviceStateResponse
   */
  async batchGetDeviceState(request: BatchGetDeviceStateRequest): Promise<BatchGetDeviceStateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchGetDeviceStateWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * A single Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
    * >  RAM users share the quota of the Alibaba Cloud account.
    *
    * @param request BatchGetEdgeDriverRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return BatchGetEdgeDriverResponse
   */
  async batchGetEdgeDriverWithOptions(request: BatchGetEdgeDriverRequest, runtime: $Util.RuntimeOptions): Promise<BatchGetEdgeDriverResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.driverIds)) {
      query["DriverIds"] = request.driverIds;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BatchGetEdgeDriver",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchGetEdgeDriverResponse>(await this.callApi(params, req, runtime), new BatchGetEdgeDriverResponse({}));
  }

  /**
    * ## Limits
    * A single Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
    * >  RAM users share the quota of the Alibaba Cloud account.
    *
    * @param request BatchGetEdgeDriverRequest
    * @return BatchGetEdgeDriverResponse
   */
  async batchGetEdgeDriver(request: BatchGetEdgeDriverRequest): Promise<BatchGetEdgeDriverResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchGetEdgeDriverWithOptions(request, runtime);
  }

  async batchGetEdgeInstanceChannelWithOptions(request: BatchGetEdgeInstanceChannelRequest, runtime: $Util.RuntimeOptions): Promise<BatchGetEdgeInstanceChannelResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.channelIds)) {
      query["ChannelIds"] = request.channelIds;
    }

    if (!Util.isUnset(request.driverId)) {
      query["DriverId"] = request.driverId;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BatchGetEdgeInstanceChannel",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchGetEdgeInstanceChannelResponse>(await this.callApi(params, req, runtime), new BatchGetEdgeInstanceChannelResponse({}));
  }

  async batchGetEdgeInstanceChannel(request: BatchGetEdgeInstanceChannelRequest): Promise<BatchGetEdgeInstanceChannelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchGetEdgeInstanceChannelWithOptions(request, runtime);
  }

  async batchGetEdgeInstanceDeviceChannelWithOptions(request: BatchGetEdgeInstanceDeviceChannelRequest, runtime: $Util.RuntimeOptions): Promise<BatchGetEdgeInstanceDeviceChannelResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.driverId)) {
      query["DriverId"] = request.driverId;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotIds)) {
      query["IotIds"] = request.iotIds;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BatchGetEdgeInstanceDeviceChannel",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchGetEdgeInstanceDeviceChannelResponse>(await this.callApi(params, req, runtime), new BatchGetEdgeInstanceDeviceChannelResponse({}));
  }

  async batchGetEdgeInstanceDeviceChannel(request: BatchGetEdgeInstanceDeviceChannelRequest): Promise<BatchGetEdgeInstanceDeviceChannelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchGetEdgeInstanceDeviceChannelWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of five queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request BatchGetEdgeInstanceDeviceConfigRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return BatchGetEdgeInstanceDeviceConfigResponse
   */
  async batchGetEdgeInstanceDeviceConfigWithOptions(request: BatchGetEdgeInstanceDeviceConfigRequest, runtime: $Util.RuntimeOptions): Promise<BatchGetEdgeInstanceDeviceConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotIds)) {
      query["IotIds"] = request.iotIds;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BatchGetEdgeInstanceDeviceConfig",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchGetEdgeInstanceDeviceConfigResponse>(await this.callApi(params, req, runtime), new BatchGetEdgeInstanceDeviceConfigResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of five queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request BatchGetEdgeInstanceDeviceConfigRequest
    * @return BatchGetEdgeInstanceDeviceConfigResponse
   */
  async batchGetEdgeInstanceDeviceConfig(request: BatchGetEdgeInstanceDeviceConfigRequest): Promise<BatchGetEdgeInstanceDeviceConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchGetEdgeInstanceDeviceConfigWithOptions(request, runtime);
  }

  async batchGetEdgeInstanceDeviceDriverWithOptions(request: BatchGetEdgeInstanceDeviceDriverRequest, runtime: $Util.RuntimeOptions): Promise<BatchGetEdgeInstanceDeviceDriverResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotIds)) {
      query["IotIds"] = request.iotIds;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BatchGetEdgeInstanceDeviceDriver",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchGetEdgeInstanceDeviceDriverResponse>(await this.callApi(params, req, runtime), new BatchGetEdgeInstanceDeviceDriverResponse({}));
  }

  async batchGetEdgeInstanceDeviceDriver(request: BatchGetEdgeInstanceDeviceDriverRequest): Promise<BatchGetEdgeInstanceDeviceDriverResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchGetEdgeInstanceDeviceDriverWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request BatchGetEdgeInstanceDriverConfigsRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return BatchGetEdgeInstanceDriverConfigsResponse
   */
  async batchGetEdgeInstanceDriverConfigsWithOptions(request: BatchGetEdgeInstanceDriverConfigsRequest, runtime: $Util.RuntimeOptions): Promise<BatchGetEdgeInstanceDriverConfigsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.driverIds)) {
      query["DriverIds"] = request.driverIds;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BatchGetEdgeInstanceDriverConfigs",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchGetEdgeInstanceDriverConfigsResponse>(await this.callApi(params, req, runtime), new BatchGetEdgeInstanceDriverConfigsResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request BatchGetEdgeInstanceDriverConfigsRequest
    * @return BatchGetEdgeInstanceDriverConfigsResponse
   */
  async batchGetEdgeInstanceDriverConfigs(request: BatchGetEdgeInstanceDriverConfigsRequest): Promise<BatchGetEdgeInstanceDriverConfigsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchGetEdgeInstanceDriverConfigsWithOptions(request, runtime);
  }

  async batchGrayMigrationDeviceWithOptions(request: BatchGrayMigrationDeviceRequest, runtime: $Util.RuntimeOptions): Promise<BatchGrayMigrationDeviceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.deviceNames)) {
      body["DeviceNames"] = request.deviceNames;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "BatchGrayMigrationDevice",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchGrayMigrationDeviceResponse>(await this.callApi(params, req, runtime), new BatchGrayMigrationDeviceResponse({}));
  }

  async batchGrayMigrationDevice(request: BatchGrayMigrationDeviceRequest): Promise<BatchGrayMigrationDeviceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchGrayMigrationDeviceWithOptions(request, runtime);
  }

  async batchImportDeviceWithOptions(request: BatchImportDeviceRequest, runtime: $Util.RuntimeOptions): Promise<BatchImportDeviceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.deviceList)) {
      body["DeviceList"] = request.deviceList;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "BatchImportDevice",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchImportDeviceResponse>(await this.callApi(params, req, runtime), new BatchImportDeviceResponse({}));
  }

  async batchImportDevice(request: BatchImportDeviceRequest): Promise<BatchImportDeviceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchImportDeviceWithOptions(request, runtime);
  }

  /**
    * Indicates whether the call was successful. Valid values: 
    * - **true**: The call was successful.
    * - **false**: The call failed.
    *
    * @param request BatchImportVehicleDeviceRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return BatchImportVehicleDeviceResponse
   */
  async batchImportVehicleDeviceWithOptions(request: BatchImportVehicleDeviceRequest, runtime: $Util.RuntimeOptions): Promise<BatchImportVehicleDeviceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.deviceList)) {
      body["DeviceList"] = request.deviceList;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "BatchImportVehicleDevice",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchImportVehicleDeviceResponse>(await this.callApi(params, req, runtime), new BatchImportVehicleDeviceResponse({}));
  }

  /**
    * Indicates whether the call was successful. Valid values: 
    * - **true**: The call was successful.
    * - **false**: The call failed.
    *
    * @param request BatchImportVehicleDeviceRequest
    * @return BatchImportVehicleDeviceResponse
   */
  async batchImportVehicleDevice(request: BatchImportVehicleDeviceRequest): Promise<BatchImportVehicleDeviceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchImportVehicleDeviceWithOptions(request, runtime);
  }

  /**
    * *   You can call this operation to publish a message to a maximum of 100 devices of a product at a time.
    * *   The BatchPub operation cannot be used to send commands of setting properties or calling services. If you need to set properties, use the [SetDeviceProperty](~~69579~~) or [SetDevicesProperty](~~96243~~) operation. If you need to call services, use the [InvokeThingService](~~69584~~) or [InvokeThingsService](~~96242~~) operation.
    * *   Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
    * >RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request BatchPubRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return BatchPubResponse
   */
  async batchPubWithOptions(request: BatchPubRequest, runtime: $Util.RuntimeOptions): Promise<BatchPubResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.messageContent)) {
      query["MessageContent"] = request.messageContent;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.qos)) {
      query["Qos"] = request.qos;
    }

    if (!Util.isUnset(request.topicShortName)) {
      query["TopicShortName"] = request.topicShortName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BatchPub",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchPubResponse>(await this.callApi(params, req, runtime), new BatchPubResponse({}));
  }

  /**
    * *   You can call this operation to publish a message to a maximum of 100 devices of a product at a time.
    * *   The BatchPub operation cannot be used to send commands of setting properties or calling services. If you need to set properties, use the [SetDeviceProperty](~~69579~~) or [SetDevicesProperty](~~96243~~) operation. If you need to call services, use the [InvokeThingService](~~69584~~) or [InvokeThingsService](~~96242~~) operation.
    * *   Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
    * >RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request BatchPubRequest
    * @return BatchPubResponse
   */
  async batchPub(request: BatchPubRequest): Promise<BatchPubResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchPubWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * *   You can query a maximum of 100 devices in a single call.
    * *   You can query the details of devices that belong only to the current Alibaba Cloud account. If you specify a device that does not belong to the current account, an error message is returned.
    * *   If you specify multiple devices and some devices do not exist, only the details of existing devices are returned.
    * *   Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
    * > RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request BatchQueryDeviceDetailRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return BatchQueryDeviceDetailResponse
   */
  async batchQueryDeviceDetailWithOptions(request: BatchQueryDeviceDetailRequest, runtime: $Util.RuntimeOptions): Promise<BatchQueryDeviceDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BatchQueryDeviceDetail",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchQueryDeviceDetailResponse>(await this.callApi(params, req, runtime), new BatchQueryDeviceDetailResponse({}));
  }

  /**
    * ## Limits
    * *   You can query a maximum of 100 devices in a single call.
    * *   You can query the details of devices that belong only to the current Alibaba Cloud account. If you specify a device that does not belong to the current account, an error message is returned.
    * *   If you specify multiple devices and some devices do not exist, only the details of existing devices are returned.
    * *   Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
    * > RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request BatchQueryDeviceDetailRequest
    * @return BatchQueryDeviceDetailResponse
   */
  async batchQueryDeviceDetail(request: BatchQueryDeviceDetailRequest): Promise<BatchQueryDeviceDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchQueryDeviceDetailWithOptions(request, runtime);
  }

  /**
    * You can use one of the following methods to register multiple devices:
    * *   If you want to generate random DeviceNames, call the BatchRegisterDevice operation.
    *     Perform the following steps to register devices and view the result:
    *     1\\. Call the BatchRegisterDevice operation to register multiple devices. A successful response indicates that the registration request is submitted. The actual registration process is asynchronously implemented and takes some minutes.
    *     2\\. Call the [QueryBatchRegisterDeviceStatus](~~69483~~) operation to query the device registration result.
    *     3\\. Call the [QueryPageByApplyId](~~69518~~) operation to view the details of registered devices. The details include the DeviceName, DeviceSecret, and IotId parameters.
    * *   If you want to specify custom DeviceNames, call the BatchRegisterDeviceWithApplyId operation. For more information, see [BatchRegisterDeviceWithApplyId](~~69514~~).
    * ## Limits
    * - You can create a maximum of 10,000 devices in a single call.
    * - Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).  >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request BatchRegisterDeviceRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return BatchRegisterDeviceResponse
   */
  async batchRegisterDeviceWithOptions(request: BatchRegisterDeviceRequest, runtime: $Util.RuntimeOptions): Promise<BatchRegisterDeviceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.count)) {
      query["Count"] = request.count;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BatchRegisterDevice",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchRegisterDeviceResponse>(await this.callApi(params, req, runtime), new BatchRegisterDeviceResponse({}));
  }

  /**
    * You can use one of the following methods to register multiple devices:
    * *   If you want to generate random DeviceNames, call the BatchRegisterDevice operation.
    *     Perform the following steps to register devices and view the result:
    *     1\\. Call the BatchRegisterDevice operation to register multiple devices. A successful response indicates that the registration request is submitted. The actual registration process is asynchronously implemented and takes some minutes.
    *     2\\. Call the [QueryBatchRegisterDeviceStatus](~~69483~~) operation to query the device registration result.
    *     3\\. Call the [QueryPageByApplyId](~~69518~~) operation to view the details of registered devices. The details include the DeviceName, DeviceSecret, and IotId parameters.
    * *   If you want to specify custom DeviceNames, call the BatchRegisterDeviceWithApplyId operation. For more information, see [BatchRegisterDeviceWithApplyId](~~69514~~).
    * ## Limits
    * - You can create a maximum of 10,000 devices in a single call.
    * - Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).  >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request BatchRegisterDeviceRequest
    * @return BatchRegisterDeviceResponse
   */
  async batchRegisterDevice(request: BatchRegisterDeviceRequest): Promise<BatchRegisterDeviceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchRegisterDeviceWithOptions(request, runtime);
  }

  /**
    * You can use one of the following methods to register multiple devices at a time:
    * *   Call the [BatchRegisterDevice](~~69473~~) operation to generate random DeviceNames.
    * *   Call the BatchRegisterDeviceWithApplyId and **BatchCheckDeviceNames** operations to specify custom DeviceNames. Procedure:
    *     Call the [BatchCheckDeviceNames](~~69482~~) operation and specify the names of devices that you want to register. If the DeviceNames are valid, IoT Platform returns an application ID that is specified by the **ApplyId** parameter. You can query the DeviceName setting results, device registration results, and device details by **ApplyId**.
    *     Call the [QueryBatchRegisterDeviceStatus](~~69483~~) operation to query the name setting result.
    *     Call the BatchRegisterDeviceWithApplyId operation to register multiple devices. The successful result that is returned by this operation indicates that only the batch registration request is submitted. In actual scenarios, the registration process takes a few minutes.
    *     Optional. Call the [QueryBatchRegisterDeviceStatus](~~69483~~) operation to query the device registration result.
    *     Call the [QueryPageByApplyId](~~69518~~) operation to view the details of devices that are registered in batches.
    * ## QPS limits
    * Each Alibaba Cloud account can run up to 500 queries per second (QPS). 
    * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
    *
    * @param request BatchRegisterDeviceWithApplyIdRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return BatchRegisterDeviceWithApplyIdResponse
   */
  async batchRegisterDeviceWithApplyIdWithOptions(request: BatchRegisterDeviceWithApplyIdRequest, runtime: $Util.RuntimeOptions): Promise<BatchRegisterDeviceWithApplyIdResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.applyId)) {
      query["ApplyId"] = request.applyId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BatchRegisterDeviceWithApplyId",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchRegisterDeviceWithApplyIdResponse>(await this.callApi(params, req, runtime), new BatchRegisterDeviceWithApplyIdResponse({}));
  }

  /**
    * You can use one of the following methods to register multiple devices at a time:
    * *   Call the [BatchRegisterDevice](~~69473~~) operation to generate random DeviceNames.
    * *   Call the BatchRegisterDeviceWithApplyId and **BatchCheckDeviceNames** operations to specify custom DeviceNames. Procedure:
    *     Call the [BatchCheckDeviceNames](~~69482~~) operation and specify the names of devices that you want to register. If the DeviceNames are valid, IoT Platform returns an application ID that is specified by the **ApplyId** parameter. You can query the DeviceName setting results, device registration results, and device details by **ApplyId**.
    *     Call the [QueryBatchRegisterDeviceStatus](~~69483~~) operation to query the name setting result.
    *     Call the BatchRegisterDeviceWithApplyId operation to register multiple devices. The successful result that is returned by this operation indicates that only the batch registration request is submitted. In actual scenarios, the registration process takes a few minutes.
    *     Optional. Call the [QueryBatchRegisterDeviceStatus](~~69483~~) operation to query the device registration result.
    *     Call the [QueryPageByApplyId](~~69518~~) operation to view the details of devices that are registered in batches.
    * ## QPS limits
    * Each Alibaba Cloud account can run up to 500 queries per second (QPS). 
    * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
    *
    * @param request BatchRegisterDeviceWithApplyIdRequest
    * @return BatchRegisterDeviceWithApplyIdResponse
   */
  async batchRegisterDeviceWithApplyId(request: BatchRegisterDeviceWithApplyIdRequest): Promise<BatchRegisterDeviceWithApplyIdResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchRegisterDeviceWithApplyIdWithOptions(request, runtime);
  }

  async batchSetEdgeInstanceDeviceChannelWithOptions(request: BatchSetEdgeInstanceDeviceChannelRequest, runtime: $Util.RuntimeOptions): Promise<BatchSetEdgeInstanceDeviceChannelResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.channelId)) {
      query["ChannelId"] = request.channelId;
    }

    if (!Util.isUnset(request.driverId)) {
      query["DriverId"] = request.driverId;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotIds)) {
      query["IotIds"] = request.iotIds;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BatchSetEdgeInstanceDeviceChannel",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchSetEdgeInstanceDeviceChannelResponse>(await this.callApi(params, req, runtime), new BatchSetEdgeInstanceDeviceChannelResponse({}));
  }

  async batchSetEdgeInstanceDeviceChannel(request: BatchSetEdgeInstanceDeviceChannelRequest): Promise<BatchSetEdgeInstanceDeviceChannelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchSetEdgeInstanceDeviceChannelWithOptions(request, runtime);
  }

  async batchSetEdgeInstanceDeviceConfigWithOptions(request: BatchSetEdgeInstanceDeviceConfigRequest, runtime: $Util.RuntimeOptions): Promise<BatchSetEdgeInstanceDeviceConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceConfigs)) {
      query["DeviceConfigs"] = request.deviceConfigs;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BatchSetEdgeInstanceDeviceConfig",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchSetEdgeInstanceDeviceConfigResponse>(await this.callApi(params, req, runtime), new BatchSetEdgeInstanceDeviceConfigResponse({}));
  }

  async batchSetEdgeInstanceDeviceConfig(request: BatchSetEdgeInstanceDeviceConfigRequest): Promise<BatchSetEdgeInstanceDeviceConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchSetEdgeInstanceDeviceConfigWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of five queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request BatchUnbindDeviceFromEdgeInstanceRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return BatchUnbindDeviceFromEdgeInstanceResponse
   */
  async batchUnbindDeviceFromEdgeInstanceWithOptions(request: BatchUnbindDeviceFromEdgeInstanceRequest, runtime: $Util.RuntimeOptions): Promise<BatchUnbindDeviceFromEdgeInstanceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotIds)) {
      query["IotIds"] = request.iotIds;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BatchUnbindDeviceFromEdgeInstance",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchUnbindDeviceFromEdgeInstanceResponse>(await this.callApi(params, req, runtime), new BatchUnbindDeviceFromEdgeInstanceResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of five queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request BatchUnbindDeviceFromEdgeInstanceRequest
    * @return BatchUnbindDeviceFromEdgeInstanceResponse
   */
  async batchUnbindDeviceFromEdgeInstance(request: BatchUnbindDeviceFromEdgeInstanceRequest): Promise<BatchUnbindDeviceFromEdgeInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchUnbindDeviceFromEdgeInstanceWithOptions(request, runtime);
  }

  async batchUnbindProjectDevicesWithOptions(request: BatchUnbindProjectDevicesRequest, runtime: $Util.RuntimeOptions): Promise<BatchUnbindProjectDevicesResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.devices)) {
      body["Devices"] = request.devices;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      body["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "BatchUnbindProjectDevices",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchUnbindProjectDevicesResponse>(await this.callApi(params, req, runtime), new BatchUnbindProjectDevicesResponse({}));
  }

  async batchUnbindProjectDevices(request: BatchUnbindProjectDevicesRequest): Promise<BatchUnbindProjectDevicesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchUnbindProjectDevicesWithOptions(request, runtime);
  }

  async batchUnbindProjectProductsWithOptions(request: BatchUnbindProjectProductsRequest, runtime: $Util.RuntimeOptions): Promise<BatchUnbindProjectProductsResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      body["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKeys)) {
      body["ProductKeys"] = request.productKeys;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "BatchUnbindProjectProducts",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchUnbindProjectProductsResponse>(await this.callApi(params, req, runtime), new BatchUnbindProjectProductsResponse({}));
  }

  async batchUnbindProjectProducts(request: BatchUnbindProjectProductsRequest): Promise<BatchUnbindProjectProductsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchUnbindProjectProductsWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request BatchUpdateDeviceNicknameRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return BatchUpdateDeviceNicknameResponse
   */
  async batchUpdateDeviceNicknameWithOptions(request: BatchUpdateDeviceNicknameRequest, runtime: $Util.RuntimeOptions): Promise<BatchUpdateDeviceNicknameResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceNicknameInfo)) {
      query["DeviceNicknameInfo"] = request.deviceNicknameInfo;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BatchUpdateDeviceNickname",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchUpdateDeviceNicknameResponse>(await this.callApi(params, req, runtime), new BatchUpdateDeviceNicknameResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request BatchUpdateDeviceNicknameRequest
    * @return BatchUpdateDeviceNicknameResponse
   */
  async batchUpdateDeviceNickname(request: BatchUpdateDeviceNicknameRequest): Promise<BatchUpdateDeviceNicknameResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchUpdateDeviceNicknameWithOptions(request, runtime);
  }

  async bindApplicationToEdgeInstanceWithOptions(request: BindApplicationToEdgeInstanceRequest, runtime: $Util.RuntimeOptions): Promise<BindApplicationToEdgeInstanceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.applicationId)) {
      query["ApplicationId"] = request.applicationId;
    }

    if (!Util.isUnset(request.applicationVersion)) {
      query["ApplicationVersion"] = request.applicationVersion;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BindApplicationToEdgeInstance",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BindApplicationToEdgeInstanceResponse>(await this.callApi(params, req, runtime), new BindApplicationToEdgeInstanceResponse({}));
  }

  async bindApplicationToEdgeInstance(request: BindApplicationToEdgeInstanceRequest): Promise<BindApplicationToEdgeInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.bindApplicationToEdgeInstanceWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of five queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request BindDriverToEdgeInstanceRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return BindDriverToEdgeInstanceResponse
   */
  async bindDriverToEdgeInstanceWithOptions(request: BindDriverToEdgeInstanceRequest, runtime: $Util.RuntimeOptions): Promise<BindDriverToEdgeInstanceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.driverId)) {
      query["DriverId"] = request.driverId;
    }

    if (!Util.isUnset(request.driverVersion)) {
      query["DriverVersion"] = request.driverVersion;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BindDriverToEdgeInstance",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BindDriverToEdgeInstanceResponse>(await this.callApi(params, req, runtime), new BindDriverToEdgeInstanceResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of five queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request BindDriverToEdgeInstanceRequest
    * @return BindDriverToEdgeInstanceResponse
   */
  async bindDriverToEdgeInstance(request: BindDriverToEdgeInstanceRequest): Promise<BindDriverToEdgeInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.bindDriverToEdgeInstanceWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request BindGatewayToEdgeInstanceRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return BindGatewayToEdgeInstanceResponse
   */
  async bindGatewayToEdgeInstanceWithOptions(request: BindGatewayToEdgeInstanceRequest, runtime: $Util.RuntimeOptions): Promise<BindGatewayToEdgeInstanceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotId)) {
      query["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BindGatewayToEdgeInstance",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BindGatewayToEdgeInstanceResponse>(await this.callApi(params, req, runtime), new BindGatewayToEdgeInstanceResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request BindGatewayToEdgeInstanceRequest
    * @return BindGatewayToEdgeInstanceResponse
   */
  async bindGatewayToEdgeInstance(request: BindGatewayToEdgeInstanceRequest): Promise<BindGatewayToEdgeInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.bindGatewayToEdgeInstanceWithOptions(request, runtime);
  }

  async bindLicenseDeviceWithOptions(request: BindLicenseDeviceRequest, runtime: $Util.RuntimeOptions): Promise<BindLicenseDeviceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.licenseCode)) {
      query["LicenseCode"] = request.licenseCode;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.deviceNameList)) {
      body["DeviceNameList"] = request.deviceNameList;
    }

    if (!Util.isUnset(request.iotIdList)) {
      body["IotIdList"] = request.iotIdList;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "BindLicenseDevice",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BindLicenseDeviceResponse>(await this.callApi(params, req, runtime), new BindLicenseDeviceResponse({}));
  }

  async bindLicenseDevice(request: BindLicenseDeviceRequest): Promise<BindLicenseDeviceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.bindLicenseDeviceWithOptions(request, runtime);
  }

  async bindLicenseProductWithOptions(request: BindLicenseProductRequest, runtime: $Util.RuntimeOptions): Promise<BindLicenseProductResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.licenseCode)) {
      query["LicenseCode"] = request.licenseCode;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BindLicenseProduct",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BindLicenseProductResponse>(await this.callApi(params, req, runtime), new BindLicenseProductResponse({}));
  }

  async bindLicenseProduct(request: BindLicenseProductRequest): Promise<BindLicenseProductResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.bindLicenseProductWithOptions(request, runtime);
  }

  async bindRoleToEdgeInstanceWithOptions(request: BindRoleToEdgeInstanceRequest, runtime: $Util.RuntimeOptions): Promise<BindRoleToEdgeInstanceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.roleArn)) {
      query["RoleArn"] = request.roleArn;
    }

    if (!Util.isUnset(request.roleName)) {
      query["RoleName"] = request.roleName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BindRoleToEdgeInstance",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BindRoleToEdgeInstanceResponse>(await this.callApi(params, req, runtime), new BindRoleToEdgeInstanceResponse({}));
  }

  async bindRoleToEdgeInstance(request: BindRoleToEdgeInstanceRequest): Promise<BindRoleToEdgeInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.bindRoleToEdgeInstanceWithOptions(request, runtime);
  }

  async bindSceneRuleToEdgeInstanceWithOptions(request: BindSceneRuleToEdgeInstanceRequest, runtime: $Util.RuntimeOptions): Promise<BindSceneRuleToEdgeInstanceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.ruleId)) {
      query["RuleId"] = request.ruleId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BindSceneRuleToEdgeInstance",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BindSceneRuleToEdgeInstanceResponse>(await this.callApi(params, req, runtime), new BindSceneRuleToEdgeInstanceResponse({}));
  }

  async bindSceneRuleToEdgeInstance(request: BindSceneRuleToEdgeInstanceRequest): Promise<BindSceneRuleToEdgeInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.bindSceneRuleToEdgeInstanceWithOptions(request, runtime);
  }

  async cancelJobWithOptions(request: CancelJobRequest, runtime: $Util.RuntimeOptions): Promise<CancelJobResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.jobId)) {
      query["JobId"] = request.jobId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CancelJob",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CancelJobResponse>(await this.callApi(params, req, runtime), new CancelJobResponse({}));
  }

  async cancelJob(request: CancelJobRequest): Promise<CancelJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.cancelJobWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * *   You can cancel only the dynamic update policy that is attached to a dynamic update batch. This operation is not applicable to static update batches.
    *     After the operation is successful, the **JobStatus** parameter is set to CANCELED.
    * *   Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
    * > RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request CancelOTAStrategyByJobRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return CancelOTAStrategyByJobResponse
   */
  async cancelOTAStrategyByJobWithOptions(request: CancelOTAStrategyByJobRequest, runtime: $Util.RuntimeOptions): Promise<CancelOTAStrategyByJobResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.jobId)) {
      query["JobId"] = request.jobId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CancelOTAStrategyByJob",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CancelOTAStrategyByJobResponse>(await this.callApi(params, req, runtime), new CancelOTAStrategyByJobResponse({}));
  }

  /**
    * ## Limits
    * *   You can cancel only the dynamic update policy that is attached to a dynamic update batch. This operation is not applicable to static update batches.
    *     After the operation is successful, the **JobStatus** parameter is set to CANCELED.
    * *   Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
    * > RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request CancelOTAStrategyByJobRequest
    * @return CancelOTAStrategyByJobResponse
   */
  async cancelOTAStrategyByJob(request: CancelOTAStrategyByJobRequest): Promise<CancelOTAStrategyByJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.cancelOTAStrategyByJobWithOptions(request, runtime);
  }

  /**
    * This operation can cancel device update tasks only when the tasks are in the to be pushed, pushed, or in upgrade state.
    * ## QPS limits
    * Each Alibaba Cloud account can run up to 10 queries per second (QPS). 
    * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
    *
    * @param request CancelOTATaskByDeviceRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return CancelOTATaskByDeviceResponse
   */
  async cancelOTATaskByDeviceWithOptions(request: CancelOTATaskByDeviceRequest, runtime: $Util.RuntimeOptions): Promise<CancelOTATaskByDeviceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.firmwareId)) {
      query["FirmwareId"] = request.firmwareId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.jobId)) {
      query["JobId"] = request.jobId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CancelOTATaskByDevice",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CancelOTATaskByDeviceResponse>(await this.callApi(params, req, runtime), new CancelOTATaskByDeviceResponse({}));
  }

  /**
    * This operation can cancel device update tasks only when the tasks are in the to be pushed, pushed, or in upgrade state.
    * ## QPS limits
    * Each Alibaba Cloud account can run up to 10 queries per second (QPS). 
    * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
    *
    * @param request CancelOTATaskByDeviceRequest
    * @return CancelOTATaskByDeviceResponse
   */
  async cancelOTATaskByDevice(request: CancelOTATaskByDeviceRequest): Promise<CancelOTATaskByDeviceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.cancelOTATaskByDeviceWithOptions(request, runtime);
  }

  /**
    * When you call this operation, make sure that you specify at least one of the CancelScheduledTask, CancelQueuedTask, CancelInProgressTask, CancelNotifiedTask, and CancelUnconfirmedTask parameters. Otherwise, the request will fail.
    * ## QPS limits
    * Each Alibaba Cloud account can run a maximum of five queries per second (QPS). 
    * >  The RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request CancelOTATaskByJobRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return CancelOTATaskByJobResponse
   */
  async cancelOTATaskByJobWithOptions(request: CancelOTATaskByJobRequest, runtime: $Util.RuntimeOptions): Promise<CancelOTATaskByJobResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.cancelInProgressTask)) {
      query["CancelInProgressTask"] = request.cancelInProgressTask;
    }

    if (!Util.isUnset(request.cancelNotifiedTask)) {
      query["CancelNotifiedTask"] = request.cancelNotifiedTask;
    }

    if (!Util.isUnset(request.cancelQueuedTask)) {
      query["CancelQueuedTask"] = request.cancelQueuedTask;
    }

    if (!Util.isUnset(request.cancelScheduledTask)) {
      query["CancelScheduledTask"] = request.cancelScheduledTask;
    }

    if (!Util.isUnset(request.cancelUnconfirmedTask)) {
      query["CancelUnconfirmedTask"] = request.cancelUnconfirmedTask;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.jobId)) {
      query["JobId"] = request.jobId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CancelOTATaskByJob",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CancelOTATaskByJobResponse>(await this.callApi(params, req, runtime), new CancelOTATaskByJobResponse({}));
  }

  /**
    * When you call this operation, make sure that you specify at least one of the CancelScheduledTask, CancelQueuedTask, CancelInProgressTask, CancelNotifiedTask, and CancelUnconfirmedTask parameters. Otherwise, the request will fail.
    * ## QPS limits
    * Each Alibaba Cloud account can run a maximum of five queries per second (QPS). 
    * >  The RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request CancelOTATaskByJobRequest
    * @return CancelOTATaskByJobResponse
   */
  async cancelOTATaskByJob(request: CancelOTATaskByJobRequest): Promise<CancelOTATaskByJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.cancelOTATaskByJobWithOptions(request, runtime);
  }

  /**
    * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request CancelReleaseProductRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return CancelReleaseProductResponse
   */
  async cancelReleaseProductWithOptions(request: CancelReleaseProductRequest, runtime: $Util.RuntimeOptions): Promise<CancelReleaseProductResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CancelReleaseProduct",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CancelReleaseProductResponse>(await this.callApi(params, req, runtime), new CancelReleaseProductResponse({}));
  }

  /**
    * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request CancelReleaseProductRequest
    * @return CancelReleaseProductResponse
   */
  async cancelReleaseProduct(request: CancelReleaseProductRequest): Promise<CancelReleaseProductResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.cancelReleaseProductWithOptions(request, runtime);
  }

  async checkBindLicenseDeviceProgressWithOptions(request: CheckBindLicenseDeviceProgressRequest, runtime: $Util.RuntimeOptions): Promise<CheckBindLicenseDeviceProgressResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.checkProgressId)) {
      query["CheckProgressId"] = request.checkProgressId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.licenseCode)) {
      query["LicenseCode"] = request.licenseCode;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CheckBindLicenseDeviceProgress",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CheckBindLicenseDeviceProgressResponse>(await this.callApi(params, req, runtime), new CheckBindLicenseDeviceProgressResponse({}));
  }

  async checkBindLicenseDeviceProgress(request: CheckBindLicenseDeviceProgressRequest): Promise<CheckBindLicenseDeviceProgressResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.checkBindLicenseDeviceProgressWithOptions(request, runtime);
  }

  /**
    * *   Each time you call this operation, you must specify the identifiers of properties whose desired values you want to delete for the **Identifies** parameter. If you do not configure the **Identifies** parameter, the call fails.
    * *   You can specify up to 10 property identifiers for the **Identifies** parameter in a single call.
    * *   After you call this operation to deletes the desired values of properties of a device, you can call the [QueryDeviceDesiredProperty](~~107566~~) operation to query the desired values of properties of the device. In this case, the QueryDeviceDesiredProperty operation returns the **Identifier** parameter instead of the **Value** parameter.
    * ## QPS limits
    * You can call this API operation up to 50 times per second per account. 
    * >  The RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request ClearDeviceDesiredPropertyRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return ClearDeviceDesiredPropertyResponse
   */
  async clearDeviceDesiredPropertyWithOptions(request: ClearDeviceDesiredPropertyRequest, runtime: $Util.RuntimeOptions): Promise<ClearDeviceDesiredPropertyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotId)) {
      query["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.identifies)) {
      body["Identifies"] = request.identifies;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ClearDeviceDesiredProperty",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ClearDeviceDesiredPropertyResponse>(await this.callApi(params, req, runtime), new ClearDeviceDesiredPropertyResponse({}));
  }

  /**
    * *   Each time you call this operation, you must specify the identifiers of properties whose desired values you want to delete for the **Identifies** parameter. If you do not configure the **Identifies** parameter, the call fails.
    * *   You can specify up to 10 property identifiers for the **Identifies** parameter in a single call.
    * *   After you call this operation to deletes the desired values of properties of a device, you can call the [QueryDeviceDesiredProperty](~~107566~~) operation to query the desired values of properties of the device. In this case, the QueryDeviceDesiredProperty operation returns the **Identifier** parameter instead of the **Value** parameter.
    * ## QPS limits
    * You can call this API operation up to 50 times per second per account. 
    * >  The RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request ClearDeviceDesiredPropertyRequest
    * @return ClearDeviceDesiredPropertyResponse
   */
  async clearDeviceDesiredProperty(request: ClearDeviceDesiredPropertyRequest): Promise<ClearDeviceDesiredPropertyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.clearDeviceDesiredPropertyWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request ClearEdgeInstanceDriverConfigsRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return ClearEdgeInstanceDriverConfigsResponse
   */
  async clearEdgeInstanceDriverConfigsWithOptions(request: ClearEdgeInstanceDriverConfigsRequest, runtime: $Util.RuntimeOptions): Promise<ClearEdgeInstanceDriverConfigsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.driverId)) {
      query["DriverId"] = request.driverId;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ClearEdgeInstanceDriverConfigs",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ClearEdgeInstanceDriverConfigsResponse>(await this.callApi(params, req, runtime), new ClearEdgeInstanceDriverConfigsResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request ClearEdgeInstanceDriverConfigsRequest
    * @return ClearEdgeInstanceDriverConfigsResponse
   */
  async clearEdgeInstanceDriverConfigs(request: ClearEdgeInstanceDriverConfigsRequest): Promise<ClearEdgeInstanceDriverConfigsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.clearEdgeInstanceDriverConfigsWithOptions(request, runtime);
  }

  async closeDeviceTunnelWithOptions(request: CloseDeviceTunnelRequest, runtime: $Util.RuntimeOptions): Promise<CloseDeviceTunnelResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.tunnelId)) {
      query["TunnelId"] = request.tunnelId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CloseDeviceTunnel",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CloseDeviceTunnelResponse>(await this.callApi(params, req, runtime), new CloseDeviceTunnelResponse({}));
  }

  async closeDeviceTunnel(request: CloseDeviceTunnelRequest): Promise<CloseDeviceTunnelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.closeDeviceTunnelWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of five queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request CloseEdgeInstanceDeploymentRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return CloseEdgeInstanceDeploymentResponse
   */
  async closeEdgeInstanceDeploymentWithOptions(request: CloseEdgeInstanceDeploymentRequest, runtime: $Util.RuntimeOptions): Promise<CloseEdgeInstanceDeploymentResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CloseEdgeInstanceDeployment",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CloseEdgeInstanceDeploymentResponse>(await this.callApi(params, req, runtime), new CloseEdgeInstanceDeploymentResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of five queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request CloseEdgeInstanceDeploymentRequest
    * @return CloseEdgeInstanceDeploymentResponse
   */
  async closeEdgeInstanceDeployment(request: CloseEdgeInstanceDeploymentRequest): Promise<CloseEdgeInstanceDeploymentResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.closeEdgeInstanceDeploymentWithOptions(request, runtime);
  }

  /**
    * To confirm update tasks in a scheduled update batch, you must call this operation within the specified time range.
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 20 queries per second (QPS). 
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request ConfirmOTATaskRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return ConfirmOTATaskResponse
   */
  async confirmOTATaskWithOptions(request: ConfirmOTATaskRequest, runtime: $Util.RuntimeOptions): Promise<ConfirmOTATaskResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.taskId)) {
      query["TaskId"] = request.taskId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ConfirmOTATask",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ConfirmOTATaskResponse>(await this.callApi(params, req, runtime), new ConfirmOTATaskResponse({}));
  }

  /**
    * To confirm update tasks in a scheduled update batch, you must call this operation within the specified time range.
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 20 queries per second (QPS). 
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request ConfirmOTATaskRequest
    * @return ConfirmOTATaskResponse
   */
  async confirmOTATask(request: ConfirmOTATaskRequest): Promise<ConfirmOTATaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.confirmOTATaskWithOptions(request, runtime);
  }

  /**
    * *   If a destination product is published, you must call the [CancelReleaseProduct](~~213875~~) operation to unpublish the product before you can copy a TSL model.
    * *   The categories of the source product and destination product must be the same. The product category is indicated by the **CategoryKey** parameter. You can call the [QueryProduct](~~69272~~) operation and view the **CategoryKey** parameter of a product in the returned result.
    * *   You must specify the version of the TSL model that you want to copy by using the **SourceModelVersion** parameter in the request. Otherwise, the CopyThingModel operation fails.
    * ## QPS limits
    * Each Alibaba Cloud account can run up to five queries per second (QPS). 
    * >  The Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request CopyThingModelRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return CopyThingModelResponse
   */
  async copyThingModelWithOptions(request: CopyThingModelRequest, runtime: $Util.RuntimeOptions): Promise<CopyThingModelResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.sourceModelVersion)) {
      query["SourceModelVersion"] = request.sourceModelVersion;
    }

    if (!Util.isUnset(request.sourceProductKey)) {
      query["SourceProductKey"] = request.sourceProductKey;
    }

    if (!Util.isUnset(request.targetProductKey)) {
      query["TargetProductKey"] = request.targetProductKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CopyThingModel",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CopyThingModelResponse>(await this.callApi(params, req, runtime), new CopyThingModelResponse({}));
  }

  /**
    * *   If a destination product is published, you must call the [CancelReleaseProduct](~~213875~~) operation to unpublish the product before you can copy a TSL model.
    * *   The categories of the source product and destination product must be the same. The product category is indicated by the **CategoryKey** parameter. You can call the [QueryProduct](~~69272~~) operation and view the **CategoryKey** parameter of a product in the returned result.
    * *   You must specify the version of the TSL model that you want to copy by using the **SourceModelVersion** parameter in the request. Otherwise, the CopyThingModel operation fails.
    * ## QPS limits
    * Each Alibaba Cloud account can run up to five queries per second (QPS). 
    * >  The Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request CopyThingModelRequest
    * @return CopyThingModelResponse
   */
  async copyThingModel(request: CopyThingModelRequest): Promise<CopyThingModelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.copyThingModelWithOptions(request, runtime);
  }

  async countSpeechBroadcastHourWithOptions(request: CountSpeechBroadcastHourRequest, runtime: $Util.RuntimeOptions): Promise<CountSpeechBroadcastHourResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.queryDateTimeHour)) {
      query["QueryDateTimeHour"] = request.queryDateTimeHour;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      body["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.shareTaskCode)) {
      body["ShareTaskCode"] = request.shareTaskCode;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CountSpeechBroadcastHour",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CountSpeechBroadcastHourResponse>(await this.callApi(params, req, runtime), new CountSpeechBroadcastHourResponse({}));
  }

  async countSpeechBroadcastHour(request: CountSpeechBroadcastHourRequest): Promise<CountSpeechBroadcastHourResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.countSpeechBroadcastHourWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request CreateConsumerGroupRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return CreateConsumerGroupResponse
   */
  async createConsumerGroupWithOptions(request: CreateConsumerGroupRequest, runtime: $Util.RuntimeOptions): Promise<CreateConsumerGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupName)) {
      query["GroupName"] = request.groupName;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.subBizCode)) {
      query["SubBizCode"] = request.subBizCode;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateConsumerGroup",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateConsumerGroupResponse>(await this.callApi(params, req, runtime), new CreateConsumerGroupResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request CreateConsumerGroupRequest
    * @return CreateConsumerGroupResponse
   */
  async createConsumerGroup(request: CreateConsumerGroupRequest): Promise<CreateConsumerGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createConsumerGroupWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request CreateConsumerGroupSubscribeRelationRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return CreateConsumerGroupSubscribeRelationResponse
   */
  async createConsumerGroupSubscribeRelationWithOptions(request: CreateConsumerGroupSubscribeRelationRequest, runtime: $Util.RuntimeOptions): Promise<CreateConsumerGroupSubscribeRelationResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.consumerGroupId)) {
      query["ConsumerGroupId"] = request.consumerGroupId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateConsumerGroupSubscribeRelation",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateConsumerGroupSubscribeRelationResponse>(await this.callApi(params, req, runtime), new CreateConsumerGroupSubscribeRelationResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request CreateConsumerGroupSubscribeRelationRequest
    * @return CreateConsumerGroupSubscribeRelationResponse
   */
  async createConsumerGroupSubscribeRelation(request: CreateConsumerGroupSubscribeRelationRequest): Promise<CreateConsumerGroupSubscribeRelationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createConsumerGroupSubscribeRelationWithOptions(request, runtime);
  }

  async createDataAPIServiceWithOptions(request: CreateDataAPIServiceRequest, runtime: $Util.RuntimeOptions): Promise<CreateDataAPIServiceResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.apiPath)) {
      body["ApiPath"] = request.apiPath;
    }

    if (!Util.isUnset(request.desc)) {
      body["Desc"] = request.desc;
    }

    if (!Util.isUnset(request.displayName)) {
      body["DisplayName"] = request.displayName;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      body["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.originSql)) {
      body["OriginSql"] = request.originSql;
    }

    if (!Util.isUnset(request.requestParam)) {
      body["RequestParam"] = request.requestParam;
    }

    if (!Util.isUnset(request.responseParam)) {
      body["ResponseParam"] = request.responseParam;
    }

    if (!Util.isUnset(request.templateSql)) {
      body["TemplateSql"] = request.templateSql;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateDataAPIService",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateDataAPIServiceResponse>(await this.callApi(params, req, runtime), new CreateDataAPIServiceResponse({}));
  }

  async createDataAPIService(request: CreateDataAPIServiceRequest): Promise<CreateDataAPIServiceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createDataAPIServiceWithOptions(request, runtime);
  }

  async createDataSourceItemWithOptions(request: CreateDataSourceItemRequest, runtime: $Util.RuntimeOptions): Promise<CreateDataSourceItemResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dataSourceId)) {
      query["DataSourceId"] = request.dataSourceId;
    }

    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.scopeType)) {
      query["ScopeType"] = request.scopeType;
    }

    if (!Util.isUnset(request.topic)) {
      query["Topic"] = request.topic;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateDataSourceItem",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateDataSourceItemResponse>(await this.callApi(params, req, runtime), new CreateDataSourceItemResponse({}));
  }

  async createDataSourceItem(request: CreateDataSourceItemRequest): Promise<CreateDataSourceItemResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createDataSourceItemWithOptions(request, runtime);
  }

  async createDestinationWithOptions(request: CreateDestinationRequest, runtime: $Util.RuntimeOptions): Promise<CreateDestinationResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.configuration)) {
      query["Configuration"] = request.configuration;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateDestination",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateDestinationResponse>(await this.callApi(params, req, runtime), new CreateDestinationResponse({}));
  }

  async createDestination(request: CreateDestinationRequest): Promise<CreateDestinationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createDestinationWithOptions(request, runtime);
  }

  /**
    * To distribute devices, perform the following steps:
    * 1\\. Asynchronously call this operation to create a device distribution task and obtain the **JobId** parameter.
    * 2\\. Use **JobId** as a request parameter and repeatedly call the [QueryDeviceDistributeJob](~~199536~~) operation to obtain the **Status** parameter.
    * >  You must control the frequency of calls based on the QPS limit of the QueryDeviceDistributeJob operation.
    * If either of the following values is returned for the **Status** parameter, the distribution task ends:
    * *   **2**: The device distribution task is completed. This return value does not indicate that the devices are distributed. To obtain the distribution result of each device, perform the next step.
    * *   **3**: The distribution is unexpectedly interrupted. After you process the error, you can initiate a device distribution task again.
    * 3\\. Use **JobId** that is returned in Step 1 as a request parameter and call the [QueryDeviceDistributeDetail](~~199533~~) operation to obtain the **File** parameter. The File parameter indicates the file URL of the distribution result.
    * >  The file URL is valid for 10 minutes.
    * 4\\. Obtain the distribution result by using the file URL. The **Code** parameter indicates whether a device is distributed. If the value of the **Code** parameter is 200, the device is distributed.
    * If the distribution fails, you can perform the preceding steps to distribute devices again.
    * ## Limits
    * - This operation can be called only by using the following **endpoint**: `iot.cn-shanghai.aliyuncs.com`.
    * - You cannot call this operation to distribute devices across accounts.
    * - Each Alibaba Cloud account can create a maximum of 10 tasks to distribute products or devices. For more information about how to create a product distribution task, see [CreateProductDistributeJob](/help/en/iot-platform/latest/createproductdistributejob).
    * - Each Alibaba Cloud account can run a maximum of 2 queries per second (QPS).  >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request CreateDeviceDistributeJobRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return CreateDeviceDistributeJobResponse
   */
  async createDeviceDistributeJobWithOptions(request: CreateDeviceDistributeJobRequest, runtime: $Util.RuntimeOptions): Promise<CreateDeviceDistributeJobResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.deviceName)) {
      body["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.productKey)) {
      body["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.sourceInstanceId)) {
      body["SourceInstanceId"] = request.sourceInstanceId;
    }

    if (!Util.isUnset(request.strategy)) {
      body["Strategy"] = request.strategy;
    }

    if (!Util.isUnset(request.targetAliyunId)) {
      body["TargetAliyunId"] = request.targetAliyunId;
    }

    if (!Util.isUnset(request.targetInstanceConfig)) {
      body["TargetInstanceConfig"] = request.targetInstanceConfig;
    }

    if (!Util.isUnset(request.targetUid)) {
      body["TargetUid"] = request.targetUid;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateDeviceDistributeJob",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateDeviceDistributeJobResponse>(await this.callApi(params, req, runtime), new CreateDeviceDistributeJobResponse({}));
  }

  /**
    * To distribute devices, perform the following steps:
    * 1\\. Asynchronously call this operation to create a device distribution task and obtain the **JobId** parameter.
    * 2\\. Use **JobId** as a request parameter and repeatedly call the [QueryDeviceDistributeJob](~~199536~~) operation to obtain the **Status** parameter.
    * >  You must control the frequency of calls based on the QPS limit of the QueryDeviceDistributeJob operation.
    * If either of the following values is returned for the **Status** parameter, the distribution task ends:
    * *   **2**: The device distribution task is completed. This return value does not indicate that the devices are distributed. To obtain the distribution result of each device, perform the next step.
    * *   **3**: The distribution is unexpectedly interrupted. After you process the error, you can initiate a device distribution task again.
    * 3\\. Use **JobId** that is returned in Step 1 as a request parameter and call the [QueryDeviceDistributeDetail](~~199533~~) operation to obtain the **File** parameter. The File parameter indicates the file URL of the distribution result.
    * >  The file URL is valid for 10 minutes.
    * 4\\. Obtain the distribution result by using the file URL. The **Code** parameter indicates whether a device is distributed. If the value of the **Code** parameter is 200, the device is distributed.
    * If the distribution fails, you can perform the preceding steps to distribute devices again.
    * ## Limits
    * - This operation can be called only by using the following **endpoint**: `iot.cn-shanghai.aliyuncs.com`.
    * - You cannot call this operation to distribute devices across accounts.
    * - Each Alibaba Cloud account can create a maximum of 10 tasks to distribute products or devices. For more information about how to create a product distribution task, see [CreateProductDistributeJob](/help/en/iot-platform/latest/createproductdistributejob).
    * - Each Alibaba Cloud account can run a maximum of 2 queries per second (QPS).  >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request CreateDeviceDistributeJobRequest
    * @return CreateDeviceDistributeJobResponse
   */
  async createDeviceDistributeJob(request: CreateDeviceDistributeJobRequest): Promise<CreateDeviceDistributeJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createDeviceDistributeJobWithOptions(request, runtime);
  }

  async createDeviceDynamicGroupWithOptions(request: CreateDeviceDynamicGroupRequest, runtime: $Util.RuntimeOptions): Promise<CreateDeviceDynamicGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dynamicGroupExpression)) {
      query["DynamicGroupExpression"] = request.dynamicGroupExpression;
    }

    if (!Util.isUnset(request.groupDesc)) {
      query["GroupDesc"] = request.groupDesc;
    }

    if (!Util.isUnset(request.groupName)) {
      query["GroupName"] = request.groupName;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateDeviceDynamicGroup",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateDeviceDynamicGroupResponse>(await this.callApi(params, req, runtime), new CreateDeviceDynamicGroupResponse({}));
  }

  async createDeviceDynamicGroup(request: CreateDeviceDynamicGroupRequest): Promise<CreateDeviceDynamicGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createDeviceDynamicGroupWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request CreateDeviceGroupRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return CreateDeviceGroupResponse
   */
  async createDeviceGroupWithOptions(request: CreateDeviceGroupRequest, runtime: $Util.RuntimeOptions): Promise<CreateDeviceGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupDesc)) {
      query["GroupDesc"] = request.groupDesc;
    }

    if (!Util.isUnset(request.groupName)) {
      query["GroupName"] = request.groupName;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.superGroupId)) {
      query["SuperGroupId"] = request.superGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateDeviceGroup",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateDeviceGroupResponse>(await this.callApi(params, req, runtime), new CreateDeviceGroupResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request CreateDeviceGroupRequest
    * @return CreateDeviceGroupResponse
   */
  async createDeviceGroup(request: CreateDeviceGroupRequest): Promise<CreateDeviceGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createDeviceGroupWithOptions(request, runtime);
  }

  async createDeviceTunnelWithOptions(request: CreateDeviceTunnelRequest, runtime: $Util.RuntimeOptions): Promise<CreateDeviceTunnelResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotId)) {
      query["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.udi)) {
      query["Udi"] = request.udi;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateDeviceTunnel",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateDeviceTunnelResponse>(await this.callApi(params, req, runtime), new CreateDeviceTunnelResponse({}));
  }

  async createDeviceTunnel(request: CreateDeviceTunnelRequest): Promise<CreateDeviceTunnelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createDeviceTunnelWithOptions(request, runtime);
  }

  async createDownloadDataJobWithOptions(tmpReq: CreateDownloadDataJobRequest, runtime: $Util.RuntimeOptions): Promise<CreateDownloadDataJobResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateDownloadDataJobShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.fileConfig)) {
      request.fileConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.fileConfig, "FileConfig", "json");
    }

    let query = { };
    if (!Util.isUnset(request.downloadDataType)) {
      query["DownloadDataType"] = request.downloadDataType;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.fileConfigShrink)) {
      query["FileConfig"] = request.fileConfigShrink;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.tableName)) {
      query["TableName"] = request.tableName;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      body["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateDownloadDataJob",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateDownloadDataJobResponse>(await this.callApi(params, req, runtime), new CreateDownloadDataJobResponse({}));
  }

  async createDownloadDataJob(request: CreateDownloadDataJobRequest): Promise<CreateDownloadDataJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createDownloadDataJobWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * A single Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
    * >  RAM users share the quota of the Alibaba Cloud account.
    *
    * @param request CreateEdgeDriverRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return CreateEdgeDriverResponse
   */
  async createEdgeDriverWithOptions(request: CreateEdgeDriverRequest, runtime: $Util.RuntimeOptions): Promise<CreateEdgeDriverResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.cpuArch)) {
      query["CpuArch"] = request.cpuArch;
    }

    if (!Util.isUnset(request.driverName)) {
      query["DriverName"] = request.driverName;
    }

    if (!Util.isUnset(request.driverProtocol)) {
      query["DriverProtocol"] = request.driverProtocol;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.isBuiltIn)) {
      query["IsBuiltIn"] = request.isBuiltIn;
    }

    if (!Util.isUnset(request.runtime)) {
      query["Runtime"] = request.runtime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateEdgeDriver",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateEdgeDriverResponse>(await this.callApi(params, req, runtime), new CreateEdgeDriverResponse({}));
  }

  /**
    * ## Limits
    * A single Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
    * >  RAM users share the quota of the Alibaba Cloud account.
    *
    * @param request CreateEdgeDriverRequest
    * @return CreateEdgeDriverResponse
   */
  async createEdgeDriver(request: CreateEdgeDriverRequest): Promise<CreateEdgeDriverResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createEdgeDriverWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request CreateEdgeDriverVersionRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return CreateEdgeDriverVersionResponse
   */
  async createEdgeDriverVersionWithOptions(request: CreateEdgeDriverVersionRequest, runtime: $Util.RuntimeOptions): Promise<CreateEdgeDriverVersionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.argument)) {
      query["Argument"] = request.argument;
    }

    if (!Util.isUnset(request.configCheckRule)) {
      query["ConfigCheckRule"] = request.configCheckRule;
    }

    if (!Util.isUnset(request.containerConfig)) {
      query["ContainerConfig"] = request.containerConfig;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.driverConfig)) {
      query["DriverConfig"] = request.driverConfig;
    }

    if (!Util.isUnset(request.driverId)) {
      query["DriverId"] = request.driverId;
    }

    if (!Util.isUnset(request.driverVersion)) {
      query["DriverVersion"] = request.driverVersion;
    }

    if (!Util.isUnset(request.edgeVersion)) {
      query["EdgeVersion"] = request.edgeVersion;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.sourceConfig)) {
      query["SourceConfig"] = request.sourceConfig;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateEdgeDriverVersion",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateEdgeDriverVersionResponse>(await this.callApi(params, req, runtime), new CreateEdgeDriverVersionResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request CreateEdgeDriverVersionRequest
    * @return CreateEdgeDriverVersionResponse
   */
  async createEdgeDriverVersion(request: CreateEdgeDriverVersionRequest): Promise<CreateEdgeDriverVersionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createEdgeDriverVersionWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * A single Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
    * >  RAM users share the quota of the Alibaba Cloud account.
    *
    * @param request CreateEdgeInstanceRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return CreateEdgeInstanceResponse
   */
  async createEdgeInstanceWithOptions(request: CreateEdgeInstanceRequest, runtime: $Util.RuntimeOptions): Promise<CreateEdgeInstanceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.spec)) {
      query["Spec"] = request.spec;
    }

    if (!Util.isUnset(request.tags)) {
      query["Tags"] = request.tags;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateEdgeInstance",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateEdgeInstanceResponse>(await this.callApi(params, req, runtime), new CreateEdgeInstanceResponse({}));
  }

  /**
    * ## Limits
    * A single Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
    * >  RAM users share the quota of the Alibaba Cloud account.
    *
    * @param request CreateEdgeInstanceRequest
    * @return CreateEdgeInstanceResponse
   */
  async createEdgeInstance(request: CreateEdgeInstanceRequest): Promise<CreateEdgeInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createEdgeInstanceWithOptions(request, runtime);
  }

  async createEdgeInstanceChannelWithOptions(request: CreateEdgeInstanceChannelRequest, runtime: $Util.RuntimeOptions): Promise<CreateEdgeInstanceChannelResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.channelName)) {
      query["ChannelName"] = request.channelName;
    }

    if (!Util.isUnset(request.configs)) {
      query["Configs"] = request.configs;
    }

    if (!Util.isUnset(request.driverId)) {
      query["DriverId"] = request.driverId;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateEdgeInstanceChannel",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateEdgeInstanceChannelResponse>(await this.callApi(params, req, runtime), new CreateEdgeInstanceChannelResponse({}));
  }

  async createEdgeInstanceChannel(request: CreateEdgeInstanceChannelRequest): Promise<CreateEdgeInstanceChannelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createEdgeInstanceChannelWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of five queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request CreateEdgeInstanceDeploymentRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return CreateEdgeInstanceDeploymentResponse
   */
  async createEdgeInstanceDeploymentWithOptions(request: CreateEdgeInstanceDeploymentRequest, runtime: $Util.RuntimeOptions): Promise<CreateEdgeInstanceDeploymentResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateEdgeInstanceDeployment",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateEdgeInstanceDeploymentResponse>(await this.callApi(params, req, runtime), new CreateEdgeInstanceDeploymentResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of five queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request CreateEdgeInstanceDeploymentRequest
    * @return CreateEdgeInstanceDeploymentResponse
   */
  async createEdgeInstanceDeployment(request: CreateEdgeInstanceDeploymentRequest): Promise<CreateEdgeInstanceDeploymentResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createEdgeInstanceDeploymentWithOptions(request, runtime);
  }

  async createEdgeInstanceMessageRoutingWithOptions(request: CreateEdgeInstanceMessageRoutingRequest, runtime: $Util.RuntimeOptions): Promise<CreateEdgeInstanceMessageRoutingResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.sourceData)) {
      query["SourceData"] = request.sourceData;
    }

    if (!Util.isUnset(request.sourceType)) {
      query["SourceType"] = request.sourceType;
    }

    if (!Util.isUnset(request.targetData)) {
      query["TargetData"] = request.targetData;
    }

    if (!Util.isUnset(request.targetIotHubQos)) {
      query["TargetIotHubQos"] = request.targetIotHubQos;
    }

    if (!Util.isUnset(request.targetType)) {
      query["TargetType"] = request.targetType;
    }

    if (!Util.isUnset(request.topicFilter)) {
      query["TopicFilter"] = request.topicFilter;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateEdgeInstanceMessageRouting",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateEdgeInstanceMessageRoutingResponse>(await this.callApi(params, req, runtime), new CreateEdgeInstanceMessageRoutingResponse({}));
  }

  async createEdgeInstanceMessageRouting(request: CreateEdgeInstanceMessageRoutingRequest): Promise<CreateEdgeInstanceMessageRoutingResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createEdgeInstanceMessageRoutingWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of five queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request CreateEdgeOssPreSignedAddressRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return CreateEdgeOssPreSignedAddressResponse
   */
  async createEdgeOssPreSignedAddressWithOptions(request: CreateEdgeOssPreSignedAddressRequest, runtime: $Util.RuntimeOptions): Promise<CreateEdgeOssPreSignedAddressResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.fileName)) {
      query["FileName"] = request.fileName;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.resourceId)) {
      query["ResourceId"] = request.resourceId;
    }

    if (!Util.isUnset(request.resourceVersion)) {
      query["ResourceVersion"] = request.resourceVersion;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateEdgeOssPreSignedAddress",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateEdgeOssPreSignedAddressResponse>(await this.callApi(params, req, runtime), new CreateEdgeOssPreSignedAddressResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of five queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request CreateEdgeOssPreSignedAddressRequest
    * @return CreateEdgeOssPreSignedAddressResponse
   */
  async createEdgeOssPreSignedAddress(request: CreateEdgeOssPreSignedAddressRequest): Promise<CreateEdgeOssPreSignedAddressResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createEdgeOssPreSignedAddressWithOptions(request, runtime);
  }

  async createJobWithOptions(tmpReq: CreateJobRequest, runtime: $Util.RuntimeOptions): Promise<CreateJobResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateJobShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.jobFile)) {
      request.jobFileShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.jobFile, "JobFile", "json");
    }

    if (!Util.isUnset(tmpReq.rolloutConfig)) {
      request.rolloutConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.rolloutConfig, "RolloutConfig", "json");
    }

    if (!Util.isUnset(tmpReq.targetConfig)) {
      request.targetConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.targetConfig, "TargetConfig", "json");
    }

    if (!Util.isUnset(tmpReq.timeoutConfig)) {
      request.timeoutConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.timeoutConfig, "TimeoutConfig", "json");
    }

    let query = { };
    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.jobDocument)) {
      query["JobDocument"] = request.jobDocument;
    }

    if (!Util.isUnset(request.jobFileShrink)) {
      query["JobFile"] = request.jobFileShrink;
    }

    if (!Util.isUnset(request.jobName)) {
      query["JobName"] = request.jobName;
    }

    if (!Util.isUnset(request.rolloutConfigShrink)) {
      query["RolloutConfig"] = request.rolloutConfigShrink;
    }

    if (!Util.isUnset(request.scheduledTime)) {
      query["ScheduledTime"] = request.scheduledTime;
    }

    if (!Util.isUnset(request.targetConfigShrink)) {
      query["TargetConfig"] = request.targetConfigShrink;
    }

    if (!Util.isUnset(request.timeoutConfigShrink)) {
      query["TimeoutConfig"] = request.timeoutConfigShrink;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateJob",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateJobResponse>(await this.callApi(params, req, runtime), new CreateJobResponse({}));
  }

  async createJob(request: CreateJobRequest): Promise<CreateJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createJobWithOptions(request, runtime);
  }

  async createLoRaNodesTaskWithOptions(request: CreateLoRaNodesTaskRequest, runtime: $Util.RuntimeOptions): Promise<CreateLoRaNodesTaskResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceInfo)) {
      query["DeviceInfo"] = request.deviceInfo;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateLoRaNodesTask",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateLoRaNodesTaskResponse>(await this.callApi(params, req, runtime), new CreateLoRaNodesTaskResponse({}));
  }

  async createLoRaNodesTask(request: CreateLoRaNodesTaskRequest): Promise<CreateLoRaNodesTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createLoRaNodesTaskWithOptions(request, runtime);
  }

  /**
    * In addition to the preceding operation-specific request parameters, you must specify common request parameters when you call this operation. For more information, see [Common parameters](~~30561~~).
    *
    * @param request CreateOTADynamicUpgradeJobRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return CreateOTADynamicUpgradeJobResponse
   */
  async createOTADynamicUpgradeJobWithOptions(request: CreateOTADynamicUpgradeJobRequest, runtime: $Util.RuntimeOptions): Promise<CreateOTADynamicUpgradeJobResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.downloadProtocol)) {
      query["DownloadProtocol"] = request.downloadProtocol;
    }

    if (!Util.isUnset(request.dynamicMode)) {
      query["DynamicMode"] = request.dynamicMode;
    }

    if (!Util.isUnset(request.firmwareId)) {
      query["FirmwareId"] = request.firmwareId;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.groupType)) {
      query["GroupType"] = request.groupType;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.maximumPerMinute)) {
      query["MaximumPerMinute"] = request.maximumPerMinute;
    }

    if (!Util.isUnset(request.multiModuleMode)) {
      query["MultiModuleMode"] = request.multiModuleMode;
    }

    if (!Util.isUnset(request.needConfirm)) {
      query["NeedConfirm"] = request.needConfirm;
    }

    if (!Util.isUnset(request.needPush)) {
      query["NeedPush"] = request.needPush;
    }

    if (!Util.isUnset(request.overwriteMode)) {
      query["OverwriteMode"] = request.overwriteMode;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.retryCount)) {
      query["RetryCount"] = request.retryCount;
    }

    if (!Util.isUnset(request.retryInterval)) {
      query["RetryInterval"] = request.retryInterval;
    }

    if (!Util.isUnset(request.srcVersion)) {
      query["SrcVersion"] = request.srcVersion;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    if (!Util.isUnset(request.timeoutInMinutes)) {
      query["TimeoutInMinutes"] = request.timeoutInMinutes;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateOTADynamicUpgradeJob",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateOTADynamicUpgradeJobResponse>(await this.callApi(params, req, runtime), new CreateOTADynamicUpgradeJobResponse({}));
  }

  /**
    * In addition to the preceding operation-specific request parameters, you must specify common request parameters when you call this operation. For more information, see [Common parameters](~~30561~~).
    *
    * @param request CreateOTADynamicUpgradeJobRequest
    * @return CreateOTADynamicUpgradeJobResponse
   */
  async createOTADynamicUpgradeJob(request: CreateOTADynamicUpgradeJobRequest): Promise<CreateOTADynamicUpgradeJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createOTADynamicUpgradeJobWithOptions(request, runtime);
  }

  /**
    * Before you call this operation to create an OTA update package, you must call the [GenerateOTAUploadURL](~~147310~~) operation to generate the information about the files that you want to add to the OTA update package and call the Object Storage Service (OSS) [PostObject](~~31988~~) operation to upload the files.
    * ## Limits
    * Each Alibaba Cloud account can have up to 500 update packages. 
    * ## QPS limits
    * You can call this API operation up to 10 times per second per account. 
    * >  The RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request CreateOTAFirmwareRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return CreateOTAFirmwareResponse
   */
  async createOTAFirmwareWithOptions(request: CreateOTAFirmwareRequest, runtime: $Util.RuntimeOptions): Promise<CreateOTAFirmwareResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.destVersion)) {
      query["DestVersion"] = request.destVersion;
    }

    if (!Util.isUnset(request.firmwareDesc)) {
      query["FirmwareDesc"] = request.firmwareDesc;
    }

    if (!Util.isUnset(request.firmwareName)) {
      query["FirmwareName"] = request.firmwareName;
    }

    if (!Util.isUnset(request.firmwareSign)) {
      query["FirmwareSign"] = request.firmwareSign;
    }

    if (!Util.isUnset(request.firmwareSize)) {
      query["FirmwareSize"] = request.firmwareSize;
    }

    if (!Util.isUnset(request.firmwareUrl)) {
      query["FirmwareUrl"] = request.firmwareUrl;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.moduleName)) {
      query["ModuleName"] = request.moduleName;
    }

    if (!Util.isUnset(request.multiFiles)) {
      query["MultiFiles"] = request.multiFiles;
    }

    if (!Util.isUnset(request.needToVerify)) {
      query["NeedToVerify"] = request.needToVerify;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.signMethod)) {
      query["SignMethod"] = request.signMethod;
    }

    if (!Util.isUnset(request.srcVersion)) {
      query["SrcVersion"] = request.srcVersion;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    if (!Util.isUnset(request.udi)) {
      query["Udi"] = request.udi;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateOTAFirmware",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateOTAFirmwareResponse>(await this.callApi(params, req, runtime), new CreateOTAFirmwareResponse({}));
  }

  /**
    * Before you call this operation to create an OTA update package, you must call the [GenerateOTAUploadURL](~~147310~~) operation to generate the information about the files that you want to add to the OTA update package and call the Object Storage Service (OSS) [PostObject](~~31988~~) operation to upload the files.
    * ## Limits
    * Each Alibaba Cloud account can have up to 500 update packages. 
    * ## QPS limits
    * You can call this API operation up to 10 times per second per account. 
    * >  The RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request CreateOTAFirmwareRequest
    * @return CreateOTAFirmwareResponse
   */
  async createOTAFirmware(request: CreateOTAFirmwareRequest): Promise<CreateOTAFirmwareResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createOTAFirmwareWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * OTA modules are the updatable units of the devices that belong to the same product. The default module indicates the entire firmware of a device. You can call this operation to create a custom OTA module.
    * *   You can create a maximum of 10 custom OTA modules for each product.
    * *   After an OTA module is created, you cannot modify its name. You can call the [UpdateOTAModule](~~186061~~) operation to modify the module alias and description.
    * *   Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
    * > RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request CreateOTAModuleRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return CreateOTAModuleResponse
   */
  async createOTAModuleWithOptions(request: CreateOTAModuleRequest, runtime: $Util.RuntimeOptions): Promise<CreateOTAModuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.aliasName)) {
      query["AliasName"] = request.aliasName;
    }

    if (!Util.isUnset(request.desc)) {
      query["Desc"] = request.desc;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.moduleName)) {
      query["ModuleName"] = request.moduleName;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateOTAModule",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateOTAModuleResponse>(await this.callApi(params, req, runtime), new CreateOTAModuleResponse({}));
  }

  /**
    * ## Limits
    * OTA modules are the updatable units of the devices that belong to the same product. The default module indicates the entire firmware of a device. You can call this operation to create a custom OTA module.
    * *   You can create a maximum of 10 custom OTA modules for each product.
    * *   After an OTA module is created, you cannot modify its name. You can call the [UpdateOTAModule](~~186061~~) operation to modify the module alias and description.
    * *   Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
    * > RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request CreateOTAModuleRequest
    * @return CreateOTAModuleResponse
   */
  async createOTAModule(request: CreateOTAModuleRequest): Promise<CreateOTAModuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createOTAModuleWithOptions(request, runtime);
  }

  /**
    * *   If you specify that an update package does not need to be verified when you call the [CreateOTAFirmware](~~147311~~) operation, you must make sure that the update package is verified before you call the CreateOTAStaticUpgradeJob operation to create an update batch. For more information about how to create a task to verify an update package, see [CreateOTAVerifyJob](~~147480~~).
    * *   You can initiate update tasks for a maximum of 200 devices in each call. If you use a device list file, you can initiate update tasks for a maximum of 1,000,000 devices. However, you must call the [GenerateDeviceNameListURL](~~186062~~) operation to generate a URL for the device list file. Then, you can perform the operations as prompted to upload the device list file.
    * *   When you initiate update tasks for multiple devices, the devices that already have the destination firmware versions are skipped.
    * *   Each device can be in the pending or updating status only in one update task. If you initiate another update task for a device that is in the pending or updating status, the update task fails.
    * *   You can create multiple static update batches by using a single update package.
    * *   Downloading update packages through the MQTT protocol is supported only in the China (Shanghai) region.
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 20 queries per second (QPS). 
    * >  The Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request CreateOTAStaticUpgradeJobRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return CreateOTAStaticUpgradeJobResponse
   */
  async createOTAStaticUpgradeJobWithOptions(request: CreateOTAStaticUpgradeJobRequest, runtime: $Util.RuntimeOptions): Promise<CreateOTAStaticUpgradeJobResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dnListFileUrl)) {
      query["DnListFileUrl"] = request.dnListFileUrl;
    }

    if (!Util.isUnset(request.downloadProtocol)) {
      query["DownloadProtocol"] = request.downloadProtocol;
    }

    if (!Util.isUnset(request.firmwareId)) {
      query["FirmwareId"] = request.firmwareId;
    }

    if (!Util.isUnset(request.grayPercent)) {
      query["GrayPercent"] = request.grayPercent;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.groupType)) {
      query["GroupType"] = request.groupType;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.maximumPerMinute)) {
      query["MaximumPerMinute"] = request.maximumPerMinute;
    }

    if (!Util.isUnset(request.multiModuleMode)) {
      query["MultiModuleMode"] = request.multiModuleMode;
    }

    if (!Util.isUnset(request.needConfirm)) {
      query["NeedConfirm"] = request.needConfirm;
    }

    if (!Util.isUnset(request.needPush)) {
      query["NeedPush"] = request.needPush;
    }

    if (!Util.isUnset(request.overwriteMode)) {
      query["OverwriteMode"] = request.overwriteMode;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.retryCount)) {
      query["RetryCount"] = request.retryCount;
    }

    if (!Util.isUnset(request.retryInterval)) {
      query["RetryInterval"] = request.retryInterval;
    }

    if (!Util.isUnset(request.scheduleFinishTime)) {
      query["ScheduleFinishTime"] = request.scheduleFinishTime;
    }

    if (!Util.isUnset(request.scheduleTime)) {
      query["ScheduleTime"] = request.scheduleTime;
    }

    if (!Util.isUnset(request.srcVersion)) {
      query["SrcVersion"] = request.srcVersion;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    if (!Util.isUnset(request.targetDeviceName)) {
      query["TargetDeviceName"] = request.targetDeviceName;
    }

    if (!Util.isUnset(request.targetSelection)) {
      query["TargetSelection"] = request.targetSelection;
    }

    if (!Util.isUnset(request.timeoutInMinutes)) {
      query["TimeoutInMinutes"] = request.timeoutInMinutes;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateOTAStaticUpgradeJob",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateOTAStaticUpgradeJobResponse>(await this.callApi(params, req, runtime), new CreateOTAStaticUpgradeJobResponse({}));
  }

  /**
    * *   If you specify that an update package does not need to be verified when you call the [CreateOTAFirmware](~~147311~~) operation, you must make sure that the update package is verified before you call the CreateOTAStaticUpgradeJob operation to create an update batch. For more information about how to create a task to verify an update package, see [CreateOTAVerifyJob](~~147480~~).
    * *   You can initiate update tasks for a maximum of 200 devices in each call. If you use a device list file, you can initiate update tasks for a maximum of 1,000,000 devices. However, you must call the [GenerateDeviceNameListURL](~~186062~~) operation to generate a URL for the device list file. Then, you can perform the operations as prompted to upload the device list file.
    * *   When you initiate update tasks for multiple devices, the devices that already have the destination firmware versions are skipped.
    * *   Each device can be in the pending or updating status only in one update task. If you initiate another update task for a device that is in the pending or updating status, the update task fails.
    * *   You can create multiple static update batches by using a single update package.
    * *   Downloading update packages through the MQTT protocol is supported only in the China (Shanghai) region.
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 20 queries per second (QPS). 
    * >  The Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request CreateOTAStaticUpgradeJobRequest
    * @return CreateOTAStaticUpgradeJobResponse
   */
  async createOTAStaticUpgradeJob(request: CreateOTAStaticUpgradeJobRequest): Promise<CreateOTAStaticUpgradeJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createOTAStaticUpgradeJobWithOptions(request, runtime);
  }

  /**
    * *   You must verify an update package before you push the package to devices for a batch update. Only verified update packages can be used to update devices in batches. You can call the [QueryOTAFirmware](~~147461~~) operation to view the status of a verification task.
    * *   You cannot initiate a verification task for an update package that is being verified or has been verified.
    * *   You can specify a maximum of 10 devices for a verification task.
    * ## QPS limits
    * Each Alibaba Cloud account can run up to 10 queries per second (QPS). 
    * >  The RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request CreateOTAVerifyJobRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return CreateOTAVerifyJobResponse
   */
  async createOTAVerifyJobWithOptions(request: CreateOTAVerifyJobRequest, runtime: $Util.RuntimeOptions): Promise<CreateOTAVerifyJobResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.downloadProtocol)) {
      query["DownloadProtocol"] = request.downloadProtocol;
    }

    if (!Util.isUnset(request.firmwareId)) {
      query["FirmwareId"] = request.firmwareId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.needConfirm)) {
      query["NeedConfirm"] = request.needConfirm;
    }

    if (!Util.isUnset(request.needPush)) {
      query["NeedPush"] = request.needPush;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    if (!Util.isUnset(request.targetDeviceName)) {
      query["TargetDeviceName"] = request.targetDeviceName;
    }

    if (!Util.isUnset(request.timeoutInMinutes)) {
      query["TimeoutInMinutes"] = request.timeoutInMinutes;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateOTAVerifyJob",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateOTAVerifyJobResponse>(await this.callApi(params, req, runtime), new CreateOTAVerifyJobResponse({}));
  }

  /**
    * *   You must verify an update package before you push the package to devices for a batch update. Only verified update packages can be used to update devices in batches. You can call the [QueryOTAFirmware](~~147461~~) operation to view the status of a verification task.
    * *   You cannot initiate a verification task for an update package that is being verified or has been verified.
    * *   You can specify a maximum of 10 devices for a verification task.
    * ## QPS limits
    * Each Alibaba Cloud account can run up to 10 queries per second (QPS). 
    * >  The RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request CreateOTAVerifyJobRequest
    * @return CreateOTAVerifyJobResponse
   */
  async createOTAVerifyJob(request: CreateOTAVerifyJobRequest): Promise<CreateOTAVerifyJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createOTAVerifyJobWithOptions(request, runtime);
  }

  async createParserWithOptions(request: CreateParserRequest, runtime: $Util.RuntimeOptions): Promise<CreateParserResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateParser",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateParserResponse>(await this.callApi(params, req, runtime), new CreateParserResponse({}));
  }

  async createParser(request: CreateParserRequest): Promise<CreateParserResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createParserWithOptions(request, runtime);
  }

  async createParserDataSourceWithOptions(request: CreateParserDataSourceRequest, runtime: $Util.RuntimeOptions): Promise<CreateParserDataSourceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateParserDataSource",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateParserDataSourceResponse>(await this.callApi(params, req, runtime), new CreateParserDataSourceResponse({}));
  }

  async createParserDataSource(request: CreateParserDataSourceRequest): Promise<CreateParserDataSourceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createParserDataSourceWithOptions(request, runtime);
  }

  /**
    * If a Thing Specification Language (TSL) model is required to create a product, you must set the **AliyunCommodityCode** parameter to iothub_senior and configure the **DataFormat** parameter.******** For more information, see the "**Request parameters**" section of this topic.
    * ## QPS limits
    * Each Alibaba Cloud account can run up to 50 queries per second (QPS). 
    * >  The RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request CreateProductRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return CreateProductResponse
   */
  async createProductWithOptions(request: CreateProductRequest, runtime: $Util.RuntimeOptions): Promise<CreateProductResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.aliyunCommodityCode)) {
      query["AliyunCommodityCode"] = request.aliyunCommodityCode;
    }

    if (!Util.isUnset(request.authType)) {
      query["AuthType"] = request.authType;
    }

    if (!Util.isUnset(request.categoryKey)) {
      query["CategoryKey"] = request.categoryKey;
    }

    if (!Util.isUnset(request.dataFormat)) {
      query["DataFormat"] = request.dataFormat;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.id2)) {
      query["Id2"] = request.id2;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.joinPermissionId)) {
      query["JoinPermissionId"] = request.joinPermissionId;
    }

    if (!Util.isUnset(request.netType)) {
      query["NetType"] = request.netType;
    }

    if (!Util.isUnset(request.nodeType)) {
      query["NodeType"] = request.nodeType;
    }

    if (!Util.isUnset(request.productName)) {
      query["ProductName"] = request.productName;
    }

    if (!Util.isUnset(request.protocolType)) {
      query["ProtocolType"] = request.protocolType;
    }

    if (!Util.isUnset(request.publishAuto)) {
      query["PublishAuto"] = request.publishAuto;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.validateType)) {
      query["ValidateType"] = request.validateType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateProduct",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateProductResponse>(await this.callApi(params, req, runtime), new CreateProductResponse({}));
  }

  /**
    * If a Thing Specification Language (TSL) model is required to create a product, you must set the **AliyunCommodityCode** parameter to iothub_senior and configure the **DataFormat** parameter.******** For more information, see the "**Request parameters**" section of this topic.
    * ## QPS limits
    * Each Alibaba Cloud account can run up to 50 queries per second (QPS). 
    * >  The RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request CreateProductRequest
    * @return CreateProductResponse
   */
  async createProduct(request: CreateProductRequest): Promise<CreateProductResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createProductWithOptions(request, runtime);
  }

  /**
    * *   This operation can be called only by using the following **endpoint**: `iot.cn-shanghai.aliyuncs.com`.
    * *   You cannot call this operation to distribute a product across accounts.
    * *   A product distribution task does not distribute the devices under the product.
    * *   After a product is distributed, you cannot modify its TSL model and scripts.
    * *   Each Alibaba Cloud account can create a maximum of 10 tasks to distribute products or devices. For more information about how to create a device distribution task, see [CreateDeviceDistributeJob](~~199390~~).
    * *   Each Alibaba Cloud account can run a maximum of 2 queries per second (QPS).
    *     **
    *     **Note** RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request CreateProductDistributeJobRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return CreateProductDistributeJobResponse
   */
  async createProductDistributeJobWithOptions(request: CreateProductDistributeJobRequest, runtime: $Util.RuntimeOptions): Promise<CreateProductDistributeJobResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.sourceInstanceId)) {
      query["SourceInstanceId"] = request.sourceInstanceId;
    }

    if (!Util.isUnset(request.targetAliyunId)) {
      query["TargetAliyunId"] = request.targetAliyunId;
    }

    if (!Util.isUnset(request.targetInstanceId)) {
      query["TargetInstanceId"] = request.targetInstanceId;
    }

    if (!Util.isUnset(request.targetUid)) {
      query["TargetUid"] = request.targetUid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateProductDistributeJob",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateProductDistributeJobResponse>(await this.callApi(params, req, runtime), new CreateProductDistributeJobResponse({}));
  }

  /**
    * *   This operation can be called only by using the following **endpoint**: `iot.cn-shanghai.aliyuncs.com`.
    * *   You cannot call this operation to distribute a product across accounts.
    * *   A product distribution task does not distribute the devices under the product.
    * *   After a product is distributed, you cannot modify its TSL model and scripts.
    * *   Each Alibaba Cloud account can create a maximum of 10 tasks to distribute products or devices. For more information about how to create a device distribution task, see [CreateDeviceDistributeJob](~~199390~~).
    * *   Each Alibaba Cloud account can run a maximum of 2 queries per second (QPS).
    *     **
    *     **Note** RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request CreateProductDistributeJobRequest
    * @return CreateProductDistributeJobResponse
   */
  async createProductDistributeJob(request: CreateProductDistributeJobRequest): Promise<CreateProductDistributeJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createProductDistributeJobWithOptions(request, runtime);
  }

  /**
    * *   You can create a maximum of 10 tags for a product in a single call.
    * *   Each product can have a maximum of 100 tags.
    * > You must specify the tag keys and tag values. Otherwise, the call fails. For description about the tag values, see the "**Request parameters**" section of this topic.
    * ## QPS limits
    * Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS). 
    * >  The Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request CreateProductTagsRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return CreateProductTagsResponse
   */
  async createProductTagsWithOptions(request: CreateProductTagsRequest, runtime: $Util.RuntimeOptions): Promise<CreateProductTagsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.productTag)) {
      query["ProductTag"] = request.productTag;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateProductTags",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateProductTagsResponse>(await this.callApi(params, req, runtime), new CreateProductTagsResponse({}));
  }

  /**
    * *   You can create a maximum of 10 tags for a product in a single call.
    * *   Each product can have a maximum of 100 tags.
    * > You must specify the tag keys and tag values. Otherwise, the call fails. For description about the tag values, see the "**Request parameters**" section of this topic.
    * ## QPS limits
    * Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS). 
    * >  The Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request CreateProductTagsRequest
    * @return CreateProductTagsResponse
   */
  async createProductTags(request: CreateProductTagsRequest): Promise<CreateProductTagsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createProductTagsWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 1 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request CreateProductTopicRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return CreateProductTopicResponse
   */
  async createProductTopicWithOptions(request: CreateProductTopicRequest, runtime: $Util.RuntimeOptions): Promise<CreateProductTopicResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.codec)) {
      query["Codec"] = request.codec;
    }

    if (!Util.isUnset(request.desc)) {
      query["Desc"] = request.desc;
    }

    if (!Util.isUnset(request.enableProxySubscribe)) {
      query["EnableProxySubscribe"] = request.enableProxySubscribe;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.operation)) {
      query["Operation"] = request.operation;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.topicShortName)) {
      query["TopicShortName"] = request.topicShortName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateProductTopic",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateProductTopicResponse>(await this.callApi(params, req, runtime), new CreateProductTopicResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 1 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request CreateProductTopicRequest
    * @return CreateProductTopicResponse
   */
  async createProductTopic(request: CreateProductTopicRequest): Promise<CreateProductTopicResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createProductTopicWithOptions(request, runtime);
  }

  /**
    * When you call this operation, you must specify the **ProductKey** parameter in the request.
    * ## QPS limits
    * Each Alibaba Cloud account can run up to 50 queries per second (QPS). 
    * >  The Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request CreateRuleRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return CreateRuleResponse
   */
  async createRuleWithOptions(request: CreateRuleRequest, runtime: $Util.RuntimeOptions): Promise<CreateRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dataType)) {
      query["DataType"] = request.dataType;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.ruleDesc)) {
      query["RuleDesc"] = request.ruleDesc;
    }

    if (!Util.isUnset(request.select)) {
      query["Select"] = request.select;
    }

    if (!Util.isUnset(request.shortTopic)) {
      query["ShortTopic"] = request.shortTopic;
    }

    if (!Util.isUnset(request.topic)) {
      query["Topic"] = request.topic;
    }

    if (!Util.isUnset(request.topicType)) {
      query["TopicType"] = request.topicType;
    }

    if (!Util.isUnset(request.where)) {
      query["Where"] = request.where;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateRule",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateRuleResponse>(await this.callApi(params, req, runtime), new CreateRuleResponse({}));
  }

  /**
    * When you call this operation, you must specify the **ProductKey** parameter in the request.
    * ## QPS limits
    * Each Alibaba Cloud account can run up to 50 queries per second (QPS). 
    * >  The Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request CreateRuleRequest
    * @return CreateRuleResponse
   */
  async createRule(request: CreateRuleRequest): Promise<CreateRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createRuleWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * *   Destination Alibaba Cloud services that are supported by the rules engine vary based on regions. For more information about the regions and destination cloud services that are supported by the rules engine, see [Regions and zones](~~85669~~).
    * *   You can create a maximum of 10 rule actions for each rule.
    * *   You can call this API operation to define rule actions to forward data to an IoT Platform topic, AMQP consumer group, or Alibaba Cloud service. The supported Alibaba Cloud services include Message Service (MNS), Function Compute, and Tablestore. If you need to forward data to ApsaraDB RDS, you must use the [IoT Platform console](https://iot.console.aliyun.com).
    * *   Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
    * > RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request CreateRuleActionRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return CreateRuleActionResponse
   */
  async createRuleActionWithOptions(request: CreateRuleActionRequest, runtime: $Util.RuntimeOptions): Promise<CreateRuleActionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.configuration)) {
      query["Configuration"] = request.configuration;
    }

    if (!Util.isUnset(request.errorActionFlag)) {
      query["ErrorActionFlag"] = request.errorActionFlag;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.ruleId)) {
      query["RuleId"] = request.ruleId;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateRuleAction",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateRuleActionResponse>(await this.callApi(params, req, runtime), new CreateRuleActionResponse({}));
  }

  /**
    * ## Limits
    * *   Destination Alibaba Cloud services that are supported by the rules engine vary based on regions. For more information about the regions and destination cloud services that are supported by the rules engine, see [Regions and zones](~~85669~~).
    * *   You can create a maximum of 10 rule actions for each rule.
    * *   You can call this API operation to define rule actions to forward data to an IoT Platform topic, AMQP consumer group, or Alibaba Cloud service. The supported Alibaba Cloud services include Message Service (MNS), Function Compute, and Tablestore. If you need to forward data to ApsaraDB RDS, you must use the [IoT Platform console](https://iot.console.aliyun.com).
    * *   Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
    * > RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request CreateRuleActionRequest
    * @return CreateRuleActionResponse
   */
  async createRuleAction(request: CreateRuleActionRequest): Promise<CreateRuleActionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createRuleActionWithOptions(request, runtime);
  }

  async createSceneRuleWithOptions(request: CreateSceneRuleRequest, runtime: $Util.RuntimeOptions): Promise<CreateSceneRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.ruleContent)) {
      query["RuleContent"] = request.ruleContent;
    }

    if (!Util.isUnset(request.ruleDescription)) {
      query["RuleDescription"] = request.ruleDescription;
    }

    if (!Util.isUnset(request.ruleName)) {
      query["RuleName"] = request.ruleName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateSceneRule",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateSceneRuleResponse>(await this.callApi(params, req, runtime), new CreateSceneRuleResponse({}));
  }

  async createSceneRule(request: CreateSceneRuleRequest): Promise<CreateSceneRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createSceneRuleWithOptions(request, runtime);
  }

  async createSchedulePeriodWithOptions(request: CreateSchedulePeriodRequest, runtime: $Util.RuntimeOptions): Promise<CreateSchedulePeriodResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.description)) {
      body["Description"] = request.description;
    }

    if (!Util.isUnset(request.endTime)) {
      body["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      body["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.scheduleCode)) {
      body["ScheduleCode"] = request.scheduleCode;
    }

    if (!Util.isUnset(request.soundCodeContent)) {
      body["SoundCodeContent"] = request.soundCodeContent;
    }

    if (!Util.isUnset(request.startTime)) {
      body["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateSchedulePeriod",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateSchedulePeriodResponse>(await this.callApi(params, req, runtime), new CreateSchedulePeriodResponse({}));
  }

  async createSchedulePeriod(request: CreateSchedulePeriodRequest): Promise<CreateSchedulePeriodResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createSchedulePeriodWithOptions(request, runtime);
  }

  async createSoundCodeWithOptions(request: CreateSoundCodeRequest, runtime: $Util.RuntimeOptions): Promise<CreateSoundCodeResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.duration)) {
      body["Duration"] = request.duration;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      body["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.name)) {
      body["Name"] = request.name;
    }

    if (!Util.isUnset(request.openType)) {
      body["OpenType"] = request.openType;
    }

    if (!Util.isUnset(request.soundCodeContent)) {
      body["SoundCodeContent"] = request.soundCodeContent;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateSoundCode",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateSoundCodeResponse>(await this.callApi(params, req, runtime), new CreateSoundCodeResponse({}));
  }

  async createSoundCode(request: CreateSoundCodeRequest): Promise<CreateSoundCodeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createSoundCodeWithOptions(request, runtime);
  }

  async createSoundCodeLabelWithOptions(request: CreateSoundCodeLabelRequest, runtime: $Util.RuntimeOptions): Promise<CreateSoundCodeLabelResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      body["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.label)) {
      body["Label"] = request.label;
    }

    if (!Util.isUnset(request.scheduleCode)) {
      body["ScheduleCode"] = request.scheduleCode;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateSoundCodeLabel",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateSoundCodeLabelResponse>(await this.callApi(params, req, runtime), new CreateSoundCodeLabelResponse({}));
  }

  async createSoundCodeLabel(request: CreateSoundCodeLabelRequest): Promise<CreateSoundCodeLabelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createSoundCodeLabelWithOptions(request, runtime);
  }

  async createSoundCodeScheduleWithOptions(request: CreateSoundCodeScheduleRequest, runtime: $Util.RuntimeOptions): Promise<CreateSoundCodeScheduleResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.description)) {
      body["Description"] = request.description;
    }

    if (!Util.isUnset(request.endDate)) {
      body["EndDate"] = request.endDate;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      body["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.name)) {
      body["Name"] = request.name;
    }

    if (!Util.isUnset(request.openType)) {
      body["OpenType"] = request.openType;
    }

    if (!Util.isUnset(request.startDate)) {
      body["StartDate"] = request.startDate;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateSoundCodeSchedule",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateSoundCodeScheduleResponse>(await this.callApi(params, req, runtime), new CreateSoundCodeScheduleResponse({}));
  }

  async createSoundCodeSchedule(request: CreateSoundCodeScheduleRequest): Promise<CreateSoundCodeScheduleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createSoundCodeScheduleWithOptions(request, runtime);
  }

  async createSpeechWithOptions(tmpReq: CreateSpeechRequest, runtime: $Util.RuntimeOptions): Promise<CreateSpeechResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateSpeechShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.soundCodeConfig)) {
      request.soundCodeConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.soundCodeConfig, "SoundCodeConfig", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.audioFormat)) {
      body["AudioFormat"] = request.audioFormat;
    }

    if (!Util.isUnset(request.bizCode)) {
      body["BizCode"] = request.bizCode;
    }

    if (!Util.isUnset(request.enableSoundCode)) {
      body["EnableSoundCode"] = request.enableSoundCode;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      body["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.projectCode)) {
      body["ProjectCode"] = request.projectCode;
    }

    if (!Util.isUnset(request.soundCodeConfigShrink)) {
      body["SoundCodeConfig"] = request.soundCodeConfigShrink;
    }

    if (!Util.isUnset(request.speechRate)) {
      body["SpeechRate"] = request.speechRate;
    }

    if (!Util.isUnset(request.speechType)) {
      body["SpeechType"] = request.speechType;
    }

    if (!Util.isUnset(request.text)) {
      body["Text"] = request.text;
    }

    if (!Util.isUnset(request.voice)) {
      body["Voice"] = request.voice;
    }

    if (!Util.isUnset(request.volume)) {
      body["Volume"] = request.volume;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateSpeech",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateSpeechResponse>(await this.callApi(params, req, runtime), new CreateSpeechResponse({}));
  }

  async createSpeech(request: CreateSpeechRequest): Promise<CreateSpeechResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createSpeechWithOptions(request, runtime);
  }

  async createStudioAppDomainOpenWithOptions(request: CreateStudioAppDomainOpenRequest, runtime: $Util.RuntimeOptions): Promise<CreateStudioAppDomainOpenResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appId)) {
      body["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.host)) {
      body["Host"] = request.host;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      body["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.protocol)) {
      body["Protocol"] = request.protocol;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateStudioAppDomainOpen",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateStudioAppDomainOpenResponse>(await this.callApi(params, req, runtime), new CreateStudioAppDomainOpenResponse({}));
  }

  async createStudioAppDomainOpen(request: CreateStudioAppDomainOpenRequest): Promise<CreateStudioAppDomainOpenResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createStudioAppDomainOpenWithOptions(request, runtime);
  }

  /**
    * Server-side subscriptions are categorized into the following two types:
    * *   MNS subscription: pushes subscribed messages to MNS queues. Your server applications listen to MNS queues to receive device messages. For more information, see [Configure MNS server-side subscriptions](~~68948~~). You can call this operation to create an MNS subscription.
    * *   AMQP subscription: pushes subscribed messages to your server by using the AMQP channel. For more information, see [Configure AMQP server-side subscriptions](~~142376~~). To configure an AMQP subscription, perform the following steps:
    *     1\\. Call the [CreateConsumerGroup](~~170388~~) operation to create a consumer group and obtain the returned consumer group ID. Messages are pushed to the consumer group. The AMQP client carries the consumer group ID when the client connected to IoT Platform. For more information, see [Connect an AMQP client to IoT Platform](~~142489~~).
    *     2\\. Call the CreateSubscribeRelation operation to create an AMQP subscription.
    *     3\\. Optional. Call the [CreateConsumerGroupSubscribeRelation](~~170354~~) operation to add a consumer group to the AMQP subscription. You can also call the [DeleteConsumerGroupSubscribeRelation](~~170357~~) operation to remove a consumer group from an AMQP subscription.
    *     4\\. Optional. Call the [QueryConsumerGroupStatus](~~170358~~) operation to query the status of a consumer group, including online client information, message consumption rate, number of accumulated messages, and last message consumption time. You can also call the [ResetConsumerGroupPosition](~~170355~~) operation to clear the accumulated messages of the consumer group.
    * ## QPS limits
    * You can call this API operation up to five times per second per account. 
    * >  The RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request CreateSubscribeRelationRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return CreateSubscribeRelationResponse
   */
  async createSubscribeRelationWithOptions(request: CreateSubscribeRelationRequest, runtime: $Util.RuntimeOptions): Promise<CreateSubscribeRelationResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.consumerGroupIds)) {
      query["ConsumerGroupIds"] = request.consumerGroupIds;
    }

    if (!Util.isUnset(request.deviceDataFlag)) {
      query["DeviceDataFlag"] = request.deviceDataFlag;
    }

    if (!Util.isUnset(request.deviceLifeCycleFlag)) {
      query["DeviceLifeCycleFlag"] = request.deviceLifeCycleFlag;
    }

    if (!Util.isUnset(request.deviceStatusChangeFlag)) {
      query["DeviceStatusChangeFlag"] = request.deviceStatusChangeFlag;
    }

    if (!Util.isUnset(request.deviceTagFlag)) {
      query["DeviceTagFlag"] = request.deviceTagFlag;
    }

    if (!Util.isUnset(request.deviceTopoLifeCycleFlag)) {
      query["DeviceTopoLifeCycleFlag"] = request.deviceTopoLifeCycleFlag;
    }

    if (!Util.isUnset(request.foundDeviceListFlag)) {
      query["FoundDeviceListFlag"] = request.foundDeviceListFlag;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.mnsConfiguration)) {
      query["MnsConfiguration"] = request.mnsConfiguration;
    }

    if (!Util.isUnset(request.otaEventFlag)) {
      query["OtaEventFlag"] = request.otaEventFlag;
    }

    if (!Util.isUnset(request.otaJobFlag)) {
      query["OtaJobFlag"] = request.otaJobFlag;
    }

    if (!Util.isUnset(request.otaVersionFlag)) {
      query["OtaVersionFlag"] = request.otaVersionFlag;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.subscribeFlags)) {
      query["SubscribeFlags"] = request.subscribeFlags;
    }

    if (!Util.isUnset(request.thingHistoryFlag)) {
      query["ThingHistoryFlag"] = request.thingHistoryFlag;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateSubscribeRelation",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateSubscribeRelationResponse>(await this.callApi(params, req, runtime), new CreateSubscribeRelationResponse({}));
  }

  /**
    * Server-side subscriptions are categorized into the following two types:
    * *   MNS subscription: pushes subscribed messages to MNS queues. Your server applications listen to MNS queues to receive device messages. For more information, see [Configure MNS server-side subscriptions](~~68948~~). You can call this operation to create an MNS subscription.
    * *   AMQP subscription: pushes subscribed messages to your server by using the AMQP channel. For more information, see [Configure AMQP server-side subscriptions](~~142376~~). To configure an AMQP subscription, perform the following steps:
    *     1\\. Call the [CreateConsumerGroup](~~170388~~) operation to create a consumer group and obtain the returned consumer group ID. Messages are pushed to the consumer group. The AMQP client carries the consumer group ID when the client connected to IoT Platform. For more information, see [Connect an AMQP client to IoT Platform](~~142489~~).
    *     2\\. Call the CreateSubscribeRelation operation to create an AMQP subscription.
    *     3\\. Optional. Call the [CreateConsumerGroupSubscribeRelation](~~170354~~) operation to add a consumer group to the AMQP subscription. You can also call the [DeleteConsumerGroupSubscribeRelation](~~170357~~) operation to remove a consumer group from an AMQP subscription.
    *     4\\. Optional. Call the [QueryConsumerGroupStatus](~~170358~~) operation to query the status of a consumer group, including online client information, message consumption rate, number of accumulated messages, and last message consumption time. You can also call the [ResetConsumerGroupPosition](~~170355~~) operation to clear the accumulated messages of the consumer group.
    * ## QPS limits
    * You can call this API operation up to five times per second per account. 
    * >  The RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request CreateSubscribeRelationRequest
    * @return CreateSubscribeRelationResponse
   */
  async createSubscribeRelation(request: CreateSubscribeRelationRequest): Promise<CreateSubscribeRelationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createSubscribeRelationWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * *   If a product is published, you must call the [CancelReleaseProduct](~~213875~~) operation to unpublish the product before you call this operation.
    * *   Before you call the operation, you can use the [json-schema](https://github.com/everit-org/json-schema?spm=a2c4g.11186623.2.23.575832d9zD7fZb) library to verify the input parameters in **ThingModelJson**. For more information, see [Data structure of ThingModelJson](~~150457~~).
    * *   You can call this operation to add a maximum of 10 TSL features. TSL features include properties, services, and events.
    * *   Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
    * > RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request CreateThingModelRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return CreateThingModelResponse
   */
  async createThingModelWithOptions(request: CreateThingModelRequest, runtime: $Util.RuntimeOptions): Promise<CreateThingModelResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.functionBlockId)) {
      query["FunctionBlockId"] = request.functionBlockId;
    }

    if (!Util.isUnset(request.functionBlockName)) {
      query["FunctionBlockName"] = request.functionBlockName;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.thingModelJson)) {
      query["ThingModelJson"] = request.thingModelJson;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateThingModel",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateThingModelResponse>(await this.callApi(params, req, runtime), new CreateThingModelResponse({}));
  }

  /**
    * ## Limits
    * *   If a product is published, you must call the [CancelReleaseProduct](~~213875~~) operation to unpublish the product before you call this operation.
    * *   Before you call the operation, you can use the [json-schema](https://github.com/everit-org/json-schema?spm=a2c4g.11186623.2.23.575832d9zD7fZb) library to verify the input parameters in **ThingModelJson**. For more information, see [Data structure of ThingModelJson](~~150457~~).
    * *   You can call this operation to add a maximum of 10 TSL features. TSL features include properties, services, and events.
    * *   Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
    * > RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request CreateThingModelRequest
    * @return CreateThingModelResponse
   */
  async createThingModel(request: CreateThingModelRequest): Promise<CreateThingModelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createThingModelWithOptions(request, runtime);
  }

  /**
    * A data parsing script is used to convert data submitted by devices into the JSON format. The data submitted by devices is in a custom format. You can write a script in JavaScript, Python 2.7, and PHP 7.2. For more information, see [Submit scripts for data parsing](~~149963~~).
    * > If the data format is **Alink JSON**, the CreateThingScript operation is not supported. Alink JSON is a standard data format that is defined by IoT Connectivity Alliance (ICA).
    * ## QPS limits
    * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS). 
    * >  The Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request CreateThingScriptRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return CreateThingScriptResponse
   */
  async createThingScriptWithOptions(request: CreateThingScriptRequest, runtime: $Util.RuntimeOptions): Promise<CreateThingScriptResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.scriptContent)) {
      query["ScriptContent"] = request.scriptContent;
    }

    if (!Util.isUnset(request.scriptType)) {
      query["ScriptType"] = request.scriptType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateThingScript",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateThingScriptResponse>(await this.callApi(params, req, runtime), new CreateThingScriptResponse({}));
  }

  /**
    * A data parsing script is used to convert data submitted by devices into the JSON format. The data submitted by devices is in a custom format. You can write a script in JavaScript, Python 2.7, and PHP 7.2. For more information, see [Submit scripts for data parsing](~~149963~~).
    * > If the data format is **Alink JSON**, the CreateThingScript operation is not supported. Alink JSON is a standard data format that is defined by IoT Connectivity Alliance (ICA).
    * ## QPS limits
    * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS). 
    * >  The Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request CreateThingScriptRequest
    * @return CreateThingScriptResponse
   */
  async createThingScript(request: CreateThingScriptRequest): Promise<CreateThingScriptResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createThingScriptWithOptions(request, runtime);
  }

  async createTopicConfigWithOptions(request: CreateTopicConfigRequest, runtime: $Util.RuntimeOptions): Promise<CreateTopicConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.codec)) {
      query["Codec"] = request.codec;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.enableBroadcast)) {
      query["EnableBroadcast"] = request.enableBroadcast;
    }

    if (!Util.isUnset(request.enableProxySubscribe)) {
      query["EnableProxySubscribe"] = request.enableProxySubscribe;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.operation)) {
      query["Operation"] = request.operation;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.topicFullName)) {
      query["TopicFullName"] = request.topicFullName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateTopicConfig",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateTopicConfigResponse>(await this.callApi(params, req, runtime), new CreateTopicConfigResponse({}));
  }

  async createTopicConfig(request: CreateTopicConfigRequest): Promise<CreateTopicConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createTopicConfigWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * *   You can specify a maximum of 100 destination topics for a source topic.
    * *   The device to which the source topic belongs must be activated.
    * *   The source and destination topics support only custom topics.
    * *   Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
    * > RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request CreateTopicRouteTableRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return CreateTopicRouteTableResponse
   */
  async createTopicRouteTableWithOptions(request: CreateTopicRouteTableRequest, runtime: $Util.RuntimeOptions): Promise<CreateTopicRouteTableResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dstTopic)) {
      query["DstTopic"] = request.dstTopic;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.srcTopic)) {
      query["SrcTopic"] = request.srcTopic;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateTopicRouteTable",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateTopicRouteTableResponse>(await this.callApi(params, req, runtime), new CreateTopicRouteTableResponse({}));
  }

  /**
    * ## Limits
    * *   You can specify a maximum of 100 destination topics for a source topic.
    * *   The device to which the source topic belongs must be activated.
    * *   The source and destination topics support only custom topics.
    * *   Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
    * > RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request CreateTopicRouteTableRequest
    * @return CreateTopicRouteTableResponse
   */
  async createTopicRouteTable(request: CreateTopicRouteTableRequest): Promise<CreateTopicRouteTableResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createTopicRouteTableWithOptions(request, runtime);
  }

  /**
    * *   You can call the [QueryClientIds](~~371985~~) operation to view the ClientIDs of a device and obtain the number of ClientIDs.
    * *   After you call the DeleteClientIds operation, all ClientIDs of the device are deleted and cannot be resumed. To obtain a new ClientID, you can register the device again.
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS). 
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request DeleteClientIdsRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return DeleteClientIdsResponse
   */
  async deleteClientIdsWithOptions(request: DeleteClientIdsRequest, runtime: $Util.RuntimeOptions): Promise<DeleteClientIdsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotId)) {
      query["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteClientIds",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteClientIdsResponse>(await this.callApi(params, req, runtime), new DeleteClientIdsResponse({}));
  }

  /**
    * *   You can call the [QueryClientIds](~~371985~~) operation to view the ClientIDs of a device and obtain the number of ClientIDs.
    * *   After you call the DeleteClientIds operation, all ClientIDs of the device are deleted and cannot be resumed. To obtain a new ClientID, you can register the device again.
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS). 
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request DeleteClientIdsRequest
    * @return DeleteClientIdsResponse
   */
  async deleteClientIds(request: DeleteClientIdsRequest): Promise<DeleteClientIdsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteClientIdsWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * *   You cannot delete the default consumer group provided by IoT Platform.
    * *   If the consumer group is associated with an AMQP subscription, you must disassociate the consumer group from the subscription. If the subscription has multiple consumer groups, you can call the [DeleteConsumerGroupSubscribeRelation](~~170357~~) operation to remove the consumer group from the subscription. If the subscription has only one consumer group, you can call the [UpdateSubscribeRelation](~~170351~~) operation to change the consumer group or call the [DeleteSubscribeRelation](~~170353~~) operation to delete the subscription.
    * *   Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
    * > RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request DeleteConsumerGroupRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return DeleteConsumerGroupResponse
   */
  async deleteConsumerGroupWithOptions(request: DeleteConsumerGroupRequest, runtime: $Util.RuntimeOptions): Promise<DeleteConsumerGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteConsumerGroup",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteConsumerGroupResponse>(await this.callApi(params, req, runtime), new DeleteConsumerGroupResponse({}));
  }

  /**
    * ## Limits
    * *   You cannot delete the default consumer group provided by IoT Platform.
    * *   If the consumer group is associated with an AMQP subscription, you must disassociate the consumer group from the subscription. If the subscription has multiple consumer groups, you can call the [DeleteConsumerGroupSubscribeRelation](~~170357~~) operation to remove the consumer group from the subscription. If the subscription has only one consumer group, you can call the [UpdateSubscribeRelation](~~170351~~) operation to change the consumer group or call the [DeleteSubscribeRelation](~~170353~~) operation to delete the subscription.
    * *   Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
    * > RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request DeleteConsumerGroupRequest
    * @return DeleteConsumerGroupResponse
   */
  async deleteConsumerGroup(request: DeleteConsumerGroupRequest): Promise<DeleteConsumerGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteConsumerGroupWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * *   If the AMQP subscription has only one consumer group, you cannot call this operation to remove the consumer group.
    * *   Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
    * > RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request DeleteConsumerGroupSubscribeRelationRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return DeleteConsumerGroupSubscribeRelationResponse
   */
  async deleteConsumerGroupSubscribeRelationWithOptions(request: DeleteConsumerGroupSubscribeRelationRequest, runtime: $Util.RuntimeOptions): Promise<DeleteConsumerGroupSubscribeRelationResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.consumerGroupId)) {
      query["ConsumerGroupId"] = request.consumerGroupId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteConsumerGroupSubscribeRelation",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteConsumerGroupSubscribeRelationResponse>(await this.callApi(params, req, runtime), new DeleteConsumerGroupSubscribeRelationResponse({}));
  }

  /**
    * ## Limits
    * *   If the AMQP subscription has only one consumer group, you cannot call this operation to remove the consumer group.
    * *   Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
    * > RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request DeleteConsumerGroupSubscribeRelationRequest
    * @return DeleteConsumerGroupSubscribeRelationResponse
   */
  async deleteConsumerGroupSubscribeRelation(request: DeleteConsumerGroupSubscribeRelationRequest): Promise<DeleteConsumerGroupSubscribeRelationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteConsumerGroupSubscribeRelationWithOptions(request, runtime);
  }

  async deleteDataSourceItemWithOptions(request: DeleteDataSourceItemRequest, runtime: $Util.RuntimeOptions): Promise<DeleteDataSourceItemResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dataSourceId)) {
      query["DataSourceId"] = request.dataSourceId;
    }

    if (!Util.isUnset(request.dataSourceItemId)) {
      query["DataSourceItemId"] = request.dataSourceItemId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteDataSourceItem",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteDataSourceItemResponse>(await this.callApi(params, req, runtime), new DeleteDataSourceItemResponse({}));
  }

  async deleteDataSourceItem(request: DeleteDataSourceItemRequest): Promise<DeleteDataSourceItemResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteDataSourceItemWithOptions(request, runtime);
  }

  async deleteDestinationWithOptions(request: DeleteDestinationRequest, runtime: $Util.RuntimeOptions): Promise<DeleteDestinationResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.destinationId)) {
      query["DestinationId"] = request.destinationId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteDestination",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteDestinationResponse>(await this.callApi(params, req, runtime), new DeleteDestinationResponse({}));
  }

  async deleteDestination(request: DeleteDestinationRequest): Promise<DeleteDestinationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteDestinationWithOptions(request, runtime);
  }

  /**
    * *   When you call this operation with an Alibaba Cloud account, IoT Platform sends a verification code by text message to confirm your identity.
    * *   When you call this operation with a RAM user, IoT Platform does not send a verification code. To ensure device security, you can create custom permission policies to perform fine-grained permission management. For more information, see [Mapping of IoT Platform operations and RAM policies](~~47485~~) and [Custom permissions](~~47495~~).
    * **Warning**
    * *   After a device is deleted, the device ID (**IotId**) becomes invalid, and all other information associated with the device is deleted. In addition, you can no longer perform an operation on the device.
    * *   Before you delete a device in the IoT Platform console, make sure that the corresponding actual device is offline. Otherwise, after the device is deleted from IoT Platform, the actual device continues to initiate connection requests to IoT Platform. If the number of requests exceeds the upper limit, IoT Platform starts request throttling. In this case, access of other devices within your Alibaba Cloud account is affected.
    * *   After you delete a device, the certificate of the device becomes invalid and cannot be restored. Proceed with caution.
    * ****
    * *   You must specify a value for the **IotId** parameter or values for the **ProductKey** and **DeviceName** parameters to identify a device.
    * *   If you specify a gateway and the number of sub-devices that belong to the gateway exceeds 2,000, you can call this operation to create a device job to delete the topological relationships in an asynchronous manner. The operation returns the **JobId** parameter.
    * ## QPS limits
    * You can call this API operation up to 50 times per second per account. 
    * >  The RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request DeleteDeviceRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return DeleteDeviceResponse
   */
  async deleteDeviceWithOptions(request: DeleteDeviceRequest, runtime: $Util.RuntimeOptions): Promise<DeleteDeviceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotId)) {
      query["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteDevice",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteDeviceResponse>(await this.callApi(params, req, runtime), new DeleteDeviceResponse({}));
  }

  /**
    * *   When you call this operation with an Alibaba Cloud account, IoT Platform sends a verification code by text message to confirm your identity.
    * *   When you call this operation with a RAM user, IoT Platform does not send a verification code. To ensure device security, you can create custom permission policies to perform fine-grained permission management. For more information, see [Mapping of IoT Platform operations and RAM policies](~~47485~~) and [Custom permissions](~~47495~~).
    * **Warning**
    * *   After a device is deleted, the device ID (**IotId**) becomes invalid, and all other information associated with the device is deleted. In addition, you can no longer perform an operation on the device.
    * *   Before you delete a device in the IoT Platform console, make sure that the corresponding actual device is offline. Otherwise, after the device is deleted from IoT Platform, the actual device continues to initiate connection requests to IoT Platform. If the number of requests exceeds the upper limit, IoT Platform starts request throttling. In this case, access of other devices within your Alibaba Cloud account is affected.
    * *   After you delete a device, the certificate of the device becomes invalid and cannot be restored. Proceed with caution.
    * ****
    * *   You must specify a value for the **IotId** parameter or values for the **ProductKey** and **DeviceName** parameters to identify a device.
    * *   If you specify a gateway and the number of sub-devices that belong to the gateway exceeds 2,000, you can call this operation to create a device job to delete the topological relationships in an asynchronous manner. The operation returns the **JobId** parameter.
    * ## QPS limits
    * You can call this API operation up to 50 times per second per account. 
    * >  The RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request DeleteDeviceRequest
    * @return DeleteDeviceResponse
   */
  async deleteDevice(request: DeleteDeviceRequest): Promise<DeleteDeviceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteDeviceWithOptions(request, runtime);
  }

  /**
    * *   This operation can be called only by using the following **endpoint**: `iot.cn-shanghai.aliyuncs.com`.
    * *   Each Alibaba Cloud account can run a maximum of 2 queries per second (QPS).
    * > RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request DeleteDeviceDistributeJobRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return DeleteDeviceDistributeJobResponse
   */
  async deleteDeviceDistributeJobWithOptions(request: DeleteDeviceDistributeJobRequest, runtime: $Util.RuntimeOptions): Promise<DeleteDeviceDistributeJobResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.jobId)) {
      query["JobId"] = request.jobId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteDeviceDistributeJob",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteDeviceDistributeJobResponse>(await this.callApi(params, req, runtime), new DeleteDeviceDistributeJobResponse({}));
  }

  /**
    * *   This operation can be called only by using the following **endpoint**: `iot.cn-shanghai.aliyuncs.com`.
    * *   Each Alibaba Cloud account can run a maximum of 2 queries per second (QPS).
    * > RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request DeleteDeviceDistributeJobRequest
    * @return DeleteDeviceDistributeJobResponse
   */
  async deleteDeviceDistributeJob(request: DeleteDeviceDistributeJobRequest): Promise<DeleteDeviceDistributeJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteDeviceDistributeJobWithOptions(request, runtime);
  }

  async deleteDeviceDynamicGroupWithOptions(request: DeleteDeviceDynamicGroupRequest, runtime: $Util.RuntimeOptions): Promise<DeleteDeviceDynamicGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteDeviceDynamicGroup",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteDeviceDynamicGroupResponse>(await this.callApi(params, req, runtime), new DeleteDeviceDynamicGroupResponse({}));
  }

  async deleteDeviceDynamicGroup(request: DeleteDeviceDynamicGroupRequest): Promise<DeleteDeviceDynamicGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteDeviceDynamicGroupWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request DeleteDeviceFileRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return DeleteDeviceFileResponse
   */
  async deleteDeviceFileWithOptions(request: DeleteDeviceFileRequest, runtime: $Util.RuntimeOptions): Promise<DeleteDeviceFileResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.fileId)) {
      query["FileId"] = request.fileId;
    }

    if (!Util.isUnset(request.iotId)) {
      query["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteDeviceFile",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteDeviceFileResponse>(await this.callApi(params, req, runtime), new DeleteDeviceFileResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request DeleteDeviceFileRequest
    * @return DeleteDeviceFileResponse
   */
  async deleteDeviceFile(request: DeleteDeviceFileRequest): Promise<DeleteDeviceFileResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteDeviceFileWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request DeleteDeviceGroupRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return DeleteDeviceGroupResponse
   */
  async deleteDeviceGroupWithOptions(request: DeleteDeviceGroupRequest, runtime: $Util.RuntimeOptions): Promise<DeleteDeviceGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteDeviceGroup",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteDeviceGroupResponse>(await this.callApi(params, req, runtime), new DeleteDeviceGroupResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request DeleteDeviceGroupRequest
    * @return DeleteDeviceGroupResponse
   */
  async deleteDeviceGroup(request: DeleteDeviceGroupRequest): Promise<DeleteDeviceGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteDeviceGroupWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request DeleteDevicePropRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return DeleteDevicePropResponse
   */
  async deleteDevicePropWithOptions(request: DeleteDevicePropRequest, runtime: $Util.RuntimeOptions): Promise<DeleteDevicePropResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotId)) {
      query["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.propKey)) {
      query["PropKey"] = request.propKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteDeviceProp",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteDevicePropResponse>(await this.callApi(params, req, runtime), new DeleteDevicePropResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request DeleteDevicePropRequest
    * @return DeleteDevicePropResponse
   */
  async deleteDeviceProp(request: DeleteDevicePropRequest): Promise<DeleteDevicePropResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteDevicePropWithOptions(request, runtime);
  }

  async deleteDeviceSpeechWithOptions(request: DeleteDeviceSpeechRequest, runtime: $Util.RuntimeOptions): Promise<DeleteDeviceSpeechResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.deviceSpeechList)) {
      body["DeviceSpeechList"] = request.deviceSpeechList;
    }

    if (!Util.isUnset(request.iotId)) {
      body["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      body["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteDeviceSpeech",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteDeviceSpeechResponse>(await this.callApi(params, req, runtime), new DeleteDeviceSpeechResponse({}));
  }

  async deleteDeviceSpeech(request: DeleteDeviceSpeechRequest): Promise<DeleteDeviceSpeechResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteDeviceSpeechWithOptions(request, runtime);
  }

  async deleteDeviceTunnelWithOptions(request: DeleteDeviceTunnelRequest, runtime: $Util.RuntimeOptions): Promise<DeleteDeviceTunnelResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.tunnelId)) {
      query["TunnelId"] = request.tunnelId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteDeviceTunnel",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteDeviceTunnelResponse>(await this.callApi(params, req, runtime), new DeleteDeviceTunnelResponse({}));
  }

  async deleteDeviceTunnel(request: DeleteDeviceTunnelRequest): Promise<DeleteDeviceTunnelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteDeviceTunnelWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * *   You are not allowed to delete a driver that has a published version.
    * *   Each Alibaba Cloud account can run a maximum of five queries per second (QPS).
    * >RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request DeleteEdgeDriverRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return DeleteEdgeDriverResponse
   */
  async deleteEdgeDriverWithOptions(request: DeleteEdgeDriverRequest, runtime: $Util.RuntimeOptions): Promise<DeleteEdgeDriverResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.driverId)) {
      query["DriverId"] = request.driverId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteEdgeDriver",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteEdgeDriverResponse>(await this.callApi(params, req, runtime), new DeleteEdgeDriverResponse({}));
  }

  /**
    * ## Limits
    * *   You are not allowed to delete a driver that has a published version.
    * *   Each Alibaba Cloud account can run a maximum of five queries per second (QPS).
    * >RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request DeleteEdgeDriverRequest
    * @return DeleteEdgeDriverResponse
   */
  async deleteEdgeDriver(request: DeleteEdgeDriverRequest): Promise<DeleteEdgeDriverResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteEdgeDriverWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * *   You are not allowed to delete a published driver version.
    * *   Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request DeleteEdgeDriverVersionRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return DeleteEdgeDriverVersionResponse
   */
  async deleteEdgeDriverVersionWithOptions(request: DeleteEdgeDriverVersionRequest, runtime: $Util.RuntimeOptions): Promise<DeleteEdgeDriverVersionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.driverId)) {
      query["DriverId"] = request.driverId;
    }

    if (!Util.isUnset(request.driverVersion)) {
      query["DriverVersion"] = request.driverVersion;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteEdgeDriverVersion",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteEdgeDriverVersionResponse>(await this.callApi(params, req, runtime), new DeleteEdgeDriverVersionResponse({}));
  }

  /**
    * ## Limits
    * *   You are not allowed to delete a published driver version.
    * *   Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request DeleteEdgeDriverVersionRequest
    * @return DeleteEdgeDriverVersionResponse
   */
  async deleteEdgeDriverVersion(request: DeleteEdgeDriverVersionRequest): Promise<DeleteEdgeDriverVersionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteEdgeDriverVersionWithOptions(request, runtime);
  }

  /**
    * Each Alibaba Cloud account can run a maximum of five queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request DeleteEdgeInstanceRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return DeleteEdgeInstanceResponse
   */
  async deleteEdgeInstanceWithOptions(request: DeleteEdgeInstanceRequest, runtime: $Util.RuntimeOptions): Promise<DeleteEdgeInstanceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteEdgeInstance",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteEdgeInstanceResponse>(await this.callApi(params, req, runtime), new DeleteEdgeInstanceResponse({}));
  }

  /**
    * Each Alibaba Cloud account can run a maximum of five queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request DeleteEdgeInstanceRequest
    * @return DeleteEdgeInstanceResponse
   */
  async deleteEdgeInstance(request: DeleteEdgeInstanceRequest): Promise<DeleteEdgeInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteEdgeInstanceWithOptions(request, runtime);
  }

  async deleteEdgeInstanceMessageRoutingWithOptions(request: DeleteEdgeInstanceMessageRoutingRequest, runtime: $Util.RuntimeOptions): Promise<DeleteEdgeInstanceMessageRoutingResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.routeId)) {
      query["RouteId"] = request.routeId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteEdgeInstanceMessageRouting",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteEdgeInstanceMessageRoutingResponse>(await this.callApi(params, req, runtime), new DeleteEdgeInstanceMessageRoutingResponse({}));
  }

  async deleteEdgeInstanceMessageRouting(request: DeleteEdgeInstanceMessageRoutingRequest): Promise<DeleteEdgeInstanceMessageRoutingResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteEdgeInstanceMessageRoutingWithOptions(request, runtime);
  }

  async deleteJobWithOptions(request: DeleteJobRequest, runtime: $Util.RuntimeOptions): Promise<DeleteJobResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.jobId)) {
      query["JobId"] = request.jobId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteJob",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteJobResponse>(await this.callApi(params, req, runtime), new DeleteJobResponse({}));
  }

  async deleteJob(request: DeleteJobRequest): Promise<DeleteJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteJobWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request DeleteOTAFirmwareRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return DeleteOTAFirmwareResponse
   */
  async deleteOTAFirmwareWithOptions(request: DeleteOTAFirmwareRequest, runtime: $Util.RuntimeOptions): Promise<DeleteOTAFirmwareResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.firmwareId)) {
      query["FirmwareId"] = request.firmwareId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteOTAFirmware",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteOTAFirmwareResponse>(await this.callApi(params, req, runtime), new DeleteOTAFirmwareResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request DeleteOTAFirmwareRequest
    * @return DeleteOTAFirmwareResponse
   */
  async deleteOTAFirmware(request: DeleteOTAFirmwareRequest): Promise<DeleteOTAFirmwareResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteOTAFirmwareWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * *   The default module cannot be deleted.
    * *   If an update package exists in an OTA module, you cannot delete the OTA module.
    * *   Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
    * > RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request DeleteOTAModuleRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return DeleteOTAModuleResponse
   */
  async deleteOTAModuleWithOptions(request: DeleteOTAModuleRequest, runtime: $Util.RuntimeOptions): Promise<DeleteOTAModuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.moduleName)) {
      query["ModuleName"] = request.moduleName;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteOTAModule",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteOTAModuleResponse>(await this.callApi(params, req, runtime), new DeleteOTAModuleResponse({}));
  }

  /**
    * ## Limits
    * *   The default module cannot be deleted.
    * *   If an update package exists in an OTA module, you cannot delete the OTA module.
    * *   Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
    * > RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request DeleteOTAModuleRequest
    * @return DeleteOTAModuleResponse
   */
  async deleteOTAModule(request: DeleteOTAModuleRequest): Promise<DeleteOTAModuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteOTAModuleWithOptions(request, runtime);
  }

  async deleteParserWithOptions(request: DeleteParserRequest, runtime: $Util.RuntimeOptions): Promise<DeleteParserResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.parserId)) {
      query["ParserId"] = request.parserId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteParser",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteParserResponse>(await this.callApi(params, req, runtime), new DeleteParserResponse({}));
  }

  async deleteParser(request: DeleteParserRequest): Promise<DeleteParserResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteParserWithOptions(request, runtime);
  }

  async deleteParserDataSourceWithOptions(request: DeleteParserDataSourceRequest, runtime: $Util.RuntimeOptions): Promise<DeleteParserDataSourceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dataSourceId)) {
      query["DataSourceId"] = request.dataSourceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteParserDataSource",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteParserDataSourceResponse>(await this.callApi(params, req, runtime), new DeleteParserDataSourceResponse({}));
  }

  async deleteParserDataSource(request: DeleteParserDataSourceRequest): Promise<DeleteParserDataSourceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteParserDataSourceWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * *   After a product is deleted, the ProductKey of the product is invalid. The related information about the product is also deleted. You cannot perform the required operations on the product.
    * *   Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
    * > RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request DeleteProductRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return DeleteProductResponse
   */
  async deleteProductWithOptions(request: DeleteProductRequest, runtime: $Util.RuntimeOptions): Promise<DeleteProductResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteProduct",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteProductResponse>(await this.callApi(params, req, runtime), new DeleteProductResponse({}));
  }

  /**
    * ## Limits
    * *   After a product is deleted, the ProductKey of the product is invalid. The related information about the product is also deleted. You cannot perform the required operations on the product.
    * *   Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
    * > RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request DeleteProductRequest
    * @return DeleteProductResponse
   */
  async deleteProduct(request: DeleteProductRequest): Promise<DeleteProductResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteProductWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * *   You can delete a maximum of 10 tags in a single call.
    * *   Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
    * > RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request DeleteProductTagsRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return DeleteProductTagsResponse
   */
  async deleteProductTagsWithOptions(request: DeleteProductTagsRequest, runtime: $Util.RuntimeOptions): Promise<DeleteProductTagsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.productTagKey)) {
      query["ProductTagKey"] = request.productTagKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteProductTags",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteProductTagsResponse>(await this.callApi(params, req, runtime), new DeleteProductTagsResponse({}));
  }

  /**
    * ## Limits
    * *   You can delete a maximum of 10 tags in a single call.
    * *   Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
    * > RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request DeleteProductTagsRequest
    * @return DeleteProductTagsResponse
   */
  async deleteProductTags(request: DeleteProductTagsRequest): Promise<DeleteProductTagsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteProductTagsWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request DeleteProductTopicRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return DeleteProductTopicResponse
   */
  async deleteProductTopicWithOptions(request: DeleteProductTopicRequest, runtime: $Util.RuntimeOptions): Promise<DeleteProductTopicResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.topicId)) {
      query["TopicId"] = request.topicId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteProductTopic",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteProductTopicResponse>(await this.callApi(params, req, runtime), new DeleteProductTopicResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request DeleteProductTopicRequest
    * @return DeleteProductTopicResponse
   */
  async deleteProductTopic(request: DeleteProductTopicRequest): Promise<DeleteProductTopicResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteProductTopicWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request DeleteRuleRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return DeleteRuleResponse
   */
  async deleteRuleWithOptions(request: DeleteRuleRequest, runtime: $Util.RuntimeOptions): Promise<DeleteRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.ruleId)) {
      query["RuleId"] = request.ruleId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteRule",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteRuleResponse>(await this.callApi(params, req, runtime), new DeleteRuleResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request DeleteRuleRequest
    * @return DeleteRuleResponse
   */
  async deleteRule(request: DeleteRuleRequest): Promise<DeleteRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteRuleWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request DeleteRuleActionRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return DeleteRuleActionResponse
   */
  async deleteRuleActionWithOptions(request: DeleteRuleActionRequest, runtime: $Util.RuntimeOptions): Promise<DeleteRuleActionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.actionId)) {
      query["ActionId"] = request.actionId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteRuleAction",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteRuleActionResponse>(await this.callApi(params, req, runtime), new DeleteRuleActionResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request DeleteRuleActionRequest
    * @return DeleteRuleActionResponse
   */
  async deleteRuleAction(request: DeleteRuleActionRequest): Promise<DeleteRuleActionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteRuleActionWithOptions(request, runtime);
  }

  async deleteSceneRuleWithOptions(request: DeleteSceneRuleRequest, runtime: $Util.RuntimeOptions): Promise<DeleteSceneRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.ruleId)) {
      query["RuleId"] = request.ruleId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteSceneRule",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteSceneRuleResponse>(await this.callApi(params, req, runtime), new DeleteSceneRuleResponse({}));
  }

  async deleteSceneRule(request: DeleteSceneRuleRequest): Promise<DeleteSceneRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteSceneRuleWithOptions(request, runtime);
  }

  async deleteSchedulePeriodWithOptions(request: DeleteSchedulePeriodRequest, runtime: $Util.RuntimeOptions): Promise<DeleteSchedulePeriodResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      body["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.periodCode)) {
      body["PeriodCode"] = request.periodCode;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteSchedulePeriod",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteSchedulePeriodResponse>(await this.callApi(params, req, runtime), new DeleteSchedulePeriodResponse({}));
  }

  async deleteSchedulePeriod(request: DeleteSchedulePeriodRequest): Promise<DeleteSchedulePeriodResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteSchedulePeriodWithOptions(request, runtime);
  }

  async deleteShareTaskDeviceWithOptions(request: DeleteShareTaskDeviceRequest, runtime: $Util.RuntimeOptions): Promise<DeleteShareTaskDeviceResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.iotIdList)) {
      body["IotIdList"] = request.iotIdList;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      body["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.shareTaskId)) {
      body["ShareTaskId"] = request.shareTaskId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteShareTaskDevice",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteShareTaskDeviceResponse>(await this.callApi(params, req, runtime), new DeleteShareTaskDeviceResponse({}));
  }

  async deleteShareTaskDevice(request: DeleteShareTaskDeviceRequest): Promise<DeleteShareTaskDeviceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteShareTaskDeviceWithOptions(request, runtime);
  }

  async deleteSoundCodeWithOptions(request: DeleteSoundCodeRequest, runtime: $Util.RuntimeOptions): Promise<DeleteSoundCodeResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      body["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.soundCode)) {
      body["SoundCode"] = request.soundCode;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteSoundCode",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteSoundCodeResponse>(await this.callApi(params, req, runtime), new DeleteSoundCodeResponse({}));
  }

  async deleteSoundCode(request: DeleteSoundCodeRequest): Promise<DeleteSoundCodeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteSoundCodeWithOptions(request, runtime);
  }

  async deleteSoundCodeLabelWithOptions(request: DeleteSoundCodeLabelRequest, runtime: $Util.RuntimeOptions): Promise<DeleteSoundCodeLabelResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      body["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.soundCode)) {
      body["SoundCode"] = request.soundCode;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteSoundCodeLabel",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteSoundCodeLabelResponse>(await this.callApi(params, req, runtime), new DeleteSoundCodeLabelResponse({}));
  }

  async deleteSoundCodeLabel(request: DeleteSoundCodeLabelRequest): Promise<DeleteSoundCodeLabelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteSoundCodeLabelWithOptions(request, runtime);
  }

  async deleteSoundCodeScheduleWithOptions(request: DeleteSoundCodeScheduleRequest, runtime: $Util.RuntimeOptions): Promise<DeleteSoundCodeScheduleResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      body["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.scheduleCode)) {
      body["ScheduleCode"] = request.scheduleCode;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteSoundCodeSchedule",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteSoundCodeScheduleResponse>(await this.callApi(params, req, runtime), new DeleteSoundCodeScheduleResponse({}));
  }

  async deleteSoundCodeSchedule(request: DeleteSoundCodeScheduleRequest): Promise<DeleteSoundCodeScheduleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteSoundCodeScheduleWithOptions(request, runtime);
  }

  async deleteSpeechWithOptions(request: DeleteSpeechRequest, runtime: $Util.RuntimeOptions): Promise<DeleteSpeechResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      body["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.speechCodeList)) {
      body["SpeechCodeList"] = request.speechCodeList;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteSpeech",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteSpeechResponse>(await this.callApi(params, req, runtime), new DeleteSpeechResponse({}));
  }

  async deleteSpeech(request: DeleteSpeechRequest): Promise<DeleteSpeechResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteSpeechWithOptions(request, runtime);
  }

  async deleteStudioAppDomainOpenWithOptions(request: DeleteStudioAppDomainOpenRequest, runtime: $Util.RuntimeOptions): Promise<DeleteStudioAppDomainOpenResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appId)) {
      body["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.domainId)) {
      body["DomainId"] = request.domainId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      body["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteStudioAppDomainOpen",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteStudioAppDomainOpenResponse>(await this.callApi(params, req, runtime), new DeleteStudioAppDomainOpenResponse({}));
  }

  async deleteStudioAppDomainOpen(request: DeleteStudioAppDomainOpenRequest): Promise<DeleteStudioAppDomainOpenResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteStudioAppDomainOpenWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request DeleteSubscribeRelationRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return DeleteSubscribeRelationResponse
   */
  async deleteSubscribeRelationWithOptions(request: DeleteSubscribeRelationRequest, runtime: $Util.RuntimeOptions): Promise<DeleteSubscribeRelationResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteSubscribeRelation",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteSubscribeRelationResponse>(await this.callApi(params, req, runtime), new DeleteSubscribeRelationResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request DeleteSubscribeRelationRequest
    * @return DeleteSubscribeRelationResponse
   */
  async deleteSubscribeRelation(request: DeleteSubscribeRelationRequest): Promise<DeleteSubscribeRelationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteSubscribeRelationWithOptions(request, runtime);
  }

  /**
    * *   If a product is published, you must call the [CancelReleaseProduct](~~213875~~) operation to unpublish the product before you call the DeleteThingModel operation.
    * *   If an existing feature or custom TSL module in a product is not published, you can call the DeleteThingModel operation to remove the feature or delete the custom TSL module.
    * *   When you call the DeleteThingModel operation, you must specify a value for the **ProductKey** parameter. The following list describes how the DeleteThingModel operation works:
    *     *   If you specify a value only for the **ProductKey** parameter, the operation deletes all custom TSL modules and removes all features in the default TSL module from the specified product.
    *     *   If you specify values only for the **ProductKey** and **FunctionBlockId** parameters, the operation deletes the specified custom TSL module from the specified product.
    *     *   If you specify a value for the **ProductKey** parameter and a value for the **PropertyIdentifier.N**, **ServiceIdentifier.N**, or **EventIdentifier.N** parameter, the operation removes one or more specified features from the default TSL module of the specified product. The operation removes the specified features only if the features exist. If the value that you specified for the **PropertyIdentifier.N**, **ServiceIdentifier.N**, or **EventIdentifier.N** parameter does not exist in the default TSL module, the operation returns the same result as when you specify a value only for the **ProductKey** parameter.
    *     *   If you specify values for the **ProductKey** and **FunctionBlockId** parameters and a value for the **PropertyIdentifier.N**, **ServiceIdentifier.N**, or **EventIdentifier.N** parameter, the operation removes one or more specified features from a specified custom TSL module in a specified product. The operation removes the specified features only if the features exist. If the value that you specified for the **PropertyIdentifier.N**, **ServiceIdentifier.N**, or **EventIdentifier.N** parameter does not exist, the operation returns the same result as when you specify values only for the **ProductKey** and **FunctionBlockId** parameters.
    * > You must specify up to 10 identifiers for the **PropertyIdentifier.N**, **ServiceIdentifier.N**, or **EventIdentifier.N** parameter.
    * *   After you call the DeleteThingModel operation to remove one or more features from a product, you must call the [PublishThingModel](~~150311~~) operation to re-publish the TSL model of the product. This way, the change takes effect.
    * ## QPS limits
    * Each Alibaba Cloud account can run up to 5 queries per second (QPS). 
    * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
    *
    * @param request DeleteThingModelRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return DeleteThingModelResponse
   */
  async deleteThingModelWithOptions(request: DeleteThingModelRequest, runtime: $Util.RuntimeOptions): Promise<DeleteThingModelResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.eventIdentifier)) {
      query["EventIdentifier"] = request.eventIdentifier;
    }

    if (!Util.isUnset(request.functionBlockId)) {
      query["FunctionBlockId"] = request.functionBlockId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.propertyIdentifier)) {
      query["PropertyIdentifier"] = request.propertyIdentifier;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.serviceIdentifier)) {
      query["ServiceIdentifier"] = request.serviceIdentifier;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteThingModel",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteThingModelResponse>(await this.callApi(params, req, runtime), new DeleteThingModelResponse({}));
  }

  /**
    * *   If a product is published, you must call the [CancelReleaseProduct](~~213875~~) operation to unpublish the product before you call the DeleteThingModel operation.
    * *   If an existing feature or custom TSL module in a product is not published, you can call the DeleteThingModel operation to remove the feature or delete the custom TSL module.
    * *   When you call the DeleteThingModel operation, you must specify a value for the **ProductKey** parameter. The following list describes how the DeleteThingModel operation works:
    *     *   If you specify a value only for the **ProductKey** parameter, the operation deletes all custom TSL modules and removes all features in the default TSL module from the specified product.
    *     *   If you specify values only for the **ProductKey** and **FunctionBlockId** parameters, the operation deletes the specified custom TSL module from the specified product.
    *     *   If you specify a value for the **ProductKey** parameter and a value for the **PropertyIdentifier.N**, **ServiceIdentifier.N**, or **EventIdentifier.N** parameter, the operation removes one or more specified features from the default TSL module of the specified product. The operation removes the specified features only if the features exist. If the value that you specified for the **PropertyIdentifier.N**, **ServiceIdentifier.N**, or **EventIdentifier.N** parameter does not exist in the default TSL module, the operation returns the same result as when you specify a value only for the **ProductKey** parameter.
    *     *   If you specify values for the **ProductKey** and **FunctionBlockId** parameters and a value for the **PropertyIdentifier.N**, **ServiceIdentifier.N**, or **EventIdentifier.N** parameter, the operation removes one or more specified features from a specified custom TSL module in a specified product. The operation removes the specified features only if the features exist. If the value that you specified for the **PropertyIdentifier.N**, **ServiceIdentifier.N**, or **EventIdentifier.N** parameter does not exist, the operation returns the same result as when you specify values only for the **ProductKey** and **FunctionBlockId** parameters.
    * > You must specify up to 10 identifiers for the **PropertyIdentifier.N**, **ServiceIdentifier.N**, or **EventIdentifier.N** parameter.
    * *   After you call the DeleteThingModel operation to remove one or more features from a product, you must call the [PublishThingModel](~~150311~~) operation to re-publish the TSL model of the product. This way, the change takes effect.
    * ## QPS limits
    * Each Alibaba Cloud account can run up to 5 queries per second (QPS). 
    * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
    *
    * @param request DeleteThingModelRequest
    * @return DeleteThingModelResponse
   */
  async deleteThingModel(request: DeleteThingModelRequest): Promise<DeleteThingModelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteThingModelWithOptions(request, runtime);
  }

  async deleteTopicConfigWithOptions(request: DeleteTopicConfigRequest, runtime: $Util.RuntimeOptions): Promise<DeleteTopicConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.topicFullName)) {
      query["TopicFullName"] = request.topicFullName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteTopicConfig",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteTopicConfigResponse>(await this.callApi(params, req, runtime), new DeleteTopicConfigResponse({}));
  }

  async deleteTopicConfig(request: DeleteTopicConfigRequest): Promise<DeleteTopicConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteTopicConfigWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request DeleteTopicRouteTableRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return DeleteTopicRouteTableResponse
   */
  async deleteTopicRouteTableWithOptions(request: DeleteTopicRouteTableRequest, runtime: $Util.RuntimeOptions): Promise<DeleteTopicRouteTableResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dstTopic)) {
      query["DstTopic"] = request.dstTopic;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.srcTopic)) {
      query["SrcTopic"] = request.srcTopic;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteTopicRouteTable",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteTopicRouteTableResponse>(await this.callApi(params, req, runtime), new DeleteTopicRouteTableResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request DeleteTopicRouteTableRequest
    * @return DeleteTopicRouteTableResponse
   */
  async deleteTopicRouteTable(request: DeleteTopicRouteTableRequest): Promise<DeleteTopicRouteTableResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteTopicRouteTableWithOptions(request, runtime);
  }

  /**
    * ## QPS limits
    * Each Alibaba Cloud account can run up to 10 queries per second (QPS).
    * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
    *
    * @param request DetachDestinationRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return DetachDestinationResponse
   */
  async detachDestinationWithOptions(request: DetachDestinationRequest, runtime: $Util.RuntimeOptions): Promise<DetachDestinationResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.destinationId)) {
      query["DestinationId"] = request.destinationId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.parserId)) {
      query["ParserId"] = request.parserId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DetachDestination",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DetachDestinationResponse>(await this.callApi(params, req, runtime), new DetachDestinationResponse({}));
  }

  /**
    * ## QPS limits
    * Each Alibaba Cloud account can run up to 10 queries per second (QPS).
    * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
    *
    * @param request DetachDestinationRequest
    * @return DetachDestinationResponse
   */
  async detachDestination(request: DetachDestinationRequest): Promise<DetachDestinationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.detachDestinationWithOptions(request, runtime);
  }

  async detachParserDataSourceWithOptions(request: DetachParserDataSourceRequest, runtime: $Util.RuntimeOptions): Promise<DetachParserDataSourceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dataSourceId)) {
      query["DataSourceId"] = request.dataSourceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.parserId)) {
      query["ParserId"] = request.parserId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DetachParserDataSource",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DetachParserDataSourceResponse>(await this.callApi(params, req, runtime), new DetachParserDataSourceResponse({}));
  }

  async detachParserDataSource(request: DetachParserDataSourceRequest): Promise<DetachParserDataSourceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.detachParserDataSourceWithOptions(request, runtime);
  }

  async disableDeviceTunnelWithOptions(request: DisableDeviceTunnelRequest, runtime: $Util.RuntimeOptions): Promise<DisableDeviceTunnelResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DisableDeviceTunnel",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DisableDeviceTunnelResponse>(await this.callApi(params, req, runtime), new DisableDeviceTunnelResponse({}));
  }

  async disableDeviceTunnel(request: DisableDeviceTunnelRequest): Promise<DisableDeviceTunnelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.disableDeviceTunnelWithOptions(request, runtime);
  }

  async disableDeviceTunnelShareWithOptions(request: DisableDeviceTunnelShareRequest, runtime: $Util.RuntimeOptions): Promise<DisableDeviceTunnelShareResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DisableDeviceTunnelShare",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DisableDeviceTunnelShareResponse>(await this.callApi(params, req, runtime), new DisableDeviceTunnelShareResponse({}));
  }

  async disableDeviceTunnelShare(request: DisableDeviceTunnelShareRequest): Promise<DisableDeviceTunnelShareResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.disableDeviceTunnelShareWithOptions(request, runtime);
  }

  async disableSceneRuleWithOptions(request: DisableSceneRuleRequest, runtime: $Util.RuntimeOptions): Promise<DisableSceneRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.ruleId)) {
      query["RuleId"] = request.ruleId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DisableSceneRule",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DisableSceneRuleResponse>(await this.callApi(params, req, runtime), new DisableSceneRuleResponse({}));
  }

  async disableSceneRule(request: DisableSceneRuleRequest): Promise<DisableSceneRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.disableSceneRuleWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * *   After a device is disabled, you cannot connect the device to IoT Platform. You can perform device-specific operations on the device. However, the information about the device is still retained in IoT Platform. You can use the [EnableThing](~~69603~~) API operation to connect the disabled device to IoT Platform again.
    * *   Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
    * > RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request DisableThingRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return DisableThingResponse
   */
  async disableThingWithOptions(request: DisableThingRequest, runtime: $Util.RuntimeOptions): Promise<DisableThingResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotId)) {
      query["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DisableThing",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DisableThingResponse>(await this.callApi(params, req, runtime), new DisableThingResponse({}));
  }

  /**
    * ## Limits
    * *   After a device is disabled, you cannot connect the device to IoT Platform. You can perform device-specific operations on the device. However, the information about the device is still retained in IoT Platform. You can use the [EnableThing](~~69603~~) API operation to connect the disabled device to IoT Platform again.
    * *   Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
    * > RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request DisableThingRequest
    * @return DisableThingResponse
   */
  async disableThing(request: DisableThingRequest): Promise<DisableThingResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.disableThingWithOptions(request, runtime);
  }

  async enableDeviceTunnelWithOptions(request: EnableDeviceTunnelRequest, runtime: $Util.RuntimeOptions): Promise<EnableDeviceTunnelResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "EnableDeviceTunnel",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<EnableDeviceTunnelResponse>(await this.callApi(params, req, runtime), new EnableDeviceTunnelResponse({}));
  }

  async enableDeviceTunnel(request: EnableDeviceTunnelRequest): Promise<EnableDeviceTunnelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.enableDeviceTunnelWithOptions(request, runtime);
  }

  async enableDeviceTunnelShareWithOptions(request: EnableDeviceTunnelShareRequest, runtime: $Util.RuntimeOptions): Promise<EnableDeviceTunnelShareResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "EnableDeviceTunnelShare",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<EnableDeviceTunnelShareResponse>(await this.callApi(params, req, runtime), new EnableDeviceTunnelShareResponse({}));
  }

  async enableDeviceTunnelShare(request: EnableDeviceTunnelShareRequest): Promise<EnableDeviceTunnelShareResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.enableDeviceTunnelShareWithOptions(request, runtime);
  }

  async enableSceneRuleWithOptions(request: EnableSceneRuleRequest, runtime: $Util.RuntimeOptions): Promise<EnableSceneRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.ruleId)) {
      query["RuleId"] = request.ruleId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "EnableSceneRule",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<EnableSceneRuleResponse>(await this.callApi(params, req, runtime), new EnableSceneRuleResponse({}));
  }

  async enableSceneRule(request: EnableSceneRuleRequest): Promise<EnableSceneRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.enableSceneRuleWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request EnableThingRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return EnableThingResponse
   */
  async enableThingWithOptions(request: EnableThingRequest, runtime: $Util.RuntimeOptions): Promise<EnableThingResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotId)) {
      query["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "EnableThing",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<EnableThingResponse>(await this.callApi(params, req, runtime), new EnableThingResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request EnableThingRequest
    * @return EnableThingResponse
   */
  async enableThing(request: EnableThingRequest): Promise<EnableThingResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.enableThingWithOptions(request, runtime);
  }

  /**
    * This operation can be used with other operations to upload a device list file. Procedure:
    * 1. Call this operation to generate the information of a device list file that you want to upload to OSS.  
    * The response parameters of this API operation include:
    * The following request parameters of the OSS [PostObject](/help/en/object-storage-service/latest/postobject) operation that is used to upload the device list file: **Key**, **AccessKeyId**, **Signature**, and **Policy**.  
    * 2. Use an [OSS SDK](/help/en/object-storage-service/latest/sdk-code-samples-overview) to call the [PostObject](/help/en/object-storage-service/latest/postobject) operation to upload the device list file within 1 minute after a response is returned. For more information about sample code, see the "Usage of response parameters" section in this topic.  
    * >  The parameter information that is returned by this operation is valid for 1 minute. You must upload the device list file within 1 minute.  3. After you upload the device list file, call the [CreateOTAStaticUpgradeJob](/help/en/iot-platform/latest/e1qtmo) operation of IoT Platform to create a static update batch within 60 minutes.  
    * If you upload device list files but you do not call the CreateOTAStaticUpgradeJob operation to create a static update batch, the system automatically deletes the uploaded files. The system deletes files on a regular basis.  
    * ## QPS limits
    * Each Alibaba Cloud account can run up to 10 queries per second (QPS). 
    * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account. 
    * ## Requirements
    * *   A device list file contains the names of devices. Separate multiple device names with line feeds. Each line contains only one device name. A device list file must be in the CSV format. The maximum size of a device list file is 5 MB.
    * *   Each device list file can contain up to 10,000 names for the devices in a product that is related to an update package. If the number of device names in a device list file exceeds the limit, an error occurs when you use the file to create a static update batch.
    *
    * @param request GenerateDeviceNameListURLRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return GenerateDeviceNameListURLResponse
   */
  async generateDeviceNameListURLWithOptions(request: GenerateDeviceNameListURLRequest, runtime: $Util.RuntimeOptions): Promise<GenerateDeviceNameListURLResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GenerateDeviceNameListURL",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GenerateDeviceNameListURLResponse>(await this.callApi(params, req, runtime), new GenerateDeviceNameListURLResponse({}));
  }

  /**
    * This operation can be used with other operations to upload a device list file. Procedure:
    * 1. Call this operation to generate the information of a device list file that you want to upload to OSS.  
    * The response parameters of this API operation include:
    * The following request parameters of the OSS [PostObject](/help/en/object-storage-service/latest/postobject) operation that is used to upload the device list file: **Key**, **AccessKeyId**, **Signature**, and **Policy**.  
    * 2. Use an [OSS SDK](/help/en/object-storage-service/latest/sdk-code-samples-overview) to call the [PostObject](/help/en/object-storage-service/latest/postobject) operation to upload the device list file within 1 minute after a response is returned. For more information about sample code, see the "Usage of response parameters" section in this topic.  
    * >  The parameter information that is returned by this operation is valid for 1 minute. You must upload the device list file within 1 minute.  3. After you upload the device list file, call the [CreateOTAStaticUpgradeJob](/help/en/iot-platform/latest/e1qtmo) operation of IoT Platform to create a static update batch within 60 minutes.  
    * If you upload device list files but you do not call the CreateOTAStaticUpgradeJob operation to create a static update batch, the system automatically deletes the uploaded files. The system deletes files on a regular basis.  
    * ## QPS limits
    * Each Alibaba Cloud account can run up to 10 queries per second (QPS). 
    * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account. 
    * ## Requirements
    * *   A device list file contains the names of devices. Separate multiple device names with line feeds. Each line contains only one device name. A device list file must be in the CSV format. The maximum size of a device list file is 5 MB.
    * *   Each device list file can contain up to 10,000 names for the devices in a product that is related to an update package. If the number of device names in a device list file exceeds the limit, an error occurs when you use the file to create a static update batch.
    *
    * @param request GenerateDeviceNameListURLRequest
    * @return GenerateDeviceNameListURLResponse
   */
  async generateDeviceNameListURL(request: GenerateDeviceNameListURLRequest): Promise<GenerateDeviceNameListURLResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.generateDeviceNameListURLWithOptions(request, runtime);
  }

  async generateFileUploadURLWithOptions(request: GenerateFileUploadURLRequest, runtime: $Util.RuntimeOptions): Promise<GenerateFileUploadURLResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.bizCode)) {
      query["BizCode"] = request.bizCode;
    }

    if (!Util.isUnset(request.fileName)) {
      query["FileName"] = request.fileName;
    }

    if (!Util.isUnset(request.fileSuffix)) {
      query["FileSuffix"] = request.fileSuffix;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GenerateFileUploadURL",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GenerateFileUploadURLResponse>(await this.callApi(params, req, runtime), new GenerateFileUploadURLResponse({}));
  }

  async generateFileUploadURL(request: GenerateFileUploadURLRequest): Promise<GenerateFileUploadURLResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.generateFileUploadURLWithOptions(request, runtime);
  }

  /**
    * This operation can be used together with other operations to create an update package. Procedure:
    * 1\\. Call this API operation to generate the details of an update package file that you want to upload to OSS.
    * The following section describes the response parameters of this API operation:
    * *   The following request parameters of the OSS [PostObject](~~31988~~) operation that is used to upload the update package file: **Key**, **OSSAccessKeyId**, **Signature**, and **Policy**.
    * *   The following request parameter of the [CreateOTAFirmware](~~147311~~) operation that is used to create the update package: **FirmwareUrl**.
    * 2\\. Use an [OSS SDK](~~52834~~) to call the [PostObject](~~31988~~) operation to upload the update package file. For more information about sample code, see the "Usage of response parameters" section.
    * > The parameter information that is returned by this operation is valid for 1 minute. You must upload the update package file within 1 minute. The maximum size of the uploaded update package file is 1,000 MB.
    * 3\\. After the update package file is uploaded, call the [CreateOTAFirmware](~~147311~~) operation to create an update package within 60 minutes.
    * If update package files are uploaded but you do not call the CreateOTAFirmware operation to create update packages for the files, the uploaded files are automatically deleted by the system on a regular basis.
    * ## QPS limits
    * Each Alibaba Cloud account can run up to 10 queries per second (QPS). 
    * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
    *
    * @param request GenerateOTAUploadURLRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return GenerateOTAUploadURLResponse
   */
  async generateOTAUploadURLWithOptions(request: GenerateOTAUploadURLRequest, runtime: $Util.RuntimeOptions): Promise<GenerateOTAUploadURLResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.fileSuffix)) {
      query["FileSuffix"] = request.fileSuffix;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GenerateOTAUploadURL",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GenerateOTAUploadURLResponse>(await this.callApi(params, req, runtime), new GenerateOTAUploadURLResponse({}));
  }

  /**
    * This operation can be used together with other operations to create an update package. Procedure:
    * 1\\. Call this API operation to generate the details of an update package file that you want to upload to OSS.
    * The following section describes the response parameters of this API operation:
    * *   The following request parameters of the OSS [PostObject](~~31988~~) operation that is used to upload the update package file: **Key**, **OSSAccessKeyId**, **Signature**, and **Policy**.
    * *   The following request parameter of the [CreateOTAFirmware](~~147311~~) operation that is used to create the update package: **FirmwareUrl**.
    * 2\\. Use an [OSS SDK](~~52834~~) to call the [PostObject](~~31988~~) operation to upload the update package file. For more information about sample code, see the "Usage of response parameters" section.
    * > The parameter information that is returned by this operation is valid for 1 minute. You must upload the update package file within 1 minute. The maximum size of the uploaded update package file is 1,000 MB.
    * 3\\. After the update package file is uploaded, call the [CreateOTAFirmware](~~147311~~) operation to create an update package within 60 minutes.
    * If update package files are uploaded but you do not call the CreateOTAFirmware operation to create update packages for the files, the uploaded files are automatically deleted by the system on a regular basis.
    * ## QPS limits
    * Each Alibaba Cloud account can run up to 10 queries per second (QPS). 
    * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
    *
    * @param request GenerateOTAUploadURLRequest
    * @return GenerateOTAUploadURLResponse
   */
  async generateOTAUploadURL(request: GenerateOTAUploadURLRequest): Promise<GenerateOTAUploadURLResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.generateOTAUploadURLWithOptions(request, runtime);
  }

  async getDataAPIServiceDetailWithOptions(request: GetDataAPIServiceDetailRequest, runtime: $Util.RuntimeOptions): Promise<GetDataAPIServiceDetailResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.apiSrn)) {
      body["ApiSrn"] = request.apiSrn;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      body["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetDataAPIServiceDetail",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDataAPIServiceDetailResponse>(await this.callApi(params, req, runtime), new GetDataAPIServiceDetailResponse({}));
  }

  async getDataAPIServiceDetail(request: GetDataAPIServiceDetailRequest): Promise<GetDataAPIServiceDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDataAPIServiceDetailWithOptions(request, runtime);
  }

  async getDestinationWithOptions(request: GetDestinationRequest, runtime: $Util.RuntimeOptions): Promise<GetDestinationResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.destinationId)) {
      query["DestinationId"] = request.destinationId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetDestination",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDestinationResponse>(await this.callApi(params, req, runtime), new GetDestinationResponse({}));
  }

  async getDestination(request: GetDestinationRequest): Promise<GetDestinationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDestinationWithOptions(request, runtime);
  }

  /**
    * ## QPS limits
    * You can call this API operation up to 500 times per second per account.
    * >  The RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request GetDeviceShadowRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return GetDeviceShadowResponse
   */
  async getDeviceShadowWithOptions(request: GetDeviceShadowRequest, runtime: $Util.RuntimeOptions): Promise<GetDeviceShadowResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetDeviceShadow",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDeviceShadowResponse>(await this.callApi(params, req, runtime), new GetDeviceShadowResponse({}));
  }

  /**
    * ## QPS limits
    * You can call this API operation up to 500 times per second per account.
    * >  The RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request GetDeviceShadowRequest
    * @return GetDeviceShadowResponse
   */
  async getDeviceShadow(request: GetDeviceShadowRequest): Promise<GetDeviceShadowResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDeviceShadowWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request GetDeviceStatusRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return GetDeviceStatusResponse
   */
  async getDeviceStatusWithOptions(request: GetDeviceStatusRequest, runtime: $Util.RuntimeOptions): Promise<GetDeviceStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotId)) {
      query["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetDeviceStatus",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDeviceStatusResponse>(await this.callApi(params, req, runtime), new GetDeviceStatusResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request GetDeviceStatusRequest
    * @return GetDeviceStatusResponse
   */
  async getDeviceStatus(request: GetDeviceStatusRequest): Promise<GetDeviceStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDeviceStatusWithOptions(request, runtime);
  }

  async getDeviceTunnelShareStatusWithOptions(request: GetDeviceTunnelShareStatusRequest, runtime: $Util.RuntimeOptions): Promise<GetDeviceTunnelShareStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetDeviceTunnelShareStatus",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDeviceTunnelShareStatusResponse>(await this.callApi(params, req, runtime), new GetDeviceTunnelShareStatusResponse({}));
  }

  async getDeviceTunnelShareStatus(request: GetDeviceTunnelShareStatusRequest): Promise<GetDeviceTunnelShareStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDeviceTunnelShareStatusWithOptions(request, runtime);
  }

  async getDeviceTunnelStatusWithOptions(request: GetDeviceTunnelStatusRequest, runtime: $Util.RuntimeOptions): Promise<GetDeviceTunnelStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetDeviceTunnelStatus",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDeviceTunnelStatusResponse>(await this.callApi(params, req, runtime), new GetDeviceTunnelStatusResponse({}));
  }

  async getDeviceTunnelStatus(request: GetDeviceTunnelStatusRequest): Promise<GetDeviceTunnelStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDeviceTunnelStatusWithOptions(request, runtime);
  }

  async getDownloadFileWithOptions(tmpReq: GetDownloadFileRequest, runtime: $Util.RuntimeOptions): Promise<GetDownloadFileResponse> {
    Util.validateModel(tmpReq);
    let request = new GetDownloadFileShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.context)) {
      request.contextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.context, "Context", "json");
    }

    let query = { };
    if (!Util.isUnset(request.longJobId)) {
      query["LongJobId"] = request.longJobId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.contextShrink)) {
      body["Context"] = request.contextShrink;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      body["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetDownloadFile",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDownloadFileResponse>(await this.callApi(params, req, runtime), new GetDownloadFileResponse({}));
  }

  async getDownloadFile(request: GetDownloadFileRequest): Promise<GetDownloadFileResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDownloadFileWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request GetEdgeDriverVersionRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return GetEdgeDriverVersionResponse
   */
  async getEdgeDriverVersionWithOptions(request: GetEdgeDriverVersionRequest, runtime: $Util.RuntimeOptions): Promise<GetEdgeDriverVersionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.driverId)) {
      query["DriverId"] = request.driverId;
    }

    if (!Util.isUnset(request.driverVersion)) {
      query["DriverVersion"] = request.driverVersion;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetEdgeDriverVersion",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetEdgeDriverVersionResponse>(await this.callApi(params, req, runtime), new GetEdgeDriverVersionResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request GetEdgeDriverVersionRequest
    * @return GetEdgeDriverVersionResponse
   */
  async getEdgeDriverVersion(request: GetEdgeDriverVersionRequest): Promise<GetEdgeDriverVersionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getEdgeDriverVersionWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request GetEdgeInstanceRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return GetEdgeInstanceResponse
   */
  async getEdgeInstanceWithOptions(request: GetEdgeInstanceRequest, runtime: $Util.RuntimeOptions): Promise<GetEdgeInstanceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetEdgeInstance",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetEdgeInstanceResponse>(await this.callApi(params, req, runtime), new GetEdgeInstanceResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request GetEdgeInstanceRequest
    * @return GetEdgeInstanceResponse
   */
  async getEdgeInstance(request: GetEdgeInstanceRequest): Promise<GetEdgeInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getEdgeInstanceWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of five queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request GetEdgeInstanceDeploymentRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return GetEdgeInstanceDeploymentResponse
   */
  async getEdgeInstanceDeploymentWithOptions(request: GetEdgeInstanceDeploymentRequest, runtime: $Util.RuntimeOptions): Promise<GetEdgeInstanceDeploymentResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deploymentId)) {
      query["DeploymentId"] = request.deploymentId;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetEdgeInstanceDeployment",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetEdgeInstanceDeploymentResponse>(await this.callApi(params, req, runtime), new GetEdgeInstanceDeploymentResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of five queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request GetEdgeInstanceDeploymentRequest
    * @return GetEdgeInstanceDeploymentResponse
   */
  async getEdgeInstanceDeployment(request: GetEdgeInstanceDeploymentRequest): Promise<GetEdgeInstanceDeploymentResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getEdgeInstanceDeploymentWithOptions(request, runtime);
  }

  async getEdgeInstanceMessageRoutingWithOptions(request: GetEdgeInstanceMessageRoutingRequest, runtime: $Util.RuntimeOptions): Promise<GetEdgeInstanceMessageRoutingResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.routeId)) {
      query["RouteId"] = request.routeId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetEdgeInstanceMessageRouting",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetEdgeInstanceMessageRoutingResponse>(await this.callApi(params, req, runtime), new GetEdgeInstanceMessageRoutingResponse({}));
  }

  async getEdgeInstanceMessageRouting(request: GetEdgeInstanceMessageRoutingRequest): Promise<GetEdgeInstanceMessageRoutingResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getEdgeInstanceMessageRoutingWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request GetGatewayBySubDeviceRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return GetGatewayBySubDeviceResponse
   */
  async getGatewayBySubDeviceWithOptions(request: GetGatewayBySubDeviceRequest, runtime: $Util.RuntimeOptions): Promise<GetGatewayBySubDeviceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotId)) {
      query["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetGatewayBySubDevice",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetGatewayBySubDeviceResponse>(await this.callApi(params, req, runtime), new GetGatewayBySubDeviceResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request GetGatewayBySubDeviceRequest
    * @return GetGatewayBySubDeviceResponse
   */
  async getGatewayBySubDevice(request: GetGatewayBySubDeviceRequest): Promise<GetGatewayBySubDeviceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getGatewayBySubDeviceWithOptions(request, runtime);
  }

  async getLoraNodesTaskWithOptions(request: GetLoraNodesTaskRequest, runtime: $Util.RuntimeOptions): Promise<GetLoraNodesTaskResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.taskId)) {
      query["TaskId"] = request.taskId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetLoraNodesTask",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetLoraNodesTaskResponse>(await this.callApi(params, req, runtime), new GetLoraNodesTaskResponse({}));
  }

  async getLoraNodesTask(request: GetLoraNodesTaskRequest): Promise<GetLoraNodesTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getLoraNodesTaskWithOptions(request, runtime);
  }

  async getParserWithOptions(request: GetParserRequest, runtime: $Util.RuntimeOptions): Promise<GetParserResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.parserId)) {
      query["ParserId"] = request.parserId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetParser",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetParserResponse>(await this.callApi(params, req, runtime), new GetParserResponse({}));
  }

  async getParser(request: GetParserRequest): Promise<GetParserResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getParserWithOptions(request, runtime);
  }

  async getParserDataSourceWithOptions(request: GetParserDataSourceRequest, runtime: $Util.RuntimeOptions): Promise<GetParserDataSourceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dataSourceId)) {
      query["DataSourceId"] = request.dataSourceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetParserDataSource",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetParserDataSourceResponse>(await this.callApi(params, req, runtime), new GetParserDataSourceResponse({}));
  }

  async getParserDataSource(request: GetParserDataSourceRequest): Promise<GetParserDataSourceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getParserDataSourceWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request GetRuleRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return GetRuleResponse
   */
  async getRuleWithOptions(request: GetRuleRequest, runtime: $Util.RuntimeOptions): Promise<GetRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.ruleId)) {
      query["RuleId"] = request.ruleId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetRule",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetRuleResponse>(await this.callApi(params, req, runtime), new GetRuleResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request GetRuleRequest
    * @return GetRuleResponse
   */
  async getRule(request: GetRuleRequest): Promise<GetRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getRuleWithOptions(request, runtime);
  }

  /**
    * In addition to the preceding operation-specific request parameters, you must specify common request parameters when you call this operation. For more information, see [Common request parameters](~~30561~~).
    *
    * @param request GetRuleActionRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return GetRuleActionResponse
   */
  async getRuleActionWithOptions(request: GetRuleActionRequest, runtime: $Util.RuntimeOptions): Promise<GetRuleActionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.actionId)) {
      query["ActionId"] = request.actionId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetRuleAction",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetRuleActionResponse>(await this.callApi(params, req, runtime), new GetRuleActionResponse({}));
  }

  /**
    * In addition to the preceding operation-specific request parameters, you must specify common request parameters when you call this operation. For more information, see [Common request parameters](~~30561~~).
    *
    * @param request GetRuleActionRequest
    * @return GetRuleActionResponse
   */
  async getRuleAction(request: GetRuleActionRequest): Promise<GetRuleActionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getRuleActionWithOptions(request, runtime);
  }

  async getSceneRuleWithOptions(request: GetSceneRuleRequest, runtime: $Util.RuntimeOptions): Promise<GetSceneRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.ruleId)) {
      query["RuleId"] = request.ruleId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetSceneRule",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetSceneRuleResponse>(await this.callApi(params, req, runtime), new GetSceneRuleResponse({}));
  }

  async getSceneRule(request: GetSceneRuleRequest): Promise<GetSceneRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getSceneRuleWithOptions(request, runtime);
  }

  async getShareSpeechModelAudioWithOptions(request: GetShareSpeechModelAudioRequest, runtime: $Util.RuntimeOptions): Promise<GetShareSpeechModelAudioResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      body["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.shareTaskId)) {
      body["ShareTaskId"] = request.shareTaskId;
    }

    if (!Util.isUnset(request.speechModelCodeList)) {
      body["SpeechModelCodeList"] = request.speechModelCodeList;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetShareSpeechModelAudio",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetShareSpeechModelAudioResponse>(await this.callApi(params, req, runtime), new GetShareSpeechModelAudioResponse({}));
  }

  async getShareSpeechModelAudio(request: GetShareSpeechModelAudioRequest): Promise<GetShareSpeechModelAudioResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getShareSpeechModelAudioWithOptions(request, runtime);
  }

  async getShareTaskByDeviceOpenWithOptions(request: GetShareTaskByDeviceOpenRequest, runtime: $Util.RuntimeOptions): Promise<GetShareTaskByDeviceOpenResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.deviceName)) {
      body["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotId)) {
      body["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      body["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      body["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetShareTaskByDeviceOpen",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetShareTaskByDeviceOpenResponse>(await this.callApi(params, req, runtime), new GetShareTaskByDeviceOpenResponse({}));
  }

  async getShareTaskByDeviceOpen(request: GetShareTaskByDeviceOpenRequest): Promise<GetShareTaskByDeviceOpenResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getShareTaskByDeviceOpenWithOptions(request, runtime);
  }

  async getSoundCodeAudioWithOptions(request: GetSoundCodeAudioRequest, runtime: $Util.RuntimeOptions): Promise<GetSoundCodeAudioResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      body["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.soundCodeList)) {
      body["SoundCodeList"] = request.soundCodeList;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetSoundCodeAudio",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetSoundCodeAudioResponse>(await this.callApi(params, req, runtime), new GetSoundCodeAudioResponse({}));
  }

  async getSoundCodeAudio(request: GetSoundCodeAudioRequest): Promise<GetSoundCodeAudioResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getSoundCodeAudioWithOptions(request, runtime);
  }

  async getSoundCodeScheduleWithOptions(request: GetSoundCodeScheduleRequest, runtime: $Util.RuntimeOptions): Promise<GetSoundCodeScheduleResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      body["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.scheduleCode)) {
      body["ScheduleCode"] = request.scheduleCode;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetSoundCodeSchedule",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetSoundCodeScheduleResponse>(await this.callApi(params, req, runtime), new GetSoundCodeScheduleResponse({}));
  }

  async getSoundCodeSchedule(request: GetSoundCodeScheduleRequest): Promise<GetSoundCodeScheduleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getSoundCodeScheduleWithOptions(request, runtime);
  }

  async getSpeechDeviceDetailWithOptions(request: GetSpeechDeviceDetailRequest, runtime: $Util.RuntimeOptions): Promise<GetSpeechDeviceDetailResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.iotId)) {
      body["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      body["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetSpeechDeviceDetail",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetSpeechDeviceDetailResponse>(await this.callApi(params, req, runtime), new GetSpeechDeviceDetailResponse({}));
  }

  async getSpeechDeviceDetail(request: GetSpeechDeviceDetailRequest): Promise<GetSpeechDeviceDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getSpeechDeviceDetailWithOptions(request, runtime);
  }

  async getSpeechLicenseDeviceStatisticsWithOptions(request: GetSpeechLicenseDeviceStatisticsRequest, runtime: $Util.RuntimeOptions): Promise<GetSpeechLicenseDeviceStatisticsResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      body["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetSpeechLicenseDeviceStatistics",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetSpeechLicenseDeviceStatisticsResponse>(await this.callApi(params, req, runtime), new GetSpeechLicenseDeviceStatisticsResponse({}));
  }

  async getSpeechLicenseDeviceStatistics(request: GetSpeechLicenseDeviceStatisticsRequest): Promise<GetSpeechLicenseDeviceStatisticsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getSpeechLicenseDeviceStatisticsWithOptions(request, runtime);
  }

  async getSpeechVoiceWithOptions(runtime: $Util.RuntimeOptions): Promise<GetSpeechVoiceResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "GetSpeechVoice",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetSpeechVoiceResponse>(await this.callApi(params, req, runtime), new GetSpeechVoiceResponse({}));
  }

  async getSpeechVoice(): Promise<GetSpeechVoiceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getSpeechVoiceWithOptions(runtime);
  }

  async getStudioAppTokenOpenWithOptions(request: GetStudioAppTokenOpenRequest, runtime: $Util.RuntimeOptions): Promise<GetStudioAppTokenOpenResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appId)) {
      body["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      body["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetStudioAppTokenOpen",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetStudioAppTokenOpenResponse>(await this.callApi(params, req, runtime), new GetStudioAppTokenOpenResponse({}));
  }

  async getStudioAppTokenOpen(request: GetStudioAppTokenOpenRequest): Promise<GetStudioAppTokenOpenResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getStudioAppTokenOpenWithOptions(request, runtime);
  }

  /**
    * In addition to the preceding operation-specific request parameters, you must specify common request parameters when you call this operation. For more information, see [Common request parameters](~~30561~~).
    *
    * @param request GetThingModelTslRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return GetThingModelTslResponse
   */
  async getThingModelTslWithOptions(request: GetThingModelTslRequest, runtime: $Util.RuntimeOptions): Promise<GetThingModelTslResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.functionBlockId)) {
      query["FunctionBlockId"] = request.functionBlockId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.modelVersion)) {
      query["ModelVersion"] = request.modelVersion;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.simple)) {
      query["Simple"] = request.simple;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetThingModelTsl",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetThingModelTslResponse>(await this.callApi(params, req, runtime), new GetThingModelTslResponse({}));
  }

  /**
    * In addition to the preceding operation-specific request parameters, you must specify common request parameters when you call this operation. For more information, see [Common request parameters](~~30561~~).
    *
    * @param request GetThingModelTslRequest
    * @return GetThingModelTslResponse
   */
  async getThingModelTsl(request: GetThingModelTslRequest): Promise<GetThingModelTslResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getThingModelTslWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 20 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request GetThingModelTslPublishedRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return GetThingModelTslPublishedResponse
   */
  async getThingModelTslPublishedWithOptions(request: GetThingModelTslPublishedRequest, runtime: $Util.RuntimeOptions): Promise<GetThingModelTslPublishedResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.functionBlockId)) {
      query["FunctionBlockId"] = request.functionBlockId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.modelVersion)) {
      query["ModelVersion"] = request.modelVersion;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.simple)) {
      query["Simple"] = request.simple;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetThingModelTslPublished",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetThingModelTslPublishedResponse>(await this.callApi(params, req, runtime), new GetThingModelTslPublishedResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 20 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request GetThingModelTslPublishedRequest
    * @return GetThingModelTslPublishedResponse
   */
  async getThingModelTslPublished(request: GetThingModelTslPublishedRequest): Promise<GetThingModelTslPublishedResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getThingModelTslPublishedWithOptions(request, runtime);
  }

  /**
    * *   A data parsing script is used to convert the custom-formatted data to JSON data after the data is submitted by a device. You can write a script in JavaScript, Python 2.7, and PHP 7.2. For more information, see [Submit scripts for data parsing](~~149963~~).
    * *   Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
    * > RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request GetThingScriptRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return GetThingScriptResponse
   */
  async getThingScriptWithOptions(request: GetThingScriptRequest, runtime: $Util.RuntimeOptions): Promise<GetThingScriptResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetThingScript",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetThingScriptResponse>(await this.callApi(params, req, runtime), new GetThingScriptResponse({}));
  }

  /**
    * *   A data parsing script is used to convert the custom-formatted data to JSON data after the data is submitted by a device. You can write a script in JavaScript, Python 2.7, and PHP 7.2. For more information, see [Submit scripts for data parsing](~~149963~~).
    * *   Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
    * > RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request GetThingScriptRequest
    * @return GetThingScriptResponse
   */
  async getThingScript(request: GetThingScriptRequest): Promise<GetThingScriptResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getThingScriptWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 2 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request GetThingTemplateRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return GetThingTemplateResponse
   */
  async getThingTemplateWithOptions(request: GetThingTemplateRequest, runtime: $Util.RuntimeOptions): Promise<GetThingTemplateResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.categoryKey)) {
      query["CategoryKey"] = request.categoryKey;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetThingTemplate",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetThingTemplateResponse>(await this.callApi(params, req, runtime), new GetThingTemplateResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 2 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request GetThingTemplateRequest
    * @return GetThingTemplateResponse
   */
  async getThingTemplate(request: GetThingTemplateRequest): Promise<GetThingTemplateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getThingTemplateWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can initiate a maximum of 500 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request GetThingTopoRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return GetThingTopoResponse
   */
  async getThingTopoWithOptions(request: GetThingTopoRequest, runtime: $Util.RuntimeOptions): Promise<GetThingTopoResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotId)) {
      query["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageNo)) {
      query["PageNo"] = request.pageNo;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetThingTopo",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetThingTopoResponse>(await this.callApi(params, req, runtime), new GetThingTopoResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can initiate a maximum of 500 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request GetThingTopoRequest
    * @return GetThingTopoResponse
   */
  async getThingTopo(request: GetThingTopoRequest): Promise<GetThingTopoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getThingTopoWithOptions(request, runtime);
  }

  async gisQueryDeviceLocationWithOptions(request: GisQueryDeviceLocationRequest, runtime: $Util.RuntimeOptions): Promise<GisQueryDeviceLocationResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.thingList)) {
      query["ThingList"] = request.thingList;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GisQueryDeviceLocation",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GisQueryDeviceLocationResponse>(await this.callApi(params, req, runtime), new GisQueryDeviceLocationResponse({}));
  }

  async gisQueryDeviceLocation(request: GisQueryDeviceLocationRequest): Promise<GisQueryDeviceLocationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.gisQueryDeviceLocationWithOptions(request, runtime);
  }

  async gisSearchDeviceTraceWithOptions(request: GisSearchDeviceTraceRequest, runtime: $Util.RuntimeOptions): Promise<GisSearchDeviceTraceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.mapMatch)) {
      query["MapMatch"] = request.mapMatch;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GisSearchDeviceTrace",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GisSearchDeviceTraceResponse>(await this.callApi(params, req, runtime), new GisSearchDeviceTraceResponse({}));
  }

  async gisSearchDeviceTrace(request: GisSearchDeviceTraceRequest): Promise<GisSearchDeviceTraceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.gisSearchDeviceTraceWithOptions(request, runtime);
  }

  async importDTDataWithOptions(request: ImportDTDataRequest, runtime: $Util.RuntimeOptions): Promise<ImportDTDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.DTInstanceId)) {
      query["DTInstanceId"] = request.DTInstanceId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      body["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.items)) {
      body["Items"] = request.items;
    }

    if (!Util.isUnset(request.productKey)) {
      body["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ImportDTData",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ImportDTDataResponse>(await this.callApi(params, req, runtime), new ImportDTDataResponse({}));
  }

  async importDTData(request: ImportDTDataRequest): Promise<ImportDTDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.importDTDataWithOptions(request, runtime);
  }

  async importDeviceWithOptions(request: ImportDeviceRequest, runtime: $Util.RuntimeOptions): Promise<ImportDeviceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.deviceSecret)) {
      query["DeviceSecret"] = request.deviceSecret;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.nickname)) {
      query["Nickname"] = request.nickname;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.sn)) {
      query["Sn"] = request.sn;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ImportDevice",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ImportDeviceResponse>(await this.callApi(params, req, runtime), new ImportDeviceResponse({}));
  }

  async importDevice(request: ImportDeviceRequest): Promise<ImportDeviceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.importDeviceWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * *   If a product is published, you must call the [CancelReleaseProduct](~~213875~~) operation to unpublish the product before you call this operation.
    * *   Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
    * > RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request ImportThingModelTslRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return ImportThingModelTslResponse
   */
  async importThingModelTslWithOptions(request: ImportThingModelTslRequest, runtime: $Util.RuntimeOptions): Promise<ImportThingModelTslResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.functionBlockId)) {
      query["FunctionBlockId"] = request.functionBlockId;
    }

    if (!Util.isUnset(request.functionBlockName)) {
      query["FunctionBlockName"] = request.functionBlockName;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.tslStr)) {
      query["TslStr"] = request.tslStr;
    }

    if (!Util.isUnset(request.tslUrl)) {
      query["TslUrl"] = request.tslUrl;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ImportThingModelTsl",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ImportThingModelTslResponse>(await this.callApi(params, req, runtime), new ImportThingModelTslResponse({}));
  }

  /**
    * ## Limits
    * *   If a product is published, you must call the [CancelReleaseProduct](~~213875~~) operation to unpublish the product before you call this operation.
    * *   Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
    * > RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request ImportThingModelTslRequest
    * @return ImportThingModelTslResponse
   */
  async importThingModelTsl(request: ImportThingModelTslRequest): Promise<ImportThingModelTslResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.importThingModelTslWithOptions(request, runtime);
  }

  async invokeDataAPIServiceWithOptions(request: InvokeDataAPIServiceRequest, runtime: $Util.RuntimeOptions): Promise<InvokeDataAPIServiceResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.apiSrn)) {
      body["ApiSrn"] = request.apiSrn;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      body["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.param)) {
      body["Param"] = request.param;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "InvokeDataAPIService",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<InvokeDataAPIServiceResponse>(await this.callApi(params, req, runtime), new InvokeDataAPIServiceResponse({}));
  }

  async invokeDataAPIService(request: InvokeDataAPIServiceRequest): Promise<InvokeDataAPIServiceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.invokeDataAPIServiceWithOptions(request, runtime);
  }

  /**
    * When you define a service in a Thing Specification Language (TSL) model, the mode in which the service is called is specified. When you call a service by using this operation, IoT Platform uses a call mode based on the value of the **Identifier** parameter.
    * *   Synchronous mode: IoT Platform sends a revert-remote procedure call (RRPC) request to a device. Then, the device synchronously returns an RRPC response. For more information about how to use an RRPC, see [What is RRPC?](~~90567~~)
    * *   Asynchronous mode: IoT Platform sends an RRPC request to a device. Then, the device asynchronously returns an RRPC response. For more information about topics, see [Device properties, events, and services](~~89301~~).
    * > If you set the Checksum Type parameter to **Verification-free** when you create a product, the asynchronous mode is used.
    * When the device receives the service call, the device returns a response to the service caller. When you configure the device, you must specify the response logic and response parameters. The data formats of response parameters must comply with the Alink protocol. Example:
    * ```
    * {
    * 	"id": "58***89",
    * 	"code": 200,
    * 	"data": {},
    * 	"message": "success",
    * 	"localizedMsg": "localizedMsg"
    * }
    * ```
    * > *   The **id** parameter specifies the unique identifier of the request. The ID is generated by IoT Platform. The device can obtain the ID from the request parameters and then return the ID.
    * >*   The **code** parameter specifies the result of the service call. The value of the parameter is an integer.
    * >*   The **data** parameter specifies the result of the service call. This parameter is returned to the service caller. You can configure the parameters that you want to include in the returned result. The data must be in the JSON format.
    * >*   The **message** and **localizedMsg** parameters are optional.
    * >*   Link SDK for C of IoT Platform provides an example on how to use a TSL model. For more information, see [Call device services](~~258239~~).
    * ## Limits
    * If you synchronously call a service, the timeout period is 8 seconds. If a server does not receive a response within 8 seconds, a timeout error occurs. No limit is imposed on the timeout period of asynchronous calls. 
    * ## QPS limits
    * Each Alibaba Cloud account can run up to 500 queries per second (QPS). 
    * >  The RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request InvokeThingServiceRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return InvokeThingServiceResponse
   */
  async invokeThingServiceWithOptions(request: InvokeThingServiceRequest, runtime: $Util.RuntimeOptions): Promise<InvokeThingServiceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.args)) {
      query["Args"] = request.args;
    }

    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.identifier)) {
      query["Identifier"] = request.identifier;
    }

    if (!Util.isUnset(request.iotId)) {
      query["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "InvokeThingService",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<InvokeThingServiceResponse>(await this.callApi(params, req, runtime), new InvokeThingServiceResponse({}));
  }

  /**
    * When you define a service in a Thing Specification Language (TSL) model, the mode in which the service is called is specified. When you call a service by using this operation, IoT Platform uses a call mode based on the value of the **Identifier** parameter.
    * *   Synchronous mode: IoT Platform sends a revert-remote procedure call (RRPC) request to a device. Then, the device synchronously returns an RRPC response. For more information about how to use an RRPC, see [What is RRPC?](~~90567~~)
    * *   Asynchronous mode: IoT Platform sends an RRPC request to a device. Then, the device asynchronously returns an RRPC response. For more information about topics, see [Device properties, events, and services](~~89301~~).
    * > If you set the Checksum Type parameter to **Verification-free** when you create a product, the asynchronous mode is used.
    * When the device receives the service call, the device returns a response to the service caller. When you configure the device, you must specify the response logic and response parameters. The data formats of response parameters must comply with the Alink protocol. Example:
    * ```
    * {
    * 	"id": "58***89",
    * 	"code": 200,
    * 	"data": {},
    * 	"message": "success",
    * 	"localizedMsg": "localizedMsg"
    * }
    * ```
    * > *   The **id** parameter specifies the unique identifier of the request. The ID is generated by IoT Platform. The device can obtain the ID from the request parameters and then return the ID.
    * >*   The **code** parameter specifies the result of the service call. The value of the parameter is an integer.
    * >*   The **data** parameter specifies the result of the service call. This parameter is returned to the service caller. You can configure the parameters that you want to include in the returned result. The data must be in the JSON format.
    * >*   The **message** and **localizedMsg** parameters are optional.
    * >*   Link SDK for C of IoT Platform provides an example on how to use a TSL model. For more information, see [Call device services](~~258239~~).
    * ## Limits
    * If you synchronously call a service, the timeout period is 8 seconds. If a server does not receive a response within 8 seconds, a timeout error occurs. No limit is imposed on the timeout period of asynchronous calls. 
    * ## QPS limits
    * Each Alibaba Cloud account can run up to 500 queries per second (QPS). 
    * >  The RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request InvokeThingServiceRequest
    * @return InvokeThingServiceResponse
   */
  async invokeThingService(request: InvokeThingServiceRequest): Promise<InvokeThingServiceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.invokeThingServiceWithOptions(request, runtime);
  }

  /**
    * You can only asynchronously call this operation.
    * When the device receives the service call, the device returns a response to the service caller. When you configure the device, you must specify the response logic and response parameters. The data formats of response parameters must comply with the Alink protocol. Example:
    * ```
    * {
    * 	"id": "58***89",
    * 	"code": 200,
    * 	"data": {},
    * 	"message": "success",
    * 	"localizedMsg": "localizedMsg"
    * }
    * ```
    * > *   The **id** parameter specifies the unique identifier of the request. The ID is generated by IoT Platform. The device can obtain the ID from the request parameters and return the ID.
    * >*   The **code** parameter specifies the result of the service call. The value of the parameter is an integer.
    * >*   The **data** parameter specifies the result of the service call. This parameter is returned to the service caller. You can specify the parameters included in the returned result. The data must be in JSON format.
    * >*   The **message** and **localizedMsg** parameters are optional.
    * >*    Link SDK for C of IoT Platform provides an example on how to use a TSL model. For more information, see [Call device services](~~258239~~).
    * ## QPS limits
    * Each Alibaba Cloud account can run up to 10 queries per second (QPS). 
    * >  The RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request InvokeThingsServiceRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return InvokeThingsServiceResponse
   */
  async invokeThingsServiceWithOptions(request: InvokeThingsServiceRequest, runtime: $Util.RuntimeOptions): Promise<InvokeThingsServiceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.args)) {
      query["Args"] = request.args;
    }

    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.identifier)) {
      query["Identifier"] = request.identifier;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "InvokeThingsService",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<InvokeThingsServiceResponse>(await this.callApi(params, req, runtime), new InvokeThingsServiceResponse({}));
  }

  /**
    * You can only asynchronously call this operation.
    * When the device receives the service call, the device returns a response to the service caller. When you configure the device, you must specify the response logic and response parameters. The data formats of response parameters must comply with the Alink protocol. Example:
    * ```
    * {
    * 	"id": "58***89",
    * 	"code": 200,
    * 	"data": {},
    * 	"message": "success",
    * 	"localizedMsg": "localizedMsg"
    * }
    * ```
    * > *   The **id** parameter specifies the unique identifier of the request. The ID is generated by IoT Platform. The device can obtain the ID from the request parameters and return the ID.
    * >*   The **code** parameter specifies the result of the service call. The value of the parameter is an integer.
    * >*   The **data** parameter specifies the result of the service call. This parameter is returned to the service caller. You can specify the parameters included in the returned result. The data must be in JSON format.
    * >*   The **message** and **localizedMsg** parameters are optional.
    * >*    Link SDK for C of IoT Platform provides an example on how to use a TSL model. For more information, see [Call device services](~~258239~~).
    * ## QPS limits
    * Each Alibaba Cloud account can run up to 10 queries per second (QPS). 
    * >  The RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request InvokeThingsServiceRequest
    * @return InvokeThingsServiceResponse
   */
  async invokeThingsService(request: InvokeThingsServiceRequest): Promise<InvokeThingsServiceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.invokeThingsServiceWithOptions(request, runtime);
  }

  async listAnalyticsDataWithOptions(request: ListAnalyticsDataRequest, runtime: $Util.RuntimeOptions): Promise<ListAnalyticsDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.apiPath)) {
      query["ApiPath"] = request.apiPath;
    }

    if (!Util.isUnset(request.condition)) {
      query["Condition"] = request.condition;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.isoId)) {
      query["IsoId"] = request.isoId;
    }

    if (!Util.isUnset(request.pageNum)) {
      query["PageNum"] = request.pageNum;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListAnalyticsData",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListAnalyticsDataResponse>(await this.callApi(params, req, runtime), new ListAnalyticsDataResponse({}));
  }

  async listAnalyticsData(request: ListAnalyticsDataRequest): Promise<ListAnalyticsDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listAnalyticsDataWithOptions(request, runtime);
  }

  async listDataSourceItemWithOptions(request: ListDataSourceItemRequest, runtime: $Util.RuntimeOptions): Promise<ListDataSourceItemResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dataSourceId)) {
      query["DataSourceId"] = request.dataSourceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.page)) {
      query["Page"] = request.page;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.searchName)) {
      query["SearchName"] = request.searchName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListDataSourceItem",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListDataSourceItemResponse>(await this.callApi(params, req, runtime), new ListDataSourceItemResponse({}));
  }

  async listDataSourceItem(request: ListDataSourceItemRequest): Promise<ListDataSourceItemResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listDataSourceItemWithOptions(request, runtime);
  }

  async listDestinationWithOptions(request: ListDestinationRequest, runtime: $Util.RuntimeOptions): Promise<ListDestinationResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.page)) {
      query["Page"] = request.page;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.searchName)) {
      query["SearchName"] = request.searchName;
    }

    if (!Util.isUnset(request.types)) {
      query["Types"] = request.types;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListDestination",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListDestinationResponse>(await this.callApi(params, req, runtime), new ListDestinationResponse({}));
  }

  async listDestination(request: ListDestinationRequest): Promise<ListDestinationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listDestinationWithOptions(request, runtime);
  }

  /**
    * If you use an Enterprise Edition instance, you must specify the **IotInstanceId** parameter when you call this operation. Otherwise, the call fails.
    * ## QPS limits
    * You can call this API operation up to five times per second per account. 
    * >  The RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request ListDeviceDistributeJobRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return ListDeviceDistributeJobResponse
   */
  async listDeviceDistributeJobWithOptions(request: ListDeviceDistributeJobRequest, runtime: $Util.RuntimeOptions): Promise<ListDeviceDistributeJobResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    if (!Util.isUnset(request.targetUid)) {
      query["TargetUid"] = request.targetUid;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.jobId)) {
      body["JobId"] = request.jobId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ListDeviceDistributeJob",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListDeviceDistributeJobResponse>(await this.callApi(params, req, runtime), new ListDeviceDistributeJobResponse({}));
  }

  /**
    * If you use an Enterprise Edition instance, you must specify the **IotInstanceId** parameter when you call this operation. Otherwise, the call fails.
    * ## QPS limits
    * You can call this API operation up to five times per second per account. 
    * >  The RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request ListDeviceDistributeJobRequest
    * @return ListDeviceDistributeJobResponse
   */
  async listDeviceDistributeJob(request: ListDeviceDistributeJobRequest): Promise<ListDeviceDistributeJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listDeviceDistributeJobWithOptions(request, runtime);
  }

  /**
    * *   This operation can be called only by using the following **endpoint**: `iot.cn-shanghai.aliyuncs.com`.
    * *   Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
    * > RAM users of an Alibaba Cloud account share the quota of the account.
    * *   Multiple Alibaba Cloud accounts can run a maximum of 200 QPS at the same time.
    *
    * @param request ListDistributedDeviceRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return ListDistributedDeviceResponse
   */
  async listDistributedDeviceWithOptions(request: ListDistributedDeviceRequest, runtime: $Util.RuntimeOptions): Promise<ListDistributedDeviceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.sourceInstanceId)) {
      query["SourceInstanceId"] = request.sourceInstanceId;
    }

    if (!Util.isUnset(request.targetUid)) {
      query["TargetUid"] = request.targetUid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListDistributedDevice",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListDistributedDeviceResponse>(await this.callApi(params, req, runtime), new ListDistributedDeviceResponse({}));
  }

  /**
    * *   This operation can be called only by using the following **endpoint**: `iot.cn-shanghai.aliyuncs.com`.
    * *   Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
    * > RAM users of an Alibaba Cloud account share the quota of the account.
    * *   Multiple Alibaba Cloud accounts can run a maximum of 200 QPS at the same time.
    *
    * @param request ListDistributedDeviceRequest
    * @return ListDistributedDeviceResponse
   */
  async listDistributedDevice(request: ListDistributedDeviceRequest): Promise<ListDistributedDeviceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listDistributedDeviceWithOptions(request, runtime);
  }

  /**
    * You can call this operation only by using the following **endpoint**: `iot.cn-shanghai.aliyuncs.com`.
    * ## QPS limits
    * You can call this API operation up to five times per second per account. 
    * >  The RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request ListDistributedProductRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return ListDistributedProductResponse
   */
  async listDistributedProductWithOptions(request: ListDistributedProductRequest, runtime: $Util.RuntimeOptions): Promise<ListDistributedProductResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.sourceInstanceId)) {
      query["SourceInstanceId"] = request.sourceInstanceId;
    }

    if (!Util.isUnset(request.targetInstanceId)) {
      query["TargetInstanceId"] = request.targetInstanceId;
    }

    if (!Util.isUnset(request.targetUid)) {
      query["TargetUid"] = request.targetUid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListDistributedProduct",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListDistributedProductResponse>(await this.callApi(params, req, runtime), new ListDistributedProductResponse({}));
  }

  /**
    * You can call this operation only by using the following **endpoint**: `iot.cn-shanghai.aliyuncs.com`.
    * ## QPS limits
    * You can call this API operation up to five times per second per account. 
    * >  The RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request ListDistributedProductRequest
    * @return ListDistributedProductResponse
   */
  async listDistributedProduct(request: ListDistributedProductRequest): Promise<ListDistributedProductResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listDistributedProductWithOptions(request, runtime);
  }

  async listJobWithOptions(request: ListJobRequest, runtime: $Util.RuntimeOptions): Promise<ListJobResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListJob",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListJobResponse>(await this.callApi(params, req, runtime), new ListJobResponse({}));
  }

  async listJob(request: ListJobRequest): Promise<ListJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listJobWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request ListOTAFirmwareRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return ListOTAFirmwareResponse
   */
  async listOTAFirmwareWithOptions(request: ListOTAFirmwareRequest, runtime: $Util.RuntimeOptions): Promise<ListOTAFirmwareResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.destVersion)) {
      query["DestVersion"] = request.destVersion;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListOTAFirmware",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListOTAFirmwareResponse>(await this.callApi(params, req, runtime), new ListOTAFirmwareResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request ListOTAFirmwareRequest
    * @return ListOTAFirmwareResponse
   */
  async listOTAFirmware(request: ListOTAFirmwareRequest): Promise<ListOTAFirmwareResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listOTAFirmwareWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request ListOTAJobByDeviceRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return ListOTAJobByDeviceResponse
   */
  async listOTAJobByDeviceWithOptions(request: ListOTAJobByDeviceRequest, runtime: $Util.RuntimeOptions): Promise<ListOTAJobByDeviceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.firmwareId)) {
      query["FirmwareId"] = request.firmwareId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListOTAJobByDevice",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListOTAJobByDeviceResponse>(await this.callApi(params, req, runtime), new ListOTAJobByDeviceResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request ListOTAJobByDeviceRequest
    * @return ListOTAJobByDeviceResponse
   */
  async listOTAJobByDevice(request: ListOTAJobByDeviceRequest): Promise<ListOTAJobByDeviceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listOTAJobByDeviceWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request ListOTAJobByFirmwareRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return ListOTAJobByFirmwareResponse
   */
  async listOTAJobByFirmwareWithOptions(request: ListOTAJobByFirmwareRequest, runtime: $Util.RuntimeOptions): Promise<ListOTAJobByFirmwareResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.firmwareId)) {
      query["FirmwareId"] = request.firmwareId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListOTAJobByFirmware",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListOTAJobByFirmwareResponse>(await this.callApi(params, req, runtime), new ListOTAJobByFirmwareResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request ListOTAJobByFirmwareRequest
    * @return ListOTAJobByFirmwareResponse
   */
  async listOTAJobByFirmware(request: ListOTAJobByFirmwareRequest): Promise<ListOTAJobByFirmwareResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listOTAJobByFirmwareWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request ListOTAModuleByProductRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return ListOTAModuleByProductResponse
   */
  async listOTAModuleByProductWithOptions(request: ListOTAModuleByProductRequest, runtime: $Util.RuntimeOptions): Promise<ListOTAModuleByProductResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListOTAModuleByProduct",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListOTAModuleByProductResponse>(await this.callApi(params, req, runtime), new ListOTAModuleByProductResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request ListOTAModuleByProductRequest
    * @return ListOTAModuleByProductResponse
   */
  async listOTAModuleByProduct(request: ListOTAModuleByProductRequest): Promise<ListOTAModuleByProductResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listOTAModuleByProductWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request ListOTAModuleVersionsByDeviceRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return ListOTAModuleVersionsByDeviceResponse
   */
  async listOTAModuleVersionsByDeviceWithOptions(request: ListOTAModuleVersionsByDeviceRequest, runtime: $Util.RuntimeOptions): Promise<ListOTAModuleVersionsByDeviceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotId)) {
      query["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListOTAModuleVersionsByDevice",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListOTAModuleVersionsByDeviceResponse>(await this.callApi(params, req, runtime), new ListOTAModuleVersionsByDeviceResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request ListOTAModuleVersionsByDeviceRequest
    * @return ListOTAModuleVersionsByDeviceResponse
   */
  async listOTAModuleVersionsByDevice(request: ListOTAModuleVersionsByDeviceRequest): Promise<ListOTAModuleVersionsByDeviceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listOTAModuleVersionsByDeviceWithOptions(request, runtime);
  }

  /**
    * ## QPS limits
    * Each Alibaba Cloud account can run up to 10 queries per second (QPS).
    * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
    *
    * @param request ListOTATaskByJobRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return ListOTATaskByJobResponse
   */
  async listOTATaskByJobWithOptions(request: ListOTATaskByJobRequest, runtime: $Util.RuntimeOptions): Promise<ListOTATaskByJobResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.deviceNames)) {
      query["DeviceNames"] = request.deviceNames;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.jobId)) {
      query["JobId"] = request.jobId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.taskStatus)) {
      query["TaskStatus"] = request.taskStatus;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListOTATaskByJob",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListOTATaskByJobResponse>(await this.callApi(params, req, runtime), new ListOTATaskByJobResponse({}));
  }

  /**
    * ## QPS limits
    * Each Alibaba Cloud account can run up to 10 queries per second (QPS).
    * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
    *
    * @param request ListOTATaskByJobRequest
    * @return ListOTATaskByJobResponse
   */
  async listOTATaskByJob(request: ListOTATaskByJobRequest): Promise<ListOTATaskByJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listOTATaskByJobWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request ListOTAUnfinishedTaskByDeviceRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return ListOTAUnfinishedTaskByDeviceResponse
   */
  async listOTAUnfinishedTaskByDeviceWithOptions(request: ListOTAUnfinishedTaskByDeviceRequest, runtime: $Util.RuntimeOptions): Promise<ListOTAUnfinishedTaskByDeviceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotId)) {
      query["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.moduleName)) {
      query["ModuleName"] = request.moduleName;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.taskStatus)) {
      query["TaskStatus"] = request.taskStatus;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListOTAUnfinishedTaskByDevice",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListOTAUnfinishedTaskByDeviceResponse>(await this.callApi(params, req, runtime), new ListOTAUnfinishedTaskByDeviceResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request ListOTAUnfinishedTaskByDeviceRequest
    * @return ListOTAUnfinishedTaskByDeviceResponse
   */
  async listOTAUnfinishedTaskByDevice(request: ListOTAUnfinishedTaskByDeviceRequest): Promise<ListOTAUnfinishedTaskByDeviceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listOTAUnfinishedTaskByDeviceWithOptions(request, runtime);
  }

  async listParserWithOptions(request: ListParserRequest, runtime: $Util.RuntimeOptions): Promise<ListParserResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.searchName)) {
      query["SearchName"] = request.searchName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListParser",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListParserResponse>(await this.callApi(params, req, runtime), new ListParserResponse({}));
  }

  async listParser(request: ListParserRequest): Promise<ListParserResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listParserWithOptions(request, runtime);
  }

  async listParserDataSourceWithOptions(request: ListParserDataSourceRequest, runtime: $Util.RuntimeOptions): Promise<ListParserDataSourceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.page)) {
      query["Page"] = request.page;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.searchName)) {
      query["SearchName"] = request.searchName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListParserDataSource",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListParserDataSourceResponse>(await this.callApi(params, req, runtime), new ListParserDataSourceResponse({}));
  }

  async listParserDataSource(request: ListParserDataSourceRequest): Promise<ListParserDataSourceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listParserDataSourceWithOptions(request, runtime);
  }

  async listParserDestinationWithOptions(request: ListParserDestinationRequest, runtime: $Util.RuntimeOptions): Promise<ListParserDestinationResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.isFailover)) {
      query["IsFailover"] = request.isFailover;
    }

    if (!Util.isUnset(request.parserId)) {
      query["ParserId"] = request.parserId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListParserDestination",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListParserDestinationResponse>(await this.callApi(params, req, runtime), new ListParserDestinationResponse({}));
  }

  async listParserDestination(request: ListParserDestinationRequest): Promise<ListParserDestinationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listParserDestinationWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * *   Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
    * > RAM users of an Alibaba Cloud account share the quota of the account.
    * *   You can specify a tag key or a tag key-value pair for search.
    * *   If you specify multiple tags, the logical relationship among these tags is **OR**.
    *
    * @param request ListProductByTagsRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return ListProductByTagsResponse
   */
  async listProductByTagsWithOptions(request: ListProductByTagsRequest, runtime: $Util.RuntimeOptions): Promise<ListProductByTagsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.productTag)) {
      query["ProductTag"] = request.productTag;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListProductByTags",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListProductByTagsResponse>(await this.callApi(params, req, runtime), new ListProductByTagsResponse({}));
  }

  /**
    * ## Limits
    * *   Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
    * > RAM users of an Alibaba Cloud account share the quota of the account.
    * *   You can specify a tag key or a tag key-value pair for search.
    * *   If you specify multiple tags, the logical relationship among these tags is **OR**.
    *
    * @param request ListProductByTagsRequest
    * @return ListProductByTagsResponse
   */
  async listProductByTags(request: ListProductByTagsRequest): Promise<ListProductByTagsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listProductByTagsWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request ListProductTagsRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return ListProductTagsResponse
   */
  async listProductTagsWithOptions(request: ListProductTagsRequest, runtime: $Util.RuntimeOptions): Promise<ListProductTagsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListProductTags",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListProductTagsResponse>(await this.callApi(params, req, runtime), new ListProductTagsResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request ListProductTagsRequest
    * @return ListProductTagsResponse
   */
  async listProductTags(request: ListProductTagsRequest): Promise<ListProductTagsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listProductTagsWithOptions(request, runtime);
  }

  /**
    * ## QPS limits
    * You can call this API operation up to 20 times per second per account.
    * >  The RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request ListRuleRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return ListRuleResponse
   */
  async listRuleWithOptions(request: ListRuleRequest, runtime: $Util.RuntimeOptions): Promise<ListRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListRule",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListRuleResponse>(await this.callApi(params, req, runtime), new ListRuleResponse({}));
  }

  /**
    * ## QPS limits
    * You can call this API operation up to 20 times per second per account.
    * >  The RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request ListRuleRequest
    * @return ListRuleResponse
   */
  async listRule(request: ListRuleRequest): Promise<ListRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listRuleWithOptions(request, runtime);
  }

  /**
    * ## QPS limits
    * Each Alibaba Cloud account can run up to 50 queries per second (QPS).
    * >  The Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request ListRuleActionsRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return ListRuleActionsResponse
   */
  async listRuleActionsWithOptions(request: ListRuleActionsRequest, runtime: $Util.RuntimeOptions): Promise<ListRuleActionsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.ruleId)) {
      query["RuleId"] = request.ruleId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListRuleActions",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListRuleActionsResponse>(await this.callApi(params, req, runtime), new ListRuleActionsResponse({}));
  }

  /**
    * ## QPS limits
    * Each Alibaba Cloud account can run up to 50 queries per second (QPS).
    * >  The Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request ListRuleActionsRequest
    * @return ListRuleActionsResponse
   */
  async listRuleActions(request: ListRuleActionsRequest): Promise<ListRuleActionsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listRuleActionsWithOptions(request, runtime);
  }

  async listTaskWithOptions(tmpReq: ListTaskRequest, runtime: $Util.RuntimeOptions): Promise<ListTaskResponse> {
    Util.validateModel(tmpReq);
    let request = new ListTaskShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.device)) {
      request.deviceShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.device, "Device", "json");
    }

    let query = { };
    if (!Util.isUnset(request.deviceShrink)) {
      query["Device"] = request.deviceShrink;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.jobId)) {
      query["JobId"] = request.jobId;
    }

    if (!Util.isUnset(request.limit)) {
      query["Limit"] = request.limit;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListTask",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListTaskResponse>(await this.callApi(params, req, runtime), new ListTaskResponse({}));
  }

  async listTask(request: ListTaskRequest): Promise<ListTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listTaskWithOptions(request, runtime);
  }

  /**
    * You can manage TSL models by version. After you import a TSL model by calling the [ImportThingModelTsl](~~150320~~) operation, copy a TSL model by calling the [CopyThingModel](~~150322~~) operation, or edit a TSL model, you must publish the TSL model by calling the [PublishThingModel](~~150311~~) operation. Then, the TSL model can be used. Each time a TSL model of a product is published, a new version is generated.
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS). 
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request ListThingModelVersionRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return ListThingModelVersionResponse
   */
  async listThingModelVersionWithOptions(request: ListThingModelVersionRequest, runtime: $Util.RuntimeOptions): Promise<ListThingModelVersionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListThingModelVersion",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListThingModelVersionResponse>(await this.callApi(params, req, runtime), new ListThingModelVersionResponse({}));
  }

  /**
    * You can manage TSL models by version. After you import a TSL model by calling the [ImportThingModelTsl](~~150320~~) operation, copy a TSL model by calling the [CopyThingModel](~~150322~~) operation, or edit a TSL model, you must publish the TSL model by calling the [PublishThingModel](~~150311~~) operation. Then, the TSL model can be used. Each time a TSL model of a product is published, a new version is generated.
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS). 
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request ListThingModelVersionRequest
    * @return ListThingModelVersionResponse
   */
  async listThingModelVersion(request: ListThingModelVersionRequest): Promise<ListThingModelVersionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listThingModelVersionWithOptions(request, runtime);
  }

  /**
    * IoT Platform provides product categories that have defined TSL models, such as street lamps, vehicle location cards, and water immersion detectors.
    * When you call the [CreateProduct](~~69123~~) operation to create a product, you can set the CategoryKey parameter to specify a product category. The product that you create references the standardized TSL model of the specified category.
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS). 
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request ListThingTemplatesRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return ListThingTemplatesResponse
   */
  async listThingTemplatesWithOptions(request: ListThingTemplatesRequest, runtime: $Util.RuntimeOptions): Promise<ListThingTemplatesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListThingTemplates",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListThingTemplatesResponse>(await this.callApi(params, req, runtime), new ListThingTemplatesResponse({}));
  }

  /**
    * IoT Platform provides product categories that have defined TSL models, such as street lamps, vehicle location cards, and water immersion detectors.
    * When you call the [CreateProduct](~~69123~~) operation to create a product, you can set the CategoryKey parameter to specify a product category. The product that you create references the standardized TSL model of the specified category.
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS). 
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request ListThingTemplatesRequest
    * @return ListThingTemplatesResponse
   */
  async listThingTemplates(request: ListThingTemplatesRequest): Promise<ListThingTemplatesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listThingTemplatesWithOptions(request, runtime);
  }

  /**
    * A successful response indicates that the command to add topological relationships is sent to the gateway. It does not indicate that the topological relationships are added.
    * When you develop the gateway, you must subscribe to the topic that is used to send notifications when you add topological relationships. For more information about the topic and message format, see [Manage topological relationships](~~89299~~).
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS). 
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request NotifyAddThingTopoRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return NotifyAddThingTopoResponse
   */
  async notifyAddThingTopoWithOptions(request: NotifyAddThingTopoRequest, runtime: $Util.RuntimeOptions): Promise<NotifyAddThingTopoResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceListStr)) {
      query["DeviceListStr"] = request.deviceListStr;
    }

    if (!Util.isUnset(request.gwDeviceName)) {
      query["GwDeviceName"] = request.gwDeviceName;
    }

    if (!Util.isUnset(request.gwIotId)) {
      query["GwIotId"] = request.gwIotId;
    }

    if (!Util.isUnset(request.gwProductKey)) {
      query["GwProductKey"] = request.gwProductKey;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "NotifyAddThingTopo",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<NotifyAddThingTopoResponse>(await this.callApi(params, req, runtime), new NotifyAddThingTopoResponse({}));
  }

  /**
    * A successful response indicates that the command to add topological relationships is sent to the gateway. It does not indicate that the topological relationships are added.
    * When you develop the gateway, you must subscribe to the topic that is used to send notifications when you add topological relationships. For more information about the topic and message format, see [Manage topological relationships](~~89299~~).
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS). 
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request NotifyAddThingTopoRequest
    * @return NotifyAddThingTopoResponse
   */
  async notifyAddThingTopo(request: NotifyAddThingTopoRequest): Promise<NotifyAddThingTopoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.notifyAddThingTopoWithOptions(request, runtime);
  }

  async openIotServiceWithOptions(request: OpenIotServiceRequest, runtime: $Util.RuntimeOptions): Promise<OpenIotServiceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "OpenIotService",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<OpenIotServiceResponse>(await this.callApi(params, req, runtime), new OpenIotServiceResponse({}));
  }

  async openIotService(request: OpenIotServiceRequest): Promise<OpenIotServiceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.openIotServiceWithOptions(request, runtime);
  }

  async packageSoundCodeLabelBatchAudioWithOptions(request: PackageSoundCodeLabelBatchAudioRequest, runtime: $Util.RuntimeOptions): Promise<PackageSoundCodeLabelBatchAudioResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.batchCode)) {
      body["BatchCode"] = request.batchCode;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      body["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "PackageSoundCodeLabelBatchAudio",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<PackageSoundCodeLabelBatchAudioResponse>(await this.callApi(params, req, runtime), new PackageSoundCodeLabelBatchAudioResponse({}));
  }

  async packageSoundCodeLabelBatchAudio(request: PackageSoundCodeLabelBatchAudioRequest): Promise<PackageSoundCodeLabelBatchAudioResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.packageSoundCodeLabelBatchAudioWithOptions(request, runtime);
  }

  async pageQuerySharedSpeechOpenWithOptions(request: PageQuerySharedSpeechOpenRequest, runtime: $Util.RuntimeOptions): Promise<PageQuerySharedSpeechOpenResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.deviceName)) {
      body["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotId)) {
      body["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      body["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageId)) {
      body["PageId"] = request.pageId;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.productKey)) {
      body["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.shareTaskCode)) {
      body["ShareTaskCode"] = request.shareTaskCode;
    }

    if (!Util.isUnset(request.status)) {
      body["Status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "PageQuerySharedSpeechOpen",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<PageQuerySharedSpeechOpenResponse>(await this.callApi(params, req, runtime), new PageQuerySharedSpeechOpenResponse({}));
  }

  async pageQuerySharedSpeechOpen(request: PageQuerySharedSpeechOpenRequest): Promise<PageQuerySharedSpeechOpenResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.pageQuerySharedSpeechOpenWithOptions(request, runtime);
  }

  async pageQuerySpeechBroadcastHourWithOptions(request: PageQuerySpeechBroadcastHourRequest, runtime: $Util.RuntimeOptions): Promise<PageQuerySpeechBroadcastHourResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.queryDateTimeHour)) {
      query["QueryDateTimeHour"] = request.queryDateTimeHour;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      body["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.pageToken)) {
      body["PageToken"] = request.pageToken;
    }

    if (!Util.isUnset(request.shareTaskCode)) {
      body["ShareTaskCode"] = request.shareTaskCode;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "PageQuerySpeechBroadcastHour",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<PageQuerySpeechBroadcastHourResponse>(await this.callApi(params, req, runtime), new PageQuerySpeechBroadcastHourResponse({}));
  }

  async pageQuerySpeechBroadcastHour(request: PageQuerySpeechBroadcastHourRequest): Promise<PageQuerySpeechBroadcastHourResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.pageQuerySpeechBroadcastHourWithOptions(request, runtime);
  }

  async printByTemplateWithOptions(request: PrintByTemplateRequest, runtime: $Util.RuntimeOptions): Promise<PrintByTemplateResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.deviceName)) {
      body["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.historyPrintTopic)) {
      body["HistoryPrintTopic"] = request.historyPrintTopic;
    }

    if (!Util.isUnset(request.iotId)) {
      body["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      body["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.paramsJsonString)) {
      body["ParamsJsonString"] = request.paramsJsonString;
    }

    if (!Util.isUnset(request.productKey)) {
      body["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.templateBizCode)) {
      body["TemplateBizCode"] = request.templateBizCode;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "PrintByTemplate",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<PrintByTemplateResponse>(await this.callApi(params, req, runtime), new PrintByTemplateResponse({}));
  }

  async printByTemplate(request: PrintByTemplateRequest): Promise<PrintByTemplateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.printByTemplateWithOptions(request, runtime);
  }

  /**
    * This operation does not support device property settings and service invocations.
    * *   To set properties, call the [SetDeviceProperty](~~69579~~) or [SetDevicesProperty](~~96243~~) operation.
    * *   To invoke a service, call the [InvokeThingService](~~69584~~) or [InvokeThingsService](~~96242~~) operation.
    * ## QPS limit
    * You can call this API operation up to 1,600 times per second per account. 
    * >  The RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request PubRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return PubResponse
   */
  async pubWithOptions(request: PubRequest, runtime: $Util.RuntimeOptions): Promise<PubResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.contentType)) {
      query["ContentType"] = request.contentType;
    }

    if (!Util.isUnset(request.correlationData)) {
      query["CorrelationData"] = request.correlationData;
    }

    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.messageExpiryInterval)) {
      query["MessageExpiryInterval"] = request.messageExpiryInterval;
    }

    if (!Util.isUnset(request.payloadFormatIndicator)) {
      query["PayloadFormatIndicator"] = request.payloadFormatIndicator;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.qos)) {
      query["Qos"] = request.qos;
    }

    if (!Util.isUnset(request.responseTopic)) {
      query["ResponseTopic"] = request.responseTopic;
    }

    if (!Util.isUnset(request.retained)) {
      query["Retained"] = request.retained;
    }

    if (!Util.isUnset(request.topicFullName)) {
      query["TopicFullName"] = request.topicFullName;
    }

    if (!Util.isUnset(request.userProp)) {
      query["UserProp"] = request.userProp;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.messageContent)) {
      body["MessageContent"] = request.messageContent;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "Pub",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<PubResponse>(await this.callApi(params, req, runtime), new PubResponse({}));
  }

  /**
    * This operation does not support device property settings and service invocations.
    * *   To set properties, call the [SetDeviceProperty](~~69579~~) or [SetDevicesProperty](~~96243~~) operation.
    * *   To invoke a service, call the [InvokeThingService](~~69584~~) or [InvokeThingsService](~~96242~~) operation.
    * ## QPS limit
    * You can call this API operation up to 1,600 times per second per account. 
    * >  The RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request PubRequest
    * @return PubResponse
   */
  async pub(request: PubRequest): Promise<PubResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.pubWithOptions(request, runtime);
  }

  /**
    * You can use the **TopicFullName** parameter in the **request** to specify the devices to which you want to broadcast messages. For more information, see the description about the **TopicFullName** parameter in this topic.
    * ## QPS limits
    * - Each Alibaba Cloud account can run only one query per second (QPS) to broadcast a message to devices that subscribe to a topic.
    * - Each Alibaba Cloud account can run only one query per minute (QPM) to broadcast a message to all online devices of a product.      >  The RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request PubBroadcastRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return PubBroadcastResponse
   */
  async pubBroadcastWithOptions(request: PubBroadcastRequest, runtime: $Util.RuntimeOptions): Promise<PubBroadcastResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.messageContent)) {
      query["MessageContent"] = request.messageContent;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.topicFullName)) {
      query["TopicFullName"] = request.topicFullName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "PubBroadcast",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<PubBroadcastResponse>(await this.callApi(params, req, runtime), new PubBroadcastResponse({}));
  }

  /**
    * You can use the **TopicFullName** parameter in the **request** to specify the devices to which you want to broadcast messages. For more information, see the description about the **TopicFullName** parameter in this topic.
    * ## QPS limits
    * - Each Alibaba Cloud account can run only one query per second (QPS) to broadcast a message to devices that subscribe to a topic.
    * - Each Alibaba Cloud account can run only one query per minute (QPM) to broadcast a message to all online devices of a product.      >  The RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request PubBroadcastRequest
    * @return PubBroadcastResponse
   */
  async pubBroadcast(request: PubBroadcastRequest): Promise<PubBroadcastResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.pubBroadcastWithOptions(request, runtime);
  }

  async publishScriptWithOptions(request: PublishScriptRequest, runtime: $Util.RuntimeOptions): Promise<PublishScriptResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.parserId)) {
      query["ParserId"] = request.parserId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "PublishScript",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<PublishScriptResponse>(await this.callApi(params, req, runtime), new PublishScriptResponse({}));
  }

  async publishScript(request: PublishScriptRequest): Promise<PublishScriptResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.publishScriptWithOptions(request, runtime);
  }

  async publishStudioAppWithOptions(request: PublishStudioAppRequest, runtime: $Util.RuntimeOptions): Promise<PublishStudioAppResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appId)) {
      body["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.description)) {
      body["Description"] = request.description;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      body["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "PublishStudioApp",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<PublishStudioAppResponse>(await this.callApi(params, req, runtime), new PublishStudioAppResponse({}));
  }

  async publishStudioApp(request: PublishStudioAppRequest): Promise<PublishStudioAppResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.publishStudioAppWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * *   If a product is published, you must call the [CancelReleaseProduct](~~213875~~) operation to unpublish the product before you call this operation.
    * *   Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
    * > RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request PublishThingModelRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return PublishThingModelResponse
   */
  async publishThingModelWithOptions(request: PublishThingModelRequest, runtime: $Util.RuntimeOptions): Promise<PublishThingModelResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.modelVersion)) {
      query["ModelVersion"] = request.modelVersion;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "PublishThingModel",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<PublishThingModelResponse>(await this.callApi(params, req, runtime), new PublishThingModelResponse({}));
  }

  /**
    * ## Limits
    * *   If a product is published, you must call the [CancelReleaseProduct](~~213875~~) operation to unpublish the product before you call this operation.
    * *   Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
    * > RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request PublishThingModelRequest
    * @return PublishThingModelResponse
   */
  async publishThingModel(request: PublishThingModelRequest): Promise<PublishThingModelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.publishThingModelWithOptions(request, runtime);
  }

  async pushSpeechWithOptions(request: PushSpeechRequest, runtime: $Util.RuntimeOptions): Promise<PushSpeechResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.deviceName)) {
      body["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotId)) {
      body["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      body["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      body["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.projectCode)) {
      body["ProjectCode"] = request.projectCode;
    }

    if (!Util.isUnset(request.pushMode)) {
      body["PushMode"] = request.pushMode;
    }

    if (!Util.isUnset(request.speechCodeList)) {
      body["SpeechCodeList"] = request.speechCodeList;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "PushSpeech",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<PushSpeechResponse>(await this.callApi(params, req, runtime), new PushSpeechResponse({}));
  }

  async pushSpeech(request: PushSpeechRequest): Promise<PushSpeechResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.pushSpeechWithOptions(request, runtime);
  }

  /**
    * ## QPS limits
    * You can call this API operation up to 30 times per second per account.
    * >  The RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryBatchRegisterDeviceStatusRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return QueryBatchRegisterDeviceStatusResponse
   */
  async queryBatchRegisterDeviceStatusWithOptions(request: QueryBatchRegisterDeviceStatusRequest, runtime: $Util.RuntimeOptions): Promise<QueryBatchRegisterDeviceStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.applyId)) {
      query["ApplyId"] = request.applyId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryBatchRegisterDeviceStatus",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryBatchRegisterDeviceStatusResponse>(await this.callApi(params, req, runtime), new QueryBatchRegisterDeviceStatusResponse({}));
  }

  /**
    * ## QPS limits
    * You can call this API operation up to 30 times per second per account.
    * >  The RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryBatchRegisterDeviceStatusRequest
    * @return QueryBatchRegisterDeviceStatusResponse
   */
  async queryBatchRegisterDeviceStatus(request: QueryBatchRegisterDeviceStatusRequest): Promise<QueryBatchRegisterDeviceStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryBatchRegisterDeviceStatusWithOptions(request, runtime);
  }

  async queryCertUrlByApplyIdWithOptions(request: QueryCertUrlByApplyIdRequest, runtime: $Util.RuntimeOptions): Promise<QueryCertUrlByApplyIdResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.applyId)) {
      query["ApplyId"] = request.applyId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryCertUrlByApplyId",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryCertUrlByApplyIdResponse>(await this.callApi(params, req, runtime), new QueryCertUrlByApplyIdResponse({}));
  }

  async queryCertUrlByApplyId(request: QueryCertUrlByApplyIdRequest): Promise<QueryCertUrlByApplyIdResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryCertUrlByApplyIdWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryClientIdsRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return QueryClientIdsResponse
   */
  async queryClientIdsWithOptions(request: QueryClientIdsRequest, runtime: $Util.RuntimeOptions): Promise<QueryClientIdsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotId)) {
      query["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryClientIds",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryClientIdsResponse>(await this.callApi(params, req, runtime), new QueryClientIdsResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryClientIdsRequest
    * @return QueryClientIdsResponse
   */
  async queryClientIds(request: QueryClientIdsRequest): Promise<QueryClientIdsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryClientIdsWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryConsumerGroupByGroupIdRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return QueryConsumerGroupByGroupIdResponse
   */
  async queryConsumerGroupByGroupIdWithOptions(request: QueryConsumerGroupByGroupIdRequest, runtime: $Util.RuntimeOptions): Promise<QueryConsumerGroupByGroupIdResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryConsumerGroupByGroupId",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryConsumerGroupByGroupIdResponse>(await this.callApi(params, req, runtime), new QueryConsumerGroupByGroupIdResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryConsumerGroupByGroupIdRequest
    * @return QueryConsumerGroupByGroupIdResponse
   */
  async queryConsumerGroupByGroupId(request: QueryConsumerGroupByGroupIdRequest): Promise<QueryConsumerGroupByGroupIdResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryConsumerGroupByGroupIdWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryConsumerGroupListRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return QueryConsumerGroupListResponse
   */
  async queryConsumerGroupListWithOptions(request: QueryConsumerGroupListRequest, runtime: $Util.RuntimeOptions): Promise<QueryConsumerGroupListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.fuzzy)) {
      query["Fuzzy"] = request.fuzzy;
    }

    if (!Util.isUnset(request.groupName)) {
      query["GroupName"] = request.groupName;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.subBizCode)) {
      query["SubBizCode"] = request.subBizCode;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryConsumerGroupList",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryConsumerGroupListResponse>(await this.callApi(params, req, runtime), new QueryConsumerGroupListResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryConsumerGroupListRequest
    * @return QueryConsumerGroupListResponse
   */
  async queryConsumerGroupList(request: QueryConsumerGroupListRequest): Promise<QueryConsumerGroupListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryConsumerGroupListWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryConsumerGroupStatusRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return QueryConsumerGroupStatusResponse
   */
  async queryConsumerGroupStatusWithOptions(request: QueryConsumerGroupStatusRequest, runtime: $Util.RuntimeOptions): Promise<QueryConsumerGroupStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryConsumerGroupStatus",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryConsumerGroupStatusResponse>(await this.callApi(params, req, runtime), new QueryConsumerGroupStatusResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryConsumerGroupStatusRequest
    * @return QueryConsumerGroupStatusResponse
   */
  async queryConsumerGroupStatus(request: QueryConsumerGroupStatusRequest): Promise<QueryConsumerGroupStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryConsumerGroupStatusWithOptions(request, runtime);
  }

  async queryDetailSceneRuleLogWithOptions(request: QueryDetailSceneRuleLogRequest, runtime: $Util.RuntimeOptions): Promise<QueryDetailSceneRuleLogResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.ruleId)) {
      query["RuleId"] = request.ruleId;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.traceId)) {
      query["TraceId"] = request.traceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryDetailSceneRuleLog",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryDetailSceneRuleLogResponse>(await this.callApi(params, req, runtime), new QueryDetailSceneRuleLogResponse({}));
  }

  async queryDetailSceneRuleLog(request: QueryDetailSceneRuleLogRequest): Promise<QueryDetailSceneRuleLogResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDetailSceneRuleLogWithOptions(request, runtime);
  }

  /**
    * The QueryDevice operation can return up to one million devices each time you call the operation.
    * ## QPS limits
    * - You can call this API operation up to 50 times per second per account. >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
    * - If the product of the value of the **CurrentPage** parameter and the value of the **PageSize** parameter is greater than or equal to 100,000, the queries per second (QPS) of this operation decreases. 
    * In this case, you can call this API operation up to two times per second per account.
    *
    * @param request QueryDeviceRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return QueryDeviceResponse
   */
  async queryDeviceWithOptions(request: QueryDeviceRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryDevice",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryDeviceResponse>(await this.callApi(params, req, runtime), new QueryDeviceResponse({}));
  }

  /**
    * The QueryDevice operation can return up to one million devices each time you call the operation.
    * ## QPS limits
    * - You can call this API operation up to 50 times per second per account. >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
    * - If the product of the value of the **CurrentPage** parameter and the value of the **PageSize** parameter is greater than or equal to 100,000, the queries per second (QPS) of this operation decreases. 
    * In this case, you can call this API operation up to two times per second per account.
    *
    * @param request QueryDeviceRequest
    * @return QueryDeviceResponse
   */
  async queryDevice(request: QueryDeviceRequest): Promise<QueryDeviceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceWithOptions(request, runtime);
  }

  /**
    * *   You can query devices on Enterprise Edition instances only in the China (Shanghai) and Japan (Tokyo) regions.
    * *   The QueryDeviceBySQL operation can return up to 10,000 devices each time you call the operation. For more information, see the "`Syntax of LIMIT clauses`" section of this topic.
    * ## QPS limits
    * You can call this API operation up to 10 times per second per account. 
    * >  The RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryDeviceBySQLRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return QueryDeviceBySQLResponse
   */
  async queryDeviceBySQLWithOptions(request: QueryDeviceBySQLRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceBySQLResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.SQL)) {
      query["SQL"] = request.SQL;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryDeviceBySQL",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryDeviceBySQLResponse>(await this.callApi(params, req, runtime), new QueryDeviceBySQLResponse({}));
  }

  /**
    * *   You can query devices on Enterprise Edition instances only in the China (Shanghai) and Japan (Tokyo) regions.
    * *   The QueryDeviceBySQL operation can return up to 10,000 devices each time you call the operation. For more information, see the "`Syntax of LIMIT clauses`" section of this topic.
    * ## QPS limits
    * You can call this API operation up to 10 times per second per account. 
    * >  The RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryDeviceBySQLRequest
    * @return QueryDeviceBySQLResponse
   */
  async queryDeviceBySQL(request: QueryDeviceBySQLRequest): Promise<QueryDeviceBySQLResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceBySQLWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * *   After the status of a device changes, the new status is applied within 10 seconds. After the new status is applied, you can search for the device by using the new status. Before the new status is applied, you can search for the device by using the previous status.
    * *   Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
    * > RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryDeviceByStatusRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return QueryDeviceByStatusResponse
   */
  async queryDeviceByStatusWithOptions(request: QueryDeviceByStatusRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceByStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryDeviceByStatus",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryDeviceByStatusResponse>(await this.callApi(params, req, runtime), new QueryDeviceByStatusResponse({}));
  }

  /**
    * ## Limits
    * *   After the status of a device changes, the new status is applied within 10 seconds. After the new status is applied, you can search for the device by using the new status. Before the new status is applied, you can search for the device by using the previous status.
    * *   Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
    * > RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryDeviceByStatusRequest
    * @return QueryDeviceByStatusResponse
   */
  async queryDeviceByStatus(request: QueryDeviceByStatusRequest): Promise<QueryDeviceByStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceByStatusWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * *   You can specify a maximum of 10 tags in a single call.
    * *   Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
    * > RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryDeviceByTagsRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return QueryDeviceByTagsResponse
   */
  async queryDeviceByTagsWithOptions(request: QueryDeviceByTagsRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceByTagsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryDeviceByTags",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryDeviceByTagsResponse>(await this.callApi(params, req, runtime), new QueryDeviceByTagsResponse({}));
  }

  /**
    * ## Limits
    * *   You can specify a maximum of 10 tags in a single call.
    * *   Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
    * > RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryDeviceByTagsRequest
    * @return QueryDeviceByTagsResponse
   */
  async queryDeviceByTags(request: QueryDeviceByTagsRequest): Promise<QueryDeviceByTagsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceByTagsWithOptions(request, runtime);
  }

  async queryDeviceCertWithOptions(request: QueryDeviceCertRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceCertResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryDeviceCert",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryDeviceCertResponse>(await this.callApi(params, req, runtime), new QueryDeviceCertResponse({}));
  }

  async queryDeviceCert(request: QueryDeviceCertRequest): Promise<QueryDeviceCertResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceCertWithOptions(request, runtime);
  }

  /**
    * *   The desired values of read-only properties cannot be queried.
    * *   You can query the desired values of up to 10 properties in a single call.
    * ## QPS limits
    * You can call this API operation up to 50 times per second per account. 
    * >  The RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryDeviceDesiredPropertyRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return QueryDeviceDesiredPropertyResponse
   */
  async queryDeviceDesiredPropertyWithOptions(request: QueryDeviceDesiredPropertyRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceDesiredPropertyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.functionBlockId)) {
      query["FunctionBlockId"] = request.functionBlockId;
    }

    if (!Util.isUnset(request.identifier)) {
      query["Identifier"] = request.identifier;
    }

    if (!Util.isUnset(request.iotId)) {
      query["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryDeviceDesiredProperty",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryDeviceDesiredPropertyResponse>(await this.callApi(params, req, runtime), new QueryDeviceDesiredPropertyResponse({}));
  }

  /**
    * *   The desired values of read-only properties cannot be queried.
    * *   You can query the desired values of up to 10 properties in a single call.
    * ## QPS limits
    * You can call this API operation up to 50 times per second per account. 
    * >  The RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryDeviceDesiredPropertyRequest
    * @return QueryDeviceDesiredPropertyResponse
   */
  async queryDeviceDesiredProperty(request: QueryDeviceDesiredPropertyRequest): Promise<QueryDeviceDesiredPropertyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceDesiredPropertyWithOptions(request, runtime);
  }

  /**
    * ## QPS limits
    * Each Alibaba Cloud account can run up to 50 queries per second (QPS).
    * >  The RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryDeviceDetailRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return QueryDeviceDetailResponse
   */
  async queryDeviceDetailWithOptions(request: QueryDeviceDetailRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotId)) {
      query["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryDeviceDetail",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryDeviceDetailResponse>(await this.callApi(params, req, runtime), new QueryDeviceDetailResponse({}));
  }

  /**
    * ## QPS limits
    * Each Alibaba Cloud account can run up to 50 queries per second (QPS).
    * >  The RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryDeviceDetailRequest
    * @return QueryDeviceDetailResponse
   */
  async queryDeviceDetail(request: QueryDeviceDetailRequest): Promise<QueryDeviceDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceDetailWithOptions(request, runtime);
  }

  /**
    * *   This operation can be called only by using the following **endpoint**: `iot.cn-shanghai.aliyuncs.com`.
    * *   Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
    * > RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryDeviceDistributeDetailRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return QueryDeviceDistributeDetailResponse
   */
  async queryDeviceDistributeDetailWithOptions(request: QueryDeviceDistributeDetailRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceDistributeDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.jobId)) {
      query["JobId"] = request.jobId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryDeviceDistributeDetail",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryDeviceDistributeDetailResponse>(await this.callApi(params, req, runtime), new QueryDeviceDistributeDetailResponse({}));
  }

  /**
    * *   This operation can be called only by using the following **endpoint**: `iot.cn-shanghai.aliyuncs.com`.
    * *   Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
    * > RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryDeviceDistributeDetailRequest
    * @return QueryDeviceDistributeDetailResponse
   */
  async queryDeviceDistributeDetail(request: QueryDeviceDistributeDetailRequest): Promise<QueryDeviceDistributeDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceDistributeDetailWithOptions(request, runtime);
  }

  /**
    * *   This operation can be called only by using the following **endpoint**: `iot.cn-shanghai.aliyuncs.com`.
    * *   Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
    * >RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryDeviceDistributeJobRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return QueryDeviceDistributeJobResponse
   */
  async queryDeviceDistributeJobWithOptions(request: QueryDeviceDistributeJobRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceDistributeJobResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.jobId)) {
      query["JobId"] = request.jobId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryDeviceDistributeJob",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryDeviceDistributeJobResponse>(await this.callApi(params, req, runtime), new QueryDeviceDistributeJobResponse({}));
  }

  /**
    * *   This operation can be called only by using the following **endpoint**: `iot.cn-shanghai.aliyuncs.com`.
    * *   Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
    * >RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryDeviceDistributeJobRequest
    * @return QueryDeviceDistributeJobResponse
   */
  async queryDeviceDistributeJob(request: QueryDeviceDistributeJobRequest): Promise<QueryDeviceDistributeJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceDistributeJobWithOptions(request, runtime);
  }

  /**
    * You can query only the event records that are generated in the previous 30 days.
    * >  The storage period of an event record is calculated from the day when the record is generated.
    * ## QPS limits
    * Each Alibaba Cloud account can run up to 50 queries per second (QPS). 
    * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
    *
    * @param request QueryDeviceEventDataRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return QueryDeviceEventDataResponse
   */
  async queryDeviceEventDataWithOptions(request: QueryDeviceEventDataRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceEventDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.asc)) {
      query["Asc"] = request.asc;
    }

    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.eventType)) {
      query["EventType"] = request.eventType;
    }

    if (!Util.isUnset(request.identifier)) {
      query["Identifier"] = request.identifier;
    }

    if (!Util.isUnset(request.iotId)) {
      query["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryDeviceEventData",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryDeviceEventDataResponse>(await this.callApi(params, req, runtime), new QueryDeviceEventDataResponse({}));
  }

  /**
    * You can query only the event records that are generated in the previous 30 days.
    * >  The storage period of an event record is calculated from the day when the record is generated.
    * ## QPS limits
    * Each Alibaba Cloud account can run up to 50 queries per second (QPS). 
    * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
    *
    * @param request QueryDeviceEventDataRequest
    * @return QueryDeviceEventDataResponse
   */
  async queryDeviceEventData(request: QueryDeviceEventDataRequest): Promise<QueryDeviceEventDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceEventDataWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryDeviceFileRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return QueryDeviceFileResponse
   */
  async queryDeviceFileWithOptions(request: QueryDeviceFileRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceFileResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.fileId)) {
      query["FileId"] = request.fileId;
    }

    if (!Util.isUnset(request.iotId)) {
      query["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryDeviceFile",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryDeviceFileResponse>(await this.callApi(params, req, runtime), new QueryDeviceFileResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryDeviceFileRequest
    * @return QueryDeviceFileResponse
   */
  async queryDeviceFile(request: QueryDeviceFileRequest): Promise<QueryDeviceFileResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceFileWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * *   The returned file information for this operation call does not contain download URLs. To obtain the download URL of a file, call [QueryDeviceFile](~~112002~~).
    * *   Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
    * >RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryDeviceFileListRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return QueryDeviceFileListResponse
   */
  async queryDeviceFileListWithOptions(request: QueryDeviceFileListRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceFileListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotId)) {
      query["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryDeviceFileList",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryDeviceFileListResponse>(await this.callApi(params, req, runtime), new QueryDeviceFileListResponse({}));
  }

  /**
    * ## Limits
    * *   The returned file information for this operation call does not contain download URLs. To obtain the download URL of a file, call [QueryDeviceFile](~~112002~~).
    * *   Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
    * >RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryDeviceFileListRequest
    * @return QueryDeviceFileListResponse
   */
  async queryDeviceFileList(request: QueryDeviceFileListRequest): Promise<QueryDeviceFileListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceFileListWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * *   You can add a device to a maximum of 10 groups.
    * *   Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
    * > RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryDeviceGroupByDeviceRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return QueryDeviceGroupByDeviceResponse
   */
  async queryDeviceGroupByDeviceWithOptions(request: QueryDeviceGroupByDeviceRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceGroupByDeviceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryDeviceGroupByDevice",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryDeviceGroupByDeviceResponse>(await this.callApi(params, req, runtime), new QueryDeviceGroupByDeviceResponse({}));
  }

  /**
    * ## Limits
    * *   You can add a device to a maximum of 10 groups.
    * *   Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
    * > RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryDeviceGroupByDeviceRequest
    * @return QueryDeviceGroupByDeviceResponse
   */
  async queryDeviceGroupByDevice(request: QueryDeviceGroupByDeviceRequest): Promise<QueryDeviceGroupByDeviceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceGroupByDeviceWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryDeviceGroupByTagsRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return QueryDeviceGroupByTagsResponse
   */
  async queryDeviceGroupByTagsWithOptions(request: QueryDeviceGroupByTagsRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceGroupByTagsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryDeviceGroupByTags",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryDeviceGroupByTagsResponse>(await this.callApi(params, req, runtime), new QueryDeviceGroupByTagsResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryDeviceGroupByTagsRequest
    * @return QueryDeviceGroupByTagsResponse
   */
  async queryDeviceGroupByTags(request: QueryDeviceGroupByTagsRequest): Promise<QueryDeviceGroupByTagsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceGroupByTagsWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 30 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryDeviceGroupInfoRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return QueryDeviceGroupInfoResponse
   */
  async queryDeviceGroupInfoWithOptions(request: QueryDeviceGroupInfoRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceGroupInfoResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.groupType)) {
      query["GroupType"] = request.groupType;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryDeviceGroupInfo",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryDeviceGroupInfoResponse>(await this.callApi(params, req, runtime), new QueryDeviceGroupInfoResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 30 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryDeviceGroupInfoRequest
    * @return QueryDeviceGroupInfoResponse
   */
  async queryDeviceGroupInfo(request: QueryDeviceGroupInfoRequest): Promise<QueryDeviceGroupInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceGroupInfoWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 100 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryDeviceGroupListRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return QueryDeviceGroupListResponse
   */
  async queryDeviceGroupListWithOptions(request: QueryDeviceGroupListRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceGroupListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.groupName)) {
      query["GroupName"] = request.groupName;
    }

    if (!Util.isUnset(request.groupTypes)) {
      query["GroupTypes"] = request.groupTypes;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.superGroupId)) {
      query["SuperGroupId"] = request.superGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryDeviceGroupList",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryDeviceGroupListResponse>(await this.callApi(params, req, runtime), new QueryDeviceGroupListResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 100 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryDeviceGroupListRequest
    * @return QueryDeviceGroupListResponse
   */
  async queryDeviceGroupList(request: QueryDeviceGroupListRequest): Promise<QueryDeviceGroupListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceGroupListWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryDeviceGroupTagListRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return QueryDeviceGroupTagListResponse
   */
  async queryDeviceGroupTagListWithOptions(request: QueryDeviceGroupTagListRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceGroupTagListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.groupType)) {
      query["GroupType"] = request.groupType;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryDeviceGroupTagList",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryDeviceGroupTagListResponse>(await this.callApi(params, req, runtime), new QueryDeviceGroupTagListResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryDeviceGroupTagListRequest
    * @return QueryDeviceGroupTagListResponse
   */
  async queryDeviceGroupTagList(request: QueryDeviceGroupTagListRequest): Promise<QueryDeviceGroupTagListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceGroupTagListWithOptions(request, runtime);
  }

  /**
    * In addition to the preceding operation-specific request parameters, you must specify common request parameters when you call this operation. For more information, see [Common request parameters](~~30561~~).
    *
    * @param request QueryDeviceInfoRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return QueryDeviceInfoResponse
   */
  async queryDeviceInfoWithOptions(request: QueryDeviceInfoRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceInfoResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotId)) {
      query["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryDeviceInfo",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryDeviceInfoResponse>(await this.callApi(params, req, runtime), new QueryDeviceInfoResponse({}));
  }

  /**
    * In addition to the preceding operation-specific request parameters, you must specify common request parameters when you call this operation. For more information, see [Common request parameters](~~30561~~).
    *
    * @param request QueryDeviceInfoRequest
    * @return QueryDeviceInfoResponse
   */
  async queryDeviceInfo(request: QueryDeviceInfoRequest): Promise<QueryDeviceInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceInfoWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryDeviceListByDeviceGroupRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return QueryDeviceListByDeviceGroupResponse
   */
  async queryDeviceListByDeviceGroupWithOptions(request: QueryDeviceListByDeviceGroupRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceListByDeviceGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryDeviceListByDeviceGroup",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryDeviceListByDeviceGroupResponse>(await this.callApi(params, req, runtime), new QueryDeviceListByDeviceGroupResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryDeviceListByDeviceGroupRequest
    * @return QueryDeviceListByDeviceGroupResponse
   */
  async queryDeviceListByDeviceGroup(request: QueryDeviceListByDeviceGroupRequest): Promise<QueryDeviceListByDeviceGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceListByDeviceGroupWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * *   You can query only the event records that are generated in the last 30 days.
    * >  The storage period of an event record is calculated from the day when the record is generated.
    * *   Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
    * >Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryDeviceOriginalEventDataRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return QueryDeviceOriginalEventDataResponse
   */
  async queryDeviceOriginalEventDataWithOptions(request: QueryDeviceOriginalEventDataRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceOriginalEventDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.asc)) {
      query["Asc"] = request.asc;
    }

    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.identifier)) {
      query["Identifier"] = request.identifier;
    }

    if (!Util.isUnset(request.iotId)) {
      query["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.nextPageToken)) {
      query["NextPageToken"] = request.nextPageToken;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryDeviceOriginalEventData",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryDeviceOriginalEventDataResponse>(await this.callApi(params, req, runtime), new QueryDeviceOriginalEventDataResponse({}));
  }

  /**
    * ## Limits
    * *   You can query only the event records that are generated in the last 30 days.
    * >  The storage period of an event record is calculated from the day when the record is generated.
    * *   Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
    * >Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryDeviceOriginalEventDataRequest
    * @return QueryDeviceOriginalEventDataResponse
   */
  async queryDeviceOriginalEventData(request: QueryDeviceOriginalEventDataRequest): Promise<QueryDeviceOriginalEventDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceOriginalEventDataWithOptions(request, runtime);
  }

  /**
    * You can query only the property records that are generated within the previous 30 days.
    * >  The data of a property is stored from the day when the data is generated.
    * ## QPS limits
    * You can call this API operation up to 50 times per second per account. 
    * >  The RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryDeviceOriginalPropertyDataRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return QueryDeviceOriginalPropertyDataResponse
   */
  async queryDeviceOriginalPropertyDataWithOptions(request: QueryDeviceOriginalPropertyDataRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceOriginalPropertyDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.asc)) {
      query["Asc"] = request.asc;
    }

    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.identifier)) {
      query["Identifier"] = request.identifier;
    }

    if (!Util.isUnset(request.iotId)) {
      query["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.nextPageToken)) {
      query["NextPageToken"] = request.nextPageToken;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryDeviceOriginalPropertyData",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryDeviceOriginalPropertyDataResponse>(await this.callApi(params, req, runtime), new QueryDeviceOriginalPropertyDataResponse({}));
  }

  /**
    * You can query only the property records that are generated within the previous 30 days.
    * >  The data of a property is stored from the day when the data is generated.
    * ## QPS limits
    * You can call this API operation up to 50 times per second per account. 
    * >  The RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryDeviceOriginalPropertyDataRequest
    * @return QueryDeviceOriginalPropertyDataResponse
   */
  async queryDeviceOriginalPropertyData(request: QueryDeviceOriginalPropertyDataRequest): Promise<QueryDeviceOriginalPropertyDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceOriginalPropertyDataWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
    * >  Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryDeviceOriginalPropertyStatusRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return QueryDeviceOriginalPropertyStatusResponse
   */
  async queryDeviceOriginalPropertyStatusWithOptions(request: QueryDeviceOriginalPropertyStatusRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceOriginalPropertyStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.asc)) {
      query["Asc"] = request.asc;
    }

    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotId)) {
      query["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.nextPageToken)) {
      query["NextPageToken"] = request.nextPageToken;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryDeviceOriginalPropertyStatus",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryDeviceOriginalPropertyStatusResponse>(await this.callApi(params, req, runtime), new QueryDeviceOriginalPropertyStatusResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
    * >  Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryDeviceOriginalPropertyStatusRequest
    * @return QueryDeviceOriginalPropertyStatusResponse
   */
  async queryDeviceOriginalPropertyStatus(request: QueryDeviceOriginalPropertyStatusRequest): Promise<QueryDeviceOriginalPropertyStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceOriginalPropertyStatusWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * *   You can query only the service call records that are generated in the last 30 days.
    * >  The storage period of a service call record is calculated from the day when the service is called.
    * *   Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
    * > Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryDeviceOriginalServiceDataRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return QueryDeviceOriginalServiceDataResponse
   */
  async queryDeviceOriginalServiceDataWithOptions(request: QueryDeviceOriginalServiceDataRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceOriginalServiceDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.asc)) {
      query["Asc"] = request.asc;
    }

    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.identifier)) {
      query["Identifier"] = request.identifier;
    }

    if (!Util.isUnset(request.iotId)) {
      query["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.nextPageToken)) {
      query["NextPageToken"] = request.nextPageToken;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryDeviceOriginalServiceData",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryDeviceOriginalServiceDataResponse>(await this.callApi(params, req, runtime), new QueryDeviceOriginalServiceDataResponse({}));
  }

  /**
    * ## Limits
    * *   You can query only the service call records that are generated in the last 30 days.
    * >  The storage period of a service call record is calculated from the day when the service is called.
    * *   Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
    * > Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryDeviceOriginalServiceDataRequest
    * @return QueryDeviceOriginalServiceDataResponse
   */
  async queryDeviceOriginalServiceData(request: QueryDeviceOriginalServiceDataRequest): Promise<QueryDeviceOriginalServiceDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceOriginalServiceDataWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryDevicePropRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return QueryDevicePropResponse
   */
  async queryDevicePropWithOptions(request: QueryDevicePropRequest, runtime: $Util.RuntimeOptions): Promise<QueryDevicePropResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotId)) {
      query["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryDeviceProp",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryDevicePropResponse>(await this.callApi(params, req, runtime), new QueryDevicePropResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryDevicePropRequest
    * @return QueryDevicePropResponse
   */
  async queryDeviceProp(request: QueryDevicePropRequest): Promise<QueryDevicePropResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDevicePropWithOptions(request, runtime);
  }

  /**
    * When you call this operation to query property records within a specified period, the number of records for a property at a point in time may reach the limit.**** The limit is specified by the **PageSize** parameter. In this case, the query stops. Some records of other properties may be not returned.**** You can check whether all records of a property are returned based on the NextValid repsonse parameter: 
    * - If the value of the **NextValid** parameter is true, unretrieved records exist in the period that is indicated by the **NextTime** and **EndTime** parameter.  
    * You can use the value of the **NextTime** response parameter as the value of the StartTime request parameter and call this operation again to query the rest records. You can call this operation multiple times until the value of the **NextValid** parameter is false.  >  To retrieve all property records within a specified period, you can set the **PageSize** parameter to the maximum value. Then, call this operation multiple times until the value of the **NextValid** parameter is false.
    * - If the value of the **NextValid** parameter is false, all property records are returned.
    * ## Limits
    * *   A maximum of 10 properties can be queried at a time. A maximum of 100 records can be queried for each property.
    * *   You can query property data that is generated within the last 30 days.
    * > The storage period of a property record is calculated from the day when the property record was generated.
    * *   Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
    * >RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryDevicePropertiesDataRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return QueryDevicePropertiesDataResponse
   */
  async queryDevicePropertiesDataWithOptions(request: QueryDevicePropertiesDataRequest, runtime: $Util.RuntimeOptions): Promise<QueryDevicePropertiesDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.asc)) {
      query["Asc"] = request.asc;
    }

    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.identifier)) {
      query["Identifier"] = request.identifier;
    }

    if (!Util.isUnset(request.iotId)) {
      query["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryDevicePropertiesData",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryDevicePropertiesDataResponse>(await this.callApi(params, req, runtime), new QueryDevicePropertiesDataResponse({}));
  }

  /**
    * When you call this operation to query property records within a specified period, the number of records for a property at a point in time may reach the limit.**** The limit is specified by the **PageSize** parameter. In this case, the query stops. Some records of other properties may be not returned.**** You can check whether all records of a property are returned based on the NextValid repsonse parameter: 
    * - If the value of the **NextValid** parameter is true, unretrieved records exist in the period that is indicated by the **NextTime** and **EndTime** parameter.  
    * You can use the value of the **NextTime** response parameter as the value of the StartTime request parameter and call this operation again to query the rest records. You can call this operation multiple times until the value of the **NextValid** parameter is false.  >  To retrieve all property records within a specified period, you can set the **PageSize** parameter to the maximum value. Then, call this operation multiple times until the value of the **NextValid** parameter is false.
    * - If the value of the **NextValid** parameter is false, all property records are returned.
    * ## Limits
    * *   A maximum of 10 properties can be queried at a time. A maximum of 100 records can be queried for each property.
    * *   You can query property data that is generated within the last 30 days.
    * > The storage period of a property record is calculated from the day when the property record was generated.
    * *   Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
    * >RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryDevicePropertiesDataRequest
    * @return QueryDevicePropertiesDataResponse
   */
  async queryDevicePropertiesData(request: QueryDevicePropertiesDataRequest): Promise<QueryDevicePropertiesDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDevicePropertiesDataWithOptions(request, runtime);
  }

  /**
    * If a device or a digital twin node has multiple properties, you can call this operation to query the data of the properties multiple times. You must specify a value for the **Identifier** parameter each time you call the operation. You can also call the [QueryDevicePropertiesData](~~99237~~) operation and specify multiple values for the **Identifier** parameter to query the data of the properties.
    * ## Limits
    * You can query only property data that is generated within the previous 30 days. 
    * >  The data of a property is stored from the day when the data is generated.
    *   
    * ## QPS limits
    * Each Alibaba Cloud account can run up to 50 queries per second (QPS). 
    * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
    *
    * @param request QueryDevicePropertyDataRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return QueryDevicePropertyDataResponse
   */
  async queryDevicePropertyDataWithOptions(request: QueryDevicePropertyDataRequest, runtime: $Util.RuntimeOptions): Promise<QueryDevicePropertyDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.asc)) {
      query["Asc"] = request.asc;
    }

    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.identifier)) {
      query["Identifier"] = request.identifier;
    }

    if (!Util.isUnset(request.iotId)) {
      query["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryDevicePropertyData",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryDevicePropertyDataResponse>(await this.callApi(params, req, runtime), new QueryDevicePropertyDataResponse({}));
  }

  /**
    * If a device or a digital twin node has multiple properties, you can call this operation to query the data of the properties multiple times. You must specify a value for the **Identifier** parameter each time you call the operation. You can also call the [QueryDevicePropertiesData](~~99237~~) operation and specify multiple values for the **Identifier** parameter to query the data of the properties.
    * ## Limits
    * You can query only property data that is generated within the previous 30 days. 
    * >  The data of a property is stored from the day when the data is generated.
    *   
    * ## QPS limits
    * Each Alibaba Cloud account can run up to 50 queries per second (QPS). 
    * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
    *
    * @param request QueryDevicePropertyDataRequest
    * @return QueryDevicePropertyDataResponse
   */
  async queryDevicePropertyData(request: QueryDevicePropertyDataRequest): Promise<QueryDevicePropertyDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDevicePropertyDataWithOptions(request, runtime);
  }

  /**
    * To query the property data of a digital twin node, you must set the **IotId** parameter to the ID of the digital twin node.
    * ## QPS limits
    * Each Alibaba Cloud account can run up to 200 queries per second (QPS). 
    * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
    *
    * @param request QueryDevicePropertyStatusRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return QueryDevicePropertyStatusResponse
   */
  async queryDevicePropertyStatusWithOptions(request: QueryDevicePropertyStatusRequest, runtime: $Util.RuntimeOptions): Promise<QueryDevicePropertyStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.functionBlockId)) {
      query["FunctionBlockId"] = request.functionBlockId;
    }

    if (!Util.isUnset(request.iotId)) {
      query["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryDevicePropertyStatus",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryDevicePropertyStatusResponse>(await this.callApi(params, req, runtime), new QueryDevicePropertyStatusResponse({}));
  }

  /**
    * To query the property data of a digital twin node, you must set the **IotId** parameter to the ID of the digital twin node.
    * ## QPS limits
    * Each Alibaba Cloud account can run up to 200 queries per second (QPS). 
    * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
    *
    * @param request QueryDevicePropertyStatusRequest
    * @return QueryDevicePropertyStatusResponse
   */
  async queryDevicePropertyStatus(request: QueryDevicePropertyStatusRequest): Promise<QueryDevicePropertyStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDevicePropertyStatusWithOptions(request, runtime);
  }

  async queryDeviceProvisioningWithOptions(request: QueryDeviceProvisioningRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceProvisioningResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.productKey)) {
      body["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "QueryDeviceProvisioning",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryDeviceProvisioningResponse>(await this.callApi(params, req, runtime), new QueryDeviceProvisioningResponse({}));
  }

  async queryDeviceProvisioning(request: QueryDeviceProvisioningRequest): Promise<QueryDeviceProvisioningResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceProvisioningWithOptions(request, runtime);
  }

  /**
    * You can query only the service call records of the previous 30 days.
    * >  The storage period of a service call record is calculated from the day when the service is called.
    * ## QPS limits
    * You can call this API operation up to 50 times per second per account. 
    * >  The RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryDeviceServiceDataRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return QueryDeviceServiceDataResponse
   */
  async queryDeviceServiceDataWithOptions(request: QueryDeviceServiceDataRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceServiceDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.asc)) {
      query["Asc"] = request.asc;
    }

    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.identifier)) {
      query["Identifier"] = request.identifier;
    }

    if (!Util.isUnset(request.iotId)) {
      query["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryDeviceServiceData",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryDeviceServiceDataResponse>(await this.callApi(params, req, runtime), new QueryDeviceServiceDataResponse({}));
  }

  /**
    * You can query only the service call records of the previous 30 days.
    * >  The storage period of a service call record is calculated from the day when the service is called.
    * ## QPS limits
    * You can call this API operation up to 50 times per second per account. 
    * >  The RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryDeviceServiceDataRequest
    * @return QueryDeviceServiceDataResponse
   */
  async queryDeviceServiceData(request: QueryDeviceServiceDataRequest): Promise<QueryDeviceServiceDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceServiceDataWithOptions(request, runtime);
  }

  async queryDeviceSpeechWithOptions(request: QueryDeviceSpeechRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceSpeechResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.iotId)) {
      body["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      body["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageId)) {
      body["PageId"] = request.pageId;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "QueryDeviceSpeech",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryDeviceSpeechResponse>(await this.callApi(params, req, runtime), new QueryDeviceSpeechResponse({}));
  }

  async queryDeviceSpeech(request: QueryDeviceSpeechRequest): Promise<QueryDeviceSpeechResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceSpeechWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryDeviceStatisticsRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return QueryDeviceStatisticsResponse
   */
  async queryDeviceStatisticsWithOptions(request: QueryDeviceStatisticsRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceStatisticsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryDeviceStatistics",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryDeviceStatisticsResponse>(await this.callApi(params, req, runtime), new QueryDeviceStatisticsResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryDeviceStatisticsRequest
    * @return QueryDeviceStatisticsResponse
   */
  async queryDeviceStatistics(request: QueryDeviceStatisticsRequest): Promise<QueryDeviceStatisticsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceStatisticsWithOptions(request, runtime);
  }

  /**
    * ## QPS limits
    * You can call this operation up to 100 times per second per account.
    * >  The RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryDeviceSubTopicRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return QueryDeviceSubTopicResponse
   */
  async queryDeviceSubTopicWithOptions(request: QueryDeviceSubTopicRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceSubTopicResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryDeviceSubTopic",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryDeviceSubTopicResponse>(await this.callApi(params, req, runtime), new QueryDeviceSubTopicResponse({}));
  }

  /**
    * ## QPS limits
    * You can call this operation up to 100 times per second per account.
    * >  The RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryDeviceSubTopicRequest
    * @return QueryDeviceSubTopicResponse
   */
  async queryDeviceSubTopic(request: QueryDeviceSubTopicRequest): Promise<QueryDeviceSubTopicResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceSubTopicWithOptions(request, runtime);
  }

  async queryDeviceTunnelWithOptions(request: QueryDeviceTunnelRequest, runtime: $Util.RuntimeOptions): Promise<QueryDeviceTunnelResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.tunnelId)) {
      query["TunnelId"] = request.tunnelId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryDeviceTunnel",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryDeviceTunnelResponse>(await this.callApi(params, req, runtime), new QueryDeviceTunnelResponse({}));
  }

  async queryDeviceTunnel(request: QueryDeviceTunnelRequest): Promise<QueryDeviceTunnelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDeviceTunnelWithOptions(request, runtime);
  }

  async queryDevicesHotStorageDataWithOptions(request: QueryDevicesHotStorageDataRequest, runtime: $Util.RuntimeOptions): Promise<QueryDevicesHotStorageDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.asc)) {
      query["Asc"] = request.asc;
    }

    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.identifier)) {
      query["Identifier"] = request.identifier;
    }

    if (!Util.isUnset(request.iotId)) {
      query["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.nextPageToken)) {
      query["NextPageToken"] = request.nextPageToken;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.userTopic)) {
      query["UserTopic"] = request.userTopic;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryDevicesHotStorageData",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryDevicesHotStorageDataResponse>(await this.callApi(params, req, runtime), new QueryDevicesHotStorageDataResponse({}));
  }

  async queryDevicesHotStorageData(request: QueryDevicesHotStorageDataRequest): Promise<QueryDevicesHotStorageDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDevicesHotStorageDataWithOptions(request, runtime);
  }

  async queryDevicesHotStorageDataStatusWithOptions(request: QueryDevicesHotStorageDataStatusRequest, runtime: $Util.RuntimeOptions): Promise<QueryDevicesHotStorageDataStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.asc)) {
      query["Asc"] = request.asc;
    }

    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotId)) {
      query["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.nextPageToken)) {
      query["NextPageToken"] = request.nextPageToken;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.userTopic)) {
      query["UserTopic"] = request.userTopic;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryDevicesHotStorageDataStatus",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryDevicesHotStorageDataStatusResponse>(await this.callApi(params, req, runtime), new QueryDevicesHotStorageDataStatusResponse({}));
  }

  async queryDevicesHotStorageDataStatus(request: QueryDevicesHotStorageDataStatusRequest): Promise<QueryDevicesHotStorageDataStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDevicesHotStorageDataStatusWithOptions(request, runtime);
  }

  async queryDynamicGroupDevicesWithOptions(request: QueryDynamicGroupDevicesRequest, runtime: $Util.RuntimeOptions): Promise<QueryDynamicGroupDevicesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.fuzzyName)) {
      query["FuzzyName"] = request.fuzzyName;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryDynamicGroupDevices",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryDynamicGroupDevicesResponse>(await this.callApi(params, req, runtime), new QueryDynamicGroupDevicesResponse({}));
  }

  async queryDynamicGroupDevices(request: QueryDynamicGroupDevicesRequest): Promise<QueryDynamicGroupDevicesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDynamicGroupDevicesWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * A single Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
    * >  RAM users share the quota of the Alibaba Cloud account.
    *
    * @param request QueryEdgeDriverRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return QueryEdgeDriverResponse
   */
  async queryEdgeDriverWithOptions(request: QueryEdgeDriverRequest, runtime: $Util.RuntimeOptions): Promise<QueryEdgeDriverResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.driverName)) {
      query["DriverName"] = request.driverName;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryEdgeDriver",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryEdgeDriverResponse>(await this.callApi(params, req, runtime), new QueryEdgeDriverResponse({}));
  }

  /**
    * ## Limits
    * A single Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
    * >  RAM users share the quota of the Alibaba Cloud account.
    *
    * @param request QueryEdgeDriverRequest
    * @return QueryEdgeDriverResponse
   */
  async queryEdgeDriver(request: QueryEdgeDriverRequest): Promise<QueryEdgeDriverResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryEdgeDriverWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryEdgeDriverVersionRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return QueryEdgeDriverVersionResponse
   */
  async queryEdgeDriverVersionWithOptions(request: QueryEdgeDriverVersionRequest, runtime: $Util.RuntimeOptions): Promise<QueryEdgeDriverVersionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.driverId)) {
      query["DriverId"] = request.driverId;
    }

    if (!Util.isUnset(request.driverVersion)) {
      query["DriverVersion"] = request.driverVersion;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.versionState)) {
      query["VersionState"] = request.versionState;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryEdgeDriverVersion",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryEdgeDriverVersionResponse>(await this.callApi(params, req, runtime), new QueryEdgeDriverVersionResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryEdgeDriverVersionRequest
    * @return QueryEdgeDriverVersionResponse
   */
  async queryEdgeDriverVersion(request: QueryEdgeDriverVersionRequest): Promise<QueryEdgeDriverVersionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryEdgeDriverVersionWithOptions(request, runtime);
  }

  /**
    * In addition to the preceding exclusive request parameters, you must specify common request parameters when calling this API operation. For more information about common request parameters, see [Common parameters](~~30561~~).
    *
    * @param request QueryEdgeInstanceRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return QueryEdgeInstanceResponse
   */
  async queryEdgeInstanceWithOptions(request: QueryEdgeInstanceRequest, runtime: $Util.RuntimeOptions): Promise<QueryEdgeInstanceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryEdgeInstance",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryEdgeInstanceResponse>(await this.callApi(params, req, runtime), new QueryEdgeInstanceResponse({}));
  }

  /**
    * In addition to the preceding exclusive request parameters, you must specify common request parameters when calling this API operation. For more information about common request parameters, see [Common parameters](~~30561~~).
    *
    * @param request QueryEdgeInstanceRequest
    * @return QueryEdgeInstanceResponse
   */
  async queryEdgeInstance(request: QueryEdgeInstanceRequest): Promise<QueryEdgeInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryEdgeInstanceWithOptions(request, runtime);
  }

  async queryEdgeInstanceChannelWithOptions(request: QueryEdgeInstanceChannelRequest, runtime: $Util.RuntimeOptions): Promise<QueryEdgeInstanceChannelResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.channelName)) {
      query["ChannelName"] = request.channelName;
    }

    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.driverId)) {
      query["DriverId"] = request.driverId;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryEdgeInstanceChannel",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryEdgeInstanceChannelResponse>(await this.callApi(params, req, runtime), new QueryEdgeInstanceChannelResponse({}));
  }

  async queryEdgeInstanceChannel(request: QueryEdgeInstanceChannelRequest): Promise<QueryEdgeInstanceChannelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryEdgeInstanceChannelWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryEdgeInstanceDeviceRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return QueryEdgeInstanceDeviceResponse
   */
  async queryEdgeInstanceDeviceWithOptions(request: QueryEdgeInstanceDeviceRequest, runtime: $Util.RuntimeOptions): Promise<QueryEdgeInstanceDeviceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryEdgeInstanceDevice",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryEdgeInstanceDeviceResponse>(await this.callApi(params, req, runtime), new QueryEdgeInstanceDeviceResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryEdgeInstanceDeviceRequest
    * @return QueryEdgeInstanceDeviceResponse
   */
  async queryEdgeInstanceDevice(request: QueryEdgeInstanceDeviceRequest): Promise<QueryEdgeInstanceDeviceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryEdgeInstanceDeviceWithOptions(request, runtime);
  }

  async queryEdgeInstanceDeviceByDriverWithOptions(request: QueryEdgeInstanceDeviceByDriverRequest, runtime: $Util.RuntimeOptions): Promise<QueryEdgeInstanceDeviceByDriverResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.channelId)) {
      query["ChannelId"] = request.channelId;
    }

    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.driverId)) {
      query["DriverId"] = request.driverId;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryEdgeInstanceDeviceByDriver",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryEdgeInstanceDeviceByDriverResponse>(await this.callApi(params, req, runtime), new QueryEdgeInstanceDeviceByDriverResponse({}));
  }

  async queryEdgeInstanceDeviceByDriver(request: QueryEdgeInstanceDeviceByDriverRequest): Promise<QueryEdgeInstanceDeviceByDriverResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryEdgeInstanceDeviceByDriverWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryEdgeInstanceDriverRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return QueryEdgeInstanceDriverResponse
   */
  async queryEdgeInstanceDriverWithOptions(request: QueryEdgeInstanceDriverRequest, runtime: $Util.RuntimeOptions): Promise<QueryEdgeInstanceDriverResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryEdgeInstanceDriver",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryEdgeInstanceDriverResponse>(await this.callApi(params, req, runtime), new QueryEdgeInstanceDriverResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryEdgeInstanceDriverRequest
    * @return QueryEdgeInstanceDriverResponse
   */
  async queryEdgeInstanceDriver(request: QueryEdgeInstanceDriverRequest): Promise<QueryEdgeInstanceDriverResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryEdgeInstanceDriverWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryEdgeInstanceGatewayRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return QueryEdgeInstanceGatewayResponse
   */
  async queryEdgeInstanceGatewayWithOptions(request: QueryEdgeInstanceGatewayRequest, runtime: $Util.RuntimeOptions): Promise<QueryEdgeInstanceGatewayResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryEdgeInstanceGateway",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryEdgeInstanceGatewayResponse>(await this.callApi(params, req, runtime), new QueryEdgeInstanceGatewayResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryEdgeInstanceGatewayRequest
    * @return QueryEdgeInstanceGatewayResponse
   */
  async queryEdgeInstanceGateway(request: QueryEdgeInstanceGatewayRequest): Promise<QueryEdgeInstanceGatewayResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryEdgeInstanceGatewayWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryEdgeInstanceHistoricDeploymentRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return QueryEdgeInstanceHistoricDeploymentResponse
   */
  async queryEdgeInstanceHistoricDeploymentWithOptions(request: QueryEdgeInstanceHistoricDeploymentRequest, runtime: $Util.RuntimeOptions): Promise<QueryEdgeInstanceHistoricDeploymentResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryEdgeInstanceHistoricDeployment",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryEdgeInstanceHistoricDeploymentResponse>(await this.callApi(params, req, runtime), new QueryEdgeInstanceHistoricDeploymentResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryEdgeInstanceHistoricDeploymentRequest
    * @return QueryEdgeInstanceHistoricDeploymentResponse
   */
  async queryEdgeInstanceHistoricDeployment(request: QueryEdgeInstanceHistoricDeploymentRequest): Promise<QueryEdgeInstanceHistoricDeploymentResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryEdgeInstanceHistoricDeploymentWithOptions(request, runtime);
  }

  async queryEdgeInstanceMessageRoutingWithOptions(request: QueryEdgeInstanceMessageRoutingRequest, runtime: $Util.RuntimeOptions): Promise<QueryEdgeInstanceMessageRoutingResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryEdgeInstanceMessageRouting",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryEdgeInstanceMessageRoutingResponse>(await this.callApi(params, req, runtime), new QueryEdgeInstanceMessageRoutingResponse({}));
  }

  async queryEdgeInstanceMessageRouting(request: QueryEdgeInstanceMessageRoutingRequest): Promise<QueryEdgeInstanceMessageRoutingResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryEdgeInstanceMessageRoutingWithOptions(request, runtime);
  }

  async queryEdgeInstanceSceneRuleWithOptions(request: QueryEdgeInstanceSceneRuleRequest, runtime: $Util.RuntimeOptions): Promise<QueryEdgeInstanceSceneRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryEdgeInstanceSceneRule",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryEdgeInstanceSceneRuleResponse>(await this.callApi(params, req, runtime), new QueryEdgeInstanceSceneRuleResponse({}));
  }

  async queryEdgeInstanceSceneRule(request: QueryEdgeInstanceSceneRuleRequest): Promise<QueryEdgeInstanceSceneRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryEdgeInstanceSceneRuleWithOptions(request, runtime);
  }

  async queryImportedDeviceByApplyIdWithOptions(request: QueryImportedDeviceByApplyIdRequest, runtime: $Util.RuntimeOptions): Promise<QueryImportedDeviceByApplyIdResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.applyId)) {
      query["ApplyId"] = request.applyId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageNo)) {
      query["PageNo"] = request.pageNo;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryImportedDeviceByApplyId",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryImportedDeviceByApplyIdResponse>(await this.callApi(params, req, runtime), new QueryImportedDeviceByApplyIdResponse({}));
  }

  async queryImportedDeviceByApplyId(request: QueryImportedDeviceByApplyIdRequest): Promise<QueryImportedDeviceByApplyIdResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryImportedDeviceByApplyIdWithOptions(request, runtime);
  }

  async queryJobWithOptions(request: QueryJobRequest, runtime: $Util.RuntimeOptions): Promise<QueryJobResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.jobId)) {
      query["JobId"] = request.jobId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryJob",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryJobResponse>(await this.callApi(params, req, runtime), new QueryJobResponse({}));
  }

  async queryJob(request: QueryJobRequest): Promise<QueryJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryJobWithOptions(request, runtime);
  }

  async queryJobStatisticsWithOptions(request: QueryJobStatisticsRequest, runtime: $Util.RuntimeOptions): Promise<QueryJobStatisticsResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryJobStatistics",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryJobStatisticsResponse>(await this.callApi(params, req, runtime), new QueryJobStatisticsResponse({}));
  }

  async queryJobStatistics(request: QueryJobStatisticsRequest): Promise<QueryJobStatisticsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryJobStatisticsWithOptions(request, runtime);
  }

  async queryLicenseDeviceListWithOptions(request: QueryLicenseDeviceListRequest, runtime: $Util.RuntimeOptions): Promise<QueryLicenseDeviceListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.iotId)) {
      query["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.licenseCode)) {
      query["LicenseCode"] = request.licenseCode;
    }

    if (!Util.isUnset(request.pageId)) {
      query["PageId"] = request.pageId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryLicenseDeviceList",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryLicenseDeviceListResponse>(await this.callApi(params, req, runtime), new QueryLicenseDeviceListResponse({}));
  }

  async queryLicenseDeviceList(request: QueryLicenseDeviceListRequest): Promise<QueryLicenseDeviceListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryLicenseDeviceListWithOptions(request, runtime);
  }

  async queryLoRaJoinPermissionsWithOptions(request: QueryLoRaJoinPermissionsRequest, runtime: $Util.RuntimeOptions): Promise<QueryLoRaJoinPermissionsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryLoRaJoinPermissions",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryLoRaJoinPermissionsResponse>(await this.callApi(params, req, runtime), new QueryLoRaJoinPermissionsResponse({}));
  }

  async queryLoRaJoinPermissions(request: QueryLoRaJoinPermissionsRequest): Promise<QueryLoRaJoinPermissionsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryLoRaJoinPermissionsWithOptions(request, runtime);
  }

  async queryMessageInfoWithOptions(request: QueryMessageInfoRequest, runtime: $Util.RuntimeOptions): Promise<QueryMessageInfoResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.uniMsgId)) {
      query["UniMsgId"] = request.uniMsgId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryMessageInfo",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryMessageInfoResponse>(await this.callApi(params, req, runtime), new QueryMessageInfoResponse({}));
  }

  async queryMessageInfo(request: QueryMessageInfoRequest): Promise<QueryMessageInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryMessageInfoWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 20 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryOTAFirmwareRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return QueryOTAFirmwareResponse
   */
  async queryOTAFirmwareWithOptions(request: QueryOTAFirmwareRequest, runtime: $Util.RuntimeOptions): Promise<QueryOTAFirmwareResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.firmwareId)) {
      query["FirmwareId"] = request.firmwareId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryOTAFirmware",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryOTAFirmwareResponse>(await this.callApi(params, req, runtime), new QueryOTAFirmwareResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 20 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryOTAFirmwareRequest
    * @return QueryOTAFirmwareResponse
   */
  async queryOTAFirmware(request: QueryOTAFirmwareRequest): Promise<QueryOTAFirmwareResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryOTAFirmwareWithOptions(request, runtime);
  }

  /**
    * After you call the [CreateOTAVerifyJob](~~147480~~), [CreateOTAStaticUpgradeJob](~~147496~~), or [CreateOTADynamicUpgradeJob](~~147887~~) API operation to create an update batch, the **JobId** parameter is returned. You can use this parameter to query the details of the update batch.
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS). 
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryOTAJobRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return QueryOTAJobResponse
   */
  async queryOTAJobWithOptions(request: QueryOTAJobRequest, runtime: $Util.RuntimeOptions): Promise<QueryOTAJobResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.jobId)) {
      query["JobId"] = request.jobId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryOTAJob",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryOTAJobResponse>(await this.callApi(params, req, runtime), new QueryOTAJobResponse({}));
  }

  /**
    * After you call the [CreateOTAVerifyJob](~~147480~~), [CreateOTAStaticUpgradeJob](~~147496~~), or [CreateOTADynamicUpgradeJob](~~147887~~) API operation to create an update batch, the **JobId** parameter is returned. You can use this parameter to query the details of the update batch.
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS). 
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryOTAJobRequest
    * @return QueryOTAJobResponse
   */
  async queryOTAJob(request: QueryOTAJobRequest): Promise<QueryOTAJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryOTAJobWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryPageByApplyIdRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return QueryPageByApplyIdResponse
   */
  async queryPageByApplyIdWithOptions(request: QueryPageByApplyIdRequest, runtime: $Util.RuntimeOptions): Promise<QueryPageByApplyIdResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.applyId)) {
      query["ApplyId"] = request.applyId;
    }

    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryPageByApplyId",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryPageByApplyIdResponse>(await this.callApi(params, req, runtime), new QueryPageByApplyIdResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryPageByApplyIdRequest
    * @return QueryPageByApplyIdResponse
   */
  async queryPageByApplyId(request: QueryPageByApplyIdRequest): Promise<QueryPageByApplyIdResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryPageByApplyIdWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryProductRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return QueryProductResponse
   */
  async queryProductWithOptions(request: QueryProductRequest, runtime: $Util.RuntimeOptions): Promise<QueryProductResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryProduct",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryProductResponse>(await this.callApi(params, req, runtime), new QueryProductResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryProductRequest
    * @return QueryProductResponse
   */
  async queryProduct(request: QueryProductRequest): Promise<QueryProductResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryProductWithOptions(request, runtime);
  }

  async queryProductCertInfoWithOptions(request: QueryProductCertInfoRequest, runtime: $Util.RuntimeOptions): Promise<QueryProductCertInfoResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryProductCertInfo",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryProductCertInfoResponse>(await this.callApi(params, req, runtime), new QueryProductCertInfoResponse({}));
  }

  async queryProductCertInfo(request: QueryProductCertInfoRequest): Promise<QueryProductCertInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryProductCertInfoWithOptions(request, runtime);
  }

  /**
    * ## QPS limits
    * *   Each Alibaba Cloud account can run up to 50 queries per second (QPS).
    * > The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
    * *   If the product of the value of the **CurrentPage** parameter and the value of the **PageSize** parameter is greater than or equal to 100,000, the QPS of this operation decreases.
    *     In this case, each Alibaba Cloud account can run up to 2 QPS.
    *
    * @param request QueryProductListRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return QueryProductListResponse
   */
  async queryProductListWithOptions(request: QueryProductListRequest, runtime: $Util.RuntimeOptions): Promise<QueryProductListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.aliyunCommodityCode)) {
      query["AliyunCommodityCode"] = request.aliyunCommodityCode;
    }

    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryProductList",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryProductListResponse>(await this.callApi(params, req, runtime), new QueryProductListResponse({}));
  }

  /**
    * ## QPS limits
    * *   Each Alibaba Cloud account can run up to 50 queries per second (QPS).
    * > The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
    * *   If the product of the value of the **CurrentPage** parameter and the value of the **PageSize** parameter is greater than or equal to 100,000, the QPS of this operation decreases.
    *     In this case, each Alibaba Cloud account can run up to 2 QPS.
    *
    * @param request QueryProductListRequest
    * @return QueryProductListResponse
   */
  async queryProductList(request: QueryProductListRequest): Promise<QueryProductListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryProductListWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 3 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryProductTopicRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return QueryProductTopicResponse
   */
  async queryProductTopicWithOptions(request: QueryProductTopicRequest, runtime: $Util.RuntimeOptions): Promise<QueryProductTopicResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryProductTopic",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryProductTopicResponse>(await this.callApi(params, req, runtime), new QueryProductTopicResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 3 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryProductTopicRequest
    * @return QueryProductTopicResponse
   */
  async queryProductTopic(request: QueryProductTopicRequest): Promise<QueryProductTopicResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryProductTopicWithOptions(request, runtime);
  }

  async queryProjectShareDeviceListWithOptions(request: QueryProjectShareDeviceListRequest, runtime: $Util.RuntimeOptions): Promise<QueryProjectShareDeviceListResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.deviceName)) {
      body["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      body["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageId)) {
      body["PageId"] = request.pageId;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.productKey)) {
      body["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "QueryProjectShareDeviceList",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryProjectShareDeviceListResponse>(await this.callApi(params, req, runtime), new QueryProjectShareDeviceListResponse({}));
  }

  async queryProjectShareDeviceList(request: QueryProjectShareDeviceListRequest): Promise<QueryProjectShareDeviceListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryProjectShareDeviceListWithOptions(request, runtime);
  }

  async querySceneRuleWithOptions(request: QuerySceneRuleRequest, runtime: $Util.RuntimeOptions): Promise<QuerySceneRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.ruleName)) {
      query["RuleName"] = request.ruleName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QuerySceneRule",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QuerySceneRuleResponse>(await this.callApi(params, req, runtime), new QuerySceneRuleResponse({}));
  }

  async querySceneRule(request: QuerySceneRuleRequest): Promise<QuerySceneRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.querySceneRuleWithOptions(request, runtime);
  }

  async querySchedulePeriodListWithOptions(request: QuerySchedulePeriodListRequest, runtime: $Util.RuntimeOptions): Promise<QuerySchedulePeriodListResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      body["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageId)) {
      body["PageId"] = request.pageId;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.scheduleCode)) {
      body["ScheduleCode"] = request.scheduleCode;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "QuerySchedulePeriodList",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QuerySchedulePeriodListResponse>(await this.callApi(params, req, runtime), new QuerySchedulePeriodListResponse({}));
  }

  async querySchedulePeriodList(request: QuerySchedulePeriodListRequest): Promise<QuerySchedulePeriodListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.querySchedulePeriodListWithOptions(request, runtime);
  }

  async queryShareTaskDeviceListWithOptions(request: QueryShareTaskDeviceListRequest, runtime: $Util.RuntimeOptions): Promise<QueryShareTaskDeviceListResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.deviceName)) {
      body["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      body["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageId)) {
      body["PageId"] = request.pageId;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.shareTaskId)) {
      body["ShareTaskId"] = request.shareTaskId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "QueryShareTaskDeviceList",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryShareTaskDeviceListResponse>(await this.callApi(params, req, runtime), new QueryShareTaskDeviceListResponse({}));
  }

  async queryShareTaskDeviceList(request: QueryShareTaskDeviceListRequest): Promise<QueryShareTaskDeviceListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryShareTaskDeviceListWithOptions(request, runtime);
  }

  async querySolutionDeviceGroupPageWithOptions(request: QuerySolutionDeviceGroupPageRequest, runtime: $Util.RuntimeOptions): Promise<QuerySolutionDeviceGroupPageResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.fuzzyGroupName)) {
      query["FuzzyGroupName"] = request.fuzzyGroupName;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageId)) {
      query["PageId"] = request.pageId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.projectCode)) {
      query["ProjectCode"] = request.projectCode;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QuerySolutionDeviceGroupPage",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QuerySolutionDeviceGroupPageResponse>(await this.callApi(params, req, runtime), new QuerySolutionDeviceGroupPageResponse({}));
  }

  async querySolutionDeviceGroupPage(request: QuerySolutionDeviceGroupPageRequest): Promise<QuerySolutionDeviceGroupPageResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.querySolutionDeviceGroupPageWithOptions(request, runtime);
  }

  async querySoundCodeLabelBatchFailedResultWithOptions(request: QuerySoundCodeLabelBatchFailedResultRequest, runtime: $Util.RuntimeOptions): Promise<QuerySoundCodeLabelBatchFailedResultResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.batchCode)) {
      body["BatchCode"] = request.batchCode;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      body["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "QuerySoundCodeLabelBatchFailedResult",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QuerySoundCodeLabelBatchFailedResultResponse>(await this.callApi(params, req, runtime), new QuerySoundCodeLabelBatchFailedResultResponse({}));
  }

  async querySoundCodeLabelBatchFailedResult(request: QuerySoundCodeLabelBatchFailedResultRequest): Promise<QuerySoundCodeLabelBatchFailedResultResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.querySoundCodeLabelBatchFailedResultWithOptions(request, runtime);
  }

  async querySoundCodeLabelBatchListWithOptions(request: QuerySoundCodeLabelBatchListRequest, runtime: $Util.RuntimeOptions): Promise<QuerySoundCodeLabelBatchListResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      body["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageId)) {
      body["PageId"] = request.pageId;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.scheduleCode)) {
      body["ScheduleCode"] = request.scheduleCode;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "QuerySoundCodeLabelBatchList",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QuerySoundCodeLabelBatchListResponse>(await this.callApi(params, req, runtime), new QuerySoundCodeLabelBatchListResponse({}));
  }

  async querySoundCodeLabelBatchList(request: QuerySoundCodeLabelBatchListRequest): Promise<QuerySoundCodeLabelBatchListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.querySoundCodeLabelBatchListWithOptions(request, runtime);
  }

  async querySoundCodeLabelListWithOptions(request: QuerySoundCodeLabelListRequest, runtime: $Util.RuntimeOptions): Promise<QuerySoundCodeLabelListResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      body["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageId)) {
      body["PageId"] = request.pageId;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.scheduleCode)) {
      body["ScheduleCode"] = request.scheduleCode;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "QuerySoundCodeLabelList",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QuerySoundCodeLabelListResponse>(await this.callApi(params, req, runtime), new QuerySoundCodeLabelListResponse({}));
  }

  async querySoundCodeLabelList(request: QuerySoundCodeLabelListRequest): Promise<QuerySoundCodeLabelListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.querySoundCodeLabelListWithOptions(request, runtime);
  }

  async querySoundCodeListWithOptions(request: QuerySoundCodeListRequest, runtime: $Util.RuntimeOptions): Promise<QuerySoundCodeListResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      body["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageId)) {
      body["PageId"] = request.pageId;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "QuerySoundCodeList",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QuerySoundCodeListResponse>(await this.callApi(params, req, runtime), new QuerySoundCodeListResponse({}));
  }

  async querySoundCodeList(request: QuerySoundCodeListRequest): Promise<QuerySoundCodeListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.querySoundCodeListWithOptions(request, runtime);
  }

  async querySoundCodeScheduleListWithOptions(request: QuerySoundCodeScheduleListRequest, runtime: $Util.RuntimeOptions): Promise<QuerySoundCodeScheduleListResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      body["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageId)) {
      body["PageId"] = request.pageId;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "QuerySoundCodeScheduleList",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QuerySoundCodeScheduleListResponse>(await this.callApi(params, req, runtime), new QuerySoundCodeScheduleListResponse({}));
  }

  async querySoundCodeScheduleList(request: QuerySoundCodeScheduleListRequest): Promise<QuerySoundCodeScheduleListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.querySoundCodeScheduleListWithOptions(request, runtime);
  }

  async querySpeechWithOptions(request: QuerySpeechRequest, runtime: $Util.RuntimeOptions): Promise<QuerySpeechResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      body["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.speechCode)) {
      body["SpeechCode"] = request.speechCode;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "QuerySpeech",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QuerySpeechResponse>(await this.callApi(params, req, runtime), new QuerySpeechResponse({}));
  }

  async querySpeech(request: QuerySpeechRequest): Promise<QuerySpeechResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.querySpeechWithOptions(request, runtime);
  }

  async querySpeechDeviceWithOptions(request: QuerySpeechDeviceRequest, runtime: $Util.RuntimeOptions): Promise<QuerySpeechDeviceResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.availableSpace)) {
      body["AvailableSpace"] = request.availableSpace;
    }

    if (!Util.isUnset(request.availableSpaceScope)) {
      body["AvailableSpaceScope"] = request.availableSpaceScope;
    }

    if (!Util.isUnset(request.deviceName)) {
      body["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      body["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageId)) {
      body["PageId"] = request.pageId;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.projectCode)) {
      body["ProjectCode"] = request.projectCode;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "QuerySpeechDevice",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QuerySpeechDeviceResponse>(await this.callApi(params, req, runtime), new QuerySpeechDeviceResponse({}));
  }

  async querySpeechDevice(request: QuerySpeechDeviceRequest): Promise<QuerySpeechDeviceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.querySpeechDeviceWithOptions(request, runtime);
  }

  async querySpeechLicenseAvailableQuotaWithOptions(request: QuerySpeechLicenseAvailableQuotaRequest, runtime: $Util.RuntimeOptions): Promise<QuerySpeechLicenseAvailableQuotaResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      body["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "QuerySpeechLicenseAvailableQuota",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QuerySpeechLicenseAvailableQuotaResponse>(await this.callApi(params, req, runtime), new QuerySpeechLicenseAvailableQuotaResponse({}));
  }

  async querySpeechLicenseAvailableQuota(request: QuerySpeechLicenseAvailableQuotaRequest): Promise<QuerySpeechLicenseAvailableQuotaResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.querySpeechLicenseAvailableQuotaWithOptions(request, runtime);
  }

  async querySpeechLicenseDeviceListWithOptions(request: QuerySpeechLicenseDeviceListRequest, runtime: $Util.RuntimeOptions): Promise<QuerySpeechLicenseDeviceListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageId)) {
      query["PageId"] = request.pageId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.checkGroupId)) {
      body["CheckGroupId"] = request.checkGroupId;
    }

    if (!Util.isUnset(request.deviceName)) {
      body["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.licenseStatusList)) {
      body["LicenseStatusList"] = request.licenseStatusList;
    }

    if (!Util.isUnset(request.productKey)) {
      body["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "QuerySpeechLicenseDeviceList",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QuerySpeechLicenseDeviceListResponse>(await this.callApi(params, req, runtime), new QuerySpeechLicenseDeviceListResponse({}));
  }

  async querySpeechLicenseDeviceList(request: QuerySpeechLicenseDeviceListRequest): Promise<QuerySpeechLicenseDeviceListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.querySpeechLicenseDeviceListWithOptions(request, runtime);
  }

  async querySpeechListWithOptions(request: QuerySpeechListRequest, runtime: $Util.RuntimeOptions): Promise<QuerySpeechListResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.audioFormat)) {
      body["AudioFormat"] = request.audioFormat;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      body["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageId)) {
      body["PageId"] = request.pageId;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.projectCode)) {
      body["ProjectCode"] = request.projectCode;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "QuerySpeechList",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QuerySpeechListResponse>(await this.callApi(params, req, runtime), new QuerySpeechListResponse({}));
  }

  async querySpeechList(request: QuerySpeechListRequest): Promise<QuerySpeechListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.querySpeechListWithOptions(request, runtime);
  }

  async querySpeechPushJobWithOptions(request: QuerySpeechPushJobRequest, runtime: $Util.RuntimeOptions): Promise<QuerySpeechPushJobResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.jobCode)) {
      query["JobCode"] = request.jobCode;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      body["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageId)) {
      body["PageId"] = request.pageId;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.projectCode)) {
      body["ProjectCode"] = request.projectCode;
    }

    if (!Util.isUnset(request.pushMode)) {
      body["PushMode"] = request.pushMode;
    }

    if (!Util.isUnset(request.statusList)) {
      body["StatusList"] = request.statusList;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "QuerySpeechPushJob",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QuerySpeechPushJobResponse>(await this.callApi(params, req, runtime), new QuerySpeechPushJobResponse({}));
  }

  async querySpeechPushJob(request: QuerySpeechPushJobRequest): Promise<QuerySpeechPushJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.querySpeechPushJobWithOptions(request, runtime);
  }

  async querySpeechPushJobDeviceWithOptions(request: QuerySpeechPushJobDeviceRequest, runtime: $Util.RuntimeOptions): Promise<QuerySpeechPushJobDeviceResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.deviceName)) {
      body["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      body["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.jobCode)) {
      body["JobCode"] = request.jobCode;
    }

    if (!Util.isUnset(request.pageId)) {
      body["PageId"] = request.pageId;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.status)) {
      body["Status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "QuerySpeechPushJobDevice",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QuerySpeechPushJobDeviceResponse>(await this.callApi(params, req, runtime), new QuerySpeechPushJobDeviceResponse({}));
  }

  async querySpeechPushJobDevice(request: QuerySpeechPushJobDeviceRequest): Promise<QuerySpeechPushJobDeviceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.querySpeechPushJobDeviceWithOptions(request, runtime);
  }

  async querySpeechPushJobSpeechWithOptions(request: QuerySpeechPushJobSpeechRequest, runtime: $Util.RuntimeOptions): Promise<QuerySpeechPushJobSpeechResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      body["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.jobCode)) {
      body["JobCode"] = request.jobCode;
    }

    if (!Util.isUnset(request.pageId)) {
      body["PageId"] = request.pageId;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "QuerySpeechPushJobSpeech",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QuerySpeechPushJobSpeechResponse>(await this.callApi(params, req, runtime), new QuerySpeechPushJobSpeechResponse({}));
  }

  async querySpeechPushJobSpeech(request: QuerySpeechPushJobSpeechRequest): Promise<QuerySpeechPushJobSpeechResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.querySpeechPushJobSpeechWithOptions(request, runtime);
  }

  async queryStudioAppDomainListOpenWithOptions(request: QueryStudioAppDomainListOpenRequest, runtime: $Util.RuntimeOptions): Promise<QueryStudioAppDomainListOpenResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appId)) {
      body["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      body["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "QueryStudioAppDomainListOpen",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryStudioAppDomainListOpenResponse>(await this.callApi(params, req, runtime), new QueryStudioAppDomainListOpenResponse({}));
  }

  async queryStudioAppDomainListOpen(request: QueryStudioAppDomainListOpenRequest): Promise<QueryStudioAppDomainListOpenResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryStudioAppDomainListOpenWithOptions(request, runtime);
  }

  async queryStudioAppListWithOptions(request: QueryStudioAppListRequest, runtime: $Util.RuntimeOptions): Promise<QueryStudioAppListResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.fuzzyName)) {
      body["FuzzyName"] = request.fuzzyName;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      body["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageNo)) {
      body["PageNo"] = request.pageNo;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.types)) {
      body["Types"] = request.types;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "QueryStudioAppList",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryStudioAppListResponse>(await this.callApi(params, req, runtime), new QueryStudioAppListResponse({}));
  }

  async queryStudioAppList(request: QueryStudioAppListRequest): Promise<QueryStudioAppListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryStudioAppListWithOptions(request, runtime);
  }

  async queryStudioAppPageListOpenWithOptions(request: QueryStudioAppPageListOpenRequest, runtime: $Util.RuntimeOptions): Promise<QueryStudioAppPageListOpenResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appId)) {
      body["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      body["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.isRelease)) {
      body["IsRelease"] = request.isRelease;
    }

    if (!Util.isUnset(request.pageNo)) {
      body["PageNo"] = request.pageNo;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "QueryStudioAppPageListOpen",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryStudioAppPageListOpenResponse>(await this.callApi(params, req, runtime), new QueryStudioAppPageListOpenResponse({}));
  }

  async queryStudioAppPageListOpen(request: QueryStudioAppPageListOpenRequest): Promise<QueryStudioAppPageListOpenResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryStudioAppPageListOpenWithOptions(request, runtime);
  }

  async queryStudioProjectListWithOptions(request: QueryStudioProjectListRequest, runtime: $Util.RuntimeOptions): Promise<QueryStudioProjectListResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      body["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.name)) {
      body["Name"] = request.name;
    }

    if (!Util.isUnset(request.pageNo)) {
      body["PageNo"] = request.pageNo;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "QueryStudioProjectList",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryStudioProjectListResponse>(await this.callApi(params, req, runtime), new QueryStudioProjectListResponse({}));
  }

  async queryStudioProjectList(request: QueryStudioProjectListRequest): Promise<QueryStudioProjectListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryStudioProjectListWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QuerySubscribeRelationRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return QuerySubscribeRelationResponse
   */
  async querySubscribeRelationWithOptions(request: QuerySubscribeRelationRequest, runtime: $Util.RuntimeOptions): Promise<QuerySubscribeRelationResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QuerySubscribeRelation",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QuerySubscribeRelationResponse>(await this.callApi(params, req, runtime), new QuerySubscribeRelationResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QuerySubscribeRelationRequest
    * @return QuerySubscribeRelationResponse
   */
  async querySubscribeRelation(request: QuerySubscribeRelationRequest): Promise<QuerySubscribeRelationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.querySubscribeRelationWithOptions(request, runtime);
  }

  async querySummarySceneRuleLogWithOptions(request: QuerySummarySceneRuleLogRequest, runtime: $Util.RuntimeOptions): Promise<QuerySummarySceneRuleLogResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.ruleId)) {
      query["RuleId"] = request.ruleId;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QuerySummarySceneRuleLog",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QuerySummarySceneRuleLogResponse>(await this.callApi(params, req, runtime), new QuerySummarySceneRuleLogResponse({}));
  }

  async querySummarySceneRuleLog(request: QuerySummarySceneRuleLogRequest): Promise<QuerySummarySceneRuleLogResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.querySummarySceneRuleLogWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QuerySuperDeviceGroupRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return QuerySuperDeviceGroupResponse
   */
  async querySuperDeviceGroupWithOptions(request: QuerySuperDeviceGroupRequest, runtime: $Util.RuntimeOptions): Promise<QuerySuperDeviceGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QuerySuperDeviceGroup",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QuerySuperDeviceGroupResponse>(await this.callApi(params, req, runtime), new QuerySuperDeviceGroupResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QuerySuperDeviceGroupRequest
    * @return QuerySuperDeviceGroupResponse
   */
  async querySuperDeviceGroup(request: QuerySuperDeviceGroupRequest): Promise<QuerySuperDeviceGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.querySuperDeviceGroupWithOptions(request, runtime);
  }

  async queryTaskWithOptions(request: QueryTaskRequest, runtime: $Util.RuntimeOptions): Promise<QueryTaskResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.taskId)) {
      query["TaskId"] = request.taskId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryTask",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryTaskResponse>(await this.callApi(params, req, runtime), new QueryTaskResponse({}));
  }

  async queryTask(request: QueryTaskRequest): Promise<QueryTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryTaskWithOptions(request, runtime);
  }

  /**
    * TSL features include properties, services, and events.
    * If you add custom modules to a TSL model and the value of the **FunctionBlockId** parameter is empty, you can obtain the TSL features of each custom module. If the value of the FunctionBlockId parameter is not empty, you can obtain the TSL features of a specified custom module.
    * For more information about the data format of the **ThingModelJson** parameter, see [Data structure of ThingModelJson](~~150457~~).
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS). 
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryThingModelRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return QueryThingModelResponse
   */
  async queryThingModelWithOptions(request: QueryThingModelRequest, runtime: $Util.RuntimeOptions): Promise<QueryThingModelResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.functionBlockId)) {
      query["FunctionBlockId"] = request.functionBlockId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.modelVersion)) {
      query["ModelVersion"] = request.modelVersion;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryThingModel",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryThingModelResponse>(await this.callApi(params, req, runtime), new QueryThingModelResponse({}));
  }

  /**
    * TSL features include properties, services, and events.
    * If you add custom modules to a TSL model and the value of the **FunctionBlockId** parameter is empty, you can obtain the TSL features of each custom module. If the value of the FunctionBlockId parameter is not empty, you can obtain the TSL features of a specified custom module.
    * For more information about the data format of the **ThingModelJson** parameter, see [Data structure of ThingModelJson](~~150457~~).
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS). 
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryThingModelRequest
    * @return QueryThingModelResponse
   */
  async queryThingModel(request: QueryThingModelRequest): Promise<QueryThingModelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryThingModelWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 20 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryThingModelExtendConfigRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return QueryThingModelExtendConfigResponse
   */
  async queryThingModelExtendConfigWithOptions(request: QueryThingModelExtendConfigRequest, runtime: $Util.RuntimeOptions): Promise<QueryThingModelExtendConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.functionBlockId)) {
      query["FunctionBlockId"] = request.functionBlockId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.modelVersion)) {
      query["ModelVersion"] = request.modelVersion;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryThingModelExtendConfig",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryThingModelExtendConfigResponse>(await this.callApi(params, req, runtime), new QueryThingModelExtendConfigResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 20 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryThingModelExtendConfigRequest
    * @return QueryThingModelExtendConfigResponse
   */
  async queryThingModelExtendConfig(request: QueryThingModelExtendConfigRequest): Promise<QueryThingModelExtendConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryThingModelExtendConfigWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 20 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryThingModelExtendConfigPublishedRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return QueryThingModelExtendConfigPublishedResponse
   */
  async queryThingModelExtendConfigPublishedWithOptions(request: QueryThingModelExtendConfigPublishedRequest, runtime: $Util.RuntimeOptions): Promise<QueryThingModelExtendConfigPublishedResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.functionBlockId)) {
      query["FunctionBlockId"] = request.functionBlockId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.modelVersion)) {
      query["ModelVersion"] = request.modelVersion;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryThingModelExtendConfigPublished",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryThingModelExtendConfigPublishedResponse>(await this.callApi(params, req, runtime), new QueryThingModelExtendConfigPublishedResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 20 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryThingModelExtendConfigPublishedRequest
    * @return QueryThingModelExtendConfigPublishedResponse
   */
  async queryThingModelExtendConfigPublished(request: QueryThingModelExtendConfigPublishedRequest): Promise<QueryThingModelExtendConfigPublishedResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryThingModelExtendConfigPublishedWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryThingModelPublishedRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return QueryThingModelPublishedResponse
   */
  async queryThingModelPublishedWithOptions(request: QueryThingModelPublishedRequest, runtime: $Util.RuntimeOptions): Promise<QueryThingModelPublishedResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.functionBlockId)) {
      query["FunctionBlockId"] = request.functionBlockId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.modelVersion)) {
      query["ModelVersion"] = request.modelVersion;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryThingModelPublished",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryThingModelPublishedResponse>(await this.callApi(params, req, runtime), new QueryThingModelPublishedResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryThingModelPublishedRequest
    * @return QueryThingModelPublishedResponse
   */
  async queryThingModelPublished(request: QueryThingModelPublishedRequest): Promise<QueryThingModelPublishedResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryThingModelPublishedWithOptions(request, runtime);
  }

  async queryTopicConfigWithOptions(request: QueryTopicConfigRequest, runtime: $Util.RuntimeOptions): Promise<QueryTopicConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryTopicConfig",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryTopicConfigResponse>(await this.callApi(params, req, runtime), new QueryTopicConfigResponse({}));
  }

  async queryTopicConfig(request: QueryTopicConfigRequest): Promise<QueryTopicConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryTopicConfigWithOptions(request, runtime);
  }

  /**
    * In addition to the preceding operation-specific request parameters, you must specify common request parameters when you call this operation. For more information, see [Common request parameters](~~30561~~).
    *
    * @param request QueryTopicReverseRouteTableRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return QueryTopicReverseRouteTableResponse
   */
  async queryTopicReverseRouteTableWithOptions(request: QueryTopicReverseRouteTableRequest, runtime: $Util.RuntimeOptions): Promise<QueryTopicReverseRouteTableResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.topic)) {
      query["Topic"] = request.topic;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryTopicReverseRouteTable",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryTopicReverseRouteTableResponse>(await this.callApi(params, req, runtime), new QueryTopicReverseRouteTableResponse({}));
  }

  /**
    * In addition to the preceding operation-specific request parameters, you must specify common request parameters when you call this operation. For more information, see [Common request parameters](~~30561~~).
    *
    * @param request QueryTopicReverseRouteTableRequest
    * @return QueryTopicReverseRouteTableResponse
   */
  async queryTopicReverseRouteTable(request: QueryTopicReverseRouteTableRequest): Promise<QueryTopicReverseRouteTableResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryTopicReverseRouteTableWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryTopicRouteTableRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return QueryTopicRouteTableResponse
   */
  async queryTopicRouteTableWithOptions(request: QueryTopicRouteTableRequest, runtime: $Util.RuntimeOptions): Promise<QueryTopicRouteTableResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.topic)) {
      query["Topic"] = request.topic;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryTopicRouteTable",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryTopicRouteTableResponse>(await this.callApi(params, req, runtime), new QueryTopicRouteTableResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request QueryTopicRouteTableRequest
    * @return QueryTopicRouteTableResponse
   */
  async queryTopicRouteTable(request: QueryTopicRouteTableRequest): Promise<QueryTopicRouteTableResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryTopicRouteTableWithOptions(request, runtime);
  }

  /**
    * *   You can call this operation to query the information about a device of a JT/T 808 gateway product.
    * *   When you call this operation, you must specify a **ProductKey** and a **DeviceName**. Otherwise, the call fails.
    * ## QPS limits
    * You can call this API operation up to 50 times per second per account. 
    * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
    *
    * @param request QueryVehicleDeviceRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return QueryVehicleDeviceResponse
   */
  async queryVehicleDeviceWithOptions(request: QueryVehicleDeviceRequest, runtime: $Util.RuntimeOptions): Promise<QueryVehicleDeviceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryVehicleDevice",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryVehicleDeviceResponse>(await this.callApi(params, req, runtime), new QueryVehicleDeviceResponse({}));
  }

  /**
    * *   You can call this operation to query the information about a device of a JT/T 808 gateway product.
    * *   When you call this operation, you must specify a **ProductKey** and a **DeviceName**. Otherwise, the call fails.
    * ## QPS limits
    * You can call this API operation up to 50 times per second per account. 
    * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
    *
    * @param request QueryVehicleDeviceRequest
    * @return QueryVehicleDeviceResponse
   */
  async queryVehicleDevice(request: QueryVehicleDeviceRequest): Promise<QueryVehicleDeviceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryVehicleDeviceWithOptions(request, runtime);
  }

  /**
    * If the device fails to send a response within the timeout period after you call the operation, IoT Platform considers that the call fails even if the device receives the message. The timeout period is specified by the **Timeout** parameter.
    * ## QPS limits
    * Each Alibaba Cloud account can run up to 1000 queries per second (QPS). 
    * >  The RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request RRpcRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return RRpcResponse
   */
  async rRpcWithOptions(request: RRpcRequest, runtime: $Util.RuntimeOptions): Promise<RRpcResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.contentType)) {
      query["ContentType"] = request.contentType;
    }

    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.requestBase64Byte)) {
      query["RequestBase64Byte"] = request.requestBase64Byte;
    }

    if (!Util.isUnset(request.timeout)) {
      query["Timeout"] = request.timeout;
    }

    if (!Util.isUnset(request.topic)) {
      query["Topic"] = request.topic;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "RRpc",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RRpcResponse>(await this.callApi(params, req, runtime), new RRpcResponse({}));
  }

  /**
    * If the device fails to send a response within the timeout period after you call the operation, IoT Platform considers that the call fails even if the device receives the message. The timeout period is specified by the **Timeout** parameter.
    * ## QPS limits
    * Each Alibaba Cloud account can run up to 1000 queries per second (QPS). 
    * >  The RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request RRpcRequest
    * @return RRpcResponse
   */
  async rRpc(request: RRpcRequest): Promise<RRpcResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.rRpcWithOptions(request, runtime);
  }

  async reBindLicenseDeviceWithOptions(request: ReBindLicenseDeviceRequest, runtime: $Util.RuntimeOptions): Promise<ReBindLicenseDeviceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.licenseCode)) {
      query["LicenseCode"] = request.licenseCode;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.deviceNameList)) {
      body["DeviceNameList"] = request.deviceNameList;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ReBindLicenseDevice",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ReBindLicenseDeviceResponse>(await this.callApi(params, req, runtime), new ReBindLicenseDeviceResponse({}));
  }

  async reBindLicenseDevice(request: ReBindLicenseDeviceRequest): Promise<ReBindLicenseDeviceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.reBindLicenseDeviceWithOptions(request, runtime);
  }

  async recognizeCarNumWithOptions(request: RecognizeCarNumRequest, runtime: $Util.RuntimeOptions): Promise<RecognizeCarNumResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.url)) {
      query["Url"] = request.url;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "RecognizeCarNum",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RecognizeCarNumResponse>(await this.callApi(params, req, runtime), new RecognizeCarNumResponse({}));
  }

  async recognizeCarNum(request: RecognizeCarNumRequest): Promise<RecognizeCarNumResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.recognizeCarNumWithOptions(request, runtime);
  }

  async recognizePictureGeneralWithOptions(request: RecognizePictureGeneralRequest, runtime: $Util.RuntimeOptions): Promise<RecognizePictureGeneralResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.url)) {
      query["Url"] = request.url;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "RecognizePictureGeneral",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RecognizePictureGeneralResponse>(await this.callApi(params, req, runtime), new RecognizePictureGeneralResponse({}));
  }

  async recognizePictureGeneral(request: RecognizePictureGeneralRequest): Promise<RecognizePictureGeneralResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.recognizePictureGeneralWithOptions(request, runtime);
  }

  async refreshDeviceTunnelSharePasswordWithOptions(request: RefreshDeviceTunnelSharePasswordRequest, runtime: $Util.RuntimeOptions): Promise<RefreshDeviceTunnelSharePasswordResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "RefreshDeviceTunnelSharePassword",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RefreshDeviceTunnelSharePasswordResponse>(await this.callApi(params, req, runtime), new RefreshDeviceTunnelSharePasswordResponse({}));
  }

  async refreshDeviceTunnelSharePassword(request: RefreshDeviceTunnelSharePasswordRequest): Promise<RefreshDeviceTunnelSharePasswordResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.refreshDeviceTunnelSharePasswordWithOptions(request, runtime);
  }

  async refreshStudioAppTokenOpenWithOptions(request: RefreshStudioAppTokenOpenRequest, runtime: $Util.RuntimeOptions): Promise<RefreshStudioAppTokenOpenResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appId)) {
      body["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      body["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "RefreshStudioAppTokenOpen",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RefreshStudioAppTokenOpenResponse>(await this.callApi(params, req, runtime), new RefreshStudioAppTokenOpenResponse({}));
  }

  async refreshStudioAppTokenOpen(request: RefreshStudioAppTokenOpenRequest): Promise<RefreshStudioAppTokenOpenResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.refreshStudioAppTokenOpenWithOptions(request, runtime);
  }

  /**
    * If you call this operation to register a device under a product, the device is added to the product in the IoT Platform console. After the device is registered, IoT Platform issues the IotId parameter to the device. This parameter is a globally unique identifier (GUID) of the device. To perform operations on a device, you must use the IotId parameter to identify the device.
    * You can also use a combination of the ProductKey and DeviceName parameters to identify a device. A ProductKey is issued by IoT Platform to a product when you create the product. A DeviceName is specified or randomly generated when you create a device. The IotId parameter has a higher priority than a combination of the ProductKey and DeviceName parameters.
    * For information about how to register multiple devices under a product at the same time, see [BatchRegisterDeviceWithApplyId](~~69514~~).
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 30 queries per second (QPS). 
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request RegisterDeviceRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return RegisterDeviceResponse
   */
  async registerDeviceWithOptions(request: RegisterDeviceRequest, runtime: $Util.RuntimeOptions): Promise<RegisterDeviceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appKey)) {
      query["AppKey"] = request.appKey;
    }

    if (!Util.isUnset(request.devEui)) {
      query["DevEui"] = request.devEui;
    }

    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.joinEui)) {
      query["JoinEui"] = request.joinEui;
    }

    if (!Util.isUnset(request.loraNodeType)) {
      query["LoraNodeType"] = request.loraNodeType;
    }

    if (!Util.isUnset(request.nickname)) {
      query["Nickname"] = request.nickname;
    }

    if (!Util.isUnset(request.pinCode)) {
      query["PinCode"] = request.pinCode;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "RegisterDevice",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RegisterDeviceResponse>(await this.callApi(params, req, runtime), new RegisterDeviceResponse({}));
  }

  /**
    * If you call this operation to register a device under a product, the device is added to the product in the IoT Platform console. After the device is registered, IoT Platform issues the IotId parameter to the device. This parameter is a globally unique identifier (GUID) of the device. To perform operations on a device, you must use the IotId parameter to identify the device.
    * You can also use a combination of the ProductKey and DeviceName parameters to identify a device. A ProductKey is issued by IoT Platform to a product when you create the product. A DeviceName is specified or randomly generated when you create a device. The IotId parameter has a higher priority than a combination of the ProductKey and DeviceName parameters.
    * For information about how to register multiple devices under a product at the same time, see [BatchRegisterDeviceWithApplyId](~~69514~~).
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 30 queries per second (QPS). 
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request RegisterDeviceRequest
    * @return RegisterDeviceResponse
   */
  async registerDevice(request: RegisterDeviceRequest): Promise<RegisterDeviceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.registerDeviceWithOptions(request, runtime);
  }

  async releaseEdgeDriverVersionWithOptions(request: ReleaseEdgeDriverVersionRequest, runtime: $Util.RuntimeOptions): Promise<ReleaseEdgeDriverVersionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.driverId)) {
      query["DriverId"] = request.driverId;
    }

    if (!Util.isUnset(request.driverVersion)) {
      query["DriverVersion"] = request.driverVersion;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ReleaseEdgeDriverVersion",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ReleaseEdgeDriverVersionResponse>(await this.callApi(params, req, runtime), new ReleaseEdgeDriverVersionResponse({}));
  }

  async releaseEdgeDriverVersion(request: ReleaseEdgeDriverVersionRequest): Promise<ReleaseEdgeDriverVersionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.releaseEdgeDriverVersionWithOptions(request, runtime);
  }

  /**
    * *   After a product is published, you cannot call the [CreateThingModel](~~150323~~), [UpdateThingModel](~~151240~~), [ImportThingModelTSL](~~150320~~), [PublishThingModel](~~150311~~), [DeleteThingModel](~~150312~~), or [CopyThingModel](~~150322~~) operation to edit the Thing Specification Language (TSL) model of the product. To edit the TSL model, you must call the [CancelReleaseProduct](~~213875~~) operation to unpublish the product.
    * *   Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
    * > RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request ReleaseProductRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return ReleaseProductResponse
   */
  async releaseProductWithOptions(request: ReleaseProductRequest, runtime: $Util.RuntimeOptions): Promise<ReleaseProductResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ReleaseProduct",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ReleaseProductResponse>(await this.callApi(params, req, runtime), new ReleaseProductResponse({}));
  }

  /**
    * *   After a product is published, you cannot call the [CreateThingModel](~~150323~~), [UpdateThingModel](~~151240~~), [ImportThingModelTSL](~~150320~~), [PublishThingModel](~~150311~~), [DeleteThingModel](~~150312~~), or [CopyThingModel](~~150322~~) operation to edit the Thing Specification Language (TSL) model of the product. To edit the TSL model, you must call the [CancelReleaseProduct](~~213875~~) operation to unpublish the product.
    * *   Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
    * > RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request ReleaseProductRequest
    * @return ReleaseProductResponse
   */
  async releaseProduct(request: ReleaseProductRequest): Promise<ReleaseProductResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.releaseProductWithOptions(request, runtime);
  }

  /**
    * *   If you specify a gateway, this operation removes the topological relationships between the gateway and all attached sub-devices.
    * *   If you specify a sub-device, this operation removes the topological relationship between the sub-device and the gateway to which the sub-device is attached.
    * # QPS limits
    * Each Alibaba Cloud account can run up to 500 queries per second (QPS). 
    * >  The RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request RemoveThingTopoRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return RemoveThingTopoResponse
   */
  async removeThingTopoWithOptions(request: RemoveThingTopoRequest, runtime: $Util.RuntimeOptions): Promise<RemoveThingTopoResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotId)) {
      query["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "RemoveThingTopo",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RemoveThingTopoResponse>(await this.callApi(params, req, runtime), new RemoveThingTopoResponse({}));
  }

  /**
    * *   If you specify a gateway, this operation removes the topological relationships between the gateway and all attached sub-devices.
    * *   If you specify a sub-device, this operation removes the topological relationship between the sub-device and the gateway to which the sub-device is attached.
    * # QPS limits
    * Each Alibaba Cloud account can run up to 500 queries per second (QPS). 
    * >  The RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request RemoveThingTopoRequest
    * @return RemoveThingTopoResponse
   */
  async removeThingTopo(request: RemoveThingTopoRequest): Promise<RemoveThingTopoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.removeThingTopoWithOptions(request, runtime);
  }

  async replaceEdgeInstanceGatewayWithOptions(request: ReplaceEdgeInstanceGatewayRequest, runtime: $Util.RuntimeOptions): Promise<ReplaceEdgeInstanceGatewayResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentGatewayId)) {
      query["CurrentGatewayId"] = request.currentGatewayId;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.newGatewayId)) {
      query["NewGatewayId"] = request.newGatewayId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ReplaceEdgeInstanceGateway",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ReplaceEdgeInstanceGatewayResponse>(await this.callApi(params, req, runtime), new ReplaceEdgeInstanceGatewayResponse({}));
  }

  async replaceEdgeInstanceGateway(request: ReplaceEdgeInstanceGatewayRequest): Promise<ReplaceEdgeInstanceGatewayResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.replaceEdgeInstanceGatewayWithOptions(request, runtime);
  }

  async rerunJobWithOptions(request: RerunJobRequest, runtime: $Util.RuntimeOptions): Promise<RerunJobResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.jobId)) {
      query["JobId"] = request.jobId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "RerunJob",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RerunJobResponse>(await this.callApi(params, req, runtime), new RerunJobResponse({}));
  }

  async rerunJob(request: RerunJobRequest): Promise<RerunJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.rerunJobWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request ResetConsumerGroupPositionRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return ResetConsumerGroupPositionResponse
   */
  async resetConsumerGroupPositionWithOptions(request: ResetConsumerGroupPositionRequest, runtime: $Util.RuntimeOptions): Promise<ResetConsumerGroupPositionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ResetConsumerGroupPosition",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ResetConsumerGroupPositionResponse>(await this.callApi(params, req, runtime), new ResetConsumerGroupPositionResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request ResetConsumerGroupPositionRequest
    * @return ResetConsumerGroupPositionResponse
   */
  async resetConsumerGroupPosition(request: ResetConsumerGroupPositionRequest): Promise<ResetConsumerGroupPositionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.resetConsumerGroupPositionWithOptions(request, runtime);
  }

  /**
    * *   After you use dynamic registration to obtain the device certificate information of a directly connected device and activate the device, you can call this operation to reset the dynamic registration status of the status to unregistered in the IoT Platform console. Then, you can use dynamic registration again to obtain the device certificate information. The device certificate information includes ProductKey, DeviceName, and DeviceSecret.
    * > This operation is called to reset the dynamic registration status instead of activation status of a device. After you call the operation to reset the dynamic registration status of a device, the status of the device in the IoT Platform console is not reset to inactive.
    * *   If you specify a gateway and the number of sub-devices that belong to the gateway exceeds 2,000, you can call this operation to create a device job to delete the topological relationships in an asynchronous manner. The operation returns the **JobId** parameter.
    * ## QPS limits
    * Each Alibaba Cloud account can run up to 500 queries per second (QPS). 
    * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
    *
    * @param request ResetThingRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return ResetThingResponse
   */
  async resetThingWithOptions(request: ResetThingRequest, runtime: $Util.RuntimeOptions): Promise<ResetThingResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotId)) {
      query["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ResetThing",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ResetThingResponse>(await this.callApi(params, req, runtime), new ResetThingResponse({}));
  }

  /**
    * *   After you use dynamic registration to obtain the device certificate information of a directly connected device and activate the device, you can call this operation to reset the dynamic registration status of the status to unregistered in the IoT Platform console. Then, you can use dynamic registration again to obtain the device certificate information. The device certificate information includes ProductKey, DeviceName, and DeviceSecret.
    * > This operation is called to reset the dynamic registration status instead of activation status of a device. After you call the operation to reset the dynamic registration status of a device, the status of the device in the IoT Platform console is not reset to inactive.
    * *   If you specify a gateway and the number of sub-devices that belong to the gateway exceeds 2,000, you can call this operation to create a device job to delete the topological relationships in an asynchronous manner. The operation returns the **JobId** parameter.
    * ## QPS limits
    * Each Alibaba Cloud account can run up to 500 queries per second (QPS). 
    * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
    *
    * @param request ResetThingRequest
    * @return ResetThingResponse
   */
  async resetThing(request: ResetThingRequest): Promise<ResetThingResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.resetThingWithOptions(request, runtime);
  }

  async retrySoundCodeLabelBatchWithOptions(request: RetrySoundCodeLabelBatchRequest, runtime: $Util.RuntimeOptions): Promise<RetrySoundCodeLabelBatchResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.batchCode)) {
      body["BatchCode"] = request.batchCode;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      body["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "RetrySoundCodeLabelBatch",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RetrySoundCodeLabelBatchResponse>(await this.callApi(params, req, runtime), new RetrySoundCodeLabelBatchResponse({}));
  }

  async retrySoundCodeLabelBatch(request: RetrySoundCodeLabelBatchRequest): Promise<RetrySoundCodeLabelBatchResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.retrySoundCodeLabelBatchWithOptions(request, runtime);
  }

  /**
    * If the update task requires confirmation, you must make sure that it has been confirmed before you call this operation. You can call the [ConfirmOTATask](~~254666~~) operation to confirm update tasks.
    * ## QPS limits
    * Each Alibaba Cloud account can run a maximum of 20 queries per second (QPS). 
    * >  The Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request ReupgradeOTATaskRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return ReupgradeOTATaskResponse
   */
  async reupgradeOTATaskWithOptions(request: ReupgradeOTATaskRequest, runtime: $Util.RuntimeOptions): Promise<ReupgradeOTATaskResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.jobId)) {
      query["JobId"] = request.jobId;
    }

    if (!Util.isUnset(request.taskId)) {
      query["TaskId"] = request.taskId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ReupgradeOTATask",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ReupgradeOTATaskResponse>(await this.callApi(params, req, runtime), new ReupgradeOTATaskResponse({}));
  }

  /**
    * If the update task requires confirmation, you must make sure that it has been confirmed before you call this operation. You can call the [ConfirmOTATask](~~254666~~) operation to confirm update tasks.
    * ## QPS limits
    * Each Alibaba Cloud account can run a maximum of 20 queries per second (QPS). 
    * >  The Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request ReupgradeOTATaskRequest
    * @return ReupgradeOTATaskResponse
   */
  async reupgradeOTATask(request: ReupgradeOTATaskRequest): Promise<ReupgradeOTATaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.reupgradeOTATaskWithOptions(request, runtime);
  }

  /**
    * *   A device can have a maximum of 100 tags.
    * *   You can modify or add a maximum of 100 tags at a time.
    * ## QPS limits
    * Each Alibaba Cloud account can run up to 50 queries per second (QPS). 
    * >  The Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request SaveDevicePropRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return SaveDevicePropResponse
   */
  async saveDevicePropWithOptions(request: SaveDevicePropRequest, runtime: $Util.RuntimeOptions): Promise<SaveDevicePropResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotId)) {
      query["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.props)) {
      query["Props"] = request.props;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SaveDeviceProp",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SaveDevicePropResponse>(await this.callApi(params, req, runtime), new SaveDevicePropResponse({}));
  }

  /**
    * *   A device can have a maximum of 100 tags.
    * *   You can modify or add a maximum of 100 tags at a time.
    * ## QPS limits
    * Each Alibaba Cloud account can run up to 50 queries per second (QPS). 
    * >  The Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request SaveDevicePropRequest
    * @return SaveDevicePropResponse
   */
  async saveDeviceProp(request: SaveDevicePropRequest): Promise<SaveDevicePropResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.saveDevicePropWithOptions(request, runtime);
  }

  async saveScriptWithOptions(request: SaveScriptRequest, runtime: $Util.RuntimeOptions): Promise<SaveScriptResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.parserId)) {
      query["ParserId"] = request.parserId;
    }

    if (!Util.isUnset(request.scriptDraft)) {
      query["ScriptDraft"] = request.scriptDraft;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SaveScript",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SaveScriptResponse>(await this.callApi(params, req, runtime), new SaveScriptResponse({}));
  }

  async saveScript(request: SaveScriptRequest): Promise<SaveScriptResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.saveScriptWithOptions(request, runtime);
  }

  /**
    * *   You cannot query the desired values of read-only properties.
    * *   You can specify up to 10 desired property values in a call.
    * *   After a device is created, the value of the **Version** parameter is 0. If you want to configure the **Version** parameter the first time you specify a desired property value, set the **Version** parameter to 0.
    * > If the Thing Specification Language (TSL) data is of the float or double type, the parameter values that correspond to the TSL data contain at least one decimal place. Examples: 10.0 and 11.1.
    * ## QPS limits
    * Each Alibaba Cloud account can run up to 50 queries per second (QPS). 
    * >  The RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request SetDeviceDesiredPropertyRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return SetDeviceDesiredPropertyResponse
   */
  async setDeviceDesiredPropertyWithOptions(request: SetDeviceDesiredPropertyRequest, runtime: $Util.RuntimeOptions): Promise<SetDeviceDesiredPropertyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotId)) {
      query["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.items)) {
      query["Items"] = request.items;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.versions)) {
      query["Versions"] = request.versions;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SetDeviceDesiredProperty",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SetDeviceDesiredPropertyResponse>(await this.callApi(params, req, runtime), new SetDeviceDesiredPropertyResponse({}));
  }

  /**
    * *   You cannot query the desired values of read-only properties.
    * *   You can specify up to 10 desired property values in a call.
    * *   After a device is created, the value of the **Version** parameter is 0. If you want to configure the **Version** parameter the first time you specify a desired property value, set the **Version** parameter to 0.
    * > If the Thing Specification Language (TSL) data is of the float or double type, the parameter values that correspond to the TSL data contain at least one decimal place. Examples: 10.0 and 11.1.
    * ## QPS limits
    * Each Alibaba Cloud account can run up to 50 queries per second (QPS). 
    * >  The RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request SetDeviceDesiredPropertyRequest
    * @return SetDeviceDesiredPropertyResponse
   */
  async setDeviceDesiredProperty(request: SetDeviceDesiredPropertyRequest): Promise<SetDeviceDesiredPropertyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setDeviceDesiredPropertyWithOptions(request, runtime);
  }

  /**
    * A device group can have a maximum of 100 tags.
    * ## QPS limits
    * Each Alibaba Cloud account can run up to 50 queries per second (QPS). 
    * >  The Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request SetDeviceGroupTagsRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return SetDeviceGroupTagsResponse
   */
  async setDeviceGroupTagsWithOptions(request: SetDeviceGroupTagsRequest, runtime: $Util.RuntimeOptions): Promise<SetDeviceGroupTagsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.groupType)) {
      query["GroupType"] = request.groupType;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.tagString)) {
      query["TagString"] = request.tagString;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SetDeviceGroupTags",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SetDeviceGroupTagsResponse>(await this.callApi(params, req, runtime), new SetDeviceGroupTagsResponse({}));
  }

  /**
    * A device group can have a maximum of 100 tags.
    * ## QPS limits
    * Each Alibaba Cloud account can run up to 50 queries per second (QPS). 
    * >  The Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request SetDeviceGroupTagsRequest
    * @return SetDeviceGroupTagsResponse
   */
  async setDeviceGroupTags(request: SetDeviceGroupTagsRequest): Promise<SetDeviceGroupTagsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setDeviceGroupTagsWithOptions(request, runtime);
  }

  /**
    * After IoT Platform sends a request to configure device properties, the device receives and processes the request in an asynchronous manner. When you call this operation, a successful response indicates that IoT Platform sent a request. The response does not indicate that the device received and processed the request. After the device SDK responds to the request, the device properties are configured.
    * > If the Thing Specification Language (TSL) data is of the float or double type, the parameter values that correspond to the TSL data contain at least one decimal place. Examples: 10.0 and 11.1.
    * ## QPS limits
    * Each Alibaba Cloud account can run up to 500 queries per second (QPS). 
    * >  The RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request SetDevicePropertyRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return SetDevicePropertyResponse
   */
  async setDevicePropertyWithOptions(request: SetDevicePropertyRequest, runtime: $Util.RuntimeOptions): Promise<SetDevicePropertyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotId)) {
      query["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.items)) {
      query["Items"] = request.items;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SetDeviceProperty",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SetDevicePropertyResponse>(await this.callApi(params, req, runtime), new SetDevicePropertyResponse({}));
  }

  /**
    * After IoT Platform sends a request to configure device properties, the device receives and processes the request in an asynchronous manner. When you call this operation, a successful response indicates that IoT Platform sent a request. The response does not indicate that the device received and processed the request. After the device SDK responds to the request, the device properties are configured.
    * > If the Thing Specification Language (TSL) data is of the float or double type, the parameter values that correspond to the TSL data contain at least one decimal place. Examples: 10.0 and 11.1.
    * ## QPS limits
    * Each Alibaba Cloud account can run up to 500 queries per second (QPS). 
    * >  The RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request SetDevicePropertyRequest
    * @return SetDevicePropertyResponse
   */
  async setDeviceProperty(request: SetDevicePropertyRequest): Promise<SetDevicePropertyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setDevicePropertyWithOptions(request, runtime);
  }

  /**
    * If the Thing Specification Language (TSL) data is of the float or double type, the parameter values that correspond to the TSL data contain at least one decimal place. Examples: 10.0 and 11.1.
    * ## QPS limits
    * Each Alibaba Cloud account can run up to 10 queries per second (QPS). 
    * >  The RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request SetDevicesPropertyRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return SetDevicesPropertyResponse
   */
  async setDevicesPropertyWithOptions(request: SetDevicesPropertyRequest, runtime: $Util.RuntimeOptions): Promise<SetDevicesPropertyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.items)) {
      query["Items"] = request.items;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SetDevicesProperty",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SetDevicesPropertyResponse>(await this.callApi(params, req, runtime), new SetDevicesPropertyResponse({}));
  }

  /**
    * If the Thing Specification Language (TSL) data is of the float or double type, the parameter values that correspond to the TSL data contain at least one decimal place. Examples: 10.0 and 11.1.
    * ## QPS limits
    * Each Alibaba Cloud account can run up to 10 queries per second (QPS). 
    * >  The RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request SetDevicesPropertyRequest
    * @return SetDevicesPropertyResponse
   */
  async setDevicesProperty(request: SetDevicesPropertyRequest): Promise<SetDevicesPropertyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setDevicesPropertyWithOptions(request, runtime);
  }

  async setEdgeInstanceDriverConfigsWithOptions(request: SetEdgeInstanceDriverConfigsRequest, runtime: $Util.RuntimeOptions): Promise<SetEdgeInstanceDriverConfigsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.configs)) {
      query["Configs"] = request.configs;
    }

    if (!Util.isUnset(request.driverId)) {
      query["DriverId"] = request.driverId;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SetEdgeInstanceDriverConfigs",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SetEdgeInstanceDriverConfigsResponse>(await this.callApi(params, req, runtime), new SetEdgeInstanceDriverConfigsResponse({}));
  }

  async setEdgeInstanceDriverConfigs(request: SetEdgeInstanceDriverConfigsRequest): Promise<SetEdgeInstanceDriverConfigsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setEdgeInstanceDriverConfigsWithOptions(request, runtime);
  }

  async setProductCertInfoWithOptions(request: SetProductCertInfoRequest, runtime: $Util.RuntimeOptions): Promise<SetProductCertInfoResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.issueModel)) {
      query["IssueModel"] = request.issueModel;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SetProductCertInfo",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SetProductCertInfoResponse>(await this.callApi(params, req, runtime), new SetProductCertInfoResponse({}));
  }

  async setProductCertInfo(request: SetProductCertInfoRequest): Promise<SetProductCertInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setProductCertInfoWithOptions(request, runtime);
  }

  async setStudioProjectCooperationWithOptions(request: SetStudioProjectCooperationRequest, runtime: $Util.RuntimeOptions): Promise<SetStudioProjectCooperationResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      body["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.status)) {
      body["Status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "SetStudioProjectCooperation",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SetStudioProjectCooperationResponse>(await this.callApi(params, req, runtime), new SetStudioProjectCooperationResponse({}));
  }

  async setStudioProjectCooperation(request: SetStudioProjectCooperationRequest): Promise<SetStudioProjectCooperationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setStudioProjectCooperationWithOptions(request, runtime);
  }

  async setupStudioAppAuthModeOpenWithOptions(request: SetupStudioAppAuthModeOpenRequest, runtime: $Util.RuntimeOptions): Promise<SetupStudioAppAuthModeOpenResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appId)) {
      body["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.authMode)) {
      body["AuthMode"] = request.authMode;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      body["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "SetupStudioAppAuthModeOpen",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SetupStudioAppAuthModeOpenResponse>(await this.callApi(params, req, runtime), new SetupStudioAppAuthModeOpenResponse({}));
  }

  async setupStudioAppAuthModeOpen(request: SetupStudioAppAuthModeOpenRequest): Promise<SetupStudioAppAuthModeOpenResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setupStudioAppAuthModeOpenWithOptions(request, runtime);
  }

  async shareSpeechByCombinationWithOptions(request: ShareSpeechByCombinationRequest, runtime: $Util.RuntimeOptions): Promise<ShareSpeechByCombinationResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.audioFormat)) {
      body["AudioFormat"] = request.audioFormat;
    }

    if (!Util.isUnset(request.combinationList)) {
      body["CombinationList"] = request.combinationList;
    }

    if (!Util.isUnset(request.deviceName)) {
      body["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotId)) {
      body["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      body["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      body["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.speechId)) {
      body["SpeechId"] = request.speechId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ShareSpeechByCombination",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ShareSpeechByCombinationResponse>(await this.callApi(params, req, runtime), new ShareSpeechByCombinationResponse({}));
  }

  async shareSpeechByCombination(request: ShareSpeechByCombinationRequest): Promise<ShareSpeechByCombinationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.shareSpeechByCombinationWithOptions(request, runtime);
  }

  async speechByCombinationWithOptions(request: SpeechByCombinationRequest, runtime: $Util.RuntimeOptions): Promise<SpeechByCombinationResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.audioFormat)) {
      body["AudioFormat"] = request.audioFormat;
    }

    if (!Util.isUnset(request.combinationList)) {
      body["CombinationList"] = request.combinationList;
    }

    if (!Util.isUnset(request.deviceName)) {
      body["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.enforceFlag)) {
      body["EnforceFlag"] = request.enforceFlag;
    }

    if (!Util.isUnset(request.iotId)) {
      body["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      body["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      body["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.speechId)) {
      body["SpeechId"] = request.speechId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "SpeechByCombination",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SpeechByCombinationResponse>(await this.callApi(params, req, runtime), new SpeechByCombinationResponse({}));
  }

  async speechByCombination(request: SpeechByCombinationRequest): Promise<SpeechByCombinationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.speechByCombinationWithOptions(request, runtime);
  }

  async speechBySynthesisWithOptions(request: SpeechBySynthesisRequest, runtime: $Util.RuntimeOptions): Promise<SpeechBySynthesisResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.audioFormat)) {
      body["AudioFormat"] = request.audioFormat;
    }

    if (!Util.isUnset(request.deviceName)) {
      body["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotId)) {
      body["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      body["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      body["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.speechId)) {
      body["SpeechId"] = request.speechId;
    }

    if (!Util.isUnset(request.speechRate)) {
      body["SpeechRate"] = request.speechRate;
    }

    if (!Util.isUnset(request.text)) {
      body["Text"] = request.text;
    }

    if (!Util.isUnset(request.voice)) {
      body["Voice"] = request.voice;
    }

    if (!Util.isUnset(request.volume)) {
      body["Volume"] = request.volume;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "SpeechBySynthesis",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SpeechBySynthesisResponse>(await this.callApi(params, req, runtime), new SpeechBySynthesisResponse({}));
  }

  async speechBySynthesis(request: SpeechBySynthesisRequest): Promise<SpeechBySynthesisResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.speechBySynthesisWithOptions(request, runtime);
  }

  async startParserWithOptions(request: StartParserRequest, runtime: $Util.RuntimeOptions): Promise<StartParserResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.parserId)) {
      query["ParserId"] = request.parserId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "StartParser",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<StartParserResponse>(await this.callApi(params, req, runtime), new StartParserResponse({}));
  }

  async startParser(request: StartParserRequest): Promise<StartParserResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.startParserWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * *   You must verify that the rule has SQL statements configured before you start the rule. If you do not set an SQL statement when you create the rule, call the [UpdateRule](~~69513~~) operation to add an SQL statement and update the rule.
    * *   Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
    * > RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request StartRuleRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return StartRuleResponse
   */
  async startRuleWithOptions(request: StartRuleRequest, runtime: $Util.RuntimeOptions): Promise<StartRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.ruleId)) {
      query["RuleId"] = request.ruleId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "StartRule",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<StartRuleResponse>(await this.callApi(params, req, runtime), new StartRuleResponse({}));
  }

  /**
    * ## Limits
    * *   You must verify that the rule has SQL statements configured before you start the rule. If you do not set an SQL statement when you create the rule, call the [UpdateRule](~~69513~~) operation to add an SQL statement and update the rule.
    * *   Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
    * > RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request StartRuleRequest
    * @return StartRuleResponse
   */
  async startRule(request: StartRuleRequest): Promise<StartRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.startRuleWithOptions(request, runtime);
  }

  async stopParserWithOptions(request: StopParserRequest, runtime: $Util.RuntimeOptions): Promise<StopParserResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.parserId)) {
      query["ParserId"] = request.parserId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "StopParser",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<StopParserResponse>(await this.callApi(params, req, runtime), new StopParserResponse({}));
  }

  async stopParser(request: StopParserRequest): Promise<StopParserResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.stopParserWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request StopRuleRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return StopRuleResponse
   */
  async stopRuleWithOptions(request: StopRuleRequest, runtime: $Util.RuntimeOptions): Promise<StopRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.ruleId)) {
      query["RuleId"] = request.ruleId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "StopRule",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<StopRuleResponse>(await this.callApi(params, req, runtime), new StopRuleResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request StopRuleRequest
    * @return StopRuleResponse
   */
  async stopRule(request: StopRuleRequest): Promise<StopRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.stopRuleWithOptions(request, runtime);
  }

  /**
    * *   The device that needs to subscribe to topics must be connected to IoT Platform and online.
    * *   You can call this operation to subscribe to the topics of a specified device. You can specify a maximum of 10 topics in a single call.
    * ## QPS limits
    * Each Alibaba Cloud account can run up to 10 queries per second (QPS). 
    * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
    *
    * @param request SubscribeTopicRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return SubscribeTopicResponse
   */
  async subscribeTopicWithOptions(request: SubscribeTopicRequest, runtime: $Util.RuntimeOptions): Promise<SubscribeTopicResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.topic)) {
      query["Topic"] = request.topic;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SubscribeTopic",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SubscribeTopicResponse>(await this.callApi(params, req, runtime), new SubscribeTopicResponse({}));
  }

  /**
    * *   The device that needs to subscribe to topics must be connected to IoT Platform and online.
    * *   You can call this operation to subscribe to the topics of a specified device. You can specify a maximum of 10 topics in a single call.
    * ## QPS limits
    * Each Alibaba Cloud account can run up to 10 queries per second (QPS). 
    * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
    *
    * @param request SubscribeTopicRequest
    * @return SubscribeTopicResponse
   */
  async subscribeTopic(request: SubscribeTopicRequest): Promise<SubscribeTopicResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.subscribeTopicWithOptions(request, runtime);
  }

  async syncSpeechByCombinationWithOptions(request: SyncSpeechByCombinationRequest, runtime: $Util.RuntimeOptions): Promise<SyncSpeechByCombinationResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.audioFormat)) {
      body["AudioFormat"] = request.audioFormat;
    }

    if (!Util.isUnset(request.combinationList)) {
      body["CombinationList"] = request.combinationList;
    }

    if (!Util.isUnset(request.deviceName)) {
      body["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.enforceFlag)) {
      body["EnforceFlag"] = request.enforceFlag;
    }

    if (!Util.isUnset(request.iotId)) {
      body["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      body["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      body["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.speechId)) {
      body["SpeechId"] = request.speechId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "SyncSpeechByCombination",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SyncSpeechByCombinationResponse>(await this.callApi(params, req, runtime), new SyncSpeechByCombinationResponse({}));
  }

  async syncSpeechByCombination(request: SyncSpeechByCombinationRequest): Promise<SyncSpeechByCombinationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.syncSpeechByCombinationWithOptions(request, runtime);
  }

  async testSpeechWithOptions(tmpReq: TestSpeechRequest, runtime: $Util.RuntimeOptions): Promise<TestSpeechResponse> {
    Util.validateModel(tmpReq);
    let request = new TestSpeechShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.soundCodeConfig)) {
      request.soundCodeConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.soundCodeConfig, "SoundCodeConfig", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.audioFormat)) {
      body["AudioFormat"] = request.audioFormat;
    }

    if (!Util.isUnset(request.enableSoundCode)) {
      body["EnableSoundCode"] = request.enableSoundCode;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      body["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.projectCode)) {
      body["ProjectCode"] = request.projectCode;
    }

    if (!Util.isUnset(request.soundCodeConfigShrink)) {
      body["SoundCodeConfig"] = request.soundCodeConfigShrink;
    }

    if (!Util.isUnset(request.speechRate)) {
      body["SpeechRate"] = request.speechRate;
    }

    if (!Util.isUnset(request.speechType)) {
      body["SpeechType"] = request.speechType;
    }

    if (!Util.isUnset(request.text)) {
      body["Text"] = request.text;
    }

    if (!Util.isUnset(request.voice)) {
      body["Voice"] = request.voice;
    }

    if (!Util.isUnset(request.volume)) {
      body["Volume"] = request.volume;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "TestSpeech",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<TestSpeechResponse>(await this.callApi(params, req, runtime), new TestSpeechResponse({}));
  }

  async testSpeech(request: TestSpeechRequest): Promise<TestSpeechResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.testSpeechWithOptions(request, runtime);
  }

  async testSwitchWithOptions(request: TestSwitchRequest, runtime: $Util.RuntimeOptions): Promise<TestSwitchResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "TestSwitch",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<TestSwitchResponse>(await this.callApi(params, req, runtime), new TestSwitchResponse({}));
  }

  async testSwitch(request: TestSwitchRequest): Promise<TestSwitchResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.testSwitchWithOptions(request, runtime);
  }

  /**
    * You can call the [QueryClientIds](~~371985~~) operation to view the ClientIDs of a device.
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS). 
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request TransformClientIdRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return TransformClientIdResponse
   */
  async transformClientIdWithOptions(request: TransformClientIdRequest, runtime: $Util.RuntimeOptions): Promise<TransformClientIdResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clientId)) {
      query["ClientId"] = request.clientId;
    }

    if (!Util.isUnset(request.iotId)) {
      query["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "TransformClientId",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<TransformClientIdResponse>(await this.callApi(params, req, runtime), new TransformClientIdResponse({}));
  }

  /**
    * You can call the [QueryClientIds](~~371985~~) operation to view the ClientIDs of a device.
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS). 
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request TransformClientIdRequest
    * @return TransformClientIdResponse
   */
  async transformClientId(request: TransformClientIdRequest): Promise<TransformClientIdResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.transformClientIdWithOptions(request, runtime);
  }

  async triggerSceneRuleWithOptions(request: TriggerSceneRuleRequest, runtime: $Util.RuntimeOptions): Promise<TriggerSceneRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.ruleId)) {
      query["RuleId"] = request.ruleId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "TriggerSceneRule",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<TriggerSceneRuleResponse>(await this.callApi(params, req, runtime), new TriggerSceneRuleResponse({}));
  }

  async triggerSceneRule(request: TriggerSceneRuleRequest): Promise<TriggerSceneRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.triggerSceneRuleWithOptions(request, runtime);
  }

  async unbindApplicationFromEdgeInstanceWithOptions(request: UnbindApplicationFromEdgeInstanceRequest, runtime: $Util.RuntimeOptions): Promise<UnbindApplicationFromEdgeInstanceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.applicationId)) {
      query["ApplicationId"] = request.applicationId;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UnbindApplicationFromEdgeInstance",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UnbindApplicationFromEdgeInstanceResponse>(await this.callApi(params, req, runtime), new UnbindApplicationFromEdgeInstanceResponse({}));
  }

  async unbindApplicationFromEdgeInstance(request: UnbindApplicationFromEdgeInstanceRequest): Promise<UnbindApplicationFromEdgeInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.unbindApplicationFromEdgeInstanceWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of five queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request UnbindDriverFromEdgeInstanceRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return UnbindDriverFromEdgeInstanceResponse
   */
  async unbindDriverFromEdgeInstanceWithOptions(request: UnbindDriverFromEdgeInstanceRequest, runtime: $Util.RuntimeOptions): Promise<UnbindDriverFromEdgeInstanceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.driverId)) {
      query["DriverId"] = request.driverId;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UnbindDriverFromEdgeInstance",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UnbindDriverFromEdgeInstanceResponse>(await this.callApi(params, req, runtime), new UnbindDriverFromEdgeInstanceResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of five queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request UnbindDriverFromEdgeInstanceRequest
    * @return UnbindDriverFromEdgeInstanceResponse
   */
  async unbindDriverFromEdgeInstance(request: UnbindDriverFromEdgeInstanceRequest): Promise<UnbindDriverFromEdgeInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.unbindDriverFromEdgeInstanceWithOptions(request, runtime);
  }

  async unbindLicenseProductWithOptions(request: UnbindLicenseProductRequest, runtime: $Util.RuntimeOptions): Promise<UnbindLicenseProductResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.licenseCode)) {
      query["LicenseCode"] = request.licenseCode;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UnbindLicenseProduct",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UnbindLicenseProductResponse>(await this.callApi(params, req, runtime), new UnbindLicenseProductResponse({}));
  }

  async unbindLicenseProduct(request: UnbindLicenseProductRequest): Promise<UnbindLicenseProductResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.unbindLicenseProductWithOptions(request, runtime);
  }

  async unbindRoleFromEdgeInstanceWithOptions(request: UnbindRoleFromEdgeInstanceRequest, runtime: $Util.RuntimeOptions): Promise<UnbindRoleFromEdgeInstanceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UnbindRoleFromEdgeInstance",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UnbindRoleFromEdgeInstanceResponse>(await this.callApi(params, req, runtime), new UnbindRoleFromEdgeInstanceResponse({}));
  }

  async unbindRoleFromEdgeInstance(request: UnbindRoleFromEdgeInstanceRequest): Promise<UnbindRoleFromEdgeInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.unbindRoleFromEdgeInstanceWithOptions(request, runtime);
  }

  async unbindSceneRuleFromEdgeInstanceWithOptions(request: UnbindSceneRuleFromEdgeInstanceRequest, runtime: $Util.RuntimeOptions): Promise<UnbindSceneRuleFromEdgeInstanceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.ruleId)) {
      query["RuleId"] = request.ruleId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UnbindSceneRuleFromEdgeInstance",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UnbindSceneRuleFromEdgeInstanceResponse>(await this.callApi(params, req, runtime), new UnbindSceneRuleFromEdgeInstanceResponse({}));
  }

  async unbindSceneRuleFromEdgeInstance(request: UnbindSceneRuleFromEdgeInstanceRequest): Promise<UnbindSceneRuleFromEdgeInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.unbindSceneRuleFromEdgeInstanceWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * *   You cannot modify the default consumer group provided by IoT Platform.
    * *   Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
    * > RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request UpdateConsumerGroupRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return UpdateConsumerGroupResponse
   */
  async updateConsumerGroupWithOptions(request: UpdateConsumerGroupRequest, runtime: $Util.RuntimeOptions): Promise<UpdateConsumerGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.newGroupName)) {
      query["NewGroupName"] = request.newGroupName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateConsumerGroup",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateConsumerGroupResponse>(await this.callApi(params, req, runtime), new UpdateConsumerGroupResponse({}));
  }

  /**
    * ## Limits
    * *   You cannot modify the default consumer group provided by IoT Platform.
    * *   Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
    * > RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request UpdateConsumerGroupRequest
    * @return UpdateConsumerGroupResponse
   */
  async updateConsumerGroup(request: UpdateConsumerGroupRequest): Promise<UpdateConsumerGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateConsumerGroupWithOptions(request, runtime);
  }

  async updateDestinationWithOptions(request: UpdateDestinationRequest, runtime: $Util.RuntimeOptions): Promise<UpdateDestinationResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.configuration)) {
      query["Configuration"] = request.configuration;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.destinationId)) {
      query["DestinationId"] = request.destinationId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateDestination",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateDestinationResponse>(await this.callApi(params, req, runtime), new UpdateDestinationResponse({}));
  }

  async updateDestination(request: UpdateDestinationRequest): Promise<UpdateDestinationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateDestinationWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request UpdateDeviceGroupRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return UpdateDeviceGroupResponse
   */
  async updateDeviceGroupWithOptions(request: UpdateDeviceGroupRequest, runtime: $Util.RuntimeOptions): Promise<UpdateDeviceGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupDesc)) {
      query["GroupDesc"] = request.groupDesc;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.groupType)) {
      query["GroupType"] = request.groupType;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateDeviceGroup",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateDeviceGroupResponse>(await this.callApi(params, req, runtime), new UpdateDeviceGroupResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request UpdateDeviceGroupRequest
    * @return UpdateDeviceGroupResponse
   */
  async updateDeviceGroup(request: UpdateDeviceGroupRequest): Promise<UpdateDeviceGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateDeviceGroupWithOptions(request, runtime);
  }

  /**
    * ## QPS limits
    * You can call this API operation up to 500 times per second per account.
    * >  The RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request UpdateDeviceShadowRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return UpdateDeviceShadowResponse
   */
  async updateDeviceShadowWithOptions(request: UpdateDeviceShadowRequest, runtime: $Util.RuntimeOptions): Promise<UpdateDeviceShadowResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deltaUpdate)) {
      query["DeltaUpdate"] = request.deltaUpdate;
    }

    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.shadowMessage)) {
      query["ShadowMessage"] = request.shadowMessage;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateDeviceShadow",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateDeviceShadowResponse>(await this.callApi(params, req, runtime), new UpdateDeviceShadowResponse({}));
  }

  /**
    * ## QPS limits
    * You can call this API operation up to 500 times per second per account.
    * >  The RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request UpdateDeviceShadowRequest
    * @return UpdateDeviceShadowResponse
   */
  async updateDeviceShadow(request: UpdateDeviceShadowRequest): Promise<UpdateDeviceShadowResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateDeviceShadowWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * *   If a request parameter is not specified, the original value of the parameter will be cleared for the driver version.
    * *   You are not allowed to update a published driver version.
    * *   Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
    * >RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request UpdateEdgeDriverVersionRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return UpdateEdgeDriverVersionResponse
   */
  async updateEdgeDriverVersionWithOptions(request: UpdateEdgeDriverVersionRequest, runtime: $Util.RuntimeOptions): Promise<UpdateEdgeDriverVersionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.argument)) {
      query["Argument"] = request.argument;
    }

    if (!Util.isUnset(request.configCheckRule)) {
      query["ConfigCheckRule"] = request.configCheckRule;
    }

    if (!Util.isUnset(request.containerConfig)) {
      query["ContainerConfig"] = request.containerConfig;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.driverConfig)) {
      query["DriverConfig"] = request.driverConfig;
    }

    if (!Util.isUnset(request.driverId)) {
      query["DriverId"] = request.driverId;
    }

    if (!Util.isUnset(request.driverVersion)) {
      query["DriverVersion"] = request.driverVersion;
    }

    if (!Util.isUnset(request.edgeVersion)) {
      query["EdgeVersion"] = request.edgeVersion;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.sourceConfig)) {
      query["SourceConfig"] = request.sourceConfig;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateEdgeDriverVersion",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateEdgeDriverVersionResponse>(await this.callApi(params, req, runtime), new UpdateEdgeDriverVersionResponse({}));
  }

  /**
    * ## Limits
    * *   If a request parameter is not specified, the original value of the parameter will be cleared for the driver version.
    * *   You are not allowed to update a published driver version.
    * *   Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
    * >RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request UpdateEdgeDriverVersionRequest
    * @return UpdateEdgeDriverVersionResponse
   */
  async updateEdgeDriverVersion(request: UpdateEdgeDriverVersionRequest): Promise<UpdateEdgeDriverVersionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateEdgeDriverVersionWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of five queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request UpdateEdgeInstanceRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return UpdateEdgeInstanceResponse
   */
  async updateEdgeInstanceWithOptions(request: UpdateEdgeInstanceRequest, runtime: $Util.RuntimeOptions): Promise<UpdateEdgeInstanceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.bizEnable)) {
      query["BizEnable"] = request.bizEnable;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.spec)) {
      query["Spec"] = request.spec;
    }

    if (!Util.isUnset(request.tags)) {
      query["Tags"] = request.tags;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateEdgeInstance",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateEdgeInstanceResponse>(await this.callApi(params, req, runtime), new UpdateEdgeInstanceResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of five queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request UpdateEdgeInstanceRequest
    * @return UpdateEdgeInstanceResponse
   */
  async updateEdgeInstance(request: UpdateEdgeInstanceRequest): Promise<UpdateEdgeInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateEdgeInstanceWithOptions(request, runtime);
  }

  async updateEdgeInstanceChannelWithOptions(request: UpdateEdgeInstanceChannelRequest, runtime: $Util.RuntimeOptions): Promise<UpdateEdgeInstanceChannelResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.channelId)) {
      query["ChannelId"] = request.channelId;
    }

    if (!Util.isUnset(request.channelName)) {
      query["ChannelName"] = request.channelName;
    }

    if (!Util.isUnset(request.configs)) {
      query["Configs"] = request.configs;
    }

    if (!Util.isUnset(request.driverId)) {
      query["DriverId"] = request.driverId;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateEdgeInstanceChannel",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateEdgeInstanceChannelResponse>(await this.callApi(params, req, runtime), new UpdateEdgeInstanceChannelResponse({}));
  }

  async updateEdgeInstanceChannel(request: UpdateEdgeInstanceChannelRequest): Promise<UpdateEdgeInstanceChannelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateEdgeInstanceChannelWithOptions(request, runtime);
  }

  async updateEdgeInstanceMessageRoutingWithOptions(request: UpdateEdgeInstanceMessageRoutingRequest, runtime: $Util.RuntimeOptions): Promise<UpdateEdgeInstanceMessageRoutingResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.routeId)) {
      query["RouteId"] = request.routeId;
    }

    if (!Util.isUnset(request.sourceData)) {
      query["SourceData"] = request.sourceData;
    }

    if (!Util.isUnset(request.sourceType)) {
      query["SourceType"] = request.sourceType;
    }

    if (!Util.isUnset(request.targetData)) {
      query["TargetData"] = request.targetData;
    }

    if (!Util.isUnset(request.targetIotHubQos)) {
      query["TargetIotHubQos"] = request.targetIotHubQos;
    }

    if (!Util.isUnset(request.targetType)) {
      query["TargetType"] = request.targetType;
    }

    if (!Util.isUnset(request.topicFilter)) {
      query["TopicFilter"] = request.topicFilter;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateEdgeInstanceMessageRouting",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateEdgeInstanceMessageRoutingResponse>(await this.callApi(params, req, runtime), new UpdateEdgeInstanceMessageRoutingResponse({}));
  }

  async updateEdgeInstanceMessageRouting(request: UpdateEdgeInstanceMessageRoutingRequest): Promise<UpdateEdgeInstanceMessageRoutingResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateEdgeInstanceMessageRoutingWithOptions(request, runtime);
  }

  async updateJobWithOptions(tmpReq: UpdateJobRequest, runtime: $Util.RuntimeOptions): Promise<UpdateJobResponse> {
    Util.validateModel(tmpReq);
    let request = new UpdateJobShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.rolloutConfig)) {
      request.rolloutConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.rolloutConfig, "RolloutConfig", "json");
    }

    if (!Util.isUnset(tmpReq.timeoutConfig)) {
      request.timeoutConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.timeoutConfig, "TimeoutConfig", "json");
    }

    let query = { };
    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.jobId)) {
      query["JobId"] = request.jobId;
    }

    if (!Util.isUnset(request.rolloutConfigShrink)) {
      query["RolloutConfig"] = request.rolloutConfigShrink;
    }

    if (!Util.isUnset(request.timeoutConfigShrink)) {
      query["TimeoutConfig"] = request.timeoutConfigShrink;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateJob",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateJobResponse>(await this.callApi(params, req, runtime), new UpdateJobResponse({}));
  }

  async updateJob(request: UpdateJobRequest): Promise<UpdateJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateJobWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request UpdateOTAModuleRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return UpdateOTAModuleResponse
   */
  async updateOTAModuleWithOptions(request: UpdateOTAModuleRequest, runtime: $Util.RuntimeOptions): Promise<UpdateOTAModuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.aliasName)) {
      query["AliasName"] = request.aliasName;
    }

    if (!Util.isUnset(request.desc)) {
      query["Desc"] = request.desc;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.moduleName)) {
      query["ModuleName"] = request.moduleName;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateOTAModule",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateOTAModuleResponse>(await this.callApi(params, req, runtime), new UpdateOTAModuleResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request UpdateOTAModuleRequest
    * @return UpdateOTAModuleResponse
   */
  async updateOTAModule(request: UpdateOTAModuleRequest): Promise<UpdateOTAModuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateOTAModuleWithOptions(request, runtime);
  }

  async updateParserWithOptions(request: UpdateParserRequest, runtime: $Util.RuntimeOptions): Promise<UpdateParserResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.parserId)) {
      query["ParserId"] = request.parserId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateParser",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateParserResponse>(await this.callApi(params, req, runtime), new UpdateParserResponse({}));
  }

  async updateParser(request: UpdateParserRequest): Promise<UpdateParserResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateParserWithOptions(request, runtime);
  }

  async updateParserDataSourceWithOptions(request: UpdateParserDataSourceRequest, runtime: $Util.RuntimeOptions): Promise<UpdateParserDataSourceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dataSourceId)) {
      query["DataSourceId"] = request.dataSourceId;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateParserDataSource",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateParserDataSourceResponse>(await this.callApi(params, req, runtime), new UpdateParserDataSourceResponse({}));
  }

  async updateParserDataSource(request: UpdateParserDataSourceRequest): Promise<UpdateParserDataSourceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateParserDataSourceWithOptions(request, runtime);
  }

  /**
    * ## QPS limits
    * You can call this API operation up to 10 times per second per account.
    * >  The RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request UpdateProductRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return UpdateProductResponse
   */
  async updateProductWithOptions(request: UpdateProductRequest, runtime: $Util.RuntimeOptions): Promise<UpdateProductResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.productName)) {
      query["ProductName"] = request.productName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateProduct",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateProductResponse>(await this.callApi(params, req, runtime), new UpdateProductResponse({}));
  }

  /**
    * ## QPS limits
    * You can call this API operation up to 10 times per second per account.
    * >  The RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request UpdateProductRequest
    * @return UpdateProductResponse
   */
  async updateProduct(request: UpdateProductRequest): Promise<UpdateProductResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateProductWithOptions(request, runtime);
  }

  /**
    * ## Message deduplication rules
    * Based on the rules that you set, IoT Platform determines whether to use the rules engine or server-side subscriptions to forward property data that is submitted by devices to a specified destination.
    * The triggering conditions of rules are related by the logic AND relation. For example, if you set the PropertyValueFilter=true and PropertyTimestampFilter=true conditions, the rule to remove duplicate messages is triggered only when both of the conditions are met.
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS). 
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request UpdateProductFilterConfigRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return UpdateProductFilterConfigResponse
   */
  async updateProductFilterConfigWithOptions(request: UpdateProductFilterConfigRequest, runtime: $Util.RuntimeOptions): Promise<UpdateProductFilterConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.propertyTimestampFilter)) {
      query["PropertyTimestampFilter"] = request.propertyTimestampFilter;
    }

    if (!Util.isUnset(request.propertyValueFilter)) {
      query["PropertyValueFilter"] = request.propertyValueFilter;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateProductFilterConfig",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateProductFilterConfigResponse>(await this.callApi(params, req, runtime), new UpdateProductFilterConfigResponse({}));
  }

  /**
    * ## Message deduplication rules
    * Based on the rules that you set, IoT Platform determines whether to use the rules engine or server-side subscriptions to forward property data that is submitted by devices to a specified destination.
    * The triggering conditions of rules are related by the logic AND relation. For example, if you set the PropertyValueFilter=true and PropertyTimestampFilter=true conditions, the rule to remove duplicate messages is triggered only when both of the conditions are met.
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS). 
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request UpdateProductFilterConfigRequest
    * @return UpdateProductFilterConfigResponse
   */
  async updateProductFilterConfig(request: UpdateProductFilterConfigRequest): Promise<UpdateProductFilterConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateProductFilterConfigWithOptions(request, runtime);
  }

  /**
    * You can update a maximum of 10 tags in a single call.
    * > You must specify the tag keys and tag values. Otherwise, the call fails. For description about the tag values, see the "**Request parameters**" section of this topic.
    * ## QPS limits
    * Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS). 
    * >  The Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request UpdateProductTagsRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return UpdateProductTagsResponse
   */
  async updateProductTagsWithOptions(request: UpdateProductTagsRequest, runtime: $Util.RuntimeOptions): Promise<UpdateProductTagsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.productTag)) {
      query["ProductTag"] = request.productTag;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateProductTags",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateProductTagsResponse>(await this.callApi(params, req, runtime), new UpdateProductTagsResponse({}));
  }

  /**
    * You can update a maximum of 10 tags in a single call.
    * > You must specify the tag keys and tag values. Otherwise, the call fails. For description about the tag values, see the "**Request parameters**" section of this topic.
    * ## QPS limits
    * Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS). 
    * >  The Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request UpdateProductTagsRequest
    * @return UpdateProductTagsResponse
   */
  async updateProductTags(request: UpdateProductTagsRequest): Promise<UpdateProductTagsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateProductTagsWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request UpdateProductTopicRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return UpdateProductTopicResponse
   */
  async updateProductTopicWithOptions(request: UpdateProductTopicRequest, runtime: $Util.RuntimeOptions): Promise<UpdateProductTopicResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.codec)) {
      query["Codec"] = request.codec;
    }

    if (!Util.isUnset(request.desc)) {
      query["Desc"] = request.desc;
    }

    if (!Util.isUnset(request.enableProxySubscribe)) {
      query["EnableProxySubscribe"] = request.enableProxySubscribe;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.operation)) {
      query["Operation"] = request.operation;
    }

    if (!Util.isUnset(request.topicId)) {
      query["TopicId"] = request.topicId;
    }

    if (!Util.isUnset(request.topicShortName)) {
      query["TopicShortName"] = request.topicShortName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateProductTopic",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateProductTopicResponse>(await this.callApi(params, req, runtime), new UpdateProductTopicResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request UpdateProductTopicRequest
    * @return UpdateProductTopicResponse
   */
  async updateProductTopic(request: UpdateProductTopicRequest): Promise<UpdateProductTopicResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateProductTopicWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request UpdateRuleRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return UpdateRuleResponse
   */
  async updateRuleWithOptions(request: UpdateRuleRequest, runtime: $Util.RuntimeOptions): Promise<UpdateRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.ruleDesc)) {
      query["RuleDesc"] = request.ruleDesc;
    }

    if (!Util.isUnset(request.ruleId)) {
      query["RuleId"] = request.ruleId;
    }

    if (!Util.isUnset(request.select)) {
      query["Select"] = request.select;
    }

    if (!Util.isUnset(request.shortTopic)) {
      query["ShortTopic"] = request.shortTopic;
    }

    if (!Util.isUnset(request.topic)) {
      query["Topic"] = request.topic;
    }

    if (!Util.isUnset(request.topicType)) {
      query["TopicType"] = request.topicType;
    }

    if (!Util.isUnset(request.where)) {
      query["Where"] = request.where;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateRule",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateRuleResponse>(await this.callApi(params, req, runtime), new UpdateRuleResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request UpdateRuleRequest
    * @return UpdateRuleResponse
   */
  async updateRule(request: UpdateRuleRequest): Promise<UpdateRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateRuleWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request UpdateRuleActionRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return UpdateRuleActionResponse
   */
  async updateRuleActionWithOptions(request: UpdateRuleActionRequest, runtime: $Util.RuntimeOptions): Promise<UpdateRuleActionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.actionId)) {
      query["ActionId"] = request.actionId;
    }

    if (!Util.isUnset(request.configuration)) {
      query["Configuration"] = request.configuration;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateRuleAction",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateRuleActionResponse>(await this.callApi(params, req, runtime), new UpdateRuleActionResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request UpdateRuleActionRequest
    * @return UpdateRuleActionResponse
   */
  async updateRuleAction(request: UpdateRuleActionRequest): Promise<UpdateRuleActionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateRuleActionWithOptions(request, runtime);
  }

  async updateSceneRuleWithOptions(request: UpdateSceneRuleRequest, runtime: $Util.RuntimeOptions): Promise<UpdateSceneRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.ruleContent)) {
      query["RuleContent"] = request.ruleContent;
    }

    if (!Util.isUnset(request.ruleDescription)) {
      query["RuleDescription"] = request.ruleDescription;
    }

    if (!Util.isUnset(request.ruleId)) {
      query["RuleId"] = request.ruleId;
    }

    if (!Util.isUnset(request.ruleName)) {
      query["RuleName"] = request.ruleName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateSceneRule",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateSceneRuleResponse>(await this.callApi(params, req, runtime), new UpdateSceneRuleResponse({}));
  }

  async updateSceneRule(request: UpdateSceneRuleRequest): Promise<UpdateSceneRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateSceneRuleWithOptions(request, runtime);
  }

  async updateSchedulePeriodWithOptions(request: UpdateSchedulePeriodRequest, runtime: $Util.RuntimeOptions): Promise<UpdateSchedulePeriodResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.description)) {
      body["Description"] = request.description;
    }

    if (!Util.isUnset(request.endTime)) {
      body["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      body["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.periodCode)) {
      body["PeriodCode"] = request.periodCode;
    }

    if (!Util.isUnset(request.soundCodeContent)) {
      body["SoundCodeContent"] = request.soundCodeContent;
    }

    if (!Util.isUnset(request.startTime)) {
      body["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateSchedulePeriod",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateSchedulePeriodResponse>(await this.callApi(params, req, runtime), new UpdateSchedulePeriodResponse({}));
  }

  async updateSchedulePeriod(request: UpdateSchedulePeriodRequest): Promise<UpdateSchedulePeriodResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateSchedulePeriodWithOptions(request, runtime);
  }

  async updateSoundCodeWithOptions(request: UpdateSoundCodeRequest, runtime: $Util.RuntimeOptions): Promise<UpdateSoundCodeResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.duration)) {
      body["Duration"] = request.duration;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      body["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.name)) {
      body["Name"] = request.name;
    }

    if (!Util.isUnset(request.soundCode)) {
      body["SoundCode"] = request.soundCode;
    }

    if (!Util.isUnset(request.soundCodeContent)) {
      body["SoundCodeContent"] = request.soundCodeContent;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateSoundCode",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateSoundCodeResponse>(await this.callApi(params, req, runtime), new UpdateSoundCodeResponse({}));
  }

  async updateSoundCode(request: UpdateSoundCodeRequest): Promise<UpdateSoundCodeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateSoundCodeWithOptions(request, runtime);
  }

  async updateSoundCodeLabelWithOptions(request: UpdateSoundCodeLabelRequest, runtime: $Util.RuntimeOptions): Promise<UpdateSoundCodeLabelResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      body["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.label)) {
      body["Label"] = request.label;
    }

    if (!Util.isUnset(request.soundCode)) {
      body["SoundCode"] = request.soundCode;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateSoundCodeLabel",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateSoundCodeLabelResponse>(await this.callApi(params, req, runtime), new UpdateSoundCodeLabelResponse({}));
  }

  async updateSoundCodeLabel(request: UpdateSoundCodeLabelRequest): Promise<UpdateSoundCodeLabelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateSoundCodeLabelWithOptions(request, runtime);
  }

  async updateSoundCodeScheduleWithOptions(request: UpdateSoundCodeScheduleRequest, runtime: $Util.RuntimeOptions): Promise<UpdateSoundCodeScheduleResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.description)) {
      body["Description"] = request.description;
    }

    if (!Util.isUnset(request.endDate)) {
      body["EndDate"] = request.endDate;
    }

    if (!Util.isUnset(request.endTime)) {
      body["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      body["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.name)) {
      body["Name"] = request.name;
    }

    if (!Util.isUnset(request.scheduleCode)) {
      body["ScheduleCode"] = request.scheduleCode;
    }

    if (!Util.isUnset(request.startDate)) {
      body["StartDate"] = request.startDate;
    }

    if (!Util.isUnset(request.startTime)) {
      body["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.status)) {
      body["Status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateSoundCodeSchedule",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateSoundCodeScheduleResponse>(await this.callApi(params, req, runtime), new UpdateSoundCodeScheduleResponse({}));
  }

  async updateSoundCodeSchedule(request: UpdateSoundCodeScheduleRequest): Promise<UpdateSoundCodeScheduleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateSoundCodeScheduleWithOptions(request, runtime);
  }

  async updateSpeechWithOptions(tmpReq: UpdateSpeechRequest, runtime: $Util.RuntimeOptions): Promise<UpdateSpeechResponse> {
    Util.validateModel(tmpReq);
    let request = new UpdateSpeechShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.soundCodeConfig)) {
      request.soundCodeConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.soundCodeConfig, "SoundCodeConfig", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.enableSoundCode)) {
      body["EnableSoundCode"] = request.enableSoundCode;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      body["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.projectCode)) {
      body["ProjectCode"] = request.projectCode;
    }

    if (!Util.isUnset(request.soundCodeConfigShrink)) {
      body["SoundCodeConfig"] = request.soundCodeConfigShrink;
    }

    if (!Util.isUnset(request.speechCode)) {
      body["SpeechCode"] = request.speechCode;
    }

    if (!Util.isUnset(request.speechRate)) {
      body["SpeechRate"] = request.speechRate;
    }

    if (!Util.isUnset(request.voice)) {
      body["Voice"] = request.voice;
    }

    if (!Util.isUnset(request.volume)) {
      body["Volume"] = request.volume;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateSpeech",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateSpeechResponse>(await this.callApi(params, req, runtime), new UpdateSpeechResponse({}));
  }

  async updateSpeech(request: UpdateSpeechRequest): Promise<UpdateSpeechResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateSpeechWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request UpdateSubscribeRelationRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return UpdateSubscribeRelationResponse
   */
  async updateSubscribeRelationWithOptions(request: UpdateSubscribeRelationRequest, runtime: $Util.RuntimeOptions): Promise<UpdateSubscribeRelationResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.consumerGroupIds)) {
      query["ConsumerGroupIds"] = request.consumerGroupIds;
    }

    if (!Util.isUnset(request.deviceDataFlag)) {
      query["DeviceDataFlag"] = request.deviceDataFlag;
    }

    if (!Util.isUnset(request.deviceLifeCycleFlag)) {
      query["DeviceLifeCycleFlag"] = request.deviceLifeCycleFlag;
    }

    if (!Util.isUnset(request.deviceStatusChangeFlag)) {
      query["DeviceStatusChangeFlag"] = request.deviceStatusChangeFlag;
    }

    if (!Util.isUnset(request.deviceTagFlag)) {
      query["DeviceTagFlag"] = request.deviceTagFlag;
    }

    if (!Util.isUnset(request.deviceTopoLifeCycleFlag)) {
      query["DeviceTopoLifeCycleFlag"] = request.deviceTopoLifeCycleFlag;
    }

    if (!Util.isUnset(request.foundDeviceListFlag)) {
      query["FoundDeviceListFlag"] = request.foundDeviceListFlag;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.mnsConfiguration)) {
      query["MnsConfiguration"] = request.mnsConfiguration;
    }

    if (!Util.isUnset(request.otaEventFlag)) {
      query["OtaEventFlag"] = request.otaEventFlag;
    }

    if (!Util.isUnset(request.otaJobFlag)) {
      query["OtaJobFlag"] = request.otaJobFlag;
    }

    if (!Util.isUnset(request.otaVersionFlag)) {
      query["OtaVersionFlag"] = request.otaVersionFlag;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.subscribeFlags)) {
      query["SubscribeFlags"] = request.subscribeFlags;
    }

    if (!Util.isUnset(request.thingHistoryFlag)) {
      query["ThingHistoryFlag"] = request.thingHistoryFlag;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateSubscribeRelation",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateSubscribeRelationResponse>(await this.callApi(params, req, runtime), new UpdateSubscribeRelationResponse({}));
  }

  /**
    * ## Limits
    * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
    * >  RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request UpdateSubscribeRelationRequest
    * @return UpdateSubscribeRelationResponse
   */
  async updateSubscribeRelation(request: UpdateSubscribeRelationRequest): Promise<UpdateSubscribeRelationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateSubscribeRelationWithOptions(request, runtime);
  }

  /**
    * ## Limits
    * *   If a product is published, you must call the [CancelReleaseProduct](~~213875~~) operation to unpublish the product before you call this operation.
    * *   When you call this operation, you can use the [json-schema](https://github.com/everit-org/json-schema?spm=a2c4g.11186623.2.23.575832d9zD7fZb) library to verify the input parameters in **ThingModelJson**. For more information, see [Data structure of ThingModelJson](~~150457~~).
    * *   You can call this operation to update only one feature. TSL features include properties, services, and events.
    * *   Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
    * > RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request UpdateThingModelRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return UpdateThingModelResponse
   */
  async updateThingModelWithOptions(request: UpdateThingModelRequest, runtime: $Util.RuntimeOptions): Promise<UpdateThingModelResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.functionBlockId)) {
      query["FunctionBlockId"] = request.functionBlockId;
    }

    if (!Util.isUnset(request.functionBlockName)) {
      query["FunctionBlockName"] = request.functionBlockName;
    }

    if (!Util.isUnset(request.identifier)) {
      query["Identifier"] = request.identifier;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.thingModelJson)) {
      query["ThingModelJson"] = request.thingModelJson;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateThingModel",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateThingModelResponse>(await this.callApi(params, req, runtime), new UpdateThingModelResponse({}));
  }

  /**
    * ## Limits
    * *   If a product is published, you must call the [CancelReleaseProduct](~~213875~~) operation to unpublish the product before you call this operation.
    * *   When you call this operation, you can use the [json-schema](https://github.com/everit-org/json-schema?spm=a2c4g.11186623.2.23.575832d9zD7fZb) library to verify the input parameters in **ThingModelJson**. For more information, see [Data structure of ThingModelJson](~~150457~~).
    * *   You can call this operation to update only one feature. TSL features include properties, services, and events.
    * *   Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
    * > RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request UpdateThingModelRequest
    * @return UpdateThingModelResponse
   */
  async updateThingModel(request: UpdateThingModelRequest): Promise<UpdateThingModelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateThingModelWithOptions(request, runtime);
  }

  /**
    * *   A data parsing script is used to convert the custom-formatted data to JSON data after the data is submitted by a device. You can write a script in JavaScript, Python 2.7, and PHP 7.2. For more information, see [Submit scripts for data parsing](~~149963~~).
    * *   Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
    * > RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request UpdateThingScriptRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return UpdateThingScriptResponse
   */
  async updateThingScriptWithOptions(request: UpdateThingScriptRequest, runtime: $Util.RuntimeOptions): Promise<UpdateThingScriptResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.scriptContent)) {
      query["ScriptContent"] = request.scriptContent;
    }

    if (!Util.isUnset(request.scriptType)) {
      query["ScriptType"] = request.scriptType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateThingScript",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateThingScriptResponse>(await this.callApi(params, req, runtime), new UpdateThingScriptResponse({}));
  }

  /**
    * *   A data parsing script is used to convert the custom-formatted data to JSON data after the data is submitted by a device. You can write a script in JavaScript, Python 2.7, and PHP 7.2. For more information, see [Submit scripts for data parsing](~~149963~~).
    * *   Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
    * > RAM users of an Alibaba Cloud account share the quota of the account.
    *
    * @param request UpdateThingScriptRequest
    * @return UpdateThingScriptResponse
   */
  async updateThingScript(request: UpdateThingScriptRequest): Promise<UpdateThingScriptResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateThingScriptWithOptions(request, runtime);
  }

  async updateTopicConfigWithOptions(request: UpdateTopicConfigRequest, runtime: $Util.RuntimeOptions): Promise<UpdateTopicConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.codec)) {
      query["Codec"] = request.codec;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.enableBroadcast)) {
      query["EnableBroadcast"] = request.enableBroadcast;
    }

    if (!Util.isUnset(request.enableProxySubscribe)) {
      query["EnableProxySubscribe"] = request.enableProxySubscribe;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.operation)) {
      query["Operation"] = request.operation;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.topicFullName)) {
      query["TopicFullName"] = request.topicFullName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateTopicConfig",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateTopicConfigResponse>(await this.callApi(params, req, runtime), new UpdateTopicConfigResponse({}));
  }

  async updateTopicConfig(request: UpdateTopicConfigRequest): Promise<UpdateTopicConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateTopicConfigWithOptions(request, runtime);
  }

  async writeDevicesHotStorageDataWithOptions(request: WriteDevicesHotStorageDataRequest, runtime: $Util.RuntimeOptions): Promise<WriteDevicesHotStorageDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.iotId)) {
      query["IotId"] = request.iotId;
    }

    if (!Util.isUnset(request.iotInstanceId)) {
      query["IotInstanceId"] = request.iotInstanceId;
    }

    if (!Util.isUnset(request.items)) {
      query["Items"] = request.items;
    }

    if (!Util.isUnset(request.productKey)) {
      query["ProductKey"] = request.productKey;
    }

    if (!Util.isUnset(request.userTopic)) {
      query["UserTopic"] = request.userTopic;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "WriteDevicesHotStorageData",
      version: "2018-01-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<WriteDevicesHotStorageDataResponse>(await this.callApi(params, req, runtime), new WriteDevicesHotStorageDataResponse({}));
  }

  async writeDevicesHotStorageData(request: WriteDevicesHotStorageDataRequest): Promise<WriteDevicesHotStorageDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.writeDevicesHotStorageDataWithOptions(request, runtime);
  }

}
