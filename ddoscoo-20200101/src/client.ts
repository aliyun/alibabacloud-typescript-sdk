// This file is auto-generated, don't edit it
/**
 */
import Util, * as $Util from '@alicloud/tea-util';
import OpenApi, * as $OpenApi from '@alicloud/openapi-client';
import OpenApiUtil from '@alicloud/openapi-util';
import EndpointUtil from '@alicloud/endpoint-util';
import * as $tea from '@alicloud/tea-typescript';

export class AddAutoCcBlacklistRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * [{"src":"198.51.XX.XX"},{"src":"198.52.XX.XX"}]
   */
  blacklist?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 300
   */
  expireTime?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * ddoscoo-cn-mp91j1ao****
   */
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      blacklist: 'Blacklist',
      expireTime: 'ExpireTime',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      blacklist: 'string',
      expireTime: 'number',
      instanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddAutoCcBlacklistResponseBody extends $tea.Model {
  /**
   * @example
   * C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddAutoCcBlacklistResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddAutoCcBlacklistResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddAutoCcBlacklistResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddAutoCcWhitelistRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is deprecated.
   * 
   * > This parameter indicates the validity period of the IP address blacklist. By default, the traffic from the IP addresses that you add to the whitelist is always allowed. You do not need to set this parameter.
   * 
   * @example
   * 0
   */
  expireTime?: number;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * > You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.
   * 
   * This parameter is required.
   * 
   * @example
   * ddoscoo-cn-mp91j1ao****
   */
  instanceId?: string;
  /**
   * @remarks
   * The configuration of the IP addresses that you want to add to the whitelist. The value is a string that consists of JSON arrays. Each element in a JSON array is a JSON struct that contains the following fields:
   * 
   * *   **src**: the IP address that you want to add. This parameter is required. Data type: string.
   * 
   * This parameter is required.
   * 
   * @example
   * [{"src":"192.XX.XX.1"},{"src":"192.XX.XX.2"}]
   */
  whitelist?: string;
  static names(): { [key: string]: string } {
    return {
      expireTime: 'ExpireTime',
      instanceId: 'InstanceId',
      whitelist: 'Whitelist',
    };
  }

  static types(): { [key: string]: any } {
    return {
      expireTime: 'number',
      instanceId: 'string',
      whitelist: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddAutoCcWhitelistResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * AB5025DA-5C52-5207-B6AC-3F198758B678
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddAutoCcWhitelistResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddAutoCcWhitelistResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddAutoCcWhitelistResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AssociateWebCertRequest extends $tea.Model {
  cert?: string;
  certId?: number;
  certIdentifier?: string;
  certName?: string;
  certRegion?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  domain?: string;
  key?: string;
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
   * 
   * @example
   * default
   */
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      cert: 'Cert',
      certId: 'CertId',
      certIdentifier: 'CertIdentifier',
      certName: 'CertName',
      certRegion: 'CertRegion',
      domain: 'Domain',
      key: 'Key',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cert: 'string',
      certId: 'number',
      certIdentifier: 'string',
      certName: 'string',
      certRegion: 'string',
      domain: 'string',
      key: 'string',
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AssociateWebCertResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 40F11005-A75C-4644-95F2-52A4E7D43E91
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AssociateWebCertResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AssociateWebCertResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AssociateWebCertResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AttachSceneDefenseObjectRequest extends $tea.Model {
  /**
   * @remarks
   * The type of the object. Set the value to **Domain**, which indicates a domain name.
   * 
   * This parameter is required.
   * 
   * @example
   * Domain
   */
  objectType?: string;
  /**
   * @remarks
   * The object that you want to add to the policy. Separate multiple objects with commas (,).
   * 
   * This parameter is required.
   * 
   * @example
   * www.aliyun.com
   */
  objects?: string;
  /**
   * @remarks
   * The ID of the policy.
   * 
   * > You can call the [DescribeSceneDefensePolicies](https://help.aliyun.com/document_detail/159382.html) operation to query the IDs of all policies.
   * 
   * This parameter is required.
   * 
   * @example
   * 321a-fd31-df51-****
   */
  policyId?: string;
  static names(): { [key: string]: string } {
    return {
      objectType: 'ObjectType',
      objects: 'Objects',
      policyId: 'PolicyId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      objectType: 'string',
      objects: 'string',
      policyId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AttachSceneDefenseObjectResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * F65DF043-E0EB-4796-9467-23DDCDF92C1D
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: yes
   * *   **false**: no
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AttachSceneDefenseObjectResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AttachSceneDefenseObjectResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AttachSceneDefenseObjectResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ConfigDomainSecurityProfileRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is unavailable.
   */
  cluster?: string;
  /**
   * @remarks
   * The configurations for the global mitigation policy feature. The configurations include the following fields:
   * 
   * *   **global_rule_mode**: optional. The mode for the global mitigation policy feature. Data type: string. Valid values:
   * 
   *     *   **weak**: loose.
   *     *   **default**: normal.
   *     *   **hard**: strict.
   * 
   * *   **global_rule_enable**: optional. Specifies whether to enable the global mitigation policy feature. Data type: string. Valid values:
   * 
   *     *   **0**: disabled.
   *     *   **1**: enabled.
   * 
   * This parameter is required.
   * 
   * @example
   * {\\"global_rule_mode\\":\\"hard\\"}
   */
  config?: string;
  /**
   * @remarks
   * The domain name of the website.
   * 
   * >  A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.
   * 
   * This parameter is required.
   * 
   * @example
   * live.abcde.com
   */
  domain?: string;
  static names(): { [key: string]: string } {
    return {
      cluster: 'Cluster',
      config: 'Config',
      domain: 'Domain',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cluster: 'string',
      config: 'string',
      domain: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ConfigDomainSecurityProfileResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 9728769F-9466-534E-BE12-CAB29A675828
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ConfigDomainSecurityProfileResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ConfigDomainSecurityProfileResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ConfigDomainSecurityProfileResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ConfigL7RsPolicyRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name of the website.
   * 
   * > A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query the domain names for which forwarding rules are configured.
   * 
   * This parameter is required.
   * 
   * @example
   * www.aliyun.com
   */
  domain?: string;
  /**
   * @remarks
   * The back-to-origin policy. The value is a string that consists of a JSON struct. The JSON struct contains the following fields:
   * 
   * *   **ProxyMode**: The load balancing algorithm for back-to-origin traffic. This field is required and must be a string. Valid values:
   * 
   *     *   **ip_hash**: the IP hash algorithm. This algorithm is used to redirect requests from the same IP address to the same origin server.
   *     *   **rr**: the round-robin algorithm. This algorithm is used to redirect requests to origin servers in turn. If you use this algorithm, you can specify a weight for each server based on server performance.
   *     *   **least_time**: the least response time algorithm. This algorithm is used to minimize the latency when requests are forwarded from the instance to origin servers based on the intelligent DNS resolution feature.
   * 
   * *   **Attributes**: the parameters for back-to-origin processing. This field is optional and must be a JSON array. Each element in the array contains the following fields:
   * 
   *     *   **RealServer**: the address of the origin server. This field is optional and must be a string.
   * 
   *     *   **Attribute**: the parameter for back-to-origin processing. This field is optional and must be a JSON object. Valid values:
   * 
   *         *   **Weight**: the weight of the server. This field is optional and must be an integer. This field takes effect only when **ProxyMode** is set to **rr**. Valid values: **1** to **100**. Default value: **100**. An origin server with a higher weight receives more requests.
   *         *   **ConnectTimeout**: the timeout period for new connections. This field is optional and must be an integer. Valid values: **1** to **10**. Unit: seconds. Default value: **5**.
   *         *   **FailTimeout**: the period after which a connection is considered to have failed. This field is optional and must be an integer. Valid values: **1** to **3600**. Unit: seconds. Default value: **10**.
   *         *   **MaxFails**: the maximum number of failures allowed. This field is related to health checks. This field is optional and must be an integer. Valid values: **1** to **10**. Unit: seconds. Default value: **3**.
   *         *   **Mode**: the primary/secondary attribute flag. This parameter is optional and must be a string. Valid values: **active** (primary) and **backup** (secondary).
   *         *   **ReadTimeout**: the read timeout period. This field is optional and must be an integer. Valid values: **10** to **300**. Unit: seconds. Default value: **120**.
   *         *   **SendTimeout**: the write timeout period. This field is optional and must be an integer. Valid values: **10** to **300**. Unit: seconds. Default value: **120**.
   * 
   * This parameter is required.
   * 
   * @example
   * {"ProxyMode":"rr","Attributes":[{"RealServer":"1.***.***.1","Attribute":{"Weight":100}},{"RealServer":"2.***.***.2","Attribute":{"Weight":100}}]}
   */
  policy?: string;
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
   * 
   * For more information about resource groups, see [Create a resource group](https://help.aliyun.com/document_detail/94485.html).
   * 
   * @example
   * rg-acfm2pz25js****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The retry switch. Valid values:
   * 
   * *   **1**: on
   * *   **0**: off
   * 
   * @example
   * 1
   */
  upstreamRetry?: number;
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
      policy: 'Policy',
      resourceGroupId: 'ResourceGroupId',
      upstreamRetry: 'UpstreamRetry',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
      policy: 'string',
      resourceGroupId: 'string',
      upstreamRetry: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ConfigL7RsPolicyResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ConfigL7RsPolicyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ConfigL7RsPolicyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ConfigL7RsPolicyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ConfigL7UsKeepaliveRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name of the website.
   * 
   * >  A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.
   * 
   * @example
   * www.aliyun.com
   */
  domain?: string;
  /**
   * @remarks
   * The settings for back-to-origin persistent connections. The value is a string that consists of a JSON struct. The JSON struct contains the following fields:
   * 
   * *   **enabled**: the switch for back-to-origin persistent connections. This field is required, and the value is of the Boolean type.
   * *   **keepalive_requests**: the number of requests that reuse a persistent connection. This field is required, and the value is of the integer type.
   * *   **keepalive_timeout**: the timeout period for an idle persistent connection. This field is required, and the value is of the integer type.
   * 
   * This parameter is required.
   * 
   * @example
   * {"enabled": true, "keepalive_requests": 1000,"keepalive_timeout": 30}
   */
  upstreamKeepalive?: string;
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
      upstreamKeepalive: 'UpstreamKeepalive',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
      upstreamKeepalive: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ConfigL7UsKeepaliveResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 6D48AED0-41DB-5D9B-B484-3B6AAD312AD1
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ConfigL7UsKeepaliveResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ConfigL7UsKeepaliveResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ConfigL7UsKeepaliveResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ConfigLayer4RealLimitRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the Anti-DDoS Pro or Anti-DDoS Premium instance.
   * 
   * > You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.
   * 
   * This parameter is required.
   * 
   * @example
   * ddoscoo-cn-XXXXX
   */
  instanceId?: string;
  /**
   * @remarks
   * Specifies the threshold of the clean bandwidth. Valid values: 0 to 15360. The value 0 indicates that rate limiting is never triggered. Unit: Mbit/s
   * 
   * This parameter is required.
   * 
   * @example
   * 0
   */
  limitValue?: number;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      limitValue: 'LimitValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      limitValue: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ConfigLayer4RealLimitResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CFCF71BD-680E-5A20-8847-174CEC62E67D
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ConfigLayer4RealLimitResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ConfigLayer4RealLimitResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ConfigLayer4RealLimitResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ConfigLayer4RemarkRequest extends $tea.Model {
  /**
   * @remarks
   * The port forwarding rule that you want to manage.
   * 
   * This parameter is a string that consists of JSON arrays. Each element in a JSON array indicates a port forwarding rule. You can perform this operation only on one port forwarding rule at a time.
   * 
   * > You can call the [DescribeNetworkRules](https://help.aliyun.com/document_detail/157484.html) to query existing port forwarding rules.
   * 
   * Each port forwarding rule contains the following fields:
   * 
   * *   **InstanceId**: the ID of the instance. This field is required and must be of the STRING type.
   * *   **Protocol**: the forwarding protocol. This field is required and must be of the STRING type. Valid values: **tcp** and **udp**.
   * *   **FrontendPort**: the forwarding port. This field is required and must be of the INTEGER type.
   * *   **Remark**: the remarks of the port forwarding rule. This field is required and must be of the STRING type. The value can contain letters, digits, and some special characters, such as `, . + - * / _`. The value can be up to 200 characters in length.
   * 
   * This parameter is required.
   * 
   * @example
   * [{\\"InstanceId\\":\\"ddosDip-sg-4hr2b3l****\\",\\"FrontendPort\\":2020,\\"Protocol\\":\\"udp\\",\\"Remark\\":\\"test\\"}]
   */
  listeners?: string;
  static names(): { [key: string]: string } {
    return {
      listeners: 'Listeners',
    };
  }

  static types(): { [key: string]: any } {
    return {
      listeners: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ConfigLayer4RemarkResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 6E46CC51-36BE-1100-B14C-DAF8381B8F73
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ConfigLayer4RemarkResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ConfigLayer4RemarkResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ConfigLayer4RemarkResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ConfigLayer4RuleBakModeRequest extends $tea.Model {
  /**
   * @remarks
   * The mode that you want to use to forward service traffic. Valid values:
   * 
   * *   **0**: the default mode. In this mode, Anti-DDoS Pro or Anti-DDoS Premium forwards service traffic to the origin IP address that you specified when you created the port forwarding rule. You can call the [CreateNetworkRules](https://help.aliyun.com/document_detail/157482.html) operation to create a port forwarding rule.
   * *   **1**: the origin redundancy mode. In this mode, Anti-DDoS Pro or Anti-DDoS Premium forwards service traffic to the IP addresses of the primary or secondary origin servers. You can call the [ConfigLayer4RulePolicy](https://help.aliyun.com/document_detail/312684.html) operation to configure IP addresses.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  bakMode?: string;
  /**
   * @remarks
   * The port forwarding rule that you want to manage.
   * 
   * This parameter is a string that consists of JSON arrays. Each element in a JSON array indicates a port forwarding rule. You can perform this operation only on one port forwarding rule at a time.
   * 
   * > You can call the [DescribeNetworkRules](https://help.aliyun.com/document_detail/157484.html) to query existing port forwarding rules.
   * 
   * Each port forwarding rule contains the following fields:
   * 
   * *   **InstanceId**: the ID of the instance. This field is required and must be of the STRING type.
   * *   **Protocol**: the forwarding protocol. This field is required and must be of the STRING type. Valid values: **tcp** and **udp**.
   * *   **FrontendPort**: the forwarding port. This field is required and must be of the INTEGER type.
   * 
   * This parameter is required.
   * 
   * @example
   * [{\\"InstanceId\\":\\"ddosDip-sg-4hr2b3l****\\",\\"FrontendPort\\":2020,\\"Protocol\\":\\"udp\\"}]
   */
  listeners?: string;
  static names(): { [key: string]: string } {
    return {
      bakMode: 'BakMode',
      listeners: 'Listeners',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bakMode: 'string',
      listeners: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ConfigLayer4RuleBakModeResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CC042262-15A3-4A49-ADF0-130968EA47BC
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ConfigLayer4RuleBakModeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ConfigLayer4RuleBakModeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ConfigLayer4RuleBakModeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ConfigLayer4RulePolicyRequest extends $tea.Model {
  /**
   * @remarks
   * The port forwarding rule that you want to manage.
   * 
   * This parameter is a string that consists of JSON arrays. Each element in a JSON array indicates a port forwarding rule. You can perform this operation only on one port forwarding rule at a time.
   * 
   * > You can call the [DescribeNetworkRules](https://help.aliyun.com/document_detail/157484.html) to query existing port forwarding rules.
   * 
   * Each port forwarding rule contains the following fields:
   * 
   * *   **InstanceId**: the ID of the instance. This field is required and must be of the STRING type.
   * 
   * *   **Protocol**: the forwarding protocol. This field is required and must be of the STRING type. Valid values: **tcp** and **udp**.
   * 
   * *   **FrontendPort**: the forwarding port. This field is required and must be of the INTEGER type.
   * 
   * *   **BackendPort**: the port of the origin server. This field is required and must be of the INTEGER type.
   * 
   * *   **PriRealServers**: the IP addresses of the primary origin server. This field is required and must be a JSON array. Each element in a JSON array indicates an IP address of the primary origin server. You can configure a maximum of 20 IP addresses.
   * 
   *     Each element in the JSON array contains the following field:
   * 
   *     *   **RealServer**: the IP address of the primary origin server. This field is required and must be of the STRING type.
   * 
   * *   **SecRealServers**: the IP addresses of the secondary origin server. This field is required and must be a JSON array. Each element in a JSON array indicates an IP address of the secondary origin server. You can configure a maximum of 20 IP addresses.
   * 
   *     Each element in the JSON array contains the following field:
   * 
   *     *   **RealServer**: the IP address of the secondary origin server. This field is required and must be of the STRING type.
   * 
   * *   **CurrentRsIndex**: the origin server that you want to use to receive service traffic. This field is required and must be of the INTEGER type. Valid values:
   * 
   *     *   **1**: the primary origin server, which indicates that Anti-DDoS Pro or Anti-DDoS Premium forwards service traffic to the IP addresses of the primary origin server.
   *     *   **2**: the secondary origin server, which indicates that Anti-DDoS Pro or Anti-DDoS Premium forwards service traffic to the IP addresses of the secondary origin server.
   * 
   * This parameter is required.
   * 
   * @example
   * [{\\"InstanceId\\":\\"ddosDip-sg-4hr2b3l****\\",\\"Protocol\\":\\"udp\\",\\"FrontendPort\\":2020,\\"BackendPort\\":2022,\\"PriRealServers\\":[{\\"RealServer\\":\\"192.0.2.1\\"},{\\"RealServer\\":\\"192.0.2.2\\"}],\\"SecRealServers\\":[{\\"RealServer\\":\\"192.0.2.3\\"},{\\"RealServer\\":\\"192.0.2.4\\"}],\\"CurrentRsIndex\\":1}]
   */
  listeners?: string;
  static names(): { [key: string]: string } {
    return {
      listeners: 'Listeners',
    };
  }

  static types(): { [key: string]: any } {
    return {
      listeners: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ConfigLayer4RulePolicyResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CC042262-15A3-4A49-ADF0-130968EA47BC
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ConfigLayer4RulePolicyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ConfigLayer4RulePolicyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ConfigLayer4RulePolicyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ConfigNetworkRegionBlockRequest extends $tea.Model {
  /**
   * @remarks
   * The details of the configurations of blocked locations. This parameter is a JSON string. The value consists of the following fields:
   * 
   * *   **RegionBlockSwitch**: the status of the location blacklist feature. This field is required and must be of the string type. Valid values:
   * 
   *     *   **on**
   *     *   **off**
   * 
   * *   **Countries**: the codes of the countries and areas from which you want to block requests. This field is optional and must be of the array type.
   * 
   *     **
   * 
   *     **Note** For more information about the codes of countries and areas, see [Location parameters](https://help.aliyun.com/document_detail/167926.html).
   * 
   * *   **Provinces**: the codes of the administrative regions in China from which you want to block requests. This field is optional and must be of the array type.
   * 
   *     **
   * 
   *     **Note** For more information about the codes of administrative regions in China, see [Location parameters](https://help.aliyun.com/document_detail/167926.html).
   * 
   *     For example, `[11,12]` specifies Beijing and Tianjin.
   * 
   * This parameter is required.
   * 
   * @example
   * {"RegionBlockSwitch":"off","Countries":[],"Provinces":[11,12,13,14,15,21,22,23,31,32,33,34,35,36,37,41,42,43,44,45,46,50,51,52,53,54,61,62,63,64,65,71,81,82]}
   */
  config?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * > You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.
   * 
   * This parameter is required.
   * 
   * @example
   * ddoscoo-cn-mp91j1ao****
   */
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      config: 'Config',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      config: 'string',
      instanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ConfigNetworkRegionBlockResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ConfigNetworkRegionBlockResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ConfigNetworkRegionBlockResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ConfigNetworkRegionBlockResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ConfigNetworkRulesRequest extends $tea.Model {
  /**
   * @remarks
   * The details of the port forwarding rule. This parameter is a JSON string. The string contains the following fields:
   * 
   * *   **InstanceId**: the ID of the instance. This field is required and must be of the STRING type.
   * *   **Protocol**: the forwarding protocol. This field is required and must be of the STRING type. Valid values: **tcp** and **udp**.
   * *   **FrontendPort**: the forwarding port. This field is required and must be of the INTEGER type.
   * *   **BackendPort**: the port of the origin server. This field is required and must be of the INTEGER type.
   * *   **RealServers**: the IP addresses of the origin server. This field is required and must be a JSON array. You can specify up to 20 IP addresses.
   * 
   * > You can modify only the value of **RealServers** when you modify a port forwarding rule.
   * 
   * This parameter is required.
   * 
   * @example
   * [{"InstanceId":"ddoscoo-cn-mp91j1ao****","Protocol":"tcp","FrontendPort":8080,"BackendPort":8080,"RealServers":["1.1.1.1","2.2.2.2","3.3.3.3"]}]
   */
  networkRules?: string;
  static names(): { [key: string]: string } {
    return {
      networkRules: 'NetworkRules',
    };
  }

  static types(): { [key: string]: any } {
    return {
      networkRules: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ConfigNetworkRulesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CC042262-15A3-4A49-ADF0-130968EA47BC
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ConfigNetworkRulesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ConfigNetworkRulesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ConfigNetworkRulesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ConfigUdpReflectRequest extends $tea.Model {
  /**
   * @remarks
   * The configuration of the filtering policy for UDP reflection attacks.
   * 
   * The value is a string that consists of a JSON struct. The JSON struct contains the following field:
   * 
   * *   **UdpSports**: the source ports of the UDP traffic that you want to block. This field is required and must be of the ARRAY type. Example: `[17,19]`.
   * 
   *     We recommend that you block the following source ports of UDP traffic:
   * 
   *     *   UDP 17: QOTD reflection attacks
   *     *   UDP 19: CharGEN reflection attacks
   *     *   UDP 69: TFTP reflection attacks
   *     *   UDP 111: Portmap reflection attacks
   *     *   UDP 123: NTP reflection attacks
   *     *   UDP 137: NetBIOS reflection attacks
   *     *   UDP 161: SNMPv2 reflection attacks
   *     *   UDP 389: CLDAP reflection attacks
   *     *   UDP 1194: OpenVPN reflection attacks
   *     *   UDP 1900: SSDP reflection attacks
   *     *   UDP 3389: RDP reflection attacks
   *     *   UDP 11211: memcached reflection attacks
   * 
   * This parameter is required.
   * 
   * @example
   * {\\"UdpSports\\":[17,19]}
   */
  config?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * > You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.
   * 
   * This parameter is required.
   * 
   * @example
   * ddoscoo-cn-i7m25564****
   */
  instanceId?: string;
  /**
   * @remarks
   * The region ID of the Anti-DDoS Proxy instance. Valid values:
   * 
   * *   **cn-hangzhou**: indicates an Anti-DDoS Proxy (Chinese Mainland) instance. This is the default value.
   * *   **ap-southeast-1**: indicates an Anti-DDoS Proxy (Outside Chinese Mainland) instance.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      config: 'Config',
      instanceId: 'InstanceId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      config: 'string',
      instanceId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ConfigUdpReflectResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 9EC62E89-BD30-4FCD-9CB8-FA53865FF0D7
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ConfigUdpReflectResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ConfigUdpReflectResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ConfigUdpReflectResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ConfigWebCCRuleV2Request extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * www.example.com
   */
  domain?: string;
  /**
   * @example
   * 600
   */
  expires?: number;
  /**
   * @remarks
   * The frequency control rule. This parameter is a JSON string that contains the following fields:
   * 
   * *   **action**: the action that is performed if the rule is matched. This field is required and must be of the string type. Valid values:
   * 
   *     *   **block**: The requests that match the rule are blocked.
   *     *   **challenge**: Completely Automated Public Turing test to tell Computers and Humans Apart (CAPTCHA) verification for the requests that match the rule is implemented.
   *     *   **watch**: The requests that match the rule are recorded in logs and allowed.
   * 
   * *   **name**: the name of the rule. This field is required and must be of the string type.
   * 
   * *   **condition**: the match conditions. This field is required and must be of the map type. This field contains the following parameters:
   * 
   *     **
   * 
   *     **Note** The AND logical operator is used to evaluate multiple match conditions.
   * 
   *     *   **field**: the match field. This field is required and must be of the string type.
   * 
   *     *   **match_method**: the logical relation. This field is required and must be of the string type.
   * 
   *         **
   * 
   *         **Note** For information about the mappings between the **field** and **match_method** parameters, see the "Mappings between the field and match_method parameters" section of this topic.
   * 
   *     *   **header_name**: the name of the custom HTTP header. This field is optional and must be of the string type.
   * 
   *         **
   * 
   *         **Note** This field is required only when **field** is set to **header**.
   * 
   *     *   **content**: the match content. This field is required and must be of the string type.
   * 
   * *   **ratelimit**: the frequency control field. This field is optional and must be of the string type. The frequency can be measured based on IP addresses or custom headers. This field contains the following parameters:
   * 
   *     *   **interval**: the statistical duration. Unit: seconds. This field is required and must be of the integer type.
   *     *   **ttl**: the period during which the specified action is performed. Unit: seconds. This field is required and must be of the integer type.
   *     *   **threshold**: the threshold. This field is required and must be of the integer type.
   *     *   **subkey**: the name of the field. This field is optional and must be of the string type. This field is required only when target is set to header.
   *     *   **target**: the statistical source. This field is required and must be of the string type. Valid values: ip and header.
   * 
   * *   **status_code**: the frequency control field. This field is optional and must be of the string type. Frequency control can be performed based on the quantity or percentage of status codes. This field contains the following parameters:
   * 
   *     *   **enabled**: specifies whether to enable status code statistics. This field is required and must be of the Boolean type.
   *     *   **code**: the status code. This field is required and must be of the integer type. Valid values: **100** to **599**.
   *     *   **use_ratio**: specifies whether to use a ratio. This field is required and must be of the Boolean type. To use a ratio, set this field to true.
   *     *   **ratio_threshold**: the ratio of the status code. This field is optional and must be of the integer type. If a ratio is used, the action specified in the rule is performed only when the ratio of the status code reaches **ratio_threshold**. Valid values: **1** to **100**.
   *     *   **count_threshold**: the quantity of the status code. This field is optional and must be of the integer type. If a ratio is not used, the action specified in the rule is performed only when the quantity of the status code reaches **count_threshold**. Valid values: **2** to **50000**.
   * 
   * *   **statistics**: specifies whether deduplication is used for statistics. This field is optional and must be of the string type. By default, deduplication is not used for statistics. This field contains the following parameters:
   * 
   *     *   **mode**: specifies whether deduplication is used for status code statistics. This field is required and must be of the string type. Valid values:
   * 
   *         *   **count**: Deduplication is not used for statistics.
   *         *   **distinct**: Deduplication is used for statistics.
   * 
   *     *   **field**: the statistical source. This field is required and must be of the string type. Valid values: ip, header, and uri.
   * 
   *     *   **header_name**: the name of the header. This field is optional and must be of the string type. This field is required only when field is set to header.
   * 
   * This parameter is required.
   * 
   * @example
   * [{"action":"block","name":"trdsss","ratelimit":{"interval":60,"ttl":300,"threshold":70,"target":"ip"},"condition":[{"field":"ip","match_method":"belong","content":"1.1.1.1"}]}]
   */
  ruleList?: string;
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
      expires: 'Expires',
      ruleList: 'RuleList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
      expires: 'number',
      ruleList: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ConfigWebCCRuleV2ResponseBody extends $tea.Model {
  /**
   * @example
   * 0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ConfigWebCCRuleV2Response extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ConfigWebCCRuleV2ResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ConfigWebCCRuleV2ResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ConfigWebCCTemplateRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name of the website.
   * 
   * > A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.
   * 
   * This parameter is required.
   * 
   * @example
   * www.aliyun.com
   */
  domain?: string;
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
   * 
   * @example
   * default
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The mode of the Frequency Control policy. Valid values:
   * 
   * *   **default**: Normal
   * *   **gf_under_attack**: Emergency
   * *   **gf_sos_verify**: Strict
   * *   **gf_sos_enhance**: Super Strict
   * 
   * This parameter is required.
   * 
   * @example
   * default
   */
  template?: string;
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
      resourceGroupId: 'ResourceGroupId',
      template: 'Template',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
      resourceGroupId: 'string',
      template: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ConfigWebCCTemplateResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ConfigWebCCTemplateResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ConfigWebCCTemplateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ConfigWebCCTemplateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ConfigWebIpSetRequest extends $tea.Model {
  /**
   * @remarks
   * The IP addresses and CIDR blocks in the blacklist. You can add up to 200 IP addresses or CIDR blocks to the blacklist.
   * 
   * @example
   * 1.1.1.1
   */
  blackList?: string[];
  /**
   * @remarks
   * The domain name of the website.
   * 
   * > A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.
   * 
   * This parameter is required.
   * 
   * @example
   * www.aliyun.com
   */
  domain?: string;
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
   * 
   * @example
   * default
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The IP addresses and CIDR blocks in the whitelist. You can add up to 200 IP addresses or CIDR blocks to the whitelist.
   * 
   * @example
   * 2.2.2.2/24
   */
  whiteList?: string[];
  static names(): { [key: string]: string } {
    return {
      blackList: 'BlackList',
      domain: 'Domain',
      resourceGroupId: 'ResourceGroupId',
      whiteList: 'WhiteList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      blackList: { 'type': 'array', 'itemType': 'string' },
      domain: 'string',
      resourceGroupId: 'string',
      whiteList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ConfigWebIpSetResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ConfigWebIpSetResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ConfigWebIpSetResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ConfigWebIpSetResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAsyncTaskRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
   * 
   * @example
   * default
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The details of the asynchronous export task. The value is a JSON string. The field in the value varies with **TaskType**.
   * 
   * If **TaskType** is set to **1**, **3**, **4**, **5**, or **6**, the following filed is returned:
   * 
   * *   **instanceId**: the ID of the instance. This field is required and must be of the STRING type.
   * 
   * If **TaskType** is set to **2**, the following field is returned:
   * 
   * *   **domain**: the domain name of the website, which must be of the STRING type. If you do not specify this field, the forwarding rules of all websites are exported.
   * 
   * This parameter is required.
   * 
   * @example
   * {"instanceId": "ddoscoo-cn-mp91j1ao****"}
   */
  taskParams?: string;
  /**
   * @remarks
   * The type of the asynchronous export task that you want to create. Valid values:
   * 
   * *   **1**: the task to export the port forwarding rules of an instance
   * *   **2**: the task to export the forwarding rules of a website protected by an instance
   * *   **3**: the task to export the session persistence and health check settings of an instance
   * *   **4**: the task to export the anti-DDoS mitigation policies of an instance
   * *   **5**: the task to download the blacklist for destination IP addresses of an instance
   * *   **6**: the task to download the whitelist for destination IP addresses of an instance
   * 
   * This parameter is required.
   * 
   * @example
   * 5
   */
  taskType?: number;
  static names(): { [key: string]: string } {
    return {
      resourceGroupId: 'ResourceGroupId',
      taskParams: 'TaskParams',
      taskType: 'TaskType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resourceGroupId: 'string',
      taskParams: 'string',
      taskType: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAsyncTaskResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAsyncTaskResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateAsyncTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateAsyncTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDomainResourceRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name of the website that you want to add to the Anti-DDoS Pro or Anti-DDoS Premium instance.
   * 
   * This parameter is required.
   * 
   * @example
   * www.example.com
   */
  domain?: string;
  /**
   * @remarks
   * The advanced HTTPS settings. This parameter takes effect only when the value of the **ProxyType** parameter includes **https**. The value is a string that consists of a JSON struct. The JSON struct contains the following fields:
   * 
   * *   **Http2https**: specifies whether to turn on Enforce HTTPS Routing. This field is optional and must be an integer. Valid values: **0** and **1**. The value 0 indicates that Enforce HTTPS Routing is turned off. The value 1 indicates that Enforce HTTPS Routing is turned on. The default value is 0.
   * 
   *     If your website supports both HTTP and HTTPS, this feature meets your business requirements. If you enable this feature, all HTTP requests to access the website are redirected to HTTPS requests on the standard port 443.
   * 
   * *   **Https2http**: specifies whether to turn on Enable HTTP. This field is optional and must be an integer. Valid values: **0** and **1**. The value 0 indicates that Enable HTTP is turned off. The value 1 indicates that Enable HTTP is turned on. The default value is 0.
   * 
   *     If your website does not support HTTPS, this feature meets your business requirements If this feature is enabled, all HTTPS requests are redirected to HTTP requests and forwarded to origin servers. This feature can redirect WebSockets requests to WebSocket requests. Requests are redirected over the standard port 80.
   * 
   * *   **Http2**: specifies whether to turn on Enable HTTP/2. This field is optional. Data type: integer. Valid values: **0** and **1**. The value 0 indicates that Enable HTTP/2 is turned off. The value 1 indicates that Enable HTTP/2 is turned on. The default value is 0.
   * 
   *     After you turn on the switch, HTTP/2 is used.
   * 
   * @example
   * {"Http2":1,"Http2https":1,"Https2http":1}
   */
  httpsExt?: string;
  /**
   * @remarks
   * An array consisting of the IDs of instances that you want to associate.
   * 
   * This parameter is required.
   */
  instanceIds?: string[];
  /**
   * @remarks
   * The details about the protocol type and port number.
   * 
   * This parameter is required.
   */
  proxyTypes?: CreateDomainResourceRequestProxyTypes[];
  /**
   * @remarks
   * An array that consists of the addresses of origin servers.
   * 
   * This parameter is required.
   */
  realServers?: string[];
  /**
   * @remarks
   * The address type of the origin server. Valid values:
   * 
   * *   **0**: IP address
   * 
   * *   **1**: domain name
   * 
   *     This parameter is suitable for scenarios where another proxy service, such as Web Application Firewall (WAF), is deployed between the origin server and Anti-DDoS Pro or Anti-DDoS Premium. The address is the jump address of the proxy service, such as the CNAME address of WAF.
   * 
   * This parameter is required.
   * 
   * @example
   * 0
   */
  rsType?: number;
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
      httpsExt: 'HttpsExt',
      instanceIds: 'InstanceIds',
      proxyTypes: 'ProxyTypes',
      realServers: 'RealServers',
      rsType: 'RsType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
      httpsExt: 'string',
      instanceIds: { 'type': 'array', 'itemType': 'string' },
      proxyTypes: { 'type': 'array', 'itemType': CreateDomainResourceRequestProxyTypes },
      realServers: { 'type': 'array', 'itemType': 'string' },
      rsType: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDomainResourceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 39499F01-19D9-4EA4-A0E9-C6014BA5CDBE
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDomainResourceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateDomainResourceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateDomainResourceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateNetworkRulesRequest extends $tea.Model {
  /**
   * @remarks
   * The details of the port forwarding rule. This parameter is a JSON string. The string contains the following fields:
   * 
   * *   **InstanceId**: the ID of the instance. This field is required and must be of the STRING type.
   * *   **Protocol**: the forwarding protocol. This field is required and must be of the STRING type. Valid values: **tcp** and **udp**.
   * *   **FrontendPort**: the forwarding port. This field is required and must be of the INTEGER type.
   * *   **BackendPort**: the port of the origin server. This field is required and must be of the INTEGER type.
   * *   **RealServers**: the IP addresses of the origin server. This field is required and must be a JSON array. You can specify up to 20 IP addresses.
   * 
   * This parameter is required.
   * 
   * @example
   * [{"InstanceId":"ddoscoo-cn-mp91j1ao****","Protocol":"tcp","FrontendPort":8080,"BackendPort":8080,"RealServers":["1.1.1.1","2.2.2.2"]}]
   */
  networkRules?: string;
  static names(): { [key: string]: string } {
    return {
      networkRules: 'NetworkRules',
    };
  }

  static types(): { [key: string]: any } {
    return {
      networkRules: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateNetworkRulesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * ADCA45A5-D15C-4B7D-9F81-138B0B36D0BD
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateNetworkRulesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateNetworkRulesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateNetworkRulesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePortRequest extends $tea.Model {
  /**
   * @remarks
   * The port of the origin server. Valid values: **0** to **65535**.
   * 
   * @example
   * 55
   */
  backendPort?: string;
  /**
   * @remarks
   * The forwarding port. Valid values: **0** to **65535**.
   * 
   * This parameter is required.
   * 
   * @example
   * 55
   */
  frontendPort?: string;
  /**
   * @remarks
   * The type of the protocol. Valid values:
   * 
   * *   **tcp**
   * *   **udp**
   * 
   * This parameter is required.
   * 
   * @example
   * tcp
   */
  frontendProtocol?: string;
  /**
   * @remarks
   * The ID of the Anti-DDoS Pro or Anti-DDoS Premium instance to which the port forwarding rule belongs.
   * 
   * > You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.
   * 
   * This parameter is required.
   * 
   * @example
   * ddoscoo-cn-st21zbyq****
   */
  instanceId?: string;
  /**
   * @remarks
   * An array that consists of the IP addresses of origin servers.
   * 
   * This parameter is required.
   */
  realServers?: string[];
  static names(): { [key: string]: string } {
    return {
      backendPort: 'BackendPort',
      frontendPort: 'FrontendPort',
      frontendProtocol: 'FrontendProtocol',
      instanceId: 'InstanceId',
      realServers: 'RealServers',
    };
  }

  static types(): { [key: string]: any } {
    return {
      backendPort: 'string',
      frontendPort: 'string',
      frontendProtocol: 'string',
      instanceId: 'string',
      realServers: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePortResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request, which is used to locate and troubleshoot issues.
   * 
   * @example
   * 4787A9A6-8230-4B4A-8211-AFBF7C416B4D
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePortResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreatePortResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreatePortResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSceneDefensePolicyRequest extends $tea.Model {
  /**
   * @remarks
   * The end time of the policy. This value is a UNIX timestamp. Units: milliseconds.
   * 
   * This parameter is required.
   * 
   * @example
   * 1586016000000
   */
  endTime?: number;
  /**
   * @remarks
   * The name of the policy.
   * 
   * This parameter is required.
   * 
   * @example
   * testpolicy
   */
  name?: string;
  /**
   * @remarks
   * The start time of the policy. This value is a UNIX timestamp. Units: milliseconds.
   * 
   * This parameter is required.
   * 
   * @example
   * 1585670400000
   */
  startTime?: number;
  /**
   * @remarks
   * The template of the policy. Valid values:
   * 
   * *   **promotion**: important activity
   * *   **bypass**: all traffic forwarded
   * 
   * This parameter is required.
   * 
   * @example
   * promotion
   */
  template?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      name: 'Name',
      startTime: 'StartTime',
      template: 'Template',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'number',
      name: 'string',
      startTime: 'number',
      template: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSceneDefensePolicyResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * F65DF043-E0EB-4796-9467-23DDCDF92C1D
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: yes
   * *   **false**: no
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSceneDefensePolicyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateSceneDefensePolicyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateSceneDefensePolicyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSchedulerRuleRequest extends $tea.Model {
  /**
   * @remarks
   * The details of the CDN interaction rule. This parameter is a JSON string. The following list describes the fields in the value of the parameter:
   * 
   * *   **ParamType**: the type of the scheduling rule. This field is required and must be of the string type. Set the value to **cdn**. This indicates that you want to modify a CDN interaction rule.
   * 
   * *   **ParamData**: the values of parameters that you want to modify for the CDN interaction rule. This field is required and must be of the map type. ParamData contains the following parameters:
   * 
   *     *   **Domain**: the accelerated domain in CDN. This parameter is required and must be of the string type.
   *     *   **Cname**: the CNAME that is assigned to the accelerated domain. This parameter is required and must be of the string type.
   *     *   **AccessQps**: the queries per second (QPS) threshold that is used to switch service traffic to Anti-DDoS Pro or Anti-DDoS Premium. This parameter is required and must be of the integer type.
   *     *   **UpstreamQps**: the QPS threshold that is used to switch service traffic to CDN. This parameter is optional and must be of the integer type.
   * 
   * @example
   * {"ParamType":"cdn","ParamData":{"Domain":"example.aliyundoc.com","Cname":"demo.aliyundoc.com","AccessQps":100,"UpstreamQps":100}}
   */
  param?: string;
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
   * 
   * @example
   * default
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The name of the rule.
   * 
   * This parameter is required.
   * 
   * @example
   * testrule
   */
  ruleName?: string;
  /**
   * @remarks
   * The type of the rule. Valid values:
   * 
   * *   **2**: tiered protection
   * *   **3**: network acceleration
   * *   **5**: Alibaba Cloud CDN (CDN) interaction
   * *   **6**: cloud service interaction
   * *   **8**: secure acceleration
   * 
   * This parameter is required.
   * 
   * @example
   * 2
   */
  ruleType?: number;
  /**
   * @remarks
   * The details of the scheduling rule. This parameter is a JSON string. The following list describes the fields in the value of the parameter:
   * 
   * *   **Type**: the address type of the interaction resource that you want to use in the scheduling rule. This field is required and must be of the string type. Valid values:
   * 
   *     *   **A**: IP address
   *     *   **CNAME**: domain name
   * 
   * *   **Value**: the address of the interaction resource that you want to use in the scheduling rule. This field is required and must be of the string type.
   * 
   * *   **Priority**: the priority of the scheduling rule. This field is required and must be of the integer type. Valid values: **0** to **100**. A larger value indicates a higher priority.
   * 
   * *   **ValueType**: the type of the interaction resource that you want to use in the scheduling rule. This field is required and must be of the integer type. Valid values:
   * 
   *     *   **1**: the IP address of the Anti-DDoS Pro or Anti-DDoS Premium instance
   *     *   **2**: the IP address of the interaction resource in the tiered protection scenario
   *     *   **3**: the IP address that is used to accelerate access in the network acceleration scenario
   *     *   **5**: the domain name that is configured in Alibaba Cloud CDN (CDN) in the CDN interaction scenario
   *     *   **6** the IP address of the interaction resource in the cloud service interaction scenario
   * 
   * *   **RegionId**: the region where the interaction resource is deployed. This parameter must be specified when **ValueType** is set to **2**. The value must be of the string type.
   * 
   * This parameter is required.
   * 
   * @example
   * [{"Type":"A", "Value":"1.1.XX.XX", "Priority":80,"ValueType":2, "RegionId":"cn-hangzhou" },{"Type":"A", "Value":"203.199.XX.XX", "Priority":80,"ValueType":1}]
   */
  rules?: string;
  static names(): { [key: string]: string } {
    return {
      param: 'Param',
      resourceGroupId: 'ResourceGroupId',
      ruleName: 'RuleName',
      ruleType: 'RuleType',
      rules: 'Rules',
    };
  }

  static types(): { [key: string]: any } {
    return {
      param: 'string',
      resourceGroupId: 'string',
      ruleName: 'string',
      ruleType: 'number',
      rules: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSchedulerRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * The CNAME that is assigned by Sec-Traffic Manager for the scheduling rule.
   * 
   * > To enable the scheduling rule, you must map the domain name of the service to the CNAME.
   * 
   * @example
   * 48k7b372gpl4****.aliyunddos0001.com
   */
  cname?: string;
  /**
   * @remarks
   * The ID of the request, which is used to locate and troubleshoot issues.
   * 
   * @example
   * 8DFB602D-1AAC-46C4-90F2-C84086E7A6E4
   */
  requestId?: string;
  /**
   * @remarks
   * The name of the rule.
   * 
   * @example
   * testrule
   */
  ruleName?: string;
  static names(): { [key: string]: string } {
    return {
      cname: 'Cname',
      requestId: 'RequestId',
      ruleName: 'RuleName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cname: 'string',
      requestId: 'string',
      ruleName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSchedulerRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateSchedulerRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateSchedulerRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTagResourcesRequest extends $tea.Model {
  /**
   * @remarks
   * The region ID of the instance. Set the value to **cn-hangzhou**, which indicates an Anti-DDoS Proxy (Chinese Mainland) instance.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management.
   * 
   * If you do not specify this parameter, the instance belongs to the default resource group.
   * 
   * @example
   * rg-acfm2pz25js****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The IDs of the Anti-DDoS Proxy (Chinese Mainland) instances to which you want to add the tag.
   * 
   * This parameter is required.
   * 
   * @example
   * ddoscoo-cn-mp91j1ao****
   */
  resourceIds?: string[];
  /**
   * @remarks
   * The type of the resource to which the tag belongs. Set the value to **INSTANCE**, which indicates an Anti-DDoS Pro instance.
   * 
   * This parameter is required.
   * 
   * @example
   * INSTANCE
   */
  resourceType?: string;
  /**
   * @remarks
   * An array that consists of the tags to add.
   */
  tags?: CreateTagResourcesRequestTags[];
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      resourceIds: 'ResourceIds',
      resourceType: 'ResourceType',
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
      resourceGroupId: 'string',
      resourceIds: { 'type': 'array', 'itemType': 'string' },
      resourceType: 'string',
      tags: { 'type': 'array', 'itemType': CreateTagResourcesRequestTags },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTagResourcesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTagResourcesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateTagResourcesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateTagResourcesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWebCCRuleRequest extends $tea.Model {
  /**
   * @remarks
   * The action on the requests that trigger the custom frequency control rule. Valid values:
   * 
   * *   **close**: blocks the requests.
   * *   **captcha**: triggers Completely Automated Public Turing test to tell Computers and Humans Apart (CAPTCHA) verification for the requests.
   * 
   * This parameter is required.
   * 
   * @example
   * close
   */
  act?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 60
   */
  count?: number;
  /**
   * @remarks
   * The domain name of the website.
   * 
   * >  A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.
   * 
   * This parameter is required.
   * 
   * @example
   * www.aliyun.com
   */
  domain?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 20
   */
  interval?: number;
  /**
   * @remarks
   * The matching mode. Valid values:
   * 
   * *   **prefix**: prefix match.
   * *   **match**: exact match.
   * 
   * >  If the **URI** of the check path contains parameters, you must set this parameter to **prefix**.
   * 
   * This parameter is required.
   * 
   * @example
   * prefix
   */
  mode?: string;
  /**
   * @remarks
   * The name of the rule. The name can be up to 128 characters in length and contain letters, digits, and underscores (_).
   * 
   * This parameter is required.
   * 
   * @example
   * testrule
   */
  name?: string;
  /**
   * @remarks
   * The ID of the resource group to which the Anti-DDoS Proxy instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
   * 
   * For more information about resource groups, see [Create a resource group](https://help.aliyun.com/document_detail/94485.html).
   * 
   * @example
   * rg-acfm2pz25js****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The blocking duration. Valid values: **60** to **86400**. Unit: seconds.
   * 
   * This parameter is required.
   * 
   * @example
   * 60
   */
  ttl?: number;
  /**
   * @remarks
   * The check path.
   * 
   * >  The URI cannot be modified. The domain name of the website, the check path, and the rule name uniquely identify a rule.
   * 
   * This parameter is required.
   * 
   * @example
   * /abc/a.php
   */
  uri?: string;
  static names(): { [key: string]: string } {
    return {
      act: 'Act',
      count: 'Count',
      domain: 'Domain',
      interval: 'Interval',
      mode: 'Mode',
      name: 'Name',
      resourceGroupId: 'ResourceGroupId',
      ttl: 'Ttl',
      uri: 'Uri',
    };
  }

  static types(): { [key: string]: any } {
    return {
      act: 'string',
      count: 'number',
      domain: 'string',
      interval: 'number',
      mode: 'string',
      name: 'string',
      resourceGroupId: 'string',
      ttl: 'number',
      uri: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWebCCRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWebCCRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateWebCCRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateWebCCRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWebRuleRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the associated defense. This parameter applies to scenarios in which other cloud services, such as Object Storage Service (OSS), are integrated with Anti-DDoS Pro or Anti-DDoS Premium.
   * 
   * > This parameter is in internal preview. Do not use this parameter.
   * 
   * For example, if you integrate OSS with Anti-DDoS Pro or Anti-DDoS Premium, Anti-DDoS Pro or Anti-DDoS Premium allocates an IP address pool for the OSS production account. Each IP address corresponds to a unique defense ID. A defense ID is a CNAME, which is automatically resolved to the IP address of the required Anti-DDoS Pro or Anti-DDoS Premium instance. A defense ID can be resolved to the same IP address to facilitate scheduling.
   * 
   * > You can specify only one of the following parameters: **InstanceIds** and **DefenseId**.
   * 
   * @example
   * testid
   */
  defenseId?: string;
  /**
   * @remarks
   * The domain name of the website that you want to add to the instance.
   * 
   * This parameter is required.
   * 
   * @example
   * example.aliyundoc.com
   */
  domain?: string;
  /**
   * @remarks
   * The advanced HTTPS settings. This parameter takes effect only when the value of the **ProxyType** parameter includes **https**. The value is a string that consists of a JSON struct. The JSON struct contains the following fields:
   * 
   * *   **Http2https**: specifies whether to turn on Enforce HTTPS Routing. This field is optional and must be an integer. Valid values: **0** and **1**. The value 0 indicates that Enforce HTTPS Routing is turned off. The value 1 indicates that Enforce HTTPS Routing is turned on. The default value is 0.
   * 
   *     If your website supports both HTTP and HTTPS, this feature meets your business requirements. If you enable this feature, all HTTP requests to access the website are redirected to HTTPS requests on the standard port 443.
   * 
   * *   **Https2http**: specifies whether to turn on Enable HTTP. This field is optional and must be an integer. Valid values: **0** and **1**. The value 0 indicates that Enable HTTP is turned off. The value 1 indicates that Enable HTTP is turned on. The default value is 0.
   * 
   *     If your website does not support HTTPS, this feature meets your business requirements If this feature is enabled, all HTTPS requests are redirected to HTTP requests and forwarded to origin servers. This feature can redirect WebSockets requests to WebSocket requests. Requests are redirected over the standard port 80.
   * 
   * *   **Http2**: specifies whether to turn on Enable HTTP/2. This field is optional and must be an integer. Valid values: **0** and **1**. The value 0 indicates that Enable HTTP/2 is turned off. The value 1 indicates that Enable HTTP/2 is turned on. The default value is 0.
   * 
   *     After you turn on Enable HTTP/2, the protocol type is HTTP/2.
   * 
   * @example
   * {"Http2":1,"Http2https":1,"Https2http":1}
   */
  httpsExt?: string;
  /**
   * @remarks
   * An array consisting of the IDs of instances that you want to associate.
   * 
   * @example
   * ddoscoo-cn-mp91j1ao****
   */
  instanceIds?: string[];
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
   * 
   * For more information about resource groups, see [Create a resource group](https://help.aliyun.com/document_detail/94485.html).
   * 
   * @example
   * rg-acfm2pz25js****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The address type of the origin server. Valid values:
   * 
   * *   **0**: IP address
   * *   **1**: domain name The domain name of the origin server is returned if you deploy proxies, such as Web Application Firewall (WAF), between the origin server and the instance. In this case, the address of the proxy, such as the CNAME provided by WAF, is returned.
   * 
   * This parameter is required.
   * 
   * @example
   * 0
   */
  rsType?: number;
  /**
   * @remarks
   * The details of the forwarding rule. The value is a string that consists of JSON arrays. Each element in a JSON array is a JSON struct that contains the following fields:
   * 
   * *   **ProxyRules**: the information about the origin server. The information includes the port number and IP address. This field is required and must be a JSON array. Each element in a JSON array is a JSON struct that contains the following fields:
   * 
   *     *   **ProxyPort**: the port number. This field is required and must be an integer.
   *     *   **RealServers**: the IP address. This field is required and must be a string array.
   * 
   * *   **ProxyType**: the protocol type. This field is required and must be a string. Valid values: **http**, **https**, **websocket**, and **websockets**.
   * 
   * This parameter is required.
   * 
   * @example
   * [{"ProxyRules":[{"ProxyPort":443,"RealServers":["192.1.XX.XX"]}],"ProxyType":"https"}]
   */
  rules?: string;
  static names(): { [key: string]: string } {
    return {
      defenseId: 'DefenseId',
      domain: 'Domain',
      httpsExt: 'HttpsExt',
      instanceIds: 'InstanceIds',
      resourceGroupId: 'ResourceGroupId',
      rsType: 'RsType',
      rules: 'Rules',
    };
  }

  static types(): { [key: string]: any } {
    return {
      defenseId: 'string',
      domain: 'string',
      httpsExt: 'string',
      instanceIds: { 'type': 'array', 'itemType': 'string' },
      resourceGroupId: 'string',
      rsType: 'number',
      rules: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWebRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request, which is used to locate and troubleshoot issues.
   * 
   * @example
   * 9EC62E89-BD30-4FCD-9CB8-FA53865FF0D7
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWebRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateWebRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateWebRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAsyncTaskRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
   * 
   * @example
   * default
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The ID of the task that you want to delete.
   * 
   * >  You can call the [DescribeAsyncTasks](~~DescribeAsyncTasks~~) operation to query the IDs of all asynchronous export tasks.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  taskId?: number;
  static names(): { [key: string]: string } {
    return {
      resourceGroupId: 'ResourceGroupId',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resourceGroupId: 'string',
      taskId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAsyncTaskResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAsyncTaskResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteAsyncTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteAsyncTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAutoCcBlacklistRequest extends $tea.Model {
  /**
   * @remarks
   * The IP addresses that you want to manage. This parameter is a JSON string. The string contains the following fields:
   * 
   * *   **src**: the IP address. This field is required and must be of the STRING type.
   * 
   * This parameter is required.
   * 
   * @example
   * [{"src":"198.51.XX.XX"},{"src":"198.52.XX.XX"}]
   */
  blacklist?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * > You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.
   * 
   * This parameter is required.
   * 
   * @example
   * ddoscoo-cn-mp91j1ao****
   */
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      blacklist: 'Blacklist',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      blacklist: 'string',
      instanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAutoCcBlacklistResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request, which is used to locate and troubleshoot issues.
   * 
   * @example
   * C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAutoCcBlacklistResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteAutoCcBlacklistResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteAutoCcBlacklistResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAutoCcWhitelistRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the instance.
   * 
   * > You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.
   * 
   * This parameter is required.
   * 
   * @example
   * ddoscoo-cn-mp91j1ao****
   */
  instanceId?: string;
  /**
   * @remarks
   * The IP addresses that you want to manage. This parameter is a JSON string. This parameter is a JSON string. The string contains the following field:
   * 
   * *   **src**: the IP address. This field is required and must be of the string type.
   * 
   * This parameter is required.
   * 
   * @example
   * [{"src":"1.1.1.1"},{"src":"2.2.2.2"}]
   */
  whitelist?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      whitelist: 'Whitelist',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      whitelist: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAutoCcWhitelistResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAutoCcWhitelistResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteAutoCcWhitelistResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteAutoCcWhitelistResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDomainResourceRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name for which the forwarding rule is configured.
   * 
   * This parameter is required.
   * 
   * @example
   * www.example.com
   */
  domain?: string;
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDomainResourceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 39499F01-19D9-4EA4-A0E9-C6014BA5CDBE
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDomainResourceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteDomainResourceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteDomainResourceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteNetworkRuleRequest extends $tea.Model {
  /**
   * @remarks
   * An array that consists of the information about the port forwarding rule. This parameter is a JSON string. The string contains the following fields:
   * 
   * *   **InstanceId**: the ID of the instance. This field is required and must be of the STRING type.
   * *   **Protocol**: the forwarding protocol. This field is required and must be of the STRING type. Valid values: **tcp** and **udp**.
   * *   **FrontendPort**: the forwarding port. This field is required and must be of the INTEGER type.
   * 
   * This parameter is required.
   * 
   * @example
   * [{"InstanceId":"ddoscoo-cn-mp91j1ao****","Protocol":"tcp","FrontendPort":8080}]
   */
  networkRule?: string;
  static names(): { [key: string]: string } {
    return {
      networkRule: 'NetworkRule',
    };
  }

  static types(): { [key: string]: any } {
    return {
      networkRule: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteNetworkRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 49AD2F34-694A-4024-9B0E-DDCFC59CCC13
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteNetworkRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteNetworkRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteNetworkRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeletePortRequest extends $tea.Model {
  /**
   * @remarks
   * The port of the origin server. Valid values: **0** to **65535**.
   * 
   * @example
   * 55
   */
  backendPort?: string;
  /**
   * @remarks
   * The forwarding port. Valid values: **0** to **65535**.
   * 
   * This parameter is required.
   * 
   * @example
   * 55
   */
  frontendPort?: string;
  /**
   * @remarks
   * The type of the protocol. Valid values:
   * 
   * *   **tcp**
   * *   **udp**
   * 
   * This parameter is required.
   * 
   * @example
   * tcp
   */
  frontendProtocol?: string;
  /**
   * @remarks
   * The ID of the Anti-DDoS Pro or Anti-DDoS Premium instance to which the port forwarding rule belongs.
   * 
   * > You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.
   * 
   * This parameter is required.
   * 
   * @example
   * ddoscoo-cn-st21zbyq****
   */
  instanceId?: string;
  /**
   * @remarks
   * An array that consists of the IP addresses of origin servers.
   */
  realServers?: string[];
  static names(): { [key: string]: string } {
    return {
      backendPort: 'BackendPort',
      frontendPort: 'FrontendPort',
      frontendProtocol: 'FrontendProtocol',
      instanceId: 'InstanceId',
      realServers: 'RealServers',
    };
  }

  static types(): { [key: string]: any } {
    return {
      backendPort: 'string',
      frontendPort: 'string',
      frontendProtocol: 'string',
      instanceId: 'string',
      realServers: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeletePortResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request, which is used to locate and troubleshoot issues.
   * 
   * @example
   * 39499F01-19D9-4EA4-A0E9-C6014BA5CDBE
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeletePortResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeletePortResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeletePortResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSceneDefensePolicyRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the policy that you want to delete.
   * 
   * > You can call the [DescribeSceneDefensePolicies](https://help.aliyun.com/document_detail/159382.html) operation to query the IDs of all policies.
   * 
   * This parameter is required.
   * 
   * @example
   * 321a-fd31-df51-****
   */
  policyId?: string;
  static names(): { [key: string]: string } {
    return {
      policyId: 'PolicyId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      policyId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSceneDefensePolicyResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * F65DF043-E0EB-4796-9467-23DDCDF92C1D
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: yes
   * *   **false**: no
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSceneDefensePolicyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteSceneDefensePolicyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteSceneDefensePolicyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSchedulerRuleRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
   * 
   * @example
   * default
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The name of the scheduling rule that you want to delete.
   * 
   * This parameter is required.
   * 
   * @example
   * testrule
   */
  ruleName?: string;
  static names(): { [key: string]: string } {
    return {
      resourceGroupId: 'ResourceGroupId',
      ruleName: 'RuleName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resourceGroupId: 'string',
      ruleName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSchedulerRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSchedulerRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteSchedulerRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteSchedulerRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTagResourcesRequest extends $tea.Model {
  /**
   * @remarks
   * Specifies whether to remove all tags from the specified resource. Valid values:
   * 
   * *   **true**: yes.
   * *   **false** no. This is the default value.
   * 
   * @example
   * false
   */
  all?: boolean;
  /**
   * @remarks
   * The region ID of the instance. Set the value to **cn-hangzhou**, which indicates an Anti-DDoS Proxy (Chinese Mainland) instance.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management.
   * 
   * If you do not configure this parameter, the instance belongs to the default resource group.
   * 
   * @example
   * rg-acfm2pz25js****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * An array consisting of the IDs of instances from which you want to remove tags.
   * 
   * This parameter is required.
   * 
   * @example
   * ddoscoo-cn-mp91j1ao****
   */
  resourceIds?: string[];
  /**
   * @remarks
   * The type of the resource to which the tag belongs. Set the value to **INSTANCE**, which indicates an Anti-DDoS Pro instance.
   * 
   * This parameter is required.
   * 
   * @example
   * INSTANCE
   */
  resourceType?: string;
  /**
   * @remarks
   * An array consisting of the keys of the tags that you want to remove.
   * 
   * @example
   * testkey
   */
  tagKey?: string[];
  static names(): { [key: string]: string } {
    return {
      all: 'All',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      resourceIds: 'ResourceIds',
      resourceType: 'ResourceType',
      tagKey: 'TagKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      all: 'boolean',
      regionId: 'string',
      resourceGroupId: 'string',
      resourceIds: { 'type': 'array', 'itemType': 'string' },
      resourceType: 'string',
      tagKey: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTagResourcesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 6623EA1F-30FB-5BC8-BEC9-74D55F6F08F1
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTagResourcesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteTagResourcesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteTagResourcesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWebCCRuleRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name of the website.
   * 
   * > A forwarding rule must be configured for a domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.
   * 
   * This parameter is required.
   * 
   * @example
   * www.aliyun.com
   */
  domain?: string;
  /**
   * @remarks
   * The name of the custom frequency control rule that you want to delete.
   * 
   * This parameter is required.
   * 
   * @example
   * wq
   */
  name?: string;
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
   * 
   * @example
   * default
   */
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
      name: 'Name',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
      name: 'string',
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWebCCRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWebCCRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteWebCCRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteWebCCRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWebCCRuleV2Request extends $tea.Model {
  /**
   * @remarks
   * The domain name of the website.
   * 
   * >  A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.
   * 
   * This parameter is required.
   * 
   * @example
   * www.example.com
   */
  domain?: string;
  /**
   * @remarks
   * The source of the rule. Valid values:
   * 
   * *   **manual** (default): manually created.
   * *   **clover**: automatically created. Specify this value when you want to delete intelligent protection rules.
   * 
   * @example
   * manual
   */
  owner?: string;
  /**
   * @remarks
   * The names of the rules that you want to delete.
   * 
   * @example
   * [\\"trdsss\\"]
   */
  ruleNames?: string;
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
      owner: 'Owner',
      ruleNames: 'RuleNames',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
      owner: 'string',
      ruleNames: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWebCCRuleV2ResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 6D48AED0-41DB-5D9B-B484-3B6AAD312AD1
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWebCCRuleV2Response extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteWebCCRuleV2ResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteWebCCRuleV2ResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWebCacheCustomRuleRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name for which you want to delete the custom rules of the Static Page Caching policy.
   * 
   * > You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all the domain names that are added to Anti-DDoS Pro or Anti-DDoS Premium.
   * 
   * This parameter is required.
   * 
   * @example
   * www.aliyundoc.com
   */
  domain?: string;
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management.
   * 
   * If you do not configure this parameter, the instance belongs to the default resource group.
   * 
   * @example
   * rg-acfm2pz25js****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * An array consisting of the names of the rules that you want to delete.
   * 
   * This parameter is required.
   * 
   * @example
   * test
   */
  ruleNames?: string[];
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
      resourceGroupId: 'ResourceGroupId',
      ruleNames: 'RuleNames',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
      resourceGroupId: 'string',
      ruleNames: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWebCacheCustomRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 6623EA1F-30FB-5BC8-BEC9-74D55F6F08F1
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWebCacheCustomRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteWebCacheCustomRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteWebCacheCustomRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWebPreciseAccessRuleRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name of the website.
   * 
   * > A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.
   * 
   * This parameter is required.
   * 
   * @example
   * www.aliyun.com
   */
  domain?: string;
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
   * 
   * @example
   * default
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * An array that consists of the names of rules to delete.
   * 
   * This parameter is required.
   * 
   * @example
   * testrule
   */
  ruleNames?: string[];
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
      resourceGroupId: 'ResourceGroupId',
      ruleNames: 'RuleNames',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
      resourceGroupId: 'string',
      ruleNames: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWebPreciseAccessRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWebPreciseAccessRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteWebPreciseAccessRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteWebPreciseAccessRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWebRuleRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name of the website from which you want to delete the forwarding rule.
   * 
   * > A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query the domain names for which forwarding rules are configured.
   * 
   * This parameter is required.
   * 
   * @example
   * www.aliyun.com
   */
  domain?: string;
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
   * 
   * For more information about resource groups, see [Create a resource group](https://help.aliyun.com/document_detail/94485.html).
   * 
   * @example
   * rg-acfm2pz25js****
   */
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWebRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 9EC62E89-BD30-4FCD-9CB8-FA53865FF0D7
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWebRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteWebRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteWebRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAsyncTasksRequest extends $tea.Model {
  /**
   * @remarks
   * The number of the page to return.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * This parameter is required.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management.
   * 
   * If you do not configure this parameter, the instance belongs to the default resource group.
   * 
   * @example
   * rg-acfm2pz25js****
   */
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAsyncTasksResponseBody extends $tea.Model {
  /**
   * @remarks
   * An array that consists of the details of the asynchronous export tasks.
   */
  asyncTasks?: DescribeAsyncTasksResponseBodyAsyncTasks[];
  /**
   * @remarks
   * The ID of the request, which is used to locate and troubleshoot issues.
   * 
   * @example
   * 6623EA1F-30FB-5BC8-BEC9-74D55F6F08F1
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of asynchronous export tasks that are returned.
   * 
   * @example
   * 1
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      asyncTasks: 'AsyncTasks',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      asyncTasks: { 'type': 'array', 'itemType': DescribeAsyncTasksResponseBodyAsyncTasks },
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAsyncTasksResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAsyncTasksResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAsyncTasksResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAttackAnalysisMaxQpsRequest extends $tea.Model {
  /**
   * @remarks
   * The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.
   * 
   * This parameter is required.
   * 
   * @example
   * 1619798400
   */
  endTime?: number;
  /**
   * @remarks
   * The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.
   * 
   * This parameter is required.
   * 
   * @example
   * 1622476799
   */
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'number',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAttackAnalysisMaxQpsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The peak queries per second (QPS) of DDoS attacks. Units: QPS.
   * 
   * @example
   * 41652
   */
  qps?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 8DFB602D-1AAC-46C4-90F2-C84086E7A6E4
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      qps: 'Qps',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      qps: 'number',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAttackAnalysisMaxQpsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAttackAnalysisMaxQpsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAttackAnalysisMaxQpsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAutoCcBlacklistRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the instance.
   * 
   * > You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.
   * 
   * This parameter is required.
   * 
   * @example
   * ddoscoo-cn-mp91j1ao****
   */
  instanceId?: string;
  /**
   * @remarks
   * The keyword for the query. This keyword is used to specify the prefix of the source IP address that you want to query.
   * 
   * > The keyword must be greater than three characters in length.
   * 
   * @example
   * 138
   */
  keyWord?: string;
  /**
   * @remarks
   * The number of the page to return. For example, to query the returned results on the first page, set the value to **1**.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * This parameter is required.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      keyWord: 'KeyWord',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      keyWord: 'string',
      pageNumber: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAutoCcBlacklistResponseBody extends $tea.Model {
  /**
   * @remarks
   * An array that consists of the details of the IP addresses in the blacklist of the instance.
   */
  autoCcBlacklist?: DescribeAutoCcBlacklistResponseBodyAutoCcBlacklist[];
  /**
   * @remarks
   * The ID of the request, which is used to locate and troubleshoot issues.
   * 
   * @example
   * E78C8472-0B15-42D5-AF22-A32A78818AB2
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of returned IP addresses in the blacklist.
   * 
   * @example
   * 2
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      autoCcBlacklist: 'AutoCcBlacklist',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      autoCcBlacklist: { 'type': 'array', 'itemType': DescribeAutoCcBlacklistResponseBodyAutoCcBlacklist },
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAutoCcBlacklistResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAutoCcBlacklistResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAutoCcBlacklistResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAutoCcListCountRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the instance.
   * 
   * > You can call the **DescribeInstanceIds** operation to query the IDs of all instances.
   * 
   * This parameter is required.
   * 
   * @example
   * ddoscoo-cn-mp91j1ao****
   */
  instanceId?: string;
  /**
   * @remarks
   * The mode of how an IP address is added to the whitelist or blacklist. Valid values:
   * 
   * *   **manual**: manually added
   * *   **auto**: automatically added
   * 
   * @example
   * manual
   */
  queryType?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      queryType: 'QueryType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      queryType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAutoCcListCountResponseBody extends $tea.Model {
  /**
   * @remarks
   * The total number of IP addresses in the blacklist.
   * 
   * @example
   * 0
   */
  blackCount?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 5AC3785F-C789-4622-87A4-F58BE7F6B184
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of IP addresses in the whitelist.
   * 
   * @example
   * 2
   */
  whiteCount?: number;
  static names(): { [key: string]: string } {
    return {
      blackCount: 'BlackCount',
      requestId: 'RequestId',
      whiteCount: 'WhiteCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      blackCount: 'number',
      requestId: 'string',
      whiteCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAutoCcListCountResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAutoCcListCountResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAutoCcListCountResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAutoCcWhitelistRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the instance.
   * 
   * > You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.
   * 
   * This parameter is required.
   * 
   * @example
   * ddoscoo-cn-mp91j1ao****
   */
  instanceId?: string;
  /**
   * @remarks
   * The keyword for the query. This keyword is used to specify the prefix of the source IP address that you want to query.
   * 
   * > The keyword must be greater than three characters in length.
   * 
   * @example
   * 138
   */
  keyWord?: string;
  /**
   * @remarks
   * The number of the page to return. For example, to query the returned results on the first page, set the value to **1**.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * This parameter is required.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      keyWord: 'KeyWord',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      keyWord: 'string',
      pageNumber: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAutoCcWhitelistResponseBody extends $tea.Model {
  /**
   * @remarks
   * An array that consists of details of the IP address in the whitelist of the instance.
   */
  autoCcWhitelist?: DescribeAutoCcWhitelistResponseBodyAutoCcWhitelist[];
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * F09D085E-5E0F-4FF2-B32E-F4A644049162
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of returned IP addresses in the whitelist.
   * 
   * @example
   * 2
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      autoCcWhitelist: 'AutoCcWhitelist',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      autoCcWhitelist: { 'type': 'array', 'itemType': DescribeAutoCcWhitelistResponseBodyAutoCcWhitelist },
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAutoCcWhitelistResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAutoCcWhitelistResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAutoCcWhitelistResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBackSourceCidrRequest extends $tea.Model {
  /**
   * @remarks
   * The IP version of the back-to-origin CIDR block.
   * 
   * *   **Ipv4**
   * *   **Ipv6**
   * 
   * @example
   * IPv4
   */
  ipVersion?: string;
  /**
   * @remarks
   * The Internet service provider (ISP) line that you want to query.
   * 
   * @example
   * coop-line-001
   */
  line?: string;
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
   * 
   * @example
   * rg-acfm2pz25js****
   */
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      ipVersion: 'IpVersion',
      line: 'Line',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ipVersion: 'string',
      line: 'string',
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBackSourceCidrResponseBody extends $tea.Model {
  /**
   * @remarks
   * An array that consists of the back-to-origin CIDR blocks of the instance.
   */
  cidrs?: string[];
  /**
   * @remarks
   * The ID of the request, which is used to locate and troubleshoot issues.
   * 
   * @example
   * 0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      cidrs: 'Cidrs',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cidrs: { 'type': 'array', 'itemType': 'string' },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBackSourceCidrResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeBackSourceCidrResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeBackSourceCidrResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBlackholeStatusRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the instance.
   * 
   * > You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.
   * 
   * This parameter is required.
   * 
   * @example
   * ddoscoo-cn-mp91j1ao****
   */
  instanceIds?: string[];
  static names(): { [key: string]: string } {
    return {
      instanceIds: 'InstanceIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceIds: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBlackholeStatusResponseBody extends $tea.Model {
  /**
   * @remarks
   * An array that consists of the blackhole filtering status of the instance.
   */
  blackholeStatus?: DescribeBlackholeStatusResponseBodyBlackholeStatus[];
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      blackholeStatus: 'BlackholeStatus',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      blackholeStatus: { 'type': 'array', 'itemType': DescribeBlackholeStatusResponseBodyBlackholeStatus },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBlackholeStatusResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeBlackholeStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeBlackholeStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBlockStatusRequest extends $tea.Model {
  /**
   * @remarks
   * An array consisting of information about the IDs of the instances that you want to query.
   * 
   * > You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.
   * 
   * This parameter is required.
   * 
   * @example
   * ddoscoo-cn-mp91j1ao****
   */
  instanceIds?: string[];
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management.
   * 
   * If you do not configure this parameter, the instance belongs to the default resource group.
   * 
   * @example
   * rg-acfm2pz25js****
   */
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceIds: 'InstanceIds',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceIds: { 'type': 'array', 'itemType': 'string' },
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBlockStatusResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E
   */
  requestId?: string;
  /**
   * @remarks
   * An array that consists of details of the Diversion from Origin Server configurations of the instance.
   */
  statusList?: DescribeBlockStatusResponseBodyStatusList[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      statusList: 'StatusList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      statusList: { 'type': 'array', 'itemType': DescribeBlockStatusResponseBodyStatusList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBlockStatusResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeBlockStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeBlockStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCertsRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name of the website.
   * 
   * > A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.
   * 
   * @example
   * www.aliyun.com
   */
  domain?: string;
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
   * 
   * @example
   * default
   */
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCertsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The certificate information about the website.
   */
  certs?: DescribeCertsResponseBodyCerts[];
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      certs: 'Certs',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      certs: { 'type': 'array', 'itemType': DescribeCertsResponseBodyCerts },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCertsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeCertsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeCertsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCnameReusesRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * www.aliyun.com
   */
  domains?: string[];
  /**
   * @example
   * default
   */
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      domains: 'Domains',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domains: { 'type': 'array', 'itemType': 'string' },
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCnameReusesResponseBody extends $tea.Model {
  cnameReuses?: DescribeCnameReusesResponseBodyCnameReuses[];
  /**
   * @example
   * 0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      cnameReuses: 'CnameReuses',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cnameReuses: { 'type': 'array', 'itemType': DescribeCnameReusesResponseBodyCnameReuses },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCnameReusesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeCnameReusesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeCnameReusesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDDoSEventsRequest extends $tea.Model {
  /**
   * @remarks
   * The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.
   * 
   * > This UNIX timestamp must indicate a point in time that is accurate to the minute.
   * 
   * @example
   * 1583683200
   */
  endTime?: number;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * > You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.
   * 
   * This parameter is required.
   * 
   * @example
   * ddoscoo-cn-mp91j1ao****
   */
  instanceIds?: string[];
  /**
   * @remarks
   * The number of the page to return. For example, to query the returned results on the first page, set the value to **1**.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * This parameter is required.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
   * 
   * @example
   * default
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.
   * 
   * > This UNIX timestamp must indicate a point in time that is accurate to the minute.
   * 
   * This parameter is required.
   * 
   * @example
   * 1582992000
   */
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      instanceIds: 'InstanceIds',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      resourceGroupId: 'ResourceGroupId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'number',
      instanceIds: { 'type': 'array', 'itemType': 'string' },
      pageNumber: 'number',
      pageSize: 'number',
      resourceGroupId: 'string',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDDoSEventsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The DDoS attack events.
   */
  DDoSEvents?: DescribeDDoSEventsResponseBodyDDoSEvents[];
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0CA72AF5-1795-4350-8C77-50A448A2F334
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of returned attack events.
   * 
   * @example
   * 1
   */
  total?: number;
  static names(): { [key: string]: string } {
    return {
      DDoSEvents: 'DDoSEvents',
      requestId: 'RequestId',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      DDoSEvents: { 'type': 'array', 'itemType': DescribeDDoSEventsResponseBodyDDoSEvents },
      requestId: 'string',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDDoSEventsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDDoSEventsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDDoSEventsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDDosAllEventListRequest extends $tea.Model {
  /**
   * @remarks
   * The end of the time range to query. The DDoS attack events occur before **EndTime** are queried. This value is a UNIX timestamp. Unit: seconds.
   * 
   * This parameter is required.
   * 
   * @example
   * 1640966399
   */
  endTime?: number;
  /**
   * @remarks
   * The type of the DDoS attack events you want to query. Valid values:
   * 
   * *   **web-cc**: resource exhaustion attacks
   * *   **cc**: connection flood attacks
   * *   **defense**: DDoS attacks that trigger traffic scrubbing
   * *   **blackhole**: DDoS attacks that trigger blackhole filtering
   * 
   * If you want to query multiple types of DDoS attack events, separate them with commas (,).
   * 
   * If you do not configure this parameter, DDoS attack events of all types are queried.
   * 
   * @example
   * defense
   */
  eventType?: string;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * This parameter is required.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The beginning of the time range to query. The DDoS attack events occur after **StartTime** are queried. This value is a UNIX timestamp. Unit: seconds.
   * 
   * This parameter is required.
   * 
   * @example
   * 1609430400
   */
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      eventType: 'EventType',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'number',
      eventType: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDDosAllEventListResponseBody extends $tea.Model {
  /**
   * @remarks
   * An array that consists of attack events.
   */
  attackEvents?: DescribeDDosAllEventListResponseBodyAttackEvents[];
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 25D83ED5-28CB-5683-9CF7-AECE521F3005
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of DDoS attack events.
   * 
   * @example
   * 1
   */
  total?: number;
  static names(): { [key: string]: string } {
    return {
      attackEvents: 'AttackEvents',
      requestId: 'RequestId',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attackEvents: { 'type': 'array', 'itemType': DescribeDDosAllEventListResponseBodyAttackEvents },
      requestId: 'string',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDDosAllEventListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDDosAllEventListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDDosAllEventListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDDosEventAreaRequest extends $tea.Model {
  /**
   * @remarks
   * The type of the attack event that you want to query. Valid values:
   * 
   * *   **defense**: attack events that trigger traffic scrubbing
   * *   **blackhole**: attack events that trigger blackhole filtering
   * 
   * This parameter is required.
   * 
   * @example
   * defense
   */
  eventType?: string;
  /**
   * @remarks
   * The IP address of the attacked Anti-DDoS Pro or Anti-DDoS Premium instance.
   * 
   * This parameter is required.
   * 
   * @example
   * 203.***.***.199
   */
  ip?: string;
  range?: number;
  /**
   * @remarks
   * The UNIX timestamp when the query starts. Unit: seconds.
   * 
   * > You can call the [DescribeDDosAllEventList](https://help.aliyun.com/document_detail/188604.html) operation to query the beginning time of all attack events.
   * 
   * This parameter is required.
   * 
   * @example
   * 1598948471
   */
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      eventType: 'EventType',
      ip: 'Ip',
      range: 'Range',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      eventType: 'string',
      ip: 'string',
      range: 'number',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDDosEventAreaResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about the source region from which the volumetric attack was initiated.
   */
  areas?: DescribeDDosEventAreaResponseBodyAreas[];
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 11710C9F-BC5E-481A-BEC5-C6D8FBFCA827
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      areas: 'Areas',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      areas: { 'type': 'array', 'itemType': DescribeDDosEventAreaResponseBodyAreas },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDDosEventAreaResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDDosEventAreaResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDDosEventAreaResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDDosEventAttackTypeRequest extends $tea.Model {
  /**
   * @remarks
   * The type of the attack event that you want to query. Valid values:
   * 
   * *   **defense**: attack events that trigger traffic scrubbing
   * *   **blackhole**: attack events that trigger blackhole filtering
   * 
   * This parameter is required.
   * 
   * @example
   * defense
   */
  eventType?: string;
  /**
   * @remarks
   * The IP address of the attacked Anti-DDoS Pro or Anti-DDoS Premium instance.
   * 
   * This parameter is required.
   * 
   * @example
   * 203.***.***.199
   */
  ip?: string;
  /**
   * @remarks
   * The UNIX timestamp when the query starts. Unit: seconds.
   * 
   * > You can call the [DescribeDDosAllEventList](https://help.aliyun.com/document_detail/188604.html) operation to query the beginning time of all attack events.
   * 
   * This parameter is required.
   * 
   * @example
   * 1598948471
   */
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      eventType: 'EventType',
      ip: 'Ip',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      eventType: 'string',
      ip: 'string',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDDosEventAttackTypeResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about the attack types.
   */
  attackTypes?: DescribeDDosEventAttackTypeResponseBodyAttackTypes[];
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 6F644A6E-40E7-483F-9DBB-CC27E16BB555
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      attackTypes: 'AttackTypes',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attackTypes: { 'type': 'array', 'itemType': DescribeDDosEventAttackTypeResponseBodyAttackTypes },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDDosEventAttackTypeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDDosEventAttackTypeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDDosEventAttackTypeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDDosEventIspRequest extends $tea.Model {
  /**
   * @remarks
   * The type of the attack event that you want to query. Valid values:
   * 
   * *   **defense**: attack events that trigger traffic scrubbing
   * *   **blackhole**: attack events that trigger blackhole filtering
   * 
   * This parameter is required.
   * 
   * @example
   * defense
   */
  eventType?: string;
  /**
   * @remarks
   * The IP address of the attacked Anti-DDoS Pro or Anti-DDoS Premium instance.
   * 
   * This parameter is required.
   * 
   * @example
   * 203.***.***.199
   */
  ip?: string;
  range?: number;
  /**
   * @remarks
   * The UNIX timestamp when the query starts. Unit: seconds.
   * 
   * > You can call the [DescribeDDosAllEventList](https://help.aliyun.com/document_detail/188604.html) operation to query the beginning time of all attack events.
   * 
   * This parameter is required.
   * 
   * @example
   * 1598948471
   */
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      eventType: 'EventType',
      ip: 'Ip',
      range: 'Range',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      eventType: 'string',
      ip: 'string',
      range: 'number',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDDosEventIspResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ISPs for the volumetric attack.
   */
  isps?: DescribeDDosEventIspResponseBodyIsps[];
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * C4A3BCD1-4A32-4342-941A-4745AE69508C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      isps: 'Isps',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isps: { 'type': 'array', 'itemType': DescribeDDosEventIspResponseBodyIsps },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDDosEventIspResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDDosEventIspResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDDosEventIspResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDDosEventMaxRequest extends $tea.Model {
  /**
   * @remarks
   * The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.
   * 
   * This parameter is required.
   * 
   * @example
   * 1604073600
   */
  endTime?: number;
  /**
   * @remarks
   * The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.
   * 
   * This parameter is required.
   * 
   * @example
   * 1598889600
   */
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'number',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDDosEventMaxResponseBody extends $tea.Model {
  /**
   * @remarks
   * The peak of connection flood attacks. Unit: connections per seconds (CPS).
   * 
   * @example
   * 1302
   */
  cps?: number;
  /**
   * @remarks
   * The peak of volumetric attacks. Unit: Mbit/s.
   * 
   * @example
   * 6809
   */
  mbps?: number;
  /**
   * @remarks
   * The peak of resource exhaustion attacks. Unit: queries per second (QPS).
   * 
   * @example
   * 26314
   */
  qps?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 5AE2FC86-C840-41AE-9F1A-3A2747C7C1DF
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      cps: 'Cps',
      mbps: 'Mbps',
      qps: 'Qps',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cps: 'number',
      mbps: 'number',
      qps: 'number',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDDosEventMaxResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDDosEventMaxResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDDosEventMaxResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDDosEventSrcIpRequest extends $tea.Model {
  /**
   * @remarks
   * The type of the attack event that you want to query. Valid values:
   * 
   * *   **defense**: attack events that trigger traffic scrubbing
   * *   **blackhole**: attack events that trigger blackhole filtering
   * 
   * This parameter is required.
   * 
   * @example
   * defense
   */
  eventType?: string;
  /**
   * @remarks
   * The IP address of the attacked Anti-DDoS Pro or Anti-DDoS Premium instance.
   * 
   * This parameter is required.
   * 
   * @example
   * 203.***.***.199
   */
  ip?: string;
  /**
   * @remarks
   * The number of source IP addresses that you want to return. The source IP addresses are returned in descending order of attack traffic. By default, the top **five** source IP addresses are returned.
   * 
   * This parameter is required.
   * 
   * @example
   * 2
   */
  range?: number;
  /**
   * @remarks
   * The UNIX timestamp when the query starts. Unit: seconds.
   * 
   * > You can call the [DescribeDDosAllEventList](https://help.aliyun.com/document_detail/188604.html) operation to query the beginning time of all attack events.
   * 
   * This parameter is required.
   * 
   * @example
   * 1598948471
   */
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      eventType: 'EventType',
      ip: 'Ip',
      range: 'Range',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      eventType: 'string',
      ip: 'string',
      range: 'number',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDDosEventSrcIpResponseBody extends $tea.Model {
  /**
   * @remarks
   * An array that consists of information about the source IP address of the volumetric attack.
   */
  ips?: DescribeDDosEventSrcIpResponseBodyIps[];
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 38A0224E-FDBC-4733-A362-B391827FC1E9
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      ips: 'Ips',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ips: { 'type': 'array', 'itemType': DescribeDDosEventSrcIpResponseBodyIps },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDDosEventSrcIpResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDDosEventSrcIpResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDDosEventSrcIpResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDefenseCountStatisticsRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management.
   * 
   * If you do not configure this parameter, the instance belongs to the default resource group.
   * 
   * @example
   * rg-acfm2pz25js****
   */
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDefenseCountStatisticsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The statistics on the number of advanced mitigation sessions.
   */
  defenseCountStatistics?: DescribeDefenseCountStatisticsResponseBodyDefenseCountStatistics;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 310A41FD-0990-5610-92E0-A6A55D7C6444
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      defenseCountStatistics: 'DefenseCountStatistics',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      defenseCountStatistics: DescribeDefenseCountStatisticsResponseBodyDefenseCountStatistics,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDefenseCountStatisticsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDefenseCountStatisticsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDefenseCountStatisticsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDefenseRecordsRequest extends $tea.Model {
  /**
   * @remarks
   * The end of the time range to query. This value is a UNIX timestamp. Units: miliseconds.
   * 
   * > The time must be in the latest 90 days.
   * 
   * This parameter is required.
   * 
   * @example
   * 1583683200000
   */
  endTime?: number;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * > You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.
   * 
   * @example
   * ddoscoo-cn-mp91j1ao****
   */
  instanceId?: string;
  /**
   * @remarks
   * The number of the page to return. For example, to query the returned results on the first page, set the value to **1**.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page. Maximum value: **50**.
   * 
   * This parameter is required.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
   * 
   * @example
   * default
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The beginning of the time range to query. This value is a UNIX timestamp. Units: miliseconds.
   * 
   * > The time must be in the latest 90 days.
   * 
   * This parameter is required.
   * 
   * @example
   * 1582992000000
   */
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      instanceId: 'InstanceId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      resourceGroupId: 'ResourceGroupId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'number',
      instanceId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      resourceGroupId: 'string',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDefenseRecordsResponseBody extends $tea.Model {
  /**
   * @remarks
   * An array that consists of details of the log of an advanced mitigation session.
   */
  defenseRecords?: DescribeDefenseRecordsResponseBodyDefenseRecords[];
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of advanced mitigation sessions.
   * 
   * @example
   * 1
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      defenseRecords: 'DefenseRecords',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      defenseRecords: { 'type': 'array', 'itemType': DescribeDefenseRecordsResponseBodyDefenseRecords },
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDefenseRecordsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDefenseRecordsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDefenseRecordsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDestinationPortEventRequest extends $tea.Model {
  /**
   * @remarks
   * The type of the attack event that you want to query. Valid values:
   * 
   * *   **defense**: attack events that trigger traffic scrubbing.
   * *   **blackhole**: attack events that trigger blackhole filtering.
   * 
   * This parameter is required.
   * 
   * @example
   * defense
   */
  eventType?: string;
  /**
   * @remarks
   * The IP address of the attacker.
   * 
   * This parameter is required.
   * 
   * @example
   * 203.107.XX.XX
   */
  ip?: string;
  /**
   * @remarks
   * The number of destination ports to return. The ports are sorted in descending order of the number of received request packets. By default, the first **10** ports are returned.
   * 
   * This parameter is required.
   * 
   * @example
   * 2
   */
  range?: number;
  /**
   * @remarks
   * The region in which your service is deployed. Valid values:
   * 
   * *   **cn**: a region in the Chinese mainland.
   * *   **cn-hongkong**: a region outside the Chinese mainland.
   * 
   * This parameter is required.
   * 
   * @example
   * cn
   */
  region?: string;
  /**
   * @remarks
   * The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.
   * 
   * >  This UNIX timestamp must indicate a point in time that is accurate to the minute.
   * 
   * This parameter is required.
   * 
   * @example
   * 1720059000
   */
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      eventType: 'EventType',
      ip: 'Ip',
      range: 'Range',
      region: 'Region',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      eventType: 'string',
      ip: 'string',
      range: 'number',
      region: 'string',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDestinationPortEventResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ports.
   */
  portList?: DescribeDestinationPortEventResponseBodyPortList[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 9E7F6B2C-03F2-462F-9076-B782CF0DD502
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      portList: 'PortList',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      portList: { 'type': 'array', 'itemType': DescribeDestinationPortEventResponseBodyPortList },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDestinationPortEventResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDestinationPortEventResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDestinationPortEventResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainAttackEventsRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name of the website.
   * 
   * > A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.
   * 
   * @example
   * www.aliyun.com
   */
  domain?: string;
  /**
   * @remarks
   * The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.
   * 
   * > This UNIX timestamp must indicate a point in time that is accurate to the minute.
   * 
   * This parameter is required.
   * 
   * @example
   * 1583683200
   */
  endTime?: number;
  /**
   * @remarks
   * The number of the page to return. For example, to query the returned results on the first page, set the value to **1**.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * This parameter is required.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
   * 
   * @example
   * default
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.
   * 
   * > This UNIX timestamp must indicate a point in time that is accurate to the minute.
   * 
   * This parameter is required.
   * 
   * @example
   * 1582992000
   */
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
      endTime: 'EndTime',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      resourceGroupId: 'ResourceGroupId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
      endTime: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      resourceGroupId: 'string',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainAttackEventsResponseBody extends $tea.Model {
  /**
   * @remarks
   * An array that consists of the details of the DDoS attack event.
   */
  domainAttackEvents?: DescribeDomainAttackEventsResponseBodyDomainAttackEvents[];
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of returned DDoS attack events.
   * 
   * @example
   * 1
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      domainAttackEvents: 'DomainAttackEvents',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainAttackEvents: { 'type': 'array', 'itemType': DescribeDomainAttackEventsResponseBodyDomainAttackEvents },
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainAttackEventsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDomainAttackEventsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDomainAttackEventsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainOverviewRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name of the website that you want to query. If you leave this parameter unspecified, the statistics on all domain names are queried.
   * 
   * > The domain name must be added to Anti-DDoS Pro or Anti-DDoS Premium. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all the domain names that are added to Anti-DDoS Pro or Anti-DDoS Premium.
   * 
   * @example
   * example.aliyundoc.com
   */
  domain?: string;
  /**
   * @remarks
   * The end of the time range to query. The value is a UNIX timestamp. Unit: seconds. If you leave this parameter unspecified, the current system time is used as the end time.
   * 
   * > This UNIX timestamp must indicate a point in time that is accurate to the minute.
   * 
   * @example
   * 1623427200
   */
  endTime?: number;
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
   * 
   * For more information about resource groups, see [Create a resource group](https://help.aliyun.com/document_detail/94485.html).
   * 
   * @example
   * rg-acfm2pz25js****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.
   * 
   * > This UNIX timestamp must indicate a point in time that is accurate to the minute.
   * 
   * This parameter is required.
   * 
   * @example
   * 1619798400
   */
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
      endTime: 'EndTime',
      resourceGroupId: 'ResourceGroupId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
      endTime: 'number',
      resourceGroupId: 'string',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainOverviewResponseBody extends $tea.Model {
  /**
   * @remarks
   * The peak queries per second (QPS) during HTTP traffic scrubbing. Unit: QPS.
   * 
   * @example
   * 41652
   */
  maxHttp?: number;
  /**
   * @remarks
   * The peak QPS during HTTPS traffic scrubbing. Unit: QPS.
   * 
   * @example
   * 0
   */
  maxHttps?: number;
  /**
   * @remarks
   * The ID of the request, which is used to locate and troubleshoot issues.
   * 
   * @example
   * C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      maxHttp: 'MaxHttp',
      maxHttps: 'MaxHttps',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxHttp: 'number',
      maxHttps: 'number',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainOverviewResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDomainOverviewResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDomainOverviewResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainQPSListRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name of the website. If you do not specify this parameter, the statistics on the QPS of all domain names are queried.
   * 
   * > A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.
   * 
   * @example
   * www.aliyun.com
   */
  domain?: string;
  /**
   * @remarks
   * The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.
   * 
   * > This UNIX timestamp must indicate a point in time that is accurate to the minute.
   * 
   * This parameter is required.
   * 
   * @example
   * 1583683200
   */
  endTime?: number;
  /**
   * @remarks
   * The interval for returning data. Unit: seconds.
   * 
   * This parameter is required.
   * 
   * @example
   * 1000
   */
  interval?: number;
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
   * 
   * @example
   * default
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.
   * 
   * > This UNIX timestamp must indicate a point in time that is accurate to the minute.
   * 
   * This parameter is required.
   * 
   * @example
   * 1582992000
   */
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
      endTime: 'EndTime',
      interval: 'Interval',
      resourceGroupId: 'ResourceGroupId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
      endTime: 'number',
      interval: 'number',
      resourceGroupId: 'string',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainQPSListResponseBody extends $tea.Model {
  /**
   * @remarks
   * An array that consists of the statistics on the QPS of the website.
   */
  domainQPSList?: DescribeDomainQPSListResponseBodyDomainQPSList[];
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 327F2ABB-104D-437A-AAB5-D633E29A8C51
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      domainQPSList: 'DomainQPSList',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainQPSList: { 'type': 'array', 'itemType': DescribeDomainQPSListResponseBodyDomainQPSList },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainQPSListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDomainQPSListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDomainQPSListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainResourceRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name of the website that you want to query.
   * 
   * @example
   * www.example.com
   */
  domain?: string;
  /**
   * @remarks
   * An array that consists of the IDs of instances to query.
   */
  instanceIds?: string[];
  /**
   * @remarks
   * The number of the page to return. Default value: **1**.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * This parameter is required.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The match mode. Valid values:
   * 
   * *   **fuzzy**: fuzzy match. This is the default value.
   * *   **exact**: exact match.
   * 
   * @example
   * fuzzy
   */
  queryDomainPattern?: string;
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
      instanceIds: 'InstanceIds',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      queryDomainPattern: 'QueryDomainPattern',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
      instanceIds: { 'type': 'array', 'itemType': 'string' },
      pageNumber: 'number',
      pageSize: 'number',
      queryDomainPattern: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainResourceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 39499F01-19D9-4EA4-A0E9-C6014BA5CDBE
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of forwarding rules.
   * 
   * @example
   * 1
   */
  totalCount?: number;
  /**
   * @remarks
   * The configurations of the forwarding rule.
   */
  webRules?: DescribeDomainResourceResponseBodyWebRules[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      totalCount: 'TotalCount',
      webRules: 'WebRules',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      totalCount: 'number',
      webRules: { 'type': 'array', 'itemType': DescribeDomainResourceResponseBodyWebRules },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainResourceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDomainResourceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDomainResourceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainSecurityProfileRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name of the website.
   * 
   * > A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.
   * 
   * This parameter is required.
   * 
   * @example
   * example.aliyundoc.com
   */
  domain?: string;
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainSecurityProfileResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request, which is used to locate and troubleshoot issues.
   */
  requestId?: string;
  /**
   * @remarks
   * The returned results.
   */
  result?: DescribeDomainSecurityProfileResponseBodyResult[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: { 'type': 'array', 'itemType': DescribeDomainSecurityProfileResponseBodyResult },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainSecurityProfileResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDomainSecurityProfileResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDomainSecurityProfileResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainStatusCodeCountRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name of the website.
   * 
   * > A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.
   * 
   * @example
   * www.aliyun.com
   */
  domain?: string;
  /**
   * @remarks
   * The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.
   * 
   * > This UNIX timestamp must indicate a point in time that is accurate to the minute.
   * 
   * This parameter is required.
   * 
   * @example
   * 1583683200
   */
  endTime?: number;
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
   * 
   * @example
   * default
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.
   * 
   * > This UNIX timestamp must indicate a point in time that is accurate to the minute.
   * 
   * This parameter is required.
   * 
   * @example
   * 1582992000
   */
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
      endTime: 'EndTime',
      resourceGroupId: 'ResourceGroupId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
      endTime: 'number',
      resourceGroupId: 'string',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainStatusCodeCountResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E
   */
  requestId?: string;
  /**
   * @remarks
   * The number of 200 status codes within the specified period of time.
   * 
   * @example
   * 951159
   */
  status200?: number;
  /**
   * @remarks
   * The number of 2xx status codes within the specified period of time.
   * 
   * @example
   * 951472
   */
  status2XX?: number;
  /**
   * @remarks
   * The number of 3xx status codes within the specified period of time.
   * 
   * @example
   * 133209
   */
  status3XX?: number;
  /**
   * @remarks
   * The number of 403 status codes within the specified period of time.
   * 
   * @example
   * 0
   */
  status403?: number;
  /**
   * @remarks
   * The number of 404 status codes within the specified period of time.
   * 
   * @example
   * 897
   */
  status404?: number;
  /**
   * @remarks
   * The number of 405 status codes within the specified period of time.
   * 
   * @example
   * 0
   */
  status405?: number;
  /**
   * @remarks
   * The number of 4xx status codes within the specified period of time.
   * 
   * @example
   * 5653
   */
  status4XX?: number;
  /**
   * @remarks
   * The number of 501 status codes within the specified period of time.
   * 
   * @example
   * 0
   */
  status501?: number;
  /**
   * @remarks
   * The number of 502 status codes within the specified period of time.
   * 
   * @example
   * 0
   */
  status502?: number;
  /**
   * @remarks
   * The number of 503 status codes within the specified period of time.
   * 
   * @example
   * 0
   */
  status503?: number;
  /**
   * @remarks
   * The number of 504 status codes within the specified period of time.
   * 
   * @example
   * 0
   */
  status504?: number;
  /**
   * @remarks
   * The number of 5xx status codes within the specified period of time.
   * 
   * @example
   * 14
   */
  status5XX?: number;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      status200: 'Status200',
      status2XX: 'Status2XX',
      status3XX: 'Status3XX',
      status403: 'Status403',
      status404: 'Status404',
      status405: 'Status405',
      status4XX: 'Status4XX',
      status501: 'Status501',
      status502: 'Status502',
      status503: 'Status503',
      status504: 'Status504',
      status5XX: 'Status5XX',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      status200: 'number',
      status2XX: 'number',
      status3XX: 'number',
      status403: 'number',
      status404: 'number',
      status405: 'number',
      status4XX: 'number',
      status501: 'number',
      status502: 'number',
      status503: 'number',
      status504: 'number',
      status5XX: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainStatusCodeCountResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDomainStatusCodeCountResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDomainStatusCodeCountResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainStatusCodeListRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name of the website. If you do not specify this parameter, the statistics on response status codes of all domain names are queried.
   * 
   * > A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.
   * 
   * @example
   * www.aliyun.com
   */
  domain?: string;
  /**
   * @remarks
   * The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.
   * 
   * > This UNIX timestamp must indicate a point in time that is accurate to the minute.
   * 
   * @example
   * 1583683200
   */
  endTime?: number;
  /**
   * @remarks
   * The interval for returning data. Unit: seconds.
   * 
   * This parameter is required.
   * 
   * @example
   * 1000
   */
  interval?: number;
  /**
   * @remarks
   * The source of the statistics. Valid values:
   * 
   * *   **gf**: Anti-DDoS Pro or Anti-DDoS Premium
   * *   **upstrem**: origin server
   * 
   * This parameter is required.
   * 
   * @example
   * gf
   */
  queryType?: string;
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
   * 
   * @example
   * default
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The start time of the event. The value is a UNIX timestamp. Unit: seconds.
   * 
   * > This UNIX timestamp must indicate a point in time that is accurate to the minute.
   * 
   * This parameter is required.
   * 
   * @example
   * 1582992000
   */
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
      endTime: 'EndTime',
      interval: 'Interval',
      queryType: 'QueryType',
      resourceGroupId: 'ResourceGroupId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
      endTime: 'number',
      interval: 'number',
      queryType: 'string',
      resourceGroupId: 'string',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainStatusCodeListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 3B63C0DD-8AC5-44B2-95D6-064CA9296B9C
   */
  requestId?: string;
  /**
   * @remarks
   * The statistics on response status codes.
   */
  statusCodeList?: DescribeDomainStatusCodeListResponseBodyStatusCodeList[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      statusCodeList: 'StatusCodeList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      statusCodeList: { 'type': 'array', 'itemType': DescribeDomainStatusCodeListResponseBodyStatusCodeList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainStatusCodeListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDomainStatusCodeListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDomainStatusCodeListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainTopAttackListRequest extends $tea.Model {
  /**
   * @remarks
   * The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.
   * 
   * > This UNIX timestamp must indicate a point in time that is accurate to the minute.
   * 
   * This parameter is required.
   * 
   * @example
   * 1583683200
   */
  endTime?: number;
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
   * 
   * @example
   * default
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.
   * 
   * > This UNIX timestamp must indicate a point in time that is accurate to the minute.
   * 
   * This parameter is required.
   * 
   * @example
   * 1582992000
   */
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      resourceGroupId: 'ResourceGroupId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'number',
      resourceGroupId: 'string',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainTopAttackListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The peak QPS of the website.
   */
  attackList?: DescribeDomainTopAttackListResponseBodyAttackList[];
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      attackList: 'AttackList',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attackList: { 'type': 'array', 'itemType': DescribeDomainTopAttackListResponseBodyAttackList },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainTopAttackListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDomainTopAttackListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDomainTopAttackListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainViewSourceCountriesRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name of the website.
   * 
   * > A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.
   * 
   * @example
   * www.aliyun.com
   */
  domain?: string;
  /**
   * @remarks
   * The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.
   * 
   * > This UNIX timestamp must indicate a point in time that is accurate to the minute.
   * 
   * This parameter is required.
   * 
   * @example
   * 1583683200
   */
  endTime?: number;
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
   * 
   * @example
   * default
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.
   * 
   * > This UNIX timestamp must indicate a point in time that is accurate to the minute.
   * 
   * This parameter is required.
   * 
   * @example
   * 1582992000
   */
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
      endTime: 'EndTime',
      resourceGroupId: 'ResourceGroupId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
      endTime: 'number',
      resourceGroupId: 'string',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainViewSourceCountriesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E
   */
  requestId?: string;
  /**
   * @remarks
   * An array consisting of the country or area from which the requests are sent.
   */
  sourceCountrys?: DescribeDomainViewSourceCountriesResponseBodySourceCountrys[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      sourceCountrys: 'SourceCountrys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      sourceCountrys: { 'type': 'array', 'itemType': DescribeDomainViewSourceCountriesResponseBodySourceCountrys },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainViewSourceCountriesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDomainViewSourceCountriesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDomainViewSourceCountriesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainViewSourceProvincesRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name of the website.
   * 
   * > A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.
   * 
   * @example
   * www.aliyun.com
   */
  domain?: string;
  /**
   * @remarks
   * The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.
   * 
   * > This UNIX timestamp must indicate a point in time that is accurate to the minute.
   * 
   * This parameter is required.
   * 
   * @example
   * 1583683200
   */
  endTime?: number;
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
   * 
   * @example
   * default
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.
   * 
   * > This UNIX timestamp must indicate a point in time that is accurate to the minute.
   * 
   * This parameter is required.
   * 
   * @example
   * 1582992000
   */
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
      endTime: 'EndTime',
      resourceGroupId: 'ResourceGroupId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
      endTime: 'number',
      resourceGroupId: 'string',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainViewSourceProvincesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E
   */
  requestId?: string;
  /**
   * @remarks
   * An array consisting of the details of the administrative region in China from which the requests are sent.
   */
  sourceProvinces?: DescribeDomainViewSourceProvincesResponseBodySourceProvinces[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      sourceProvinces: 'SourceProvinces',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      sourceProvinces: { 'type': 'array', 'itemType': DescribeDomainViewSourceProvincesResponseBodySourceProvinces },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainViewSourceProvincesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDomainViewSourceProvincesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDomainViewSourceProvincesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainViewTopCostTimeRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name of the website.
   * 
   * > A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.
   * 
   * @example
   * www.aliyun.com
   */
  domain?: string;
  /**
   * @remarks
   * The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.
   * 
   * > This UNIX timestamp must indicate a point in time that is accurate to the minute.
   * 
   * This parameter is required.
   * 
   * @example
   * 1583683200
   */
  endTime?: number;
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
   * 
   * @example
   * default
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.
   * 
   * > This UNIX timestamp must indicate a point in time that is accurate to the minute.
   * 
   * This parameter is required.
   * 
   * @example
   * 1582992000
   */
  startTime?: number;
  /**
   * @remarks
   * The number of URLs to query. Valid values: **1** to **100**.
   * 
   * This parameter is required.
   * 
   * @example
   * 5
   */
  top?: number;
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
      endTime: 'EndTime',
      resourceGroupId: 'ResourceGroupId',
      startTime: 'StartTime',
      top: 'Top',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
      endTime: 'number',
      resourceGroupId: 'string',
      startTime: 'number',
      top: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainViewTopCostTimeResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E
   */
  requestId?: string;
  /**
   * @remarks
   * The URLs which require the longest time to respond to requests.
   */
  urlList?: DescribeDomainViewTopCostTimeResponseBodyUrlList[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      urlList: 'UrlList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      urlList: { 'type': 'array', 'itemType': DescribeDomainViewTopCostTimeResponseBodyUrlList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainViewTopCostTimeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDomainViewTopCostTimeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDomainViewTopCostTimeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainViewTopUrlRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name of the website.
   * 
   * > A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.
   * 
   * @example
   * www.aliyun.com
   */
  domain?: string;
  /**
   * @remarks
   * The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.
   * 
   * > This UNIX timestamp must indicate a point in time that is accurate to the minute.
   * 
   * This parameter is required.
   * 
   * @example
   * 1583683200
   */
  endTime?: number;
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
   * 
   * @example
   * default
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.
   * 
   * > This UNIX timestamp must indicate a point in time that is accurate to the minute.
   * 
   * This parameter is required.
   * 
   * @example
   * 1582992000
   */
  startTime?: number;
  /**
   * @remarks
   * The number of URLs to query. Valid values: **1** to **100**.
   * 
   * This parameter is required.
   * 
   * @example
   * 5
   */
  top?: number;
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
      endTime: 'EndTime',
      resourceGroupId: 'ResourceGroupId',
      startTime: 'StartTime',
      top: 'Top',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
      endTime: 'number',
      resourceGroupId: 'string',
      startTime: 'number',
      top: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainViewTopUrlResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E
   */
  requestId?: string;
  /**
   * @remarks
   * An array consisting of the URLs that receive the most requests.
   */
  urlList?: DescribeDomainViewTopUrlResponseBodyUrlList[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      urlList: 'UrlList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      urlList: { 'type': 'array', 'itemType': DescribeDomainViewTopUrlResponseBodyUrlList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainViewTopUrlResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDomainViewTopUrlResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDomainViewTopUrlResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainsRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the instance that you want to query.
   * 
   * > You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.
   * 
   * @example
   * ddoscoo-cn-mp91j1ao****
   */
  instanceIds?: string[];
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
   * 
   * For more information about resource groups, see [Create a resource group](https://help.aliyun.com/document_detail/94485.html).
   * 
   * @example
   * rg-acfm2pz25js****
   */
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceIds: 'InstanceIds',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceIds: { 'type': 'array', 'itemType': 'string' },
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainsResponseBody extends $tea.Model {
  /**
   * @remarks
   * An array consisting of details of the domain name for which the forwarding rules are configured.
   */
  domains?: string[];
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * F908E959-ADA8-4D7B-8A05-FF2F67F50964
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      domains: 'Domains',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domains: { 'type': 'array', 'itemType': 'string' },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDomainsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDomainsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeElasticBandwidthSpecRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the instance.
   * 
   * > You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.
   * 
   * This parameter is required.
   * 
   * @example
   * ddoscoo-cn-mp91j1ao****
   */
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeElasticBandwidthSpecResponseBody extends $tea.Model {
  /**
   * @remarks
   * An array that consists of the available burstable protection bandwidths. Unit: Gbit/s.
   */
  elasticBandwidthSpec?: string[];
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      elasticBandwidthSpec: 'ElasticBandwidthSpec',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      elasticBandwidthSpec: { 'type': 'array', 'itemType': 'string' },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeElasticBandwidthSpecResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeElasticBandwidthSpecResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeElasticBandwidthSpecResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeElasticQpsRequest extends $tea.Model {
  /**
   * @remarks
   * The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.
   * 
   * >  This UNIX timestamp must indicate a point in time that is accurate to the minute.
   * 
   * This parameter is required.
   * 
   * @example
   * 1684339200
   */
  endTime?: number;
  /**
   * @remarks
   * The sampling interval. Unit: seconds. The value must be a multiple of 60. Default value: 60. Unit: seconds. The query result varies depending on the sampling interval.
   * 
   * @example
   * 60
   */
  interval?: string;
  /**
   * @remarks
   * The IP address of the Anti-DDoS Proxy instance to query.
   * 
   * @example
   * 203.107.XX.XX
   */
  ip?: string;
  /**
   * @remarks
   * The type of the service. Valid values:
   * 
   * *   **cn**: Anti-DDoS Proxy (Chinese Mainland)
   * *   **cn-hongkong**: Anti-DDoS Proxy (Outside Chinese Mainland)
   * 
   * This parameter is required.
   * 
   * @example
   * cn
   */
  region?: string;
  /**
   * @remarks
   * The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.
   * 
   * >  This UNIX timestamp must indicate a point in time that is accurate to the minute.
   * 
   * This parameter is required.
   * 
   * @example
   * 1684252800
   */
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      interval: 'Interval',
      ip: 'Ip',
      region: 'Region',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'number',
      interval: 'string',
      ip: 'string',
      region: 'string',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeElasticQpsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about the burstable QPS.
   */
  elasticQps?: DescribeElasticQpsResponseBodyElasticQps[];
  /**
   * @remarks
   * The request ID, which is used to locate and troubleshoot issues.
   * 
   * @example
   * 2E7F7F7B-39A8-5D92-BAB4-D89D9DCE7D4F
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      elasticQps: 'ElasticQps',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      elasticQps: { 'type': 'array', 'itemType': DescribeElasticQpsResponseBodyElasticQps },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeElasticQpsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeElasticQpsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeElasticQpsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeElasticQpsRecordRequest extends $tea.Model {
  /**
   * @remarks
   * The end of the time range to query. The value is a timestamp. Unit: milliseconds.
   * 
   * This parameter is required.
   * 
   * @example
   * 1688140799999
   */
  endTime?: number;
  /**
   * @remarks
   * The IP address of the Anti-DDoS Proxy instance to query.
   * 
   * This parameter is required.
   * 
   * @example
   * 203.107.XX.XX
   */
  ip?: string;
  /**
   * @remarks
   * The beginning of the time range to query. The value is a timestamp. Unit: milliseconds.
   * 
   * This parameter is required.
   * 
   * @example
   * 1684252800000
   */
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      ip: 'Ip',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'number',
      ip: 'string',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeElasticQpsRecordResponseBody extends $tea.Model {
  /**
   * @remarks
   * The QPS information about the instance.
   */
  elasticQpsList?: DescribeElasticQpsRecordResponseBodyElasticQpsList[];
  /**
   * @remarks
   * The request ID, which is used to locate and troubleshoot issues.
   * 
   * @example
   * F68B34E2-570C-508D-95FD-DFB6611D518F
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      elasticQpsList: 'ElasticQpsList',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      elasticQpsList: { 'type': 'array', 'itemType': DescribeElasticQpsRecordResponseBodyElasticQpsList },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeElasticQpsRecordResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeElasticQpsRecordResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeElasticQpsRecordResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHeadersRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name that you want to query.
   * 
   * > You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all the domain names that are added to Anti-DDoS Pro or Anti-DDoS Premium.
   * 
   * This parameter is required.
   * 
   * @example
   * example.aliyundoc.com
   */
  domain?: string;
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
   * 
   * @example
   * rg-aek3cmuvpia****
   */
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHeadersResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about the custom header.
   */
  customHeader?: DescribeHeadersResponseBodyCustomHeader;
  /**
   * @remarks
   * The ID of the request, which is used to locate and troubleshoot issues.
   * 
   * @example
   * 48BC7BA5-69BE-5C31-A080-AFF2431AE48D
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      customHeader: 'CustomHeader',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      customHeader: DescribeHeadersResponseBodyCustomHeader,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHeadersResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeHeadersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeHeadersResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHealthCheckListRequest extends $tea.Model {
  /**
   * @remarks
   * The information about the port forwarding rule. This parameter is a JSON string. The string contains the following fields:
   * 
   * *   **InstanceId**: the ID of the instance. This field is required and must be of the STRING type.
   * *   **Protocol**: the forwarding protocol. This field is required and must be of the STRING type. Valid values: **tcp** and **udp**.
   * *   **FrontendPort**: the forwarding port. This field is required and must be of the INTEGER type.
   * 
   * This parameter is required.
   * 
   * @example
   * [{"InstanceId":"ddoscoo-cn-mp91j1ao****","Protocol":"tcp","FrontendPort":8080}]
   */
  networkRules?: string;
  static names(): { [key: string]: string } {
    return {
      networkRules: 'NetworkRules',
    };
  }

  static types(): { [key: string]: any } {
    return {
      networkRules: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHealthCheckListResponseBody extends $tea.Model {
  /**
   * @remarks
   * An array that consists of information about the health check configuration.
   */
  healthCheckList?: DescribeHealthCheckListResponseBodyHealthCheckList[];
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 83B4AF42-E8EE-4DC9-BD73-87B7733A36F9
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      healthCheckList: 'HealthCheckList',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      healthCheckList: { 'type': 'array', 'itemType': DescribeHealthCheckListResponseBodyHealthCheckList },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHealthCheckListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeHealthCheckListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeHealthCheckListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHealthCheckStatusRequest extends $tea.Model {
  /**
   * @remarks
   * An array that consists of the details of the port forwarding rule. This parameter is a JSON string. The string contains the following fields:
   * 
   * *   **InstanceId**: the ID of the instance. This field is required and must be of the STRING type.
   * *   **Protocol**: the forwarding protocol. This field is required and must be of the STRING type. Valid values: **tcp** and **udp**.
   * *   **FrontendPort**: the forwarding port. This field is required and must be of the INTEGER type.
   * 
   * This parameter is required.
   * 
   * @example
   * [{"InstanceId":"ddoscoo-cn-mp91j1ao****","Protocol":"tcp","FrontendPort":8080}]
   */
  networkRules?: string;
  static names(): { [key: string]: string } {
    return {
      networkRules: 'NetworkRules',
    };
  }

  static types(): { [key: string]: any } {
    return {
      networkRules: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHealthCheckStatusResponseBody extends $tea.Model {
  /**
   * @remarks
   * An array that consists of the details of the health status of the origin server.
   */
  healthCheckStatus?: DescribeHealthCheckStatusResponseBodyHealthCheckStatus[];
  /**
   * @remarks
   * The ID of the request, which is used to locate and troubleshoot issues.
   * 
   * @example
   * DE9FF9E1-569C-4B6C-AB6A-0F6D927BB27C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      healthCheckStatus: 'HealthCheckStatus',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      healthCheckStatus: { 'type': 'array', 'itemType': DescribeHealthCheckStatusResponseBodyHealthCheckStatus },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHealthCheckStatusResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeHealthCheckStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeHealthCheckStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceDetailsRequest extends $tea.Model {
  /**
   * @remarks
   * An array that consists of the IDs of instances to query.
   * 
   * This parameter is required.
   */
  instanceIds?: string[];
  static names(): { [key: string]: string } {
    return {
      instanceIds: 'InstanceIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceIds: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceDetailsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The IP address and ISP line information about the instance.
   */
  instanceDetails?: DescribeInstanceDetailsResponseBodyInstanceDetails[];
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 3C814429-21A5-4673-827E-FDD19DC75681
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceDetails: 'InstanceDetails',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceDetails: { 'type': 'array', 'itemType': DescribeInstanceDetailsResponseBodyInstanceDetails },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceDetailsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeInstanceDetailsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeInstanceDetailsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceExtRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the instance.
   * 
   * >  You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.
   * 
   * @example
   * ddoscoo-cn-i7m25564****
   */
  instanceId?: string;
  /**
   * @remarks
   * The number of the page. For example, to query the returned results on the first page, set the value to **1**.
   * 
   * @example
   * 1
   */
  pageNumber?: string;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 10
   */
  pageSize?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      pageNumber: 'string',
      pageSize: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceExtResponseBody extends $tea.Model {
  /**
   * @remarks
   * The extended information about the Anti-DDoS Proxy instance.
   */
  instanceExtSpecs?: DescribeInstanceExtResponseBodyInstanceExtSpecs[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * CF33B4C3-196E-4015-AADD-5CAD00057B80
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of queried instances.
   * 
   * @example
   * 10
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      instanceExtSpecs: 'InstanceExtSpecs',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceExtSpecs: { 'type': 'array', 'itemType': DescribeInstanceExtResponseBodyInstanceExtSpecs },
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceExtResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeInstanceExtResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeInstanceExtResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceIdsRequest extends $tea.Model {
  /**
   * @remarks
   * The type of the instance to query. Valid values:
   * 
   * *   **0**: Anti-DDoS Proxy (Outside Chinese Mainland) instance of the Insurance mitigation plan
   * *   **1**: Anti-DDoS Proxy (Outside Chinese Mainland) instance of the Unlimited mitigation plan
   * *   **2**: Anti-DDoS Proxy (Outside Chinese Mainland) instance of the Chinese Mainland Acceleration (CMA) mitigation plan
   * *   **3**: Anti-DDoS Proxy (Outside Chinese Mainland) instance of the Secure Chinese Mainland Acceleration (Sec-CMA) mitigation plan
   * *   **9**: Anti-DDoS Proxy (Chinese Mainland) instance of the Profession mitigation plan
   * 
   * @example
   * 9
   */
  edition?: number;
  /**
   * @remarks
   * The IDs of instances to query.
   * 
   * @example
   * ddoscoo-cn-mp91j1ao****
   */
  instanceIds?: string[];
  /**
   * @example
   * rg-acfm2pz25js****
   */
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      edition: 'Edition',
      instanceIds: 'InstanceIds',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      edition: 'number',
      instanceIds: { 'type': 'array', 'itemType': 'string' },
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceIdsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID, type, description, and IP version of the instance.
   */
  instanceIds?: DescribeInstanceIdsResponseBodyInstanceIds[];
  /**
   * @example
   * 310A41FD-0990-5610-92E0-A6A55D7C6444
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceIds: 'InstanceIds',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceIds: { 'type': 'array', 'itemType': DescribeInstanceIdsResponseBodyInstanceIds },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceIdsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeInstanceIdsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeInstanceIdsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceSpecsRequest extends $tea.Model {
  /**
   * @remarks
   * An array that consists of the IDs of instances to query.
   * 
   * This parameter is required.
   */
  instanceIds?: string[];
  static names(): { [key: string]: string } {
    return {
      instanceIds: 'InstanceIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceIds: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceSpecsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details of the specifications of the instance.
   */
  instanceSpecs?: DescribeInstanceSpecsResponseBodyInstanceSpecs[];
  /**
   * @remarks
   * The ID of the request, which is used to locate and troubleshoot issues.
   * 
   * @example
   * 4E3A9B5F-5DDB-593D-A1E6-F1F451DB5E0B
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceSpecs: 'InstanceSpecs',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceSpecs: { 'type': 'array', 'itemType': DescribeInstanceSpecsResponseBodyInstanceSpecs },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceSpecsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeInstanceSpecsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeInstanceSpecsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceStatisticsRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the instance that you want to query.
   * 
   * > You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.
   * 
   * This parameter is required.
   * 
   * @example
   * ddoscoo-cn-mp91j1ao****
   */
  instanceIds?: string[];
  static names(): { [key: string]: string } {
    return {
      instanceIds: 'InstanceIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceIds: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceStatisticsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The statistics on the instance.
   */
  instanceStatistics?: DescribeInstanceStatisticsResponseBodyInstanceStatistics[];
  /**
   * @remarks
   * The ID of the request, which is used to locate and troubleshoot issues.
   * 
   * @example
   * 642319A9-D1F2-4459-A447-E57CFC599FDE
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceStatistics: 'InstanceStatistics',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceStatistics: { 'type': 'array', 'itemType': DescribeInstanceStatisticsResponseBodyInstanceStatistics },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceStatisticsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeInstanceStatisticsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeInstanceStatisticsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceStatusRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the Anti-DDoS Proxy instance to query.
   * 
   * >  You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all Anti-DDoS Proxy (Chinese Mainland) or Anti-DDoS Proxy (Outside Chinese Mainland) instances.
   * 
   * This parameter is required.
   * 
   * @example
   * ddoscoo-cn-6ja1y6p5****
   */
  instanceId?: string;
  /**
   * @remarks
   * The type of the Anti-DDoS Proxy instance to query. Valid values:
   * 
   * *   **1**: an Anti-DDoS Proxy (Chinese Mainland) instance
   * *   **2**: an Anti-DDoS Proxy (Outside Chinese Mainland) instance
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  productType?: number;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      productType: 'ProductType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      productType: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceStatusResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * ddoscoo-cn-6ja1y6p5****
   */
  instanceId?: string;
  /**
   * @remarks
   * The status of the instance. Valid values:
   * 
   * *   **1**: normal
   * *   **2**: expired
   * *   **3**: overdue
   * *   **4**: released
   * 
   * @example
   * 1
   */
  instanceStatus?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 112777CC-2AD6-46FC-A263-00B931406FCD
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      instanceStatus: 'InstanceStatus',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      instanceStatus: 'number',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceStatusResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeInstanceStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeInstanceStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancesRequest extends $tea.Model {
  /**
   * @remarks
   * The mitigation plan of the instance to query. Valid values:
   * 
   * *   **0**: Anti-DDoS Proxy (Outside Chinese Mainland) instance of the Insurance mitigation plan
   * *   **1**: Anti-DDoS Proxy (Outside Chinese Mainland) instance of the Unlimited mitigation plan
   * *   **2**: Anti-DDoS Proxy (Outside Chinese Mainland) instance of the Chinese Mainland Acceleration (CMA) mitigation plan
   * *   **9**: Anti-DDoS Proxy (Chinese Mainland) instance of the Profession mitigation plan
   * 
   * @example
   * 9
   */
  edition?: number;
  /**
   * @remarks
   * The traffic forwarding status of the instance to query. Valid values:
   * 
   * *   **0**: The instance no longer forwards service traffic.
   * *   **1**: The instance forwards service traffic as expected.
   * 
   * @example
   * 1
   */
  enabled?: number;
  /**
   * @remarks
   * The end of the time range to query. Instances whose expiration time is earlier than the point in time are queried. This value is a UNIX timestamp. Unit: milliseconds.
   * 
   * @example
   * 1640361700000
   */
  expireEndTime?: number;
  /**
   * @remarks
   * The beginning of the time range to query. Instances whose expiration time is later than the point in time are queried. This value is a UNIX timestamp. Unit: milliseconds.
   * 
   * @example
   * 1640361500000
   */
  expireStartTime?: number;
  /**
   * @remarks
   * The IDs of the instances to query. You can specify up to 200 instance IDs.
   */
  instanceIds?: string[];
  /**
   * @remarks
   * The IP address of the instance to query.
   * 
   * @example
   * 203.107.XX.XX
   */
  ip?: string;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  pageNumber?: string;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * This parameter is required.
   * 
   * @example
   * 10
   */
  pageSize?: string;
  /**
   * @remarks
   * The remarks of the instance to query. Fuzzy match is supported.
   * 
   * @example
   * doc-test
   */
  remark?: string;
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management.
   * 
   * If you do not specify this parameter, the instance belongs to the default resource group.
   * 
   * @example
   * rg-acfm2pz25js****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The states of the instances to query. You can specify up to two states.
   */
  status?: number[];
  /**
   * @remarks
   * The tags that are added to the instances to query.
   */
  tag?: DescribeInstancesRequestTag[];
  static names(): { [key: string]: string } {
    return {
      edition: 'Edition',
      enabled: 'Enabled',
      expireEndTime: 'ExpireEndTime',
      expireStartTime: 'ExpireStartTime',
      instanceIds: 'InstanceIds',
      ip: 'Ip',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      remark: 'Remark',
      resourceGroupId: 'ResourceGroupId',
      status: 'Status',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      edition: 'number',
      enabled: 'number',
      expireEndTime: 'number',
      expireStartTime: 'number',
      instanceIds: { 'type': 'array', 'itemType': 'string' },
      ip: 'string',
      pageNumber: 'string',
      pageSize: 'string',
      remark: 'string',
      resourceGroupId: 'string',
      status: { 'type': 'array', 'itemType': 'number' },
      tag: { 'type': 'array', 'itemType': DescribeInstancesRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details about the instances.
   */
  instances?: DescribeInstancesResponseBodyInstances[];
  /**
   * @remarks
   * The ID of the request, which is used to locate and troubleshoot issues.
   * 
   * @example
   * A0AF40CC-814A-5A86-AEAA-6F19E88B8A39
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of the instances.
   * 
   * @example
   * 1
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      instances: 'Instances',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instances: { 'type': 'array', 'itemType': DescribeInstancesResponseBodyInstances },
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeInstancesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeInstancesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeL7RsPolicyRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name of the website to query.
   * 
   * > A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query the domain names for which forwarding rules are configured.
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domain?: string;
  /**
   * @remarks
   * An array that consists of N addresses of origin servers to query. The maximum value of N is 200. You can specify up to 200 addresses.
   * 
   * @example
   * 1.***.***.1
   */
  realServers?: string[];
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
   * 
   * For more information about resource groups, see [Create a resource group](https://help.aliyun.com/document_detail/94485.html).
   * 
   * @example
   * rg-acfm2pz25js****
   */
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
      realServers: 'RealServers',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
      realServers: { 'type': 'array', 'itemType': 'string' },
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeL7RsPolicyResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details about the parameters for back-to-origin processing.
   */
  attributes?: DescribeL7RsPolicyResponseBodyAttributes[];
  /**
   * @remarks
   * The scheduling algorithm for back-to-origin traffic. Valid values:
   * 
   * *   **ip_hash**: the IP hash algorithm. This algorithm is used to redirect the requests from the same IP address to the same origin server.
   * *   **rr**: the round-robin algorithm. This algorithm is used to redirect requests to origin servers in turn.
   * *   **least_time**: the least response time algorithm. This algorithm is used to minimize the latency when requests are forwarded from Anti-DDoS Pro or Anti-DDoS Premium instances to origin servers based on the intelligent DNS resolution feature.
   * 
   * @example
   * rr
   */
  proxyMode?: string;
  /**
   * @remarks
   * The ID of the request, which is used to locate and troubleshoot issues.
   * 
   * @example
   * 9E7F6B2C-03F2-462F-9076-B782CF0DD502
   */
  requestId?: string;
  /**
   * @remarks
   * The back-to-origin retry switch. Valid values:
   * 
   * *   **1**: on
   * *   **0**: off
   * 
   * @example
   * 1
   */
  upstreamRetry?: number;
  static names(): { [key: string]: string } {
    return {
      attributes: 'Attributes',
      proxyMode: 'ProxyMode',
      requestId: 'RequestId',
      upstreamRetry: 'UpstreamRetry',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attributes: { 'type': 'array', 'itemType': DescribeL7RsPolicyResponseBodyAttributes },
      proxyMode: 'string',
      requestId: 'string',
      upstreamRetry: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeL7RsPolicyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeL7RsPolicyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeL7RsPolicyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeL7UsKeepaliveRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name of the website.
   * 
   * >  A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.
   * 
   * @example
   * www.aliyun.com
   */
  domain?: string;
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeL7UsKeepaliveResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 39499F01-19D9-4EA4-A0E9-C6014BA5CDBE
   */
  requestId?: string;
  /**
   * @remarks
   * The value of the Back-to-origin Persistent Connections parameter.
   */
  rsKeepalive?: DescribeL7UsKeepaliveResponseBodyRsKeepalive;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      rsKeepalive: 'RsKeepalive',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      rsKeepalive: DescribeL7UsKeepaliveResponseBodyRsKeepalive,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeL7UsKeepaliveResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeL7UsKeepaliveResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeL7UsKeepaliveResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLayer4RulePolicyRequest extends $tea.Model {
  /**
   * @remarks
   * The port forwarding rule that you want to query.
   * 
   * This parameter is a string that consists of JSON arrays. Each element in a JSON array indicates a port forwarding rule. You can query only one port forwarding rule at a time.
   * 
   * > You can call the [DescribeNetworkRules](https://help.aliyun.com/document_detail/157484.html) to query existing port forwarding rules.
   * 
   * Each port forwarding rule contains the following fields:
   * 
   * *   **InstanceId**: the ID of the instance. This field is required and must be of the string type.
   * *   **Protocol**: the forwarding protocol. This field is required and must be of the string type. Valid values: **tcp** and **udp**.
   * *   **FrontendPort**: the forwarding port. This field is required and must be of the integer type.
   * 
   * This parameter is required.
   * 
   * @example
   * [{\\"InstanceId\\":\\"ddosDip-sg-4hr2b3l****\\",\\"FrontendPort\\":2020,\\"Protocol\\":\\"udp\\"}]
   */
  listeners?: string;
  static names(): { [key: string]: string } {
    return {
      listeners: 'Listeners',
    };
  }

  static types(): { [key: string]: any } {
    return {
      listeners: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLayer4RulePolicyResponseBody extends $tea.Model {
  /**
   * @remarks
   * The port of the origin server.
   * 
   * @example
   * 2022
   */
  backendPort?: number;
  /**
   * @remarks
   * The mode that is used to forward service traffic. Valid values:
   * 
   * *   0: the default mode. In this mode, Anti-DDoS Pro or Anti-DDoS Premium forwards service traffic to the origin IP address that you specified when you created the port forwarding rule. You can call the [CreateNetworkRules](https://help.aliyun.com/document_detail/157482.html) operation to create a port forwarding rule.
   * *   1: the origin redundancy mode. In this mode, Anti-DDoS Pro or Anti-DDoS Premium forwards service traffic to the IP addresses of the primary or secondary origin servers. You can call the [ConfigLayer4RulePolicy](https://help.aliyun.com/document_detail/312684.html) operation to configure IP addresses.
   * 
   * @example
   * 1
   */
  bakMode?: string;
  /**
   * @remarks
   * The origin server that is used to receive service traffic. Valid values:
   * 
   * *   **1**: the primary origin server, which indicates that Anti-DDoS Pro or Anti-DDoS Premium forwards service traffic to the IP addresses of the primary origin server.
   * *   **2**: the secondary origin server, which indicates that Anti-DDoS Pro or Anti-DDoS Premium forwards service traffic to the IP addresses of the secondary origin server.
   * 
   * @example
   * 1
   */
  currentIndex?: number;
  /**
   * @remarks
   * The type of the protocol.
   * 
   * @example
   * udp
   */
  forwardProtocol?: string;
  /**
   * @remarks
   * The forwarding port.
   * 
   * @example
   * 2020
   */
  frontendPort?: number;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * ddosDip-sg-4hr2b3l****
   */
  instanceId?: string;
  /**
   * @remarks
   * An array that consists of the information about the primary origin server, including the IP addresses, forwarding protocol, and forwarding port.
   */
  priRealServers?: DescribeLayer4RulePolicyResponseBodyPriRealServers[];
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 6E46CC51-36BE-1100-B14C-DAF8381B8F73
   */
  requestId?: string;
  /**
   * @remarks
   * An array that consists of the information about the secondary origin server, including the IP addresses, forwarding protocol, and forwarding port.
   */
  secRealServers?: DescribeLayer4RulePolicyResponseBodySecRealServers[];
  static names(): { [key: string]: string } {
    return {
      backendPort: 'BackendPort',
      bakMode: 'BakMode',
      currentIndex: 'CurrentIndex',
      forwardProtocol: 'ForwardProtocol',
      frontendPort: 'FrontendPort',
      instanceId: 'InstanceId',
      priRealServers: 'PriRealServers',
      requestId: 'RequestId',
      secRealServers: 'SecRealServers',
    };
  }

  static types(): { [key: string]: any } {
    return {
      backendPort: 'number',
      bakMode: 'string',
      currentIndex: 'number',
      forwardProtocol: 'string',
      frontendPort: 'number',
      instanceId: 'string',
      priRealServers: { 'type': 'array', 'itemType': DescribeLayer4RulePolicyResponseBodyPriRealServers },
      requestId: 'string',
      secRealServers: { 'type': 'array', 'itemType': DescribeLayer4RulePolicyResponseBodySecRealServers },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLayer4RulePolicyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeLayer4RulePolicyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLayer4RulePolicyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLogStoreExistStatusRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
   * 
   * @example
   * default
   */
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLogStoreExistStatusResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether a Logstore is created for Anti-DDoS Pro or Anti-DDoS Premium. Valid values:
   * 
   * *   **true**: yes
   * *   **false**: no
   * 
   * @example
   * true
   */
  existStatus?: boolean;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CF33B4C3-196E-4015-AADD-5CAD00057B80
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      existStatus: 'ExistStatus',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      existStatus: 'boolean',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLogStoreExistStatusResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeLogStoreExistStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLogStoreExistStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNetworkRegionBlockRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the instance.
   * 
   * > You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.
   * 
   * This parameter is required.
   * 
   * @example
   * ddoscoo-cn-mp91j1ao****
   */
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNetworkRegionBlockResponseBody extends $tea.Model {
  /**
   * @remarks
   * The configuration of blocked locations.
   */
  config?: DescribeNetworkRegionBlockResponseBodyConfig;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      config: 'Config',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      config: DescribeNetworkRegionBlockResponseBodyConfig,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNetworkRegionBlockResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeNetworkRegionBlockResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeNetworkRegionBlockResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNetworkRuleAttributesRequest extends $tea.Model {
  /**
   * @remarks
   * The details of the port forwarding rule. This parameter is a JSON string. The string contains the following fields:
   * 
   * *   **InstanceId**: the ID of the instance. This field is required and must be of the STRING type.
   * *   **Protocol**: the forwarding protocol. This field is required and must be of the STRING type. Valid values: **tcp** and **udp**.
   * *   **FrontendPort**: the forwarding port. This field is required and must be of the INTEGER type.
   * 
   * This parameter is required.
   * 
   * @example
   * [{"InstanceId":"ddoscoo-cn-mp91j1ao****","Protocol":"tcp","FrontendPort":8080}]
   */
  networkRules?: string;
  static names(): { [key: string]: string } {
    return {
      networkRules: 'NetworkRules',
    };
  }

  static types(): { [key: string]: any } {
    return {
      networkRules: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNetworkRuleAttributesResponseBody extends $tea.Model {
  /**
   * @remarks
   * An array that consists of the mitigation settings of the port forwarding rule for a non-website service. The mitigation settings include session persistence and DDoS mitigation policies.
   */
  networkRuleAttributes?: DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributes[];
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * F9F2F77D-307C-4F15-8D02-AB5957EEBF97
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      networkRuleAttributes: 'NetworkRuleAttributes',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      networkRuleAttributes: { 'type': 'array', 'itemType': DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributes },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNetworkRuleAttributesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeNetworkRuleAttributesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeNetworkRuleAttributesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNetworkRulesRequest extends $tea.Model {
  /**
   * @remarks
   * The forwarding protocol. Valid values:
   * 
   * *   **tcp**
   * *   **udp**
   * 
   * @example
   * tcp
   */
  forwardProtocol?: string;
  /**
   * @remarks
   * The forwarding port.
   * 
   * @example
   * 80
   */
  frontendPort?: number;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * > You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.
   * 
   * This parameter is required.
   * 
   * @example
   * ddoscoo-cn-mp91j1ao****
   */
  instanceId?: string;
  /**
   * @remarks
   * The number of the page to return. For example, to query the returned results on the first page, set the value to **1**.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * This parameter is required.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      forwardProtocol: 'ForwardProtocol',
      frontendPort: 'FrontendPort',
      instanceId: 'InstanceId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      forwardProtocol: 'string',
      frontendPort: 'number',
      instanceId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNetworkRulesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details of a port forwarding rule.
   */
  networkRules?: DescribeNetworkRulesResponseBodyNetworkRules[];
  /**
   * @remarks
   * The ID of the request, which is used to locate and troubleshoot issues.
   * 
   * @example
   * 8597F235-FA5E-4FC7-BAD9-E4C0B01BC771
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of returned port forwarding rules.
   * 
   * @example
   * 1
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      networkRules: 'NetworkRules',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      networkRules: { 'type': 'array', 'itemType': DescribeNetworkRulesResponseBodyNetworkRules },
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNetworkRulesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeNetworkRulesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeNetworkRulesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOpEntitiesRequest extends $tea.Model {
  /**
   * @remarks
   * The end of the time range to query. The value is a UNIX timestamp. Unit: milliseconds.
   * 
   * > The time must be in the latest 30 days.
   * 
   * This parameter is required.
   * 
   * @example
   * 1583683200000
   */
  endTime?: number;
  /**
   * @remarks
   * The operation object that you want to query.
   * 
   * @example
   * 203.***.***.132
   */
  entityObject?: string;
  /**
   * @remarks
   * The type of the operation object that you want to query. Valid values:
   * 
   * *   **1**: the IP address of the Anti-DDoS Pro or Anti-DDoS Premium instance
   * *   **2**: Anti-DDoS plans
   * *   **3**: ECS instances
   * *   **4**: all logs
   * 
   * @example
   * 1
   */
  entityType?: number;
  /**
   * @remarks
   * The number of the page to return. For example, to query the returned results on the first page, set the value to **1**.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page. Maximum value: **50**.
   * 
   * This parameter is required.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
   * 
   * @example
   * default
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The beginning of the time range to query. The value is a UNIX timestamp. Unit: milliseconds.
   * 
   * > The time must be in the latest 30 days.
   * 
   * This parameter is required.
   * 
   * @example
   * 1582992000000
   */
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      entityObject: 'EntityObject',
      entityType: 'EntityType',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      resourceGroupId: 'ResourceGroupId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'number',
      entityObject: 'string',
      entityType: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      resourceGroupId: 'string',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOpEntitiesResponseBody extends $tea.Model {
  /**
   * @remarks
   * An array that consists of the details of the operation log.
   */
  opEntities?: DescribeOpEntitiesResponseBodyOpEntities[];
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * FB24D70C-71F5-4000-8CD8-22CDA0C53CD1
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of returned operation records.
   * 
   * @example
   * 1
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      opEntities: 'OpEntities',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      opEntities: { 'type': 'array', 'itemType': DescribeOpEntitiesResponseBodyOpEntities },
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOpEntitiesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeOpEntitiesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeOpEntitiesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePortRequest extends $tea.Model {
  /**
   * @remarks
   * The forwarding port to query. Valid values: **0** to **65535**.
   * 
   * @example
   * 55
   */
  frontendPort?: number;
  /**
   * @remarks
   * The type of the forwarding protocol to query. Valid values:
   * 
   * *   **tcp**
   * *   **udp**
   * 
   * @example
   * tcp
   */
  frontendProtocol?: string;
  /**
   * @remarks
   * The ID of the instance to query.
   * 
   * > You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.
   * 
   * This parameter is required.
   * 
   * @example
   * ddoscoo-cn-7e225i41****
   */
  instanceId?: string;
  /**
   * @remarks
   * The number of the page to return. For example, if you want to obtain results on the first page, set the value to **1**.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * This parameter is required.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      frontendPort: 'FrontendPort',
      frontendProtocol: 'FrontendProtocol',
      instanceId: 'InstanceId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      frontendPort: 'number',
      frontendProtocol: 'string',
      instanceId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePortResponseBody extends $tea.Model {
  /**
   * @remarks
   * An array that consists of port forwarding rules.
   */
  networkRules?: DescribePortResponseBodyNetworkRules[];
  /**
   * @remarks
   * The ID of the request, which is used to locate and troubleshoot issues.
   * 
   * @example
   * 39499F01-19D9-4EA4-A0E9-C6014BA5CDBE
   */
  requestId?: string;
  /**
   * @remarks
   * The number of port forwarding rules returned.
   * 
   * @example
   * 1
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      networkRules: 'NetworkRules',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      networkRules: { 'type': 'array', 'itemType': DescribePortResponseBodyNetworkRules },
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePortResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribePortResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribePortResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePortAttackMaxFlowRequest extends $tea.Model {
  /**
   * @remarks
   * The end of the time range to query. This value is a UNIX timestamp. Unit: seconds.
   * 
   * > This UNIX timestamp must indicate a point in time that is accurate to the minute.
   * 
   * This parameter is required.
   * 
   * @example
   * 1583683200
   */
  endTime?: number;
  /**
   * @remarks
   * An array that consists of the IDs of instances to query.
   * 
   * This parameter is required.
   * 
   * @example
   * ddoscoo-cn-mp91j1ao****
   */
  instanceIds?: string[];
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management.
   * 
   * If you do not configure this parameter, the instance belongs to the default resource group.
   * 
   * @example
   * rg-acfm2pz25js****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The beginning of the time range to query. This value is a UNIX timestamp. Unit: seconds.
   * 
   * > This UNIX timestamp must indicate a point in time that is accurate to the minute.
   * 
   * This parameter is required.
   * 
   * @example
   * 1582992000
   */
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      instanceIds: 'InstanceIds',
      resourceGroupId: 'ResourceGroupId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'number',
      instanceIds: { 'type': 'array', 'itemType': 'string' },
      resourceGroupId: 'string',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePortAttackMaxFlowResponseBody extends $tea.Model {
  /**
   * @remarks
   * The peak bandwidth of attack traffic. Unit: bit/s.
   * 
   * @example
   * 149559
   */
  bps?: number;
  /**
   * @remarks
   * The peak packet rate of attack traffic . Unit: packets per second (pps).
   * 
   * @example
   * 23
   */
  pps?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      bps: 'Bps',
      pps: 'Pps',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bps: 'number',
      pps: 'number',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePortAttackMaxFlowResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribePortAttackMaxFlowResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribePortAttackMaxFlowResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePortAutoCcStatusRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the instance.
   * 
   * > You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.
   * 
   * This parameter is required.
   * 
   * @example
   * ddoscoo-cn-mp91j1ao****
   */
  instanceIds?: string[];
  static names(): { [key: string]: string } {
    return {
      instanceIds: 'InstanceIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceIds: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePortAutoCcStatusResponseBody extends $tea.Model {
  /**
   * @remarks
   * An array that consists of the configurations of the Intelligent Protection policy.
   */
  portAutoCcStatus?: DescribePortAutoCcStatusResponseBodyPortAutoCcStatus[];
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * BC3C6403-F248-4125-B2C9-8733ED94EA85
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      portAutoCcStatus: 'PortAutoCcStatus',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      portAutoCcStatus: { 'type': 'array', 'itemType': DescribePortAutoCcStatusResponseBodyPortAutoCcStatus },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePortAutoCcStatusResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribePortAutoCcStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribePortAutoCcStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePortCcAttackTopIPRequest extends $tea.Model {
  /**
   * @remarks
   * The IP address of the Anti-DDoS Pro or Anti-DDoS Premium instance to query.
   * 
   * This parameter is required.
   * 
   * @example
   * 203.107.XX.XX
   */
  ip?: string;
  /**
   * @remarks
   * The maximum number of entries to return.
   * 
   * @example
   * 10
   */
  limit?: number;
  /**
   * @remarks
   * The attacked port.
   * 
   * This parameter is required.
   * 
   * @example
   * 6663
   */
  port?: string;
  /**
   * @remarks
   * The beginning of the time range to query. Unit: seconds.
   * 
   * This parameter is required.
   * 
   * @example
   * 1678017453
   */
  startTimestamp?: number;
  static names(): { [key: string]: string } {
    return {
      ip: 'Ip',
      limit: 'Limit',
      port: 'Port',
      startTimestamp: 'StartTimestamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ip: 'string',
      limit: 'number',
      port: 'string',
      startTimestamp: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePortCcAttackTopIPResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID, which is used to locate and troubleshoot issues.
   * 
   * @example
   * 24F36D81-5E2D-52E5-9DB6-A3ED23CF271A
   */
  requestId?: string;
  /**
   * @remarks
   * The information about the source IP address of the attack.
   */
  topIp?: DescribePortCcAttackTopIPResponseBodyTopIp[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      topIp: 'TopIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      topIp: { 'type': 'array', 'itemType': DescribePortCcAttackTopIPResponseBodyTopIp },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePortCcAttackTopIPResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribePortCcAttackTopIPResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribePortCcAttackTopIPResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePortConnsCountRequest extends $tea.Model {
  /**
   * @remarks
   * The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.
   * 
   * > This UNIX timestamp must indicate a point in time that is accurate to the minute.
   * 
   * This parameter is required.
   * 
   * @example
   * 1583683200
   */
  endTime?: number;
  /**
   * @remarks
   * An array that consists of the IDs of instances.
   * 
   * > You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.
   * 
   * This parameter is required.
   * 
   * @example
   * ddoscoo-cn-mp91j1ao****
   */
  instanceIds?: string[];
  /**
   * @remarks
   * The number of port that you want to query. If you do not specify this parameter, all ports are queried.
   * 
   * @example
   * 80
   */
  port?: string;
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
   * 
   * @example
   * default
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.
   * 
   * > This UNIX timestamp must indicate a point in time that is accurate to the minute.
   * 
   * This parameter is required.
   * 
   * @example
   * 1582992000
   */
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      instanceIds: 'InstanceIds',
      port: 'Port',
      resourceGroupId: 'ResourceGroupId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'number',
      instanceIds: { 'type': 'array', 'itemType': 'string' },
      port: 'string',
      resourceGroupId: 'string',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePortConnsCountResponseBody extends $tea.Model {
  /**
   * @remarks
   * The number of active connections.
   * 
   * @example
   * 159
   */
  actConns?: number;
  /**
   * @remarks
   * The number of concurrent connections.
   * 
   * @example
   * 46340
   */
  conns?: number;
  /**
   * @remarks
   * The number of new connections.
   * 
   * @example
   * 0
   */
  cps?: number;
  /**
   * @remarks
   * The number of inactive connections.
   * 
   * @example
   * 121
   */
  inActConns?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 48859E14-A9FB-4100-99FF-AAB75CA46776
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      actConns: 'ActConns',
      conns: 'Conns',
      cps: 'Cps',
      inActConns: 'InActConns',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actConns: 'number',
      conns: 'number',
      cps: 'number',
      inActConns: 'number',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePortConnsCountResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribePortConnsCountResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribePortConnsCountResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePortConnsListRequest extends $tea.Model {
  /**
   * @remarks
   * The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.
   * 
   * > This UNIX timestamp must indicate a point in time that is accurate to the minute.
   * 
   * This parameter is required.
   * 
   * @example
   * 1583683200
   */
  endTime?: number;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * > You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.
   * 
   * This parameter is required.
   * 
   * @example
   * ddoscoo-cn-mp91j1ao****
   */
  instanceIds?: string[];
  /**
   * @remarks
   * The interval for returning data. Unit: seconds.
   * 
   * This parameter is required.
   * 
   * @example
   * 1000
   */
  interval?: number;
  /**
   * @remarks
   * The number of port that you want to query. If you do not specify this parameter, all ports are queried.
   * 
   * @example
   * 80
   */
  port?: string;
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
   * 
   * @example
   * default
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.
   * 
   * > This UNIX timestamp must indicate a point in time that is accurate to the minute.
   * 
   * This parameter is required.
   * 
   * @example
   * 1582992000
   */
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      instanceIds: 'InstanceIds',
      interval: 'Interval',
      port: 'Port',
      resourceGroupId: 'ResourceGroupId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'number',
      instanceIds: { 'type': 'array', 'itemType': 'string' },
      interval: 'number',
      port: 'string',
      resourceGroupId: 'string',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePortConnsListResponseBody extends $tea.Model {
  /**
   * @remarks
   * Details about the connections established over the port.
   */
  connsList?: DescribePortConnsListResponseBodyConnsList[];
  /**
   * @remarks
   * The ID of the request, which is used to locate and troubleshoot issues.
   * 
   * @example
   * 6D48AED0-41DB-5D9B-B484-3B6AAD312AD1
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      connsList: 'ConnsList',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      connsList: { 'type': 'array', 'itemType': DescribePortConnsListResponseBodyConnsList },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePortConnsListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribePortConnsListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribePortConnsListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePortFlowListRequest extends $tea.Model {
  /**
   * @remarks
   * The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.
   * 
   * **
   * 
   * **This UNIX timestamp must indicate a point in time that is accurate to the minute.
   * 
   * This parameter is required.
   * 
   * @example
   * 1583683200
   */
  endTime?: number;
  /**
   * @remarks
   * An array that consists of the IDs of instances.
   * 
   * This parameter is required.
   * 
   * @example
   * ddoscoo-cn-mp91j1ao****
   */
  instanceIds?: string[];
  /**
   * @remarks
   * The interval for returning data. Unit: seconds. The interval that you can specify varies based on the time range to query. The time range to query is determined by the values of **StartTime** and **EndTime**.
   * 
   * *   If the time range to query is no greater than 1 hour, we recommend that you specify the interval from 60 seconds to the time range to query.
   * *   If the time range to query is greater than 1 hour but no greater than 6 hours, we recommend that you specify the interval from 600 seconds to the time range to query.
   * *   If the time range to query is greater than 6 hours but no greater than 24 hours, we recommend that you specify the interval from 1,800 seconds to the time range to query.
   * *   If the time range to query is greater than 24 hours but no greater than 7 days, we recommend that you specify the interval from 3,600 seconds to the time range to query.
   * *   If the time range to query is greater than 7 days but no greater than 15 days, we recommend that you specify the interval from 14,400 seconds to the time range to query.
   * *   If the time range to query is greater than 15 days, we recommend that you specify the interval from 43,200 seconds to the time range to query.
   * 
   * This parameter is required.
   * 
   * @example
   * 1000
   */
  interval?: number;
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
   * 
   * For more information about resource groups, see [Create a resource group](https://help.aliyun.com/document_detail/94485.html).
   * 
   * @example
   * rg-acfm2pz25js****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.
   * 
   * **
   * 
   * **This UNIX timestamp must indicate a point in time that is accurate to the minute.
   * 
   * This parameter is required.
   * 
   * @example
   * 1582992000
   */
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      instanceIds: 'InstanceIds',
      interval: 'Interval',
      resourceGroupId: 'ResourceGroupId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'number',
      instanceIds: { 'type': 'array', 'itemType': 'string' },
      interval: 'number',
      resourceGroupId: 'string',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePortFlowListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned traffic data.
   */
  portFlowList?: DescribePortFlowListResponseBodyPortFlowList[];
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * FFC77501-BDF8-4BC8-9BF5-B295FBC3189B
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      portFlowList: 'PortFlowList',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      portFlowList: { 'type': 'array', 'itemType': DescribePortFlowListResponseBodyPortFlowList },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePortFlowListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribePortFlowListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribePortFlowListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePortMaxConnsRequest extends $tea.Model {
  /**
   * @remarks
   * The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.
   * 
   * > This UNIX timestamp must indicate a point in time that is accurate to the minute.
   * 
   * This parameter is required.
   * 
   * @example
   * 1583683200
   */
  endTime?: number;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * > You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.
   * 
   * This parameter is required.
   * 
   * @example
   * ddoscoo-cn-mp91j1ao****
   */
  instanceIds?: string[];
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
   * 
   * @example
   * default
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.
   * 
   * > This UNIX timestamp must indicate a point in time that is accurate to the minute.
   * 
   * This parameter is required.
   * 
   * @example
   * 1582992000
   */
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      instanceIds: 'InstanceIds',
      resourceGroupId: 'ResourceGroupId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'number',
      instanceIds: { 'type': 'array', 'itemType': 'string' },
      resourceGroupId: 'string',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePortMaxConnsResponseBody extends $tea.Model {
  /**
   * @remarks
   * An array consisting of the details of the maximum number of connections that are established over a port of the instance.
   */
  portMaxConns?: DescribePortMaxConnsResponseBodyPortMaxConns[];
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 08F79110-2AF5-4FA7-998E-7C5E75EACF9C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      portMaxConns: 'PortMaxConns',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      portMaxConns: { 'type': 'array', 'itemType': DescribePortMaxConnsResponseBodyPortMaxConns },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePortMaxConnsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribePortMaxConnsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribePortMaxConnsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePortViewSourceCountriesRequest extends $tea.Model {
  /**
   * @remarks
   * The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.
   * 
   * > This UNIX timestamp must indicate a point in time that is accurate to the minute.
   * 
   * This parameter is required.
   * 
   * @example
   * 1583683200
   */
  endTime?: number;
  /**
   * @remarks
   * An array that consists of the IDs of instances to query.
   * 
   * This parameter is required.
   * 
   * @example
   * ddoscoo-cn-mp91j1ao****
   */
  instanceIds?: string[];
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
   * 
   * For more information about resource groups, see [Create a resource group](https://help.aliyun.com/document_detail/94485.html).
   * 
   * @example
   * rg-acfm2pz25js****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.
   * 
   * > This UNIX timestamp must indicate a point in time that is accurate to the minute.
   * 
   * This parameter is required.
   * 
   * @example
   * 1582992000
   */
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      instanceIds: 'InstanceIds',
      resourceGroupId: 'ResourceGroupId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'number',
      instanceIds: { 'type': 'array', 'itemType': 'string' },
      resourceGroupId: 'string',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePortViewSourceCountriesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E
   */
  requestId?: string;
  /**
   * @remarks
   * An array consisting of countries or areas from which the requests are sent.
   */
  sourceCountrys?: DescribePortViewSourceCountriesResponseBodySourceCountrys[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      sourceCountrys: 'SourceCountrys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      sourceCountrys: { 'type': 'array', 'itemType': DescribePortViewSourceCountriesResponseBodySourceCountrys },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePortViewSourceCountriesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribePortViewSourceCountriesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribePortViewSourceCountriesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePortViewSourceIspsRequest extends $tea.Model {
  /**
   * @remarks
   * The end of the time range to query. This value is a UNIX timestamp. Unit: seconds.
   * 
   * > This UNIX timestamp must indicate a point in time that is accurate to the minute.
   * 
   * This parameter is required.
   * 
   * @example
   * 1583683200
   */
  endTime?: number;
  /**
   * @remarks
   * An array that consists of the IDs of instances to query.
   * 
   * This parameter is required.
   * 
   * @example
   * ddoscoo-cn-mp91j1ao****
   */
  instanceIds?: string[];
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management.
   * 
   * If you do not configure this parameter, the instance belongs to the default resource group.
   * 
   * @example
   * rg-acfm2pz25js****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The beginning of the time range to query. This value is a UNIX timestamp. Unit: seconds.
   * 
   * > This UNIX timestamp must indicate a point in time that is accurate to the minute.
   * 
   * This parameter is required.
   * 
   * @example
   * 1582992000
   */
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      instanceIds: 'InstanceIds',
      resourceGroupId: 'ResourceGroupId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'number',
      instanceIds: { 'type': 'array', 'itemType': 'string' },
      resourceGroupId: 'string',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePortViewSourceIspsResponseBody extends $tea.Model {
  /**
   * @remarks
   * An array that consists of the details of the ISP.
   */
  isps?: DescribePortViewSourceIspsResponseBodyIsps[];
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      isps: 'Isps',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isps: { 'type': 'array', 'itemType': DescribePortViewSourceIspsResponseBodyIsps },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePortViewSourceIspsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribePortViewSourceIspsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribePortViewSourceIspsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePortViewSourceProvincesRequest extends $tea.Model {
  /**
   * @remarks
   * The end of the time range to query. The value is a UNIX timestamp. Unit: seconds. If you do not configure this parameter, the current system time is used as the end time.
   * 
   * > This UNIX timestamp must indicate a point in time that is accurate to the minute.
   * 
   * @example
   * 1583683200
   */
  endTime?: number;
  /**
   * @remarks
   * The IDs of instances to query.
   * 
   * This parameter is required.
   * 
   * @example
   * ddoscoo-cn-mp91j1ao****
   */
  instanceIds?: string[];
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
   * 
   * For more information about resource groups, see [Create a resource group](https://help.aliyun.com/document_detail/94485.html).
   * 
   * @example
   * rg-acfm2pz25js****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.
   * 
   * > This UNIX timestamp must indicate a point in time that is accurate to the minute.
   * 
   * This parameter is required.
   * 
   * @example
   * 1582992000
   */
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      instanceIds: 'InstanceIds',
      resourceGroupId: 'ResourceGroupId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'number',
      instanceIds: { 'type': 'array', 'itemType': 'string' },
      resourceGroupId: 'string',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePortViewSourceProvincesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E
   */
  requestId?: string;
  /**
   * @remarks
   * Details about the administrative region in China from which the requests are sent.
   */
  sourceProvinces?: DescribePortViewSourceProvincesResponseBodySourceProvinces[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      sourceProvinces: 'SourceProvinces',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      sourceProvinces: { 'type': 'array', 'itemType': DescribePortViewSourceProvincesResponseBodySourceProvinces },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePortViewSourceProvincesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribePortViewSourceProvincesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribePortViewSourceProvincesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSceneDefenseObjectsRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the policy that you want to query.
   * 
   * > You can call the [DescribeSceneDefensePolicies](https://help.aliyun.com/document_detail/159382.html) operation to query the IDs of all policies.
   * 
   * This parameter is required.
   * 
   * @example
   * 47e07ebd-0ba5-4afc-957b-59d15b90****
   */
  policyId?: string;
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management.
   * 
   * If you do not configure this parameter, the instance belongs to the default resource group.
   * 
   * @example
   * rg-acfm2pz25js****
   */
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      policyId: 'PolicyId',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      policyId: 'string',
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSceneDefenseObjectsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about the protected assets.
   */
  objects?: DescribeSceneDefenseObjectsResponseBodyObjects[];
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * FE07E73F-F19E-4A51-B62F-AC59E3B962D8
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: yes
   * *   **false**: no
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      objects: 'Objects',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      objects: { 'type': 'array', 'itemType': DescribeSceneDefenseObjectsResponseBodyObjects },
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSceneDefenseObjectsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeSceneDefenseObjectsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeSceneDefenseObjectsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSceneDefensePoliciesRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management.
   * 
   * If you do not configure this parameter, the instance belongs to the default resource group.
   * 
   * @example
   * rg-acfm2pz25js****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The status of the policy. Valid values:
   * 
   * *   **0**: disabled
   * *   **1**: pending enabling
   * *   **2**: enabled
   * *   **3**: expired
   * 
   * @example
   * 1
   */
  status?: string;
  /**
   * @remarks
   * The type of the template that is used to create the policy. Valid values:
   * 
   * *   **promotion**: the Important Activity template
   * *   **bypass**: the Forward All template
   * 
   * @example
   * promotion
   */
  template?: string;
  static names(): { [key: string]: string } {
    return {
      resourceGroupId: 'ResourceGroupId',
      status: 'Status',
      template: 'Template',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resourceGroupId: 'string',
      status: 'string',
      template: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSceneDefensePoliciesResponseBody extends $tea.Model {
  /**
   * @remarks
   * An array that consists of the configurations of the scenario-specific custom policy.
   */
  policies?: DescribeSceneDefensePoliciesResponseBodyPolicies[];
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * F65DF043-E0EB-4796-9467-23DDCDF92C1D
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: yes
   * *   **false**: no
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      policies: 'Policies',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      policies: { 'type': 'array', 'itemType': DescribeSceneDefensePoliciesResponseBodyPolicies },
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSceneDefensePoliciesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeSceneDefensePoliciesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeSceneDefensePoliciesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSchedulerRulesRequest extends $tea.Model {
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * default
   */
  resourceGroupId?: string;
  /**
   * @example
   * testrule
   */
  ruleName?: string;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      resourceGroupId: 'ResourceGroupId',
      ruleName: 'RuleName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      resourceGroupId: 'string',
      ruleName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSchedulerRulesResponseBody extends $tea.Model {
  /**
   * @example
   * 11C55595-1757-4B17-9ACE-4ACB68C2D989
   */
  requestId?: string;
  schedulerRules?: DescribeSchedulerRulesResponseBodySchedulerRules[];
  /**
   * @example
   * 1
   */
  totalCount?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      schedulerRules: 'SchedulerRules',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      schedulerRules: { 'type': 'array', 'itemType': DescribeSchedulerRulesResponseBodySchedulerRules },
      totalCount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSchedulerRulesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeSchedulerRulesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeSchedulerRulesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSlaEventListRequest extends $tea.Model {
  /**
   * @remarks
   * The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.
   * 
   * >  This UNIX timestamp must indicate a point in time that is accurate to the minute.
   * 
   * This parameter is required.
   * 
   * @example
   * 3289457398
   */
  endTime?: number;
  /**
   * @remarks
   * The IP address of the Anti-DDoS Pro or Anti-DDoS Premium instance.
   * 
   * @example
   * 203.107.XX.XX
   */
  ip?: string;
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  page?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The type of the service Valid values:
   * 
   * *   **cn**: Anti-DDoS Pro
   * *   **cn-hongkong**: Anti-DDoS Premium
   * 
   * This parameter is required.
   * 
   * @example
   * cn
   */
  region?: string;
  /**
   * @remarks
   * The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.
   * 
   * >  This UNIX timestamp must indicate a point in time that is accurate to the minute.
   * 
   * This parameter is required.
   * 
   * @example
   * 3289457398
   */
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      ip: 'Ip',
      page: 'Page',
      pageSize: 'PageSize',
      region: 'Region',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'number',
      ip: 'string',
      page: 'number',
      pageSize: 'number',
      region: 'string',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSlaEventListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * CF33B4C3-196E-4015-AADD-5CAD00057B80
   */
  requestId?: string;
  /**
   * @remarks
   * The destination rate limit events.
   */
  slaEvent?: DescribeSlaEventListResponseBodySlaEvent[];
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 10
   */
  total?: number;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      slaEvent: 'SlaEvent',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      slaEvent: { 'type': 'array', 'itemType': DescribeSlaEventListResponseBodySlaEvent },
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSlaEventListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeSlaEventListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeSlaEventListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSlsAuthStatusRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
   * 
   * @example
   * default
   */
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSlsAuthStatusResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CF33B4C3-196E-4015-AADD-5CAD00057B80
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether Anti-DDoS Pro or Anti-DDoS Premium is authorized to access Log Service. Valid values:
   * 
   * *   **true**: yes
   * *   **false**: no
   * 
   * @example
   * true
   */
  slsAuthStatus?: boolean;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      slsAuthStatus: 'SlsAuthStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      slsAuthStatus: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSlsAuthStatusResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeSlsAuthStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeSlsAuthStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSlsLogstoreInfoRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
   * 
   * @example
   * default
   */
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSlsLogstoreInfoResponseBody extends $tea.Model {
  /**
   * @remarks
   * The Logstore of the Anti-DDoS Pro or Anti-DDoS Premium instance.
   * 
   * @example
   * ddoscoo-logstore
   */
  logStore?: string;
  /**
   * @remarks
   * The Logstore project of the Anti-DDoS Pro or Anti-DDoS Premium instance.
   * 
   * @example
   * ddoscoo-project-181071506993****-cn-hangzhou
   */
  project?: string;
  /**
   * @remarks
   * The available log storage capacity. Unit: bytes.
   * 
   * @example
   * 3298534883328
   */
  quota?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CF33B4C3-196E-4015-AADD-5CAD00057B80
   */
  requestId?: string;
  /**
   * @remarks
   * The log storage duration. Unit: days.
   * 
   * @example
   * 180
   */
  ttl?: number;
  /**
   * @remarks
   * The used log storage capacity. Unit: bytes.
   * 
   * > The statistics on Log Service are delayed for about two hours.
   * 
   * @example
   * 0
   */
  used?: number;
  static names(): { [key: string]: string } {
    return {
      logStore: 'LogStore',
      project: 'Project',
      quota: 'Quota',
      requestId: 'RequestId',
      ttl: 'Ttl',
      used: 'Used',
    };
  }

  static types(): { [key: string]: any } {
    return {
      logStore: 'string',
      project: 'string',
      quota: 'number',
      requestId: 'string',
      ttl: 'number',
      used: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSlsLogstoreInfoResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeSlsLogstoreInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeSlsLogstoreInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSlsOpenStatusRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
   * 
   * @example
   * default
   */
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSlsOpenStatusResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CF33B4C3-196E-4015-AADD-5CAD00057B80
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether Log Service is activated. Valid values:
   * 
   * *   **true**: yes
   * *   **false**: no
   * 
   * @example
   * true
   */
  slsOpenStatus?: boolean;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      slsOpenStatus: 'SlsOpenStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      slsOpenStatus: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSlsOpenStatusResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeSlsOpenStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeSlsOpenStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeStsGrantStatusRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management.
   * 
   * If you do not configure this parameter, the instance belongs to the default resource group.
   * 
   * @example
   * rg-acfm2pz25js****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The name of the RAM role to query. Set the value to **AliyunDDoSCOODefaultRole**, which indicates the default role of Anti-DDoS Pro or Anti-DDoS Premium.
   * 
   * > Anti-DDoS Pro or Anti-DDoS Premium uses the default role to access other cloud services.
   * 
   * This parameter is required.
   * 
   * @example
   * AliyunDDoSCOODefaultRole
   */
  role?: string;
  static names(): { [key: string]: string } {
    return {
      resourceGroupId: 'ResourceGroupId',
      role: 'Role',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resourceGroupId: 'string',
      role: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeStsGrantStatusResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 6623EA1F-30FB-5BC8-BEC9-74D55F6F08F1
   */
  requestId?: string;
  /**
   * @remarks
   * The authorization status of Anti-DDoS Pro or Anti-DDoS Premium.
   */
  stsGrant?: DescribeStsGrantStatusResponseBodyStsGrant;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      stsGrant: 'StsGrant',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      stsGrant: DescribeStsGrantStatusResponseBodyStsGrant,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeStsGrantStatusResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeStsGrantStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeStsGrantStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSystemLogRequest extends $tea.Model {
  /**
   * @remarks
   * The end of the time range to query. The bills of the burstable clean bandwidth that are issued before this point in time are queried. The value is a UNIX timestamp. Unit: milliseconds.
   * 
   * This parameter is required.
   * 
   * @example
   * 1640966400000
   */
  endTime?: number;
  /**
   * @remarks
   * The IP address of the instance.
   * 
   * > You can call the [DescribeInstanceDetails](https://help.aliyun.com/document_detail/91490.html) operation to query the IP addresses of all instances.
   * 
   * @example
   * 203.107.XX.XX
   */
  entityObject?: string;
  /**
   * @remarks
   * The type of the system log. Set the value to **20**, which indicates the billing logs for the burstable clean bandwidth.
   * 
   * > You must specify this parameter. Otherwise, the call fails.
   * 
   * @example
   * 20
   */
  entityType?: number;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * This parameter is required.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The beginning of the time range to query. The bills of the burstable clean bandwidth that are issued after this point in time are queried. The value is a UNIX timestamp. Unit: milliseconds.
   * 
   * This parameter is required.
   * 
   * @example
   * 1609430400000
   */
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      entityObject: 'EntityObject',
      entityType: 'EntityType',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'number',
      entityObject: 'string',
      entityType: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSystemLogResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 8BC3A33A-F832-58DB-952F-7682A25AD14C
   */
  requestId?: string;
  /**
   * @remarks
   * An array that consists of details of the billing logs for the burstable clean bandwidth.
   */
  systemLog?: DescribeSystemLogResponseBodySystemLog[];
  /**
   * @remarks
   * The total number of billing logs for the burstable clean bandwidth.
   * 
   * @example
   * 1
   */
  total?: number;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      systemLog: 'SystemLog',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      systemLog: { 'type': 'array', 'itemType': DescribeSystemLogResponseBodySystemLog },
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSystemLogResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeSystemLogResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeSystemLogResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTagKeysRequest extends $tea.Model {
  /**
   * @remarks
   * The number of the page to return. Default value: **1**.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page. Default value: **10**.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The region ID of the instance. Set the value to **cn-hangzhou**, which indicates an Anti-DDoS Proxy (Chinese Mainland) instance.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management.
   * 
   * If you do not configure this parameter, the instance belongs to the default resource group.
   * 
   * @example
   * rg-acfm2pz25js****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The type of the resource to which the tag belongs. Set the value to **INSTANCE**, which indicates an Anti-DDoS Pro instance.
   * 
   * This parameter is required.
   * 
   * @example
   * INSTANCE
   */
  resourceType?: string;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      resourceType: 'ResourceType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      regionId: 'string',
      resourceGroupId: 'string',
      resourceType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTagKeysResponseBody extends $tea.Model {
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned on each page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 6623EA1F-30FB-5BC8-BEC9-74D55F6F08F1
   */
  requestId?: string;
  /**
   * @remarks
   * The details about the tag keys.
   */
  tagKeys?: DescribeTagKeysResponseBodyTagKeys[];
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 1
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      tagKeys: 'TagKeys',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      tagKeys: { 'type': 'array', 'itemType': DescribeTagKeysResponseBodyTagKeys },
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTagKeysResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeTagKeysResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeTagKeysResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTagResourcesRequest extends $tea.Model {
  /**
   * @remarks
   * The query token. Set the value to the value of **NextToken** that is returned in the last call.
   * 
   * > You do not need to configure this parameter if you call this operation for the first time.
   * 
   * @example
   * RGuYpqDdKhzXb8C3.D1BwQgc1tMBsoxdGiEKHHUUCf****
   */
  nextToken?: string;
  /**
   * @remarks
   * The region ID of the instance. Set the value to **cn-hangzhou**, which indicates an Anti-DDoS Proxy (Chinese Mainland) instance.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management.
   * 
   * If you do not configure this parameter, the instance belongs to the default resource group.
   * 
   * @example
   * rg-acfm2pz25js****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The IDs of the Anti-DDoS Proxy (Chinese Mainland) instances that you want to query.
   * 
   * @example
   * ddoscoo-cn-mp91j1ao****
   */
  resourceIds?: string[];
  /**
   * @remarks
   * The type of the resource to which the tag belongs. Set the value to **INSTANCE**, which indicates an Anti-DDoS Pro instance.
   * 
   * This parameter is required.
   * 
   * @example
   * INSTANCE
   */
  resourceType?: string;
  /**
   * @remarks
   * An array consisting of tags that you want to query. Each tag consists of a tag **key** and a tag **value**.
   */
  tags?: DescribeTagResourcesRequestTags[];
  static names(): { [key: string]: string } {
    return {
      nextToken: 'NextToken',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      resourceIds: 'ResourceIds',
      resourceType: 'ResourceType',
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nextToken: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      resourceIds: { 'type': 'array', 'itemType': 'string' },
      resourceType: 'string',
      tags: { 'type': 'array', 'itemType': DescribeTagResourcesRequestTags },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTagResourcesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The query token that is returned in this call.
   * 
   * @example
   * RGuYpqDdKhzXb8C3.D1BwQgc1tMBsoxdGiEKHHUUCf****
   */
  nextToken?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 36E698F7-48A4-48D0-9554-0BB4BAAB99B3
   */
  requestId?: string;
  /**
   * @remarks
   * The tags that are added to the Anti-DDoS Proxy (Chinese Mainland) instance.
   */
  tagResources?: DescribeTagResourcesResponseBodyTagResources;
  static names(): { [key: string]: string } {
    return {
      nextToken: 'NextToken',
      requestId: 'RequestId',
      tagResources: 'TagResources',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nextToken: 'string',
      requestId: 'string',
      tagResources: DescribeTagResourcesResponseBodyTagResources,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTagResourcesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeTagResourcesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeTagResourcesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTotalAttackMaxFlowRequest extends $tea.Model {
  /**
   * @remarks
   * The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.
   * 
   * > This UNIX timestamp must indicate a point in time that is accurate to the minute.
   * 
   * This parameter is required.
   * 
   * @example
   * 1659697200
   */
  endTime?: number;
  /**
   * @remarks
   * The IDs of the instances. Separate multiple instance IDs with commas (,). Example: InstanceIds.1, InstanceIds.2, InstanceIds.3.
   * 
   * This parameter is required.
   */
  instanceIds?: string[];
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management. If you do not configure this parameter, the instance belongs to the default resource group.
   * 
   * @example
   * default
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.
   * 
   * > This UNIX timestamp must indicate a point in time that is accurate to the minute.
   * 
   * This parameter is required.
   * 
   * @example
   * 1669240800
   */
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      instanceIds: 'InstanceIds',
      resourceGroupId: 'ResourceGroupId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'number',
      instanceIds: { 'type': 'array', 'itemType': 'string' },
      resourceGroupId: 'string',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTotalAttackMaxFlowResponseBody extends $tea.Model {
  /**
   * @remarks
   * The peak bandwidth of attack traffic. Unit: bit/s.
   * 
   * @example
   * 0
   */
  bps?: number;
  /**
   * @remarks
   * The peak packet rate of attack traffic . Unit: packets per second (pps).
   * 
   * @example
   * 0
   */
  pps?: number;
  /**
   * @remarks
   * The ID of the request, which is used to locate and troubleshoot issues.
   * 
   * @example
   * 9173A3CB-C40B-559B-96B7-2373830BD06A
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      bps: 'Bps',
      pps: 'Pps',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bps: 'number',
      pps: 'number',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTotalAttackMaxFlowResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeTotalAttackMaxFlowResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeTotalAttackMaxFlowResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUdpReflectRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the instance to query.
   * 
   * > You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.
   * 
   * This parameter is required.
   * 
   * @example
   * ddoscoo-cn-i7m25564****
   */
  instanceId?: string;
  /**
   * @remarks
   * The region ID of the instance. Valid values:
   * 
   * *   **cn-hangzhou**: indicates an Anti-DDoS Proxy (Chinese Mainland) instance. This is the default value.
   * *   **ap-southeast-1**: indicates an Anti-DDoS Proxy (Outside Chinese Mainland) instance.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUdpReflectResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * F97A8766-FB4D-411A-9CD5-2CFF701B592F
   */
  requestId?: string;
  /**
   * @remarks
   * An array consisting of the source ports of the UDP traffic that are filtered out by the filtering policies for UDP reflection attacks.
   */
  udpSports?: string[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      udpSports: 'UdpSports',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      udpSports: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUdpReflectResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeUdpReflectResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeUdpReflectResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUnBlackholeCountRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
   * 
   * @example
   * default
   */
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUnBlackholeCountResponseBody extends $tea.Model {
  /**
   * @remarks
   * The remaining quota that you can deactivate blackhole filtering.
   * 
   * @example
   * 5
   */
  remainCount?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 232929FA-40B6-4C53-9476-EE335ABA44CD
   */
  requestId?: string;
  /**
   * @remarks
   * The total quota that you can deactivate blackhole filtering.
   * 
   * @example
   * 5
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      remainCount: 'RemainCount',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      remainCount: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUnBlackholeCountResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeUnBlackholeCountResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeUnBlackholeCountResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUnBlockCountRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
   * 
   * @example
   * default
   */
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUnBlockCountResponseBody extends $tea.Model {
  /**
   * @remarks
   * The remaining quota that you can use the Diversion from Origin Server policy.
   * 
   * @example
   * 7
   */
  remainCount?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E
   */
  requestId?: string;
  /**
   * @remarks
   * The total quota that you can use the Diversion from Origin Server policy.
   * 
   * @example
   * 10
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      remainCount: 'RemainCount',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      remainCount: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUnBlockCountResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeUnBlockCountResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeUnBlockCountResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebAccessLogDispatchStatusRequest extends $tea.Model {
  /**
   * @remarks
   * The number of the page to return. Default value: **1**.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page. Default value: **10**.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management.
   * 
   * If you do not configure this parameter, the instance belongs to the default resource group.
   * 
   * @example
   * rg-acfm2pz25js****
   */
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebAccessLogDispatchStatusResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CF33B4C3-196E-4015-AADD-5CAD00057B80
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the log analysis feature is enabled for domain names.
   */
  slsConfigStatus?: DescribeWebAccessLogDispatchStatusResponseBodySlsConfigStatus[];
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 1
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      slsConfigStatus: 'SlsConfigStatus',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      slsConfigStatus: { 'type': 'array', 'itemType': DescribeWebAccessLogDispatchStatusResponseBodySlsConfigStatus },
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebAccessLogDispatchStatusResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeWebAccessLogDispatchStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeWebAccessLogDispatchStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebAccessLogEmptyCountRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
   * 
   * @example
   * default
   */
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebAccessLogEmptyCountResponseBody extends $tea.Model {
  /**
   * @remarks
   * The remaining quota that you can clear the Logstore.
   * 
   * @example
   * 10
   */
  availableCount?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CF33B4C3-196E-4015-AADD-5CAD00057B80
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      availableCount: 'AvailableCount',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      availableCount: 'number',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebAccessLogEmptyCountResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeWebAccessLogEmptyCountResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeWebAccessLogEmptyCountResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebAccessLogStatusRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name of the website.
   * 
   * > A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.
   * 
   * This parameter is required.
   * 
   * @example
   * www.aliyun.com
   */
  domain?: string;
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
   * 
   * @example
   * default
   */
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebAccessLogStatusResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CF33B4C3-196E-4015-AADD-5CAD00057B80
   */
  requestId?: string;
  /**
   * @remarks
   * The Logstore of the instance.
   * 
   * @example
   * ddoscoo-logstore
   */
  slsLogstore?: string;
  /**
   * @remarks
   * The Log Service project of the instance.
   * 
   * @example
   * ddoscoo-project-128965410602****-cn-hangzhou
   */
  slsProject?: string;
  /**
   * @remarks
   * Indicates whether the Log Analysis feature is enabled for the website. Valid values:
   * 
   * *   **true**: enabled
   * *   **false**: disabled
   * 
   * @example
   * true
   */
  slsStatus?: boolean;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      slsLogstore: 'SlsLogstore',
      slsProject: 'SlsProject',
      slsStatus: 'SlsStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      slsLogstore: 'string',
      slsProject: 'string',
      slsStatus: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebAccessLogStatusResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeWebAccessLogStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeWebAccessLogStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebAccessModeRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name of the website.
   * 
   * > A forwarding rule must be configured for a domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.
   * 
   * This parameter is required.
   * 
   * @example
   * www.aliyun.com
   */
  domains?: string[];
  static names(): { [key: string]: string } {
    return {
      domains: 'Domains',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domains: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebAccessModeResponseBody extends $tea.Model {
  /**
   * @remarks
   * An array consisting of the modes in which the website service is added.
   */
  domainModes?: DescribeWebAccessModeResponseBodyDomainModes[];
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      domainModes: 'DomainModes',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainModes: { 'type': 'array', 'itemType': DescribeWebAccessModeResponseBodyDomainModes },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebAccessModeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeWebAccessModeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeWebAccessModeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebAreaBlockConfigsRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name of the website.
   * 
   * > A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.
   * 
   * This parameter is required.
   * 
   * @example
   * www.aliyun.com
   */
  domains?: string[];
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
   * 
   * @example
   * default
   */
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      domains: 'Domains',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domains: { 'type': 'array', 'itemType': 'string' },
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebAreaBlockConfigsResponseBody extends $tea.Model {
  /**
   * @remarks
   * An array that consists of the configurations of the Location Blacklist (Domain Names) policy.
   */
  areaBlockConfigs?: DescribeWebAreaBlockConfigsResponseBodyAreaBlockConfigs[];
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      areaBlockConfigs: 'AreaBlockConfigs',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      areaBlockConfigs: { 'type': 'array', 'itemType': DescribeWebAreaBlockConfigsResponseBodyAreaBlockConfigs },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebAreaBlockConfigsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeWebAreaBlockConfigsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeWebAreaBlockConfigsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebCCRulesRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name of the website.
   * 
   * > A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.
   * 
   * This parameter is required.
   * 
   * @example
   * www.aliyun.com
   */
  domain?: string;
  /**
   * @remarks
   * The number of the page to return. For example, to query the returned results on the first page, set the value to **1**.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * This parameter is required.
   * 
   * @example
   * 10
   */
  pageSize?: string;
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
   * 
   * @example
   * default
   */
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
      pageNumber: 'number',
      pageSize: 'string',
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebCCRulesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * EAED912D-909E-45F0-AF74-AC0CCDCAE314
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of returned custom frequency control rules.
   * 
   * @example
   * 1
   */
  totalCount?: number;
  /**
   * @remarks
   * An array that consists of the details of the custom frequency control rule.
   */
  webCCRules?: DescribeWebCCRulesResponseBodyWebCCRules[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      totalCount: 'TotalCount',
      webCCRules: 'WebCCRules',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      totalCount: 'number',
      webCCRules: { 'type': 'array', 'itemType': DescribeWebCCRulesResponseBodyWebCCRules },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebCCRulesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeWebCCRulesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeWebCCRulesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebCCRulesV2Request extends $tea.Model {
  /**
   * @remarks
   * The domain name of the website that you want to add to the Anti-DDoS Proxy instance for protection.
   * 
   * @example
   * example.com
   */
  domain?: string;
  /**
   * @remarks
   * The number of entries that you want the system to skip before the system returns entries. Default value: **0**.
   * 
   * @example
   * 0
   */
  offset?: string;
  /**
   * @remarks
   * The method used to create the rule. Valid values:
   * 
   * *   **manual** (default): manually created.
   * *   **clover**: automatically created.
   * 
   * @example
   * manual
   */
  owner?: string;
  /**
   * @remarks
   * The number of entries per page. Maximum value: **20**. Default value: **20**.
   * 
   * @example
   * 20
   */
  pageSize?: string;
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
      offset: 'Offset',
      owner: 'Owner',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
      offset: 'string',
      owner: 'string',
      pageSize: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebCCRulesV2ResponseBody extends $tea.Model {
  /**
   * @remarks
   * The domain name of the website.
   * 
   * @example
   * www.aliyun.com
   */
  domain?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * CF33B4C3-196E-4015-AADD-5CAD00057B80
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of returned custom frequency control rules.
   * 
   * @example
   * 12
   */
  totalCount?: string;
  /**
   * @remarks
   * The custom frequency control rules.
   */
  webCCRules?: DescribeWebCCRulesV2ResponseBodyWebCCRules[];
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
      webCCRules: 'WebCCRules',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
      requestId: 'string',
      totalCount: 'string',
      webCCRules: { 'type': 'array', 'itemType': DescribeWebCCRulesV2ResponseBodyWebCCRules },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebCCRulesV2Response extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeWebCCRulesV2ResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeWebCCRulesV2ResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebCacheConfigsRequest extends $tea.Model {
  /**
   * @remarks
   * An array consisting of domain names for which you want to query the Static Page Caching configurations.
   * 
   * This parameter is required.
   * 
   * @example
   * www.aliyun.com
   */
  domains?: string[];
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management.
   * 
   * If you do not configure this parameter, the instance belongs to the default resource group.
   * 
   * @example
   * rg-acfm2pz25js****
   */
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      domains: 'Domains',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domains: { 'type': 'array', 'itemType': 'string' },
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebCacheConfigsResponseBody extends $tea.Model {
  /**
   * @remarks
   * An array that consists of Static Page Caching configurations.
   */
  domainCacheConfigs?: DescribeWebCacheConfigsResponseBodyDomainCacheConfigs[];
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 6623EA1F-30FB-5BC8-BEC9-74D55F6F08F1
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      domainCacheConfigs: 'DomainCacheConfigs',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainCacheConfigs: { 'type': 'array', 'itemType': DescribeWebCacheConfigsResponseBodyDomainCacheConfigs },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebCacheConfigsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeWebCacheConfigsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeWebCacheConfigsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebCcProtectSwitchRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name of the website.
   * 
   * > A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.
   * 
   * This parameter is required.
   * 
   * @example
   * www.aliyun.com
   */
  domains?: string[];
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
   * 
   * @example
   * default
   */
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      domains: 'Domains',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domains: { 'type': 'array', 'itemType': 'string' },
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebCcProtectSwitchResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status of each mitigation policy for the website.
   */
  protectSwitchList?: DescribeWebCcProtectSwitchResponseBodyProtectSwitchList[];
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 3ADD9EED-CA4B-488C-BC82-01B0B899363D
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      protectSwitchList: 'ProtectSwitchList',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      protectSwitchList: { 'type': 'array', 'itemType': DescribeWebCcProtectSwitchResponseBodyProtectSwitchList },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebCcProtectSwitchResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeWebCcProtectSwitchResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeWebCcProtectSwitchResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebCustomPortsRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
   * 
   * @example
   * default
   */
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebCustomPortsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc
   */
  requestId?: string;
  /**
   * @remarks
   * An array consisting of information about supported custom ports that are used by a website.
   */
  webCustomPorts?: DescribeWebCustomPortsResponseBodyWebCustomPorts[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      webCustomPorts: 'WebCustomPorts',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      webCustomPorts: { 'type': 'array', 'itemType': DescribeWebCustomPortsResponseBodyWebCustomPorts },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebCustomPortsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeWebCustomPortsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeWebCustomPortsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebInstanceRelationsRequest extends $tea.Model {
  /**
   * @remarks
   * The domain names of the website. list
   * 
   * > A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.
   * 
   * This parameter is required.
   * 
   * @example
   * www.aliyun.com
   */
  domains?: string[];
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
   * 
   * @example
   * default
   */
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      domains: 'Domains',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domains: { 'type': 'array', 'itemType': 'string' },
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebInstanceRelationsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0222382B-5FE5-4FF7-BC9B-97EE31D58818
   */
  requestId?: string;
  /**
   * @remarks
   * The information about the instances to which a website service is added.
   */
  webInstanceRelations?: DescribeWebInstanceRelationsResponseBodyWebInstanceRelations[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      webInstanceRelations: 'WebInstanceRelations',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      webInstanceRelations: { 'type': 'array', 'itemType': DescribeWebInstanceRelationsResponseBodyWebInstanceRelations },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebInstanceRelationsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeWebInstanceRelationsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeWebInstanceRelationsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebPreciseAccessRuleRequest extends $tea.Model {
  /**
   * @remarks
   * An array that consists of the domain names of websites.
   * 
   * > A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.
   * 
   * This parameter is required.
   * 
   * @example
   * www.aliyun.com
   */
  domains?: string[];
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
   * 
   * @example
   * default
   */
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      domains: 'Domains',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domains: { 'type': 'array', 'itemType': 'string' },
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebPreciseAccessRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * The configuration of the accurate access control rule that is created for the website.
   */
  preciseAccessConfigList?: DescribeWebPreciseAccessRuleResponseBodyPreciseAccessConfigList[];
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 209EEFBF-B0C7-441E-8C28-D0945A57A638
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      preciseAccessConfigList: 'PreciseAccessConfigList',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      preciseAccessConfigList: { 'type': 'array', 'itemType': DescribeWebPreciseAccessRuleResponseBodyPreciseAccessConfigList },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebPreciseAccessRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeWebPreciseAccessRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeWebPreciseAccessRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebReportTopIpRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name of the website.
   * 
   * >  A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query the domain names for which forwarding rules are configured.
   * 
   * @example
   * app.bmjqxvb.cn
   */
  domain?: string;
  /**
   * @remarks
   * The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.
   * 
   * >  This UNIX timestamp must indicate a point in time that is accurate to the minute.
   * 
   * This parameter is required.
   * 
   * @example
   * 1687228200
   */
  endTime?: number;
  /**
   * @remarks
   * The interval at which data is collected. Unit: seconds. Valid values are 300, 3600, and 86400.
   * 
   * *   If the time span between StartTime and EndTime is less than 3 days (3 days excluded), valid values are 300, 3600, and 86400.
   * *   If the time span between StartTime and EndTime is from 3 to 31 days (31 days excluded), valid values are 3600 and 86400.
   * *   If the time span between StartTime and EndTime is 31 days or longer, the valid value is 86400.
   * 
   * This parameter is required.
   * 
   * @example
   * 300
   */
  interval?: number;
  /**
   * @remarks
   * The source of the statistics. Valid value:
   * 
   * *   **visit**: indicates all IP addresses.
   * *   **block**: indicates blocked IP addresses.
   * 
   * This parameter is required.
   * 
   * @example
   * block
   */
  queryType?: string;
  /**
   * @remarks
   * The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.
   * 
   * >  This UNIX timestamp must indicate a point in time that is accurate to the minute.
   * 
   * This parameter is required.
   * 
   * @example
   * 1680424200
   */
  startTime?: number;
  /**
   * @remarks
   * The maximum number of entries to return.
   * 
   * @example
   * 5
   */
  top?: number;
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
      endTime: 'EndTime',
      interval: 'Interval',
      queryType: 'QueryType',
      startTime: 'StartTime',
      top: 'Top',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
      endTime: 'number',
      interval: 'number',
      queryType: 'string',
      startTime: 'number',
      top: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebReportTopIpResponseBody extends $tea.Model {
  /**
   * @remarks
   * The response parameters.
   */
  dataList?: DescribeWebReportTopIpResponseBodyDataList[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * D21BE0C4-8E83-5E32-86C6-AA6BE9B1B5BD
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      dataList: 'DataList',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataList: { 'type': 'array', 'itemType': DescribeWebReportTopIpResponseBodyDataList },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebReportTopIpResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeWebReportTopIpResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeWebReportTopIpResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebRulesRequest extends $tea.Model {
  /**
   * @example
   * kzmk7b8tt351****.aliyunddos1014****
   */
  cname?: string;
  /**
   * @example
   * example.com
   */
  domain?: string;
  /**
   * @example
   * ddoscoo-cn-mp91j1ao****
   */
  instanceIds?: string[];
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * exact
   */
  queryDomainPattern?: string;
  /**
   * @example
   * rg-acfm2pz25js****
   */
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      cname: 'Cname',
      domain: 'Domain',
      instanceIds: 'InstanceIds',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      queryDomainPattern: 'QueryDomainPattern',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cname: 'string',
      domain: 'string',
      instanceIds: { 'type': 'array', 'itemType': 'string' },
      pageNumber: 'number',
      pageSize: 'number',
      queryDomainPattern: 'string',
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebRulesResponseBody extends $tea.Model {
  /**
   * @example
   * 0F5B72DD-96F4-423A-B12B-A5151DD746B8
   */
  requestId?: string;
  /**
   * @example
   * 1
   */
  totalCount?: number;
  webRules?: DescribeWebRulesResponseBodyWebRules[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      totalCount: 'TotalCount',
      webRules: 'WebRules',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      totalCount: 'number',
      webRules: { 'type': 'array', 'itemType': DescribeWebRulesResponseBodyWebRules },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebRulesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeWebRulesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeWebRulesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DetachSceneDefenseObjectRequest extends $tea.Model {
  /**
   * @remarks
   * The type of the object. Set the value to **Domain**, which indicates a domain name.
   * 
   * @example
   * Domain
   */
  objectType?: string;
  /**
   * @remarks
   * The protection asset that you want to remove from a policy. Separate multiple protection assets with commas (,).
   * 
   * This parameter is required.
   * 
   * @example
   * www.aliyun.com
   */
  objects?: string;
  /**
   * @remarks
   * The ID of the policy.
   * 
   * > You can call the [DescribeSceneDefensePolicies](https://help.aliyun.com/document_detail/159382.html) operation to query the IDs of all policies.
   * 
   * This parameter is required.
   * 
   * @example
   * 321a-fd31-df51-****
   */
  policyId?: string;
  static names(): { [key: string]: string } {
    return {
      objectType: 'ObjectType',
      objects: 'Objects',
      policyId: 'PolicyId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      objectType: 'string',
      objects: 'string',
      policyId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DetachSceneDefenseObjectResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * F65DF043-E0EB-4796-9467-23DDCDF92C1D
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: yes
   * *   **false**: no
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DetachSceneDefenseObjectResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DetachSceneDefenseObjectResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DetachSceneDefenseObjectResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableSceneDefensePolicyRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the policy that you want to disable.
   * 
   * > You can call the [DescribeSceneDefensePolicies](https://help.aliyun.com/document_detail/159382.html) operation to query the IDs of all policies.
   * 
   * This parameter is required.
   * 
   * @example
   * 321a-fd31-df51-****
   */
  policyId?: string;
  static names(): { [key: string]: string } {
    return {
      policyId: 'PolicyId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      policyId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableSceneDefensePolicyResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * F65DF043-E0EB-4796-9467-23DDCDF92C1D
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: yes
   * *   **false**: no
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableSceneDefensePolicyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DisableSceneDefensePolicyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DisableSceneDefensePolicyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableWebAccessLogConfigRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name of the website.
   * 
   * > A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.
   * 
   * This parameter is required.
   * 
   * @example
   * www.aliyun.com
   */
  domain?: string;
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
   * 
   * @example
   * default
   */
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableWebAccessLogConfigResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CF33B4C3-196E-4015-AADD-5CAD00057B80
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableWebAccessLogConfigResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DisableWebAccessLogConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DisableWebAccessLogConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableWebCCRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name of the website.
   * 
   * > A forwarding rule must be configured for a domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.
   * 
   * This parameter is required.
   * 
   * @example
   * www.aliyun.com
   */
  domain?: string;
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
   * 
   * @example
   * default
   */
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableWebCCResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableWebCCResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DisableWebCCResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DisableWebCCResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableWebCCRuleRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name of the website.
   * 
   * > A forwarding rule must be configured for a domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.
   * 
   * This parameter is required.
   * 
   * @example
   * www.aliyun.com
   */
  domain?: string;
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
   * 
   * @example
   * default
   */
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableWebCCRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableWebCCRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DisableWebCCRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DisableWebCCRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EmptyAutoCcBlacklistRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the instance.
   * 
   * > You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.
   * 
   * This parameter is required.
   * 
   * @example
   * ddoscoo-cn-mp91j1ao****
   */
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EmptyAutoCcBlacklistResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EmptyAutoCcBlacklistResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: EmptyAutoCcBlacklistResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: EmptyAutoCcBlacklistResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EmptyAutoCcWhitelistRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the instance.
   * 
   * > You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.
   * 
   * This parameter is required.
   * 
   * @example
   * ddoscoo-cn-mp91j1ao****
   */
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EmptyAutoCcWhitelistResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EmptyAutoCcWhitelistResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: EmptyAutoCcWhitelistResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: EmptyAutoCcWhitelistResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EmptySlsLogstoreRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
   * 
   * @example
   * default
   */
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EmptySlsLogstoreResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CF33B4C3-196E-4015-AADD-5CAD00057B80
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EmptySlsLogstoreResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: EmptySlsLogstoreResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: EmptySlsLogstoreResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableSceneDefensePolicyRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the policy that you want to enable.
   * 
   * > You can call the [DescribeSceneDefensePolicies](https://help.aliyun.com/document_detail/159382.html) operation to query the IDs of all policies.
   * 
   * This parameter is required.
   * 
   * @example
   * 321a-fd31-df51-****
   */
  policyId?: string;
  static names(): { [key: string]: string } {
    return {
      policyId: 'PolicyId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      policyId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableSceneDefensePolicyResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * F65DF043-E0EB-4796-9467-23DDCDF92C1D
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: yes
   * *   **false**: no
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableSceneDefensePolicyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: EnableSceneDefensePolicyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: EnableSceneDefensePolicyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableWebAccessLogConfigRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name of the website.
   * 
   * > A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.
   * 
   * This parameter is required.
   * 
   * @example
   * www.aliyun.com
   */
  domain?: string;
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
   * 
   * @example
   * default
   */
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableWebAccessLogConfigResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CF33B4C3-196E-4015-AADD-5CAD00057B80
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableWebAccessLogConfigResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: EnableWebAccessLogConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: EnableWebAccessLogConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableWebCCRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name of the website.
   * 
   * > A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.
   * 
   * This parameter is required.
   * 
   * @example
   * www.aliyun.com
   */
  domain?: string;
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
   * 
   * @example
   * default
   */
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableWebCCResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableWebCCResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: EnableWebCCResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: EnableWebCCResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableWebCCRuleRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name of the website.
   * 
   * > A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.
   * 
   * This parameter is required.
   * 
   * @example
   * www.aliyun.com
   */
  domain?: string;
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
   * 
   * @example
   * default
   */
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableWebCCRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableWebCCRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: EnableWebCCRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: EnableWebCCRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyBizBandWidthModeRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the instance.
   * 
   * > You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.
   * 
   * This parameter is required.
   * 
   * @example
   * ddoscoo-cn-zvp2ay9b****
   */
  instanceId?: string;
  /**
   * @remarks
   * The metering method of the burstable clean bandwidth feature. Valid values:
   * 
   * *   **month**: the metering method of monthly 95th percentile
   * *   **day**: the metering method of daily 95th percentile
   * 
   * This parameter is required.
   * 
   * @example
   * month
   */
  mode?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      mode: 'Mode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      mode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyBizBandWidthModeResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request, which is used to locate and troubleshoot issues.
   * 
   * @example
   * CF33B4C3-196E-4015-AADD-5CAD00057B80
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyBizBandWidthModeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyBizBandWidthModeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyBizBandWidthModeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyBlackholeStatusRequest extends $tea.Model {
  /**
   * @remarks
   * The action that you want to perform on the instance. Set the value to **undo**, which indicates that you want to deactivate blackhole filtering.
   * 
   * This parameter is required.
   * 
   * @example
   * undo
   */
  blackholeStatus?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * > You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.
   * 
   * This parameter is required.
   * 
   * @example
   * ddoscoo-cn-mp91j1ao****
   */
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      blackholeStatus: 'BlackholeStatus',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      blackholeStatus: 'string',
      instanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyBlackholeStatusResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyBlackholeStatusResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyBlackholeStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyBlackholeStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyBlockStatusRequest extends $tea.Model {
  /**
   * @remarks
   * The blocking period. Valid values: **15** to **43200**. Unit: minutes.
   * 
   * > If you set **Status** to **do**, you must also specify this parameter.
   * 
   * @example
   * 60
   */
  duration?: number;
  /**
   * @remarks
   * The ID of the Anti-DDoS Pro instance to manage.
   * 
   * > You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.
   * 
   * This parameter is required.
   * 
   * @example
   * ddoscoo-cn-mp91j1ao****
   */
  instanceId?: string;
  /**
   * @remarks
   * An array consisting of the Internet service provider (ISP) lines from which traffic is blocked.
   * 
   * This parameter is required.
   * 
   * @example
   * ct
   */
  lines?: string[];
  /**
   * @remarks
   * Specifies the status of the Diversion from Origin Server policy. Valid values:
   * 
   * *   **do**: enables the policy.
   * *   **undo**: disables the policy.
   * 
   * This parameter is required.
   * 
   * @example
   * do
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      duration: 'Duration',
      instanceId: 'InstanceId',
      lines: 'Lines',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      duration: 'number',
      instanceId: 'string',
      lines: { 'type': 'array', 'itemType': 'string' },
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyBlockStatusResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyBlockStatusResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyBlockStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyBlockStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyCnameReuseRequest extends $tea.Model {
  /**
   * @remarks
   * The CNAME record that you want to reuse for the website.
   * 
   * @example
   * 4o6ep6q217k9****.aliyunddos0004.com
   */
  cname?: string;
  /**
   * @remarks
   * The domain name of the website.
   * 
   * > A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.
   * 
   * This parameter is required.
   * 
   * @example
   * www.aliyun.com
   */
  domain?: string;
  /**
   * @remarks
   * Specifies whether to enable CNAME reuse. Valid values:
   * 
   * *   **0:** disabled
   * *   **1:** enabled
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  enable?: number;
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
   * 
   * @example
   * default
   */
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      cname: 'Cname',
      domain: 'Domain',
      enable: 'Enable',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cname: 'string',
      domain: 'string',
      enable: 'number',
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyCnameReuseResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyCnameReuseResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyCnameReuseResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyCnameReuseResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDomainResourceRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name that is added to the Anti-DDoS Pro or Anti-DDoS Premium instance.
   * 
   * This parameter is required.
   * 
   * @example
   * www.example.com
   */
  domain?: string;
  /**
   * @remarks
   * The advanced HTTPS settings. This parameter takes effect only when the value of the **ProxyType** parameter includes **https**. The value is a string that consists of a JSON struct. The JSON struct contains the following fields:
   * 
   * *   **Http2https**: specifies whether to turn on Enforce HTTPS Routing. This field is optional and must be an integer. Valid values: **0** and **1**. The value 0 indicates that Enforce HTTPS Routing is turned off. The value 1 indicates that Enforce HTTPS Routing is turned on. The default value is 0.
   * 
   *     If your website supports both HTTP and HTTPS, this feature meets your business requirements. If you enable this feature, all HTTP requests to access the website are redirected to HTTPS requests on the standard port 443.
   * 
   * *   **Https2http**: specifies whether to turn on Enable HTTP. This field is optional and must be an integer. Valid values: **0** and **1**. The value 0 indicates that Enable HTTP is turned off. The value 1 indicates that Enable HTTP is turned on. The default value is 0.
   * 
   *     If your website does not support HTTPS, this feature meets your business requirements If this feature is enabled, all HTTPS requests are redirected to HTTP requests and forwarded to origin servers. This feature can redirect WebSockets requests to WebSocket requests. Requests are redirected over the standard port 80.
   * 
   * *   **Http2**: specifies whether to turn on Enable HTTP/2. This field is optional. Data type: integer. Valid values: **0** and **1**. The value 0 indicates that Enable HTTP/2 is turned off. The value 1 indicates that Enable HTTP/2 is turned on. The default value is 0.
   * 
   *     After you turn on the switch, HTTP/2 is used.
   * 
   * @example
   * {"Http2":1,"Http2https":1,"Https2http":1}
   */
  httpsExt?: string;
  /**
   * @remarks
   * An array consisting of the IDs of instances that you want to associate.
   * 
   * This parameter is required.
   */
  instanceIds?: string[];
  /**
   * @remarks
   * The details about the protocol type and port number.
   * 
   * This parameter is required.
   */
  proxyTypes?: ModifyDomainResourceRequestProxyTypes[];
  /**
   * @remarks
   * An array that consists of the addresses of origin servers.
   * 
   * This parameter is required.
   */
  realServers?: string[];
  /**
   * @remarks
   * The address type of the origin server. Valid values:
   * 
   * *   **0**: IP address
   * 
   * *   **1**: domain name
   * 
   *     If you deploy proxies, such as a Web Application Firewall (WAF) instance, between the origin server and the Anti-DDoS Pro or Anti-DDoS Premium instance, set the value to 1. If you use the domain name, you must enter the address of the proxy, such as the CNAME of WAF.
   * 
   * This parameter is required.
   * 
   * @example
   * 0
   */
  rsType?: number;
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
      httpsExt: 'HttpsExt',
      instanceIds: 'InstanceIds',
      proxyTypes: 'ProxyTypes',
      realServers: 'RealServers',
      rsType: 'RsType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
      httpsExt: 'string',
      instanceIds: { 'type': 'array', 'itemType': 'string' },
      proxyTypes: { 'type': 'array', 'itemType': ModifyDomainResourceRequestProxyTypes },
      realServers: { 'type': 'array', 'itemType': 'string' },
      rsType: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDomainResourceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 39499F01-19D9-4EA4-A0E9-C6014BA5CDBE
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDomainResourceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyDomainResourceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyDomainResourceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyElasticBandWidthRequest extends $tea.Model {
  /**
   * @remarks
   * The new burstable protection bandwidth that you want to use. Unit: Gbit/s.
   * 
   * > You can call the [DescribeElasticBandwidthSpec](https://help.aliyun.com/document_detail/91502.html) operation to query the available burstable protection bandwidth of the instance.
   * 
   * This parameter is required.
   * 
   * @example
   * 50
   */
  elasticBandwidth?: number;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * >  The instance must be in a normal state. You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.
   * 
   * This parameter is required.
   * 
   * @example
   * ddoscoo-cn-mp91j1ao****
   */
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      elasticBandwidth: 'ElasticBandwidth',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      elasticBandwidth: 'number',
      instanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyElasticBandWidthResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyElasticBandWidthResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyElasticBandWidthResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyElasticBandWidthResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyElasticBizBandWidthRequest extends $tea.Model {
  /**
   * @remarks
   * The burstable clean bandwidth. Unit: Mbit/s. The burstable clean bandwidth cannot exceed nine times the clean bandwidth of your Anti-DDoS Pro or Anti-DDoS Premium instance, and the sum of the clean bandwidth and the burstable clean bandwidth cannot exceed the maximum clean bandwidth that is supported by your instance. The value 0 indicates that the burstable clean bandwidth feature is disabled. You can disable the burstable clean bandwidth feature once a month.
   * 
   * This parameter is required.
   * 
   * @example
   * 0
   */
  elasticBizBandwidth?: number;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * > You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.
   * 
   * This parameter is required.
   * 
   * @example
   * ddoscoo-cn-tl32morr****
   */
  instanceId?: string;
  /**
   * @remarks
   * The metering method of the burstable clean bandwidth feature. Valid values:
   * 
   * *   **month**: the metering method of monthly 95th percentile
   * *   **day**: the metering method of daily 95th percentile
   * 
   * @example
   * month
   */
  mode?: string;
  static names(): { [key: string]: string } {
    return {
      elasticBizBandwidth: 'ElasticBizBandwidth',
      instanceId: 'InstanceId',
      mode: 'Mode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      elasticBizBandwidth: 'number',
      instanceId: 'string',
      mode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyElasticBizBandWidthResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request, which is used to locate and troubleshoot issues.
   * 
   * @example
   * C566BA3A-192F-5D32-8A33-21422F975145
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyElasticBizBandWidthResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyElasticBizBandWidthResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyElasticBizBandWidthResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyElasticBizQpsRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the Anti-DDoS Proxy instance.
   * 
   * >  You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.
   * 
   * This parameter is required.
   * 
   * @example
   * ddoscoo-cn-mp91j1ao****
   */
  instanceId?: string;
  /**
   * @remarks
   * The metering method for the burstable QPS. Valid values:
   * 
   * *   **month**: monthly 95th percentile
   * *   **day**: daily 95th percentile QPS
   * 
   * This parameter is required.
   * 
   * @example
   * month
   */
  mode?: string;
  /**
   * @remarks
   * The burstable QPS value.
   * 
   * >  The default value is 300,000 for the Chinese mainland and 150,000 for regions outside the Chinese mainland.
   * 
   * @example
   * 300000
   */
  opsElasticQps?: number;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      mode: 'Mode',
      opsElasticQps: 'OpsElasticQps',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      mode: 'string',
      opsElasticQps: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyElasticBizQpsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID, which is used to locate and troubleshoot issues.
   * 
   * @example
   * 0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyElasticBizQpsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyElasticBizQpsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyElasticBizQpsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyFullLogTtlRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
   * 
   * @example
   * default
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The log storage duration of a website. Valid values: **30** to **180**. Unit: days.
   * 
   * This parameter is required.
   * 
   * @example
   * 30
   */
  ttl?: number;
  static names(): { [key: string]: string } {
    return {
      resourceGroupId: 'ResourceGroupId',
      ttl: 'Ttl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resourceGroupId: 'string',
      ttl: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyFullLogTtlResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyFullLogTtlResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyFullLogTtlResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyFullLogTtlResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyHeadersRequest extends $tea.Model {
  /**
   * @remarks
   * The key-value pair of the custom header. The key specifies the header name, and the value specifies the header value. You can specify up to five key-value pairs. The key-value pairs can be up to 200 characters in length.
   * 
   * Take note of the following items:
   * 
   * *   Do not use X-Forwarded-ClientSrcPort as a custom header.
   * *   Do not use a standard HTTP header such as User-Agent. Otherwise, the original header may be overwritten.
   * 
   * >  If you specify a key of X-Forwarded-ClientSrcPort, the system obtains the originating port of the client that accesses Anti-DDoS Proxy (a Layer 7 proxy). In this case, the value is an empty string.
   * 
   * This parameter is required.
   * 
   * @example
   * {\\"X-Forwarded-ClientSrcPort\\":\\"\\"}
   */
  customHeaders?: string;
  /**
   * @remarks
   * The domain name of the website.
   * 
   * > A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.
   * 
   * This parameter is required.
   * 
   * @example
   * example.aliyundoc.com
   */
  domain?: string;
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs.
   * 
   * > 
   * 
   * *   You can query resource group IDs in the Anti-DDoS Pro or Anti-DDoS Premium console or by calling the [ListResourceGroups](https://help.aliyun.com/document_detail/158855.html) operation. For more information, see [View basic information of a resource group](https://help.aliyun.com/document_detail/151181.html).
   * 
   * *   Before you modify the resource group to which an instance belongs, you can call the [ListResources](https://help.aliyun.com/document_detail/158866.html) operation to view the current resource group of the instance.
   * 
   * @example
   * rg-acfmz6jbof5****
   */
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      customHeaders: 'CustomHeaders',
      domain: 'Domain',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      customHeaders: 'string',
      domain: 'string',
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyHeadersResponseBody extends $tea.Model {
  /**
   * @remarks
   * The unique ID of the request, which is used to locate and troubleshoot issues.
   * 
   * @example
   * DC38A1D3-C042-5670-8394-8F6B1FA97B5E
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyHeadersResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyHeadersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyHeadersResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyHealthCheckConfigRequest extends $tea.Model {
  /**
   * @remarks
   * The forwarding protocol. Valid values:
   * 
   * *   **tcp**
   * *   **udp**
   * 
   * This parameter is required.
   * 
   * @example
   * tcp
   */
  forwardProtocol?: string;
  /**
   * @remarks
   * The forwarding port.
   * 
   * This parameter is required.
   * 
   * @example
   * 8080
   */
  frontendPort?: number;
  /**
   * @remarks
   * The details of the health check configuration. This parameter is a JSON string. The string contains the following fields:
   * 
   * *   **Type**: the protocol type. This field is required and must be of the STRING type. Valid values: **tcp** (Layer 4) and **http** (Layer 7).
   * 
   * *   **Domain**: the domain name, which must be of the STRING type.
   * 
   *     **
   * 
   *     **Note**This parameter is returned only when the Layer 7 health check configuration is queried.
   * 
   * *   **Uri**: the check path, which must be of the STRING type.
   * 
   *     **
   * 
   *     **Note**This parameter is returned only when the Layer 7 health check configuration is queried.
   * 
   * *   **Timeout**: the response timeout period, which must be of the INTEGER type. Valid values: **1** to **30**. Unit: seconds.
   * 
   * *   **Port**: the port on which you want to perform the health check, which must be of the INTEGER type.
   * 
   * *   **Interval**: the health check interval, which must be of the INTEGER type. Valid values: **1** to **30**. Unit: seconds.
   * 
   * *   **Up**: the number of consecutive successful health checks that must occur before declaring a port healthy, which must be of the INTEGER type. Valid values: **1** to **10**.
   * 
   * *   **Down**: the number of consecutive failed health checks that must occur before declaring a port unhealthy, which must be of the INTEGER type. Valid values: **1** to **10**.
   * 
   * This parameter is required.
   * 
   * @example
   * {"Type":"tcp","Timeout":10,"Port":8080,"Interval":10,"Up":10,"Down":40}
   */
  healthCheck?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * > You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.
   * 
   * This parameter is required.
   * 
   * @example
   * ddoscoo-cn-mp91j1ao****
   */
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      forwardProtocol: 'ForwardProtocol',
      frontendPort: 'FrontendPort',
      healthCheck: 'HealthCheck',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      forwardProtocol: 'string',
      frontendPort: 'number',
      healthCheck: 'string',
      instanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyHealthCheckConfigResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyHealthCheckConfigResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyHealthCheckConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyHealthCheckConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyHttp2EnableRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name of the website.
   * 
   * > A forwarding rule must be configured for the domain name, and the domain name must be associated with an instance that uses the Enhanced function plan. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.
   * 
   * This parameter is required.
   * 
   * @example
   * www.aliyun.com
   */
  domain?: string;
  /**
   * @remarks
   * Specifies whether to enable HTTP/2. Valid values:
   * 
   * *   **0**: disables HTTP/2.
   * *   **1**: enables HTTP/2.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  enable?: number;
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
   * 
   * @example
   * default
   */
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
      enable: 'Enable',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
      enable: 'number',
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyHttp2EnableResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyHttp2EnableResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyHttp2EnableResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyHttp2EnableResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceRemarkRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the instance.
   * 
   * > You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.
   * 
   * This parameter is required.
   * 
   * @example
   * ddoscoo-cn-mp91j1ao****
   */
  instanceId?: string;
  /**
   * @remarks
   * The description of the instance.
   * 
   * The value can contain letters, digits, and some special characters, such as`, . + - * / _` The value can be up to 500 characters in length.
   * 
   * This parameter is required.
   * 
   * @example
   * new-remark
   */
  remark?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      remark: 'Remark',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      remark: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceRemarkResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request, which is used to locate and troubleshoot issues.
   * 
   * @example
   * 7EFA2BA6-9C0A-4410-B735-FC337EB634A1
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceRemarkResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyInstanceRemarkResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyInstanceRemarkResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyNetworkRuleAttributeRequest extends $tea.Model {
  /**
   * @remarks
   * The session persistence settings of the port forwarding rule. This parameter is a JSON string. The string contains the following fields:
   * 
   * *   **PersistenceTimeout**: The timeout period of session persistence. This field is required and must be of the integer type. Valid values: **30** to **3600**. Unit: seconds. Default value: **0**. A value of 0 indicates that session persistence is disabled.
   * 
   * This parameter is required.
   * 
   * @example
   * {"PersistenceTimeout":900}
   */
  config?: string;
  /**
   * @remarks
   * The forwarding protocol. Valid values:
   * 
   * *   **tcp**
   * *   **udp**
   * 
   * This parameter is required.
   * 
   * @example
   * tcp
   */
  forwardProtocol?: string;
  /**
   * @remarks
   * The forwarding port.
   * 
   * This parameter is required.
   * 
   * @example
   * 8080
   */
  frontendPort?: number;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * > You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.
   * 
   * This parameter is required.
   * 
   * @example
   * ddoscoo-cn-mp91j1ao****
   */
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      config: 'Config',
      forwardProtocol: 'ForwardProtocol',
      frontendPort: 'FrontendPort',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      config: 'string',
      forwardProtocol: 'string',
      frontendPort: 'number',
      instanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyNetworkRuleAttributeResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyNetworkRuleAttributeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyNetworkRuleAttributeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyNetworkRuleAttributeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyOcspStatusRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name for which you want to configure the Static Page Caching policy.
   * 
   * > You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all the domain names that are added to Anti-DDoS Pro or Anti-DDoS Premium.
   * 
   * This parameter is required.
   * 
   * @example
   * click.linktech.cn
   */
  domain?: string;
  /**
   * @remarks
   * Specifies whether to enable the OCSP feature. Valid values:
   * 
   * *   **1**: yes
   * *   **0**: no
   * 
   * This parameter is required.
   */
  enable?: number;
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
      enable: 'Enable',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
      enable: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyOcspStatusResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request, which is used to locate and troubleshoot issues.
   * 
   * @example
   * D8DDBA8E-8182-5C85-AA41-F17EACFCAE0D
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyOcspStatusResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyOcspStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyOcspStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyPortRequest extends $tea.Model {
  /**
   * @remarks
   * The port of the origin server. Valid values: **0** to **65535**.
   * 
   * This parameter is required.
   * 
   * @example
   * 55
   */
  backendPort?: string;
  /**
   * @remarks
   * The forwarding port. Valid values: **0** to **65535**.
   * 
   * This parameter is required.
   * 
   * @example
   * 55
   */
  frontendPort?: string;
  /**
   * @remarks
   * The type of the protocol. Valid values:
   * 
   * *   **tcp**
   * *   **udp**
   * 
   * This parameter is required.
   * 
   * @example
   * tcp
   */
  frontendProtocol?: string;
  /**
   * @remarks
   * The ID of the Anti-DDoS Pro or Anti-DDoS Premium instance to which the port forwarding rule belongs.
   * 
   * > You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.
   * 
   * This parameter is required.
   * 
   * @example
   * ddoscoo-cn-st21zbyq****
   */
  instanceId?: string;
  /**
   * @remarks
   * An array that consists of the IP addresses of origin servers.
   * 
   * This parameter is required.
   */
  realServers?: string[];
  static names(): { [key: string]: string } {
    return {
      backendPort: 'BackendPort',
      frontendPort: 'FrontendPort',
      frontendProtocol: 'FrontendProtocol',
      instanceId: 'InstanceId',
      realServers: 'RealServers',
    };
  }

  static types(): { [key: string]: any } {
    return {
      backendPort: 'string',
      frontendPort: 'string',
      frontendProtocol: 'string',
      instanceId: 'string',
      realServers: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyPortResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request, which is used to locate and troubleshoot issues.
   * 
   * @example
   * 39499F01-19D9-4EA4-A0E9-C6014BA5CDBE
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyPortResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyPortResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyPortResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyPortAutoCcStatusRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the instance.
   * 
   * > You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.
   * 
   * This parameter is required.
   * 
   * @example
   * ddoscoo-cn-mp91j1ao****
   */
  instanceId?: string;
  /**
   * @remarks
   * The mode of the Intelligent Protection policy. Valid values:
   * 
   * *   **normal**
   * *   **loose**
   * *   **strict**
   * 
   * This parameter is required.
   * 
   * @example
   * normal
   */
  mode?: string;
  /**
   * @remarks
   * Specifies the status of the Intelligent Protection policy. Valid values:
   * 
   * *   **on**: enables the policy.
   * *   **off**: disables the policy.
   * 
   * This parameter is required.
   * 
   * @example
   * on
   */
  switch?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      mode: 'Mode',
      switch: 'Switch',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      mode: 'string',
      switch: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyPortAutoCcStatusResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyPortAutoCcStatusResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyPortAutoCcStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyPortAutoCcStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyQpsModeRequest extends $tea.Model {
  /**
   * @remarks
   * The region ID of the Anti-DDoS Pro instance.
   * 
   * >  You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.
   * 
   * This parameter is required.
   * 
   * @example
   * ddoscoo-cn-7e225i41****
   */
  instanceId?: string;
  /**
   * @remarks
   * The metering method of QPS. Valid values:
   * 
   * *   **month**: monthly 95th percentile QPS.
   * *   **day**: daily 95th percentile QPS.
   * 
   * This parameter is required.
   * 
   * @example
   * month
   */
  mode?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      mode: 'Mode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      mode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyQpsModeResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID, which is used to locate and troubleshoot issues.
   * 
   * @example
   * 48859E14-A9FB-4100-99FF-AAB75CA46776
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyQpsModeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyQpsModeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyQpsModeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifySceneDefensePolicyRequest extends $tea.Model {
  /**
   * @remarks
   * The end time of the policy. The value is a UNIX timestamp. Unit: milliseconds.
   * 
   * This parameter is required.
   * 
   * @example
   * 1586016000000
   */
  endTime?: number;
  /**
   * @remarks
   * The name of the policy.
   * 
   * This parameter is required.
   * 
   * @example
   * testpolicy
   */
  name?: string;
  /**
   * @remarks
   * The ID of the policy that you want to modify.
   * 
   * > You can call the [DescribeSceneDefensePolicies](https://help.aliyun.com/document_detail/159382.html) operation to query the IDs of all policies.
   * 
   * This parameter is required.
   * 
   * @example
   * 321a-fd31-df51-****
   */
  policyId?: string;
  /**
   * @remarks
   * The start time of the policy. The value is a UNIX timestamp. Unit: milliseconds.
   * 
   * This parameter is required.
   * 
   * @example
   * 1585670400000
   */
  startTime?: number;
  /**
   * @remarks
   * The template of the policy. Valid values:
   * 
   * *   **promotion**: important activity
   * *   **bypass**: all traffic forwarded
   * 
   * This parameter is required.
   * 
   * @example
   * promotion
   */
  template?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      name: 'Name',
      policyId: 'PolicyId',
      startTime: 'StartTime',
      template: 'Template',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'number',
      name: 'string',
      policyId: 'string',
      startTime: 'number',
      template: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifySceneDefensePolicyResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * F65DF043-E0EB-4796-9467-23DDCDF92C1D
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful. Valid values:
   * 
   * *   **true**: yes
   * *   **false**: no
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifySceneDefensePolicyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifySceneDefensePolicyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifySceneDefensePolicyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifySchedulerRuleRequest extends $tea.Model {
  /**
   * @remarks
   * The details of the CDN interaction rule. This parameter is a JSON string. The string contains the following fields:
   * 
   * *   **ParamType**: the type of the scheduling rule. This field is required and must be of the string type. Set the value to **cdn**. This indicates that you want to modify a CDN interaction rule.
   * 
   * *   **ParamData**: the values of parameters that you want to modify for the CDN interaction rule. This field is required and must be of the map type. The ParamData parameter contains the following parameters:
   * 
   *     *   **Domain**: the accelerated domain in CDN. This parameter is required and must be of the string type.
   *     *   **Cname**: the CNAME that is assigned to the accelerated domain. This parameter is required and must be of the string type.
   *     *   **AccessQps**: the queries per second (QPS) threshold that is used to switch service traffic to Anti-DDoS Pro or Anti-DDoS Premium. This parameter is required and must be of the integer type.
   *     *   **UpstreamQps**: the QPS threshold that is used to switch service traffic to CDN. This parameter is optional and must be of the integer type.
   * 
   * @example
   * {"ParamType":"cdn","ParamData":"Domain":"example.aliyundoc.com","Cname":"demo.aliyundoc.com","AccessQps":100,"UpstreamQps":100}}
   */
  param?: string;
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
   * 
   * @example
   * default
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The name of the rule that you want to modify.
   * 
   * This parameter is required.
   * 
   * @example
   * testrule
   */
  ruleName?: string;
  /**
   * @remarks
   * The type of the scheduling rule. Valid values:
   * 
   * *   **2**: tiered protection
   * *   **3**: network acceleration
   * *   **5**: CDN interaction
   * *   **6**: cloud service interaction
   * *   **8**: secure acceleration
   * 
   * This parameter is required.
   * 
   * @example
   * 2
   */
  ruleType?: number;
  /**
   * @remarks
   * The details of the scheduling rule. This parameter is a JSON string. The following list describes the fields in the value of the parameter:
   * 
   * *   **Type**: the address type of the interaction resource that you want to use in the scheduling rule. This field is required and must be of the string type. Valid values:
   * 
   *     *   **A**: IP address
   *     *   **CNAME**: domain name
   * 
   * *   **Value**: the address of the interaction resource that you want to use in the scheduling rule. This field is required and must be of the string type.
   * 
   * *   **Priority**: the priority of the scheduling rule. This field is required and must be of the integer type. Valid values: **0** to **100**. A larger value indicates a higher priority.
   * 
   * *   **ValueType**: the type of the interaction resource that you want to use in the scheduling rule. This field is required and must be of the integer type. Valid values:
   * 
   *     *   **1**: the IP address of the Anti-DDoS Pro or Anti-DDoS Premium instance
   *     *   **2**: the IP address of the interaction resource in the tiered protection scenario
   *     *   **3**: the IP address that is used to accelerate access in the network acceleration scenario
   *     *   **5**: the domain name that is configured in Alibaba Cloud CDN (CDN) in the CDN interaction scenario
   *     *   **6** the IP address of the interaction resource in the cloud service interaction scenario
   *     *   **8**: the IP address of the Secure Chinese Mainland Acceleration (Sec-CMA) instance in the secure acceleration scenario
   * 
   * *   **RegionId**: the region where the interaction resource is deployed. This parameter must be specified when **ValueType** is set to **2**. The value must be of the string type.
   * 
   * This parameter is required.
   * 
   * @example
   * [{"Type":"A", "Value":"1.1.XX.XX", "Priority":80,"ValueType":2, "RegionId":"cn-hangzhou" },{"Type":"A", "Value":"203.199.XX.XX", "Priority":80,"ValueType":1}]
   */
  rules?: string;
  static names(): { [key: string]: string } {
    return {
      param: 'Param',
      resourceGroupId: 'ResourceGroupId',
      ruleName: 'RuleName',
      ruleType: 'RuleType',
      rules: 'Rules',
    };
  }

  static types(): { [key: string]: any } {
    return {
      param: 'string',
      resourceGroupId: 'string',
      ruleName: 'string',
      ruleType: 'number',
      rules: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifySchedulerRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * The CNAME that is assigned by Sec-Traffic Manager for the scheduling rule.
   * 
   * > To enable the scheduling rule, you must map the domain name of the service to the CNAME.
   * 
   * @example
   * 48k7b372gpl4****.aliyunddos0001.com
   */
  cname?: string;
  /**
   * @remarks
   * The ID of the request, which is used to locate and troubleshoot issues.
   * 
   * @example
   * FFC77501-BDF8-4BC8-9BF5-B295FBC3189B
   */
  requestId?: string;
  /**
   * @remarks
   * The name of the rule.
   * 
   * @example
   * testrule
   */
  ruleName?: string;
  static names(): { [key: string]: string } {
    return {
      cname: 'Cname',
      requestId: 'RequestId',
      ruleName: 'RuleName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cname: 'string',
      requestId: 'string',
      ruleName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifySchedulerRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifySchedulerRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifySchedulerRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTlsConfigRequest extends $tea.Model {
  /**
   * @remarks
   * The details of the TLS policy. The value is a JSON string that contains the following fields:
   * 
   * *   **ssl_protocols**: the version of TLS. This field is required. Data type: string. Valid values:
   * 
   *     *   **tls1.0**: TLS 1.0 and later
   *     *   **tls1.1**: TLS 1.1 and later
   *     *   **tls1.2**: TLS 1.2 and later
   * 
   * *   **ssl_ciphers**: the type of the cipher suite. This field is required. Data type: string. Valid values:
   * 
   *     *   **all**: all cipher suites, which include strong and weak cipher suites
   *     *   **improved**: enhanced cipher suites
   *     *   **strong**: strong cipher suites
   *     *   **default**: default cipher suites, which include only strong cipher suites
   * 
   * This parameter is required.
   * 
   * @example
   * {"ssl_protocols":"tls1.0","ssl_ciphers":"all"}
   */
  config?: string;
  /**
   * @remarks
   * The domain name of the website.
   * 
   * > A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.
   * 
   * This parameter is required.
   * 
   * @example
   * example.aliyundoc.com
   */
  domain?: string;
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
   * 
   * @example
   * default
   */
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      config: 'Config',
      domain: 'Domain',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      config: 'string',
      domain: 'string',
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTlsConfigResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request, which is used to locate and troubleshoot issues.
   * 
   * @example
   * C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTlsConfigResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyTlsConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyTlsConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyWebAIProtectModeRequest extends $tea.Model {
  /**
   * @remarks
   * The details of the Intelligent Protection policy. This parameter is a JSON string. The string contains the following fields:
   * 
   * *   **AiTemplate**: the level of the Intelligent Protection policy. This field is required and must be of the STRING type. Valid values:
   * 
   *     *   **level30**: the Low level
   *     *   **level60**: the Normal level
   *     *   **level90**: the Strict level
   * 
   * *   **AiMode**: the mode of the Intelligent Protection policy. This field is required and must be of the string type. Valid values:
   * 
   *     *   **watch**: the Warning mode
   *     *   **defense**: the Defense mode
   * 
   * This parameter is required.
   * 
   * @example
   * {"AiTemplate":"level60","AiMode":"defense"}
   */
  config?: string;
  /**
   * @remarks
   * The domain name of the website.
   * 
   * > A forwarding rule must be configured for a domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.
   * 
   * This parameter is required.
   * 
   * @example
   * www.aliyun.com
   */
  domain?: string;
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
   * 
   * @example
   * default
   */
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      config: 'Config',
      domain: 'Domain',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      config: 'string',
      domain: 'string',
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyWebAIProtectModeResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyWebAIProtectModeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyWebAIProtectModeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyWebAIProtectModeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyWebAIProtectSwitchRequest extends $tea.Model {
  /**
   * @remarks
   * The details of the Intelligent Protection policy. This parameter is a JSON string. The string contains the following fields:
   * 
   * *   **AiRuleEnable**: the status of the Intelligent Protection policy. This field is required and must be of the integer type. Valid values:
   * 
   *     *   **0**: disabled
   *     *   **1**: enabled
   * 
   * This parameter is required.
   * 
   * @example
   * {"AiRuleEnable": 1}
   */
  config?: string;
  /**
   * @remarks
   * The domain name of the website.
   * 
   * > A forwarding rule must be configured for a domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.
   * 
   * This parameter is required.
   * 
   * @example
   * www.aliyun.com
   */
  domain?: string;
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
   * 
   * @example
   * default
   */
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      config: 'Config',
      domain: 'Domain',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      config: 'string',
      domain: 'string',
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyWebAIProtectSwitchResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyWebAIProtectSwitchResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyWebAIProtectSwitchResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyWebAIProtectSwitchResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyWebAccessModeRequest extends $tea.Model {
  /**
   * @remarks
   * The mode in which a website service is added to Anti-DDoS Pro or Anti-DDoS Premium. Valid values:
   * 
   * *   **0**: A record mode
   * *   **1**: anti-DDoS mode
   * *   **2**: origin redundancy mode
   * 
   * This parameter is required.
   * 
   * @example
   * 2
   */
  accessMode?: number;
  /**
   * @remarks
   * The domain name of the website.
   * 
   * > A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.
   * 
   * This parameter is required.
   * 
   * @example
   * www.aliyun.com
   */
  domain?: string;
  static names(): { [key: string]: string } {
    return {
      accessMode: 'AccessMode',
      domain: 'Domain',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessMode: 'number',
      domain: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyWebAccessModeResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyWebAccessModeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyWebAccessModeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyWebAccessModeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyWebAreaBlockRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name whose configurations you want to modify.
   * 
   * > A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.
   * 
   * This parameter is required.
   * 
   * @example
   * www.aliyun.com
   */
  domain?: string;
  /**
   * @remarks
   * The regions from which you block requests.
   * 
   * > If you do not configure this parameter, the Blocked Regions (Domain Names) policy is disabled.
   * 
   * @example
   * CN-SHANGHAI
   */
  regions?: string[];
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
   * 
   * For more information about resource groups, see [Create a resource group](https://help.aliyun.com/document_detail/94485.html).
   * 
   * @example
   * rg-acfm2pz25js****
   */
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
      regions: 'Regions',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
      regions: { 'type': 'array', 'itemType': 'string' },
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyWebAreaBlockResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 5AA2BD65-E289-4E91-9DD9-3E1FB2140D17
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyWebAreaBlockResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyWebAreaBlockResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyWebAreaBlockResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyWebAreaBlockSwitchRequest extends $tea.Model {
  /**
   * @remarks
   * Specifies whether to enable or disable the Location Blacklist (Domain Names) policy for a domain name. The value is a string that consists of a JSON struct. The JSON struct contains the following parameters:
   * 
   * *   **RegionblockEnable**: the status of the Location Blacklist (Domain Names) policy. This parameter is required and must be of the INTEGER type. Valid values:
   * 
   *     *   **1**: enables the policy.
   *     *   **0**: disables the policy.
   * 
   * This parameter is required.
   * 
   * @example
   * {"RegionblockEnable": 1}
   */
  config?: string;
  /**
   * @remarks
   * The domain name for which you want to enable or disable the Location Blacklist policy.
   * 
   * > You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all the domain names that are added to Anti-DDoS Pro or Anti-DDoS Premium.
   * 
   * This parameter is required.
   * 
   * @example
   * www.aliyundoc.com
   */
  domain?: string;
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management.
   * 
   * If you do not configure this parameter, the instance belongs to the default resource group.
   * 
   * @example
   * rg-acfm2pz25js****
   */
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      config: 'Config',
      domain: 'Domain',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      config: 'string',
      domain: 'string',
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyWebAreaBlockSwitchResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 6623EA1F-30FB-5BC8-BEC9-74D55F6F08F1
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyWebAreaBlockSwitchResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyWebAreaBlockSwitchResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyWebAreaBlockSwitchResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyWebCCGlobalSwitchRequest extends $tea.Model {
  /**
   * @remarks
   * Specifies whether the HTTP flood mitigation feature is enabled. Valid values:
   * 
   * *   **open**
   * *   **close**
   * 
   * This parameter is required.
   * 
   * @example
   * open
   */
  ccGlobalSwitch?: string;
  /**
   * @remarks
   * The domain name of the website.
   * 
   * >  A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.
   * 
   * This parameter is required.
   * 
   * @example
   * example.aliyundoc.com
   */
  domain?: string;
  static names(): { [key: string]: string } {
    return {
      ccGlobalSwitch: 'CcGlobalSwitch',
      domain: 'Domain',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ccGlobalSwitch: 'string',
      domain: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyWebCCGlobalSwitchResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 5AE2FC86-C840-41AE-9F1A-3A2747C7C1DF
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyWebCCGlobalSwitchResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyWebCCGlobalSwitchResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyWebCCGlobalSwitchResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyWebCCRuleRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * close
   */
  act?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 3
   */
  count?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * www.aliyun.com
   */
  domain?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 30
   */
  interval?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * prefix
   */
  mode?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * testrule
   */
  name?: string;
  /**
   * @example
   * default
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The blocking duration. Valid values: **60** to **86400**. Unit: seconds.
   * 
   * This parameter is required.
   * 
   * @example
   * 60
   */
  ttl?: number;
  /**
   * @remarks
   * The check path.
   * 
   * >  You cannot modify the Uniform Resource Identifier (URI). The domain name of the website, the check path, and the rule name uniquely identify a rule.
   * 
   * This parameter is required.
   * 
   * @example
   * /abc
   */
  uri?: string;
  static names(): { [key: string]: string } {
    return {
      act: 'Act',
      count: 'Count',
      domain: 'Domain',
      interval: 'Interval',
      mode: 'Mode',
      name: 'Name',
      resourceGroupId: 'ResourceGroupId',
      ttl: 'Ttl',
      uri: 'Uri',
    };
  }

  static types(): { [key: string]: any } {
    return {
      act: 'string',
      count: 'number',
      domain: 'string',
      interval: 'number',
      mode: 'string',
      name: 'string',
      resourceGroupId: 'string',
      ttl: 'number',
      uri: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyWebCCRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyWebCCRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyWebCCRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyWebCCRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyWebCacheCustomRuleRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name of the website.
   * 
   * > A forwarding rule must be configured for the domain name, and the domain name must be associated with an instance that uses the Enhanced function plan. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.
   * 
   * This parameter is required.
   * 
   * @example
   * www.aliyun.com
   */
  domain?: string;
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
   * 
   * @example
   * default
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The details of the custom rule. This parameter is a JSON string. The string contains the following fields:
   * 
   * *   **Name**: the name of the rule. This field is required and must be of the string type.
   * 
   * *   **Uri**: the path to the cached page. This field is required and must be of the STRING type.
   * 
   * *   **Mode**: the cache mode. This field is required and must be of the STRING type. Valid values:
   * 
   *     *   **standard**: uses the standard mode.
   *     *   **aggressive**: uses the enhanced mode.
   *     *   **bypass**: No data is cached.
   * 
   * *   **CacheTtl**: the expiration time of the page cache. This field is required and must be of the INTEGER type. Unit: seconds.
   * 
   * This parameter is required.
   * 
   * @example
   * [{"Name": "test","Uri": "/a","Mode": "standard","CacheTtl": 3600}]
   */
  rules?: string;
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
      resourceGroupId: 'ResourceGroupId',
      rules: 'Rules',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
      resourceGroupId: 'string',
      rules: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyWebCacheCustomRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyWebCacheCustomRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyWebCacheCustomRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyWebCacheCustomRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyWebCacheModeRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name of the website.
   * 
   * > A forwarding rule must be configured for the domain name, and the domain name must be associated with an instance that uses the Enhanced function plan. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.
   * 
   * This parameter is required.
   * 
   * @example
   * www.aliyun.com
   */
  domain?: string;
  /**
   * @remarks
   * The cache mode of the Static Page Caching policy. Valid values:
   * 
   * *   **standard**: uses the standard cache mode.
   * *   **aggressive**: uses the enhanced cache mode.
   * *   **bypass**: caches no data.
   * 
   * This parameter is required.
   * 
   * @example
   * standard
   */
  mode?: string;
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
   * 
   * @example
   * default
   */
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
      mode: 'Mode',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
      mode: 'string',
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyWebCacheModeResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyWebCacheModeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyWebCacheModeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyWebCacheModeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyWebCacheSwitchRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name for which you want to configure the Static Page Caching policy.
   * 
   * > You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all the domain names that are added to Anti-DDoS Pro or Anti-DDoS Premium.
   * 
   * This parameter is required.
   * 
   * @example
   * www.aliyundoc.com
   */
  domain?: string;
  /**
   * @remarks
   * Specifies whether to enable or disable the Static Page Caching policy for a website. Valid values:
   * 
   * *   **1**: enables the policy.
   * *   **0**: disables the policy.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  enable?: number;
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management.
   * 
   * If you do not configure this parameter, the instance belongs to the default resource group.
   * 
   * @example
   * rg-acfm2pz25js****
   */
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
      enable: 'Enable',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
      enable: 'number',
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyWebCacheSwitchResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 6623EA1F-30FB-5BC8-BEC9-74D55F6F08F1
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyWebCacheSwitchResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyWebCacheSwitchResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyWebCacheSwitchResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyWebIpSetSwitchRequest extends $tea.Model {
  /**
   * @remarks
   * The details of the Blacklist/Whitelist (Domain Names) feature. This parameter is a JSON string. The value consists of the following fields:
   * 
   * **bwlist_enable**: the status of the Blacklist/Whitelist (Domain Names) feature. This field is required and must be of the integer type. Valid values:
   * 
   * *   0: turned off
   * *   1: turned on
   * 
   * This parameter is required.
   * 
   * @example
   * {"BwlistEnable":1}
   */
  config?: string;
  /**
   * @remarks
   * The domain name of the website.
   * 
   * > A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.
   * 
   * This parameter is required.
   * 
   * @example
   * www.aliyun.com
   */
  domain?: string;
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
   * 
   * @example
   * default
   */
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      config: 'Config',
      domain: 'Domain',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      config: 'string',
      domain: 'string',
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyWebIpSetSwitchResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyWebIpSetSwitchResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyWebIpSetSwitchResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyWebIpSetSwitchResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyWebPreciseAccessRuleRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name of the website.
   * 
   * > A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.
   * 
   * This parameter is required.
   * 
   * @example
   * example.aliyundoc.com
   */
  domain?: string;
  /**
   * @remarks
   * The validity period of the rule. Unit: seconds. This parameter takes effect only when **action** of a rule is **block**. Access requests that match the rule are blocked within the specified validity period of the rule. If you do not specify this parameter, this rule takes effect all the time.
   * 
   * @example
   * 600
   */
  expires?: number;
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
   * 
   * @example
   * rg-acfm2pz25js****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The settings of the accurate access control rule. This parameter is a JSON string. The following list describes the fields in the value of the parameter:
   * 
   * *   **action**: the action that is performed if the rule is matched. This field is required and must be of the string type. Valid values:
   * 
   *     *   **accept**: allows the requests that match the rule.
   *     *   **block**: blocks the requests that match the rule.
   *     *   **challenge**: implements a CAPTCHA for the requests that match the rule.
   * 
   * *   **name**: the name of the rule. This field is required and must be of the string type.
   * 
   * *   **condition**: the match conditions. This field is required and must be of the map type. A match condition contains the following parameters.
   * 
   *     **
   * 
   *     **Note**The AND logical operator is used to define the relationship among multiple match conditions.
   * 
   *     *   **field**: the match field. This parameter is required and must be of the string type.
   * 
   *     *   **match_method**: the logical relation. This parameter is required and must be of the string type.
   * 
   *         **
   * 
   *         **Note**For information about the mappings between the **field** and **match_method** parameters, see the Mappings between the field and match_method parameters table in this topic.
   * 
   *     *   **content**: the match content. This parameter is required and must be of the string type.
   * 
   * *   **header_name**: the HTTP header. This parameter is optional and must be of the string type. This parameter takes effect only when **field** is **header**.
   * 
   * This parameter is required.
   * 
   * @example
   * [{"action":"block","name":"testrule","condition":[{"field":"uri","match_method":"contain","content":"/test/123"}]}]
   */
  rules?: string;
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
      expires: 'Expires',
      resourceGroupId: 'ResourceGroupId',
      rules: 'Rules',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
      expires: 'number',
      resourceGroupId: 'string',
      rules: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyWebPreciseAccessRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request, which is used to locate and troubleshoot issues.
   * 
   * @example
   * F908E959-ADA8-4D7B-8A05-FF2F67F50964
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyWebPreciseAccessRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyWebPreciseAccessRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyWebPreciseAccessRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyWebPreciseAccessSwitchRequest extends $tea.Model {
  /**
   * @remarks
   * The configuration of the Accurate Access Control policy. This parameter is a JSON string. The string contains the following fields:
   * 
   * *   **PreciseRuleEnable**: the status of the Accurate Access Control policy. This field is required and must be of the INTEGER type. Valid values:
   * 
   *     *   **0**: disables the policy.
   *     *   **1**: enables the policy.
   * 
   * This parameter is required.
   * 
   * @example
   * {"PreciseRuleEnable":0}
   */
  config?: string;
  /**
   * @remarks
   * The domain name of the website.
   * 
   * > A forwarding rule must be configured for a domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.
   * 
   * This parameter is required.
   * 
   * @example
   * www.aliyun.com
   */
  domain?: string;
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
   * 
   * @example
   * default
   */
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      config: 'Config',
      domain: 'Domain',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      config: 'string',
      domain: 'string',
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyWebPreciseAccessSwitchResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyWebPreciseAccessSwitchResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyWebPreciseAccessSwitchResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyWebPreciseAccessSwitchResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyWebRuleRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * www.aliyun.com
   */
  domain?: string;
  /**
   * @example
   * {"Http2":1,"Http2https":1,"Https2http":1}
   */
  httpsExt?: string;
  /**
   * @example
   * ddoscoo-cn-mp91j1ao****
   */
  instanceIds?: string[];
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * [{"ProxyType":"https","ProxyPorts":[443]}]
   */
  proxyTypes?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 1.xxx.xxx.1
   */
  realServers?: string[];
  /**
   * @example
   * rg-acfm2pz25js****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 0
   */
  rsType?: number;
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
      httpsExt: 'HttpsExt',
      instanceIds: 'InstanceIds',
      proxyTypes: 'ProxyTypes',
      realServers: 'RealServers',
      resourceGroupId: 'ResourceGroupId',
      rsType: 'RsType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
      httpsExt: 'string',
      instanceIds: { 'type': 'array', 'itemType': 'string' },
      proxyTypes: 'string',
      realServers: { 'type': 'array', 'itemType': 'string' },
      resourceGroupId: 'string',
      rsType: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyWebRuleResponseBody extends $tea.Model {
  /**
   * @example
   * CB3261D2-7D1B-4ADA-9E98-A200B2CDA2DC
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyWebRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyWebRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyWebRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReleaseInstanceRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * ddoscoo-cn-mp91j1ao****
   */
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReleaseInstanceResponseBody extends $tea.Model {
  /**
   * @example
   * 06FFAF5F-CD3E-4886-A849-AAB40DFF6515
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReleaseInstanceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ReleaseInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ReleaseInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SwitchSchedulerRuleRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the scheduling rule to manage.
   * 
   * > You can call the [DescribeSchedulerRules](https://help.aliyun.com/document_detail/157481.html) operation to query the names of all scheduling rules.
   * 
   * This parameter is required.
   * 
   * @example
   * testrule
   */
  ruleName?: string;
  /**
   * @remarks
   * The type of the scheduling rule. Valid values:
   * 
   * *   **2**: tiered protection rule
   * *   **3**: network acceleration rule
   * *   **5**: Alibaba Cloud CDN (CDN) interaction rule
   * *   **6**: cloud service interaction rule
   * 
   * This parameter is required.
   * 
   * @example
   * 6
   */
  ruleType?: number;
  /**
   * @remarks
   * The configuration that is used to switch service traffic. This parameter is a string that consists of JSON arrays. Each element in a JSON array is a JSON struct that includes the following parameters:
   * 
   * *   **Value**: required. The IP address of the associated resource. Data type: string.
   * 
   * *   **State**: required. The operation type. Data type: integer. Valid values:
   * 
   *     *   **0**: switches service traffic from the associated resource to your Anti-DDoS Pro or Anti-DDoS Premium instance for scrubbing.
   *     *   **1**: switches service traffic back to the associated cloud resource.
   * 
   * *   **Interval**: optional. The waiting time that is required before the service traffic is switched back. Unit: minutes. Data type: integer. Usage notes:
   * 
   *     *   If the **State** parameter is set to **0**, you must set this parameter to \\*\\*-1\\*\\*. Otherwise, the call fails.
   *     *   If the **State** parameter is set to **1**, you do not need to set this parameter.
   * 
   * This parameter is required.
   * 
   * @example
   * [{"Value":"39.104.XX.XX","State":0,"Interval":-1}]
   */
  switchData?: string;
  static names(): { [key: string]: string } {
    return {
      ruleName: 'RuleName',
      ruleType: 'RuleType',
      switchData: 'SwitchData',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ruleName: 'string',
      ruleType: 'number',
      switchData: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SwitchSchedulerRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 7E3C301F-84BB-50E4-9DB9-2937B2429C1E
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SwitchSchedulerRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SwitchSchedulerRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SwitchSchedulerRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDomainResourceRequestProxyTypes extends $tea.Model {
  /**
   * @remarks
   * The port numbers.
   * 
   * This parameter is required.
   */
  proxyPorts?: number[];
  /**
   * @remarks
   * The type of the protocol. Valid values:
   * 
   * *   **http**
   * *   **https**
   * *   **websocket**
   * *   **websockets**
   * 
   * @example
   * http
   */
  proxyType?: string;
  static names(): { [key: string]: string } {
    return {
      proxyPorts: 'ProxyPorts',
      proxyType: 'ProxyType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      proxyPorts: { 'type': 'array', 'itemType': 'number' },
      proxyType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTagResourcesRequestTags extends $tea.Model {
  /**
   * @remarks
   * The key of the tag to add.
   * 
   * @example
   * testkey
   */
  key?: string;
  /**
   * @remarks
   * The value of the tag to add.
   * 
   * @example
   * testvalue
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAsyncTasksResponseBodyAsyncTasks extends $tea.Model {
  /**
   * @remarks
   * The end time of the task. This value is a UNIX timestamp. Unit: milliseconds.
   * 
   * @example
   * 157927362000
   */
  endTime?: number;
  /**
   * @remarks
   * The start time of the task. The value is a UNIX timestamp. Unit: milliseconds.
   * 
   * @example
   * 156927362000
   */
  startTime?: number;
  /**
   * @remarks
   * The ID of the job.
   * 
   * @example
   * 1
   */
  taskId?: number;
  /**
   * @remarks
   * The task parameter. The value is a JSON string. The returned field in the value varies based on the value of **TaskType**.
   * 
   * If **TaskType** is set to **1**, **3**, **4**, **5**, or **6**, the following filed is returned:
   * 
   * *   **instanceId**: the ID of the instance. Data type: string.
   * 
   * If **TaskType** is set to **2**, the following field is returned:
   * 
   * *   **domain**: the domain name of the website. Data type: string.
   * 
   * @example
   * {"instanceId": "ddoscoo-cn-mp91j1ao****"}
   */
  taskParams?: string;
  /**
   * @remarks
   * The execution result of the task. The value is a JSON string. The returned fields in the value vary based on the value of **TaskType**.
   * 
   * If **TaskType** is set to **1**, **3**, **4**, **5**, or **6**, the following fields are returned:
   * 
   * *   **instanceId**: the ID of the instance. Data type: string.
   * *   **url**: the URL to download the exported file from Object Storage Service (OSS). Data type: string.
   * 
   * If **TaskType** is set to **2**, the following fields are returned:
   * 
   * *   **domain**: the domain name of the website. Data type: string.
   * *   **url**: the URL to download the exported file from OSS. Data type: string.
   * 
   * @example
   * {"instanceId": "ddoscoo-cn-mp91j1ao****","url": "https://****.oss-cn-beijing.aliyuncs.com/heap.bin?Expires=1584785140&OSSAccessKeyId=TMP.3KfzD82FyRJevJdEkRX6JEFHhbvRBBb75PZJnyJmksA2QkMm47xFAFDgMhEV8Nm6Vxr8xExMfiy9LsUFAcLcTBrN3r****&Signature=Sj8BNcsxJLE8l5qm4cjNlDt8gv****"}
   */
  taskResult?: string;
  /**
   * @remarks
   * The status of the task. Valid values:
   * 
   * *   **0**: indicates that the task is being initialized.
   * *   **1**: indicates that the task is in progress.
   * *   **2**: indicates that the task is successful.
   * *   **3**: indicates that the task failed.
   * 
   * @example
   * 2
   */
  taskStatus?: number;
  /**
   * @remarks
   * The type of the task. Valid values:
   * 
   * *   **1**: the task to export the port forwarding rules of an instance
   * *   **2**: the task to export the forwarding rules of a website protected by an instance
   * *   **3**: the task to export the sessions and health check settings of an instance
   * *   **4**: the task to export the mitigation policies of an instance
   * *   **5**: the task to download the blacklist for destination IP addresses of an instance
   * *   **6**: the task to download the whitelist for destination IP addresses of an instance
   * 
   * @example
   * 5
   */
  taskType?: number;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      startTime: 'StartTime',
      taskId: 'TaskId',
      taskParams: 'TaskParams',
      taskResult: 'TaskResult',
      taskStatus: 'TaskStatus',
      taskType: 'TaskType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'number',
      startTime: 'number',
      taskId: 'number',
      taskParams: 'string',
      taskResult: 'string',
      taskStatus: 'number',
      taskType: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAutoCcBlacklistResponseBodyAutoCcBlacklist extends $tea.Model {
  /**
   * @remarks
   * The IP address of the instance.
   * 
   * @example
   * 192.0.XX.XX
   */
  destIp?: string;
  /**
   * @remarks
   * The validity period of the IP address in the blacklist. The value is a UNIX timestamp. Unit: seconds.
   * 
   * @example
   * 1584093569
   */
  endTime?: number;
  /**
   * @remarks
   * The IP address in the blacklist.
   * 
   * @example
   * 47.100.XX.XX
   */
  sourceIp?: string;
  /**
   * @remarks
   * The mode of how the IP address is added to the blacklist. Valid values:
   * 
   * *   **manual**: manually added
   * *   **auto**: automatically added
   * 
   * @example
   * manual
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      destIp: 'DestIp',
      endTime: 'EndTime',
      sourceIp: 'SourceIp',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      destIp: 'string',
      endTime: 'number',
      sourceIp: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAutoCcWhitelistResponseBodyAutoCcWhitelist extends $tea.Model {
  /**
   * @remarks
   * The IP address of the instance.
   * 
   * @example
   * 203.***.***.117
   */
  destIp?: string;
  /**
   * @remarks
   * The validity period of the IP address in the whitelist. Unit: seconds. **0** indicates that the IP address in the whitelist never expires.
   * 
   * @example
   * 0
   */
  endTime?: number;
  /**
   * @remarks
   * The IP addresses that is contained in the IP address whitelist.
   * 
   * @example
   * 2.2.2.2
   */
  sourceIp?: string;
  /**
   * @remarks
   * The mode of how an IP address is added to the whitelist. Valid values:
   * 
   * *   **manual**: manually added
   * *   **auto**: automatically added
   * 
   * @example
   * manual
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      destIp: 'DestIp',
      endTime: 'EndTime',
      sourceIp: 'SourceIp',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      destIp: 'string',
      endTime: 'number',
      sourceIp: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBlackholeStatusResponseBodyBlackholeStatus extends $tea.Model {
  /**
   * @remarks
   * Indicates whether blackhole filtering is triggered for the instance. Valid values:
   * 
   * *   **blackhole**: yes
   * *   **normal**: no
   * 
   * @example
   * blackhole
   */
  blackStatus?: string;
  /**
   * @remarks
   * The end time of blackhole filtering. The value is a UNIX timestamp. Unit: seconds.
   * 
   * @example
   * 1540196323
   */
  endTime?: number;
  /**
   * @remarks
   * The IP address of the instance.
   * 
   * @example
   * 203.***.***.132
   */
  ip?: string;
  /**
   * @remarks
   * The start time of blackhole filtering. The value is a UNIX timestamp. Unit: seconds.
   * 
   * @example
   * 1540195323
   */
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      blackStatus: 'BlackStatus',
      endTime: 'EndTime',
      ip: 'Ip',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      blackStatus: 'string',
      endTime: 'number',
      ip: 'string',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBlockStatusResponseBodyStatusListBlockStatusList extends $tea.Model {
  /**
   * @remarks
   * The blocking status of the network traffic. Valid values:
   * 
   * *   **areablock**: Network traffic is blocked.
   * *   **normal**: Network traffic is not blocked.
   * 
   * @example
   * areablock
   */
  blockStatus?: string;
  /**
   * @remarks
   * The end time of the blocking. This value is a UNIX timestamp. Unit: seconds.
   * 
   * @example
   * 1540196323
   */
  endTime?: number;
  /**
   * @remarks
   * The Internet service provider (ISP) line from which the traffic is blocked. Valid values:
   * 
   * *   **ct**: China Telecom (International)
   * *   **cut**: China Unicom (International)
   * 
   * @example
   * cut
   */
  line?: string;
  /**
   * @remarks
   * The start time of the blocking. This value is a UNIX timestamp. Unit: seconds.
   * 
   * @example
   * 1540195323
   */
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      blockStatus: 'BlockStatus',
      endTime: 'EndTime',
      line: 'Line',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      blockStatus: 'string',
      endTime: 'number',
      line: 'string',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBlockStatusResponseBodyStatusList extends $tea.Model {
  /**
   * @remarks
   * An array that consists of details of the Diversion from Origin Server configuration.
   */
  blockStatusList?: DescribeBlockStatusResponseBodyStatusListBlockStatusList[];
  /**
   * @remarks
   * The IP address of the instance.
   * 
   * @example
   * 203.XX.XX.88
   */
  ip?: string;
  static names(): { [key: string]: string } {
    return {
      blockStatusList: 'BlockStatusList',
      ip: 'Ip',
    };
  }

  static types(): { [key: string]: any } {
    return {
      blockStatusList: { 'type': 'array', 'itemType': DescribeBlockStatusResponseBodyStatusListBlockStatusList },
      ip: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCertsResponseBodyCerts extends $tea.Model {
  /**
   * @remarks
   * The global certificate ID, which is in the certificate ID-cn-hangzhou format. If the ID of the certificate is 123, CertIdentifier is 123-cn-hangzhou.
   * 
   * @example
   * 126345-ap-southeast-1
   */
  certIdentifier?: string;
  /**
   * @remarks
   * The domain name that is associated with the certificate.
   * 
   * @example
   * www.aliyun.com
   */
  common?: string;
  /**
   * @remarks
   * Indicates whether the certificate is associated with the domain name. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * true
   */
  domainRelated?: boolean;
  /**
   * @remarks
   * The expiration date of the certificate. The value is a string.
   * 
   * @example
   * 2021-09-12
   */
  endDate?: string;
  /**
   * @remarks
   * The certificate ID.
   * 
   * @example
   * 81
   */
  id?: number;
  /**
   * @remarks
   * The certificate authority (CA) that issued the certificate.
   * 
   * @example
   * Symantec
   */
  issuer?: string;
  /**
   * @remarks
   * The name of the certificate.
   * 
   * @example
   * testcert
   */
  name?: string;
  /**
   * @remarks
   * The issuance date of the certificate. The value is a string.
   * 
   * @example
   * 2019-09-12
   */
  startDate?: string;
  static names(): { [key: string]: string } {
    return {
      certIdentifier: 'CertIdentifier',
      common: 'Common',
      domainRelated: 'DomainRelated',
      endDate: 'EndDate',
      id: 'Id',
      issuer: 'Issuer',
      name: 'Name',
      startDate: 'StartDate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      certIdentifier: 'string',
      common: 'string',
      domainRelated: 'boolean',
      endDate: 'string',
      id: 'number',
      issuer: 'string',
      name: 'string',
      startDate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCnameReusesResponseBodyCnameReuses extends $tea.Model {
  /**
   * @example
   * 4o6ep6q217k9****.aliyunddos0004.com
   */
  cname?: string;
  /**
   * @example
   * www.aliyun.com
   */
  domain?: string;
  /**
   * @example
   * 1
   */
  enable?: number;
  static names(): { [key: string]: string } {
    return {
      cname: 'Cname',
      domain: 'Domain',
      enable: 'Enable',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cname: 'string',
      domain: 'string',
      enable: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDDoSEventsResponseBodyDDoSEvents extends $tea.Model {
  /**
   * @remarks
   * The bandwidth of attack traffic. Unit: bit/s.
   * 
   * @example
   * 0
   */
  bps?: number;
  /**
   * @remarks
   * The time when the DDoS attack stopped. The value is a UNIX timestamp. Unit: seconds.
   * 
   * @example
   * 1583933330
   */
  endTime?: number;
  /**
   * @remarks
   * The type of the attack event. Valid values:
   * 
   * *   **defense**: traffic scrubbing events
   * *   **blackhole**: blackhole filtering events
   * 
   * @example
   * blackhole
   */
  eventType?: string;
  /**
   * @remarks
   * The attacked IP address.
   * 
   * @example
   * 203.***.***.132
   */
  ip?: string;
  /**
   * @remarks
   * The attacked port.
   * 
   * @example
   * 80
   */
  port?: string;
  /**
   * @remarks
   * The packet forwarding rate of attack traffic. Unit: packets per second (pps).
   * 
   * @example
   * 0
   */
  pps?: number;
  /**
   * @remarks
   * The region from which the attack was launched. Valid values:
   * 
   * *   **cn**: a region in the Chinese mainland
   * *   **alb-ap-northeast-1-gf-x**: Japan (Tokyo)
   * *   **alb-ap-southeast-gf-x**: Singapore
   * *   **alb-cn-hongkong-gf-x**: Hong Kong (China)
   * *   **alb-eu-central-1-gf-x**: Germany (Frankfurt)
   * *   **alb-us-west-1-gf-x**: US (Silicon Valley)
   * 
   * > The values except **cn** are returned only when **RegionId** is set to **ap-southeast-1**.
   * 
   * @example
   * cn
   */
  region?: string;
  /**
   * @remarks
   * The time when the DDoS attack started. The value is a UNIX timestamp. Unit: seconds.
   * 
   * @example
   * 1583933277
   */
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      bps: 'Bps',
      endTime: 'EndTime',
      eventType: 'EventType',
      ip: 'Ip',
      port: 'Port',
      pps: 'Pps',
      region: 'Region',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bps: 'number',
      endTime: 'number',
      eventType: 'string',
      ip: 'string',
      port: 'string',
      pps: 'number',
      region: 'string',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDDosAllEventListResponseBodyAttackEvents extends $tea.Model {
  /**
   * @remarks
   * The source location or region from which the attack was initiated. Valid values:
   * 
   * *   **cn**: Chinese mainland
   * *   **alb-cn-hongkong-gf-2**: China (Hongkong)
   * *   **alb-us-west-1-gf-2**: US (Silicon Valley)
   * *   **alb-ap-northeast-1-gf-1**: Japan (Tokyo)
   * *   **alb-ap-southeast-gf-1**: Singapore
   * *   **alb-eu-central-1-gf-1**: Germany (Frankfurt)
   * *   **alb-eu-central-1-gf-1** or **selb-eu-west-1-gf-1a**: UK (London)
   * *   **alb-us-east-gf-1**: US (Virginia)
   * *   **CT-yundi**: China (Hongkong) This value is returned only for Anti-DDoS Premium instances of the Secure Chinese Mainland Acceleration (Sec-CMA) mitigation plan.
   * 
   * @example
   * cn
   */
  area?: string;
  /**
   * @remarks
   * The time when the DDoS attack stopped. This value is a UNIX timestamp. Unit: seconds.
   * 
   * @example
   * 1634546030
   */
  endTime?: number;
  /**
   * @remarks
   * The type of the DDoS attack event. Valid values:
   * 
   * *   **web-cc**: resource exhaustion attacks
   * *   **cc**: connection flood attacks
   * *   **defense**: DDoS attacks that trigger traffic scrubbing
   * *   **blackhole**: DDoS attacks that trigger blackhole filtering
   * 
   * @example
   * cc
   */
  eventType?: string;
  /**
   * @remarks
   * The attacked object. The attacked object varies based on the attack event type. The following list describes different attacked objects of different attack event types:
   * 
   * *   If **EventType** is set to **web-cc**, the value of this parameter indicates the domain name of the attacked website.
   * *   If **EventType** is set to **cc**, the value of this parameter indicates the IP address of the attacked Anti-DDoS Pro or Anti-DDoS Premium instance.
   * *   If **EventType** is set to **defense** or **blackhole**, the value of this parameter indicates the IP address of the attacked Anti-DDoS Pro or Anti-DDoS Premium instance.
   * 
   * @example
   * 203.107.XX.XX
   */
  ip?: string;
  /**
   * @remarks
   * The peak bandwidth of the attack traffic. Unit: Mbit/s.
   * 
   * @example
   * 101899
   */
  mbps?: number;
  /**
   * @remarks
   * The attacked port.
   * 
   * > If **EventType** is set to **web-cc**, this parameter is not returned.
   * 
   * @example
   * 80
   */
  port?: string;
  /**
   * @remarks
   * The peak packet forwarding rate of attack traffic. Unit: packets per second (pps).
   * 
   * @example
   * 9664270
   */
  pps?: number;
  /**
   * @remarks
   * The time when the DDoS attack started. This value is a UNIX timestamp. Unit: seconds.
   * 
   * @example
   * 1634543764
   */
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      area: 'Area',
      endTime: 'EndTime',
      eventType: 'EventType',
      ip: 'Ip',
      mbps: 'Mbps',
      port: 'Port',
      pps: 'Pps',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      area: 'string',
      endTime: 'number',
      eventType: 'string',
      ip: 'string',
      mbps: 'number',
      port: 'string',
      pps: 'number',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDDosEventAreaResponseBodyAreas extends $tea.Model {
  /**
   * @remarks
   * The code or ID of the source region. For more information, see [Codes of administrative regions in China and codes of countries and areas](https://help.aliyun.com/document_detail/167926.html). For example, **110000** indicates Beijing, China, and **us** indicates the United States.
   * 
   * @example
   * 110000
   */
  area?: string;
  /**
   * @remarks
   * The number of request packets that were sent from the source region.
   * 
   * @example
   * 228
   */
  inPkts?: number;
  static names(): { [key: string]: string } {
    return {
      area: 'Area',
      inPkts: 'InPkts',
    };
  }

  static types(): { [key: string]: any } {
    return {
      area: 'string',
      inPkts: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDDosEventAttackTypeResponseBodyAttackTypes extends $tea.Model {
  /**
   * @remarks
   * The type of the attack Valid values:
   * 
   * *   **QOTD-Reflect-Flood**: QOTD reflection attacks
   * *   **CharGEN-Reflect-Flood**: CHARGEN reflection attacks
   * *   **DNS-Reflect-Flood**: DNS reflection attacks
   * *   **TFTP-Reflect-Flood**: TFTP reflection attacks
   * *   **Portmap-Reflect-Flood**: Portmap reflection attacks
   * *   **NTP-Reflect-Flood**: NTP reflection attacks
   * *   **NetBIOS-Reflect-Flood**: NetBIOS reflection attacks
   * *   **SNMPv2-Reflect-Flood**: SNMPv2 reflection attacks
   * *   **CLDAP-Reflect-Flood**: CLDAP reflection attacks
   * *   **Ripv1-Reflect-Flood**: RIPv1 reflection attacks
   * *   **OpenVPN-Reflect-Flood**: OpenVPN reflection attacks
   * *   **SSDP-Reflect-Flood**: SSDP reflection attacks
   * *   **NetAssistant-Reflect-Flood**: NetAssistant reflection attacks
   * *   **WSDiscovery-Reflect-Flood**: WS-Discovery reflection attacks
   * *   **Kad-Reflect-Flood**: Kad reflection attacks
   * *   **mDNS-Reflect-Flood**: mDNS reflection attacks
   * *   **10001-Reflect-Flood**: reflection attacks over port 10001
   * *   **Memcached-Reflect-Flood**: Memcached reflection attacks
   * *   **QNP-Reflect-Flood**: QNP reflection attacks
   * *   **DVR-Reflect-Flood**: DVR reflection attacks
   * *   **CoAP-Reflect-Flood**: CoAP reflection attacks
   * *   **ADDP-Reflect-Flood**: ADDP reflection attacks
   * *   **Tcp-Syn**: TCP SYN flood attacks
   * *   **Tcp-Fin**: TCP FIN flood attacks
   * *   **Tcp-Ack**: TCP ACK flood attacks
   * *   **Tcp-Rst**: TCP RST flood attacks
   * *   **Tcp-Pushack**: TCP PSH-ACK flood attacks
   * *   **Tcp-Synack**: TCP SYN-ACK flood attacks
   * *   **Udp-None**: UDP attacks
   * *   **Udp-Ssh**: UDP-based SSH attacks
   * *   **Udp-Dns**: UDP-based DNS attacks
   * *   **Udp-Http**: UDP-based HTTP attacks
   * *   **Udp-Https**: UDP-based HTTPS attacks
   * *   **Udp-Ntp**: UDP-based NTP attacks
   * *   **Udp-Ldap**: UDP-based LDAP attacks
   * *   **Udp-Ssdp**: UDP-based SSDP attacks
   * *   **Udp-Memcached**: Memcached UDP reflection attacks
   * *   **Tcp-Other**: other TCP attacks
   * *   **Icmp**: ICMP flood attacks
   * *   **Igmp**: IGMP flood attacks
   * *   **Ipv6**: IPv6 attacks
   * 
   * @example
   * Tcp-Syn
   */
  attackType?: string;
  /**
   * @remarks
   * The number of request packets of the attack type.
   * 
   * @example
   * 145902
   */
  inPkts?: number;
  static names(): { [key: string]: string } {
    return {
      attackType: 'AttackType',
      inPkts: 'InPkts',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attackType: 'string',
      inPkts: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDDosEventIspResponseBodyIsps extends $tea.Model {
  /**
   * @remarks
   * The number of request packets that were sent from the ISP.
   * 
   * @example
   * 230
   */
  inPkts?: number;
  /**
   * @remarks
   * The code of the ISP. Valid values:
   * 
   * *   **100017**: China Telecom
   * *   **100026**: China Unicom
   * *   **100025**: China Mobile
   * *   **100027**: China Education and Research Network
   * *   **100020**: China Mobile Tietong
   * *   **1000143**: Dr.Peng Telecom & Media Group
   * *   **100080**: Beijing Gehua CATV Network
   * *   **1000139**: National Radio and Television Administration
   * *   **100023**: Oriental Cable Network
   * *   **100063**: Founder Broadband
   * *   **1000337**: China Internet Exchange
   * *   **100021**: 21Vianet Group
   * *   **1000333**: Wasu Media Holding
   * *   **100093**: Wangsu Science & Technology
   * *   **1000401**: Tencent
   * *   **100099**: Baidu
   * *   **1000323**: Alibaba Cloud
   * *   **100098**: Alibaba
   * 
   * @example
   * 1000323
   */
  isp?: string;
  static names(): { [key: string]: string } {
    return {
      inPkts: 'InPkts',
      isp: 'Isp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      inPkts: 'number',
      isp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDDosEventSrcIpResponseBodyIps extends $tea.Model {
  /**
   * @remarks
   * The code or ID of the source region. For more information, see [Codes of administrative regions in China and codes of countries and areas](https://help.aliyun.com/document_detail/167926.html). For example, **110000** indicates Beijing, China, and **us** indicates the United States.
   * 
   * @example
   * 110000
   */
  areaId?: string;
  /**
   * @remarks
   * The Internet service provider (ISP) for the volumetric attack. Valid values:
   * 
   * *   **100017**: China Telecom
   * *   **100026**: China Unicom
   * *   **100025**: China Mobile
   * *   **100027**: China Education and Research Network
   * *   **100020**: China Mobile Tietong
   * *   **1000143**: Dr.Peng Telecom & Media Group
   * *   **100080**: Beijing Gehua CATV Network
   * *   **1000139**: National Radio and Television Administration
   * *   **100023**: Oriental Cable Network
   * *   **100063**: Founder Broadband
   * *   **1000337**: China Internet Exchange
   * *   **100021**: 21Vianet Group
   * *   **1000333**: Wasu Media Holding
   * *   **100093**: Wangsu Science & Technology
   * *   **1000401**: Tencent
   * *   **100099**: Baidu
   * *   **1000323**: Alibaba Cloud
   * *   **100098**: Alibaba
   * 
   * @example
   * 100026
   */
  isp?: string;
  /**
   * @remarks
   * The source IP address of the volumetric attack.
   * 
   * @example
   * 218.***.***.24
   */
  srcIp?: string;
  static names(): { [key: string]: string } {
    return {
      areaId: 'AreaId',
      isp: 'Isp',
      srcIp: 'SrcIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      areaId: 'string',
      isp: 'string',
      srcIp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDefenseCountStatisticsResponseBodyDefenseCountStatistics extends $tea.Model {
  /**
   * @remarks
   * The number of advanced mitigation sessions that are used within the current calendar month.
   * 
   * @example
   * 0
   */
  defenseCountTotalUsageOfCurrentMonth?: number;
  /**
   * @remarks
   * The number of available global advanced mitigation sessions for the Insurance mitigation plan.
   * 
   * @example
   * 0
   */
  flowPackCountRemain?: number;
  /**
   * @remarks
   * The maximum number of advanced mitigation sessions available for the current calendar month. The advanced mitigation sessions include the advanced mitigation sessions that are provided free of charge and the global advanced mitigation sessions that you purchase.
   * 
   * @example
   * 20
   */
  maxUsableDefenseCountCurrentMonth?: number;
  /**
   * @remarks
   * The number of available global advanced mitigation sessions for the Secure Chinese Mainland Acceleration (Sec-CMA) mitigation plan.
   * 
   * @example
   * 0
   */
  secHighSpeedCountRemain?: number;
  static names(): { [key: string]: string } {
    return {
      defenseCountTotalUsageOfCurrentMonth: 'DefenseCountTotalUsageOfCurrentMonth',
      flowPackCountRemain: 'FlowPackCountRemain',
      maxUsableDefenseCountCurrentMonth: 'MaxUsableDefenseCountCurrentMonth',
      secHighSpeedCountRemain: 'SecHighSpeedCountRemain',
    };
  }

  static types(): { [key: string]: any } {
    return {
      defenseCountTotalUsageOfCurrentMonth: 'number',
      flowPackCountRemain: 'number',
      maxUsableDefenseCountCurrentMonth: 'number',
      secHighSpeedCountRemain: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDefenseRecordsResponseBodyDefenseRecords extends $tea.Model {
  /**
   * @remarks
   * The peak attack traffic. Unit: bit/s.
   * 
   * @example
   * 6584186000
   */
  attackPeak?: number;
  /**
   * @remarks
   * The end time of the advanced mitigation session. This value is a UNIX timestamp. Units: miliseconds.
   * 
   * @example
   * 1583683200000
   */
  endTime?: number;
  /**
   * @remarks
   * The number of attacks.
   * 
   * @example
   * 2
   */
  eventCount?: number;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * ddoscoo-cn-mp91j1ao****
   */
  instanceId?: string;
  /**
   * @remarks
   * The start time of the advanced mitigation session. This value is a UNIX timestamp. Units: miliseconds.
   * 
   * @example
   * 1582992000000
   */
  startTime?: number;
  /**
   * @remarks
   * The status of the advanced mitigation session. Valid values:
   * 
   * *   **0**: The advanced mitigation session is being used.
   * *   **1**: The advanced mitigation session is used.
   * 
   * @example
   * 0
   */
  status?: number;
  static names(): { [key: string]: string } {
    return {
      attackPeak: 'AttackPeak',
      endTime: 'EndTime',
      eventCount: 'EventCount',
      instanceId: 'InstanceId',
      startTime: 'StartTime',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attackPeak: 'number',
      endTime: 'number',
      eventCount: 'number',
      instanceId: 'string',
      startTime: 'number',
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDestinationPortEventResponseBodyPortList extends $tea.Model {
  /**
   * @remarks
   * The destination port.
   * 
   * @example
   * 80
   */
  dstPort?: string;
  /**
   * @remarks
   * The number of request packets received by the destination port.
   * 
   * @example
   * 8760950
   */
  inPkts?: number;
  static names(): { [key: string]: string } {
    return {
      dstPort: 'DstPort',
      inPkts: 'InPkts',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dstPort: 'string',
      inPkts: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainAttackEventsResponseBodyDomainAttackEvents extends $tea.Model {
  /**
   * @remarks
   * The attacked domain name.
   * 
   * @example
   * www.aliyun.com
   */
  domain?: string;
  /**
   * @remarks
   * The time when the DDoS attack stopped. The value is a UNIX timestamp. Unit: seconds.
   * 
   * @example
   * 1560320160
   */
  endTime?: number;
  /**
   * @remarks
   * The peak attack QPS.
   * 
   * @example
   * 1000
   */
  maxQps?: number;
  /**
   * @remarks
   * The time when the DDoS attack started. The value is a UNIX timestamp. Unit: seconds.
   * 
   * @example
   * 1560312900
   */
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
      endTime: 'EndTime',
      maxQps: 'MaxQps',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
      endTime: 'number',
      maxQps: 'number',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainQPSListResponseBodyDomainQPSList extends $tea.Model {
  /**
   * @remarks
   * The attack QPS.
   * 
   * @example
   * 1
   */
  attackQps?: number;
  /**
   * @remarks
   * The number of cache hits.
   * 
   * @example
   * 0
   */
  cacheHits?: number;
  /**
   * @remarks
   * The index number of the returned data.
   * 
   * @example
   * 0
   */
  index?: number;
  /**
   * @remarks
   * The peak attack QPS.
   * 
   * @example
   * 37
   */
  maxAttackQps?: number;
  /**
   * @remarks
   * The peak of normal QPS.
   * 
   * @example
   * 93
   */
  maxNormalQps?: number;
  /**
   * @remarks
   * The peak of total QPS.
   * 
   * @example
   * 130
   */
  maxQps?: number;
  /**
   * @remarks
   * The time when the data was collected. The value is a UNIX timestamp. Unit: seconds.
   * 
   * @example
   * 1582992000
   */
  time?: number;
  /**
   * @remarks
   * The total number of requests.
   * 
   * @example
   * 20008
   */
  totalCount?: number;
  /**
   * @remarks
   * The total QPS.
   * 
   * @example
   * 1
   */
  totalQps?: number;
  static names(): { [key: string]: string } {
    return {
      attackQps: 'AttackQps',
      cacheHits: 'CacheHits',
      index: 'Index',
      maxAttackQps: 'MaxAttackQps',
      maxNormalQps: 'MaxNormalQps',
      maxQps: 'MaxQps',
      time: 'Time',
      totalCount: 'TotalCount',
      totalQps: 'TotalQps',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attackQps: 'number',
      cacheHits: 'number',
      index: 'number',
      maxAttackQps: 'number',
      maxNormalQps: 'number',
      maxQps: 'number',
      time: 'number',
      totalCount: 'number',
      totalQps: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainResourceResponseBodyWebRulesProxyTypes extends $tea.Model {
  /**
   * @remarks
   * The port numbers.
   */
  proxyPorts?: string[];
  /**
   * @remarks
   * The type of the protocol. Valid values:
   * 
   * *   **http**
   * *   **https**
   * *   **websocket**
   * *   **websockets**
   * 
   * @example
   * http
   */
  proxyType?: string;
  static names(): { [key: string]: string } {
    return {
      proxyPorts: 'ProxyPorts',
      proxyType: 'ProxyType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      proxyPorts: { 'type': 'array', 'itemType': 'string' },
      proxyType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainResourceResponseBodyWebRules extends $tea.Model {
  /**
   * @remarks
   * The IP addresses that are included in the blacklist of the domain name.
   */
  blackList?: string[];
  /**
   * @remarks
   * Indicates whether Frequency Control is enabled. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * true
   */
  ccEnabled?: boolean;
  /**
   * @remarks
   * Indicates whether the Custom Rules switch of Frequency Control is turned on. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * true
   */
  ccRuleEnabled?: boolean;
  /**
   * @remarks
   * The mode of Frequency Control. Valid values:
   * 
   * *   **default**: the Normal mode
   * *   **gf_under_attack**: the Emergency mode
   * *   **gf_sos_verify**: the Strict mode
   * *   **gf_sos_verify**: the Super Strict mode
   * 
   * @example
   * default
   */
  ccTemplate?: string;
  /**
   * @remarks
   * The name of the SSL certificate used by the domain name.
   * 
   * @example
   * 49944XX.pem
   */
  certName?: string;
  /**
   * @remarks
   * The CNAME provided by the instance to which the domain name is added.
   * 
   * @example
   * 0ekb69x3j9wvXXXX.aliyunddosXXXX.com
   */
  cname?: string;
  /**
   * @remarks
   * The custom cipher suites.
   */
  customCiphers?: string[];
  /**
   * @remarks
   * The domain name of the website.
   * 
   * @example
   * www.example.com
   */
  domain?: string;
  /**
   * @remarks
   * Indicates whether Enable HTTP/2 is turned on. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * false
   */
  http2Enable?: boolean;
  /**
   * @remarks
   * Indicates whether Enable HTTPS Redirection is turned on. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * false
   */
  http2HttpsEnable?: boolean;
  /**
   * @remarks
   * Indicates whether Enable HTTP Redirection of Back-to-origin Requests is turned on. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * false
   */
  https2HttpEnable?: boolean;
  /**
   * @remarks
   * The advanced HTTPS settings. This parameter takes effect only when the value of the **ProxyType** parameter includes **https**. The value is a string that consists of a JSON struct. The JSON struct contains the following fields:
   * 
   * *   **Http2https**: indicates whether Enable HTTPS Redirection is turned on. Data type: integer. Valid values: **0** and **1**. The value 0 indicates that Enable HTTPS Redirection is turned on. The value 1 indicates that Enable HTTPS Redirection is turned off.
   * *   **Https2http**: indicates whether Enable HTTP Redirection of Back-to-origin Requests is turned on. Data type: integer. Valid values: **0** and **1**. The value 0 indicates that the feature is turned on. The value 1 indicates that the feature is turned off.
   * *   **Http2**: indicates whether Enable HTTP/2 is turned on. Data type: integer. Valid values: **0** and **1**. The value 0 indicates that Enable HTTP/2 is turned off. The value 1 indicates that Enable HTTP/2 is turned on.
   * 
   * @example
   * {"Https2http":0,"Http2":0,"Http2https":0}
   */
  httpsExt?: string;
  /**
   * @remarks
   * The IDs of the instances to which the domain name is added.
   */
  instanceIds?: string[];
  /**
   * @remarks
   * Indicates whether the Online Certificate Status Protocol (OCSP) feature is turned on. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * false
   */
  ocspEnabled?: boolean;
  /**
   * @remarks
   * The scheduling algorithm for back-to-origin traffic. Valid values:
   * 
   * *   **ip_hash**: the IP hash algorithm. This algorithm is used to redirect the requests from the same IP address to the same origin server.
   * *   **rr**: the round-robin algorithm. This algorithm is used to redirect requests to origin servers in turn.
   * *   **least_time**: the least response time algorithm. This algorithm is used to minimize the latency when requests are forwarded from the instance to origin servers based on the intelligent DNS resolution feature.
   * 
   * @example
   * ip_hash
   */
  policyMode?: string;
  /**
   * @remarks
   * Indicates whether the instance forwards the traffic that is destined for the website. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * true
   */
  proxyEnabled?: boolean;
  /**
   * @remarks
   * The details about the protocol type and port number.
   */
  proxyTypes?: DescribeDomainResourceResponseBodyWebRulesProxyTypes[];
  /**
   * @remarks
   * The reason why the domain name is invalid. Valid values:
   * 
   * *   **1**: No Content Provider (ICP) filing is completed for the domain name.
   * *   **2**: The business for which you registered the domain name does not meet regulatory requirements.
   * 
   * If the two reasons are both involved, the value **2** is returned.
   * 
   * @example
   * 1
   */
  punishReason?: number;
  /**
   * @remarks
   * Indicates whether the domain name is invalid. Valid values:
   * 
   * *   **true**: The domain name is invalid. You can view the specific reasons from the **PunishReason** parameter.
   * *   **false**: The domain name is valid.
   * 
   * @example
   * false
   */
  punishStatus?: boolean;
  /**
   * @remarks
   * The addresses of origin servers.
   */
  realServers?: string[];
  /**
   * @remarks
   * The address type of the origin server. Valid values:
   * 
   * *   **0**: IP address
   * *   **1**: domain name
   * 
   * @example
   * 0
   */
  rsType?: number;
  /**
   * @remarks
   * Indicates whether TLS 1.3 is supported. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * false
   */
  ssl13Enabled?: boolean;
  /**
   * @remarks
   * The type of the cipher suite. Valid values:
   * 
   * *   **default**: custom cipher suite
   * *   **all**: all cipher suites
   * *   **strong**: strong cipher suites
   * 
   * @example
   * default
   */
  sslCiphers?: string;
  /**
   * @remarks
   * The version of the TLS protocol. Valid values:
   * 
   * *   **tls1.0**: TLS 1.0 or later
   * *   **tls1.1**: TLS 1.1 or later
   * *   **tls1.2**: TLS 1.2 or later
   * 
   * @example
   * tls1.0
   */
  sslProtocols?: string;
  /**
   * @remarks
   * The IP addresses that are included in the whitelist of the domain name.
   */
  whiteList?: string[];
  static names(): { [key: string]: string } {
    return {
      blackList: 'BlackList',
      ccEnabled: 'CcEnabled',
      ccRuleEnabled: 'CcRuleEnabled',
      ccTemplate: 'CcTemplate',
      certName: 'CertName',
      cname: 'Cname',
      customCiphers: 'CustomCiphers',
      domain: 'Domain',
      http2Enable: 'Http2Enable',
      http2HttpsEnable: 'Http2HttpsEnable',
      https2HttpEnable: 'Https2HttpEnable',
      httpsExt: 'HttpsExt',
      instanceIds: 'InstanceIds',
      ocspEnabled: 'OcspEnabled',
      policyMode: 'PolicyMode',
      proxyEnabled: 'ProxyEnabled',
      proxyTypes: 'ProxyTypes',
      punishReason: 'PunishReason',
      punishStatus: 'PunishStatus',
      realServers: 'RealServers',
      rsType: 'RsType',
      ssl13Enabled: 'Ssl13Enabled',
      sslCiphers: 'SslCiphers',
      sslProtocols: 'SslProtocols',
      whiteList: 'WhiteList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      blackList: { 'type': 'array', 'itemType': 'string' },
      ccEnabled: 'boolean',
      ccRuleEnabled: 'boolean',
      ccTemplate: 'string',
      certName: 'string',
      cname: 'string',
      customCiphers: { 'type': 'array', 'itemType': 'string' },
      domain: 'string',
      http2Enable: 'boolean',
      http2HttpsEnable: 'boolean',
      https2HttpEnable: 'boolean',
      httpsExt: 'string',
      instanceIds: { 'type': 'array', 'itemType': 'string' },
      ocspEnabled: 'boolean',
      policyMode: 'string',
      proxyEnabled: 'boolean',
      proxyTypes: { 'type': 'array', 'itemType': DescribeDomainResourceResponseBodyWebRulesProxyTypes },
      punishReason: 'number',
      punishStatus: 'boolean',
      realServers: { 'type': 'array', 'itemType': 'string' },
      rsType: 'number',
      ssl13Enabled: 'boolean',
      sslCiphers: 'string',
      sslProtocols: 'string',
      whiteList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainSecurityProfileResponseBodyResult extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the global mitigation policy is enabled. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * true
   */
  globalEnable?: boolean;
  /**
   * @remarks
   * The mode of the global mitigation policy. Valid values:
   * 
   * *   **weak**: the Low mode
   * *   **default**: the Normal mode
   * *   **hard**: the Strict mode
   * 
   * @example
   * default
   */
  globalMode?: string;
  static names(): { [key: string]: string } {
    return {
      globalEnable: 'GlobalEnable',
      globalMode: 'GlobalMode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      globalEnable: 'boolean',
      globalMode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainStatusCodeListResponseBodyStatusCodeList extends $tea.Model {
  /**
   * @remarks
   * The index number of the returned data.
   * 
   * @example
   * 0
   */
  index?: number;
  /**
   * @remarks
   * The number of 200 status codes.
   * 
   * @example
   * 15520
   */
  status200?: number;
  /**
   * @remarks
   * The number of 2xx status codes.
   * 
   * @example
   * 15520
   */
  status2XX?: number;
  /**
   * @remarks
   * The number of 3xx status codes.
   * 
   * @example
   * 0
   */
  status3XX?: number;
  /**
   * @remarks
   * The number of 403 status codes.
   * 
   * @example
   * 0
   */
  status403?: number;
  /**
   * @remarks
   * The number of 404 status codes.
   * 
   * @example
   * 0
   */
  status404?: number;
  /**
   * @remarks
   * The number of 405 status codes.
   * 
   * @example
   * 0
   */
  status405?: number;
  /**
   * @remarks
   * The number of 4xx status codes.
   * 
   * @example
   * 4486
   */
  status4XX?: number;
  /**
   * @remarks
   * The number of 501 status codes.
   * 
   * @example
   * 0
   */
  status501?: number;
  /**
   * @remarks
   * The number of 502 status codes.
   * 
   * @example
   * 0
   */
  status502?: number;
  /**
   * @remarks
   * The number of 503 status codes.
   * 
   * @example
   * 0
   */
  status503?: number;
  /**
   * @remarks
   * The number of 504 status codes.
   * 
   * @example
   * 0
   */
  status504?: number;
  /**
   * @remarks
   * The number of 5xx status codes.
   * 
   * @example
   * 0
   */
  status5XX?: number;
  /**
   * @remarks
   * The time when the data was collected. The value is a UNIX timestamp. Unit: seconds.
   * 
   * @example
   * 1582992000
   */
  time?: number;
  static names(): { [key: string]: string } {
    return {
      index: 'Index',
      status200: 'Status200',
      status2XX: 'Status2XX',
      status3XX: 'Status3XX',
      status403: 'Status403',
      status404: 'Status404',
      status405: 'Status405',
      status4XX: 'Status4XX',
      status501: 'Status501',
      status502: 'Status502',
      status503: 'Status503',
      status504: 'Status504',
      status5XX: 'Status5XX',
      time: 'Time',
    };
  }

  static types(): { [key: string]: any } {
    return {
      index: 'number',
      status200: 'number',
      status2XX: 'number',
      status3XX: 'number',
      status403: 'number',
      status404: 'number',
      status405: 'number',
      status4XX: 'number',
      status501: 'number',
      status502: 'number',
      status503: 'number',
      status504: 'number',
      status5XX: 'number',
      time: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainTopAttackListResponseBodyAttackList extends $tea.Model {
  /**
   * @remarks
   * The attack QPS. Unit: QPS
   * 
   * @example
   * 0
   */
  attack?: number;
  /**
   * @remarks
   * The number of all QPS, which includes normal and attack QPS. Unit: QPS.
   * 
   * @example
   * 294
   */
  count?: number;
  /**
   * @remarks
   * The domain name of the website.
   * 
   * @example
   * www.aliyun.com
   */
  domain?: string;
  static names(): { [key: string]: string } {
    return {
      attack: 'Attack',
      count: 'Count',
      domain: 'Domain',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attack: 'number',
      count: 'number',
      domain: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainViewSourceCountriesResponseBodySourceCountrys extends $tea.Model {
  /**
   * @remarks
   * The total number of requests.
   * 
   * @example
   * 3390671
   */
  count?: number;
  /**
   * @remarks
   * The abbreviation of the country or area. For more information, see the **Codes of countries and areas** section of the [Codes of administrative regions in China and codes of countries and areas](https://help.aliyun.com/document_detail/167926.html) topic. For example, **cn** indicates China, and **us** indicates the United States.
   * 
   * @example
   * cn
   */
  countryId?: string;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      countryId: 'CountryId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      countryId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainViewSourceProvincesResponseBodySourceProvinces extends $tea.Model {
  /**
   * @remarks
   * The total number of requests.
   * 
   * @example
   * 3390671
   */
  count?: number;
  /**
   * @remarks
   * The ID of the region inside China. For more information, see the **Codes of administrative regions in China** section of the [Codes of administrative regions in China and codes of countries and areas](https://help.aliyun.com/document_detail/167926.html) topic. For example, **110000** indicates Beijing, and **120000** indicates Tianjin.
   * 
   * @example
   * 440000
   */
  provinceId?: string;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      provinceId: 'ProvinceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      provinceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainViewTopCostTimeResponseBodyUrlList extends $tea.Model {
  /**
   * @remarks
   * The response duration. Unit: milliseconds.
   * 
   * @example
   * 3000
   */
  costTime?: number;
  /**
   * @remarks
   * The domain name of the website.
   * 
   * @example
   * www.aliyun.com
   */
  domain?: string;
  /**
   * @remarks
   * The URL that is Base64-encoded.
   * 
   * @example
   * Lw==
   */
  url?: string;
  static names(): { [key: string]: string } {
    return {
      costTime: 'CostTime',
      domain: 'Domain',
      url: 'Url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      costTime: 'number',
      domain: 'string',
      url: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainViewTopUrlResponseBodyUrlList extends $tea.Model {
  /**
   * @remarks
   * The total number of requests.
   * 
   * @example
   * 3390671
   */
  count?: number;
  /**
   * @remarks
   * The domain name of the website.
   * 
   * @example
   * www.aliyun.com
   */
  domain?: string;
  /**
   * @remarks
   * The URL that is Base64-encoded.
   * 
   * @example
   * Lw==
   */
  url?: string;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      domain: 'Domain',
      url: 'Url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      domain: 'string',
      url: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeElasticQpsResponseBodyElasticQps extends $tea.Model {
  /**
   * @remarks
   * The index number of the returned data.
   * 
   * @example
   * 1
   */
  index?: number;
  /**
   * @remarks
   * The peak QPS of the normal service.
   * 
   * @example
   * 23
   */
  maxNormalQps?: number;
  /**
   * @remarks
   * The peak inbound QPS.
   * 
   * @example
   * 100
   */
  maxQps?: number;
  /**
   * @remarks
   * The total number of requests during the step size period.
   * 
   * @example
   * 15104
   */
  pv?: number;
  /**
   * @remarks
   * The total number of HTTP 2xx status codes during the step size period.
   * 
   * @example
   * 455
   */
  status2?: number;
  /**
   * @remarks
   * The total number of HTTP 3xx status codes during the step size period.
   * 
   * @example
   * 100
   */
  status3?: number;
  /**
   * @remarks
   * The total number of HTTP 4xx status codes during the step size period.
   * 
   * @example
   * 34
   */
  status4?: number;
  /**
   * @remarks
   * The total number of HTTP 5xx status codes during the step size period.
   * 
   * @example
   * 0
   */
  status5?: number;
  /**
   * @remarks
   * The total number of origin requests during the step size period.
   * 
   * @example
   * 1223
   */
  ups?: number;
  static names(): { [key: string]: string } {
    return {
      index: 'Index',
      maxNormalQps: 'MaxNormalQps',
      maxQps: 'MaxQps',
      pv: 'Pv',
      status2: 'Status2',
      status3: 'Status3',
      status4: 'Status4',
      status5: 'Status5',
      ups: 'Ups',
    };
  }

  static types(): { [key: string]: any } {
    return {
      index: 'number',
      maxNormalQps: 'number',
      maxQps: 'number',
      pv: 'number',
      status2: 'number',
      status3: 'number',
      status4: 'number',
      status5: 'number',
      ups: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeElasticQpsRecordResponseBodyElasticQpsList extends $tea.Model {
  /**
   * @remarks
   * The timestamp. Unit: milliseconds.
   * 
   * @example
   * 1688140799999
   */
  date?: number;
  /**
   * @remarks
   * The ID of the Anti-DDoS Proxy instance.
   * 
   * @example
   * ddoscoo-cn-7e225i41****
   */
  instanceId?: string;
  /**
   * @remarks
   * The IP address of the Anti-DDoS Proxy instance.
   * 
   * @example
   * 203.***.***.199
   */
  ip?: string;
  /**
   * @remarks
   * The burstable QPS value. A value of 0 indicates that the burstable QPS feature is not enabled.
   * 
   * @example
   * 300000
   */
  opsElasticQps?: number;
  /**
   * @remarks
   * The service QPS (active).
   * 
   * @example
   * 1345
   */
  opsQps?: number;
  /**
   * @remarks
   * The service QPS (purchased).
   * 
   * @example
   * 1345
   */
  originQps?: number;
  /**
   * @remarks
   * The daily peak 95th percentile QPS.
   * 
   * @example
   * 4367
   */
  qps?: number;
  /**
   * @remarks
   * The daily peak traffic.
   * 
   * @example
   * 122
   */
  qpsPeak?: number;
  /**
   * @remarks
   * Indicates whether the instance has expired or is released. Valid values:
   * 
   * *   **1**: The instance runs as expected.
   * *   **2**: The instance has expired.
   * *   **4**: The instance is released.
   * 
   * @example
   * 1
   */
  status?: number;
  static names(): { [key: string]: string } {
    return {
      date: 'Date',
      instanceId: 'InstanceId',
      ip: 'Ip',
      opsElasticQps: 'OpsElasticQps',
      opsQps: 'OpsQps',
      originQps: 'OriginQps',
      qps: 'Qps',
      qpsPeak: 'QpsPeak',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      date: 'number',
      instanceId: 'string',
      ip: 'string',
      opsElasticQps: 'number',
      opsQps: 'number',
      originQps: 'number',
      qps: 'number',
      qpsPeak: 'number',
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHeadersResponseBodyCustomHeader extends $tea.Model {
  /**
   * @remarks
   * The domain name of the website.
   * 
   * @example
   * example.aliyundoc.com
   */
  domain?: string;
  /**
   * @remarks
   * The header of the response.
   * 
   * @example
   * {"X-Forwarded-ClientSrcPort":"","header1":"hLeLele"}
   */
  headers?: string;
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
      headers: 'Headers',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
      headers: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHealthCheckListResponseBodyHealthCheckListHealthCheck extends $tea.Model {
  /**
   * @remarks
   * The domain name.
   * 
   * > This parameter is returned only when the Layer 7 health check configuration is queried.
   * 
   * @example
   * www.aliyun.com
   */
  domain?: string;
  /**
   * @remarks
   * The number of consecutive failed health checks that must occur before a port is declared unhealthy. Valid values: **1** to **10**.
   * 
   * @example
   * 3
   */
  down?: number;
  /**
   * @remarks
   * The interval at which checks are performed. Valid values: **1** to **30**. Unit: seconds.
   * 
   * @example
   * 15
   */
  interval?: number;
  /**
   * @remarks
   * The port that was checked.
   * 
   * @example
   * 8080
   */
  port?: number;
  /**
   * @remarks
   * The response timeout period. Valid values: **1** to **30**. Unit: seconds.
   * 
   * @example
   * 5
   */
  timeout?: number;
  /**
   * @remarks
   * The type of the protocol. Valid values:
   * 
   * *   **tcp**: The Layer 4 health check configuration was queried.
   * *   **http**: The Layer 7 health check configuration was queried.
   * 
   * @example
   * tcp
   */
  type?: string;
  /**
   * @remarks
   * The number of consecutive successful health checks that must occur before a port is declared healthy. Valid values: **1** to **10**.
   * 
   * @example
   * 3
   */
  up?: number;
  /**
   * @remarks
   * The check path.
   * 
   * > This parameter is returned only when the Layer 7 health check configuration is queried.
   * 
   * @example
   * /abc
   */
  uri?: string;
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
      down: 'Down',
      interval: 'Interval',
      port: 'Port',
      timeout: 'Timeout',
      type: 'Type',
      up: 'Up',
      uri: 'Uri',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
      down: 'number',
      interval: 'number',
      port: 'number',
      timeout: 'number',
      type: 'string',
      up: 'number',
      uri: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHealthCheckListResponseBodyHealthCheckList extends $tea.Model {
  /**
   * @remarks
   * The forwarding port.
   * 
   * @example
   * 8080
   */
  frontendPort?: number;
  /**
   * @remarks
   * The health check configuration.
   */
  healthCheck?: DescribeHealthCheckListResponseBodyHealthCheckListHealthCheck;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * ddoscoo-cn-mp91j1ao****
   */
  instanceId?: string;
  /**
   * @remarks
   * The forwarding protocol. Valid values:
   * 
   * *   **tcp**
   * *   **udp**
   * 
   * @example
   * tcp
   */
  protocol?: string;
  static names(): { [key: string]: string } {
    return {
      frontendPort: 'FrontendPort',
      healthCheck: 'HealthCheck',
      instanceId: 'InstanceId',
      protocol: 'Protocol',
    };
  }

  static types(): { [key: string]: any } {
    return {
      frontendPort: 'number',
      healthCheck: DescribeHealthCheckListResponseBodyHealthCheckListHealthCheck,
      instanceId: 'string',
      protocol: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHealthCheckStatusResponseBodyHealthCheckStatusRealServerStatusList extends $tea.Model {
  /**
   * @remarks
   * The IP address of the origin server.
   * 
   * @example
   * 192.0.XX.XX
   */
  address?: string;
  /**
   * @remarks
   * The health state of the IP address. Valid values:
   * 
   * *   **normal**: healthy
   * *   **abnormal**: unhealthy
   * 
   * @example
   * abnormal
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      address: 'Address',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      address: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHealthCheckStatusResponseBodyHealthCheckStatus extends $tea.Model {
  /**
   * @remarks
   * The forwarding port.
   * 
   * @example
   * 8080
   */
  frontendPort?: number;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * ddoscoo-cn-mp91j1ao****
   */
  instanceId?: string;
  /**
   * @remarks
   * The forwarding protocol. Valid values:
   * 
   * *   **tcp**
   * *   **udp**
   * 
   * @example
   * tcp
   */
  protocol?: string;
  /**
   * @remarks
   * An array that consists of the health states of the IP addresses of the origin server.
   */
  realServerStatusList?: DescribeHealthCheckStatusResponseBodyHealthCheckStatusRealServerStatusList[];
  /**
   * @remarks
   * The health status of the origin server. Valid values:
   * 
   * *   **normal**: healthy
   * *   **abnormal**: unhealthy
   * 
   * @example
   * normal
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      frontendPort: 'FrontendPort',
      instanceId: 'InstanceId',
      protocol: 'Protocol',
      realServerStatusList: 'RealServerStatusList',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      frontendPort: 'number',
      instanceId: 'string',
      protocol: 'string',
      realServerStatusList: { 'type': 'array', 'itemType': DescribeHealthCheckStatusResponseBodyHealthCheckStatusRealServerStatusList },
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceDetailsResponseBodyInstanceDetailsEipInfos extends $tea.Model {
  certConfigured?: boolean;
  /**
   * @remarks
   * The IP address of the instance.
   * 
   * @example
   * 203.117.XX.XX
   */
  eip?: string;
  functionVersion?: string;
  /**
   * @remarks
   * The IP address-based forwarding mode of the instance. Valid values:
   * 
   * *   **fnat**: Requests from IPv4 addresses are forwarded to origin servers that use IPv4 addresses and requests from IPv6 addresses are forwarded to origin servers that use IPv6 addresses.
   * *   **v6tov4**: All requests are forwarded to origin servers that use IPv4 addresses.
   * 
   * @example
   * fnat
   */
  ipMode?: string;
  /**
   * @remarks
   * The IP version of the protocol. Valid values:
   * 
   * *   **Ipv4**: IPv4
   * *   **Ipv6**: IPv6
   * 
   * @example
   * Ipv4
   */
  ipVersion?: string;
  ssl13Enabled?: boolean;
  /**
   * @remarks
   * The status of the instance. Valid values:
   * 
   * *   **normal**: indicates that the instance is normal.
   * *   **expired**: indicates that the instance expired.
   * *   **defense**: indicates that traffic scrubbing is performed on the asset that is protected by the instance.
   * *   **blackhole**: indicates that blackhole filtering is triggered for the asset that is protected by the instance.
   * *   **punished**: indicates that the instance is in penalty.
   * 
   * @example
   * normal
   */
  status?: string;
  tlsVersion?: string;
  static names(): { [key: string]: string } {
    return {
      certConfigured: 'CertConfigured',
      eip: 'Eip',
      functionVersion: 'FunctionVersion',
      ipMode: 'IpMode',
      ipVersion: 'IpVersion',
      ssl13Enabled: 'Ssl13Enabled',
      status: 'Status',
      tlsVersion: 'TlsVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      certConfigured: 'boolean',
      eip: 'string',
      functionVersion: 'string',
      ipMode: 'string',
      ipVersion: 'string',
      ssl13Enabled: 'boolean',
      status: 'string',
      tlsVersion: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceDetailsResponseBodyInstanceDetails extends $tea.Model {
  /**
   * @remarks
   * The information about the IP address of the instance.
   */
  eipInfos?: DescribeInstanceDetailsResponseBodyInstanceDetailsEipInfos[];
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * ddoscoo-cn-zvp2eibz****
   */
  instanceId?: string;
  /**
   * @remarks
   * The protection line of the instance.
   * 
   * @example
   * coop-line-001
   */
  line?: string;
  static names(): { [key: string]: string } {
    return {
      eipInfos: 'EipInfos',
      instanceId: 'InstanceId',
      line: 'Line',
    };
  }

  static types(): { [key: string]: any } {
    return {
      eipInfos: { 'type': 'array', 'itemType': DescribeInstanceDetailsResponseBodyInstanceDetailsEipInfos },
      instanceId: 'string',
      line: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceExtResponseBodyInstanceExtSpecs extends $tea.Model {
  /**
   * @remarks
   * The function plan. Valid values:
   * 
   * *   **0**: Standard
   * *   **1**: Enhanced
   * 
   * @example
   * 0
   */
  functionVersion?: number;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * ddoscoo-cn-i7m25564****
   */
  instanceId?: string;
  /**
   * @remarks
   * The clean bandwidth. Unit: Mbit/s.
   * 
   * @example
   * 100
   */
  normalBandwidth?: number;
  /**
   * @remarks
   * The type of the instance. Valid values:
   * 
   * *   **0**: Anti-DDoS Proxy (Outside Chinese Mainland) instance of the Insurance mitigation plan
   * *   **1**: Anti-DDoS Proxy (Outside Chinese Mainland) instance of the Unlimited mitigation plan
   * *   **2**: Anti-DDoS Proxy (Outside Chinese Mainland) instance of the Chinese Mainland Acceleration (CMA) mitigation plan
   * *   **3**: Anti-DDoS Proxy (Outside Chinese Mainland) instance of the Secure Chinese Mainland Acceleration (Sec-CMA) mitigation plan
   * *   **9**: Anti-DDoS Proxy (Chinese Mainland) instance of the Profession mitigation plan
   * 
   * @example
   * 0
   */
  productPlan?: number;
  /**
   * @remarks
   * The Internet service provider (ISP) line of the Anti-DDoS Proxy (Chinese Mainland) instance.
   * 
   * @example
   * coop-line-001
   */
  servicePartner?: string;
  static names(): { [key: string]: string } {
    return {
      functionVersion: 'FunctionVersion',
      instanceId: 'InstanceId',
      normalBandwidth: 'NormalBandwidth',
      productPlan: 'ProductPlan',
      servicePartner: 'ServicePartner',
    };
  }

  static types(): { [key: string]: any } {
    return {
      functionVersion: 'number',
      instanceId: 'string',
      normalBandwidth: 'number',
      productPlan: 'number',
      servicePartner: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceIdsResponseBodyInstanceIds extends $tea.Model {
  /**
   * @remarks
   * The type of the instance. Valid values:
   * 
   * *   **0**: Anti-DDoS Proxy (Outside Chinese Mainland) instance of the Insurance mitigation plan
   * *   **1**: Anti-DDoS Proxy (Outside Chinese Mainland) instance of the Unlimited mitigation plan
   * *   **2**: Anti-DDoS Proxy (Outside Chinese Mainland) instance of the CMA mitigation plan
   * *   **3**: Anti-DDoS Proxy (Outside Chinese Mainland) instance of the Sec-CMA mitigation plan
   * *   **9**: Anti-DDoS Proxy (Chinese Mainland) instance of the Profession mitigation plan
   * 
   * @example
   * 9
   */
  edition?: number;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * ddoscoo-cn-zvp2eibz****
   */
  instanceId?: string;
  /**
   * @remarks
   * The IP address-based forwarding mode of the instance. Valid values:
   * 
   * *   **fnat**: Requests from IPv4 addresses are forwarded to origin servers that use IPv4 addresses and requests from IPv6 addresses are forwarded to origin servers that use IPv6 addresses.
   * *   **v6tov4**: All requests are forwarded to origin servers that use IPv4 addresses.
   * 
   * @example
   * fnat
   */
  ipMode?: string;
  /**
   * @remarks
   * The IP version of the instance. Valid values:
   * 
   * *   **Ipv4**
   * *   **Ipv6**
   * 
   * @example
   * Ipv4
   */
  ipVersion?: string;
  /**
   * @remarks
   * The description of the instance.
   * 
   * @example
   * test
   */
  remark?: string;
  static names(): { [key: string]: string } {
    return {
      edition: 'Edition',
      instanceId: 'InstanceId',
      ipMode: 'IpMode',
      ipVersion: 'IpVersion',
      remark: 'Remark',
    };
  }

  static types(): { [key: string]: any } {
    return {
      edition: 'number',
      instanceId: 'string',
      ipMode: 'string',
      ipVersion: 'string',
      remark: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceSpecsResponseBodyInstanceSpecs extends $tea.Model {
  /**
   * @remarks
   * The clean bandwidth. Unit: Mbit/s.
   * 
   * @example
   * 100
   */
  bandwidthMbps?: number;
  /**
   * @remarks
   * The basic protection bandwidth. Unit: Gbit/s.
   * 
   * @example
   * 30
   */
  baseBandwidth?: number;
  /**
   * @remarks
   * The specification of concurrent connections of the instance.
   * 
   * @example
   * 100000
   */
  connLimit?: number;
  /**
   * @remarks
   * The specification of new connections of the instance.
   * 
   * @example
   * 5000
   */
  cpsLimit?: number;
  /**
   * @remarks
   * The number of available advanced mitigation sessions for this month. **-1**: unlimited
   * 
   * >  This parameter is returned only when the request parameter **RegionId** is set to **ap-southeast-1**. If RegionId is set to ap-southeast-1, the specifications of Anti-DDoS Proxy (Outside Chinese Mainland) instances are queried.
   * 
   * @example
   * 2
   */
  defenseCount?: number;
  /**
   * @remarks
   * The number of domain names that can be protected by the instance.
   * 
   * @example
   * 50
   */
  domainLimit?: number;
  /**
   * @remarks
   * The burstable protection bandwidth. Unit: Gbit/s.
   * 
   * @example
   * 30
   */
  elasticBandwidth?: number;
  /**
   * @remarks
   * The burstable clean bandwidth. Unit: Mbit/s.
   * 
   * @example
   * 300
   */
  elasticBw?: number;
  /**
   * @remarks
   * The metering method of the burstable clean bandwidth. Valid values:
   * 
   * *   **day**: the metering method of daily 95th percentile
   * *   **month**: the metering method of monthly 95th percentile
   * 
   * @example
   * day
   */
  elasticBwModel?: string;
  /**
   * @remarks
   * The burstable QPS. Unit: QPS
   * 
   * @example
   * 10
   */
  elasticQps?: number;
  /**
   * @remarks
   * The metering method of the burstable QPS. Valid values:
   * 
   * *   **day**: the metering method of daily 95th percentile
   * *   **month**: the metering method of monthly 95th percentile
   * 
   * @example
   * day
   */
  elasticQpsMode?: string;
  /**
   * @remarks
   * The function plan of the instance. Valid values:
   * 
   * *   **default**: Standard
   * *   **enhance**: Enhanced
   * *   **cnhk**: Chinese Mainland Acceleration (CMA)
   * *   **cnhk_default**: Secure Chinese Mainland Acceleration (Sec-CMA) standard
   * *   **cnhk_enhance**: Sec-CMA enhanced
   * 
   * @example
   * default
   */
  functionVersion?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * ddoscoo-cn-zvp2eibz****
   */
  instanceId?: string;
  /**
   * @remarks
   * The number of ports that can be protected by the instance.
   * 
   * @example
   * 50
   */
  portLimit?: number;
  /**
   * @remarks
   * The clean QPS.
   * 
   * @example
   * 3000
   */
  qpsLimit?: number;
  /**
   * @remarks
   * The threshold of the clean bandwidth. Valid values: 0 to 15360. The value 0 indicates that rate limiting is never triggered. Unit: Mbit/s
   * 
   * @example
   * 0
   */
  realLimitBw?: number;
  /**
   * @remarks
   * The number of sites that can be protected by the instance.
   * 
   * @example
   * 5
   */
  siteLimit?: number;
  static names(): { [key: string]: string } {
    return {
      bandwidthMbps: 'BandwidthMbps',
      baseBandwidth: 'BaseBandwidth',
      connLimit: 'ConnLimit',
      cpsLimit: 'CpsLimit',
      defenseCount: 'DefenseCount',
      domainLimit: 'DomainLimit',
      elasticBandwidth: 'ElasticBandwidth',
      elasticBw: 'ElasticBw',
      elasticBwModel: 'ElasticBwModel',
      elasticQps: 'ElasticQps',
      elasticQpsMode: 'ElasticQpsMode',
      functionVersion: 'FunctionVersion',
      instanceId: 'InstanceId',
      portLimit: 'PortLimit',
      qpsLimit: 'QpsLimit',
      realLimitBw: 'RealLimitBw',
      siteLimit: 'SiteLimit',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bandwidthMbps: 'number',
      baseBandwidth: 'number',
      connLimit: 'number',
      cpsLimit: 'number',
      defenseCount: 'number',
      domainLimit: 'number',
      elasticBandwidth: 'number',
      elasticBw: 'number',
      elasticBwModel: 'string',
      elasticQps: 'number',
      elasticQpsMode: 'string',
      functionVersion: 'string',
      instanceId: 'string',
      portLimit: 'number',
      qpsLimit: 'number',
      realLimitBw: 'number',
      siteLimit: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceStatisticsResponseBodyInstanceStatistics extends $tea.Model {
  /**
   * @remarks
   * The number of advanced mitigation sessions that are used in this month.
   * 
   * >  This parameter is returned only if Anti-DDoS Proxy (Outside Chinese Mainland) instances are queried.
   * 
   * @example
   * 1
   */
  defenseCountUsage?: number;
  /**
   * @remarks
   * The number of domain names that are protected by the instance.
   * 
   * @example
   * 1
   */
  domainUsage?: number;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * ddoscoo-cn-mp91j1ao****
   */
  instanceId?: string;
  /**
   * @remarks
   * The number of ports that are protected by the instance.
   * 
   * @example
   * 2
   */
  portUsage?: number;
  /**
   * @remarks
   * The number of websites that are protected by the instance.
   * 
   * @example
   * 1
   */
  siteUsage?: number;
  static names(): { [key: string]: string } {
    return {
      defenseCountUsage: 'DefenseCountUsage',
      domainUsage: 'DomainUsage',
      instanceId: 'InstanceId',
      portUsage: 'PortUsage',
      siteUsage: 'SiteUsage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      defenseCountUsage: 'number',
      domainUsage: 'number',
      instanceId: 'string',
      portUsage: 'number',
      siteUsage: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancesRequestTag extends $tea.Model {
  /**
   * @remarks
   * The key of the tag that is added to the instance to query. You can specify up to 200 tag keys. When you specify tags, take note of the following rules:
   * 
   * *   Each tag consists of a key (**Key**) and a value (**Value**), which are separated with a comma (,).
   * *   Separate multiple tags with commas (,).
   * 
   * >  The tag key (**Key**) and tag value (**Value**) must be specified in pairs.
   * 
   * @example
   * test-key
   */
  key?: string;
  /**
   * @remarks
   * The value of the tag that is added to the instance to query. You can specify up to 200 tag values. When you specify tags, take note of the following rules:
   * 
   * *   Each tag consists of a key (**Key**) and a value (**Value**), which are separated with a comma (,).
   * *   Separate multiple tags with commas (,).
   * 
   * >  The tag key (**Key**) and tag value (**Value**) must be specified in pairs.
   * 
   * @example
   * test-value
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancesResponseBodyInstances extends $tea.Model {
  /**
   * @remarks
   * The time when the instance was created. The value is a UNIX timestamp. Unit: milliseconds.
   * 
   * @example
   * 1637751953000
   */
  createTime?: number;
  /**
   * @remarks
   * The overdue status of the instance. The value is fixed as **0**, which indicates that your Alibaba Cloud account does not have overdue payments. The instance supports only the subscription billing method.
   * 
   * @example
   * 0
   */
  debtStatus?: number;
  /**
   * @remarks
   * The mitigation plan of the instance. Valid values:
   * 
   * *   **0**: Anti-DDoS Proxy (Outside Chinese Mainland) instance of the Insurance mitigation plan
   * *   **1**: Anti-DDoS Proxy (Outside Chinese Mainland) instance of the Unlimited mitigation plan
   * *   **2**: Anti-DDoS Proxy (Outside Chinese Mainland) instance of the Chinese Mainland Acceleration (CMA) mitigation plan
   * *   **9**: Anti-DDoS Proxy (Chinese Mainland) instance of the Profession mitigation plan
   * 
   * @example
   * 9
   */
  edition?: number;
  /**
   * @remarks
   * The traffic forwarding status of the instance. Valid values:
   * 
   * *   **0**: The instance no longer forwards service traffic.
   * *   **1**: The instance forwards service traffic as expected.
   * 
   * @example
   * 1
   */
  enabled?: number;
  /**
   * @remarks
   * The time when the instance expires. The value is a UNIX timestamp. Unit: milliseconds.
   * 
   * @example
   * 1640361600000
   */
  expireTime?: number;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * ddoscoo-cn-7pp2g9ed****
   */
  instanceId?: string;
  /**
   * @remarks
   * The IP address of the instance.
   * 
   * @example
   * 203.199.XX.XX
   */
  ip?: string;
  /**
   * @remarks
   * The IP address-based forwarding mode of the instance. Valid values:
   * 
   * *   **fnat**: Requests from IPv4 addresses are forwarded to origin servers that use IPv4 addresses and requests from IPv6 addresses are forwarded to origin servers that use IPv6 addresses.
   * *   **v6tov4**: All requests are forwarded to origin servers that use IPv4 addresses.
   * 
   * @example
   * fnat
   */
  ipMode?: string;
  /**
   * @remarks
   * The IP version of the instance. Valid values:
   * 
   * *   **Ipv4**
   * *   **Ipv6**
   * 
   * @example
   * Ipv4
   */
  ipVersion?: string;
  /**
   * @remarks
   * Indicates whether the metering method of the 95th percentile burstable clean bandwidth is enabled for the instance. Valid values:
   * 
   * *   0: no
   * *   1: yes
   * 
   * @example
   * 0
   */
  isFirstOpenBw?: number;
  /**
   * @remarks
   * Indicates whether the metering method of the 95th percentile burstable QPS is enabled for the instance. Valid values:
   * 
   * *   0: no
   * *   1: yes
   * 
   * @example
   * 0
   */
  isFirstOpenQps?: number;
  /**
   * @remarks
   * The remarks of the instance.
   * 
   * @example
   * doc-test
   */
  remark?: string;
  /**
   * @remarks
   * The status of the instance. Valid values:
   * 
   * *   **1**: normal
   * *   **2**: expired
   * 
   * @example
   * 1
   */
  status?: number;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      debtStatus: 'DebtStatus',
      edition: 'Edition',
      enabled: 'Enabled',
      expireTime: 'ExpireTime',
      instanceId: 'InstanceId',
      ip: 'Ip',
      ipMode: 'IpMode',
      ipVersion: 'IpVersion',
      isFirstOpenBw: 'IsFirstOpenBw',
      isFirstOpenQps: 'IsFirstOpenQps',
      remark: 'Remark',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'number',
      debtStatus: 'number',
      edition: 'number',
      enabled: 'number',
      expireTime: 'number',
      instanceId: 'string',
      ip: 'string',
      ipMode: 'string',
      ipVersion: 'string',
      isFirstOpenBw: 'number',
      isFirstOpenQps: 'number',
      remark: 'string',
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeL7RsPolicyResponseBodyAttributesAttribute extends $tea.Model {
  /**
   * @remarks
   * The timeout period for a new connection. Valid values: **1** to **10**. Unit: seconds. Default value: **5**.
   * 
   * @example
   * 5
   */
  connectTimeout?: number;
  /**
   * @remarks
   * The expiration time of a connection, in seconds. If the number of failures at the origin server exceeds the **MaxFails** value, the address of the origin server is set to down and the expiration time is **FailTimeout**. The final value is the maximum value of **ConnectTimeout** and **FailTimeout**. Valid values: **1** to **3600**. Unit: seconds. Default value: **10**.
   * 
   * @example
   * 10
   */
  failTimeout?: number;
  /**
   * @remarks
   * The maximum number of failures. This parameter is related to health check. Valid values: **1** to **10**. Unit: seconds. Default value: **3**.
   * 
   * @example
   * 3
   */
  maxFails?: number;
  /**
   * @remarks
   * The primary/secondary flag. Valid values:
   * 
   * *   **active**: primary
   * *   **backup**: secondary
   * 
   * @example
   * active
   */
  mode?: string;
  /**
   * @remarks
   * The timeout period for a read connection. Valid values: **10** to **300**. Unit: seconds. Default value: **120**.
   * 
   * @example
   * 120
   */
  readTimeout?: number;
  /**
   * @remarks
   * The timeout period for a write connection. Valid values: **10** to **300**. Unit: seconds. Default value: **120**.
   * 
   * @example
   * 120
   */
  sendTimeout?: number;
  /**
   * @remarks
   * The weight of the origin server. This parameter takes effect only when **ProxyMode** is set to **rr**.
   * 
   * Valid values: **1** to **100**. Default value: **100**. A server with a higher weight receives more requests.
   * 
   * @example
   * 100
   */
  weight?: number;
  static names(): { [key: string]: string } {
    return {
      connectTimeout: 'ConnectTimeout',
      failTimeout: 'FailTimeout',
      maxFails: 'MaxFails',
      mode: 'Mode',
      readTimeout: 'ReadTimeout',
      sendTimeout: 'SendTimeout',
      weight: 'Weight',
    };
  }

  static types(): { [key: string]: any } {
    return {
      connectTimeout: 'number',
      failTimeout: 'number',
      maxFails: 'number',
      mode: 'string',
      readTimeout: 'number',
      sendTimeout: 'number',
      weight: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeL7RsPolicyResponseBodyAttributes extends $tea.Model {
  /**
   * @remarks
   * The parameter for back-to-origin processing.
   */
  attribute?: DescribeL7RsPolicyResponseBodyAttributesAttribute;
  /**
   * @remarks
   * The address of the origin server.
   * 
   * @example
   * 1.***.***.1
   */
  realServer?: string;
  /**
   * @remarks
   * The address type of the origin server. Valid values:
   * 
   * *   **0**: IP address
   * *   **1**: domain name
   * 
   * @example
   * 0
   */
  rsType?: number;
  static names(): { [key: string]: string } {
    return {
      attribute: 'Attribute',
      realServer: 'RealServer',
      rsType: 'RsType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attribute: DescribeL7RsPolicyResponseBodyAttributesAttribute,
      realServer: 'string',
      rsType: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeL7UsKeepaliveResponseBodyRsKeepalive extends $tea.Model {
  /**
   * @remarks
   * Indicates whether Back-to-origin Persistent Connections is turned on. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * true
   */
  enabled?: boolean;
  /**
   * @remarks
   * The number of requests that reuse persistent connections.
   * 
   * @example
   * 1000
   */
  keepaliveRequests?: number;
  /**
   * @remarks
   * The timeout period of idle persistent connections.
   * 
   * @example
   * 30
   */
  keepaliveTimeout?: number;
  static names(): { [key: string]: string } {
    return {
      enabled: 'Enabled',
      keepaliveRequests: 'KeepaliveRequests',
      keepaliveTimeout: 'KeepaliveTimeout',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enabled: 'boolean',
      keepaliveRequests: 'number',
      keepaliveTimeout: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLayer4RulePolicyResponseBodyPriRealServers extends $tea.Model {
  /**
   * @remarks
   * The origin server that is used to receive service traffic. Valid values:
   * 
   * *   **1**: the primary origin server, which indicates that Anti-DDoS Pro or Anti-DDoS Premium forwards service traffic to the IP addresses of the primary origin server.
   * *   **2**: the secondary origin server, which indicates that Anti-DDoS Pro or Anti-DDoS Premium forwards service traffic to the IP addresses of the secondary origin server.
   * 
   * @example
   * 1
   */
  currentIndex?: number;
  /**
   * @remarks
   * The IP address of the instance.
   * 
   * @example
   * 203.107.XX.XX
   */
  eip?: string;
  /**
   * @remarks
   * The forwarding port.
   * 
   * @example
   * 2020
   */
  frontendPort?: number;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * ddosDip-sg-4hr2b3l****
   */
  instanceId?: string;
  /**
   * @remarks
   * The type of the protocol.
   * 
   * @example
   * udp
   */
  protocol?: string;
  /**
   * @remarks
   * The IP address of the primary origin server.
   * 
   * @example
   * 192.0.2.1
   */
  realServer?: string;
  static names(): { [key: string]: string } {
    return {
      currentIndex: 'CurrentIndex',
      eip: 'Eip',
      frontendPort: 'FrontendPort',
      instanceId: 'InstanceId',
      protocol: 'Protocol',
      realServer: 'RealServer',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentIndex: 'number',
      eip: 'string',
      frontendPort: 'number',
      instanceId: 'string',
      protocol: 'string',
      realServer: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLayer4RulePolicyResponseBodySecRealServers extends $tea.Model {
  /**
   * @remarks
   * The origin server that is used to receive service traffic. Valid values:
   * 
   * *   **1**: the primary origin server, which indicates that Anti-DDoS Pro or Anti-DDoS Premium forwards service traffic to the IP addresses of the primary origin server.
   * *   **2**: the secondary origin server, which indicates that Anti-DDoS Pro or Anti-DDoS Premium forwards service traffic to the IP addresses of the secondary origin server.
   * 
   * @example
   * 1
   */
  currentIndex?: number;
  /**
   * @remarks
   * The IP address of the instance.
   * 
   * @example
   * 203.107.XX.XX
   */
  eip?: string;
  /**
   * @remarks
   * The forwarding port.
   * 
   * @example
   * 2020
   */
  frontendPort?: number;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * ddosDip-sg-4hr2b3l****
   */
  instanceId?: string;
  /**
   * @remarks
   * The type of the protocol.
   * 
   * @example
   * udp
   */
  protocol?: string;
  /**
   * @remarks
   * The IP address of the secondary origin server.
   * 
   * @example
   * 192.0.2.3
   */
  realServer?: string;
  static names(): { [key: string]: string } {
    return {
      currentIndex: 'CurrentIndex',
      eip: 'Eip',
      frontendPort: 'FrontendPort',
      instanceId: 'InstanceId',
      protocol: 'Protocol',
      realServer: 'RealServer',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentIndex: 'number',
      eip: 'string',
      frontendPort: 'number',
      instanceId: 'string',
      protocol: 'string',
      realServer: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNetworkRegionBlockResponseBodyConfig extends $tea.Model {
  /**
   * @remarks
   * The codes of the countries or areas from which the requests are blocked.
   */
  countries?: number[];
  /**
   * @remarks
   * The codes of the administrative regions in China from which the requests are blocked.
   */
  provinces?: number[];
  /**
   * @remarks
   * The status of the Location Blacklist policy. Valid values:
   * 
   * *   **on**: enabled
   * *   **off**: disabled
   * 
   * @example
   * on
   */
  regionBlockSwitch?: string;
  static names(): { [key: string]: string } {
    return {
      countries: 'Countries',
      provinces: 'Provinces',
      regionBlockSwitch: 'RegionBlockSwitch',
    };
  }

  static types(): { [key: string]: any } {
    return {
      countries: { 'type': 'array', 'itemType': 'number' },
      provinces: { 'type': 'array', 'itemType': 'number' },
      regionBlockSwitch: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigCcSblack extends $tea.Model {
  /**
   * @remarks
   * The threshold that the number of connections initiated from a source IP address can exceed the limit. Set the value to **5**. If the number of connections initiated from a source IP address exceeds the limit five times during the check, the source IP address is added to the blacklist.
   * 
   * @example
   * 5
   */
  cnt?: number;
  /**
   * @remarks
   * The interval at which checks are performed. Set the value to **60**. Unit: seconds.
   * 
   * @example
   * 60
   */
  during?: number;
  /**
   * @remarks
   * The validity period of the IP address in the blacklist. Valid values: **60** to **604800**. Unit: seconds.
   * 
   * @example
   * 600
   */
  expires?: number;
  /**
   * @remarks
   * The type of the limit that causes a source IP address to be added to the blacklist. Valid values:
   * 
   * *   **1**: Source New Connection Rate Limit
   * *   **2**: Source Concurrent Connection Rate Limit
   * *   **3**: PPS Limit for Source
   * *   **4**: Bandwidth Limit for Source
   * 
   * @example
   * 1
   */
  type?: number;
  static names(): { [key: string]: string } {
    return {
      cnt: 'Cnt',
      during: 'During',
      expires: 'Expires',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cnt: 'number',
      during: 'number',
      expires: 'number',
      type: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigCc extends $tea.Model {
  /**
   * @remarks
   * The protection policy that a source IP address is added to the blacklist when the number of connections initiated from the IP address frequently exceeds the limit.
   */
  sblack?: DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigCcSblack[];
  static names(): { [key: string]: string } {
    return {
      sblack: 'Sblack',
    };
  }

  static types(): { [key: string]: any } {
    return {
      sblack: { 'type': 'array', 'itemType': DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigCcSblack },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigPayloadLen extends $tea.Model {
  /**
   * @remarks
   * The maximum length of a packet. Valid values: **0** to **6000**. Unit: bytes.
   * 
   * @example
   * 6000
   */
  max?: number;
  /**
   * @remarks
   * The minimum length of a packet. Valid values: **0** to **6000**. Unit: bytes.
   * 
   * @example
   * 0
   */
  min?: number;
  static names(): { [key: string]: string } {
    return {
      max: 'Max',
      min: 'Min',
    };
  }

  static types(): { [key: string]: any } {
    return {
      max: 'number',
      min: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigSla extends $tea.Model {
  /**
   * @remarks
   * The maximum number of new connections per second that can be established over the port of the destination instance. Valid values: **100** to **100000**.
   * 
   * @example
   * 100000
   */
  cps?: number;
  /**
   * @remarks
   * The status of the Destination New Connection Rate Limit switch. Valid values:
   * 
   * *   **0**: The switch is turned off.
   * *   **1**: The switch is turned on.
   * 
   * @example
   * 1
   */
  cpsEnable?: number;
  /**
   * @remarks
   * The maximum number of concurrent connections that can be established over the port of the destination instance. Valid values: **1000** to **1000000**.
   * 
   * @example
   * 1000000
   */
  maxconn?: number;
  /**
   * @remarks
   * The status of the Destination Concurrent Connection Rate Limit switch. Valid values:
   * 
   * *   **0**: The switch is turned off.
   * *   **1**: The switch is turned on.
   * 
   * @example
   * 0
   */
  maxconnEnable?: number;
  static names(): { [key: string]: string } {
    return {
      cps: 'Cps',
      cpsEnable: 'CpsEnable',
      maxconn: 'Maxconn',
      maxconnEnable: 'MaxconnEnable',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cps: 'number',
      cpsEnable: 'number',
      maxconn: 'number',
      maxconnEnable: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigSlimit extends $tea.Model {
  /**
   * @remarks
   * The bandwidth limit for a source IP address. Valid values: **1024** to **268435456**. Unit: bytes/s. Default value: **0**, which indicates that the bandwidth for a source IP address is unlimited.
   * 
   * @example
   * 0
   */
  bps?: number;
  /**
   * @remarks
   * The maximum number of new connections per second that can be initiated from a source IP address. Valid values: **1** to **500000**.
   * 
   * @example
   * 0
   */
  cps?: number;
  /**
   * @remarks
   * The status of the Source New Connection Rate Limit switch. Valid values:
   * 
   * *   **0**: The switch is turned off.
   * *   **1**: The switch is turned on.
   * 
   * @example
   * 0
   */
  cpsEnable?: number;
  /**
   * @remarks
   * The mode of the Source New Connection Rate Limit switch. Valid values:
   * 
   * *   **1**: the manual mode
   * *   **2**: the automatic mode
   * 
   * @example
   * 1
   */
  cpsMode?: number;
  /**
   * @remarks
   * The maximum number of concurrent connections initiated from a source IP address. Valid values: **1** to **500000**.
   * 
   * @example
   * 0
   */
  maxconn?: number;
  /**
   * @remarks
   * The status of the Source Concurrent Connection Rate Limit switch. Valid values:
   * 
   * *   **0**: The switch is turned off.
   * *   **1**: The switch is turned on.
   * 
   * @example
   * 0
   */
  maxconnEnable?: number;
  /**
   * @remarks
   * The packets per second (pps) limit for a source IP address. Valid values: **1** to **100000**. Unit: packets/s. Default value: **0**, which indicates that the pps for a source IP address is unlimited.
   * 
   * @example
   * 0
   */
  pps?: number;
  static names(): { [key: string]: string } {
    return {
      bps: 'Bps',
      cps: 'Cps',
      cpsEnable: 'CpsEnable',
      cpsMode: 'CpsMode',
      maxconn: 'Maxconn',
      maxconnEnable: 'MaxconnEnable',
      pps: 'Pps',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bps: 'number',
      cps: 'number',
      cpsEnable: 'number',
      cpsMode: 'number',
      maxconn: 'number',
      maxconnEnable: 'number',
      pps: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfig extends $tea.Model {
  /**
   * @remarks
   * The protection policy applied when the number of connections initiated from a source IP address frequently exceeds the limit.
   */
  cc?: DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigCc;
  /**
   * @remarks
   * The status of the Empty Connection switch. Valid values:
   * 
   * *   **on**: The switch is turned on.
   * *   **off**: The switch is turned off.
   * 
   * @example
   * off
   */
  nodataConn?: string;
  /**
   * @remarks
   * The settings of the Packet Length Limit policy.
   */
  payloadLen?: DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigPayloadLen;
  /**
   * @remarks
   * The timeout period of session persistence. Valid values: **30** to **3600**. Unit: seconds. Default value: **0**, which indicates that session persistence is disabled.
   * 
   * @example
   * 0
   */
  persistenceTimeout?: number;
  /**
   * @remarks
   * The settings of the Speed Limit for Destination policy.
   */
  sla?: DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigSla;
  /**
   * @remarks
   * The settings of the Speed Limit for Source policy.
   */
  slimit?: DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigSlimit;
  /**
   * @remarks
   * The status of the False Source switch. Valid values:
   * 
   * *   **on**: The switch is turned on.
   * *   **off**: The switch is turned off.
   * 
   * @example
   * off
   */
  synproxy?: string;
  static names(): { [key: string]: string } {
    return {
      cc: 'Cc',
      nodataConn: 'NodataConn',
      payloadLen: 'PayloadLen',
      persistenceTimeout: 'PersistenceTimeout',
      sla: 'Sla',
      slimit: 'Slimit',
      synproxy: 'Synproxy',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cc: DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigCc,
      nodataConn: 'string',
      payloadLen: DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigPayloadLen,
      persistenceTimeout: 'number',
      sla: DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigSla,
      slimit: DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigSlimit,
      synproxy: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributes extends $tea.Model {
  /**
   * @remarks
   * The mitigation settings of the port forwarding rule.
   */
  config?: DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfig;
  /**
   * @remarks
   * The forwarding port.
   * 
   * @example
   * 8080
   */
  frontendPort?: number;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * ddoscoo-cn-mp91j1ao****
   */
  instanceId?: string;
  /**
   * @remarks
   * The forwarding protocol. Valid values:
   * 
   * *   **tcp**
   * *   **udp**
   * 
   * @example
   * tcp
   */
  protocol?: string;
  static names(): { [key: string]: string } {
    return {
      config: 'Config',
      frontendPort: 'FrontendPort',
      instanceId: 'InstanceId',
      protocol: 'Protocol',
    };
  }

  static types(): { [key: string]: any } {
    return {
      config: DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfig,
      frontendPort: 'number',
      instanceId: 'string',
      protocol: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNetworkRulesResponseBodyNetworkRules extends $tea.Model {
  /**
   * @remarks
   * The port of the origin server.
   * 
   * @example
   * 80
   */
  backendPort?: number;
  /**
   * @remarks
   * The forwarding port.
   * 
   * @example
   * 80
   */
  frontendPort?: number;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * ddoscoo-cn-mp91j1ao****
   */
  instanceId?: string;
  /**
   * @remarks
   * Indicates whether the port forwarding rule is automatically created. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * true
   */
  isAutoCreate?: boolean;
  /**
   * @remarks
   * The forwarding protocol. Valid values:
   * 
   * *   **tcp**
   * *   **udp**
   * 
   * @example
   * tcp
   */
  protocol?: string;
  /**
   * @remarks
   * The IP addresses of origin servers.
   */
  realServers?: string[];
  /**
   * @remarks
   * The remarks of the port forwarding rule.
   * 
   * @example
   * Test
   */
  remark?: string;
  static names(): { [key: string]: string } {
    return {
      backendPort: 'BackendPort',
      frontendPort: 'FrontendPort',
      instanceId: 'InstanceId',
      isAutoCreate: 'IsAutoCreate',
      protocol: 'Protocol',
      realServers: 'RealServers',
      remark: 'Remark',
    };
  }

  static types(): { [key: string]: any } {
    return {
      backendPort: 'number',
      frontendPort: 'number',
      instanceId: 'string',
      isAutoCreate: 'boolean',
      protocol: 'string',
      realServers: { 'type': 'array', 'itemType': 'string' },
      remark: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOpEntitiesResponseBodyOpEntities extends $tea.Model {
  /**
   * @remarks
   * The operation object.
   * 
   * @example
   * 203.***.***.132
   */
  entityObject?: string;
  /**
   * @remarks
   * The type of the operation object. Valid values:
   * 
   * *   **1**: the IP address of the Anti-DDoS Pro or Anti-DDoS Premium instance
   * *   **2**: Anti-DDoS plans
   * *   **3**: ECS instances
   * *   **4**: all logs
   * 
   * @example
   * 1
   */
  entityType?: number;
  /**
   * @remarks
   * The time when the operation was performed. The value is a UNIX timestamp. Unit: milliseconds.
   * 
   * @example
   * 1584451769000
   */
  gmtCreate?: number;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account that is used to call the API operation.
   * 
   * @example
   * 128965410602****
   */
  opAccount?: string;
  /**
   * @remarks
   * The type of the operation. Valid values:
   * 
   * *   **1**: configuring burstable protection bandwidth.
   * *   **5**: using Anti-DDoS plans.
   * *   **8**: changing IP addresses of ECS instances.
   * *   **9**: deactivating blackhole filtering.
   * *   **10**: configuring the Diversion from Origin Server policy.
   * *   **11**: clearing all logs.
   * *   **12**: downgrading the specifications of instances. If the instance expires or the account has overdue payments, this operation is performed to downgrade the burstable protection bandwidth.
   * *   **13**: restoring the specifications of instances. If the instance is renewed or you have paid the overdue payments within your account, this operation is performed to restore the burstable protection bandwidth.
   * 
   * @example
   * 9
   */
  opAction?: number;
  /**
   * @remarks
   * The details of the operation. This parameter is a JSON string. The string contains the following fields:
   * 
   * *   **newEntity**: the values of the parameters after the operation. This field must be of the STRING type.
   * *   **oldEntity**: the values of the parameters before the operation. This field must be of the STRING type.
   * 
   * Both **newEntity** and **oldEntity** are JSON strings. The returned parameters vary with **OpAtion**.
   * 
   * If **OpAction** is **1**, **12**, or **13**, the following parameter is returned:
   * 
   * *   **elasticBandwidth**: the burstable protection bandwidth. The value is of the INTEGER type.
   * 
   *     For example: `{"newEntity":{"elasticBandwidth":300},"oldEntity":{"elasticBandwidth":300}}`
   * 
   * If **OpAction** is **5**, the following parameters are returned:
   * 
   * *   **bandwidth**: the burstable protection bandwidth. The value is of the INTEGER type. Unit: Gbit/s.
   * 
   * *   **count**: the number of Anti-DDoS plans. The value is of the INTEGER type.
   * 
   * *   **deductCount**: the number of used Anti-DDoS plans. The value is of the INTEGER type.
   * 
   * *   **expireTime**: the expiration time of the Anti-DDoS plans. The value is of the LONG type. The value is a UNIX timestamp. Unit: milliseconds.
   * 
   * *   **instanceId**: the ID of the instance. The value is of the STRING type.
   * 
   * *   **peakFlow**: the peak throughput on the instance. The value is of the INTEGER type. Unit: bit/s.
   * 
   *     For example: `{"newEntity":{"bandwidth":100,"count":4,"deductCount":1,"expireTime":1616299196000,"instanceId":"ddoscoo-cn-v641kpmq****","peakFlow":751427000}}`
   * 
   * If **OpAction** is **8**, the following parameter is returned:
   * 
   * *   **instanceId**: the ID of the ECS instance whose IP address is changed. The value is of the STRING type.
   * 
   *     For example: `{"newEntity":{"instanceId":"i-wz9h6nc313zptbqn****"}}`
   * 
   * If **OpAction** is **9**, the following parameter is returned:
   * 
   * *   **actionMethod**: the operation method. The value is of the STRING type. Valid value: **undo**, which indicates that you deactivated blackhole filtering.
   * 
   *     For example: `{"newEntity":{"actionMethod":"undo"}}`
   * 
   * If **OpAction** is **10**, the following parameters are returned:
   * 
   * *   **actionMethod**: the operation method. The value is of the STRING type. Valid values:
   * 
   *     *   **do**: The Diversion from Origin Server policy is enabled.
   *     *   **undo**: The Diversion from Origin Server policy is disabled.
   * 
   * *   **lines**: The Internet service provider (ISP) line from which the traffic is blocked. Valid values:
   * 
   *     *   **ct**: China Telecom (International)
   *     *   **cut**: China Unicom (International)
   * 
   *     For example: `{"newEntity":{"actionMethod":"undo","lines":["ct"]}}`
   * 
   * If **OpAction** is **11**, no parameter is returned, and the description is empty.
   * 
   * @example
   * {"newEntity":{"actionMethod":"undo"}}
   */
  opDesc?: string;
  static names(): { [key: string]: string } {
    return {
      entityObject: 'EntityObject',
      entityType: 'EntityType',
      gmtCreate: 'GmtCreate',
      opAccount: 'OpAccount',
      opAction: 'OpAction',
      opDesc: 'OpDesc',
    };
  }

  static types(): { [key: string]: any } {
    return {
      entityObject: 'string',
      entityType: 'number',
      gmtCreate: 'number',
      opAccount: 'string',
      opAction: 'number',
      opDesc: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePortResponseBodyNetworkRules extends $tea.Model {
  /**
   * @remarks
   * The port of the origin server.
   * 
   * @example
   * 55
   */
  backendPort?: number;
  /**
   * @remarks
   * The forwarding port.
   * 
   * @example
   * 55
   */
  frontendPort?: number;
  /**
   * @remarks
   * The type of the protocol. Valid values:
   * 
   * *   **tcp**
   * *   **udp**
   * 
   * @example
   * tcp
   */
  frontendProtocol?: string;
  /**
   * @remarks
   * The ID of the instance to which the port forwarding rule is applied.
   * 
   * @example
   * ddoscoo-cn-7e225i41****
   */
  instanceId?: string;
  /**
   * @remarks
   * Indicates whether the port forwarding rule is automatically created by the instance. Valid values:
   * 
   * *   **true**: yes
   * *   **false**: no
   * 
   * @example
   * false
   */
  isAutoCreate?: boolean;
  /**
   * @remarks
   * An array that consists of IP addresses of origin servers.
   */
  realServers?: string[];
  static names(): { [key: string]: string } {
    return {
      backendPort: 'BackendPort',
      frontendPort: 'FrontendPort',
      frontendProtocol: 'FrontendProtocol',
      instanceId: 'InstanceId',
      isAutoCreate: 'IsAutoCreate',
      realServers: 'RealServers',
    };
  }

  static types(): { [key: string]: any } {
    return {
      backendPort: 'number',
      frontendPort: 'number',
      frontendProtocol: 'string',
      instanceId: 'string',
      isAutoCreate: 'boolean',
      realServers: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePortAutoCcStatusResponseBodyPortAutoCcStatus extends $tea.Model {
  /**
   * @remarks
   * The mode of the Intelligent Protection policy. Valid values:
   * 
   * *   **normal**
   * *   **loose**
   * *   **strict**
   * 
   * @example
   * normal
   */
  mode?: string;
  /**
   * @remarks
   * The status of the Intelligent Protection policy. Valid values:
   * 
   * *   **on**: enabled
   * *   **off**: disabled
   * 
   * @example
   * on
   */
  switch?: string;
  /**
   * @remarks
   * The protection mode for ports 80 and 443. Valid values:
   * 
   * *   **normal**
   * *   **loose**
   * *   **strict**
   * 
   * @example
   * normal
   */
  webMode?: string;
  /**
   * @remarks
   * The status of the Intelligent Protection policy for ports 80 and 443. Valid values:
   * 
   * *   **on**: enabled
   * *   **off**: disabled
   * 
   * @example
   * off
   */
  webSwitch?: string;
  static names(): { [key: string]: string } {
    return {
      mode: 'Mode',
      switch: 'Switch',
      webMode: 'WebMode',
      webSwitch: 'WebSwitch',
    };
  }

  static types(): { [key: string]: any } {
    return {
      mode: 'string',
      switch: 'string',
      webMode: 'string',
      webSwitch: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePortCcAttackTopIPResponseBodyTopIp extends $tea.Model {
  /**
   * @remarks
   * The code of the location from which the attack is initiated. For more information, see [Codes of administrative regions in China and codes of countries and areas](https://help.aliyun.com/document_detail/167926.html). For example, **110000** indicates Beijing, China, and **us** indicates the United States.
   * 
   * @example
   * cn-shanghai
   */
  areaId?: string;
  /**
   * @remarks
   * The number of attacks from the IP address.
   * 
   * @example
   * 33971
   */
  pv?: number;
  /**
   * @remarks
   * The source IP address of the attack.
   * 
   * @example
   * 172.18.XX.XX
   */
  srcIp?: string;
  static names(): { [key: string]: string } {
    return {
      areaId: 'AreaId',
      pv: 'Pv',
      srcIp: 'SrcIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      areaId: 'string',
      pv: 'number',
      srcIp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePortConnsListResponseBodyConnsList extends $tea.Model {
  /**
   * @remarks
   * The number of active connections.
   * 
   * @example
   * 3
   */
  actConns?: number;
  /**
   * @remarks
   * >  This parameter is in internal preview. Do not use this parameter.
   * 
   * @example
   * 8
   */
  conns?: number;
  /**
   * @remarks
   * The number of new connections.
   * 
   * @example
   * 0
   */
  cps?: number;
  /**
   * @remarks
   * The number of inactive connections.
   * 
   * @example
   * 2
   */
  inActConns?: number;
  /**
   * @remarks
   * The index number of the returned data.
   * 
   * @example
   * 16506
   */
  index?: number;
  static names(): { [key: string]: string } {
    return {
      actConns: 'ActConns',
      conns: 'Conns',
      cps: 'Cps',
      inActConns: 'InActConns',
      index: 'Index',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actConns: 'number',
      conns: 'number',
      cps: 'number',
      inActConns: 'number',
      index: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePortFlowListResponseBodyPortFlowList extends $tea.Model {
  /**
   * @remarks
   * The bandwidth of attack traffic. Unit: bit/s.
   * 
   * @example
   * 0
   */
  attackBps?: number;
  /**
   * @remarks
   * The packet forwarding rate of attack traffic. Unit: pps.
   * 
   * @example
   * 0
   */
  attackPps?: number;
  /**
   * @remarks
   * The inbound bandwidth. Unit: bit/s.
   * 
   * @example
   * 2176000
   */
  inBps?: number;
  /**
   * @remarks
   * The packet forwarding rate of inbound traffic. Unit: packets per second.
   * 
   * @example
   * 2934
   */
  inPps?: number;
  /**
   * @remarks
   * The index number of the returned data.
   * 
   * @example
   * 0
   */
  index?: number;
  /**
   * @remarks
   * The outbound bandwidth. Unit: bit/s.
   * 
   * @example
   * 4389
   */
  outBps?: number;
  /**
   * @remarks
   * The packet forwarding rate of outbound traffic. Unit: packets per second (pps).
   * 
   * @example
   * 5
   */
  outPps?: number;
  /**
   * @remarks
   * The source region of the traffic. Valid values:
   * 
   * *   **cn**: mainland China
   * *   **alb-ap-northeast-1-gf-x**: Japan (Tokyo)
   * *   **alb-ap-southeast-gf-x**: Singapore
   * *   **alb-cn-hongkong-gf-x**: Hong Kong (China)
   * *   **alb-eu-central-1-gf-x**: Germany (Frankfurt)
   * *   **alb-us-west-1-gf-x**: US (Silicon Valley)
   * 
   * > The values except **cn** are returned only when **RegionId** is set to **ap-southeast-1**.
   * 
   * @example
   * cn
   */
  region?: string;
  slaBpsDropBps?: number;
  slaBpsDropPps?: number;
  slaConnDropBps?: number;
  slaConnDropPps?: number;
  slaCpsDropBps?: number;
  slaCpsDropPps?: number;
  slaPpsDropBps?: number;
  slaPpsDropPps?: number;
  /**
   * @remarks
   * The time when the data was collected. The value is a UNIX timestamp. Unit: seconds.
   * 
   * @example
   * 1582992000
   */
  time?: number;
  static names(): { [key: string]: string } {
    return {
      attackBps: 'AttackBps',
      attackPps: 'AttackPps',
      inBps: 'InBps',
      inPps: 'InPps',
      index: 'Index',
      outBps: 'OutBps',
      outPps: 'OutPps',
      region: 'Region',
      slaBpsDropBps: 'SlaBpsDropBps',
      slaBpsDropPps: 'SlaBpsDropPps',
      slaConnDropBps: 'SlaConnDropBps',
      slaConnDropPps: 'SlaConnDropPps',
      slaCpsDropBps: 'SlaCpsDropBps',
      slaCpsDropPps: 'SlaCpsDropPps',
      slaPpsDropBps: 'SlaPpsDropBps',
      slaPpsDropPps: 'SlaPpsDropPps',
      time: 'Time',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attackBps: 'number',
      attackPps: 'number',
      inBps: 'number',
      inPps: 'number',
      index: 'number',
      outBps: 'number',
      outPps: 'number',
      region: 'string',
      slaBpsDropBps: 'number',
      slaBpsDropPps: 'number',
      slaConnDropBps: 'number',
      slaConnDropPps: 'number',
      slaCpsDropBps: 'number',
      slaCpsDropPps: 'number',
      slaPpsDropBps: 'number',
      slaPpsDropPps: 'number',
      time: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePortMaxConnsResponseBodyPortMaxConns extends $tea.Model {
  /**
   * @remarks
   * The maximum number of connections per second (CPS).
   * 
   * @example
   * 100
   */
  cps?: number;
  /**
   * @remarks
   * The IP address of the instance.
   * 
   * @example
   * 203.***.***.117
   */
  ip?: string;
  /**
   * @remarks
   * The port of the instance.
   * 
   * @example
   * 80
   */
  port?: string;
  static names(): { [key: string]: string } {
    return {
      cps: 'Cps',
      ip: 'Ip',
      port: 'Port',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cps: 'number',
      ip: 'string',
      port: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePortViewSourceCountriesResponseBodySourceCountrys extends $tea.Model {
  /**
   * @remarks
   * The number of requests.
   * 
   * @example
   * 3390671
   */
  count?: number;
  /**
   * @remarks
   * The abbreviation of the country or area. For example, **cn** indicates China and **us** indicates the United States.
   * 
   * > For more information, see [Location parameters](https://help.aliyun.com/document_detail/167926.html).
   * 
   * @example
   * cn
   */
  countryId?: string;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      countryId: 'CountryId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      countryId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePortViewSourceIspsResponseBodyIsps extends $tea.Model {
  /**
   * @remarks
   * The total number of requests that are sent from the ISP.
   * 
   * > This parameter does not indicate the accurate number of requests. You can use this parameter to calculate the proportion of requests from different ISPs.
   * 
   * @example
   * 3390671
   */
  count?: number;
  /**
   * @remarks
   * The ID of the ISP. For more information, see the ISP codes table.
   * 
   * @example
   * 100017
   */
  ispId?: string;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      ispId: 'IspId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      ispId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePortViewSourceProvincesResponseBodySourceProvinces extends $tea.Model {
  /**
   * @remarks
   * The total number of requests that are sent from the ISP.
   * 
   * > This parameter does not indicate the accurate number of requests. You can use this parameter to calculate the proportion of requests from different administrative regions in China.
   * 
   * @example
   * 3390671
   */
  count?: number;
  /**
   * @remarks
   * The ID of the administrative region in China from which the requests are sent. For example, **110000** indicates Beijing, and **120000** indicates Tianjin.
   * 
   * > For more information, see [Location parameters](https://help.aliyun.com/document_detail/167926.html).
   * 
   * @example
   * 440000
   */
  provinceId?: string;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      provinceId: 'ProvinceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      provinceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSceneDefenseObjectsResponseBodyObjects extends $tea.Model {
  /**
   * @remarks
   * The domain name that is protected by the policy.
   * 
   * @example
   * www.aliyundoc.com
   */
  domain?: string;
  /**
   * @remarks
   * The ID of the policy.
   * 
   * @example
   * 47e07ebd-0ba5-4afc-957b-59d15b90****
   */
  policyId?: string;
  /**
   * @remarks
   * The IP address of the Anti-DDoS Pro or Anti-DDoS Premium instance that is protected by the policy.
   * 
   * @example
   * 203.XX.XX.119
   */
  vip?: string;
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
      policyId: 'PolicyId',
      vip: 'Vip',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
      policyId: 'string',
      vip: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSceneDefensePoliciesResponseBodyPoliciesRuntimePolicies extends $tea.Model {
  /**
   * @remarks
   * The protection rule that is applied when the policy takes effect.
   * 
   * If you set **PolicyType** to **1**, the value is **{"cc_rule_enable": false }**. The value indicates that the Frequency Control policy is disabled.
   * 
   * If you set **PolicyType** to **2**, the value is **{"ai_rule_enable": 0}**. The value indicates that the Intelligent Protection policy is disabled.
   * 
   * @example
   * {"cc_rule_enable": false }
   */
  newValue?: string;
  /**
   * @remarks
   * The protection policy whose status is changed when the policy takes effect. Valid values:
   * 
   * *   **1**: indicates that the Frequency Control policy is changed.
   * *   **2**: indicates that the Intelligent Protection policy is changed.
   * 
   * @example
   * 1
   */
  policyType?: number;
  /**
   * @remarks
   * The running status of the policy. Valid values:
   * 
   * *   **0**: The policy has not been issued or is restored.
   * *   **1**: The policy is pending.
   * *   **2**: The policy is being restored.
   * *   **3**: The policy takes effect.
   * *   **4**: The policy fails to take effect.
   * *   **5**:The policy fails to be restored.
   * *   **6**: The configurations of the protected objects for the policy does not exist because the configurations may be deleted.
   * 
   * @example
   * 3
   */
  status?: number;
  /**
   * @remarks
   * The protection rule that is applied before the policy takes effect.
   * 
   * If you set **PolicyType** to **1**, the value is **{"cc_rule_enable": true}**. The value indicates that the Frequency Control policy is enabled.
   * 
   * If you set **PolicyType** to **2**, the value is **{"ai_rule_enable": 1}**. The value indicates that the Intelligent Protection policy is enabled.
   * 
   * @example
   * {"cc_rule_enable": true}
   */
  oldValue?: string;
  static names(): { [key: string]: string } {
    return {
      newValue: 'NewValue',
      policyType: 'PolicyType',
      status: 'Status',
      oldValue: 'oldValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      newValue: 'string',
      policyType: 'number',
      status: 'number',
      oldValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSceneDefensePoliciesResponseBodyPolicies extends $tea.Model {
  /**
   * @remarks
   * The execution status of the policy. Valid values:
   * 
   * *   **1**: not executed or execution completed
   * *   **0**: being executed
   * *   **-1**: execution failed
   * 
   * @example
   * 1
   */
  done?: number;
  /**
   * @remarks
   * The time at which the policy expires. The value is a UNIX timestamp. Unit: milliseconds.
   * 
   * @example
   * 1586016000000
   */
  endTime?: number;
  /**
   * @remarks
   * The name of the policy.
   * 
   * @example
   * testpolicy
   */
  name?: string;
  /**
   * @remarks
   * The number of objects that are protected by the policy.
   * 
   * @example
   * 1
   */
  objectCount?: number;
  /**
   * @remarks
   * The ID of the policy.
   * 
   * @example
   * 321a-fd31-df51-****
   */
  policyId?: string;
  /**
   * @remarks
   * The running rules of the policy.
   */
  runtimePolicies?: DescribeSceneDefensePoliciesResponseBodyPoliciesRuntimePolicies[];
  /**
   * @remarks
   * The time at which the policy takes effect. The value is a UNIX timestamp. Unit: milliseconds.
   * 
   * @example
   * 1585670400000
   */
  startTime?: number;
  /**
   * @remarks
   * The status of the policy. Valid values:
   * 
   * *   **0**: disabled
   * *   **1**: pending enabling
   * *   **2**: enabled
   * *   **3**: expired
   * 
   * @example
   * 1
   */
  status?: number;
  /**
   * @remarks
   * The type of the template that is used to create the policy. Valid values:
   * 
   * *   **promotion**: the Important Activity template
   * *   **bypass**: the Forward All template
   * 
   * @example
   * promotion
   */
  template?: string;
  static names(): { [key: string]: string } {
    return {
      done: 'Done',
      endTime: 'EndTime',
      name: 'Name',
      objectCount: 'ObjectCount',
      policyId: 'PolicyId',
      runtimePolicies: 'RuntimePolicies',
      startTime: 'StartTime',
      status: 'Status',
      template: 'Template',
    };
  }

  static types(): { [key: string]: any } {
    return {
      done: 'number',
      endTime: 'number',
      name: 'string',
      objectCount: 'number',
      policyId: 'string',
      runtimePolicies: { 'type': 'array', 'itemType': DescribeSceneDefensePoliciesResponseBodyPoliciesRuntimePolicies },
      startTime: 'number',
      status: 'number',
      template: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSchedulerRulesResponseBodySchedulerRulesParamParamData extends $tea.Model {
  /**
   * @example
   * ga-bp1htlajy5509rc99****
   */
  cloudInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      cloudInstanceId: 'CloudInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cloudInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSchedulerRulesResponseBodySchedulerRulesParam extends $tea.Model {
  paramData?: DescribeSchedulerRulesResponseBodySchedulerRulesParamParamData;
  /**
   * @example
   * GA
   */
  paramType?: string;
  static names(): { [key: string]: string } {
    return {
      paramData: 'ParamData',
      paramType: 'ParamType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      paramData: DescribeSchedulerRulesResponseBodySchedulerRulesParamParamData,
      paramType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSchedulerRulesResponseBodySchedulerRulesRules extends $tea.Model {
  line?: string;
  /**
   * @example
   * 100
   */
  priority?: number;
  /**
   * @example
   * 1
   */
  regionId?: string;
  /**
   * @example
   * 60
   */
  restoreDelay?: number;
  /**
   * @example
   * 0
   */
  status?: number;
  /**
   * @example
   * A
   */
  type?: string;
  /**
   * @example
   * 203.***.***.39
   */
  value?: string;
  /**
   * @example
   * 1
   */
  valueType?: number;
  static names(): { [key: string]: string } {
    return {
      line: 'Line',
      priority: 'Priority',
      regionId: 'RegionId',
      restoreDelay: 'RestoreDelay',
      status: 'Status',
      type: 'Type',
      value: 'Value',
      valueType: 'ValueType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      line: 'string',
      priority: 'number',
      regionId: 'string',
      restoreDelay: 'number',
      status: 'number',
      type: 'string',
      value: 'string',
      valueType: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSchedulerRulesResponseBodySchedulerRules extends $tea.Model {
  /**
   * @example
   * 4eru5229a843****.aliyunddos0001.com
   */
  cname?: string;
  param?: DescribeSchedulerRulesResponseBodySchedulerRulesParam;
  /**
   * @example
   * doctest
   */
  ruleName?: string;
  ruleType?: string;
  rules?: DescribeSchedulerRulesResponseBodySchedulerRulesRules[];
  static names(): { [key: string]: string } {
    return {
      cname: 'Cname',
      param: 'Param',
      ruleName: 'RuleName',
      ruleType: 'RuleType',
      rules: 'Rules',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cname: 'string',
      param: DescribeSchedulerRulesResponseBodySchedulerRulesParam,
      ruleName: 'string',
      ruleType: 'string',
      rules: { 'type': 'array', 'itemType': DescribeSchedulerRulesResponseBodySchedulerRulesRules },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSlaEventListResponseBodySlaEvent extends $tea.Model {
  /**
   * @remarks
   * The end of the time range. Unit: seconds.
   * 
   * @example
   * 1671886740
   */
  endTime?: number;
  /**
   * @remarks
   * The IP address of the instance.
   * 
   * @example
   * 203.107.XX.XX
   */
  ip?: string;
  /**
   * @remarks
   * The region to which the destination IP address belongs. Valid values:
   * 
   * *   **cn**: a region in the Chinese mainland
   * *   **cn-hongkong**: China (Hong Kong)
   * 
   * @example
   * cn
   */
  region?: string;
  /**
   * @remarks
   * The beginning of the time range. Unit: seconds.
   * 
   * @example
   * 1678080840
   */
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      ip: 'Ip',
      region: 'Region',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'number',
      ip: 'string',
      region: 'string',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeStsGrantStatusResponseBodyStsGrant extends $tea.Model {
  /**
   * @remarks
   * The authorization status. Valid values:
   * 
   * *   **0**: Anti-DDoS Pro or Anti-DDoS Premium is not authorized to access other cloud services.
   * *   **1**: Anti-DDoS Pro or Anti-DDoS Premium is authorized to access other cloud services.
   * 
   * @example
   * 1
   */
  status?: number;
  static names(): { [key: string]: string } {
    return {
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSystemLogResponseBodySystemLog extends $tea.Model {
  /**
   * @remarks
   * The IP address of the instance.
   * 
   * @example
   * 203.107.XX.XX
   */
  entityObject?: string;
  /**
   * @remarks
   * The type of the system log. The value is fixed as **20**, which indicates the billing logs for burstable clean bandwidth.
   * 
   * @example
   * 20
   */
  entityType?: number;
  /**
   * @remarks
   * The time when the bill was generated. The value is a UNIX timestamp. Unit: milliseconds.
   * 
   * @example
   * 1631793531000
   */
  gmtCreate?: number;
  /**
   * @remarks
   * The time when the bill was last modified. The value is a UNIX timestamp. Unit: milliseconds.
   * 
   * @example
   * 1635425407000
   */
  gmtModified?: number;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account to which the bill belongs.
   * 
   * @example
   * 171986973287****
   */
  opAccount?: string;
  /**
   * @remarks
   * The operation type. The value is fixed as **100**, which indicates the billing logs for the burstable clean bandwidth that you increased.
   * 
   * @example
   * 100
   */
  opAction?: number;
  /**
   * @remarks
   * The details of the bill. The value is a string that consists of a JSON struct. The JSON struct contains the following fields:
   * 
   * *   **newEntity**: the bill record, which contains the following fields. Data type: object.
   * 
   *     *   **billValue**: the usage of the burstable clean bandwidth within a month. Unit: Mbit/s. Data type: integer.
   *     *   **instanceId**: the ID of the instance. Data type: string.
   *     *   **ip**: the IP address of the instance. Data type: string.
   *     *   **maxBw**: the peak service traffic (monthly 95th percentile bandwidth) within a month. Unit: Mbit/s. Data type: string.
   *     *   **month**: the month in which the bill of the previous calendar month is issued. This value is a UNIX timestamp. Unit: milliseconds. Data type: long.
   *     *   **overBandwidth**: the peak service traffic minus the clean bandwidth of the instance. Unit: Mbit/s. Data type: integer.
   *     *   **peakTime**: the time in point of the peak service traffic that is measured for billing. This value is a UNIX timestamp. Unit: seconds. Data type: long.
   *     *   **startTimestamp**: the beginning of the time range for the peak service traffic range. This value is a UNIX timestamp. Unit: seconds. Data type: long.
   * 
   * @example
   * {"newEntity":{"billValue":"60","instanceId":"ddoscoo-cn-zz121ogz****","ip":"203.107.XX.XX","maxBw":"300","month":1627747200000,"overBandwidth":"120","peakTime":1629871200,"startTimestamp":1629871200}}
   */
  opDesc?: string;
  /**
   * @remarks
   * The status of the bill. Valid values:
   * 
   * *   **0**: to be billed
   * *   **1**: billed
   * *   **2**: terminated
   * 
   * @example
   * 1
   */
  status?: number;
  static names(): { [key: string]: string } {
    return {
      entityObject: 'EntityObject',
      entityType: 'EntityType',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      opAccount: 'OpAccount',
      opAction: 'OpAction',
      opDesc: 'OpDesc',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      entityObject: 'string',
      entityType: 'number',
      gmtCreate: 'number',
      gmtModified: 'number',
      opAccount: 'string',
      opAction: 'number',
      opDesc: 'string',
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTagKeysResponseBodyTagKeys extends $tea.Model {
  /**
   * @remarks
   * The number of Anti-DDoS Proxy (Chinese Mainland) instances to which the tag key is added.
   * 
   * @example
   * 2
   */
  tagCount?: number;
  /**
   * @remarks
   * The tag key.
   * 
   * @example
   * aa1
   */
  tagKey?: string;
  static names(): { [key: string]: string } {
    return {
      tagCount: 'TagCount',
      tagKey: 'TagKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagCount: 'number',
      tagKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTagResourcesRequestTags extends $tea.Model {
  /**
   * @remarks
   * The key of the tag that you want to query.
   * 
   * > 
   * 
   * *   You must specify at least one of the **ResourceIds.N** and **Tags.N.Key** parameters.
   * 
   * *   You can call the [DescribeTagKeys](https://help.aliyun.com/document_detail/159785.html) operation to query all tag keys.
   * 
   * @example
   * testkey
   */
  key?: string;
  /**
   * @remarks
   * The value of the tag that you want to query.
   * 
   * @example
   * testvalue
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTagResourcesResponseBodyTagResourcesTagResource extends $tea.Model {
  /**
   * @remarks
   * The ID of the Anti-DDoS Proxy (Chinese Mainland) instance.
   * 
   * @example
   * ddoscoo-cn-zz121ogz****
   */
  resourceId?: string;
  /**
   * @remarks
   * The resource type. The value is fixed as **INSTANCE**, which indicates an Anti-DDoS Proxy instance.
   * 
   * @example
   * INSTANCE
   */
  resourceType?: string;
  /**
   * @remarks
   * The key of the tag that is added to the Anti-DDoS Proxy (Chinese Mainland) instance.
   * 
   * @example
   * testvalue
   */
  tagKey?: string;
  /**
   * @remarks
   * The value of the tag that is added to the Anti-DDoS Proxy (Chinese Mainland) instance.
   * 
   * @example
   * testkey
   */
  tagValue?: string;
  static names(): { [key: string]: string } {
    return {
      resourceId: 'ResourceId',
      resourceType: 'ResourceType',
      tagKey: 'TagKey',
      tagValue: 'TagValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resourceId: 'string',
      resourceType: 'string',
      tagKey: 'string',
      tagValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTagResourcesResponseBodyTagResources extends $tea.Model {
  tagResource?: DescribeTagResourcesResponseBodyTagResourcesTagResource[];
  static names(): { [key: string]: string } {
    return {
      tagResource: 'TagResource',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagResource: { 'type': 'array', 'itemType': DescribeTagResourcesResponseBodyTagResourcesTagResource },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebAccessLogDispatchStatusResponseBodySlsConfigStatus extends $tea.Model {
  /**
   * @remarks
   * The domain name.
   * 
   * @example
   * www.aliyundoc.com
   */
  domain?: string;
  /**
   * @remarks
   * Indicates whether the log analysis feature is enabled. Valid values:
   * 
   * *   **true**: yes
   * *   **false**: no
   * 
   * @example
   * true
   */
  enable?: boolean;
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
      enable: 'Enable',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
      enable: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebAccessModeResponseBodyDomainModes extends $tea.Model {
  /**
   * @remarks
   * The mode in which the website service is added. Valid values:
   * 
   * *   **0**: A record
   * *   **1**: anti-DDoS mode
   * *   **2**: origin redundancy mode
   * 
   * @example
   * 0
   */
  accessMode?: number;
  /**
   * @remarks
   * The domain name of the website.
   * 
   * @example
   * www.aliyun.com
   */
  domain?: string;
  static names(): { [key: string]: string } {
    return {
      accessMode: 'AccessMode',
      domain: 'Domain',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessMode: 'number',
      domain: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebAreaBlockConfigsResponseBodyAreaBlockConfigsRegionList extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the location is blocked. Valid values:
   * 
   * *   **0**: yes
   * *   **1**: no
   * 
   * @example
   * 0
   */
  block?: number;
  /**
   * @remarks
   * The name of the location.
   * 
   * @example
   * CN-SHANGHAI
   */
  region?: string;
  static names(): { [key: string]: string } {
    return {
      block: 'Block',
      region: 'Region',
    };
  }

  static types(): { [key: string]: any } {
    return {
      block: 'number',
      region: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebAreaBlockConfigsResponseBodyAreaBlockConfigs extends $tea.Model {
  /**
   * @remarks
   * The domain name of the website.
   * 
   * @example
   * www.aliyun.com
   */
  domain?: string;
  /**
   * @remarks
   * The configuration of the blocked locations.
   */
  regionList?: DescribeWebAreaBlockConfigsResponseBodyAreaBlockConfigsRegionList[];
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
      regionList: 'RegionList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
      regionList: { 'type': 'array', 'itemType': DescribeWebAreaBlockConfigsResponseBodyAreaBlockConfigsRegionList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebCCRulesResponseBodyWebCCRules extends $tea.Model {
  /**
   * @remarks
   * The blocking type. Valid values:
   * 
   * *   **close**: blocks requests.
   * *   **captcha**: enables Completely Automated Public Turing test to tell Computers and Humans Apart (CAPTCHA) verification.
   * 
   * @example
   * close
   */
  act?: string;
  /**
   * @remarks
   * The number of requests that are allowed from an individual IP address. Valid values: **2** to **2000**.
   * 
   * @example
   * 3
   */
  count?: number;
  /**
   * @remarks
   * The check intervals. Valid values: **5** to **10800**. Unit: seconds.
   * 
   * @example
   * 5
   */
  interval?: number;
  /**
   * @remarks
   * The match mode. Valid values:
   * 
   * *   **prefix**: prefix match
   * *   **match**: exact match
   * 
   * @example
   * prefix
   */
  mode?: string;
  /**
   * @remarks
   * The name of the rule.
   * 
   * @example
   * wq
   */
  name?: string;
  /**
   * @remarks
   * The blocking duration. Valid values: **1** to **1440**. Unit: minutes.
   * 
   * @example
   * 60
   */
  ttl?: number;
  /**
   * @remarks
   * The check path.
   * 
   * @example
   * /hello
   */
  uri?: string;
  static names(): { [key: string]: string } {
    return {
      act: 'Act',
      count: 'Count',
      interval: 'Interval',
      mode: 'Mode',
      name: 'Name',
      ttl: 'Ttl',
      uri: 'Uri',
    };
  }

  static types(): { [key: string]: any } {
    return {
      act: 'string',
      count: 'number',
      interval: 'number',
      mode: 'string',
      name: 'string',
      ttl: 'number',
      uri: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebCCRulesV2ResponseBodyWebCCRulesRuleDetailCondition extends $tea.Model {
  /**
   * @remarks
   * The match content.
   * 
   * @example
   * 192.0.XX.XX
   */
  content?: string;
  contentList?: string;
  /**
   * @remarks
   * The match field.
   * 
   * @example
   * ip
   */
  field?: string;
  /**
   * @remarks
   * The custom HTTP request header.
   * 
   * >  This parameter takes effect only when **Field** is set to **header**.
   * 
   * @example
   * null
   */
  headerName?: string;
  /**
   * @remarks
   * The match method.
   * 
   * @example
   * belong
   */
  matchMethod?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      contentList: 'ContentList',
      field: 'Field',
      headerName: 'HeaderName',
      matchMethod: 'MatchMethod',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      contentList: 'string',
      field: 'string',
      headerName: 'string',
      matchMethod: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebCCRulesV2ResponseBodyWebCCRulesRuleDetailRateLimit extends $tea.Model {
  /**
   * @remarks
   * The statistical period. Unit: seconds.
   * 
   * @example
   * 60
   */
  interval?: number;
  /**
   * @remarks
   * The name of the field. This parameter is required only when the Target parameter is set to header.
   * 
   * @example
   * action
   */
  subKey?: string;
  /**
   * @remarks
   * The statistical method. Valid values:
   * 
   * *   **ip**
   * *   **header**
   * 
   * @example
   * ip
   */
  target?: string;
  /**
   * @remarks
   * The trigger threshold.
   * 
   * @example
   * 20
   */
  threshold?: number;
  /**
   * @remarks
   * The blocking duration. Unit: seconds.
   * 
   * @example
   * 15
   */
  ttl?: number;
  static names(): { [key: string]: string } {
    return {
      interval: 'Interval',
      subKey: 'SubKey',
      target: 'Target',
      threshold: 'Threshold',
      ttl: 'Ttl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      interval: 'number',
      subKey: 'string',
      target: 'string',
      threshold: 'number',
      ttl: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebCCRulesV2ResponseBodyWebCCRulesRuleDetailStatistics extends $tea.Model {
  /**
   * @remarks
   * The statistical method. Valid values:
   * 
   * *   **ip**
   * *   **header**
   * *   **uri**
   * 
   * @example
   * uri
   */
  field?: string;
  /**
   * @remarks
   * The name of the header. This parameter is required only when the Field parameter is set to header.
   * 
   * @example
   * hello
   */
  headerName?: string;
  /**
   * @remarks
   * Indicates whether the system collects statistics after deduplication. Valid values:
   * 
   * *   **count**: The system collects statistics before deduplication.
   * *   **distinct**: The system collects statistics after deduplication.
   * 
   * @example
   * count
   */
  mode?: string;
  static names(): { [key: string]: string } {
    return {
      field: 'Field',
      headerName: 'HeaderName',
      mode: 'Mode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      field: 'string',
      headerName: 'string',
      mode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebCCRulesV2ResponseBodyWebCCRulesRuleDetailStatusCode extends $tea.Model {
  /**
   * @remarks
   * The status code. Valid values: **100** to **599**.
   * 
   * *   **200**: The request was successful.
   * *   Other codes: The request failed.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * If a ratio is not used, the handling action is triggered only when the number of requests of the corresponding status code reaches the value of **CountThreshold**. Valid values: **2** to **50000**.
   * 
   * @example
   * 10
   */
  countThreshold?: number;
  /**
   * @remarks
   * Indicates whether the status code is enabled. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * true
   */
  enabled?: boolean;
  /**
   * @remarks
   * If a ratio is used, the handling action is triggered only when the number of requests of the corresponding status code reaches the value of **RatioThreshold**. Valid values: **1** to **100**.
   * 
   * @example
   * 10
   */
  ratioThreshold?: number;
  /**
   * @remarks
   * Indicates whether to use a ratio.
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * true
   */
  useRatio?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      countThreshold: 'CountThreshold',
      enabled: 'Enabled',
      ratioThreshold: 'RatioThreshold',
      useRatio: 'UseRatio',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      countThreshold: 'number',
      enabled: 'boolean',
      ratioThreshold: 'number',
      useRatio: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebCCRulesV2ResponseBodyWebCCRulesRuleDetail extends $tea.Model {
  /**
   * @remarks
   * The action triggered if the rule is matched. Valid values:
   * 
   * *   **accept**: The requests that match the rule are allowed.
   * *   **block**: The requests that match the rule are blocked.
   * *   **challenge**: Completely Automated Public Turing test to tell Computers and Humans Apart (CAPTCHA) verification for the requests that match the rule is implemented.
   * *   **watch**: The requests that match the rule are recorded in logs and allowed.
   * 
   * @example
   * block
   */
  action?: string;
  /**
   * @remarks
   * The match conditions.
   */
  condition?: DescribeWebCCRulesV2ResponseBodyWebCCRulesRuleDetailCondition[];
  /**
   * @remarks
   * The parameter is deprecated.
   */
  count?: number;
  /**
   * @remarks
   * The parameter is deprecated.
   * 
   * @example
   * 60
   */
  interval?: number;
  /**
   * @remarks
   * The parameter is deprecated.
   */
  mode?: string;
  /**
   * @remarks
   * The name of the rule.
   * 
   * @example
   * ccauto14
   */
  name?: string;
  /**
   * @remarks
   * The frequency statistics.
   */
  rateLimit?: DescribeWebCCRulesV2ResponseBodyWebCCRulesRuleDetailRateLimit;
  /**
   * @remarks
   * The statistics after deduplication. By default, the system collects statistics before deduplication.
   */
  statistics?: DescribeWebCCRulesV2ResponseBodyWebCCRulesRuleDetailStatistics;
  /**
   * @remarks
   * The status codes.
   */
  statusCode?: DescribeWebCCRulesV2ResponseBodyWebCCRulesRuleDetailStatusCode;
  /**
   * @remarks
   * The parameter is deprecated.
   * 
   * @example
   * 300
   */
  ttl?: number;
  /**
   * @remarks
   * The parameter is deprecated.
   * 
   * @example
   * /p3shijihao
   */
  uri?: string;
  static names(): { [key: string]: string } {
    return {
      action: 'Action',
      condition: 'Condition',
      count: 'Count',
      interval: 'Interval',
      mode: 'Mode',
      name: 'Name',
      rateLimit: 'RateLimit',
      statistics: 'Statistics',
      statusCode: 'StatusCode',
      ttl: 'Ttl',
      uri: 'Uri',
    };
  }

  static types(): { [key: string]: any } {
    return {
      action: 'string',
      condition: { 'type': 'array', 'itemType': DescribeWebCCRulesV2ResponseBodyWebCCRulesRuleDetailCondition },
      count: 'number',
      interval: 'number',
      mode: 'string',
      name: 'string',
      rateLimit: DescribeWebCCRulesV2ResponseBodyWebCCRulesRuleDetailRateLimit,
      statistics: DescribeWebCCRulesV2ResponseBodyWebCCRulesRuleDetailStatistics,
      statusCode: DescribeWebCCRulesV2ResponseBodyWebCCRulesRuleDetailStatusCode,
      ttl: 'number',
      uri: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebCCRulesV2ResponseBodyWebCCRules extends $tea.Model {
  /**
   * @remarks
   * The validity period of the rule. Unit: seconds. If the Action parameter is set to block, the system blocks the requests that match the rule within the validity period of the rule. The value 0 indicates that the rule is permanently valid.
   * 
   * @example
   * 0
   */
  expires?: number;
  /**
   * @remarks
   * The name of the rule.
   * 
   * @example
   * wq
   */
  name?: string;
  /**
   * @remarks
   * The method used to create the rule. Valid values:
   * 
   * *   **manual** (default): manually created.
   * *   **clover**: automatically created.
   * 
   * @example
   * manual
   */
  owner?: string;
  /**
   * @remarks
   * The details of the rule.
   */
  ruleDetail?: DescribeWebCCRulesV2ResponseBodyWebCCRulesRuleDetail;
  static names(): { [key: string]: string } {
    return {
      expires: 'Expires',
      name: 'Name',
      owner: 'Owner',
      ruleDetail: 'RuleDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      expires: 'number',
      name: 'string',
      owner: 'string',
      ruleDetail: DescribeWebCCRulesV2ResponseBodyWebCCRulesRuleDetail,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebCacheConfigsResponseBodyDomainCacheConfigsCustomRules extends $tea.Model {
  /**
   * @remarks
   * The expiration time of the page cache. Unit: seconds.
   * 
   * @example
   * 86400
   */
  cacheTtl?: number;
  /**
   * @remarks
   * The cache mode. Valid values:
   * 
   * *   **standard**: The standard cache mode is used.
   * *   **aggressive**: The enhanced cache mode is used.
   * *   **bypass**: No data is cached.
   * 
   * @example
   * standard
   */
  mode?: string;
  /**
   * @remarks
   * The name of the rule.
   * 
   * @example
   * c1
   */
  name?: string;
  /**
   * @remarks
   * The path to the cached page.
   * 
   * @example
   * /blog/
   */
  uri?: string;
  static names(): { [key: string]: string } {
    return {
      cacheTtl: 'CacheTtl',
      mode: 'Mode',
      name: 'Name',
      uri: 'Uri',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cacheTtl: 'number',
      mode: 'string',
      name: 'string',
      uri: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebCacheConfigsResponseBodyDomainCacheConfigs extends $tea.Model {
  /**
   * @remarks
   * An array that consists of custom caching rules.
   */
  customRules?: DescribeWebCacheConfigsResponseBodyDomainCacheConfigsCustomRules[];
  /**
   * @remarks
   * The domain name of the website.
   * 
   * @example
   * www.aliyundoc.com
   */
  domain?: string;
  /**
   * @remarks
   * The status of the Static Page Caching policy. Valid values:
   * 
   * *   **1**: enabled
   * *   **0**: disabled
   * 
   * @example
   * 1
   */
  enable?: number;
  /**
   * @remarks
   * The cache mode. Valid values:
   * 
   * *   **standard**: The standard cache mode is used.
   * *   **aggressive**: The enhanced cache mode is used.
   * *   **bypass**: No data is cached.
   * 
   * @example
   * bypass
   */
  mode?: string;
  static names(): { [key: string]: string } {
    return {
      customRules: 'CustomRules',
      domain: 'Domain',
      enable: 'Enable',
      mode: 'Mode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      customRules: { 'type': 'array', 'itemType': DescribeWebCacheConfigsResponseBodyDomainCacheConfigsCustomRules },
      domain: 'string',
      enable: 'number',
      mode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebCcProtectSwitchResponseBodyProtectSwitchList extends $tea.Model {
  /**
   * @remarks
   * The mode of Intelligent Protection. Valid values:
   * 
   * *   **watch**: Warning
   * *   **defense**: Defense
   * 
   * @example
   * defense
   */
  aiMode?: string;
  /**
   * @remarks
   * The status of Intelligent Protection. Valid values:
   * 
   * *   **0**: turned off
   * *   **1:** turned on
   * 
   * @example
   * 1
   */
  aiRuleEnable?: number;
  /**
   * @remarks
   * The level of Intelligent Protection. Valid values:
   * 
   * *   **level30**: Loose
   * *   **level60**: Normal
   * *   **level90**: Strict
   * 
   * @example
   * level60
   */
  aiTemplate?: string;
  /**
   * @remarks
   * The status of Blacklist/Whitelist (Domain Names). Valid values:
   * 
   * *   **0**: turned off
   * *   **1:** turned on
   * 
   * @example
   * 1
   */
  blackWhiteListEnable?: number;
  /**
   * @remarks
   * The status of the Custom Rules switch for Frequency Control. Valid values:
   * 
   * *   **0**: turned off
   * *   **1:** turned on
   * 
   * @example
   * 0
   */
  ccCustomRuleEnable?: number;
  /**
   * @remarks
   * The status of Frequency Control. Valid values:
   * 
   * *   **0**: turned off
   * *   **1:** turned on
   * 
   * @example
   * 1
   */
  ccEnable?: number;
  ccGlobalSwitch?: string;
  /**
   * @remarks
   * The mode of Frequency Control. Valid values:
   * 
   * *   **default**: Normal
   * *   **gf_under_attack**: Emergency
   * *   **gf_sos_verify**: Strict
   * *   **gf_sos_enhance**: Super Strict
   * 
   * @example
   * default
   */
  ccTemplate?: string;
  /**
   * @remarks
   * The domain name of the website.
   * 
   * @example
   * www.aliyun.com
   */
  domain?: string;
  /**
   * @remarks
   * The status of Accurate Access Control. Valid values:
   * 
   * *   **0**: turned off
   * *   **1:** turned on
   * 
   * @example
   * 0
   */
  preciseRuleEnable?: number;
  /**
   * @remarks
   * The status of Location Blacklist (Domain Names). Valid values:
   * 
   * *   **0**: turned off
   * *   **1:** turned on
   * 
   * @example
   * 0
   */
  regionBlockEnable?: number;
  static names(): { [key: string]: string } {
    return {
      aiMode: 'AiMode',
      aiRuleEnable: 'AiRuleEnable',
      aiTemplate: 'AiTemplate',
      blackWhiteListEnable: 'BlackWhiteListEnable',
      ccCustomRuleEnable: 'CcCustomRuleEnable',
      ccEnable: 'CcEnable',
      ccGlobalSwitch: 'CcGlobalSwitch',
      ccTemplate: 'CcTemplate',
      domain: 'Domain',
      preciseRuleEnable: 'PreciseRuleEnable',
      regionBlockEnable: 'RegionBlockEnable',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aiMode: 'string',
      aiRuleEnable: 'number',
      aiTemplate: 'string',
      blackWhiteListEnable: 'number',
      ccCustomRuleEnable: 'number',
      ccEnable: 'number',
      ccGlobalSwitch: 'string',
      ccTemplate: 'string',
      domain: 'string',
      preciseRuleEnable: 'number',
      regionBlockEnable: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebCustomPortsResponseBodyWebCustomPorts extends $tea.Model {
  /**
   * @remarks
   * An array that consists of supported custom ports.
   */
  proxyPorts?: string[];
  /**
   * @remarks
   * The type of the protocol. Valid values:
   * 
   * *   **http**
   * *   **https**
   * 
   * @example
   * http
   */
  proxyType?: string;
  static names(): { [key: string]: string } {
    return {
      proxyPorts: 'ProxyPorts',
      proxyType: 'ProxyType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      proxyPorts: { 'type': 'array', 'itemType': 'string' },
      proxyType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebInstanceRelationsResponseBodyWebInstanceRelationsInstanceDetails extends $tea.Model {
  /**
   * @remarks
   * The IP addresses of the instance.
   */
  eipList?: string[];
  /**
   * @remarks
   * The function plan of the instance. Valid values:
   * 
   * *   **default**: Standard function plan
   * *   **enhance**: Enhanced function plan
   * 
   * @example
   * enhance
   */
  functionVersion?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * ddoscoo-cn-0pp163pd****
   */
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      eipList: 'EipList',
      functionVersion: 'FunctionVersion',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      eipList: { 'type': 'array', 'itemType': 'string' },
      functionVersion: 'string',
      instanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebInstanceRelationsResponseBodyWebInstanceRelations extends $tea.Model {
  /**
   * @remarks
   * The domain name of the website.
   * 
   * @example
   * www.aliyun.com
   */
  domain?: string;
  /**
   * @remarks
   * The information about the instance to which a website service is added.
   */
  instanceDetails?: DescribeWebInstanceRelationsResponseBodyWebInstanceRelationsInstanceDetails[];
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
      instanceDetails: 'InstanceDetails',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
      instanceDetails: { 'type': 'array', 'itemType': DescribeWebInstanceRelationsResponseBodyWebInstanceRelationsInstanceDetails },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebPreciseAccessRuleResponseBodyPreciseAccessConfigListRuleListConditionList extends $tea.Model {
  /**
   * @remarks
   * The match content.
   * 
   * @example
   * 1.1.1.1
   */
  content?: string;
  contentList?: string[];
  /**
   * @remarks
   * The match field.
   * 
   * @example
   * ip
   */
  field?: string;
  /**
   * @remarks
   * The custom HTTP request header.
   * 
   * >  This parameter takes effect only when **Field** is set to **header**.
   * 
   * @example
   * null
   */
  headerName?: string;
  /**
   * @remarks
   * The logical operator.
   * 
   * @example
   * belong
   */
  matchMethod?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      contentList: 'ContentList',
      field: 'Field',
      headerName: 'HeaderName',
      matchMethod: 'MatchMethod',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      contentList: { 'type': 'array', 'itemType': 'string' },
      field: 'string',
      headerName: 'string',
      matchMethod: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebPreciseAccessRuleResponseBodyPreciseAccessConfigListRuleList extends $tea.Model {
  /**
   * @remarks
   * The action triggered if the rule is matched. Valid values:
   * 
   * *   **accept**: The requests that match the rule are allowed.
   * *   **block**: The requests that match the rule are blocked.
   * *   **challenge**: Completely Automated Public Turing test to tell Computers and Humans Apart (CAPTCHA) verification for the requests that match the rule is implemented.
   * 
   * @example
   * accept
   */
  action?: string;
  /**
   * @remarks
   * The match conditions.
   */
  conditionList?: DescribeWebPreciseAccessRuleResponseBodyPreciseAccessConfigListRuleListConditionList[];
  /**
   * @remarks
   * The validity period of the rule. Unit: seconds. This parameter takes effect only when **action** of a rule is **block**. Access requests that match the rule are blocked within the specified validity period of the rule. The value **0** indicates that the whitelist takes effect all the time.
   * 
   * @example
   * 0
   */
  expires?: number;
  /**
   * @remarks
   * The name of the scheduling rule.
   * 
   * @example
   * testrule
   */
  name?: string;
  /**
   * @remarks
   * The source of the rule. Valid values:
   * 
   * *   **manual** (default): manually created.
   * *   **auto**: automatically generated.
   * 
   * @example
   * manual
   */
  owner?: string;
  static names(): { [key: string]: string } {
    return {
      action: 'Action',
      conditionList: 'ConditionList',
      expires: 'Expires',
      name: 'Name',
      owner: 'Owner',
    };
  }

  static types(): { [key: string]: any } {
    return {
      action: 'string',
      conditionList: { 'type': 'array', 'itemType': DescribeWebPreciseAccessRuleResponseBodyPreciseAccessConfigListRuleListConditionList },
      expires: 'number',
      name: 'string',
      owner: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebPreciseAccessRuleResponseBodyPreciseAccessConfigList extends $tea.Model {
  /**
   * @remarks
   * The domain name of the website.
   * 
   * @example
   * www.aliyun.com
   */
  domain?: string;
  /**
   * @remarks
   * The scheduling rules.
   */
  ruleList?: DescribeWebPreciseAccessRuleResponseBodyPreciseAccessConfigListRuleList[];
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
      ruleList: 'RuleList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
      ruleList: { 'type': 'array', 'itemType': DescribeWebPreciseAccessRuleResponseBodyPreciseAccessConfigListRuleList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebReportTopIpResponseBodyDataList extends $tea.Model {
  /**
   * @remarks
   * The ID of the location.
   * 
   * @example
   * 90998690
   */
  areaId?: string;
  /**
   * @remarks
   * The number of entries returned.
   * 
   * @example
   * 5
   */
  count?: number;
  /**
   * @remarks
   * The Internet service provider (ISP) for the attack. Valid values:
   * 
   * *   **100017**: China Telecom
   * *   **100026**: China Unicom
   * *   **100025**: China Mobile
   * *   **100027**: China Education and Research Network
   * *   **100020**: China Mobile Tietong
   * *   **1000143**: Dr.Peng Telecom & Media Group
   * *   **100080**: Beijing Gehua CATV Network
   * *   **1000139**: National Radio and Television Administration
   * *   **100023**: Oriental Cable Network
   * *   **100063**: Founder Broadband
   * *   **1000337**: China Internet Exchange
   * *   **100021**: 21Vianet Group
   * *   **1000333**: Wasu Media Holding
   * *   **100093**: Wangsu Science & Technology
   * *   **1000401**: Tencent
   * *   **100099**: Baidu
   * *   **1000323**: Alibaba Cloud
   * *   **100098**: Alibaba
   * 
   * @example
   * 100017
   */
  isp?: string;
  /**
   * @remarks
   * The source IP address.
   * 
   * @example
   * 117.186.XX.XX
   */
  sourceIp?: string;
  static names(): { [key: string]: string } {
    return {
      areaId: 'AreaId',
      count: 'Count',
      isp: 'Isp',
      sourceIp: 'SourceIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      areaId: 'string',
      count: 'number',
      isp: 'string',
      sourceIp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebRulesResponseBodyWebRulesGmCert extends $tea.Model {
  /**
   * @example
   * 725****
   */
  certId?: string;
  /**
   * @example
   * 1
   */
  gmEnable?: number;
  /**
   * @example
   * 1
   */
  gmOnly?: number;
  static names(): { [key: string]: string } {
    return {
      certId: 'CertId',
      gmEnable: 'GmEnable',
      gmOnly: 'GmOnly',
    };
  }

  static types(): { [key: string]: any } {
    return {
      certId: 'string',
      gmEnable: 'number',
      gmOnly: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebRulesResponseBodyWebRulesProxyTypes extends $tea.Model {
  proxyPorts?: string[];
  /**
   * @example
   * https
   */
  proxyType?: string;
  static names(): { [key: string]: string } {
    return {
      proxyPorts: 'ProxyPorts',
      proxyType: 'ProxyType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      proxyPorts: { 'type': 'array', 'itemType': 'string' },
      proxyType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebRulesResponseBodyWebRulesRealServers extends $tea.Model {
  /**
   * @example
   * 192.0.XX.XX
   */
  realServer?: string;
  /**
   * @example
   * 0
   */
  rsType?: number;
  static names(): { [key: string]: string } {
    return {
      realServer: 'RealServer',
      rsType: 'RsType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      realServer: 'string',
      rsType: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebRulesResponseBodyWebRules extends $tea.Model {
  blackList?: string[];
  /**
   * @example
   * true
   */
  ccEnabled?: boolean;
  /**
   * @example
   * false
   */
  ccRuleEnabled?: boolean;
  /**
   * @example
   * default
   */
  ccTemplate?: string;
  /**
   * @example
   * testcert
   */
  certName?: string;
  certRegion?: string;
  /**
   * @example
   * kzmk7b8tt351****.aliyunddos1014****
   */
  cname?: string;
  customCiphers?: string[];
  /**
   * @example
   * example.com
   */
  domain?: string;
  gmCert?: DescribeWebRulesResponseBodyWebRulesGmCert;
  /**
   * @example
   * true
   */
  http2Enable?: boolean;
  /**
   * @example
   * true
   */
  http2HttpsEnable?: boolean;
  /**
   * @example
   * true
   */
  https2HttpEnable?: boolean;
  /**
   * @example
   * false
   */
  ocspEnabled?: boolean;
  /**
   * @example
   * ip_hash
   */
  policyMode?: string;
  /**
   * @example
   * true
   */
  proxyEnabled?: boolean;
  proxyTypes?: DescribeWebRulesResponseBodyWebRulesProxyTypes[];
  /**
   * @example
   * 1
   */
  punishReason?: number;
  /**
   * @example
   * true
   */
  punishStatus?: boolean;
  realServers?: DescribeWebRulesResponseBodyWebRulesRealServers[];
  /**
   * @example
   * false
   */
  ssl13Enabled?: boolean;
  /**
   * @example
   * default
   */
  sslCiphers?: string;
  /**
   * @example
   * tls1.1
   */
  sslProtocols?: string;
  whiteList?: string[];
  static names(): { [key: string]: string } {
    return {
      blackList: 'BlackList',
      ccEnabled: 'CcEnabled',
      ccRuleEnabled: 'CcRuleEnabled',
      ccTemplate: 'CcTemplate',
      certName: 'CertName',
      certRegion: 'CertRegion',
      cname: 'Cname',
      customCiphers: 'CustomCiphers',
      domain: 'Domain',
      gmCert: 'GmCert',
      http2Enable: 'Http2Enable',
      http2HttpsEnable: 'Http2HttpsEnable',
      https2HttpEnable: 'Https2HttpEnable',
      ocspEnabled: 'OcspEnabled',
      policyMode: 'PolicyMode',
      proxyEnabled: 'ProxyEnabled',
      proxyTypes: 'ProxyTypes',
      punishReason: 'PunishReason',
      punishStatus: 'PunishStatus',
      realServers: 'RealServers',
      ssl13Enabled: 'Ssl13Enabled',
      sslCiphers: 'SslCiphers',
      sslProtocols: 'SslProtocols',
      whiteList: 'WhiteList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      blackList: { 'type': 'array', 'itemType': 'string' },
      ccEnabled: 'boolean',
      ccRuleEnabled: 'boolean',
      ccTemplate: 'string',
      certName: 'string',
      certRegion: 'string',
      cname: 'string',
      customCiphers: { 'type': 'array', 'itemType': 'string' },
      domain: 'string',
      gmCert: DescribeWebRulesResponseBodyWebRulesGmCert,
      http2Enable: 'boolean',
      http2HttpsEnable: 'boolean',
      https2HttpEnable: 'boolean',
      ocspEnabled: 'boolean',
      policyMode: 'string',
      proxyEnabled: 'boolean',
      proxyTypes: { 'type': 'array', 'itemType': DescribeWebRulesResponseBodyWebRulesProxyTypes },
      punishReason: 'number',
      punishStatus: 'boolean',
      realServers: { 'type': 'array', 'itemType': DescribeWebRulesResponseBodyWebRulesRealServers },
      ssl13Enabled: 'boolean',
      sslCiphers: 'string',
      sslProtocols: 'string',
      whiteList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDomainResourceRequestProxyTypes extends $tea.Model {
  /**
   * @remarks
   * The port numbers.
   * 
   * This parameter is required.
   */
  proxyPorts?: number[];
  /**
   * @remarks
   * The type of the protocol. Valid values:
   * 
   * *   **http**
   * *   **https**
   * *   **websocket**
   * *   **websockets**
   * 
   * @example
   * https
   */
  proxyType?: string;
  static names(): { [key: string]: string } {
    return {
      proxyPorts: 'ProxyPorts',
      proxyType: 'ProxyType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      proxyPorts: { 'type': 'array', 'itemType': 'number' },
      proxyType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}


export default class Client extends OpenApi {

  constructor(config: $OpenApi.Config) {
    super(config);
    this._endpointRule = "regional";
    this.checkConfig(config);
    this._endpoint = this.getEndpoint("ddoscoo", this._regionId, this._endpointRule, this._network, this._suffix, this._endpointMap, this._endpoint);
  }


  getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: {[key: string ]: string}, endpoint: string): string {
    if (!Util.empty(endpoint)) {
      return endpoint;
    }

    if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
      return endpointMap[regionId];
    }

    return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
  }

  /**
   * @param request - AddAutoCcBlacklistRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AddAutoCcBlacklistResponse
   */
  async addAutoCcBlacklistWithOptions(request: AddAutoCcBlacklistRequest, runtime: $Util.RuntimeOptions): Promise<AddAutoCcBlacklistResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.blacklist)) {
      query["Blacklist"] = request.blacklist;
    }

    if (!Util.isUnset(request.expireTime)) {
      query["ExpireTime"] = request.expireTime;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddAutoCcBlacklist",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddAutoCcBlacklistResponse>(await this.callApi(params, req, runtime), new AddAutoCcBlacklistResponse({}));
  }

  /**
   * @param request - AddAutoCcBlacklistRequest
   * @returns AddAutoCcBlacklistResponse
   */
  async addAutoCcBlacklist(request: AddAutoCcBlacklistRequest): Promise<AddAutoCcBlacklistResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addAutoCcBlacklistWithOptions(request, runtime);
  }

  /**
   * Adds IP addresses to the IP address whitelist of an Anti-DDoS Pro or Anti-DDoS Premium instance.
   * 
   * @remarks
   * You can call the AddAutoCcWhitelist operation to add IP addresses to the whitelist of an Anti-DDoS Pro or Anti-DDoS Premium instance. This way, the Anti-DDoS Pro or Anti-DDoS Premium instance allows traffic from the IP addresses.
   * By default, the traffic from the IP addresses that you add to the whitelist is always allowed. If you no longer use the whitelist, you can call the [EmptyAutoCcWhitelist](https://help.aliyun.com/document_detail/157505.html) operation to remove the IP addresses from the whitelist.
   * ### Limits
   * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
   * 
   * @param request - AddAutoCcWhitelistRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AddAutoCcWhitelistResponse
   */
  async addAutoCcWhitelistWithOptions(request: AddAutoCcWhitelistRequest, runtime: $Util.RuntimeOptions): Promise<AddAutoCcWhitelistResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.expireTime)) {
      query["ExpireTime"] = request.expireTime;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.whitelist)) {
      query["Whitelist"] = request.whitelist;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddAutoCcWhitelist",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddAutoCcWhitelistResponse>(await this.callApi(params, req, runtime), new AddAutoCcWhitelistResponse({}));
  }

  /**
   * Adds IP addresses to the IP address whitelist of an Anti-DDoS Pro or Anti-DDoS Premium instance.
   * 
   * @remarks
   * You can call the AddAutoCcWhitelist operation to add IP addresses to the whitelist of an Anti-DDoS Pro or Anti-DDoS Premium instance. This way, the Anti-DDoS Pro or Anti-DDoS Premium instance allows traffic from the IP addresses.
   * By default, the traffic from the IP addresses that you add to the whitelist is always allowed. If you no longer use the whitelist, you can call the [EmptyAutoCcWhitelist](https://help.aliyun.com/document_detail/157505.html) operation to remove the IP addresses from the whitelist.
   * ### Limits
   * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
   * 
   * @param request - AddAutoCcWhitelistRequest
   * @returns AddAutoCcWhitelistResponse
   */
  async addAutoCcWhitelist(request: AddAutoCcWhitelistRequest): Promise<AddAutoCcWhitelistResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addAutoCcWhitelistWithOptions(request, runtime);
  }

  /**
   * Associates an SSL certificate with the forwarding rule of a website.
   * 
   * @param request - AssociateWebCertRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AssociateWebCertResponse
   */
  async associateWebCertWithOptions(request: AssociateWebCertRequest, runtime: $Util.RuntimeOptions): Promise<AssociateWebCertResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.cert)) {
      body["Cert"] = request.cert;
    }

    if (!Util.isUnset(request.certId)) {
      body["CertId"] = request.certId;
    }

    if (!Util.isUnset(request.certIdentifier)) {
      body["CertIdentifier"] = request.certIdentifier;
    }

    if (!Util.isUnset(request.certName)) {
      body["CertName"] = request.certName;
    }

    if (!Util.isUnset(request.certRegion)) {
      body["CertRegion"] = request.certRegion;
    }

    if (!Util.isUnset(request.domain)) {
      body["Domain"] = request.domain;
    }

    if (!Util.isUnset(request.key)) {
      body["Key"] = request.key;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "AssociateWebCert",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AssociateWebCertResponse>(await this.callApi(params, req, runtime), new AssociateWebCertResponse({}));
  }

  /**
   * Associates an SSL certificate with the forwarding rule of a website.
   * 
   * @param request - AssociateWebCertRequest
   * @returns AssociateWebCertResponse
   */
  async associateWebCert(request: AssociateWebCertRequest): Promise<AssociateWebCertResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.associateWebCertWithOptions(request, runtime);
  }

  /**
   * Adds an object to a scenario-specific custom policy for protection.
   * 
   * @param request - AttachSceneDefenseObjectRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AttachSceneDefenseObjectResponse
   */
  async attachSceneDefenseObjectWithOptions(request: AttachSceneDefenseObjectRequest, runtime: $Util.RuntimeOptions): Promise<AttachSceneDefenseObjectResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.objectType)) {
      query["ObjectType"] = request.objectType;
    }

    if (!Util.isUnset(request.objects)) {
      query["Objects"] = request.objects;
    }

    if (!Util.isUnset(request.policyId)) {
      query["PolicyId"] = request.policyId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AttachSceneDefenseObject",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AttachSceneDefenseObjectResponse>(await this.callApi(params, req, runtime), new AttachSceneDefenseObjectResponse({}));
  }

  /**
   * Adds an object to a scenario-specific custom policy for protection.
   * 
   * @param request - AttachSceneDefenseObjectRequest
   * @returns AttachSceneDefenseObjectResponse
   */
  async attachSceneDefenseObject(request: AttachSceneDefenseObjectRequest): Promise<AttachSceneDefenseObjectResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.attachSceneDefenseObjectWithOptions(request, runtime);
  }

  /**
   * Configures the global mitigation policy feature, including the feature status and settings.
   * 
   * @param request - ConfigDomainSecurityProfileRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ConfigDomainSecurityProfileResponse
   */
  async configDomainSecurityProfileWithOptions(request: ConfigDomainSecurityProfileRequest, runtime: $Util.RuntimeOptions): Promise<ConfigDomainSecurityProfileResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.cluster)) {
      query["Cluster"] = request.cluster;
    }

    if (!Util.isUnset(request.config)) {
      query["Config"] = request.config;
    }

    if (!Util.isUnset(request.domain)) {
      query["Domain"] = request.domain;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ConfigDomainSecurityProfile",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ConfigDomainSecurityProfileResponse>(await this.callApi(params, req, runtime), new ConfigDomainSecurityProfileResponse({}));
  }

  /**
   * Configures the global mitigation policy feature, including the feature status and settings.
   * 
   * @param request - ConfigDomainSecurityProfileRequest
   * @returns ConfigDomainSecurityProfileResponse
   */
  async configDomainSecurityProfile(request: ConfigDomainSecurityProfileRequest): Promise<ConfigDomainSecurityProfileResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.configDomainSecurityProfileWithOptions(request, runtime);
  }

  /**
   * Configures a back-to-origin policy for the forwarding rule of a website.
   * 
   * @remarks
   * If multiple origin servers are configured for a website that is added to Anti-DDoS Pro or Anti-DDoS Premium, you can modify the load balancing algorithms for back-to-origin traffic based on back-to-origin policies. The IP hash algorithm is used by default. You can change the algorithm to the round-robin or least response time algorithm. For more information, see the description of the **Policy** parameter in the "Request parameters" section of this topic.
   * 
   * @param request - ConfigL7RsPolicyRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ConfigL7RsPolicyResponse
   */
  async configL7RsPolicyWithOptions(request: ConfigL7RsPolicyRequest, runtime: $Util.RuntimeOptions): Promise<ConfigL7RsPolicyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domain)) {
      query["Domain"] = request.domain;
    }

    if (!Util.isUnset(request.policy)) {
      query["Policy"] = request.policy;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.upstreamRetry)) {
      query["UpstreamRetry"] = request.upstreamRetry;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ConfigL7RsPolicy",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ConfigL7RsPolicyResponse>(await this.callApi(params, req, runtime), new ConfigL7RsPolicyResponse({}));
  }

  /**
   * Configures a back-to-origin policy for the forwarding rule of a website.
   * 
   * @remarks
   * If multiple origin servers are configured for a website that is added to Anti-DDoS Pro or Anti-DDoS Premium, you can modify the load balancing algorithms for back-to-origin traffic based on back-to-origin policies. The IP hash algorithm is used by default. You can change the algorithm to the round-robin or least response time algorithm. For more information, see the description of the **Policy** parameter in the "Request parameters" section of this topic.
   * 
   * @param request - ConfigL7RsPolicyRequest
   * @returns ConfigL7RsPolicyResponse
   */
  async configL7RsPolicy(request: ConfigL7RsPolicyRequest): Promise<ConfigL7RsPolicyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.configL7RsPolicyWithOptions(request, runtime);
  }

  /**
   * Configures the settings for back-to-origin persistent connections for a domain name.
   * 
   * @param request - ConfigL7UsKeepaliveRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ConfigL7UsKeepaliveResponse
   */
  async configL7UsKeepaliveWithOptions(request: ConfigL7UsKeepaliveRequest, runtime: $Util.RuntimeOptions): Promise<ConfigL7UsKeepaliveResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domain)) {
      query["Domain"] = request.domain;
    }

    if (!Util.isUnset(request.upstreamKeepalive)) {
      query["UpstreamKeepalive"] = request.upstreamKeepalive;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ConfigL7UsKeepalive",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ConfigL7UsKeepaliveResponse>(await this.callApi(params, req, runtime), new ConfigL7UsKeepaliveResponse({}));
  }

  /**
   * Configures the settings for back-to-origin persistent connections for a domain name.
   * 
   * @param request - ConfigL7UsKeepaliveRequest
   * @returns ConfigL7UsKeepaliveResponse
   */
  async configL7UsKeepalive(request: ConfigL7UsKeepaliveRequest): Promise<ConfigL7UsKeepaliveResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.configL7UsKeepaliveWithOptions(request, runtime);
  }

  /**
   * Specifies a threshold for the clean bandwidth of an Anti-DDoS Pro or Anti-DDoS premium instance. If the threshold is reached, rate limiting is triggered.
   * 
   * @param request - ConfigLayer4RealLimitRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ConfigLayer4RealLimitResponse
   */
  async configLayer4RealLimitWithOptions(request: ConfigLayer4RealLimitRequest, runtime: $Util.RuntimeOptions): Promise<ConfigLayer4RealLimitResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.limitValue)) {
      query["LimitValue"] = request.limitValue;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ConfigLayer4RealLimit",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ConfigLayer4RealLimitResponse>(await this.callApi(params, req, runtime), new ConfigLayer4RealLimitResponse({}));
  }

  /**
   * Specifies a threshold for the clean bandwidth of an Anti-DDoS Pro or Anti-DDoS premium instance. If the threshold is reached, rate limiting is triggered.
   * 
   * @param request - ConfigLayer4RealLimitRequest
   * @returns ConfigLayer4RealLimitResponse
   */
  async configLayer4RealLimit(request: ConfigLayer4RealLimitRequest): Promise<ConfigLayer4RealLimitResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.configLayer4RealLimitWithOptions(request, runtime);
  }

  /**
   * Adds a description to a port forwarding rule.
   * 
   * @param request - ConfigLayer4RemarkRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ConfigLayer4RemarkResponse
   */
  async configLayer4RemarkWithOptions(request: ConfigLayer4RemarkRequest, runtime: $Util.RuntimeOptions): Promise<ConfigLayer4RemarkResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.listeners)) {
      query["Listeners"] = request.listeners;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ConfigLayer4Remark",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ConfigLayer4RemarkResponse>(await this.callApi(params, req, runtime), new ConfigLayer4RemarkResponse({}));
  }

  /**
   * Adds a description to a port forwarding rule.
   * 
   * @param request - ConfigLayer4RemarkRequest
   * @returns ConfigLayer4RemarkResponse
   */
  async configLayer4Remark(request: ConfigLayer4RemarkRequest): Promise<ConfigLayer4RemarkResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.configLayer4RemarkWithOptions(request, runtime);
  }

  /**
   * Enables or disables the origin redundancy mode for a port forwarding rule.
   * 
   * @param request - ConfigLayer4RuleBakModeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ConfigLayer4RuleBakModeResponse
   */
  async configLayer4RuleBakModeWithOptions(request: ConfigLayer4RuleBakModeRequest, runtime: $Util.RuntimeOptions): Promise<ConfigLayer4RuleBakModeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.bakMode)) {
      query["BakMode"] = request.bakMode;
    }

    if (!Util.isUnset(request.listeners)) {
      query["Listeners"] = request.listeners;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ConfigLayer4RuleBakMode",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ConfigLayer4RuleBakModeResponse>(await this.callApi(params, req, runtime), new ConfigLayer4RuleBakModeResponse({}));
  }

  /**
   * Enables or disables the origin redundancy mode for a port forwarding rule.
   * 
   * @param request - ConfigLayer4RuleBakModeRequest
   * @returns ConfigLayer4RuleBakModeResponse
   */
  async configLayer4RuleBakMode(request: ConfigLayer4RuleBakModeRequest): Promise<ConfigLayer4RuleBakModeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.configLayer4RuleBakModeWithOptions(request, runtime);
  }

  /**
   * Configures the IP addresses of the primary and secondary origin servers for a port forwarding rule.
   * 
   * @param request - ConfigLayer4RulePolicyRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ConfigLayer4RulePolicyResponse
   */
  async configLayer4RulePolicyWithOptions(request: ConfigLayer4RulePolicyRequest, runtime: $Util.RuntimeOptions): Promise<ConfigLayer4RulePolicyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.listeners)) {
      query["Listeners"] = request.listeners;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ConfigLayer4RulePolicy",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ConfigLayer4RulePolicyResponse>(await this.callApi(params, req, runtime), new ConfigLayer4RulePolicyResponse({}));
  }

  /**
   * Configures the IP addresses of the primary and secondary origin servers for a port forwarding rule.
   * 
   * @param request - ConfigLayer4RulePolicyRequest
   * @returns ConfigLayer4RulePolicyResponse
   */
  async configLayer4RulePolicy(request: ConfigLayer4RulePolicyRequest): Promise<ConfigLayer4RulePolicyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.configLayer4RulePolicyWithOptions(request, runtime);
  }

  /**
   * Configures blocked locations for an Anti-DDoS Proxy instance.
   * 
   * @param request - ConfigNetworkRegionBlockRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ConfigNetworkRegionBlockResponse
   */
  async configNetworkRegionBlockWithOptions(request: ConfigNetworkRegionBlockRequest, runtime: $Util.RuntimeOptions): Promise<ConfigNetworkRegionBlockResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.config)) {
      query["Config"] = request.config;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ConfigNetworkRegionBlock",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ConfigNetworkRegionBlockResponse>(await this.callApi(params, req, runtime), new ConfigNetworkRegionBlockResponse({}));
  }

  /**
   * Configures blocked locations for an Anti-DDoS Proxy instance.
   * 
   * @param request - ConfigNetworkRegionBlockRequest
   * @returns ConfigNetworkRegionBlockResponse
   */
  async configNetworkRegionBlock(request: ConfigNetworkRegionBlockRequest): Promise<ConfigNetworkRegionBlockResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.configNetworkRegionBlockWithOptions(request, runtime);
  }

  /**
   * Modifies the IP addresses of the origin server that is configured in a port forwarding rule.
   * 
   * @param request - ConfigNetworkRulesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ConfigNetworkRulesResponse
   */
  async configNetworkRulesWithOptions(request: ConfigNetworkRulesRequest, runtime: $Util.RuntimeOptions): Promise<ConfigNetworkRulesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.networkRules)) {
      query["NetworkRules"] = request.networkRules;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ConfigNetworkRules",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ConfigNetworkRulesResponse>(await this.callApi(params, req, runtime), new ConfigNetworkRulesResponse({}));
  }

  /**
   * Modifies the IP addresses of the origin server that is configured in a port forwarding rule.
   * 
   * @param request - ConfigNetworkRulesRequest
   * @returns ConfigNetworkRulesResponse
   */
  async configNetworkRules(request: ConfigNetworkRulesRequest): Promise<ConfigNetworkRulesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.configNetworkRulesWithOptions(request, runtime);
  }

  /**
   * Adds the filtering policies for UDP reflection attacks on an Anti-DDoS Pro or Anti-DDoS Premium instance to filter out the source ports of UDP traffic.
   * 
   * @remarks
   * You can call this operation to configure filtering policies to filter out UDP traffic from specific ports. This helps defend against UDP reflection attacks.
   * ### Limits
   * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
   * 
   * @param request - ConfigUdpReflectRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ConfigUdpReflectResponse
   */
  async configUdpReflectWithOptions(request: ConfigUdpReflectRequest, runtime: $Util.RuntimeOptions): Promise<ConfigUdpReflectResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.config)) {
      query["Config"] = request.config;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ConfigUdpReflect",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ConfigUdpReflectResponse>(await this.callApi(params, req, runtime), new ConfigUdpReflectResponse({}));
  }

  /**
   * Adds the filtering policies for UDP reflection attacks on an Anti-DDoS Pro or Anti-DDoS Premium instance to filter out the source ports of UDP traffic.
   * 
   * @remarks
   * You can call this operation to configure filtering policies to filter out UDP traffic from specific ports. This helps defend against UDP reflection attacks.
   * ### Limits
   * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
   * 
   * @param request - ConfigUdpReflectRequest
   * @returns ConfigUdpReflectResponse
   */
  async configUdpReflect(request: ConfigUdpReflectRequest): Promise<ConfigUdpReflectResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.configUdpReflectWithOptions(request, runtime);
  }

  /**
   * cc
   * 
   * @param request - ConfigWebCCRuleV2Request
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ConfigWebCCRuleV2Response
   */
  async configWebCCRuleV2WithOptions(request: ConfigWebCCRuleV2Request, runtime: $Util.RuntimeOptions): Promise<ConfigWebCCRuleV2Response> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domain)) {
      query["Domain"] = request.domain;
    }

    if (!Util.isUnset(request.expires)) {
      query["Expires"] = request.expires;
    }

    if (!Util.isUnset(request.ruleList)) {
      query["RuleList"] = request.ruleList;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ConfigWebCCRuleV2",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ConfigWebCCRuleV2Response>(await this.callApi(params, req, runtime), new ConfigWebCCRuleV2Response({}));
  }

  /**
   * cc
   * 
   * @param request - ConfigWebCCRuleV2Request
   * @returns ConfigWebCCRuleV2Response
   */
  async configWebCCRuleV2(request: ConfigWebCCRuleV2Request): Promise<ConfigWebCCRuleV2Response> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.configWebCCRuleV2WithOptions(request, runtime);
  }

  /**
   * Configures the mode of the Frequency Control policy for a website.
   * 
   * @param request - ConfigWebCCTemplateRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ConfigWebCCTemplateResponse
   */
  async configWebCCTemplateWithOptions(request: ConfigWebCCTemplateRequest, runtime: $Util.RuntimeOptions): Promise<ConfigWebCCTemplateResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domain)) {
      query["Domain"] = request.domain;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.template)) {
      query["Template"] = request.template;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ConfigWebCCTemplate",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ConfigWebCCTemplateResponse>(await this.callApi(params, req, runtime), new ConfigWebCCTemplateResponse({}));
  }

  /**
   * Configures the mode of the Frequency Control policy for a website.
   * 
   * @param request - ConfigWebCCTemplateRequest
   * @returns ConfigWebCCTemplateResponse
   */
  async configWebCCTemplate(request: ConfigWebCCTemplateRequest): Promise<ConfigWebCCTemplateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.configWebCCTemplateWithOptions(request, runtime);
  }

  /**
   * Configures the IP address whitelist and blacklist for a website.
   * 
   * @param request - ConfigWebIpSetRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ConfigWebIpSetResponse
   */
  async configWebIpSetWithOptions(request: ConfigWebIpSetRequest, runtime: $Util.RuntimeOptions): Promise<ConfigWebIpSetResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.blackList)) {
      query["BlackList"] = request.blackList;
    }

    if (!Util.isUnset(request.domain)) {
      query["Domain"] = request.domain;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.whiteList)) {
      query["WhiteList"] = request.whiteList;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ConfigWebIpSet",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ConfigWebIpSetResponse>(await this.callApi(params, req, runtime), new ConfigWebIpSetResponse({}));
  }

  /**
   * Configures the IP address whitelist and blacklist for a website.
   * 
   * @param request - ConfigWebIpSetRequest
   * @returns ConfigWebIpSetResponse
   */
  async configWebIpSet(request: ConfigWebIpSetRequest): Promise<ConfigWebIpSetResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.configWebIpSetWithOptions(request, runtime);
  }

  /**
   * Creates an asynchronous export task to export forwarding rules for websites, port forwarding rules, session persistence and health check settings, DDoS mitigation policies, the IP address blacklist, or the IP address whitelist.
   * 
   * @param request - CreateAsyncTaskRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateAsyncTaskResponse
   */
  async createAsyncTaskWithOptions(request: CreateAsyncTaskRequest, runtime: $Util.RuntimeOptions): Promise<CreateAsyncTaskResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.taskParams)) {
      query["TaskParams"] = request.taskParams;
    }

    if (!Util.isUnset(request.taskType)) {
      query["TaskType"] = request.taskType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateAsyncTask",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateAsyncTaskResponse>(await this.callApi(params, req, runtime), new CreateAsyncTaskResponse({}));
  }

  /**
   * Creates an asynchronous export task to export forwarding rules for websites, port forwarding rules, session persistence and health check settings, DDoS mitigation policies, the IP address blacklist, or the IP address whitelist.
   * 
   * @param request - CreateAsyncTaskRequest
   * @returns CreateAsyncTaskResponse
   */
  async createAsyncTask(request: CreateAsyncTaskRequest): Promise<CreateAsyncTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createAsyncTaskWithOptions(request, runtime);
  }

  /**
   * Creates a forwarding rule for a website.
   * 
   * @param request - CreateDomainResourceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateDomainResourceResponse
   */
  async createDomainResourceWithOptions(request: CreateDomainResourceRequest, runtime: $Util.RuntimeOptions): Promise<CreateDomainResourceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domain)) {
      query["Domain"] = request.domain;
    }

    if (!Util.isUnset(request.httpsExt)) {
      query["HttpsExt"] = request.httpsExt;
    }

    if (!Util.isUnset(request.instanceIds)) {
      query["InstanceIds"] = request.instanceIds;
    }

    if (!Util.isUnset(request.proxyTypes)) {
      query["ProxyTypes"] = request.proxyTypes;
    }

    if (!Util.isUnset(request.realServers)) {
      query["RealServers"] = request.realServers;
    }

    if (!Util.isUnset(request.rsType)) {
      query["RsType"] = request.rsType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateDomainResource",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateDomainResourceResponse>(await this.callApi(params, req, runtime), new CreateDomainResourceResponse({}));
  }

  /**
   * Creates a forwarding rule for a website.
   * 
   * @param request - CreateDomainResourceRequest
   * @returns CreateDomainResourceResponse
   */
  async createDomainResource(request: CreateDomainResourceRequest): Promise<CreateDomainResourceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createDomainResourceWithOptions(request, runtime);
  }

  /**
   * Creates a port forwarding rule.
   * 
   * @param request - CreateNetworkRulesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateNetworkRulesResponse
   */
  async createNetworkRulesWithOptions(request: CreateNetworkRulesRequest, runtime: $Util.RuntimeOptions): Promise<CreateNetworkRulesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.networkRules)) {
      query["NetworkRules"] = request.networkRules;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateNetworkRules",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateNetworkRulesResponse>(await this.callApi(params, req, runtime), new CreateNetworkRulesResponse({}));
  }

  /**
   * Creates a port forwarding rule.
   * 
   * @param request - CreateNetworkRulesRequest
   * @returns CreateNetworkRulesResponse
   */
  async createNetworkRules(request: CreateNetworkRulesRequest): Promise<CreateNetworkRulesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createNetworkRulesWithOptions(request, runtime);
  }

  /**
   * Creates a port forwarding rule.
   * 
   * @remarks
   * You can call this operation by using Terraform. For more information about Terraform, see [What is Terraform?](https://help.aliyun.com/document_detail/95820.html).
   * 
   * @param request - CreatePortRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreatePortResponse
   */
  async createPortWithOptions(request: CreatePortRequest, runtime: $Util.RuntimeOptions): Promise<CreatePortResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.backendPort)) {
      query["BackendPort"] = request.backendPort;
    }

    if (!Util.isUnset(request.frontendPort)) {
      query["FrontendPort"] = request.frontendPort;
    }

    if (!Util.isUnset(request.frontendProtocol)) {
      query["FrontendProtocol"] = request.frontendProtocol;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.realServers)) {
      query["RealServers"] = request.realServers;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreatePort",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreatePortResponse>(await this.callApi(params, req, runtime), new CreatePortResponse({}));
  }

  /**
   * Creates a port forwarding rule.
   * 
   * @remarks
   * You can call this operation by using Terraform. For more information about Terraform, see [What is Terraform?](https://help.aliyun.com/document_detail/95820.html).
   * 
   * @param request - CreatePortRequest
   * @returns CreatePortResponse
   */
  async createPort(request: CreatePortRequest): Promise<CreatePortResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createPortWithOptions(request, runtime);
  }

  /**
   * Creates a scenario-specific custom policy.
   * 
   * @param request - CreateSceneDefensePolicyRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateSceneDefensePolicyResponse
   */
  async createSceneDefensePolicyWithOptions(request: CreateSceneDefensePolicyRequest, runtime: $Util.RuntimeOptions): Promise<CreateSceneDefensePolicyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.template)) {
      query["Template"] = request.template;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateSceneDefensePolicy",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateSceneDefensePolicyResponse>(await this.callApi(params, req, runtime), new CreateSceneDefensePolicyResponse({}));
  }

  /**
   * Creates a scenario-specific custom policy.
   * 
   * @param request - CreateSceneDefensePolicyRequest
   * @returns CreateSceneDefensePolicyResponse
   */
  async createSceneDefensePolicy(request: CreateSceneDefensePolicyRequest): Promise<CreateSceneDefensePolicyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createSceneDefensePolicyWithOptions(request, runtime);
  }

  /**
   * Creates a scheduling rule for Sec-Traffic Manager.
   * 
   * @param request - CreateSchedulerRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateSchedulerRuleResponse
   */
  async createSchedulerRuleWithOptions(request: CreateSchedulerRuleRequest, runtime: $Util.RuntimeOptions): Promise<CreateSchedulerRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.param)) {
      query["Param"] = request.param;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.ruleName)) {
      query["RuleName"] = request.ruleName;
    }

    if (!Util.isUnset(request.ruleType)) {
      query["RuleType"] = request.ruleType;
    }

    if (!Util.isUnset(request.rules)) {
      query["Rules"] = request.rules;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateSchedulerRule",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateSchedulerRuleResponse>(await this.callApi(params, req, runtime), new CreateSchedulerRuleResponse({}));
  }

  /**
   * Creates a scheduling rule for Sec-Traffic Manager.
   * 
   * @param request - CreateSchedulerRuleRequest
   * @returns CreateSchedulerRuleResponse
   */
  async createSchedulerRule(request: CreateSchedulerRuleRequest): Promise<CreateSchedulerRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createSchedulerRuleWithOptions(request, runtime);
  }

  /**
   * Adds tags to multiple Anti-DDoS Proxy (Chinese Mainland) instances at a time.
   * 
   * @remarks
   * You can call the CreateTagResources operation to add a tag to multiple Anti-DDoS Proxy (Chinese Mainland) instances at a time.
   * >  Anti-DDoS Proxy (Outside Chinese Mainland) does not support the tag feature.
   * ### [](#qps-)QPS limits
   * You can call this operation up to 10 times per second per account. If the number of calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
   * 
   * @param request - CreateTagResourcesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateTagResourcesResponse
   */
  async createTagResourcesWithOptions(request: CreateTagResourcesRequest, runtime: $Util.RuntimeOptions): Promise<CreateTagResourcesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.resourceIds)) {
      query["ResourceIds"] = request.resourceIds;
    }

    if (!Util.isUnset(request.resourceType)) {
      query["ResourceType"] = request.resourceType;
    }

    if (!Util.isUnset(request.tags)) {
      query["Tags"] = request.tags;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateTagResources",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateTagResourcesResponse>(await this.callApi(params, req, runtime), new CreateTagResourcesResponse({}));
  }

  /**
   * Adds tags to multiple Anti-DDoS Proxy (Chinese Mainland) instances at a time.
   * 
   * @remarks
   * You can call the CreateTagResources operation to add a tag to multiple Anti-DDoS Proxy (Chinese Mainland) instances at a time.
   * >  Anti-DDoS Proxy (Outside Chinese Mainland) does not support the tag feature.
   * ### [](#qps-)QPS limits
   * You can call this operation up to 10 times per second per account. If the number of calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
   * 
   * @param request - CreateTagResourcesRequest
   * @returns CreateTagResourcesResponse
   */
  async createTagResources(request: CreateTagResourcesRequest): Promise<CreateTagResourcesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createTagResourcesWithOptions(request, runtime);
  }

  /**
   * Creates a custom frequency control rule for a website.
   * 
   * @deprecated OpenAPI CreateWebCCRule is deprecated, please use ddoscoo::2020-01-01::ConfigWebCCRuleV2 instead.
   * 
   * @param request - CreateWebCCRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateWebCCRuleResponse
   */
  // Deprecated
  async createWebCCRuleWithOptions(request: CreateWebCCRuleRequest, runtime: $Util.RuntimeOptions): Promise<CreateWebCCRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.act)) {
      query["Act"] = request.act;
    }

    if (!Util.isUnset(request.count)) {
      query["Count"] = request.count;
    }

    if (!Util.isUnset(request.domain)) {
      query["Domain"] = request.domain;
    }

    if (!Util.isUnset(request.interval)) {
      query["Interval"] = request.interval;
    }

    if (!Util.isUnset(request.mode)) {
      query["Mode"] = request.mode;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.ttl)) {
      query["Ttl"] = request.ttl;
    }

    if (!Util.isUnset(request.uri)) {
      query["Uri"] = request.uri;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateWebCCRule",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateWebCCRuleResponse>(await this.callApi(params, req, runtime), new CreateWebCCRuleResponse({}));
  }

  /**
   * Creates a custom frequency control rule for a website.
   * 
   * @deprecated OpenAPI CreateWebCCRule is deprecated, please use ddoscoo::2020-01-01::ConfigWebCCRuleV2 instead.
   * 
   * @param request - CreateWebCCRuleRequest
   * @returns CreateWebCCRuleResponse
   */
  // Deprecated
  async createWebCCRule(request: CreateWebCCRuleRequest): Promise<CreateWebCCRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createWebCCRuleWithOptions(request, runtime);
  }

  /**
   * Creates a forwarding rule for a website.
   * 
   * @param request - CreateWebRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateWebRuleResponse
   */
  async createWebRuleWithOptions(request: CreateWebRuleRequest, runtime: $Util.RuntimeOptions): Promise<CreateWebRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.defenseId)) {
      query["DefenseId"] = request.defenseId;
    }

    if (!Util.isUnset(request.domain)) {
      query["Domain"] = request.domain;
    }

    if (!Util.isUnset(request.httpsExt)) {
      query["HttpsExt"] = request.httpsExt;
    }

    if (!Util.isUnset(request.instanceIds)) {
      query["InstanceIds"] = request.instanceIds;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.rsType)) {
      query["RsType"] = request.rsType;
    }

    if (!Util.isUnset(request.rules)) {
      query["Rules"] = request.rules;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateWebRule",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateWebRuleResponse>(await this.callApi(params, req, runtime), new CreateWebRuleResponse({}));
  }

  /**
   * Creates a forwarding rule for a website.
   * 
   * @param request - CreateWebRuleRequest
   * @returns CreateWebRuleResponse
   */
  async createWebRule(request: CreateWebRuleRequest): Promise<CreateWebRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createWebRuleWithOptions(request, runtime);
  }

  /**
   * Deletes an asynchronous export task.
   * 
   * @param request - DeleteAsyncTaskRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteAsyncTaskResponse
   */
  async deleteAsyncTaskWithOptions(request: DeleteAsyncTaskRequest, runtime: $Util.RuntimeOptions): Promise<DeleteAsyncTaskResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.taskId)) {
      query["TaskId"] = request.taskId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteAsyncTask",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteAsyncTaskResponse>(await this.callApi(params, req, runtime), new DeleteAsyncTaskResponse({}));
  }

  /**
   * Deletes an asynchronous export task.
   * 
   * @param request - DeleteAsyncTaskRequest
   * @returns DeleteAsyncTaskResponse
   */
  async deleteAsyncTask(request: DeleteAsyncTaskRequest): Promise<DeleteAsyncTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteAsyncTaskWithOptions(request, runtime);
  }

  /**
   * Removes IP addresses from the IP address blacklist of an Anti-DDoS Pro or Anti-DDoS Premium instance.
   * 
   * @param request - DeleteAutoCcBlacklistRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteAutoCcBlacklistResponse
   */
  async deleteAutoCcBlacklistWithOptions(request: DeleteAutoCcBlacklistRequest, runtime: $Util.RuntimeOptions): Promise<DeleteAutoCcBlacklistResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.blacklist)) {
      query["Blacklist"] = request.blacklist;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteAutoCcBlacklist",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteAutoCcBlacklistResponse>(await this.callApi(params, req, runtime), new DeleteAutoCcBlacklistResponse({}));
  }

  /**
   * Removes IP addresses from the IP address blacklist of an Anti-DDoS Pro or Anti-DDoS Premium instance.
   * 
   * @param request - DeleteAutoCcBlacklistRequest
   * @returns DeleteAutoCcBlacklistResponse
   */
  async deleteAutoCcBlacklist(request: DeleteAutoCcBlacklistRequest): Promise<DeleteAutoCcBlacklistResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteAutoCcBlacklistWithOptions(request, runtime);
  }

  /**
   * Removes IP addresses from the IP address whitelist of an Anti-DDoS Pro or Anti-DDoS Premium instance.
   * 
   * @param request - DeleteAutoCcWhitelistRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteAutoCcWhitelistResponse
   */
  async deleteAutoCcWhitelistWithOptions(request: DeleteAutoCcWhitelistRequest, runtime: $Util.RuntimeOptions): Promise<DeleteAutoCcWhitelistResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.whitelist)) {
      query["Whitelist"] = request.whitelist;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteAutoCcWhitelist",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteAutoCcWhitelistResponse>(await this.callApi(params, req, runtime), new DeleteAutoCcWhitelistResponse({}));
  }

  /**
   * Removes IP addresses from the IP address whitelist of an Anti-DDoS Pro or Anti-DDoS Premium instance.
   * 
   * @param request - DeleteAutoCcWhitelistRequest
   * @returns DeleteAutoCcWhitelistResponse
   */
  async deleteAutoCcWhitelist(request: DeleteAutoCcWhitelistRequest): Promise<DeleteAutoCcWhitelistResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteAutoCcWhitelistWithOptions(request, runtime);
  }

  /**
   * Deletes a specified forwarding rule of a website.
   * 
   * @param request - DeleteDomainResourceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteDomainResourceResponse
   */
  async deleteDomainResourceWithOptions(request: DeleteDomainResourceRequest, runtime: $Util.RuntimeOptions): Promise<DeleteDomainResourceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domain)) {
      query["Domain"] = request.domain;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteDomainResource",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteDomainResourceResponse>(await this.callApi(params, req, runtime), new DeleteDomainResourceResponse({}));
  }

  /**
   * Deletes a specified forwarding rule of a website.
   * 
   * @param request - DeleteDomainResourceRequest
   * @returns DeleteDomainResourceResponse
   */
  async deleteDomainResource(request: DeleteDomainResourceRequest): Promise<DeleteDomainResourceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteDomainResourceWithOptions(request, runtime);
  }

  /**
   * Deletes a port forwarding rule. You can delete only one port forwarding rule at a time.
   * 
   * @param request - DeleteNetworkRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteNetworkRuleResponse
   */
  async deleteNetworkRuleWithOptions(request: DeleteNetworkRuleRequest, runtime: $Util.RuntimeOptions): Promise<DeleteNetworkRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.networkRule)) {
      query["NetworkRule"] = request.networkRule;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteNetworkRule",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteNetworkRuleResponse>(await this.callApi(params, req, runtime), new DeleteNetworkRuleResponse({}));
  }

  /**
   * Deletes a port forwarding rule. You can delete only one port forwarding rule at a time.
   * 
   * @param request - DeleteNetworkRuleRequest
   * @returns DeleteNetworkRuleResponse
   */
  async deleteNetworkRule(request: DeleteNetworkRuleRequest): Promise<DeleteNetworkRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteNetworkRuleWithOptions(request, runtime);
  }

  /**
   * Deletes the specified port forwarding rule.
   * 
   * @remarks
   * After you delete a port forwarding rule, the Anti-DDoS Pro or Anti-DDoS Premium instance no longer forwards service traffic on the Layer 4 port. Before you delete a specific port forwarding rule, make sure that the service traffic destined for the Layer 4 port is redirected to the origin server. This can prevent negative impacts on your services.
   * > You can call this operation by using Terraform. For more information about Terraform, see [What is Terraform?](https://help.aliyun.com/document_detail/95820.html).
   * 
   * @param request - DeletePortRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeletePortResponse
   */
  async deletePortWithOptions(request: DeletePortRequest, runtime: $Util.RuntimeOptions): Promise<DeletePortResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.backendPort)) {
      query["BackendPort"] = request.backendPort;
    }

    if (!Util.isUnset(request.frontendPort)) {
      query["FrontendPort"] = request.frontendPort;
    }

    if (!Util.isUnset(request.frontendProtocol)) {
      query["FrontendProtocol"] = request.frontendProtocol;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.realServers)) {
      query["RealServers"] = request.realServers;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeletePort",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeletePortResponse>(await this.callApi(params, req, runtime), new DeletePortResponse({}));
  }

  /**
   * Deletes the specified port forwarding rule.
   * 
   * @remarks
   * After you delete a port forwarding rule, the Anti-DDoS Pro or Anti-DDoS Premium instance no longer forwards service traffic on the Layer 4 port. Before you delete a specific port forwarding rule, make sure that the service traffic destined for the Layer 4 port is redirected to the origin server. This can prevent negative impacts on your services.
   * > You can call this operation by using Terraform. For more information about Terraform, see [What is Terraform?](https://help.aliyun.com/document_detail/95820.html).
   * 
   * @param request - DeletePortRequest
   * @returns DeletePortResponse
   */
  async deletePort(request: DeletePortRequest): Promise<DeletePortResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deletePortWithOptions(request, runtime);
  }

  /**
   * Deletes a scenario-specific custom policy.
   * 
   * @param request - DeleteSceneDefensePolicyRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteSceneDefensePolicyResponse
   */
  async deleteSceneDefensePolicyWithOptions(request: DeleteSceneDefensePolicyRequest, runtime: $Util.RuntimeOptions): Promise<DeleteSceneDefensePolicyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.policyId)) {
      query["PolicyId"] = request.policyId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteSceneDefensePolicy",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteSceneDefensePolicyResponse>(await this.callApi(params, req, runtime), new DeleteSceneDefensePolicyResponse({}));
  }

  /**
   * Deletes a scenario-specific custom policy.
   * 
   * @param request - DeleteSceneDefensePolicyRequest
   * @returns DeleteSceneDefensePolicyResponse
   */
  async deleteSceneDefensePolicy(request: DeleteSceneDefensePolicyRequest): Promise<DeleteSceneDefensePolicyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteSceneDefensePolicyWithOptions(request, runtime);
  }

  /**
   * Deletes a scheduling rule of Sec-Traffic Manager.
   * 
   * @param request - DeleteSchedulerRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteSchedulerRuleResponse
   */
  async deleteSchedulerRuleWithOptions(request: DeleteSchedulerRuleRequest, runtime: $Util.RuntimeOptions): Promise<DeleteSchedulerRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.ruleName)) {
      query["RuleName"] = request.ruleName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteSchedulerRule",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteSchedulerRuleResponse>(await this.callApi(params, req, runtime), new DeleteSchedulerRuleResponse({}));
  }

  /**
   * Deletes a scheduling rule of Sec-Traffic Manager.
   * 
   * @param request - DeleteSchedulerRuleRequest
   * @returns DeleteSchedulerRuleResponse
   */
  async deleteSchedulerRule(request: DeleteSchedulerRuleRequest): Promise<DeleteSchedulerRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteSchedulerRuleWithOptions(request, runtime);
  }

  /**
   * Removes tags from Anti-DDoS Proxy (Chinese Mainland) instances.
   * 
   * @remarks
   * You can call the DeleteTagResources operation to remove tags from Anti-DDoS Proxy (Chinese Mainland) instances.
   * >  Only Anti-DDoS Proxy (Chinese Mainland) supports tags.
   * ### [](#qps-)QPS limits
   * You can call this operation up to 10 times per second per account. If the number of calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
   * 
   * @param request - DeleteTagResourcesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteTagResourcesResponse
   */
  async deleteTagResourcesWithOptions(request: DeleteTagResourcesRequest, runtime: $Util.RuntimeOptions): Promise<DeleteTagResourcesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.all)) {
      query["All"] = request.all;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.resourceIds)) {
      query["ResourceIds"] = request.resourceIds;
    }

    if (!Util.isUnset(request.resourceType)) {
      query["ResourceType"] = request.resourceType;
    }

    if (!Util.isUnset(request.tagKey)) {
      query["TagKey"] = request.tagKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteTagResources",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteTagResourcesResponse>(await this.callApi(params, req, runtime), new DeleteTagResourcesResponse({}));
  }

  /**
   * Removes tags from Anti-DDoS Proxy (Chinese Mainland) instances.
   * 
   * @remarks
   * You can call the DeleteTagResources operation to remove tags from Anti-DDoS Proxy (Chinese Mainland) instances.
   * >  Only Anti-DDoS Proxy (Chinese Mainland) supports tags.
   * ### [](#qps-)QPS limits
   * You can call this operation up to 10 times per second per account. If the number of calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
   * 
   * @param request - DeleteTagResourcesRequest
   * @returns DeleteTagResourcesResponse
   */
  async deleteTagResources(request: DeleteTagResourcesRequest): Promise<DeleteTagResourcesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteTagResourcesWithOptions(request, runtime);
  }

  /**
   * Deletes custom frequency control rules of a website.
   * 
   * @deprecated OpenAPI DeleteWebCCRule is deprecated, please use ddoscoo::2020-01-01::DeleteWebCCRuleV2 instead.
   * 
   * @param request - DeleteWebCCRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteWebCCRuleResponse
   */
  // Deprecated
  async deleteWebCCRuleWithOptions(request: DeleteWebCCRuleRequest, runtime: $Util.RuntimeOptions): Promise<DeleteWebCCRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domain)) {
      query["Domain"] = request.domain;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteWebCCRule",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteWebCCRuleResponse>(await this.callApi(params, req, runtime), new DeleteWebCCRuleResponse({}));
  }

  /**
   * Deletes custom frequency control rules of a website.
   * 
   * @deprecated OpenAPI DeleteWebCCRule is deprecated, please use ddoscoo::2020-01-01::DeleteWebCCRuleV2 instead.
   * 
   * @param request - DeleteWebCCRuleRequest
   * @returns DeleteWebCCRuleResponse
   */
  // Deprecated
  async deleteWebCCRule(request: DeleteWebCCRuleRequest): Promise<DeleteWebCCRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteWebCCRuleWithOptions(request, runtime);
  }

  /**
   * Deletes custom frequency control rules of a website.
   * 
   * @param request - DeleteWebCCRuleV2Request
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteWebCCRuleV2Response
   */
  async deleteWebCCRuleV2WithOptions(request: DeleteWebCCRuleV2Request, runtime: $Util.RuntimeOptions): Promise<DeleteWebCCRuleV2Response> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domain)) {
      query["Domain"] = request.domain;
    }

    if (!Util.isUnset(request.owner)) {
      query["Owner"] = request.owner;
    }

    if (!Util.isUnset(request.ruleNames)) {
      query["RuleNames"] = request.ruleNames;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteWebCCRuleV2",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteWebCCRuleV2Response>(await this.callApi(params, req, runtime), new DeleteWebCCRuleV2Response({}));
  }

  /**
   * Deletes custom frequency control rules of a website.
   * 
   * @param request - DeleteWebCCRuleV2Request
   * @returns DeleteWebCCRuleV2Response
   */
  async deleteWebCCRuleV2(request: DeleteWebCCRuleV2Request): Promise<DeleteWebCCRuleV2Response> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteWebCCRuleV2WithOptions(request, runtime);
  }

  /**
   * Deletes the custom rules of the Static Page Caching policy for a website.
   * 
   * @remarks
   * You can call the DeleteWebCacheCustomRule operation to delete the custom rules of the Static Page Caching policy for a website.
   * ### Limits
   * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
   * 
   * @param request - DeleteWebCacheCustomRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteWebCacheCustomRuleResponse
   */
  async deleteWebCacheCustomRuleWithOptions(request: DeleteWebCacheCustomRuleRequest, runtime: $Util.RuntimeOptions): Promise<DeleteWebCacheCustomRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domain)) {
      query["Domain"] = request.domain;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.ruleNames)) {
      query["RuleNames"] = request.ruleNames;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteWebCacheCustomRule",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteWebCacheCustomRuleResponse>(await this.callApi(params, req, runtime), new DeleteWebCacheCustomRuleResponse({}));
  }

  /**
   * Deletes the custom rules of the Static Page Caching policy for a website.
   * 
   * @remarks
   * You can call the DeleteWebCacheCustomRule operation to delete the custom rules of the Static Page Caching policy for a website.
   * ### Limits
   * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
   * 
   * @param request - DeleteWebCacheCustomRuleRequest
   * @returns DeleteWebCacheCustomRuleResponse
   */
  async deleteWebCacheCustomRule(request: DeleteWebCacheCustomRuleRequest): Promise<DeleteWebCacheCustomRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteWebCacheCustomRuleWithOptions(request, runtime);
  }

  /**
   * Deletes the accurate access control rules that are created for a website.
   * 
   * @param request - DeleteWebPreciseAccessRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteWebPreciseAccessRuleResponse
   */
  async deleteWebPreciseAccessRuleWithOptions(request: DeleteWebPreciseAccessRuleRequest, runtime: $Util.RuntimeOptions): Promise<DeleteWebPreciseAccessRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domain)) {
      query["Domain"] = request.domain;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.ruleNames)) {
      query["RuleNames"] = request.ruleNames;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteWebPreciseAccessRule",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteWebPreciseAccessRuleResponse>(await this.callApi(params, req, runtime), new DeleteWebPreciseAccessRuleResponse({}));
  }

  /**
   * Deletes the accurate access control rules that are created for a website.
   * 
   * @param request - DeleteWebPreciseAccessRuleRequest
   * @returns DeleteWebPreciseAccessRuleResponse
   */
  async deleteWebPreciseAccessRule(request: DeleteWebPreciseAccessRuleRequest): Promise<DeleteWebPreciseAccessRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteWebPreciseAccessRuleWithOptions(request, runtime);
  }

  /**
   * Deletes a forwarding rule of a website.
   * 
   * @param request - DeleteWebRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteWebRuleResponse
   */
  async deleteWebRuleWithOptions(request: DeleteWebRuleRequest, runtime: $Util.RuntimeOptions): Promise<DeleteWebRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domain)) {
      query["Domain"] = request.domain;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteWebRule",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteWebRuleResponse>(await this.callApi(params, req, runtime), new DeleteWebRuleResponse({}));
  }

  /**
   * Deletes a forwarding rule of a website.
   * 
   * @param request - DeleteWebRuleRequest
   * @returns DeleteWebRuleResponse
   */
  async deleteWebRule(request: DeleteWebRuleRequest): Promise<DeleteWebRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteWebRuleWithOptions(request, runtime);
  }

  /**
   * Queries the details of asynchronous export tasks, such as the IDs, start time, end time, status, parameters, and results.
   * 
   * @remarks
   * You can call the DescribeAsyncTasks operation to query the details of asynchronous export tasks, such as the IDs, start time, end time, status, parameters, and results.
   * ### Limits
   * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
   * 
   * @param request - DescribeAsyncTasksRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeAsyncTasksResponse
   */
  async describeAsyncTasksWithOptions(request: DescribeAsyncTasksRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAsyncTasksResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAsyncTasks",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAsyncTasksResponse>(await this.callApi(params, req, runtime), new DescribeAsyncTasksResponse({}));
  }

  /**
   * Queries the details of asynchronous export tasks, such as the IDs, start time, end time, status, parameters, and results.
   * 
   * @remarks
   * You can call the DescribeAsyncTasks operation to query the details of asynchronous export tasks, such as the IDs, start time, end time, status, parameters, and results.
   * ### Limits
   * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
   * 
   * @param request - DescribeAsyncTasksRequest
   * @returns DescribeAsyncTasksResponse
   */
  async describeAsyncTasks(request: DescribeAsyncTasksRequest): Promise<DescribeAsyncTasksResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAsyncTasksWithOptions(request, runtime);
  }

  /**
   * Queries the peak QPS of DDoS attacks within the specific period of time.
   * 
   * @param request - DescribeAttackAnalysisMaxQpsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeAttackAnalysisMaxQpsResponse
   */
  async describeAttackAnalysisMaxQpsWithOptions(request: DescribeAttackAnalysisMaxQpsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAttackAnalysisMaxQpsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAttackAnalysisMaxQps",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAttackAnalysisMaxQpsResponse>(await this.callApi(params, req, runtime), new DescribeAttackAnalysisMaxQpsResponse({}));
  }

  /**
   * Queries the peak QPS of DDoS attacks within the specific period of time.
   * 
   * @param request - DescribeAttackAnalysisMaxQpsRequest
   * @returns DescribeAttackAnalysisMaxQpsResponse
   */
  async describeAttackAnalysisMaxQps(request: DescribeAttackAnalysisMaxQpsRequest): Promise<DescribeAttackAnalysisMaxQpsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAttackAnalysisMaxQpsWithOptions(request, runtime);
  }

  /**
   * Queries IP addresses in the IP address blacklist of an Anti-DDoS Pro or Anti-DDoS Premium instance.
   * 
   * @param request - DescribeAutoCcBlacklistRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeAutoCcBlacklistResponse
   */
  async describeAutoCcBlacklistWithOptions(request: DescribeAutoCcBlacklistRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAutoCcBlacklistResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.keyWord)) {
      query["KeyWord"] = request.keyWord;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAutoCcBlacklist",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAutoCcBlacklistResponse>(await this.callApi(params, req, runtime), new DescribeAutoCcBlacklistResponse({}));
  }

  /**
   * Queries IP addresses in the IP address blacklist of an Anti-DDoS Pro or Anti-DDoS Premium instance.
   * 
   * @param request - DescribeAutoCcBlacklistRequest
   * @returns DescribeAutoCcBlacklistResponse
   */
  async describeAutoCcBlacklist(request: DescribeAutoCcBlacklistRequest): Promise<DescribeAutoCcBlacklistResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAutoCcBlacklistWithOptions(request, runtime);
  }

  /**
   * Queries the numbers of IP addresses in the IP address whitelist and IP address blacklist of an Anti-DDoS Pro or Anti-DDoS Premium instance.
   * 
   * @param request - DescribeAutoCcListCountRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeAutoCcListCountResponse
   */
  async describeAutoCcListCountWithOptions(request: DescribeAutoCcListCountRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAutoCcListCountResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.queryType)) {
      query["QueryType"] = request.queryType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAutoCcListCount",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAutoCcListCountResponse>(await this.callApi(params, req, runtime), new DescribeAutoCcListCountResponse({}));
  }

  /**
   * Queries the numbers of IP addresses in the IP address whitelist and IP address blacklist of an Anti-DDoS Pro or Anti-DDoS Premium instance.
   * 
   * @param request - DescribeAutoCcListCountRequest
   * @returns DescribeAutoCcListCountResponse
   */
  async describeAutoCcListCount(request: DescribeAutoCcListCountRequest): Promise<DescribeAutoCcListCountResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAutoCcListCountWithOptions(request, runtime);
  }

  /**
   * Queries IP addresses in the IP address whitelist of an Anti-DDoS Pro or Anti-DDoS Premium instance.
   * 
   * @param request - DescribeAutoCcWhitelistRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeAutoCcWhitelistResponse
   */
  async describeAutoCcWhitelistWithOptions(request: DescribeAutoCcWhitelistRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAutoCcWhitelistResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.keyWord)) {
      query["KeyWord"] = request.keyWord;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAutoCcWhitelist",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAutoCcWhitelistResponse>(await this.callApi(params, req, runtime), new DescribeAutoCcWhitelistResponse({}));
  }

  /**
   * Queries IP addresses in the IP address whitelist of an Anti-DDoS Pro or Anti-DDoS Premium instance.
   * 
   * @param request - DescribeAutoCcWhitelistRequest
   * @returns DescribeAutoCcWhitelistResponse
   */
  async describeAutoCcWhitelist(request: DescribeAutoCcWhitelistRequest): Promise<DescribeAutoCcWhitelistResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAutoCcWhitelistWithOptions(request, runtime);
  }

  /**
   * Queries the back-to-origin CIDR blocks of Anti-DDoS Pro or Anti-DDoS Premium.
   * 
   * @param request - DescribeBackSourceCidrRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeBackSourceCidrResponse
   */
  async describeBackSourceCidrWithOptions(request: DescribeBackSourceCidrRequest, runtime: $Util.RuntimeOptions): Promise<DescribeBackSourceCidrResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ipVersion)) {
      query["IpVersion"] = request.ipVersion;
    }

    if (!Util.isUnset(request.line)) {
      query["Line"] = request.line;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeBackSourceCidr",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeBackSourceCidrResponse>(await this.callApi(params, req, runtime), new DescribeBackSourceCidrResponse({}));
  }

  /**
   * Queries the back-to-origin CIDR blocks of Anti-DDoS Pro or Anti-DDoS Premium.
   * 
   * @param request - DescribeBackSourceCidrRequest
   * @returns DescribeBackSourceCidrResponse
   */
  async describeBackSourceCidr(request: DescribeBackSourceCidrRequest): Promise<DescribeBackSourceCidrResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeBackSourceCidrWithOptions(request, runtime);
  }

  /**
   * Queries the blackhole filtering status of one or more Anti-DDoS Pro or Anti-DDoS Premium instances.
   * 
   * @param request - DescribeBlackholeStatusRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeBlackholeStatusResponse
   */
  async describeBlackholeStatusWithOptions(request: DescribeBlackholeStatusRequest, runtime: $Util.RuntimeOptions): Promise<DescribeBlackholeStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceIds)) {
      query["InstanceIds"] = request.instanceIds;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeBlackholeStatus",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeBlackholeStatusResponse>(await this.callApi(params, req, runtime), new DescribeBlackholeStatusResponse({}));
  }

  /**
   * Queries the blackhole filtering status of one or more Anti-DDoS Pro or Anti-DDoS Premium instances.
   * 
   * @param request - DescribeBlackholeStatusRequest
   * @returns DescribeBlackholeStatusResponse
   */
  async describeBlackholeStatus(request: DescribeBlackholeStatusRequest): Promise<DescribeBlackholeStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeBlackholeStatusWithOptions(request, runtime);
  }

  /**
   * Queries the Diversion from Origin Server configurations of one or more Anti-DDoS Proxy (Chinese Mainland) instances.
   * 
   * @remarks
   * You can call this operation to query the Diversion from Origin Server configurations of one or more Anti-DDoS Proxy (Chinese Mainland) instances.
   * >  This operation is suitable only for Anti-DDoS Proxy (Chinese Mainland).
   * ### [](#qps-)QPS limits
   * You can call this operation up to 10 times per second per account. If the number of calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
   * 
   * @param request - DescribeBlockStatusRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeBlockStatusResponse
   */
  async describeBlockStatusWithOptions(request: DescribeBlockStatusRequest, runtime: $Util.RuntimeOptions): Promise<DescribeBlockStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceIds)) {
      query["InstanceIds"] = request.instanceIds;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeBlockStatus",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeBlockStatusResponse>(await this.callApi(params, req, runtime), new DescribeBlockStatusResponse({}));
  }

  /**
   * Queries the Diversion from Origin Server configurations of one or more Anti-DDoS Proxy (Chinese Mainland) instances.
   * 
   * @remarks
   * You can call this operation to query the Diversion from Origin Server configurations of one or more Anti-DDoS Proxy (Chinese Mainland) instances.
   * >  This operation is suitable only for Anti-DDoS Proxy (Chinese Mainland).
   * ### [](#qps-)QPS limits
   * You can call this operation up to 10 times per second per account. If the number of calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
   * 
   * @param request - DescribeBlockStatusRequest
   * @returns DescribeBlockStatusResponse
   */
  async describeBlockStatus(request: DescribeBlockStatusRequest): Promise<DescribeBlockStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeBlockStatusWithOptions(request, runtime);
  }

  /**
   * Queries information about all certificates that can be associated with the current domain name instead of the certificate currently in use. To query the information about the certificate that is currently in use, you can call the DescribeWebRules operation and view the values of the CertName and CertRegion response parameters.
   * 
   * @param request - DescribeCertsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeCertsResponse
   */
  async describeCertsWithOptions(request: DescribeCertsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeCertsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domain)) {
      query["Domain"] = request.domain;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeCerts",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeCertsResponse>(await this.callApi(params, req, runtime), new DescribeCertsResponse({}));
  }

  /**
   * Queries information about all certificates that can be associated with the current domain name instead of the certificate currently in use. To query the information about the certificate that is currently in use, you can call the DescribeWebRules operation and view the values of the CertName and CertRegion response parameters.
   * 
   * @param request - DescribeCertsRequest
   * @returns DescribeCertsResponse
   */
  async describeCerts(request: DescribeCertsRequest): Promise<DescribeCertsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeCertsWithOptions(request, runtime);
  }

  /**
   * @param request - DescribeCnameReusesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeCnameReusesResponse
   */
  async describeCnameReusesWithOptions(request: DescribeCnameReusesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeCnameReusesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domains)) {
      query["Domains"] = request.domains;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeCnameReuses",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeCnameReusesResponse>(await this.callApi(params, req, runtime), new DescribeCnameReusesResponse({}));
  }

  /**
   * @param request - DescribeCnameReusesRequest
   * @returns DescribeCnameReusesResponse
   */
  async describeCnameReuses(request: DescribeCnameReusesRequest): Promise<DescribeCnameReusesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeCnameReusesWithOptions(request, runtime);
  }

  /**
   * Queries the attack events launched against one or more Anti-DDoS Proxy instances.
   * 
   * @param request - DescribeDDoSEventsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDDoSEventsResponse
   */
  async describeDDoSEventsWithOptions(request: DescribeDDoSEventsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDDoSEventsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.instanceIds)) {
      query["InstanceIds"] = request.instanceIds;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDDoSEvents",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDDoSEventsResponse>(await this.callApi(params, req, runtime), new DescribeDDoSEventsResponse({}));
  }

  /**
   * Queries the attack events launched against one or more Anti-DDoS Proxy instances.
   * 
   * @param request - DescribeDDoSEventsRequest
   * @returns DescribeDDoSEventsResponse
   */
  async describeDDoSEvents(request: DescribeDDoSEventsRequest): Promise<DescribeDDoSEventsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDDoSEventsWithOptions(request, runtime);
  }

  /**
   * Query DDoS attacks by IP address.
   * 
   * @remarks
   * You can call the DescribeDDosAllEventList operation to query DDoS attack events within a specific time range by page. The information about a DDoS attack event includes the start time and end time of the attack, attack event type, attacked object, peak bandwidth of attack traffic, and peak packet forwarding rate.
   * ### Limits
   * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
   * 
   * @param request - DescribeDDosAllEventListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDDosAllEventListResponse
   */
  async describeDDosAllEventListWithOptions(request: DescribeDDosAllEventListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDDosAllEventListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.eventType)) {
      query["EventType"] = request.eventType;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDDosAllEventList",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDDosAllEventListResponse>(await this.callApi(params, req, runtime), new DescribeDDosAllEventListResponse({}));
  }

  /**
   * Query DDoS attacks by IP address.
   * 
   * @remarks
   * You can call the DescribeDDosAllEventList operation to query DDoS attack events within a specific time range by page. The information about a DDoS attack event includes the start time and end time of the attack, attack event type, attacked object, peak bandwidth of attack traffic, and peak packet forwarding rate.
   * ### Limits
   * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
   * 
   * @param request - DescribeDDosAllEventListRequest
   * @returns DescribeDDosAllEventListResponse
   */
  async describeDDosAllEventList(request: DescribeDDosAllEventListRequest): Promise<DescribeDDosAllEventListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDDosAllEventListWithOptions(request, runtime);
  }

  /**
   * Queries the source region from which a volumetric attack is initiated.
   * 
   * @remarks
   * > This operation is suitable only for volumetric attacks.
   * 
   * @param request - DescribeDDosEventAreaRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDDosEventAreaResponse
   */
  async describeDDosEventAreaWithOptions(request: DescribeDDosEventAreaRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDDosEventAreaResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.eventType)) {
      query["EventType"] = request.eventType;
    }

    if (!Util.isUnset(request.ip)) {
      query["Ip"] = request.ip;
    }

    if (!Util.isUnset(request.range)) {
      query["Range"] = request.range;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDDosEventArea",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDDosEventAreaResponse>(await this.callApi(params, req, runtime), new DescribeDDosEventAreaResponse({}));
  }

  /**
   * Queries the source region from which a volumetric attack is initiated.
   * 
   * @remarks
   * > This operation is suitable only for volumetric attacks.
   * 
   * @param request - DescribeDDosEventAreaRequest
   * @returns DescribeDDosEventAreaResponse
   */
  async describeDDosEventArea(request: DescribeDDosEventAreaRequest): Promise<DescribeDDosEventAreaResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDDosEventAreaWithOptions(request, runtime);
  }

  /**
   * Queries the attack type details of a volumetric attack.
   * 
   * @remarks
   * > This operation is suitable only for volumetric attacks.
   * 
   * @param request - DescribeDDosEventAttackTypeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDDosEventAttackTypeResponse
   */
  async describeDDosEventAttackTypeWithOptions(request: DescribeDDosEventAttackTypeRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDDosEventAttackTypeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.eventType)) {
      query["EventType"] = request.eventType;
    }

    if (!Util.isUnset(request.ip)) {
      query["Ip"] = request.ip;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDDosEventAttackType",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDDosEventAttackTypeResponse>(await this.callApi(params, req, runtime), new DescribeDDosEventAttackTypeResponse({}));
  }

  /**
   * Queries the attack type details of a volumetric attack.
   * 
   * @remarks
   * > This operation is suitable only for volumetric attacks.
   * 
   * @param request - DescribeDDosEventAttackTypeRequest
   * @returns DescribeDDosEventAttackTypeResponse
   */
  async describeDDosEventAttackType(request: DescribeDDosEventAttackTypeRequest): Promise<DescribeDDosEventAttackTypeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDDosEventAttackTypeWithOptions(request, runtime);
  }

  /**
   * Queries the Internet service provider (ISP) information about a volumetric attack.
   * 
   * @remarks
   * > This operation is suitable only for volumetric attacks.
   * 
   * @param request - DescribeDDosEventIspRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDDosEventIspResponse
   */
  async describeDDosEventIspWithOptions(request: DescribeDDosEventIspRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDDosEventIspResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.eventType)) {
      query["EventType"] = request.eventType;
    }

    if (!Util.isUnset(request.ip)) {
      query["Ip"] = request.ip;
    }

    if (!Util.isUnset(request.range)) {
      query["Range"] = request.range;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDDosEventIsp",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDDosEventIspResponse>(await this.callApi(params, req, runtime), new DescribeDDosEventIspResponse({}));
  }

  /**
   * Queries the Internet service provider (ISP) information about a volumetric attack.
   * 
   * @remarks
   * > This operation is suitable only for volumetric attacks.
   * 
   * @param request - DescribeDDosEventIspRequest
   * @returns DescribeDDosEventIspResponse
   */
  async describeDDosEventIsp(request: DescribeDDosEventIspRequest): Promise<DescribeDDosEventIspResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDDosEventIspWithOptions(request, runtime);
  }

  /**
   * Queries the peaks of volumetric attacks (bit/s), connection flood attacks (CPS), and resource exhaustion attacks on websites (QPS).
   * 
   * @param request - DescribeDDosEventMaxRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDDosEventMaxResponse
   */
  async describeDDosEventMaxWithOptions(request: DescribeDDosEventMaxRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDDosEventMaxResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDDosEventMax",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDDosEventMaxResponse>(await this.callApi(params, req, runtime), new DescribeDDosEventMaxResponse({}));
  }

  /**
   * Queries the peaks of volumetric attacks (bit/s), connection flood attacks (CPS), and resource exhaustion attacks on websites (QPS).
   * 
   * @param request - DescribeDDosEventMaxRequest
   * @returns DescribeDDosEventMaxResponse
   */
  async describeDDosEventMax(request: DescribeDDosEventMaxRequest): Promise<DescribeDDosEventMaxResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDDosEventMaxWithOptions(request, runtime);
  }

  /**
   * Queries the source IP address from which a volumetric attack is initiated.
   * 
   * @remarks
   * > This operation is suitable only for volumetric attacks.
   * 
   * @param request - DescribeDDosEventSrcIpRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDDosEventSrcIpResponse
   */
  async describeDDosEventSrcIpWithOptions(request: DescribeDDosEventSrcIpRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDDosEventSrcIpResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.eventType)) {
      query["EventType"] = request.eventType;
    }

    if (!Util.isUnset(request.ip)) {
      query["Ip"] = request.ip;
    }

    if (!Util.isUnset(request.range)) {
      query["Range"] = request.range;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDDosEventSrcIp",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDDosEventSrcIpResponse>(await this.callApi(params, req, runtime), new DescribeDDosEventSrcIpResponse({}));
  }

  /**
   * Queries the source IP address from which a volumetric attack is initiated.
   * 
   * @remarks
   * > This operation is suitable only for volumetric attacks.
   * 
   * @param request - DescribeDDosEventSrcIpRequest
   * @returns DescribeDDosEventSrcIpResponse
   */
  async describeDDosEventSrcIp(request: DescribeDDosEventSrcIpRequest): Promise<DescribeDDosEventSrcIpResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDDosEventSrcIpWithOptions(request, runtime);
  }

  /**
   * Queries the statistics on advanced mitigation sessions of an Anti-DDoS Proxy (Outside Chinese Mainland) instance.
   * 
   * @remarks
   * You can call the DescribeDefenseCountStatistics operation to query the information about advanced mitigation sessions of an Anti-DDoS Proxy (Outside Chinese Mainland) instance. For example, you can query the number of advanced mitigation sessions that are used within the current calendar month and the number of remaining advanced mitigation sessions.
   * >  This operation is suitable only for Anti-DDoS Proxy (Outside Chinese Mainland).
   * ### [](#qps-)QPS limits
   * You can call this operation up to 10 times per second per account. If the number of calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
   * 
   * @param request - DescribeDefenseCountStatisticsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDefenseCountStatisticsResponse
   */
  async describeDefenseCountStatisticsWithOptions(request: DescribeDefenseCountStatisticsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDefenseCountStatisticsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDefenseCountStatistics",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDefenseCountStatisticsResponse>(await this.callApi(params, req, runtime), new DescribeDefenseCountStatisticsResponse({}));
  }

  /**
   * Queries the statistics on advanced mitigation sessions of an Anti-DDoS Proxy (Outside Chinese Mainland) instance.
   * 
   * @remarks
   * You can call the DescribeDefenseCountStatistics operation to query the information about advanced mitigation sessions of an Anti-DDoS Proxy (Outside Chinese Mainland) instance. For example, you can query the number of advanced mitigation sessions that are used within the current calendar month and the number of remaining advanced mitigation sessions.
   * >  This operation is suitable only for Anti-DDoS Proxy (Outside Chinese Mainland).
   * ### [](#qps-)QPS limits
   * You can call this operation up to 10 times per second per account. If the number of calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
   * 
   * @param request - DescribeDefenseCountStatisticsRequest
   * @returns DescribeDefenseCountStatisticsResponse
   */
  async describeDefenseCountStatistics(request: DescribeDefenseCountStatisticsRequest): Promise<DescribeDefenseCountStatisticsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDefenseCountStatisticsWithOptions(request, runtime);
  }

  /**
   * Queries the advanced mitigation logs of Anti-DDoS Premium.
   * 
   * @remarks
   * > This operation is suitable only for Anti-DDoS Premium.
   * 
   * @param request - DescribeDefenseRecordsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDefenseRecordsResponse
   */
  async describeDefenseRecordsWithOptions(request: DescribeDefenseRecordsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDefenseRecordsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDefenseRecords",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDefenseRecordsResponse>(await this.callApi(params, req, runtime), new DescribeDefenseRecordsResponse({}));
  }

  /**
   * Queries the advanced mitigation logs of Anti-DDoS Premium.
   * 
   * @remarks
   * > This operation is suitable only for Anti-DDoS Premium.
   * 
   * @param request - DescribeDefenseRecordsRequest
   * @returns DescribeDefenseRecordsResponse
   */
  async describeDefenseRecords(request: DescribeDefenseRecordsRequest): Promise<DescribeDefenseRecordsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDefenseRecordsWithOptions(request, runtime);
  }

  /**
   * Queries the number of request packets received by the destination ports of the attacked IP address that is protected by Anti-DDoS Proxy.
   * 
   * @param request - DescribeDestinationPortEventRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDestinationPortEventResponse
   */
  async describeDestinationPortEventWithOptions(request: DescribeDestinationPortEventRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDestinationPortEventResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.eventType)) {
      query["EventType"] = request.eventType;
    }

    if (!Util.isUnset(request.ip)) {
      query["Ip"] = request.ip;
    }

    if (!Util.isUnset(request.range)) {
      query["Range"] = request.range;
    }

    if (!Util.isUnset(request.region)) {
      query["Region"] = request.region;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDestinationPortEvent",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDestinationPortEventResponse>(await this.callApi(params, req, runtime), new DescribeDestinationPortEventResponse({}));
  }

  /**
   * Queries the number of request packets received by the destination ports of the attacked IP address that is protected by Anti-DDoS Proxy.
   * 
   * @param request - DescribeDestinationPortEventRequest
   * @returns DescribeDestinationPortEventResponse
   */
  async describeDestinationPortEvent(request: DescribeDestinationPortEventRequest): Promise<DescribeDestinationPortEventResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDestinationPortEventWithOptions(request, runtime);
  }

  /**
   * Queries the attack events launched against a website.
   * 
   * @param request - DescribeDomainAttackEventsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDomainAttackEventsResponse
   */
  async describeDomainAttackEventsWithOptions(request: DescribeDomainAttackEventsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDomainAttackEventsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domain)) {
      query["Domain"] = request.domain;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDomainAttackEvents",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDomainAttackEventsResponse>(await this.callApi(params, req, runtime), new DescribeDomainAttackEventsResponse({}));
  }

  /**
   * Queries the attack events launched against a website.
   * 
   * @param request - DescribeDomainAttackEventsRequest
   * @returns DescribeDomainAttackEventsResponse
   */
  async describeDomainAttackEvents(request: DescribeDomainAttackEventsRequest): Promise<DescribeDomainAttackEventsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDomainAttackEventsWithOptions(request, runtime);
  }

  /**
   * Queries the attack overview of a website, such as the peak HTTP and HTTPS traffic.
   * 
   * @param request - DescribeDomainOverviewRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDomainOverviewResponse
   */
  async describeDomainOverviewWithOptions(request: DescribeDomainOverviewRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDomainOverviewResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domain)) {
      query["Domain"] = request.domain;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDomainOverview",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDomainOverviewResponse>(await this.callApi(params, req, runtime), new DescribeDomainOverviewResponse({}));
  }

  /**
   * Queries the attack overview of a website, such as the peak HTTP and HTTPS traffic.
   * 
   * @param request - DescribeDomainOverviewRequest
   * @returns DescribeDomainOverviewResponse
   */
  async describeDomainOverview(request: DescribeDomainOverviewRequest): Promise<DescribeDomainOverviewResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDomainOverviewWithOptions(request, runtime);
  }

  /**
   * Queries the statistics on the queries per second (QPS) of a website.
   * 
   * @param request - DescribeDomainQPSListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDomainQPSListResponse
   */
  async describeDomainQPSListWithOptions(request: DescribeDomainQPSListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDomainQPSListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domain)) {
      query["Domain"] = request.domain;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.interval)) {
      query["Interval"] = request.interval;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDomainQPSList",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDomainQPSListResponse>(await this.callApi(params, req, runtime), new DescribeDomainQPSListResponse({}));
  }

  /**
   * Queries the statistics on the queries per second (QPS) of a website.
   * 
   * @param request - DescribeDomainQPSListRequest
   * @returns DescribeDomainQPSListResponse
   */
  async describeDomainQPSList(request: DescribeDomainQPSListRequest): Promise<DescribeDomainQPSListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDomainQPSListWithOptions(request, runtime);
  }

  /**
   * Queries the configurations of a forwarding rule.
   * 
   * @remarks
   * You can call the DescribeDomainResource operation to query the configurations of the forwarding rules that you create for a website by page. The configurations include the domain name-related configurations, protocol-related configurations, HTTPS-related configurations, and configurations that are used to mitigate HTTP flood attacks.
   * You can call this operation by using Terraform. For more information about Terraform, see [What is Terraform?](https://help.aliyun.com/document_detail/95820.html).
   * ### Limits
   * You can call this operation up to 50 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
   * 
   * @param request - DescribeDomainResourceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDomainResourceResponse
   */
  async describeDomainResourceWithOptions(request: DescribeDomainResourceRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDomainResourceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domain)) {
      query["Domain"] = request.domain;
    }

    if (!Util.isUnset(request.instanceIds)) {
      query["InstanceIds"] = request.instanceIds;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.queryDomainPattern)) {
      query["QueryDomainPattern"] = request.queryDomainPattern;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDomainResource",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDomainResourceResponse>(await this.callApi(params, req, runtime), new DescribeDomainResourceResponse({}));
  }

  /**
   * Queries the configurations of a forwarding rule.
   * 
   * @remarks
   * You can call the DescribeDomainResource operation to query the configurations of the forwarding rules that you create for a website by page. The configurations include the domain name-related configurations, protocol-related configurations, HTTPS-related configurations, and configurations that are used to mitigate HTTP flood attacks.
   * You can call this operation by using Terraform. For more information about Terraform, see [What is Terraform?](https://help.aliyun.com/document_detail/95820.html).
   * ### Limits
   * You can call this operation up to 50 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
   * 
   * @param request - DescribeDomainResourceRequest
   * @returns DescribeDomainResourceResponse
   */
  async describeDomainResource(request: DescribeDomainResourceRequest): Promise<DescribeDomainResourceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDomainResourceWithOptions(request, runtime);
  }

  /**
   * Queries the global mitigation policy for a domain name.
   * 
   * @param request - DescribeDomainSecurityProfileRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDomainSecurityProfileResponse
   */
  async describeDomainSecurityProfileWithOptions(request: DescribeDomainSecurityProfileRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDomainSecurityProfileResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domain)) {
      query["Domain"] = request.domain;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDomainSecurityProfile",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDomainSecurityProfileResponse>(await this.callApi(params, req, runtime), new DescribeDomainSecurityProfileResponse({}));
  }

  /**
   * Queries the global mitigation policy for a domain name.
   * 
   * @param request - DescribeDomainSecurityProfileRequest
   * @returns DescribeDomainSecurityProfileResponse
   */
  async describeDomainSecurityProfile(request: DescribeDomainSecurityProfileRequest): Promise<DescribeDomainSecurityProfileResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDomainSecurityProfileWithOptions(request, runtime);
  }

  /**
   * Queries the statistics on HTTP status codes of a website within a specified period of time.
   * 
   * @param request - DescribeDomainStatusCodeCountRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDomainStatusCodeCountResponse
   */
  async describeDomainStatusCodeCountWithOptions(request: DescribeDomainStatusCodeCountRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDomainStatusCodeCountResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domain)) {
      query["Domain"] = request.domain;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDomainStatusCodeCount",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDomainStatusCodeCountResponse>(await this.callApi(params, req, runtime), new DescribeDomainStatusCodeCountResponse({}));
  }

  /**
   * Queries the statistics on HTTP status codes of a website within a specified period of time.
   * 
   * @param request - DescribeDomainStatusCodeCountRequest
   * @returns DescribeDomainStatusCodeCountResponse
   */
  async describeDomainStatusCodeCount(request: DescribeDomainStatusCodeCountRequest): Promise<DescribeDomainStatusCodeCountResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDomainStatusCodeCountWithOptions(request, runtime);
  }

  /**
   * Queries the statistics on HTTP status codes of a website.
   * 
   * @param request - DescribeDomainStatusCodeListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDomainStatusCodeListResponse
   */
  async describeDomainStatusCodeListWithOptions(request: DescribeDomainStatusCodeListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDomainStatusCodeListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domain)) {
      query["Domain"] = request.domain;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.interval)) {
      query["Interval"] = request.interval;
    }

    if (!Util.isUnset(request.queryType)) {
      query["QueryType"] = request.queryType;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDomainStatusCodeList",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDomainStatusCodeListResponse>(await this.callApi(params, req, runtime), new DescribeDomainStatusCodeListResponse({}));
  }

  /**
   * Queries the statistics on HTTP status codes of a website.
   * 
   * @param request - DescribeDomainStatusCodeListRequest
   * @returns DescribeDomainStatusCodeListResponse
   */
  async describeDomainStatusCodeList(request: DescribeDomainStatusCodeListRequest): Promise<DescribeDomainStatusCodeListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDomainStatusCodeListWithOptions(request, runtime);
  }

  /**
   * Queries the peak queries per second (QPS) information about a website, such as the attack QPS and total QPS, within a specific period of time.
   * 
   * @param request - DescribeDomainTopAttackListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDomainTopAttackListResponse
   */
  async describeDomainTopAttackListWithOptions(request: DescribeDomainTopAttackListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDomainTopAttackListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDomainTopAttackList",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDomainTopAttackListResponse>(await this.callApi(params, req, runtime), new DescribeDomainTopAttackListResponse({}));
  }

  /**
   * Queries the peak queries per second (QPS) information about a website, such as the attack QPS and total QPS, within a specific period of time.
   * 
   * @param request - DescribeDomainTopAttackListRequest
   * @returns DescribeDomainTopAttackListResponse
   */
  async describeDomainTopAttackList(request: DescribeDomainTopAttackListRequest): Promise<DescribeDomainTopAttackListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDomainTopAttackListWithOptions(request, runtime);
  }

  /**
   * Queries the areas and countries from which requests are sent to a website within a specified period of time.
   * 
   * @param request - DescribeDomainViewSourceCountriesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDomainViewSourceCountriesResponse
   */
  async describeDomainViewSourceCountriesWithOptions(request: DescribeDomainViewSourceCountriesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDomainViewSourceCountriesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domain)) {
      query["Domain"] = request.domain;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDomainViewSourceCountries",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDomainViewSourceCountriesResponse>(await this.callApi(params, req, runtime), new DescribeDomainViewSourceCountriesResponse({}));
  }

  /**
   * Queries the areas and countries from which requests are sent to a website within a specified period of time.
   * 
   * @param request - DescribeDomainViewSourceCountriesRequest
   * @returns DescribeDomainViewSourceCountriesResponse
   */
  async describeDomainViewSourceCountries(request: DescribeDomainViewSourceCountriesRequest): Promise<DescribeDomainViewSourceCountriesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDomainViewSourceCountriesWithOptions(request, runtime);
  }

  /**
   * Queries the administrative regions in China from which requests are sent to a website within a specified period of time.
   * 
   * @param request - DescribeDomainViewSourceProvincesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDomainViewSourceProvincesResponse
   */
  async describeDomainViewSourceProvincesWithOptions(request: DescribeDomainViewSourceProvincesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDomainViewSourceProvincesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domain)) {
      query["Domain"] = request.domain;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDomainViewSourceProvinces",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDomainViewSourceProvincesResponse>(await this.callApi(params, req, runtime), new DescribeDomainViewSourceProvincesResponse({}));
  }

  /**
   * Queries the administrative regions in China from which requests are sent to a website within a specified period of time.
   * 
   * @param request - DescribeDomainViewSourceProvincesRequest
   * @returns DescribeDomainViewSourceProvincesResponse
   */
  async describeDomainViewSourceProvinces(request: DescribeDomainViewSourceProvincesRequest): Promise<DescribeDomainViewSourceProvincesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDomainViewSourceProvincesWithOptions(request, runtime);
  }

  /**
   * Queries the top N URLs that require the longest time to respond to requests within a specified period of time.
   * 
   * @param request - DescribeDomainViewTopCostTimeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDomainViewTopCostTimeResponse
   */
  async describeDomainViewTopCostTimeWithOptions(request: DescribeDomainViewTopCostTimeRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDomainViewTopCostTimeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domain)) {
      query["Domain"] = request.domain;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.top)) {
      query["Top"] = request.top;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDomainViewTopCostTime",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDomainViewTopCostTimeResponse>(await this.callApi(params, req, runtime), new DescribeDomainViewTopCostTimeResponse({}));
  }

  /**
   * Queries the top N URLs that require the longest time to respond to requests within a specified period of time.
   * 
   * @param request - DescribeDomainViewTopCostTimeRequest
   * @returns DescribeDomainViewTopCostTimeResponse
   */
  async describeDomainViewTopCostTime(request: DescribeDomainViewTopCostTimeRequest): Promise<DescribeDomainViewTopCostTimeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDomainViewTopCostTimeWithOptions(request, runtime);
  }

  /**
   * Queries the top N URLs that receive the most requests within a specified period of time.
   * 
   * @param request - DescribeDomainViewTopUrlRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDomainViewTopUrlResponse
   */
  async describeDomainViewTopUrlWithOptions(request: DescribeDomainViewTopUrlRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDomainViewTopUrlResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domain)) {
      query["Domain"] = request.domain;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.top)) {
      query["Top"] = request.top;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDomainViewTopUrl",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDomainViewTopUrlResponse>(await this.callApi(params, req, runtime), new DescribeDomainViewTopUrlResponse({}));
  }

  /**
   * Queries the top N URLs that receive the most requests within a specified period of time.
   * 
   * @param request - DescribeDomainViewTopUrlRequest
   * @returns DescribeDomainViewTopUrlResponse
   */
  async describeDomainViewTopUrl(request: DescribeDomainViewTopUrlRequest): Promise<DescribeDomainViewTopUrlResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDomainViewTopUrlWithOptions(request, runtime);
  }

  /**
   * Queries domain names for which forwarding rules are created.
   * 
   * @param request - DescribeDomainsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDomainsResponse
   */
  async describeDomainsWithOptions(request: DescribeDomainsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDomainsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceIds)) {
      query["InstanceIds"] = request.instanceIds;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDomains",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDomainsResponse>(await this.callApi(params, req, runtime), new DescribeDomainsResponse({}));
  }

  /**
   * Queries domain names for which forwarding rules are created.
   * 
   * @param request - DescribeDomainsRequest
   * @returns DescribeDomainsResponse
   */
  async describeDomains(request: DescribeDomainsRequest): Promise<DescribeDomainsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDomainsWithOptions(request, runtime);
  }

  /**
   * Queries the available burstable protection bandwidths of an Anti-DDoS Pro instance.
   * 
   * @remarks
   * > This operation is suitable only for Anti-DDoS Pro.
   * 
   * @param request - DescribeElasticBandwidthSpecRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeElasticBandwidthSpecResponse
   */
  async describeElasticBandwidthSpecWithOptions(request: DescribeElasticBandwidthSpecRequest, runtime: $Util.RuntimeOptions): Promise<DescribeElasticBandwidthSpecResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeElasticBandwidthSpec",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeElasticBandwidthSpecResponse>(await this.callApi(params, req, runtime), new DescribeElasticBandwidthSpecResponse({}));
  }

  /**
   * Queries the available burstable protection bandwidths of an Anti-DDoS Pro instance.
   * 
   * @remarks
   * > This operation is suitable only for Anti-DDoS Pro.
   * 
   * @param request - DescribeElasticBandwidthSpecRequest
   * @returns DescribeElasticBandwidthSpecResponse
   */
  async describeElasticBandwidthSpec(request: DescribeElasticBandwidthSpecRequest): Promise<DescribeElasticBandwidthSpecResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeElasticBandwidthSpecWithOptions(request, runtime);
  }

  /**
   * Queries the line chart of the bills for the burstable QPS of an Anti-DDoS Proxy instance.
   * 
   * @param request - DescribeElasticQpsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeElasticQpsResponse
   */
  async describeElasticQpsWithOptions(request: DescribeElasticQpsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeElasticQpsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.interval)) {
      query["Interval"] = request.interval;
    }

    if (!Util.isUnset(request.ip)) {
      query["Ip"] = request.ip;
    }

    if (!Util.isUnset(request.region)) {
      query["Region"] = request.region;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeElasticQps",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeElasticQpsResponse>(await this.callApi(params, req, runtime), new DescribeElasticQpsResponse({}));
  }

  /**
   * Queries the line chart of the bills for the burstable QPS of an Anti-DDoS Proxy instance.
   * 
   * @param request - DescribeElasticQpsRequest
   * @returns DescribeElasticQpsResponse
   */
  async describeElasticQps(request: DescribeElasticQpsRequest): Promise<DescribeElasticQpsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeElasticQpsWithOptions(request, runtime);
  }

  /**
   * Queries the burstable QPS details of an Anti-DDoS Proxy instance.
   * 
   * @param request - DescribeElasticQpsRecordRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeElasticQpsRecordResponse
   */
  async describeElasticQpsRecordWithOptions(request: DescribeElasticQpsRecordRequest, runtime: $Util.RuntimeOptions): Promise<DescribeElasticQpsRecordResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.ip)) {
      query["Ip"] = request.ip;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeElasticQpsRecord",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeElasticQpsRecordResponse>(await this.callApi(params, req, runtime), new DescribeElasticQpsRecordResponse({}));
  }

  /**
   * Queries the burstable QPS details of an Anti-DDoS Proxy instance.
   * 
   * @param request - DescribeElasticQpsRecordRequest
   * @returns DescribeElasticQpsRecordResponse
   */
  async describeElasticQpsRecord(request: DescribeElasticQpsRecordRequest): Promise<DescribeElasticQpsRecordResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeElasticQpsRecordWithOptions(request, runtime);
  }

  /**
   * Queries the custom header that is specified for a domain name.
   * 
   * @param request - DescribeHeadersRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeHeadersResponse
   */
  async describeHeadersWithOptions(request: DescribeHeadersRequest, runtime: $Util.RuntimeOptions): Promise<DescribeHeadersResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domain)) {
      query["Domain"] = request.domain;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeHeaders",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeHeadersResponse>(await this.callApi(params, req, runtime), new DescribeHeadersResponse({}));
  }

  /**
   * Queries the custom header that is specified for a domain name.
   * 
   * @param request - DescribeHeadersRequest
   * @returns DescribeHeadersResponse
   */
  async describeHeaders(request: DescribeHeadersRequest): Promise<DescribeHeadersResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeHeadersWithOptions(request, runtime);
  }

  /**
   * Queries the Layer 4 or Layer 7 health check configurations of a port forwarding rule.
   * 
   * @param request - DescribeHealthCheckListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeHealthCheckListResponse
   */
  async describeHealthCheckListWithOptions(request: DescribeHealthCheckListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeHealthCheckListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.networkRules)) {
      query["NetworkRules"] = request.networkRules;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeHealthCheckList",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeHealthCheckListResponse>(await this.callApi(params, req, runtime), new DescribeHealthCheckListResponse({}));
  }

  /**
   * Queries the Layer 4 or Layer 7 health check configurations of a port forwarding rule.
   * 
   * @param request - DescribeHealthCheckListRequest
   * @returns DescribeHealthCheckListResponse
   */
  async describeHealthCheckList(request: DescribeHealthCheckListRequest): Promise<DescribeHealthCheckListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeHealthCheckListWithOptions(request, runtime);
  }

  /**
   * Queries the health status of an origin server.
   * 
   * @param request - DescribeHealthCheckStatusRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeHealthCheckStatusResponse
   */
  async describeHealthCheckStatusWithOptions(request: DescribeHealthCheckStatusRequest, runtime: $Util.RuntimeOptions): Promise<DescribeHealthCheckStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.networkRules)) {
      query["NetworkRules"] = request.networkRules;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeHealthCheckStatus",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeHealthCheckStatusResponse>(await this.callApi(params, req, runtime), new DescribeHealthCheckStatusResponse({}));
  }

  /**
   * Queries the health status of an origin server.
   * 
   * @param request - DescribeHealthCheckStatusRequest
   * @returns DescribeHealthCheckStatusResponse
   */
  async describeHealthCheckStatus(request: DescribeHealthCheckStatusRequest): Promise<DescribeHealthCheckStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeHealthCheckStatusWithOptions(request, runtime);
  }

  /**
   * Queries the IP addresses and Internet service provider (ISP) lines of Anti-DDoS Pro or Anti-DDoS Premium instances.
   * 
   * @remarks
   * You can call the DescribeInstanceDetails operation to query the information about the IP addresses and ISP lines of the instances. The information includes the IP address, status, and protection line.
   * ### Limits
   * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
   * 
   * @param request - DescribeInstanceDetailsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeInstanceDetailsResponse
   */
  async describeInstanceDetailsWithOptions(request: DescribeInstanceDetailsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeInstanceDetailsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceIds)) {
      query["InstanceIds"] = request.instanceIds;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeInstanceDetails",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeInstanceDetailsResponse>(await this.callApi(params, req, runtime), new DescribeInstanceDetailsResponse({}));
  }

  /**
   * Queries the IP addresses and Internet service provider (ISP) lines of Anti-DDoS Pro or Anti-DDoS Premium instances.
   * 
   * @remarks
   * You can call the DescribeInstanceDetails operation to query the information about the IP addresses and ISP lines of the instances. The information includes the IP address, status, and protection line.
   * ### Limits
   * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
   * 
   * @param request - DescribeInstanceDetailsRequest
   * @returns DescribeInstanceDetailsResponse
   */
  async describeInstanceDetails(request: DescribeInstanceDetailsRequest): Promise<DescribeInstanceDetailsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeInstanceDetailsWithOptions(request, runtime);
  }

  /**
   * Queries the information about Anti-DDoS Pro and Anti-DDoS Premium instances.
   * 
   * @param request - DescribeInstanceExtRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeInstanceExtResponse
   */
  async describeInstanceExtWithOptions(request: DescribeInstanceExtRequest, runtime: $Util.RuntimeOptions): Promise<DescribeInstanceExtResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeInstanceExt",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeInstanceExtResponse>(await this.callApi(params, req, runtime), new DescribeInstanceExtResponse({}));
  }

  /**
   * Queries the information about Anti-DDoS Pro and Anti-DDoS Premium instances.
   * 
   * @param request - DescribeInstanceExtRequest
   * @returns DescribeInstanceExtResponse
   */
  async describeInstanceExt(request: DescribeInstanceExtRequest): Promise<DescribeInstanceExtResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeInstanceExtWithOptions(request, runtime);
  }

  /**
   * The description of the instance.
   * 
   * @param request - DescribeInstanceIdsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeInstanceIdsResponse
   */
  async describeInstanceIdsWithOptions(request: DescribeInstanceIdsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeInstanceIdsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.edition)) {
      query["Edition"] = request.edition;
    }

    if (!Util.isUnset(request.instanceIds)) {
      query["InstanceIds"] = request.instanceIds;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeInstanceIds",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeInstanceIdsResponse>(await this.callApi(params, req, runtime), new DescribeInstanceIdsResponse({}));
  }

  /**
   * The description of the instance.
   * 
   * @param request - DescribeInstanceIdsRequest
   * @returns DescribeInstanceIdsResponse
   */
  async describeInstanceIds(request: DescribeInstanceIdsRequest): Promise<DescribeInstanceIdsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeInstanceIdsWithOptions(request, runtime);
  }

  /**
   * Queries the specifications of Anti-DDoS Pro or Anti-DDoS Premium instances.
   * 
   * @remarks
   * You can call the DescribeInstanceSpecs operation to query the specifications of multiple Anti-DDoS Pro or Anti-DDoS Premium instances at a time. The specifications include the clean bandwidth, protection bandwidth, function plan, and the numbers of domain names and ports that can be protected.
   * ### Limits
   * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
   * 
   * @param request - DescribeInstanceSpecsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeInstanceSpecsResponse
   */
  async describeInstanceSpecsWithOptions(request: DescribeInstanceSpecsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeInstanceSpecsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceIds)) {
      query["InstanceIds"] = request.instanceIds;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeInstanceSpecs",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeInstanceSpecsResponse>(await this.callApi(params, req, runtime), new DescribeInstanceSpecsResponse({}));
  }

  /**
   * Queries the specifications of Anti-DDoS Pro or Anti-DDoS Premium instances.
   * 
   * @remarks
   * You can call the DescribeInstanceSpecs operation to query the specifications of multiple Anti-DDoS Pro or Anti-DDoS Premium instances at a time. The specifications include the clean bandwidth, protection bandwidth, function plan, and the numbers of domain names and ports that can be protected.
   * ### Limits
   * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
   * 
   * @param request - DescribeInstanceSpecsRequest
   * @returns DescribeInstanceSpecsResponse
   */
  async describeInstanceSpecs(request: DescribeInstanceSpecsRequest): Promise<DescribeInstanceSpecsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeInstanceSpecsWithOptions(request, runtime);
  }

  /**
   * Queries the statistics on one or more Anti-DDoS Proxy instances, such as the numbers of protected domain names and ports.
   * 
   * @param request - DescribeInstanceStatisticsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeInstanceStatisticsResponse
   */
  async describeInstanceStatisticsWithOptions(request: DescribeInstanceStatisticsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeInstanceStatisticsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceIds)) {
      query["InstanceIds"] = request.instanceIds;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeInstanceStatistics",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeInstanceStatisticsResponse>(await this.callApi(params, req, runtime), new DescribeInstanceStatisticsResponse({}));
  }

  /**
   * Queries the statistics on one or more Anti-DDoS Proxy instances, such as the numbers of protected domain names and ports.
   * 
   * @param request - DescribeInstanceStatisticsRequest
   * @returns DescribeInstanceStatisticsResponse
   */
  async describeInstanceStatistics(request: DescribeInstanceStatisticsRequest): Promise<DescribeInstanceStatisticsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeInstanceStatisticsWithOptions(request, runtime);
  }

  /**
   * Queries the status of a specified Anti-DDoS Proxy instance.
   * 
   * @param request - DescribeInstanceStatusRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeInstanceStatusResponse
   */
  async describeInstanceStatusWithOptions(request: DescribeInstanceStatusRequest, runtime: $Util.RuntimeOptions): Promise<DescribeInstanceStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.productType)) {
      query["ProductType"] = request.productType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeInstanceStatus",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeInstanceStatusResponse>(await this.callApi(params, req, runtime), new DescribeInstanceStatusResponse({}));
  }

  /**
   * Queries the status of a specified Anti-DDoS Proxy instance.
   * 
   * @param request - DescribeInstanceStatusRequest
   * @returns DescribeInstanceStatusResponse
   */
  async describeInstanceStatus(request: DescribeInstanceStatusRequest): Promise<DescribeInstanceStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeInstanceStatusWithOptions(request, runtime);
  }

  /**
   * @remarks
   * You can call the DescribeInstances operation to query the details of Anti-DDoS Pro or Anti-DDoS Premium instances within the Alibaba Cloud account by page. The details include the ID, mitigation plan, expiration time, and forwarding status.
   * 
   * @param request - DescribeInstancesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeInstancesResponse
   */
  async describeInstancesWithOptions(request: DescribeInstancesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeInstancesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.edition)) {
      query["Edition"] = request.edition;
    }

    if (!Util.isUnset(request.enabled)) {
      query["Enabled"] = request.enabled;
    }

    if (!Util.isUnset(request.expireEndTime)) {
      query["ExpireEndTime"] = request.expireEndTime;
    }

    if (!Util.isUnset(request.expireStartTime)) {
      query["ExpireStartTime"] = request.expireStartTime;
    }

    if (!Util.isUnset(request.instanceIds)) {
      query["InstanceIds"] = request.instanceIds;
    }

    if (!Util.isUnset(request.ip)) {
      query["Ip"] = request.ip;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.remark)) {
      query["Remark"] = request.remark;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeInstances",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeInstancesResponse>(await this.callApi(params, req, runtime), new DescribeInstancesResponse({}));
  }

  /**
   * @remarks
   * You can call the DescribeInstances operation to query the details of Anti-DDoS Pro or Anti-DDoS Premium instances within the Alibaba Cloud account by page. The details include the ID, mitigation plan, expiration time, and forwarding status.
   * 
   * @param request - DescribeInstancesRequest
   * @returns DescribeInstancesResponse
   */
  async describeInstances(request: DescribeInstancesRequest): Promise<DescribeInstancesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeInstancesWithOptions(request, runtime);
  }

  /**
   * Queries the back-to-origin policies for the forwarding rule of a website.
   * 
   * @param request - DescribeL7RsPolicyRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeL7RsPolicyResponse
   */
  async describeL7RsPolicyWithOptions(request: DescribeL7RsPolicyRequest, runtime: $Util.RuntimeOptions): Promise<DescribeL7RsPolicyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domain)) {
      query["Domain"] = request.domain;
    }

    if (!Util.isUnset(request.realServers)) {
      query["RealServers"] = request.realServers;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeL7RsPolicy",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeL7RsPolicyResponse>(await this.callApi(params, req, runtime), new DescribeL7RsPolicyResponse({}));
  }

  /**
   * Queries the back-to-origin policies for the forwarding rule of a website.
   * 
   * @param request - DescribeL7RsPolicyRequest
   * @returns DescribeL7RsPolicyResponse
   */
  async describeL7RsPolicy(request: DescribeL7RsPolicyRequest): Promise<DescribeL7RsPolicyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeL7RsPolicyWithOptions(request, runtime);
  }

  /**
   * Queries the configuration of back-to-origin persistent connections of a domain name.
   * 
   * @param request - DescribeL7UsKeepaliveRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeL7UsKeepaliveResponse
   */
  async describeL7UsKeepaliveWithOptions(request: DescribeL7UsKeepaliveRequest, runtime: $Util.RuntimeOptions): Promise<DescribeL7UsKeepaliveResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domain)) {
      query["Domain"] = request.domain;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeL7UsKeepalive",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeL7UsKeepaliveResponse>(await this.callApi(params, req, runtime), new DescribeL7UsKeepaliveResponse({}));
  }

  /**
   * Queries the configuration of back-to-origin persistent connections of a domain name.
   * 
   * @param request - DescribeL7UsKeepaliveRequest
   * @returns DescribeL7UsKeepaliveResponse
   */
  async describeL7UsKeepalive(request: DescribeL7UsKeepaliveRequest): Promise<DescribeL7UsKeepaliveResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeL7UsKeepaliveWithOptions(request, runtime);
  }

  /**
   * Queries the back-to-origin settings of a port forwarding rule.
   * 
   * @param request - DescribeLayer4RulePolicyRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeLayer4RulePolicyResponse
   */
  async describeLayer4RulePolicyWithOptions(request: DescribeLayer4RulePolicyRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLayer4RulePolicyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.listeners)) {
      query["Listeners"] = request.listeners;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLayer4RulePolicy",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLayer4RulePolicyResponse>(await this.callApi(params, req, runtime), new DescribeLayer4RulePolicyResponse({}));
  }

  /**
   * Queries the back-to-origin settings of a port forwarding rule.
   * 
   * @param request - DescribeLayer4RulePolicyRequest
   * @returns DescribeLayer4RulePolicyResponse
   */
  async describeLayer4RulePolicy(request: DescribeLayer4RulePolicyRequest): Promise<DescribeLayer4RulePolicyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLayer4RulePolicyWithOptions(request, runtime);
  }

  /**
   * Checks whether a Logstore is created for Anti-DDoS Pro or Anti-DDoS Premium.
   * 
   * @param request - DescribeLogStoreExistStatusRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeLogStoreExistStatusResponse
   */
  async describeLogStoreExistStatusWithOptions(request: DescribeLogStoreExistStatusRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLogStoreExistStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLogStoreExistStatus",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLogStoreExistStatusResponse>(await this.callApi(params, req, runtime), new DescribeLogStoreExistStatusResponse({}));
  }

  /**
   * Checks whether a Logstore is created for Anti-DDoS Pro or Anti-DDoS Premium.
   * 
   * @param request - DescribeLogStoreExistStatusRequest
   * @returns DescribeLogStoreExistStatusResponse
   */
  async describeLogStoreExistStatus(request: DescribeLogStoreExistStatusRequest): Promise<DescribeLogStoreExistStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLogStoreExistStatusWithOptions(request, runtime);
  }

  /**
   * Queries the blocked locations that are configured for an Anti-DDoS Pro or Anti-DDoS Premium instance.
   * 
   * @param request - DescribeNetworkRegionBlockRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeNetworkRegionBlockResponse
   */
  async describeNetworkRegionBlockWithOptions(request: DescribeNetworkRegionBlockRequest, runtime: $Util.RuntimeOptions): Promise<DescribeNetworkRegionBlockResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeNetworkRegionBlock",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeNetworkRegionBlockResponse>(await this.callApi(params, req, runtime), new DescribeNetworkRegionBlockResponse({}));
  }

  /**
   * Queries the blocked locations that are configured for an Anti-DDoS Pro or Anti-DDoS Premium instance.
   * 
   * @param request - DescribeNetworkRegionBlockRequest
   * @returns DescribeNetworkRegionBlockResponse
   */
  async describeNetworkRegionBlock(request: DescribeNetworkRegionBlockRequest): Promise<DescribeNetworkRegionBlockResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeNetworkRegionBlockWithOptions(request, runtime);
  }

  /**
   * Queries the mitigation settings of the port forwarding rule for a non-website service. The mitigation settings include session persistence and DDoS mitigation policies.
   * 
   * @param request - DescribeNetworkRuleAttributesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeNetworkRuleAttributesResponse
   */
  async describeNetworkRuleAttributesWithOptions(request: DescribeNetworkRuleAttributesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeNetworkRuleAttributesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.networkRules)) {
      query["NetworkRules"] = request.networkRules;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeNetworkRuleAttributes",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeNetworkRuleAttributesResponse>(await this.callApi(params, req, runtime), new DescribeNetworkRuleAttributesResponse({}));
  }

  /**
   * Queries the mitigation settings of the port forwarding rule for a non-website service. The mitigation settings include session persistence and DDoS mitigation policies.
   * 
   * @param request - DescribeNetworkRuleAttributesRequest
   * @returns DescribeNetworkRuleAttributesResponse
   */
  async describeNetworkRuleAttributes(request: DescribeNetworkRuleAttributesRequest): Promise<DescribeNetworkRuleAttributesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeNetworkRuleAttributesWithOptions(request, runtime);
  }

  /**
   * Queries port forwarding rules.
   * 
   * @param request - DescribeNetworkRulesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeNetworkRulesResponse
   */
  async describeNetworkRulesWithOptions(request: DescribeNetworkRulesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeNetworkRulesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.forwardProtocol)) {
      query["ForwardProtocol"] = request.forwardProtocol;
    }

    if (!Util.isUnset(request.frontendPort)) {
      query["FrontendPort"] = request.frontendPort;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeNetworkRules",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeNetworkRulesResponse>(await this.callApi(params, req, runtime), new DescribeNetworkRulesResponse({}));
  }

  /**
   * Queries port forwarding rules.
   * 
   * @param request - DescribeNetworkRulesRequest
   * @returns DescribeNetworkRulesResponse
   */
  async describeNetworkRules(request: DescribeNetworkRulesRequest): Promise<DescribeNetworkRulesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeNetworkRulesWithOptions(request, runtime);
  }

  /**
   * Queries the operation logs of Anti-DDoS Pro.
   * 
   * @remarks
   * > This operation is suitable only for Anti-DDoS Pro.
   * You can query operations performed on Anti-DDoS Pro, such as configuring burstable protection bandwidth, deactivating blackhole filtering, configuring the Diversion from Origin Server policy, using Anti-DDoS plans, changing the IP addresses of Elastic Compute Service (ECS) instances, and clearing all logs.
   * 
   * @param request - DescribeOpEntitiesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeOpEntitiesResponse
   */
  async describeOpEntitiesWithOptions(request: DescribeOpEntitiesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeOpEntitiesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.entityObject)) {
      query["EntityObject"] = request.entityObject;
    }

    if (!Util.isUnset(request.entityType)) {
      query["EntityType"] = request.entityType;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeOpEntities",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeOpEntitiesResponse>(await this.callApi(params, req, runtime), new DescribeOpEntitiesResponse({}));
  }

  /**
   * Queries the operation logs of Anti-DDoS Pro.
   * 
   * @remarks
   * > This operation is suitable only for Anti-DDoS Pro.
   * You can query operations performed on Anti-DDoS Pro, such as configuring burstable protection bandwidth, deactivating blackhole filtering, configuring the Diversion from Origin Server policy, using Anti-DDoS plans, changing the IP addresses of Elastic Compute Service (ECS) instances, and clearing all logs.
   * 
   * @param request - DescribeOpEntitiesRequest
   * @returns DescribeOpEntitiesResponse
   */
  async describeOpEntities(request: DescribeOpEntitiesRequest): Promise<DescribeOpEntitiesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeOpEntitiesWithOptions(request, runtime);
  }

  /**
   * Queries the port forwarding rules that are created for an Anti-DDoS Pro or Anti-DDoS Premium instance.
   * 
   * @remarks
   * You can call this operation by using Terraform. For more information about Terraform, see [What is Terraform?](https://help.aliyun.com/document_detail/95820.html).
   * 
   * @param request - DescribePortRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribePortResponse
   */
  async describePortWithOptions(request: DescribePortRequest, runtime: $Util.RuntimeOptions): Promise<DescribePortResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.frontendPort)) {
      query["FrontendPort"] = request.frontendPort;
    }

    if (!Util.isUnset(request.frontendProtocol)) {
      query["FrontendProtocol"] = request.frontendProtocol;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribePort",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribePortResponse>(await this.callApi(params, req, runtime), new DescribePortResponse({}));
  }

  /**
   * Queries the port forwarding rules that are created for an Anti-DDoS Pro or Anti-DDoS Premium instance.
   * 
   * @remarks
   * You can call this operation by using Terraform. For more information about Terraform, see [What is Terraform?](https://help.aliyun.com/document_detail/95820.html).
   * 
   * @param request - DescribePortRequest
   * @returns DescribePortResponse
   */
  async describePort(request: DescribePortRequest): Promise<DescribePortResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describePortWithOptions(request, runtime);
  }

  /**
   * Queries the peak attack traffic bandwidth and peak attack traffic packet rates of one or more Anti-DDoS Pro or Anti-DDoS Premium instances within a specified period of time.
   * 
   * @remarks
   * You can call this operation to query the peak bandwidth and peak packet rate of attack traffic on one or more Anti-DDoS Pro or Anti-DDoS Premium instances within a specific period of time.
   * ### Limits
   * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
   * 
   * @param request - DescribePortAttackMaxFlowRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribePortAttackMaxFlowResponse
   */
  async describePortAttackMaxFlowWithOptions(request: DescribePortAttackMaxFlowRequest, runtime: $Util.RuntimeOptions): Promise<DescribePortAttackMaxFlowResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.instanceIds)) {
      query["InstanceIds"] = request.instanceIds;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribePortAttackMaxFlow",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribePortAttackMaxFlowResponse>(await this.callApi(params, req, runtime), new DescribePortAttackMaxFlowResponse({}));
  }

  /**
   * Queries the peak attack traffic bandwidth and peak attack traffic packet rates of one or more Anti-DDoS Pro or Anti-DDoS Premium instances within a specified period of time.
   * 
   * @remarks
   * You can call this operation to query the peak bandwidth and peak packet rate of attack traffic on one or more Anti-DDoS Pro or Anti-DDoS Premium instances within a specific period of time.
   * ### Limits
   * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
   * 
   * @param request - DescribePortAttackMaxFlowRequest
   * @returns DescribePortAttackMaxFlowResponse
   */
  async describePortAttackMaxFlow(request: DescribePortAttackMaxFlowRequest): Promise<DescribePortAttackMaxFlowResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describePortAttackMaxFlowWithOptions(request, runtime);
  }

  /**
   * Queries the configurations of the Intelligent Protection policy for non-website services.
   * 
   * @param request - DescribePortAutoCcStatusRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribePortAutoCcStatusResponse
   */
  async describePortAutoCcStatusWithOptions(request: DescribePortAutoCcStatusRequest, runtime: $Util.RuntimeOptions): Promise<DescribePortAutoCcStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceIds)) {
      query["InstanceIds"] = request.instanceIds;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribePortAutoCcStatus",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribePortAutoCcStatusResponse>(await this.callApi(params, req, runtime), new DescribePortAutoCcStatusResponse({}));
  }

  /**
   * Queries the configurations of the Intelligent Protection policy for non-website services.
   * 
   * @param request - DescribePortAutoCcStatusRequest
   * @returns DescribePortAutoCcStatusResponse
   */
  async describePortAutoCcStatus(request: DescribePortAutoCcStatusRequest): Promise<DescribePortAutoCcStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describePortAutoCcStatusWithOptions(request, runtime);
  }

  /**
   * Queries the top source IP addresses of the volumetric attack events for the Anti-DDoS Pro or Anti-DDoS Premium instance.
   * 
   * @param request - DescribePortCcAttackTopIPRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribePortCcAttackTopIPResponse
   */
  async describePortCcAttackTopIPWithOptions(request: DescribePortCcAttackTopIPRequest, runtime: $Util.RuntimeOptions): Promise<DescribePortCcAttackTopIPResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ip)) {
      query["Ip"] = request.ip;
    }

    if (!Util.isUnset(request.limit)) {
      query["Limit"] = request.limit;
    }

    if (!Util.isUnset(request.port)) {
      query["Port"] = request.port;
    }

    if (!Util.isUnset(request.startTimestamp)) {
      query["StartTimestamp"] = request.startTimestamp;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribePortCcAttackTopIP",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribePortCcAttackTopIPResponse>(await this.callApi(params, req, runtime), new DescribePortCcAttackTopIPResponse({}));
  }

  /**
   * Queries the top source IP addresses of the volumetric attack events for the Anti-DDoS Pro or Anti-DDoS Premium instance.
   * 
   * @param request - DescribePortCcAttackTopIPRequest
   * @returns DescribePortCcAttackTopIPResponse
   */
  async describePortCcAttackTopIP(request: DescribePortCcAttackTopIPRequest): Promise<DescribePortCcAttackTopIPResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describePortCcAttackTopIPWithOptions(request, runtime);
  }

  /**
   * The statistics on the connections established over the ports of one or more Anti-DDoS Pro or Anti-DDoS Premium instances are queried.
   * 
   * @param request - DescribePortConnsCountRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribePortConnsCountResponse
   */
  async describePortConnsCountWithOptions(request: DescribePortConnsCountRequest, runtime: $Util.RuntimeOptions): Promise<DescribePortConnsCountResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.instanceIds)) {
      query["InstanceIds"] = request.instanceIds;
    }

    if (!Util.isUnset(request.port)) {
      query["Port"] = request.port;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribePortConnsCount",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribePortConnsCountResponse>(await this.callApi(params, req, runtime), new DescribePortConnsCountResponse({}));
  }

  /**
   * The statistics on the connections established over the ports of one or more Anti-DDoS Pro or Anti-DDoS Premium instances are queried.
   * 
   * @param request - DescribePortConnsCountRequest
   * @returns DescribePortConnsCountResponse
   */
  async describePortConnsCount(request: DescribePortConnsCountRequest): Promise<DescribePortConnsCountResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describePortConnsCountWithOptions(request, runtime);
  }

  /**
   * Queries the connections established over the ports of one or more Anti-DDoS Proxy instances.
   * 
   * @param request - DescribePortConnsListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribePortConnsListResponse
   */
  async describePortConnsListWithOptions(request: DescribePortConnsListRequest, runtime: $Util.RuntimeOptions): Promise<DescribePortConnsListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.instanceIds)) {
      query["InstanceIds"] = request.instanceIds;
    }

    if (!Util.isUnset(request.interval)) {
      query["Interval"] = request.interval;
    }

    if (!Util.isUnset(request.port)) {
      query["Port"] = request.port;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribePortConnsList",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribePortConnsListResponse>(await this.callApi(params, req, runtime), new DescribePortConnsListResponse({}));
  }

  /**
   * Queries the connections established over the ports of one or more Anti-DDoS Proxy instances.
   * 
   * @param request - DescribePortConnsListRequest
   * @returns DescribePortConnsListResponse
   */
  async describePortConnsList(request: DescribePortConnsListRequest): Promise<DescribePortConnsListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describePortConnsListWithOptions(request, runtime);
  }

  /**
   * Queries the traffic data of one or more Anti-DDoS Pro or Anti-DDoS Premium instances.
   * 
   * @param request - DescribePortFlowListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribePortFlowListResponse
   */
  async describePortFlowListWithOptions(request: DescribePortFlowListRequest, runtime: $Util.RuntimeOptions): Promise<DescribePortFlowListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.instanceIds)) {
      query["InstanceIds"] = request.instanceIds;
    }

    if (!Util.isUnset(request.interval)) {
      query["Interval"] = request.interval;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribePortFlowList",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribePortFlowListResponse>(await this.callApi(params, req, runtime), new DescribePortFlowListResponse({}));
  }

  /**
   * Queries the traffic data of one or more Anti-DDoS Pro or Anti-DDoS Premium instances.
   * 
   * @param request - DescribePortFlowListRequest
   * @returns DescribePortFlowListResponse
   */
  async describePortFlowList(request: DescribePortFlowListRequest): Promise<DescribePortFlowListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describePortFlowListWithOptions(request, runtime);
  }

  /**
   * Queries the maximum number of connections that can be established over the ports of one or more Anti-DDoS Pro or Anti-DDoS Premium instances.
   * 
   * @param request - DescribePortMaxConnsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribePortMaxConnsResponse
   */
  async describePortMaxConnsWithOptions(request: DescribePortMaxConnsRequest, runtime: $Util.RuntimeOptions): Promise<DescribePortMaxConnsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.instanceIds)) {
      query["InstanceIds"] = request.instanceIds;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribePortMaxConns",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribePortMaxConnsResponse>(await this.callApi(params, req, runtime), new DescribePortMaxConnsResponse({}));
  }

  /**
   * Queries the maximum number of connections that can be established over the ports of one or more Anti-DDoS Pro or Anti-DDoS Premium instances.
   * 
   * @param request - DescribePortMaxConnsRequest
   * @returns DescribePortMaxConnsResponse
   */
  async describePortMaxConns(request: DescribePortMaxConnsRequest): Promise<DescribePortMaxConnsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describePortMaxConnsWithOptions(request, runtime);
  }

  /**
   * Queries the areas and countries from which requests are sent to one or more Anti-DDoS Pro or Anti-DDoS Premium instances within the specified period of time.
   * 
   * @param request - DescribePortViewSourceCountriesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribePortViewSourceCountriesResponse
   */
  async describePortViewSourceCountriesWithOptions(request: DescribePortViewSourceCountriesRequest, runtime: $Util.RuntimeOptions): Promise<DescribePortViewSourceCountriesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.instanceIds)) {
      query["InstanceIds"] = request.instanceIds;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribePortViewSourceCountries",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribePortViewSourceCountriesResponse>(await this.callApi(params, req, runtime), new DescribePortViewSourceCountriesResponse({}));
  }

  /**
   * Queries the areas and countries from which requests are sent to one or more Anti-DDoS Pro or Anti-DDoS Premium instances within the specified period of time.
   * 
   * @param request - DescribePortViewSourceCountriesRequest
   * @returns DescribePortViewSourceCountriesResponse
   */
  async describePortViewSourceCountries(request: DescribePortViewSourceCountriesRequest): Promise<DescribePortViewSourceCountriesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describePortViewSourceCountriesWithOptions(request, runtime);
  }

  /**
   * Queries the Internet service providers (ISPs) from which requests are sent to one or more Anti-DDoS Pro or Anti-DDoS Premium instances within the specified period of time.
   * 
   * @remarks
   * You can call the DescribePortViewSourceIsps operation to query the ISPs from which requests are sent to one or more Anti-DDoS Pro or Anti-DDoS Premium instances within a specific period of time.
   * > The data returned for this operation cannot reflect the actual traffic volume because Layer 4 identity authentication algorithms are updated for Anti-DDoS Pro and Anti-DDoS Premium. You can call this operation to calculate only the proportion of requests sent from different ISPs. If you want to query the request traffic volume, we recommend that you call the [DescribePortFlowList](https://help.aliyun.com/document_detail/157460.html) operation.
   * ### Limits
   * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
   * 
   * @param request - DescribePortViewSourceIspsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribePortViewSourceIspsResponse
   */
  async describePortViewSourceIspsWithOptions(request: DescribePortViewSourceIspsRequest, runtime: $Util.RuntimeOptions): Promise<DescribePortViewSourceIspsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.instanceIds)) {
      query["InstanceIds"] = request.instanceIds;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribePortViewSourceIsps",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribePortViewSourceIspsResponse>(await this.callApi(params, req, runtime), new DescribePortViewSourceIspsResponse({}));
  }

  /**
   * Queries the Internet service providers (ISPs) from which requests are sent to one or more Anti-DDoS Pro or Anti-DDoS Premium instances within the specified period of time.
   * 
   * @remarks
   * You can call the DescribePortViewSourceIsps operation to query the ISPs from which requests are sent to one or more Anti-DDoS Pro or Anti-DDoS Premium instances within a specific period of time.
   * > The data returned for this operation cannot reflect the actual traffic volume because Layer 4 identity authentication algorithms are updated for Anti-DDoS Pro and Anti-DDoS Premium. You can call this operation to calculate only the proportion of requests sent from different ISPs. If you want to query the request traffic volume, we recommend that you call the [DescribePortFlowList](https://help.aliyun.com/document_detail/157460.html) operation.
   * ### Limits
   * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
   * 
   * @param request - DescribePortViewSourceIspsRequest
   * @returns DescribePortViewSourceIspsResponse
   */
  async describePortViewSourceIsps(request: DescribePortViewSourceIspsRequest): Promise<DescribePortViewSourceIspsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describePortViewSourceIspsWithOptions(request, runtime);
  }

  /**
   * Queries the administrative regions in China from which requests are sent to one or more Anti-DDoS Pro or Anti-DDoS Premium instances within a specified period of time.
   * 
   * @param request - DescribePortViewSourceProvincesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribePortViewSourceProvincesResponse
   */
  async describePortViewSourceProvincesWithOptions(request: DescribePortViewSourceProvincesRequest, runtime: $Util.RuntimeOptions): Promise<DescribePortViewSourceProvincesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.instanceIds)) {
      query["InstanceIds"] = request.instanceIds;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribePortViewSourceProvinces",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribePortViewSourceProvincesResponse>(await this.callApi(params, req, runtime), new DescribePortViewSourceProvincesResponse({}));
  }

  /**
   * Queries the administrative regions in China from which requests are sent to one or more Anti-DDoS Pro or Anti-DDoS Premium instances within a specified period of time.
   * 
   * @param request - DescribePortViewSourceProvincesRequest
   * @returns DescribePortViewSourceProvincesResponse
   */
  async describePortViewSourceProvinces(request: DescribePortViewSourceProvincesRequest): Promise<DescribePortViewSourceProvincesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describePortViewSourceProvincesWithOptions(request, runtime);
  }

  /**
   * Queries the protected objects of a scenario-specific custom policy.
   * 
   * @remarks
   * You can call the DescribeSceneDefenseObjects operation to query the protected objects of a scenario-specific custom policy.
   * Before you call this operation, make sure that you have created a scenario-specific custom policy by calling the [CreateSceneDefensePolicy](https://help.aliyun.com/document_detail/159779.html) operation.
   * ### Limits
   * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
   * 
   * @param request - DescribeSceneDefenseObjectsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeSceneDefenseObjectsResponse
   */
  async describeSceneDefenseObjectsWithOptions(request: DescribeSceneDefenseObjectsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeSceneDefenseObjectsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.policyId)) {
      query["PolicyId"] = request.policyId;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeSceneDefenseObjects",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeSceneDefenseObjectsResponse>(await this.callApi(params, req, runtime), new DescribeSceneDefenseObjectsResponse({}));
  }

  /**
   * Queries the protected objects of a scenario-specific custom policy.
   * 
   * @remarks
   * You can call the DescribeSceneDefenseObjects operation to query the protected objects of a scenario-specific custom policy.
   * Before you call this operation, make sure that you have created a scenario-specific custom policy by calling the [CreateSceneDefensePolicy](https://help.aliyun.com/document_detail/159779.html) operation.
   * ### Limits
   * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
   * 
   * @param request - DescribeSceneDefenseObjectsRequest
   * @returns DescribeSceneDefenseObjectsResponse
   */
  async describeSceneDefenseObjects(request: DescribeSceneDefenseObjectsRequest): Promise<DescribeSceneDefenseObjectsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeSceneDefenseObjectsWithOptions(request, runtime);
  }

  /**
   * Queries the configurations of a scenario-specific custom policy.
   * 
   * @remarks
   * You can call the DescribeSceneDefensePolicies operation to query the configurations of a scenario-specific custom policy that is created. For example, you can query the status, protected objects, and protection rules of the policy.
   * ### Limits
   * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
   * 
   * @param request - DescribeSceneDefensePoliciesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeSceneDefensePoliciesResponse
   */
  async describeSceneDefensePoliciesWithOptions(request: DescribeSceneDefensePoliciesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeSceneDefensePoliciesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    if (!Util.isUnset(request.template)) {
      query["Template"] = request.template;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeSceneDefensePolicies",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeSceneDefensePoliciesResponse>(await this.callApi(params, req, runtime), new DescribeSceneDefensePoliciesResponse({}));
  }

  /**
   * Queries the configurations of a scenario-specific custom policy.
   * 
   * @remarks
   * You can call the DescribeSceneDefensePolicies operation to query the configurations of a scenario-specific custom policy that is created. For example, you can query the status, protected objects, and protection rules of the policy.
   * ### Limits
   * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
   * 
   * @param request - DescribeSceneDefensePoliciesRequest
   * @returns DescribeSceneDefensePoliciesResponse
   */
  async describeSceneDefensePolicies(request: DescribeSceneDefensePoliciesRequest): Promise<DescribeSceneDefensePoliciesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeSceneDefensePoliciesWithOptions(request, runtime);
  }

  /**
   * @param request - DescribeSchedulerRulesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeSchedulerRulesResponse
   */
  async describeSchedulerRulesWithOptions(request: DescribeSchedulerRulesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeSchedulerRulesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.ruleName)) {
      query["RuleName"] = request.ruleName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeSchedulerRules",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeSchedulerRulesResponse>(await this.callApi(params, req, runtime), new DescribeSchedulerRulesResponse({}));
  }

  /**
   * @param request - DescribeSchedulerRulesRequest
   * @returns DescribeSchedulerRulesResponse
   */
  async describeSchedulerRules(request: DescribeSchedulerRulesRequest): Promise<DescribeSchedulerRulesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeSchedulerRulesWithOptions(request, runtime);
  }

  /**
   * Queries the destination rate limit events.
   * 
   * @param request - DescribeSlaEventListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeSlaEventListResponse
   */
  async describeSlaEventListWithOptions(request: DescribeSlaEventListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeSlaEventListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.ip)) {
      query["Ip"] = request.ip;
    }

    if (!Util.isUnset(request.page)) {
      query["Page"] = request.page;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.region)) {
      query["Region"] = request.region;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeSlaEventList",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeSlaEventListResponse>(await this.callApi(params, req, runtime), new DescribeSlaEventListResponse({}));
  }

  /**
   * Queries the destination rate limit events.
   * 
   * @param request - DescribeSlaEventListRequest
   * @returns DescribeSlaEventListResponse
   */
  async describeSlaEventList(request: DescribeSlaEventListRequest): Promise<DescribeSlaEventListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeSlaEventListWithOptions(request, runtime);
  }

  /**
   * Queries whether Anti-DDoS Pro or Anti-DDoS Premium is authorized to access Log Service.
   * 
   * @param request - DescribeSlsAuthStatusRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeSlsAuthStatusResponse
   */
  async describeSlsAuthStatusWithOptions(request: DescribeSlsAuthStatusRequest, runtime: $Util.RuntimeOptions): Promise<DescribeSlsAuthStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeSlsAuthStatus",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeSlsAuthStatusResponse>(await this.callApi(params, req, runtime), new DescribeSlsAuthStatusResponse({}));
  }

  /**
   * Queries whether Anti-DDoS Pro or Anti-DDoS Premium is authorized to access Log Service.
   * 
   * @param request - DescribeSlsAuthStatusRequest
   * @returns DescribeSlsAuthStatusResponse
   */
  async describeSlsAuthStatus(request: DescribeSlsAuthStatusRequest): Promise<DescribeSlsAuthStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeSlsAuthStatusWithOptions(request, runtime);
  }

  /**
   * Queries the information about the Logstore of the Anti-DDoS Pro or Anti-DDoS Premium instance, such as the log storage capacity and log storage duration.
   * 
   * @param request - DescribeSlsLogstoreInfoRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeSlsLogstoreInfoResponse
   */
  async describeSlsLogstoreInfoWithOptions(request: DescribeSlsLogstoreInfoRequest, runtime: $Util.RuntimeOptions): Promise<DescribeSlsLogstoreInfoResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeSlsLogstoreInfo",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeSlsLogstoreInfoResponse>(await this.callApi(params, req, runtime), new DescribeSlsLogstoreInfoResponse({}));
  }

  /**
   * Queries the information about the Logstore of the Anti-DDoS Pro or Anti-DDoS Premium instance, such as the log storage capacity and log storage duration.
   * 
   * @param request - DescribeSlsLogstoreInfoRequest
   * @returns DescribeSlsLogstoreInfoResponse
   */
  async describeSlsLogstoreInfo(request: DescribeSlsLogstoreInfoRequest): Promise<DescribeSlsLogstoreInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeSlsLogstoreInfoWithOptions(request, runtime);
  }

  /**
   * Checks whether Log Service is activated.
   * 
   * @param request - DescribeSlsOpenStatusRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeSlsOpenStatusResponse
   */
  async describeSlsOpenStatusWithOptions(request: DescribeSlsOpenStatusRequest, runtime: $Util.RuntimeOptions): Promise<DescribeSlsOpenStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeSlsOpenStatus",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeSlsOpenStatusResponse>(await this.callApi(params, req, runtime), new DescribeSlsOpenStatusResponse({}));
  }

  /**
   * Checks whether Log Service is activated.
   * 
   * @param request - DescribeSlsOpenStatusRequest
   * @returns DescribeSlsOpenStatusResponse
   */
  async describeSlsOpenStatus(request: DescribeSlsOpenStatusRequest): Promise<DescribeSlsOpenStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeSlsOpenStatusWithOptions(request, runtime);
  }

  /**
   * Queries whether Anti-DDoS Pro or Anti-DDoS Premium is authorized to access other cloud services.
   * 
   * @remarks
   * You can call the DescribeStsGrantStatus operation to query whether Anti-DDoS Pro or Anti-DDoS Premium of the current Alibaba Cloud account is authorized to access other cloud services.
   * ### Limits
   * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
   * 
   * @param request - DescribeStsGrantStatusRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeStsGrantStatusResponse
   */
  async describeStsGrantStatusWithOptions(request: DescribeStsGrantStatusRequest, runtime: $Util.RuntimeOptions): Promise<DescribeStsGrantStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.role)) {
      query["Role"] = request.role;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeStsGrantStatus",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeStsGrantStatusResponse>(await this.callApi(params, req, runtime), new DescribeStsGrantStatusResponse({}));
  }

  /**
   * Queries whether Anti-DDoS Pro or Anti-DDoS Premium is authorized to access other cloud services.
   * 
   * @remarks
   * You can call the DescribeStsGrantStatus operation to query whether Anti-DDoS Pro or Anti-DDoS Premium of the current Alibaba Cloud account is authorized to access other cloud services.
   * ### Limits
   * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
   * 
   * @param request - DescribeStsGrantStatusRequest
   * @returns DescribeStsGrantStatusResponse
   */
  async describeStsGrantStatus(request: DescribeStsGrantStatusRequest): Promise<DescribeStsGrantStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeStsGrantStatusWithOptions(request, runtime);
  }

  /**
   * Queries the details of the bills for the burstable clean bandwidth.
   * 
   * @remarks
   * You can call the DescribeSystemLog operation to query the system logs of Anti-DDoS Pro or Anti-DDoS Premium. The system logs contain only billing logs for the burstable clean bandwidth.
   * If you have enabled the burstable clean bandwidth feature, you can call this operation to query the details of the bills of the burstable clean bandwidth.
   * ### Limits
   * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
   * 
   * @param request - DescribeSystemLogRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeSystemLogResponse
   */
  async describeSystemLogWithOptions(request: DescribeSystemLogRequest, runtime: $Util.RuntimeOptions): Promise<DescribeSystemLogResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.entityObject)) {
      query["EntityObject"] = request.entityObject;
    }

    if (!Util.isUnset(request.entityType)) {
      query["EntityType"] = request.entityType;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeSystemLog",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeSystemLogResponse>(await this.callApi(params, req, runtime), new DescribeSystemLogResponse({}));
  }

  /**
   * Queries the details of the bills for the burstable clean bandwidth.
   * 
   * @remarks
   * You can call the DescribeSystemLog operation to query the system logs of Anti-DDoS Pro or Anti-DDoS Premium. The system logs contain only billing logs for the burstable clean bandwidth.
   * If you have enabled the burstable clean bandwidth feature, you can call this operation to query the details of the bills of the burstable clean bandwidth.
   * ### Limits
   * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
   * 
   * @param request - DescribeSystemLogRequest
   * @returns DescribeSystemLogResponse
   */
  async describeSystemLog(request: DescribeSystemLogRequest): Promise<DescribeSystemLogResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeSystemLogWithOptions(request, runtime);
  }

  /**
   * Queries all tag keys and the number of Anti-DDoS Proxy (Chinese Mainland) instances to which each tag key is added.
   * 
   * @remarks
   * You can call this operation to query all tag keys and the number of Anti-DDoS Proxy (Chinese Mainland) instances to which each tag key is added by page.
   * >  Only Anti-DDoS Proxy (Chinese Mainland) supports tags.
   * ### [](#qps-)QPS limits
   * You can call this operation up to 10 times per second per account. If the number of calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
   * 
   * @param request - DescribeTagKeysRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeTagKeysResponse
   */
  async describeTagKeysWithOptions(request: DescribeTagKeysRequest, runtime: $Util.RuntimeOptions): Promise<DescribeTagKeysResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.resourceType)) {
      query["ResourceType"] = request.resourceType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeTagKeys",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeTagKeysResponse>(await this.callApi(params, req, runtime), new DescribeTagKeysResponse({}));
  }

  /**
   * Queries all tag keys and the number of Anti-DDoS Proxy (Chinese Mainland) instances to which each tag key is added.
   * 
   * @remarks
   * You can call this operation to query all tag keys and the number of Anti-DDoS Proxy (Chinese Mainland) instances to which each tag key is added by page.
   * >  Only Anti-DDoS Proxy (Chinese Mainland) supports tags.
   * ### [](#qps-)QPS limits
   * You can call this operation up to 10 times per second per account. If the number of calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
   * 
   * @param request - DescribeTagKeysRequest
   * @returns DescribeTagKeysResponse
   */
  async describeTagKeys(request: DescribeTagKeysRequest): Promise<DescribeTagKeysResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeTagKeysWithOptions(request, runtime);
  }

  /**
   * Queries the information about the tags that are added to an Anti-DDoS Proxy (Chinese Mainland) instance.
   * 
   * @remarks
   * You can call the DescribeTagResources operation to query the information about the tags that are added to an Anti-DDoS Proxy (Chinese Mainland) instance.
   * >  Only Anti-DDoS Proxy (Chinese Mainland) supports tags.
   * ### [](#qps-)QPS limits
   * You can call this operation up to 10 times per second per account. If the number of calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
   * 
   * @param request - DescribeTagResourcesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeTagResourcesResponse
   */
  async describeTagResourcesWithOptions(request: DescribeTagResourcesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeTagResourcesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.resourceIds)) {
      query["ResourceIds"] = request.resourceIds;
    }

    if (!Util.isUnset(request.resourceType)) {
      query["ResourceType"] = request.resourceType;
    }

    if (!Util.isUnset(request.tags)) {
      query["Tags"] = request.tags;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeTagResources",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeTagResourcesResponse>(await this.callApi(params, req, runtime), new DescribeTagResourcesResponse({}));
  }

  /**
   * Queries the information about the tags that are added to an Anti-DDoS Proxy (Chinese Mainland) instance.
   * 
   * @remarks
   * You can call the DescribeTagResources operation to query the information about the tags that are added to an Anti-DDoS Proxy (Chinese Mainland) instance.
   * >  Only Anti-DDoS Proxy (Chinese Mainland) supports tags.
   * ### [](#qps-)QPS limits
   * You can call this operation up to 10 times per second per account. If the number of calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
   * 
   * @param request - DescribeTagResourcesRequest
   * @returns DescribeTagResourcesResponse
   */
  async describeTagResources(request: DescribeTagResourcesRequest): Promise<DescribeTagResourcesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeTagResourcesWithOptions(request, runtime);
  }

  /**
   * Queries the peak bandwidth and peak packet rates of attack traffic on one or more Anti-DDoS Pro or Anti-DDoS Premium instances within a specific period of time.
   * 
   * @param request - DescribeTotalAttackMaxFlowRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeTotalAttackMaxFlowResponse
   */
  async describeTotalAttackMaxFlowWithOptions(request: DescribeTotalAttackMaxFlowRequest, runtime: $Util.RuntimeOptions): Promise<DescribeTotalAttackMaxFlowResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.instanceIds)) {
      query["InstanceIds"] = request.instanceIds;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeTotalAttackMaxFlow",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeTotalAttackMaxFlowResponse>(await this.callApi(params, req, runtime), new DescribeTotalAttackMaxFlowResponse({}));
  }

  /**
   * Queries the peak bandwidth and peak packet rates of attack traffic on one or more Anti-DDoS Pro or Anti-DDoS Premium instances within a specific period of time.
   * 
   * @param request - DescribeTotalAttackMaxFlowRequest
   * @returns DescribeTotalAttackMaxFlowResponse
   */
  async describeTotalAttackMaxFlow(request: DescribeTotalAttackMaxFlowRequest): Promise<DescribeTotalAttackMaxFlowResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeTotalAttackMaxFlowWithOptions(request, runtime);
  }

  /**
   * Queries the source ports of UDP traffic that are filtered out by the filtering policies for UDP reflection attacks on an Anti-DDoS Pro or Anti-DDoS Premium instance.
   * 
   * @param request - DescribeUdpReflectRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeUdpReflectResponse
   */
  async describeUdpReflectWithOptions(request: DescribeUdpReflectRequest, runtime: $Util.RuntimeOptions): Promise<DescribeUdpReflectResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeUdpReflect",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeUdpReflectResponse>(await this.callApi(params, req, runtime), new DescribeUdpReflectResponse({}));
  }

  /**
   * Queries the source ports of UDP traffic that are filtered out by the filtering policies for UDP reflection attacks on an Anti-DDoS Pro or Anti-DDoS Premium instance.
   * 
   * @param request - DescribeUdpReflectRequest
   * @returns DescribeUdpReflectResponse
   */
  async describeUdpReflect(request: DescribeUdpReflectRequest): Promise<DescribeUdpReflectResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeUdpReflectWithOptions(request, runtime);
  }

  /**
   * Queries the total quota and remaining quota that allow you to deactivate blackhole filtering.
   * 
   * @param request - DescribeUnBlackholeCountRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeUnBlackholeCountResponse
   */
  async describeUnBlackholeCountWithOptions(request: DescribeUnBlackholeCountRequest, runtime: $Util.RuntimeOptions): Promise<DescribeUnBlackholeCountResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeUnBlackholeCount",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeUnBlackholeCountResponse>(await this.callApi(params, req, runtime), new DescribeUnBlackholeCountResponse({}));
  }

  /**
   * Queries the total quota and remaining quota that allow you to deactivate blackhole filtering.
   * 
   * @param request - DescribeUnBlackholeCountRequest
   * @returns DescribeUnBlackholeCountResponse
   */
  async describeUnBlackholeCount(request: DescribeUnBlackholeCountRequest): Promise<DescribeUnBlackholeCountResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeUnBlackholeCountWithOptions(request, runtime);
  }

  /**
   * Queries the remaining quota that allows you to use the Diversion from Origin Server policy.
   * 
   * @remarks
   * > This operation is suitable only for Anti-DDoS Pro.
   * 
   * @param request - DescribeUnBlockCountRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeUnBlockCountResponse
   */
  async describeUnBlockCountWithOptions(request: DescribeUnBlockCountRequest, runtime: $Util.RuntimeOptions): Promise<DescribeUnBlockCountResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeUnBlockCount",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeUnBlockCountResponse>(await this.callApi(params, req, runtime), new DescribeUnBlockCountResponse({}));
  }

  /**
   * Queries the remaining quota that allows you to use the Diversion from Origin Server policy.
   * 
   * @remarks
   * > This operation is suitable only for Anti-DDoS Pro.
   * 
   * @param request - DescribeUnBlockCountRequest
   * @returns DescribeUnBlockCountResponse
   */
  async describeUnBlockCount(request: DescribeUnBlockCountRequest): Promise<DescribeUnBlockCountResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeUnBlockCountWithOptions(request, runtime);
  }

  /**
   * Checks whether the log analysis feature is enabled for all domain names.
   * 
   * @remarks
   * You can call the DescribeWebAccessLogDispatchStatus operation to check whether the log analysis feature is enabled for all domain names that are added to your Anti-DDoS Pro or Anti-DDoS Premium instance.
   * ### Limits
   * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
   * 
   * @param request - DescribeWebAccessLogDispatchStatusRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeWebAccessLogDispatchStatusResponse
   */
  async describeWebAccessLogDispatchStatusWithOptions(request: DescribeWebAccessLogDispatchStatusRequest, runtime: $Util.RuntimeOptions): Promise<DescribeWebAccessLogDispatchStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeWebAccessLogDispatchStatus",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeWebAccessLogDispatchStatusResponse>(await this.callApi(params, req, runtime), new DescribeWebAccessLogDispatchStatusResponse({}));
  }

  /**
   * Checks whether the log analysis feature is enabled for all domain names.
   * 
   * @remarks
   * You can call the DescribeWebAccessLogDispatchStatus operation to check whether the log analysis feature is enabled for all domain names that are added to your Anti-DDoS Pro or Anti-DDoS Premium instance.
   * ### Limits
   * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
   * 
   * @param request - DescribeWebAccessLogDispatchStatusRequest
   * @returns DescribeWebAccessLogDispatchStatusResponse
   */
  async describeWebAccessLogDispatchStatus(request: DescribeWebAccessLogDispatchStatusRequest): Promise<DescribeWebAccessLogDispatchStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeWebAccessLogDispatchStatusWithOptions(request, runtime);
  }

  /**
   * Queries the remaining quota that allows you to clear the Logstore.
   * 
   * @param request - DescribeWebAccessLogEmptyCountRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeWebAccessLogEmptyCountResponse
   */
  async describeWebAccessLogEmptyCountWithOptions(request: DescribeWebAccessLogEmptyCountRequest, runtime: $Util.RuntimeOptions): Promise<DescribeWebAccessLogEmptyCountResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeWebAccessLogEmptyCount",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeWebAccessLogEmptyCountResponse>(await this.callApi(params, req, runtime), new DescribeWebAccessLogEmptyCountResponse({}));
  }

  /**
   * Queries the remaining quota that allows you to clear the Logstore.
   * 
   * @param request - DescribeWebAccessLogEmptyCountRequest
   * @returns DescribeWebAccessLogEmptyCountResponse
   */
  async describeWebAccessLogEmptyCount(request: DescribeWebAccessLogEmptyCountRequest): Promise<DescribeWebAccessLogEmptyCountResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeWebAccessLogEmptyCountWithOptions(request, runtime);
  }

  /**
   * Queries the information about the Log Analysis feature for a website, such as the feature status and the Log Service project and Logstore that are used.
   * 
   * @param request - DescribeWebAccessLogStatusRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeWebAccessLogStatusResponse
   */
  async describeWebAccessLogStatusWithOptions(request: DescribeWebAccessLogStatusRequest, runtime: $Util.RuntimeOptions): Promise<DescribeWebAccessLogStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domain)) {
      query["Domain"] = request.domain;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeWebAccessLogStatus",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeWebAccessLogStatusResponse>(await this.callApi(params, req, runtime), new DescribeWebAccessLogStatusResponse({}));
  }

  /**
   * Queries the information about the Log Analysis feature for a website, such as the feature status and the Log Service project and Logstore that are used.
   * 
   * @param request - DescribeWebAccessLogStatusRequest
   * @returns DescribeWebAccessLogStatusResponse
   */
  async describeWebAccessLogStatus(request: DescribeWebAccessLogStatusRequest): Promise<DescribeWebAccessLogStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeWebAccessLogStatusWithOptions(request, runtime);
  }

  /**
   * Queries the mode in which a website service is added to Anti-DDoS Pro or Anti-DDoS Premium.
   * 
   * @param request - DescribeWebAccessModeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeWebAccessModeResponse
   */
  async describeWebAccessModeWithOptions(request: DescribeWebAccessModeRequest, runtime: $Util.RuntimeOptions): Promise<DescribeWebAccessModeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domains)) {
      query["Domains"] = request.domains;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeWebAccessMode",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeWebAccessModeResponse>(await this.callApi(params, req, runtime), new DescribeWebAccessModeResponse({}));
  }

  /**
   * Queries the mode in which a website service is added to Anti-DDoS Pro or Anti-DDoS Premium.
   * 
   * @param request - DescribeWebAccessModeRequest
   * @returns DescribeWebAccessModeResponse
   */
  async describeWebAccessMode(request: DescribeWebAccessModeRequest): Promise<DescribeWebAccessModeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeWebAccessModeWithOptions(request, runtime);
  }

  /**
   * Queries the Location Blacklist (Domain Names) configurations for websites.
   * 
   * @param request - DescribeWebAreaBlockConfigsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeWebAreaBlockConfigsResponse
   */
  async describeWebAreaBlockConfigsWithOptions(request: DescribeWebAreaBlockConfigsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeWebAreaBlockConfigsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domains)) {
      query["Domains"] = request.domains;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeWebAreaBlockConfigs",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeWebAreaBlockConfigsResponse>(await this.callApi(params, req, runtime), new DescribeWebAreaBlockConfigsResponse({}));
  }

  /**
   * Queries the Location Blacklist (Domain Names) configurations for websites.
   * 
   * @param request - DescribeWebAreaBlockConfigsRequest
   * @returns DescribeWebAreaBlockConfigsResponse
   */
  async describeWebAreaBlockConfigs(request: DescribeWebAreaBlockConfigsRequest): Promise<DescribeWebAreaBlockConfigsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeWebAreaBlockConfigsWithOptions(request, runtime);
  }

  /**
   * Queries the custom frequency control rules that are created for a website.
   * 
   * @deprecated OpenAPI DescribeWebCCRules is deprecated, please use ddoscoo::2020-01-01::ConfigWebCCRuleV2 instead.
   * 
   * @param request - DescribeWebCCRulesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeWebCCRulesResponse
   */
  // Deprecated
  async describeWebCCRulesWithOptions(request: DescribeWebCCRulesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeWebCCRulesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domain)) {
      query["Domain"] = request.domain;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeWebCCRules",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeWebCCRulesResponse>(await this.callApi(params, req, runtime), new DescribeWebCCRulesResponse({}));
  }

  /**
   * Queries the custom frequency control rules that are created for a website.
   * 
   * @deprecated OpenAPI DescribeWebCCRules is deprecated, please use ddoscoo::2020-01-01::ConfigWebCCRuleV2 instead.
   * 
   * @param request - DescribeWebCCRulesRequest
   * @returns DescribeWebCCRulesResponse
   */
  // Deprecated
  async describeWebCCRules(request: DescribeWebCCRulesRequest): Promise<DescribeWebCCRulesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeWebCCRulesWithOptions(request, runtime);
  }

  /**
   * Queries the custom frequency control rules that are created for a website.
   * 
   * @param request - DescribeWebCCRulesV2Request
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeWebCCRulesV2Response
   */
  async describeWebCCRulesV2WithOptions(request: DescribeWebCCRulesV2Request, runtime: $Util.RuntimeOptions): Promise<DescribeWebCCRulesV2Response> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domain)) {
      query["Domain"] = request.domain;
    }

    if (!Util.isUnset(request.offset)) {
      query["Offset"] = request.offset;
    }

    if (!Util.isUnset(request.owner)) {
      query["Owner"] = request.owner;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeWebCCRulesV2",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeWebCCRulesV2Response>(await this.callApi(params, req, runtime), new DescribeWebCCRulesV2Response({}));
  }

  /**
   * Queries the custom frequency control rules that are created for a website.
   * 
   * @param request - DescribeWebCCRulesV2Request
   * @returns DescribeWebCCRulesV2Response
   */
  async describeWebCCRulesV2(request: DescribeWebCCRulesV2Request): Promise<DescribeWebCCRulesV2Response> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeWebCCRulesV2WithOptions(request, runtime);
  }

  /**
   * Queries the Static Page Caching configuration of websites.
   * 
   * @remarks
   * You can call the DescribeWebCacheConfigs operation to query the Static Page Caching configurations of websites. The configurations include cache modes and custom caching rules.
   * ### Limits
   * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
   * 
   * @param request - DescribeWebCacheConfigsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeWebCacheConfigsResponse
   */
  async describeWebCacheConfigsWithOptions(request: DescribeWebCacheConfigsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeWebCacheConfigsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domains)) {
      query["Domains"] = request.domains;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeWebCacheConfigs",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeWebCacheConfigsResponse>(await this.callApi(params, req, runtime), new DescribeWebCacheConfigsResponse({}));
  }

  /**
   * Queries the Static Page Caching configuration of websites.
   * 
   * @remarks
   * You can call the DescribeWebCacheConfigs operation to query the Static Page Caching configurations of websites. The configurations include cache modes and custom caching rules.
   * ### Limits
   * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
   * 
   * @param request - DescribeWebCacheConfigsRequest
   * @returns DescribeWebCacheConfigsResponse
   */
  async describeWebCacheConfigs(request: DescribeWebCacheConfigsRequest): Promise<DescribeWebCacheConfigsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeWebCacheConfigsWithOptions(request, runtime);
  }

  /**
   * Queries the status of each mitigation policy for a website.
   * 
   * @param request - DescribeWebCcProtectSwitchRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeWebCcProtectSwitchResponse
   */
  async describeWebCcProtectSwitchWithOptions(request: DescribeWebCcProtectSwitchRequest, runtime: $Util.RuntimeOptions): Promise<DescribeWebCcProtectSwitchResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domains)) {
      query["Domains"] = request.domains;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeWebCcProtectSwitch",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeWebCcProtectSwitchResponse>(await this.callApi(params, req, runtime), new DescribeWebCcProtectSwitchResponse({}));
  }

  /**
   * Queries the status of each mitigation policy for a website.
   * 
   * @param request - DescribeWebCcProtectSwitchRequest
   * @returns DescribeWebCcProtectSwitchResponse
   */
  async describeWebCcProtectSwitch(request: DescribeWebCcProtectSwitchRequest): Promise<DescribeWebCcProtectSwitchResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeWebCcProtectSwitchWithOptions(request, runtime);
  }

  /**
   * Queries the supported custom ports of a website.
   * 
   * @param request - DescribeWebCustomPortsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeWebCustomPortsResponse
   */
  async describeWebCustomPortsWithOptions(request: DescribeWebCustomPortsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeWebCustomPortsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeWebCustomPorts",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeWebCustomPortsResponse>(await this.callApi(params, req, runtime), new DescribeWebCustomPortsResponse({}));
  }

  /**
   * Queries the supported custom ports of a website.
   * 
   * @param request - DescribeWebCustomPortsRequest
   * @returns DescribeWebCustomPortsResponse
   */
  async describeWebCustomPorts(request: DescribeWebCustomPortsRequest): Promise<DescribeWebCustomPortsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeWebCustomPortsWithOptions(request, runtime);
  }

  /**
   * Queries the information about Anti-DDoS Pro or Anti-DDoS Premium instances to which a website service is added.
   * 
   * @param request - DescribeWebInstanceRelationsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeWebInstanceRelationsResponse
   */
  async describeWebInstanceRelationsWithOptions(request: DescribeWebInstanceRelationsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeWebInstanceRelationsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domains)) {
      query["Domains"] = request.domains;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeWebInstanceRelations",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeWebInstanceRelationsResponse>(await this.callApi(params, req, runtime), new DescribeWebInstanceRelationsResponse({}));
  }

  /**
   * Queries the information about Anti-DDoS Pro or Anti-DDoS Premium instances to which a website service is added.
   * 
   * @param request - DescribeWebInstanceRelationsRequest
   * @returns DescribeWebInstanceRelationsResponse
   */
  async describeWebInstanceRelations(request: DescribeWebInstanceRelationsRequest): Promise<DescribeWebInstanceRelationsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeWebInstanceRelationsWithOptions(request, runtime);
  }

  /**
   * Queries the accurate access control rules that are created for websites.
   * 
   * @param request - DescribeWebPreciseAccessRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeWebPreciseAccessRuleResponse
   */
  async describeWebPreciseAccessRuleWithOptions(request: DescribeWebPreciseAccessRuleRequest, runtime: $Util.RuntimeOptions): Promise<DescribeWebPreciseAccessRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domains)) {
      query["Domains"] = request.domains;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeWebPreciseAccessRule",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeWebPreciseAccessRuleResponse>(await this.callApi(params, req, runtime), new DescribeWebPreciseAccessRuleResponse({}));
  }

  /**
   * Queries the accurate access control rules that are created for websites.
   * 
   * @param request - DescribeWebPreciseAccessRuleRequest
   * @returns DescribeWebPreciseAccessRuleResponse
   */
  async describeWebPreciseAccessRule(request: DescribeWebPreciseAccessRuleRequest): Promise<DescribeWebPreciseAccessRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeWebPreciseAccessRuleWithOptions(request, runtime);
  }

  /**
   * Queries the top source IP addresses of the web resource exhaustion attacks for the Anti-DDoS Proxy instance.
   * 
   * @param request - DescribeWebReportTopIpRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeWebReportTopIpResponse
   */
  async describeWebReportTopIpWithOptions(request: DescribeWebReportTopIpRequest, runtime: $Util.RuntimeOptions): Promise<DescribeWebReportTopIpResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domain)) {
      query["Domain"] = request.domain;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.interval)) {
      query["Interval"] = request.interval;
    }

    if (!Util.isUnset(request.queryType)) {
      query["QueryType"] = request.queryType;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.top)) {
      query["Top"] = request.top;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeWebReportTopIp",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeWebReportTopIpResponse>(await this.callApi(params, req, runtime), new DescribeWebReportTopIpResponse({}));
  }

  /**
   * Queries the top source IP addresses of the web resource exhaustion attacks for the Anti-DDoS Proxy instance.
   * 
   * @param request - DescribeWebReportTopIpRequest
   * @returns DescribeWebReportTopIpResponse
   */
  async describeWebReportTopIp(request: DescribeWebReportTopIpRequest): Promise<DescribeWebReportTopIpResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeWebReportTopIpWithOptions(request, runtime);
  }

  /**
   * Indicates whether Allow Access Only from SM Certificates-based Clients is turned on.
   * *   0: no
   * *   1: yes
   * 
   * @param request - DescribeWebRulesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeWebRulesResponse
   */
  async describeWebRulesWithOptions(request: DescribeWebRulesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeWebRulesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.cname)) {
      query["Cname"] = request.cname;
    }

    if (!Util.isUnset(request.domain)) {
      query["Domain"] = request.domain;
    }

    if (!Util.isUnset(request.instanceIds)) {
      query["InstanceIds"] = request.instanceIds;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.queryDomainPattern)) {
      query["QueryDomainPattern"] = request.queryDomainPattern;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeWebRules",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeWebRulesResponse>(await this.callApi(params, req, runtime), new DescribeWebRulesResponse({}));
  }

  /**
   * Indicates whether Allow Access Only from SM Certificates-based Clients is turned on.
   * *   0: no
   * *   1: yes
   * 
   * @param request - DescribeWebRulesRequest
   * @returns DescribeWebRulesResponse
   */
  async describeWebRules(request: DescribeWebRulesRequest): Promise<DescribeWebRulesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeWebRulesWithOptions(request, runtime);
  }

  /**
   * Removes a protected object from a scenario-specific custom policy.
   * 
   * @param request - DetachSceneDefenseObjectRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DetachSceneDefenseObjectResponse
   */
  async detachSceneDefenseObjectWithOptions(request: DetachSceneDefenseObjectRequest, runtime: $Util.RuntimeOptions): Promise<DetachSceneDefenseObjectResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.objectType)) {
      query["ObjectType"] = request.objectType;
    }

    if (!Util.isUnset(request.objects)) {
      query["Objects"] = request.objects;
    }

    if (!Util.isUnset(request.policyId)) {
      query["PolicyId"] = request.policyId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DetachSceneDefenseObject",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DetachSceneDefenseObjectResponse>(await this.callApi(params, req, runtime), new DetachSceneDefenseObjectResponse({}));
  }

  /**
   * Removes a protected object from a scenario-specific custom policy.
   * 
   * @param request - DetachSceneDefenseObjectRequest
   * @returns DetachSceneDefenseObjectResponse
   */
  async detachSceneDefenseObject(request: DetachSceneDefenseObjectRequest): Promise<DetachSceneDefenseObjectResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.detachSceneDefenseObjectWithOptions(request, runtime);
  }

  /**
   * Disables a scenario-specific custom policy.
   * 
   * @param request - DisableSceneDefensePolicyRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DisableSceneDefensePolicyResponse
   */
  async disableSceneDefensePolicyWithOptions(request: DisableSceneDefensePolicyRequest, runtime: $Util.RuntimeOptions): Promise<DisableSceneDefensePolicyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.policyId)) {
      query["PolicyId"] = request.policyId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DisableSceneDefensePolicy",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DisableSceneDefensePolicyResponse>(await this.callApi(params, req, runtime), new DisableSceneDefensePolicyResponse({}));
  }

  /**
   * Disables a scenario-specific custom policy.
   * 
   * @param request - DisableSceneDefensePolicyRequest
   * @returns DisableSceneDefensePolicyResponse
   */
  async disableSceneDefensePolicy(request: DisableSceneDefensePolicyRequest): Promise<DisableSceneDefensePolicyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.disableSceneDefensePolicyWithOptions(request, runtime);
  }

  /**
   * Disables the log analysis feature for a website.
   * 
   * @param request - DisableWebAccessLogConfigRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DisableWebAccessLogConfigResponse
   */
  async disableWebAccessLogConfigWithOptions(request: DisableWebAccessLogConfigRequest, runtime: $Util.RuntimeOptions): Promise<DisableWebAccessLogConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domain)) {
      query["Domain"] = request.domain;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DisableWebAccessLogConfig",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DisableWebAccessLogConfigResponse>(await this.callApi(params, req, runtime), new DisableWebAccessLogConfigResponse({}));
  }

  /**
   * Disables the log analysis feature for a website.
   * 
   * @param request - DisableWebAccessLogConfigRequest
   * @returns DisableWebAccessLogConfigResponse
   */
  async disableWebAccessLogConfig(request: DisableWebAccessLogConfigRequest): Promise<DisableWebAccessLogConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.disableWebAccessLogConfigWithOptions(request, runtime);
  }

  /**
   * Disables the Frequency Control policy for a website.
   * 
   * @param request - DisableWebCCRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DisableWebCCResponse
   */
  async disableWebCCWithOptions(request: DisableWebCCRequest, runtime: $Util.RuntimeOptions): Promise<DisableWebCCResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domain)) {
      query["Domain"] = request.domain;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DisableWebCC",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DisableWebCCResponse>(await this.callApi(params, req, runtime), new DisableWebCCResponse({}));
  }

  /**
   * Disables the Frequency Control policy for a website.
   * 
   * @param request - DisableWebCCRequest
   * @returns DisableWebCCResponse
   */
  async disableWebCC(request: DisableWebCCRequest): Promise<DisableWebCCResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.disableWebCCWithOptions(request, runtime);
  }

  /**
   * Turns off the Custom Rule switch of the Frequency Control policy for a website.
   * 
   * @param request - DisableWebCCRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DisableWebCCRuleResponse
   */
  async disableWebCCRuleWithOptions(request: DisableWebCCRuleRequest, runtime: $Util.RuntimeOptions): Promise<DisableWebCCRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domain)) {
      query["Domain"] = request.domain;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DisableWebCCRule",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DisableWebCCRuleResponse>(await this.callApi(params, req, runtime), new DisableWebCCRuleResponse({}));
  }

  /**
   * Turns off the Custom Rule switch of the Frequency Control policy for a website.
   * 
   * @param request - DisableWebCCRuleRequest
   * @returns DisableWebCCRuleResponse
   */
  async disableWebCCRule(request: DisableWebCCRuleRequest): Promise<DisableWebCCRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.disableWebCCRuleWithOptions(request, runtime);
  }

  /**
   * Clears the IP address blacklist of an Anti-DDoS Pro or Anti-DDoS Premium instance.
   * 
   * @param request - EmptyAutoCcBlacklistRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns EmptyAutoCcBlacklistResponse
   */
  async emptyAutoCcBlacklistWithOptions(request: EmptyAutoCcBlacklistRequest, runtime: $Util.RuntimeOptions): Promise<EmptyAutoCcBlacklistResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "EmptyAutoCcBlacklist",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<EmptyAutoCcBlacklistResponse>(await this.callApi(params, req, runtime), new EmptyAutoCcBlacklistResponse({}));
  }

  /**
   * Clears the IP address blacklist of an Anti-DDoS Pro or Anti-DDoS Premium instance.
   * 
   * @param request - EmptyAutoCcBlacklistRequest
   * @returns EmptyAutoCcBlacklistResponse
   */
  async emptyAutoCcBlacklist(request: EmptyAutoCcBlacklistRequest): Promise<EmptyAutoCcBlacklistResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.emptyAutoCcBlacklistWithOptions(request, runtime);
  }

  /**
   * Clears the IP address whitelist of an Anti-DDoS Pro or Anti-DDoS Premium instance.
   * 
   * @param request - EmptyAutoCcWhitelistRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns EmptyAutoCcWhitelistResponse
   */
  async emptyAutoCcWhitelistWithOptions(request: EmptyAutoCcWhitelistRequest, runtime: $Util.RuntimeOptions): Promise<EmptyAutoCcWhitelistResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "EmptyAutoCcWhitelist",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<EmptyAutoCcWhitelistResponse>(await this.callApi(params, req, runtime), new EmptyAutoCcWhitelistResponse({}));
  }

  /**
   * Clears the IP address whitelist of an Anti-DDoS Pro or Anti-DDoS Premium instance.
   * 
   * @param request - EmptyAutoCcWhitelistRequest
   * @returns EmptyAutoCcWhitelistResponse
   */
  async emptyAutoCcWhitelist(request: EmptyAutoCcWhitelistRequest): Promise<EmptyAutoCcWhitelistResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.emptyAutoCcWhitelistWithOptions(request, runtime);
  }

  /**
   * Clears the Logstore of Anti-DDoS Pro or Anti-DDoS Premium.
   * 
   * @param request - EmptySlsLogstoreRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns EmptySlsLogstoreResponse
   */
  async emptySlsLogstoreWithOptions(request: EmptySlsLogstoreRequest, runtime: $Util.RuntimeOptions): Promise<EmptySlsLogstoreResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "EmptySlsLogstore",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<EmptySlsLogstoreResponse>(await this.callApi(params, req, runtime), new EmptySlsLogstoreResponse({}));
  }

  /**
   * Clears the Logstore of Anti-DDoS Pro or Anti-DDoS Premium.
   * 
   * @param request - EmptySlsLogstoreRequest
   * @returns EmptySlsLogstoreResponse
   */
  async emptySlsLogstore(request: EmptySlsLogstoreRequest): Promise<EmptySlsLogstoreResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.emptySlsLogstoreWithOptions(request, runtime);
  }

  /**
   * Enables a scenario-specific custom policy.
   * 
   * @param request - EnableSceneDefensePolicyRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns EnableSceneDefensePolicyResponse
   */
  async enableSceneDefensePolicyWithOptions(request: EnableSceneDefensePolicyRequest, runtime: $Util.RuntimeOptions): Promise<EnableSceneDefensePolicyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.policyId)) {
      query["PolicyId"] = request.policyId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "EnableSceneDefensePolicy",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<EnableSceneDefensePolicyResponse>(await this.callApi(params, req, runtime), new EnableSceneDefensePolicyResponse({}));
  }

  /**
   * Enables a scenario-specific custom policy.
   * 
   * @param request - EnableSceneDefensePolicyRequest
   * @returns EnableSceneDefensePolicyResponse
   */
  async enableSceneDefensePolicy(request: EnableSceneDefensePolicyRequest): Promise<EnableSceneDefensePolicyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.enableSceneDefensePolicyWithOptions(request, runtime);
  }

  /**
   * Enables the log analysis feature for a website.
   * 
   * @param request - EnableWebAccessLogConfigRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns EnableWebAccessLogConfigResponse
   */
  async enableWebAccessLogConfigWithOptions(request: EnableWebAccessLogConfigRequest, runtime: $Util.RuntimeOptions): Promise<EnableWebAccessLogConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domain)) {
      query["Domain"] = request.domain;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "EnableWebAccessLogConfig",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<EnableWebAccessLogConfigResponse>(await this.callApi(params, req, runtime), new EnableWebAccessLogConfigResponse({}));
  }

  /**
   * Enables the log analysis feature for a website.
   * 
   * @param request - EnableWebAccessLogConfigRequest
   * @returns EnableWebAccessLogConfigResponse
   */
  async enableWebAccessLogConfig(request: EnableWebAccessLogConfigRequest): Promise<EnableWebAccessLogConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.enableWebAccessLogConfigWithOptions(request, runtime);
  }

  /**
   * Enables the Frequency Control policy for a website.
   * 
   * @param request - EnableWebCCRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns EnableWebCCResponse
   */
  async enableWebCCWithOptions(request: EnableWebCCRequest, runtime: $Util.RuntimeOptions): Promise<EnableWebCCResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domain)) {
      query["Domain"] = request.domain;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "EnableWebCC",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<EnableWebCCResponse>(await this.callApi(params, req, runtime), new EnableWebCCResponse({}));
  }

  /**
   * Enables the Frequency Control policy for a website.
   * 
   * @param request - EnableWebCCRequest
   * @returns EnableWebCCResponse
   */
  async enableWebCC(request: EnableWebCCRequest): Promise<EnableWebCCResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.enableWebCCWithOptions(request, runtime);
  }

  /**
   * Turns on the Custom Rule switch of the Frequency Control policy for a website.
   * 
   * @param request - EnableWebCCRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns EnableWebCCRuleResponse
   */
  async enableWebCCRuleWithOptions(request: EnableWebCCRuleRequest, runtime: $Util.RuntimeOptions): Promise<EnableWebCCRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domain)) {
      query["Domain"] = request.domain;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "EnableWebCCRule",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<EnableWebCCRuleResponse>(await this.callApi(params, req, runtime), new EnableWebCCRuleResponse({}));
  }

  /**
   * Turns on the Custom Rule switch of the Frequency Control policy for a website.
   * 
   * @param request - EnableWebCCRuleRequest
   * @returns EnableWebCCRuleResponse
   */
  async enableWebCCRule(request: EnableWebCCRuleRequest): Promise<EnableWebCCRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.enableWebCCRuleWithOptions(request, runtime);
  }

  /**
   * Switches between the metering methods of the burstable clean bandwidth feature.
   * 
   * @remarks
   * You can switch between the metering methods of the burstable clean bandwidth feature. The new metering method takes effect from 00:00 on the first day of the next month. You can change the metering method up to three times each calendar month. The most recent metering method that you select takes effect in the next month. You cannot change the metering method on the last day of each calendar month.
   * 
   * @param request - ModifyBizBandWidthModeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyBizBandWidthModeResponse
   */
  async modifyBizBandWidthModeWithOptions(request: ModifyBizBandWidthModeRequest, runtime: $Util.RuntimeOptions): Promise<ModifyBizBandWidthModeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.mode)) {
      query["Mode"] = request.mode;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyBizBandWidthMode",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyBizBandWidthModeResponse>(await this.callApi(params, req, runtime), new ModifyBizBandWidthModeResponse({}));
  }

  /**
   * Switches between the metering methods of the burstable clean bandwidth feature.
   * 
   * @remarks
   * You can switch between the metering methods of the burstable clean bandwidth feature. The new metering method takes effect from 00:00 on the first day of the next month. You can change the metering method up to three times each calendar month. The most recent metering method that you select takes effect in the next month. You cannot change the metering method on the last day of each calendar month.
   * 
   * @param request - ModifyBizBandWidthModeRequest
   * @returns ModifyBizBandWidthModeResponse
   */
  async modifyBizBandWidthMode(request: ModifyBizBandWidthModeRequest): Promise<ModifyBizBandWidthModeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyBizBandWidthModeWithOptions(request, runtime);
  }

  /**
   * Deactivates blackhole filtering that is triggered on an instance.
   * 
   * @param request - ModifyBlackholeStatusRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyBlackholeStatusResponse
   */
  async modifyBlackholeStatusWithOptions(request: ModifyBlackholeStatusRequest, runtime: $Util.RuntimeOptions): Promise<ModifyBlackholeStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.blackholeStatus)) {
      query["BlackholeStatus"] = request.blackholeStatus;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyBlackholeStatus",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyBlackholeStatusResponse>(await this.callApi(params, req, runtime), new ModifyBlackholeStatusResponse({}));
  }

  /**
   * Deactivates blackhole filtering that is triggered on an instance.
   * 
   * @param request - ModifyBlackholeStatusRequest
   * @returns ModifyBlackholeStatusResponse
   */
  async modifyBlackholeStatus(request: ModifyBlackholeStatusRequest): Promise<ModifyBlackholeStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyBlackholeStatusWithOptions(request, runtime);
  }

  /**
   * Modifies the Diversion from Origin Server configuration of an Anti-DDoS Proxy (Chinese Mainland) instance.
   * 
   * @remarks
   * >  This operation is suitable only for Anti-DDoS Proxy (Chinese Mainland).
   * 
   * @param request - ModifyBlockStatusRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyBlockStatusResponse
   */
  async modifyBlockStatusWithOptions(request: ModifyBlockStatusRequest, runtime: $Util.RuntimeOptions): Promise<ModifyBlockStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.duration)) {
      query["Duration"] = request.duration;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.lines)) {
      query["Lines"] = request.lines;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyBlockStatus",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyBlockStatusResponse>(await this.callApi(params, req, runtime), new ModifyBlockStatusResponse({}));
  }

  /**
   * Modifies the Diversion from Origin Server configuration of an Anti-DDoS Proxy (Chinese Mainland) instance.
   * 
   * @remarks
   * >  This operation is suitable only for Anti-DDoS Proxy (Chinese Mainland).
   * 
   * @param request - ModifyBlockStatusRequest
   * @returns ModifyBlockStatusResponse
   */
  async modifyBlockStatus(request: ModifyBlockStatusRequest): Promise<ModifyBlockStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyBlockStatusWithOptions(request, runtime);
  }

  /**
   * Enables or disables CNAME reuse for a website.
   * 
   * @remarks
   * > This operation is suitable only for Anti-DDoS Premium.
   * 
   * @param request - ModifyCnameReuseRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyCnameReuseResponse
   */
  async modifyCnameReuseWithOptions(request: ModifyCnameReuseRequest, runtime: $Util.RuntimeOptions): Promise<ModifyCnameReuseResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.cname)) {
      query["Cname"] = request.cname;
    }

    if (!Util.isUnset(request.domain)) {
      query["Domain"] = request.domain;
    }

    if (!Util.isUnset(request.enable)) {
      query["Enable"] = request.enable;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyCnameReuse",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyCnameReuseResponse>(await this.callApi(params, req, runtime), new ModifyCnameReuseResponse({}));
  }

  /**
   * Enables or disables CNAME reuse for a website.
   * 
   * @remarks
   * > This operation is suitable only for Anti-DDoS Premium.
   * 
   * @param request - ModifyCnameReuseRequest
   * @returns ModifyCnameReuseResponse
   */
  async modifyCnameReuse(request: ModifyCnameReuseRequest): Promise<ModifyCnameReuseResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyCnameReuseWithOptions(request, runtime);
  }

  /**
   * Modifies the forwarding rule of a website.
   * 
   * @param request - ModifyDomainResourceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyDomainResourceResponse
   */
  async modifyDomainResourceWithOptions(request: ModifyDomainResourceRequest, runtime: $Util.RuntimeOptions): Promise<ModifyDomainResourceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domain)) {
      query["Domain"] = request.domain;
    }

    if (!Util.isUnset(request.httpsExt)) {
      query["HttpsExt"] = request.httpsExt;
    }

    if (!Util.isUnset(request.instanceIds)) {
      query["InstanceIds"] = request.instanceIds;
    }

    if (!Util.isUnset(request.proxyTypes)) {
      query["ProxyTypes"] = request.proxyTypes;
    }

    if (!Util.isUnset(request.realServers)) {
      query["RealServers"] = request.realServers;
    }

    if (!Util.isUnset(request.rsType)) {
      query["RsType"] = request.rsType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyDomainResource",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyDomainResourceResponse>(await this.callApi(params, req, runtime), new ModifyDomainResourceResponse({}));
  }

  /**
   * Modifies the forwarding rule of a website.
   * 
   * @param request - ModifyDomainResourceRequest
   * @returns ModifyDomainResourceResponse
   */
  async modifyDomainResource(request: ModifyDomainResourceRequest): Promise<ModifyDomainResourceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyDomainResourceWithOptions(request, runtime);
  }

  /**
   * Modifies the burstable protection bandwidth of a specified Anti-DDoS Proxy (Chinese Mainland) instance.
   * 
   * @remarks
   * >  This operation is suitable only for Anti-DDoS Proxy (Chinese Mainland).
   * 
   * @param request - ModifyElasticBandWidthRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyElasticBandWidthResponse
   */
  async modifyElasticBandWidthWithOptions(request: ModifyElasticBandWidthRequest, runtime: $Util.RuntimeOptions): Promise<ModifyElasticBandWidthResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.elasticBandwidth)) {
      query["ElasticBandwidth"] = request.elasticBandwidth;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyElasticBandWidth",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyElasticBandWidthResponse>(await this.callApi(params, req, runtime), new ModifyElasticBandWidthResponse({}));
  }

  /**
   * Modifies the burstable protection bandwidth of a specified Anti-DDoS Proxy (Chinese Mainland) instance.
   * 
   * @remarks
   * >  This operation is suitable only for Anti-DDoS Proxy (Chinese Mainland).
   * 
   * @param request - ModifyElasticBandWidthRequest
   * @returns ModifyElasticBandWidthResponse
   */
  async modifyElasticBandWidth(request: ModifyElasticBandWidthRequest): Promise<ModifyElasticBandWidthResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyElasticBandWidthWithOptions(request, runtime);
  }

  /**
   * Modifies the burstable clean bandwidth for an Anti-DDoS Pro or Anti-DDoS Premium instance.
   * 
   * @remarks
   * Before you call this operation, make sure that you have fully understood the billing method and [pricing](https://help.aliyun.com/document_detail/283754.html) of the burstable clean bandwidth feature. After you call this operation for the first time, the modification immediately takes effect.
   * 
   * @param request - ModifyElasticBizBandWidthRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyElasticBizBandWidthResponse
   */
  async modifyElasticBizBandWidthWithOptions(request: ModifyElasticBizBandWidthRequest, runtime: $Util.RuntimeOptions): Promise<ModifyElasticBizBandWidthResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.elasticBizBandwidth)) {
      query["ElasticBizBandwidth"] = request.elasticBizBandwidth;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.mode)) {
      query["Mode"] = request.mode;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyElasticBizBandWidth",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyElasticBizBandWidthResponse>(await this.callApi(params, req, runtime), new ModifyElasticBizBandWidthResponse({}));
  }

  /**
   * Modifies the burstable clean bandwidth for an Anti-DDoS Pro or Anti-DDoS Premium instance.
   * 
   * @remarks
   * Before you call this operation, make sure that you have fully understood the billing method and [pricing](https://help.aliyun.com/document_detail/283754.html) of the burstable clean bandwidth feature. After you call this operation for the first time, the modification immediately takes effect.
   * 
   * @param request - ModifyElasticBizBandWidthRequest
   * @returns ModifyElasticBizBandWidthResponse
   */
  async modifyElasticBizBandWidth(request: ModifyElasticBizBandWidthRequest): Promise<ModifyElasticBizBandWidthResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyElasticBizBandWidthWithOptions(request, runtime);
  }

  /**
   * Configures the burstable QPS and mode of an Anti-DDoS Proxy instance.
   * 
   * @remarks
   * You can enable burstable QPS only for IPv4 instances.
   * 
   * @param request - ModifyElasticBizQpsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyElasticBizQpsResponse
   */
  async modifyElasticBizQpsWithOptions(request: ModifyElasticBizQpsRequest, runtime: $Util.RuntimeOptions): Promise<ModifyElasticBizQpsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.mode)) {
      query["Mode"] = request.mode;
    }

    if (!Util.isUnset(request.opsElasticQps)) {
      query["OpsElasticQps"] = request.opsElasticQps;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyElasticBizQps",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyElasticBizQpsResponse>(await this.callApi(params, req, runtime), new ModifyElasticBizQpsResponse({}));
  }

  /**
   * Configures the burstable QPS and mode of an Anti-DDoS Proxy instance.
   * 
   * @remarks
   * You can enable burstable QPS only for IPv4 instances.
   * 
   * @param request - ModifyElasticBizQpsRequest
   * @returns ModifyElasticBizQpsResponse
   */
  async modifyElasticBizQps(request: ModifyElasticBizQpsRequest): Promise<ModifyElasticBizQpsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyElasticBizQpsWithOptions(request, runtime);
  }

  /**
   * Modifies the log storage duration for Anti-DDoS Pro or Anti-DDoS Premium.
   * 
   * @param request - ModifyFullLogTtlRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyFullLogTtlResponse
   */
  async modifyFullLogTtlWithOptions(request: ModifyFullLogTtlRequest, runtime: $Util.RuntimeOptions): Promise<ModifyFullLogTtlResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.ttl)) {
      query["Ttl"] = request.ttl;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyFullLogTtl",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyFullLogTtlResponse>(await this.callApi(params, req, runtime), new ModifyFullLogTtlResponse({}));
  }

  /**
   * Modifies the log storage duration for Anti-DDoS Pro or Anti-DDoS Premium.
   * 
   * @param request - ModifyFullLogTtlRequest
   * @returns ModifyFullLogTtlResponse
   */
  async modifyFullLogTtl(request: ModifyFullLogTtlRequest): Promise<ModifyFullLogTtlResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyFullLogTtlWithOptions(request, runtime);
  }

  /**
   * Modifies the custom header of a domain name that is added to an Anti-DDoS Pro or Anti-DDoS Premium instance.
   * 
   * @param request - ModifyHeadersRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyHeadersResponse
   */
  async modifyHeadersWithOptions(request: ModifyHeadersRequest, runtime: $Util.RuntimeOptions): Promise<ModifyHeadersResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.customHeaders)) {
      query["CustomHeaders"] = request.customHeaders;
    }

    if (!Util.isUnset(request.domain)) {
      query["Domain"] = request.domain;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyHeaders",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyHeadersResponse>(await this.callApi(params, req, runtime), new ModifyHeadersResponse({}));
  }

  /**
   * Modifies the custom header of a domain name that is added to an Anti-DDoS Pro or Anti-DDoS Premium instance.
   * 
   * @param request - ModifyHeadersRequest
   * @returns ModifyHeadersResponse
   */
  async modifyHeaders(request: ModifyHeadersRequest): Promise<ModifyHeadersResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyHeadersWithOptions(request, runtime);
  }

  /**
   * Modifies the Layer 4 or Layer 7 health check configuration of a port forwarding rule.
   * 
   * @param request - ModifyHealthCheckConfigRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyHealthCheckConfigResponse
   */
  async modifyHealthCheckConfigWithOptions(request: ModifyHealthCheckConfigRequest, runtime: $Util.RuntimeOptions): Promise<ModifyHealthCheckConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.forwardProtocol)) {
      query["ForwardProtocol"] = request.forwardProtocol;
    }

    if (!Util.isUnset(request.frontendPort)) {
      query["FrontendPort"] = request.frontendPort;
    }

    if (!Util.isUnset(request.healthCheck)) {
      query["HealthCheck"] = request.healthCheck;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyHealthCheckConfig",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyHealthCheckConfigResponse>(await this.callApi(params, req, runtime), new ModifyHealthCheckConfigResponse({}));
  }

  /**
   * Modifies the Layer 4 or Layer 7 health check configuration of a port forwarding rule.
   * 
   * @param request - ModifyHealthCheckConfigRequest
   * @returns ModifyHealthCheckConfigResponse
   */
  async modifyHealthCheckConfig(request: ModifyHealthCheckConfigRequest): Promise<ModifyHealthCheckConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyHealthCheckConfigWithOptions(request, runtime);
  }

  /**
   * Enables or disables HTTP/2 for the forwarding rule of a website.
   * 
   * @remarks
   * >  This operation is suitable only for Anti-DDoS Proxy (Chinese Mainland).
   * 
   * @param request - ModifyHttp2EnableRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyHttp2EnableResponse
   */
  async modifyHttp2EnableWithOptions(request: ModifyHttp2EnableRequest, runtime: $Util.RuntimeOptions): Promise<ModifyHttp2EnableResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domain)) {
      query["Domain"] = request.domain;
    }

    if (!Util.isUnset(request.enable)) {
      query["Enable"] = request.enable;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyHttp2Enable",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyHttp2EnableResponse>(await this.callApi(params, req, runtime), new ModifyHttp2EnableResponse({}));
  }

  /**
   * Enables or disables HTTP/2 for the forwarding rule of a website.
   * 
   * @remarks
   * >  This operation is suitable only for Anti-DDoS Proxy (Chinese Mainland).
   * 
   * @param request - ModifyHttp2EnableRequest
   * @returns ModifyHttp2EnableResponse
   */
  async modifyHttp2Enable(request: ModifyHttp2EnableRequest): Promise<ModifyHttp2EnableResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyHttp2EnableWithOptions(request, runtime);
  }

  /**
   * Modifies the description of an Anti-DDoS Pro or Anti-DDoS Premium instance.
   * 
   * @param request - ModifyInstanceRemarkRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyInstanceRemarkResponse
   */
  async modifyInstanceRemarkWithOptions(request: ModifyInstanceRemarkRequest, runtime: $Util.RuntimeOptions): Promise<ModifyInstanceRemarkResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.remark)) {
      query["Remark"] = request.remark;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyInstanceRemark",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyInstanceRemarkResponse>(await this.callApi(params, req, runtime), new ModifyInstanceRemarkResponse({}));
  }

  /**
   * Modifies the description of an Anti-DDoS Pro or Anti-DDoS Premium instance.
   * 
   * @param request - ModifyInstanceRemarkRequest
   * @returns ModifyInstanceRemarkResponse
   */
  async modifyInstanceRemark(request: ModifyInstanceRemarkRequest): Promise<ModifyInstanceRemarkResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyInstanceRemarkWithOptions(request, runtime);
  }

  /**
   * Modifies the session persistence settings of a port forwarding rule.
   * 
   * @param request - ModifyNetworkRuleAttributeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyNetworkRuleAttributeResponse
   */
  async modifyNetworkRuleAttributeWithOptions(request: ModifyNetworkRuleAttributeRequest, runtime: $Util.RuntimeOptions): Promise<ModifyNetworkRuleAttributeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.config)) {
      query["Config"] = request.config;
    }

    if (!Util.isUnset(request.forwardProtocol)) {
      query["ForwardProtocol"] = request.forwardProtocol;
    }

    if (!Util.isUnset(request.frontendPort)) {
      query["FrontendPort"] = request.frontendPort;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyNetworkRuleAttribute",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyNetworkRuleAttributeResponse>(await this.callApi(params, req, runtime), new ModifyNetworkRuleAttributeResponse({}));
  }

  /**
   * Modifies the session persistence settings of a port forwarding rule.
   * 
   * @param request - ModifyNetworkRuleAttributeRequest
   * @returns ModifyNetworkRuleAttributeResponse
   */
  async modifyNetworkRuleAttribute(request: ModifyNetworkRuleAttributeRequest): Promise<ModifyNetworkRuleAttributeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyNetworkRuleAttributeWithOptions(request, runtime);
  }

  /**
   * Specifies whether to enable the Online Certificate Status Protocol (OCSP) feature.
   * 
   * @remarks
   * This feature is available only for a website that supports HTTPS. If HTTPS is selected for Protocol, we recommend that you enable this feature.
   * 
   * @param request - ModifyOcspStatusRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyOcspStatusResponse
   */
  async modifyOcspStatusWithOptions(request: ModifyOcspStatusRequest, runtime: $Util.RuntimeOptions): Promise<ModifyOcspStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domain)) {
      query["Domain"] = request.domain;
    }

    if (!Util.isUnset(request.enable)) {
      query["Enable"] = request.enable;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyOcspStatus",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyOcspStatusResponse>(await this.callApi(params, req, runtime), new ModifyOcspStatusResponse({}));
  }

  /**
   * Specifies whether to enable the Online Certificate Status Protocol (OCSP) feature.
   * 
   * @remarks
   * This feature is available only for a website that supports HTTPS. If HTTPS is selected for Protocol, we recommend that you enable this feature.
   * 
   * @param request - ModifyOcspStatusRequest
   * @returns ModifyOcspStatusResponse
   */
  async modifyOcspStatus(request: ModifyOcspStatusRequest): Promise<ModifyOcspStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyOcspStatusWithOptions(request, runtime);
  }

  /**
   * Modifies a port forwarding rule.
   * 
   * @remarks
   * You can call the ModifyPort operation by using Terraform. For more information about Terraform, see [What is Terraform?](https://help.aliyun.com/document_detail/95820.html).
   * 
   * @param request - ModifyPortRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyPortResponse
   */
  async modifyPortWithOptions(request: ModifyPortRequest, runtime: $Util.RuntimeOptions): Promise<ModifyPortResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.backendPort)) {
      query["BackendPort"] = request.backendPort;
    }

    if (!Util.isUnset(request.frontendPort)) {
      query["FrontendPort"] = request.frontendPort;
    }

    if (!Util.isUnset(request.frontendProtocol)) {
      query["FrontendProtocol"] = request.frontendProtocol;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.realServers)) {
      query["RealServers"] = request.realServers;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyPort",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyPortResponse>(await this.callApi(params, req, runtime), new ModifyPortResponse({}));
  }

  /**
   * Modifies a port forwarding rule.
   * 
   * @remarks
   * You can call the ModifyPort operation by using Terraform. For more information about Terraform, see [What is Terraform?](https://help.aliyun.com/document_detail/95820.html).
   * 
   * @param request - ModifyPortRequest
   * @returns ModifyPortResponse
   */
  async modifyPort(request: ModifyPortRequest): Promise<ModifyPortResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyPortWithOptions(request, runtime);
  }

  /**
   * Modifies the Intelligent Protection configuration of a non-website service.
   * 
   * @param request - ModifyPortAutoCcStatusRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyPortAutoCcStatusResponse
   */
  async modifyPortAutoCcStatusWithOptions(request: ModifyPortAutoCcStatusRequest, runtime: $Util.RuntimeOptions): Promise<ModifyPortAutoCcStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.mode)) {
      query["Mode"] = request.mode;
    }

    if (!Util.isUnset(request.switch)) {
      query["Switch"] = request.switch;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyPortAutoCcStatus",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyPortAutoCcStatusResponse>(await this.callApi(params, req, runtime), new ModifyPortAutoCcStatusResponse({}));
  }

  /**
   * Modifies the Intelligent Protection configuration of a non-website service.
   * 
   * @param request - ModifyPortAutoCcStatusRequest
   * @returns ModifyPortAutoCcStatusResponse
   */
  async modifyPortAutoCcStatus(request: ModifyPortAutoCcStatusRequest): Promise<ModifyPortAutoCcStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyPortAutoCcStatusWithOptions(request, runtime);
  }

  /**
   * Switches between the metering methods of the burstable clean bandwidth feature.
   * 
   * @param request - ModifyQpsModeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyQpsModeResponse
   */
  async modifyQpsModeWithOptions(request: ModifyQpsModeRequest, runtime: $Util.RuntimeOptions): Promise<ModifyQpsModeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.mode)) {
      query["Mode"] = request.mode;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyQpsMode",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyQpsModeResponse>(await this.callApi(params, req, runtime), new ModifyQpsModeResponse({}));
  }

  /**
   * Switches between the metering methods of the burstable clean bandwidth feature.
   * 
   * @param request - ModifyQpsModeRequest
   * @returns ModifyQpsModeResponse
   */
  async modifyQpsMode(request: ModifyQpsModeRequest): Promise<ModifyQpsModeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyQpsModeWithOptions(request, runtime);
  }

  /**
   * Modifies a scenario-specific custom policy.
   * 
   * @param request - ModifySceneDefensePolicyRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifySceneDefensePolicyResponse
   */
  async modifySceneDefensePolicyWithOptions(request: ModifySceneDefensePolicyRequest, runtime: $Util.RuntimeOptions): Promise<ModifySceneDefensePolicyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.policyId)) {
      query["PolicyId"] = request.policyId;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.template)) {
      query["Template"] = request.template;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifySceneDefensePolicy",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifySceneDefensePolicyResponse>(await this.callApi(params, req, runtime), new ModifySceneDefensePolicyResponse({}));
  }

  /**
   * Modifies a scenario-specific custom policy.
   * 
   * @param request - ModifySceneDefensePolicyRequest
   * @returns ModifySceneDefensePolicyResponse
   */
  async modifySceneDefensePolicy(request: ModifySceneDefensePolicyRequest): Promise<ModifySceneDefensePolicyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifySceneDefensePolicyWithOptions(request, runtime);
  }

  /**
   * Modifies the scheduling rule of Sec-Traffic Manager.
   * 
   * @param request - ModifySchedulerRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifySchedulerRuleResponse
   */
  async modifySchedulerRuleWithOptions(request: ModifySchedulerRuleRequest, runtime: $Util.RuntimeOptions): Promise<ModifySchedulerRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.param)) {
      query["Param"] = request.param;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.ruleName)) {
      query["RuleName"] = request.ruleName;
    }

    if (!Util.isUnset(request.ruleType)) {
      query["RuleType"] = request.ruleType;
    }

    if (!Util.isUnset(request.rules)) {
      query["Rules"] = request.rules;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifySchedulerRule",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifySchedulerRuleResponse>(await this.callApi(params, req, runtime), new ModifySchedulerRuleResponse({}));
  }

  /**
   * Modifies the scheduling rule of Sec-Traffic Manager.
   * 
   * @param request - ModifySchedulerRuleRequest
   * @returns ModifySchedulerRuleResponse
   */
  async modifySchedulerRule(request: ModifySchedulerRuleRequest): Promise<ModifySchedulerRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifySchedulerRuleWithOptions(request, runtime);
  }

  /**
   * Modifies the Transport Layer Security (TLS) policy configuration for the forwarding rule of a website.
   * 
   * @param request - ModifyTlsConfigRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyTlsConfigResponse
   */
  async modifyTlsConfigWithOptions(request: ModifyTlsConfigRequest, runtime: $Util.RuntimeOptions): Promise<ModifyTlsConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.config)) {
      query["Config"] = request.config;
    }

    if (!Util.isUnset(request.domain)) {
      query["Domain"] = request.domain;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyTlsConfig",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyTlsConfigResponse>(await this.callApi(params, req, runtime), new ModifyTlsConfigResponse({}));
  }

  /**
   * Modifies the Transport Layer Security (TLS) policy configuration for the forwarding rule of a website.
   * 
   * @param request - ModifyTlsConfigRequest
   * @returns ModifyTlsConfigResponse
   */
  async modifyTlsConfig(request: ModifyTlsConfigRequest): Promise<ModifyTlsConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyTlsConfigWithOptions(request, runtime);
  }

  /**
   * Changes the mode of the Intelligent Protection policy for a website.
   * 
   * @param request - ModifyWebAIProtectModeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyWebAIProtectModeResponse
   */
  async modifyWebAIProtectModeWithOptions(request: ModifyWebAIProtectModeRequest, runtime: $Util.RuntimeOptions): Promise<ModifyWebAIProtectModeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.config)) {
      query["Config"] = request.config;
    }

    if (!Util.isUnset(request.domain)) {
      query["Domain"] = request.domain;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyWebAIProtectMode",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyWebAIProtectModeResponse>(await this.callApi(params, req, runtime), new ModifyWebAIProtectModeResponse({}));
  }

  /**
   * Changes the mode of the Intelligent Protection policy for a website.
   * 
   * @param request - ModifyWebAIProtectModeRequest
   * @returns ModifyWebAIProtectModeResponse
   */
  async modifyWebAIProtectMode(request: ModifyWebAIProtectModeRequest): Promise<ModifyWebAIProtectModeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyWebAIProtectModeWithOptions(request, runtime);
  }

  /**
   * Enables or disables the Intelligent Protection policy for a website.
   * 
   * @param request - ModifyWebAIProtectSwitchRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyWebAIProtectSwitchResponse
   */
  async modifyWebAIProtectSwitchWithOptions(request: ModifyWebAIProtectSwitchRequest, runtime: $Util.RuntimeOptions): Promise<ModifyWebAIProtectSwitchResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.config)) {
      query["Config"] = request.config;
    }

    if (!Util.isUnset(request.domain)) {
      query["Domain"] = request.domain;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyWebAIProtectSwitch",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyWebAIProtectSwitchResponse>(await this.callApi(params, req, runtime), new ModifyWebAIProtectSwitchResponse({}));
  }

  /**
   * Enables or disables the Intelligent Protection policy for a website.
   * 
   * @param request - ModifyWebAIProtectSwitchRequest
   * @returns ModifyWebAIProtectSwitchResponse
   */
  async modifyWebAIProtectSwitch(request: ModifyWebAIProtectSwitchRequest): Promise<ModifyWebAIProtectSwitchResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyWebAIProtectSwitchWithOptions(request, runtime);
  }

  /**
   * Changes the mode in which a website service is added to Anti-DDoS Pro or Anti-DDoS Premium.
   * 
   * @param request - ModifyWebAccessModeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyWebAccessModeResponse
   */
  async modifyWebAccessModeWithOptions(request: ModifyWebAccessModeRequest, runtime: $Util.RuntimeOptions): Promise<ModifyWebAccessModeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.accessMode)) {
      query["AccessMode"] = request.accessMode;
    }

    if (!Util.isUnset(request.domain)) {
      query["Domain"] = request.domain;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyWebAccessMode",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyWebAccessModeResponse>(await this.callApi(params, req, runtime), new ModifyWebAccessModeResponse({}));
  }

  /**
   * Changes the mode in which a website service is added to Anti-DDoS Pro or Anti-DDoS Premium.
   * 
   * @param request - ModifyWebAccessModeRequest
   * @returns ModifyWebAccessModeResponse
   */
  async modifyWebAccessMode(request: ModifyWebAccessModeRequest): Promise<ModifyWebAccessModeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyWebAccessModeWithOptions(request, runtime);
  }

  /**
   * Modifies the blocked locations that are configured in the Location Blacklist (Domain Names) policy for a website.
   * 
   * @param request - ModifyWebAreaBlockRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyWebAreaBlockResponse
   */
  async modifyWebAreaBlockWithOptions(request: ModifyWebAreaBlockRequest, runtime: $Util.RuntimeOptions): Promise<ModifyWebAreaBlockResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domain)) {
      query["Domain"] = request.domain;
    }

    if (!Util.isUnset(request.regions)) {
      query["Regions"] = request.regions;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyWebAreaBlock",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyWebAreaBlockResponse>(await this.callApi(params, req, runtime), new ModifyWebAreaBlockResponse({}));
  }

  /**
   * Modifies the blocked locations that are configured in the Location Blacklist (Domain Names) policy for a website.
   * 
   * @param request - ModifyWebAreaBlockRequest
   * @returns ModifyWebAreaBlockResponse
   */
  async modifyWebAreaBlock(request: ModifyWebAreaBlockRequest): Promise<ModifyWebAreaBlockResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyWebAreaBlockWithOptions(request, runtime);
  }

  /**
   * Enables or disables the Location Blacklist (Domain Names) policy for a domain name.
   * 
   * @remarks
   * You can call the ModifyWebAreaBlockSwitch operation to enable or disable the Location Blacklist (Domain Names) policy for a domain name.
   * ### Limits
   * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
   * 
   * @param request - ModifyWebAreaBlockSwitchRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyWebAreaBlockSwitchResponse
   */
  async modifyWebAreaBlockSwitchWithOptions(request: ModifyWebAreaBlockSwitchRequest, runtime: $Util.RuntimeOptions): Promise<ModifyWebAreaBlockSwitchResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.config)) {
      query["Config"] = request.config;
    }

    if (!Util.isUnset(request.domain)) {
      query["Domain"] = request.domain;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyWebAreaBlockSwitch",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyWebAreaBlockSwitchResponse>(await this.callApi(params, req, runtime), new ModifyWebAreaBlockSwitchResponse({}));
  }

  /**
   * Enables or disables the Location Blacklist (Domain Names) policy for a domain name.
   * 
   * @remarks
   * You can call the ModifyWebAreaBlockSwitch operation to enable or disable the Location Blacklist (Domain Names) policy for a domain name.
   * ### Limits
   * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
   * 
   * @param request - ModifyWebAreaBlockSwitchRequest
   * @returns ModifyWebAreaBlockSwitchResponse
   */
  async modifyWebAreaBlockSwitch(request: ModifyWebAreaBlockSwitchRequest): Promise<ModifyWebAreaBlockSwitchResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyWebAreaBlockSwitchWithOptions(request, runtime);
  }

  /**
   * Enables or disables the HTTP flood mitigation feature for a website.
   * 
   * @param request - ModifyWebCCGlobalSwitchRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyWebCCGlobalSwitchResponse
   */
  async modifyWebCCGlobalSwitchWithOptions(request: ModifyWebCCGlobalSwitchRequest, runtime: $Util.RuntimeOptions): Promise<ModifyWebCCGlobalSwitchResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ccGlobalSwitch)) {
      query["CcGlobalSwitch"] = request.ccGlobalSwitch;
    }

    if (!Util.isUnset(request.domain)) {
      query["Domain"] = request.domain;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyWebCCGlobalSwitch",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyWebCCGlobalSwitchResponse>(await this.callApi(params, req, runtime), new ModifyWebCCGlobalSwitchResponse({}));
  }

  /**
   * Enables or disables the HTTP flood mitigation feature for a website.
   * 
   * @param request - ModifyWebCCGlobalSwitchRequest
   * @returns ModifyWebCCGlobalSwitchResponse
   */
  async modifyWebCCGlobalSwitch(request: ModifyWebCCGlobalSwitchRequest): Promise<ModifyWebCCGlobalSwitchResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyWebCCGlobalSwitchWithOptions(request, runtime);
  }

  /**
   * Modifies the custom frequency control rule of a website.
   * 
   * @deprecated OpenAPI ModifyWebCCRule is deprecated, please use ddoscoo::2020-01-01::ConfigWebCCRuleV2 instead.
   * 
   * @param request - ModifyWebCCRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyWebCCRuleResponse
   */
  // Deprecated
  async modifyWebCCRuleWithOptions(request: ModifyWebCCRuleRequest, runtime: $Util.RuntimeOptions): Promise<ModifyWebCCRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.act)) {
      query["Act"] = request.act;
    }

    if (!Util.isUnset(request.count)) {
      query["Count"] = request.count;
    }

    if (!Util.isUnset(request.domain)) {
      query["Domain"] = request.domain;
    }

    if (!Util.isUnset(request.interval)) {
      query["Interval"] = request.interval;
    }

    if (!Util.isUnset(request.mode)) {
      query["Mode"] = request.mode;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.ttl)) {
      query["Ttl"] = request.ttl;
    }

    if (!Util.isUnset(request.uri)) {
      query["Uri"] = request.uri;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyWebCCRule",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyWebCCRuleResponse>(await this.callApi(params, req, runtime), new ModifyWebCCRuleResponse({}));
  }

  /**
   * Modifies the custom frequency control rule of a website.
   * 
   * @deprecated OpenAPI ModifyWebCCRule is deprecated, please use ddoscoo::2020-01-01::ConfigWebCCRuleV2 instead.
   * 
   * @param request - ModifyWebCCRuleRequest
   * @returns ModifyWebCCRuleResponse
   */
  // Deprecated
  async modifyWebCCRule(request: ModifyWebCCRuleRequest): Promise<ModifyWebCCRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyWebCCRuleWithOptions(request, runtime);
  }

  /**
   * Modifies the custom rule of the Static Page Caching policy for a website.
   * 
   * @param request - ModifyWebCacheCustomRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyWebCacheCustomRuleResponse
   */
  async modifyWebCacheCustomRuleWithOptions(request: ModifyWebCacheCustomRuleRequest, runtime: $Util.RuntimeOptions): Promise<ModifyWebCacheCustomRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domain)) {
      query["Domain"] = request.domain;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.rules)) {
      query["Rules"] = request.rules;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyWebCacheCustomRule",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyWebCacheCustomRuleResponse>(await this.callApi(params, req, runtime), new ModifyWebCacheCustomRuleResponse({}));
  }

  /**
   * Modifies the custom rule of the Static Page Caching policy for a website.
   * 
   * @param request - ModifyWebCacheCustomRuleRequest
   * @returns ModifyWebCacheCustomRuleResponse
   */
  async modifyWebCacheCustomRule(request: ModifyWebCacheCustomRuleRequest): Promise<ModifyWebCacheCustomRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyWebCacheCustomRuleWithOptions(request, runtime);
  }

  /**
   * Changes the cache mode of the Static Page Caching policy for a website.
   * 
   * @param request - ModifyWebCacheModeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyWebCacheModeResponse
   */
  async modifyWebCacheModeWithOptions(request: ModifyWebCacheModeRequest, runtime: $Util.RuntimeOptions): Promise<ModifyWebCacheModeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domain)) {
      query["Domain"] = request.domain;
    }

    if (!Util.isUnset(request.mode)) {
      query["Mode"] = request.mode;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyWebCacheMode",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyWebCacheModeResponse>(await this.callApi(params, req, runtime), new ModifyWebCacheModeResponse({}));
  }

  /**
   * Changes the cache mode of the Static Page Caching policy for a website.
   * 
   * @param request - ModifyWebCacheModeRequest
   * @returns ModifyWebCacheModeResponse
   */
  async modifyWebCacheMode(request: ModifyWebCacheModeRequest): Promise<ModifyWebCacheModeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyWebCacheModeWithOptions(request, runtime);
  }

  /**
   * Enables or disables the Static Page Caching policy for a website.
   * 
   * @remarks
   * You can call the ModifyWebCacheSwitch operation to enable or disable the Static Page Caching policy for a website.
   * ### Limits
   * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
   * 
   * @param request - ModifyWebCacheSwitchRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyWebCacheSwitchResponse
   */
  async modifyWebCacheSwitchWithOptions(request: ModifyWebCacheSwitchRequest, runtime: $Util.RuntimeOptions): Promise<ModifyWebCacheSwitchResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domain)) {
      query["Domain"] = request.domain;
    }

    if (!Util.isUnset(request.enable)) {
      query["Enable"] = request.enable;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyWebCacheSwitch",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyWebCacheSwitchResponse>(await this.callApi(params, req, runtime), new ModifyWebCacheSwitchResponse({}));
  }

  /**
   * Enables or disables the Static Page Caching policy for a website.
   * 
   * @remarks
   * You can call the ModifyWebCacheSwitch operation to enable or disable the Static Page Caching policy for a website.
   * ### Limits
   * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
   * 
   * @param request - ModifyWebCacheSwitchRequest
   * @returns ModifyWebCacheSwitchResponse
   */
  async modifyWebCacheSwitch(request: ModifyWebCacheSwitchRequest): Promise<ModifyWebCacheSwitchResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyWebCacheSwitchWithOptions(request, runtime);
  }

  /**
   * Enables or disables the Black Lists and White Lists (Domain Names) policy for a domain name.
   * 
   * @param request - ModifyWebIpSetSwitchRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyWebIpSetSwitchResponse
   */
  async modifyWebIpSetSwitchWithOptions(request: ModifyWebIpSetSwitchRequest, runtime: $Util.RuntimeOptions): Promise<ModifyWebIpSetSwitchResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.config)) {
      query["Config"] = request.config;
    }

    if (!Util.isUnset(request.domain)) {
      query["Domain"] = request.domain;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyWebIpSetSwitch",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyWebIpSetSwitchResponse>(await this.callApi(params, req, runtime), new ModifyWebIpSetSwitchResponse({}));
  }

  /**
   * Enables or disables the Black Lists and White Lists (Domain Names) policy for a domain name.
   * 
   * @param request - ModifyWebIpSetSwitchRequest
   * @returns ModifyWebIpSetSwitchResponse
   */
  async modifyWebIpSetSwitch(request: ModifyWebIpSetSwitchRequest): Promise<ModifyWebIpSetSwitchResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyWebIpSetSwitchWithOptions(request, runtime);
  }

  /**
   * Modifies the accurate access control rule of a website.
   * 
   * @param request - ModifyWebPreciseAccessRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyWebPreciseAccessRuleResponse
   */
  async modifyWebPreciseAccessRuleWithOptions(request: ModifyWebPreciseAccessRuleRequest, runtime: $Util.RuntimeOptions): Promise<ModifyWebPreciseAccessRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domain)) {
      query["Domain"] = request.domain;
    }

    if (!Util.isUnset(request.expires)) {
      query["Expires"] = request.expires;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.rules)) {
      query["Rules"] = request.rules;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyWebPreciseAccessRule",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyWebPreciseAccessRuleResponse>(await this.callApi(params, req, runtime), new ModifyWebPreciseAccessRuleResponse({}));
  }

  /**
   * Modifies the accurate access control rule of a website.
   * 
   * @param request - ModifyWebPreciseAccessRuleRequest
   * @returns ModifyWebPreciseAccessRuleResponse
   */
  async modifyWebPreciseAccessRule(request: ModifyWebPreciseAccessRuleRequest): Promise<ModifyWebPreciseAccessRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyWebPreciseAccessRuleWithOptions(request, runtime);
  }

  /**
   * Enables or disables the Accurate Access Control policy for a website.
   * 
   * @param request - ModifyWebPreciseAccessSwitchRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyWebPreciseAccessSwitchResponse
   */
  async modifyWebPreciseAccessSwitchWithOptions(request: ModifyWebPreciseAccessSwitchRequest, runtime: $Util.RuntimeOptions): Promise<ModifyWebPreciseAccessSwitchResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.config)) {
      query["Config"] = request.config;
    }

    if (!Util.isUnset(request.domain)) {
      query["Domain"] = request.domain;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyWebPreciseAccessSwitch",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyWebPreciseAccessSwitchResponse>(await this.callApi(params, req, runtime), new ModifyWebPreciseAccessSwitchResponse({}));
  }

  /**
   * Enables or disables the Accurate Access Control policy for a website.
   * 
   * @param request - ModifyWebPreciseAccessSwitchRequest
   * @returns ModifyWebPreciseAccessSwitchResponse
   */
  async modifyWebPreciseAccessSwitch(request: ModifyWebPreciseAccessSwitchRequest): Promise<ModifyWebPreciseAccessSwitchResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyWebPreciseAccessSwitchWithOptions(request, runtime);
  }

  /**
   * @param request - ModifyWebRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyWebRuleResponse
   */
  async modifyWebRuleWithOptions(request: ModifyWebRuleRequest, runtime: $Util.RuntimeOptions): Promise<ModifyWebRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domain)) {
      query["Domain"] = request.domain;
    }

    if (!Util.isUnset(request.httpsExt)) {
      query["HttpsExt"] = request.httpsExt;
    }

    if (!Util.isUnset(request.instanceIds)) {
      query["InstanceIds"] = request.instanceIds;
    }

    if (!Util.isUnset(request.proxyTypes)) {
      query["ProxyTypes"] = request.proxyTypes;
    }

    if (!Util.isUnset(request.realServers)) {
      query["RealServers"] = request.realServers;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.rsType)) {
      query["RsType"] = request.rsType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyWebRule",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyWebRuleResponse>(await this.callApi(params, req, runtime), new ModifyWebRuleResponse({}));
  }

  /**
   * @param request - ModifyWebRuleRequest
   * @returns ModifyWebRuleResponse
   */
  async modifyWebRule(request: ModifyWebRuleRequest): Promise<ModifyWebRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyWebRuleWithOptions(request, runtime);
  }

  /**
   * The ID of the instance that you want to release.
   * > You can release only expired instances. You can call the [DescribeInstances](https://help.aliyun.com/document_detail/91478.html) operation to query the IDs and expiration status of all instances.
   * 
   * @remarks
   * The ID of the request, which is used to locate and troubleshoot issues.
   * 
   * @param request - ReleaseInstanceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ReleaseInstanceResponse
   */
  async releaseInstanceWithOptions(request: ReleaseInstanceRequest, runtime: $Util.RuntimeOptions): Promise<ReleaseInstanceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ReleaseInstance",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ReleaseInstanceResponse>(await this.callApi(params, req, runtime), new ReleaseInstanceResponse({}));
  }

  /**
   * The ID of the instance that you want to release.
   * > You can release only expired instances. You can call the [DescribeInstances](https://help.aliyun.com/document_detail/91478.html) operation to query the IDs and expiration status of all instances.
   * 
   * @remarks
   * The ID of the request, which is used to locate and troubleshoot issues.
   * 
   * @param request - ReleaseInstanceRequest
   * @returns ReleaseInstanceResponse
   */
  async releaseInstance(request: ReleaseInstanceRequest): Promise<ReleaseInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.releaseInstanceWithOptions(request, runtime);
  }

  /**
   * Switches service traffic to an Anti-DDoS Pro or Anti-DDoS Premium instance for scrubbing or switches service traffic back to the associated cloud resources.
   * 
   * @remarks
   * You can call the SwitchSchedulerRule operation to modify the resources to which service traffic is switched for a scheduling rule. For example, you can switch service traffic to an Anti-DDoS Pro or Anti-DDoS Premium instance for scrubbing or switch the service traffic back to the associated cloud resources.
   * Before you call this operation, you must have created a scheduling rule by calling the [CreateSchedulerRule](https://help.aliyun.com/document_detail/157479.html) operation.
   * ### Limits
   * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
   * 
   * @param request - SwitchSchedulerRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SwitchSchedulerRuleResponse
   */
  async switchSchedulerRuleWithOptions(request: SwitchSchedulerRuleRequest, runtime: $Util.RuntimeOptions): Promise<SwitchSchedulerRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ruleName)) {
      query["RuleName"] = request.ruleName;
    }

    if (!Util.isUnset(request.ruleType)) {
      query["RuleType"] = request.ruleType;
    }

    if (!Util.isUnset(request.switchData)) {
      query["SwitchData"] = request.switchData;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SwitchSchedulerRule",
      version: "2020-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SwitchSchedulerRuleResponse>(await this.callApi(params, req, runtime), new SwitchSchedulerRuleResponse({}));
  }

  /**
   * Switches service traffic to an Anti-DDoS Pro or Anti-DDoS Premium instance for scrubbing or switches service traffic back to the associated cloud resources.
   * 
   * @remarks
   * You can call the SwitchSchedulerRule operation to modify the resources to which service traffic is switched for a scheduling rule. For example, you can switch service traffic to an Anti-DDoS Pro or Anti-DDoS Premium instance for scrubbing or switch the service traffic back to the associated cloud resources.
   * Before you call this operation, you must have created a scheduling rule by calling the [CreateSchedulerRule](https://help.aliyun.com/document_detail/157479.html) operation.
   * ### Limits
   * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
   * 
   * @param request - SwitchSchedulerRuleRequest
   * @returns SwitchSchedulerRuleResponse
   */
  async switchSchedulerRule(request: SwitchSchedulerRuleRequest): Promise<SwitchSchedulerRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.switchSchedulerRuleWithOptions(request, runtime);
  }

}
